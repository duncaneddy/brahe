{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Brahe","text":"<p> Brahe - Practical Astrodynamics </p> <p> </p> <p>Documentation: https://duncaneddy.github.io/brahe/latest</p> <p>Rust Library Reference: https://docs.rs/crate/brahe/latest</p> <p>Source Code: https://github.com/duncaneddy/brahe</p>"},{"location":"index.html#brahe","title":"Brahe","text":"<p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, quick-to-deploy, and easy to build on. The north-star of the development is enabling users to solve meaningful problems quickly and correctly.</p> <p>Brahe is permissively licensed under an MIT License to encourage enable people to use and build on the work without worrying about licensing restrictions. We want people to be able to stop reinventing the astrodynamics wheel because commercial licenses are expensive, or open-source options are hard to use or incomplete.</p> <p>Finally, we also try to make the software library easy to understand and extend. Many astrodynamics libraries are written in a way that makes them hard to read, understand, or modify. Brahe is written in a modern style with an emphasis on code clarity and modularity to make it easier to understand how algorithms are implemented and to make it easier to extend the library to support new use-cases. This also has the added benefit of making it easier to verify and validate the correctness of the implementation.</p> <p>If you do find this useful, please consider starring the repository on GitHub to help increase its visibility. If you're using Brahe for school, research, a commercial endeavour, or flying a mission. I'd love to know about it!</p> <p>If you find a bug, have a feature request, want to contribute, please open an issue or a pull request on the GitHub repository. Contributions are welcome and encouraged! If you see something missing, but don't know how to start contributing, please open an issue and we can discuss it. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p> <p>We hope you find Brahe useful for your work!</p>"},{"location":"index.html#going-further","title":"Going Further","text":"<p>If you want to learn more about how to use the package the documentation is structured in the following way:</p> <ul> <li>Learn: Provides short-form documentation of major concepts of the package.</li> <li>Examples: Provides longer-form examples of how-to examples of accomplish common tasks.</li> <li>Python API Reference: Provides detailed reference documentation of the Python API.</li> <li>Rust API Reference: Provides detailed reference documentation of the Rust API.</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>The project is licensed under the MIT License - see the LICENSE for details.</p> <p>We want to make it easy for people to use and build on the work without worrying about licensing restrictions.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<p>To install the latest release of brahe for Python, simply run:</p> <pre><code>pip install brahe\n</code></pre> <p>You can then import the package in your Python code with:</p> <pre><code>import brahe as bh\n</code></pre> <p>And do something fun like calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>import brahe as bh\n\n# Define the semi-major axis of a low Earth orbit (in meters)\na = bh.constants.R_EARTH + 400e3  # 400 km altitude\n\n# Calculate the orbital period\nT = bh.orbital_period(a)\n\nprint(f\"Orbital Period: {T / 60:.2f} minutes\")\n# Outputs:\n# Orbital Period: 92.56 minutes\n</code></pre> <p>or find the when the ISS will next pass overhead:</p> <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute upcoming passes of the ISS over San Francisco\npasses = bh.location_accesses(\n    bh.PointLocation(-122.4194, 37.7749, 0.0),  # San Francisco\n    bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\"),  # ISS\n    bh.Epoch.now(),\n    bh.Epoch.now() + 24 * 3600.0,  # Next 24 hours\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n)\nprint(f\"Number of passes in next 24 hours: {len(passes)}\")\n# Example Output: Number of passes in next 24 hours: 5\n</code></pre>"},{"location":"index.html#additional-examples","title":"Additional Examples","text":"<p>If you want to see more examples of how to use brahe, here are some additional quick examples. You can find even more with full source code in the Examples section of the documentation.</p>"},{"location":"index.html#python","title":"Python","text":"<p>Working with Time: <pre><code>import brahe as bh\n\n# Create an epoch from a specific date and time\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Print as ISO 8601 string\nprint(f\"Epoch in UTC: {epc.isostring()}\")\n# Output:\n# Epoch in UTC: 2024-01-01T12:00:00Z\n\n# Get the Modified Julian Date (MJD) in different time systems\nmjd_tai = epc.mjd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"MJD in TAI: {mjd_tai}\")\n# Output:\n# MJD in TAI: 60310.50042824074\n\n# Get the time as a Julian Date (JD) in GPS time system\njd_gps = epc.jd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"JD in GPS: {jd_gps}\")\n# Output:\n# JD in GPS: 2460311.000208333\n\n# Take the difference between two epochs in different time systems\nepc2 = bh.Epoch(2024, 1, 2, 13, 30, 0.0, time_system=bh.TimeSystem.GPS)\ndelta_seconds = epc2 - epc\nprint(f\"Difference between epochs in seconds: {delta_seconds}\")\n# Output:\n# Difference between epochs in seconds: 91782.0\n\n# Get the epoch as a string in different time systems\nepc_utc = epc2.to_string_as_time_system(bh.TimeSystem.UTC)\nprint(f\"Epoch in GPS: {epc2}\")\nprint(f\"Epoch in UTC: {epc_utc}\")\n# Outputs:\n# Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n# Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n</code></pre></p> <p>Coordinate Transformations: <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize Earth Orientation Parameter data\nbh.initialize_eop()\n\n# Define orbital elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis in meters (700 km altitude)\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in radians\nraan = 15.0  # Right Ascension of Ascending Node in radians\narg_periapsis = 30.0  # Argument of Periapsis in radians\nmean_anomaly = 45.0  # Mean Anomaly\n\n# Create a state vector from orbital elements\nstate_kep = np.array([a, e, i, raan, arg_periapsis, mean_anomaly])\n\n# Convert Keplerian state to ECI coordinates\nstate_eci = bh.state_osculating_to_cartesian(state_kep, bh.AngleFormat.DEGREES)\nprint(f\"ECI Coordinates: {state_eci}\")\n# Outputs:\n# ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Define a time epoch\nepoch = bh.Epoch(2024, 6, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Convert ECI coordinates to ECEF coordinates at the given epoch\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\nprint(f\"ECEF Coordinates: {state_ecef}\")\n# Outputs:\n# ECEF Coordinates: [ 1.86480173e+05 -2.07022599e+06  6.76081548e+06 -4.53886373e+03 5.77702345e+03  1.89973203e+03]\n\n# Convert back from ECEF to ECI coordinates\nstate_eci_2 = bh.state_ecef_to_eci(epoch, state_ecef)\nprint(f\"Recovered ECI Coordinates: {state_eci_2}\")\n# Outputs:\n# Recovered ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Convert back from ECI to Keplerian elements\nstate_kep_2 = bh.state_cartesian_to_osculating(state_eci_2, bh.AngleFormat.DEGREES)\nprint(f\"Recovered Keplerian Elements: {state_kep_2}\")\n# Outputs:\n# Recovered Keplerian Elements: [7.0781363e+06 1.0000000e-03 9.8700000e+01 1.5000000e+01 3.0000000e+01 4.5000000e+01]\n</code></pre> Propagating an Orbit: <pre><code>import numpy as np\nimport brahe as bh\n\n# Define the initial Keplerian elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis: 700 km altitude\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in degrees\nraan = 15.0  # Right Ascension of Ascending Node in degrees\nargp = 30.0  # Argument of Perigee in degrees\nmean_anomaly = 75.0  # Mean Anomaly at epoch in degrees\n\ninitial_state = np.array([a, e, i, raan, argp, mean_anomaly])\n\n# Define the epoch time\nepoch = bh.Epoch.now()\n\n# Create the Keplerian Orbit Propagator\ndt = 60.0  # Time step in seconds\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, initial_state, bh.AngleFormat.DEGREES, dt\n)\n\n# Propagate the orbit for 3 time steps\npropagator.propagate_steps(3)\n\n# States are stored as a Trajectory object\nassert len(propagator.trajectory) == 4  # Initial state + 3 propagated states\n\n# Convert trajectory to ECI coordinates\neci_trajectory = propagator.trajectory.to_eci()\n\n# Iterate over all stored states\nfor epoch, state in eci_trajectory:\n    print(\n        f\"Epoch: {epoch}, Position (ECI): {state[0] / 1e3:.2f} km, {state[1] / 1e3:.2f} km, {state[2] / 1e3:.2f} km\"\n    )\n\n# Output:\n# Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n# Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n# Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n# Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n# Propagate for 7 days\nend_epoch = epoch + 86400 * 7  # 7 days later\npropagator.propagate_to(end_epoch)\n\n# Confirm the final epoch is as expected\nassert abs(propagator.current_epoch - end_epoch) &lt; 1e-6\nprint(\"Propagation complete. Final epoch:\", propagator.current_epoch)\n# Output:\n# Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>import brahe as bh\n\n# Initialize EOP\nbh.initialize_eop()\n\n# Set the location\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\n\n# Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\npropagator = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n\n# Configure Search Window\nepoch_start = bh.Epoch.now()\nepoch_end = epoch_start + 7 * 86400.0  # 7 days later\n\n# Set access constraints -&gt; Must be above 10 degrees elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(location, propagator, epoch_start, epoch_end, constraint)\n\nassert len(windows) &gt; 0, \"Should find at least one access window\"\n\n# Print first 3 access windows\nfor window in windows[:3]:\n    print(\n        f\"Access Window: {window.window_open} to {window.window_close}, Duration: {window.duration / 60:.2f} minutes\"\n    )\n# Outputs:\n# Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n# Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n# Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n</code></pre></p>"},{"location":"index.html#rust","title":"Rust","text":"<p>To use brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre> <p>You can then use the crate in your rust code with:</p> <pre><code>use brahe as bh;\n</code></pre> <p>And still calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>use brahe::{R_EARTH, orbital_period};\n\nfn main() {\n    // Define the semi-major axis of a low Earth orbit (in meters)\n    let semi_major_axis = R_EARTH + 400e3; // 400 km altitude\n\n    // Calculate the orbital period\n    let period = orbital_period(semi_major_axis); \n\n    println!(\"Orbital Period: {:.2} minutes\", period / 60.0);\n    // Outputs:\n    // Orbital Period: 92.56 minutes\n}\n</code></pre> <p>You can do everything that you can do in Python in Rust as well:</p> <p>Working with Time: <pre><code>use brahe::{Epoch, TimeSystem};\n\nfn main() {\n    // Create an epoch from a specific date and time\n    let epc = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Print as ISO 8601 string\n    println!(\"Epoch in UTC: {}\", epc.isostring());\n    // Output:\n    // Epoch in UTC: 2024-01-01T12:00:00Z\n\n    // Get the Modified Julian Date (MJD) in different time systems\n    let mjd_tai = epc.mjd_as_time_system(TimeSystem::TAI);\n    println!(\"MJD in TAI: {}\", mjd_tai);\n    // Output:\n    // MJD in TAI: 60310.50042824074\n\n    // Get the time as a Julian Date (JD) in GPS time system\n    let jd_gps = epc.jd_as_time_system(TimeSystem::GPS);\n    println!(\"JD in GPS: {}\", jd_gps);\n    // Output:\n    // JD in GPS: 2460311.000208333\n\n    // Take the difference between two epochs in different time systems\n    let epc2 = Epoch::from_datetime(2024, 1, 2, 13, 30, 0.0, 0.0, TimeSystem::GPS);\n    let delta_seconds = epc2 - epc;\n    println!(\"Difference between epochs in seconds: {}\", delta_seconds);\n    // Output:\n    // Difference between epochs in seconds: 91782.0\n\n    // Get the epoch as a string in different time systems\n    let epc_utc = epc2.to_string_as_time_system(TimeSystem::UTC);\n    println!(\"Epoch in GPS: {}\", epc2);\n    println!(\"Epoch in UTC: {}\", epc_utc);\n    // Outputs:\n    // Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n    // Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n}\n</code></pre></p> <p>Coordinate Transformations: <pre><code>use brahe as bh;\nuse brahe::{Epoch, TimeSystem, R_EARTH, state_osculating_to_cartesian,\n            state_eci_to_ecef, state_ecef_to_eci, state_cartesian_to_osculating, AngleFormat};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements\n    let a = R_EARTH + 700e3;    // Semi-major axis in meters (700 km altitude)\n    let e = 0.001;              // Eccentricity\n    let i = 98.7;               // Inclination in degrees\n    let raan = 15.0;            // Right Ascension of Ascending Node in degrees\n    let arg_periapsis = 30.0;   // Argument of Periapsis in degrees\n    let mean_anomaly = 45.0;    // Mean Anomaly in degrees\n\n    // Create a state vector from orbital elements\n    let state_kep = Vector6::new(a, e, i, raan, arg_periapsis, mean_anomaly);\n\n    // Convert Keplerian state to ECI coordinates\n    let state_eci = state_osculating_to_cartesian(state_kep, AngleFormat::Degrees);\n    println!(\"ECI Coordinates: {:?}\", state_eci);\n    // Outputs:\n    // ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Define a time epoch\n    let epoch = Epoch::from_datetime(2024, 6, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Convert ECI coordinates to ECEF coordinates at the given epoch\n    let state_ecef = state_eci_to_ecef(epoch, state_eci);\n    println!(\"ECEF Coordinates: {:?}\", state_ecef);\n    // Outputs:\n    // ECEF Coordinates: [186480.17260881448, -2070225.9929370368, 6760815.482882127, -4538.863726757974, 5777.023453395301, 1899.7320274086795]\n\n    // Convert back from ECEF to ECI coordinates\n    let state_eci_2 = state_ecef_to_eci(epoch, state_ecef);\n    println!(\"Recovered ECI Coordinates: {:?}\", state_eci_2);\n    // Outputs:\n    // Recovered ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Convert back from ECI to Keplerian elements\n    let state_kep_2 = state_cartesian_to_osculating(state_eci_2, AngleFormat::Degrees);\n    println!(\"Recovered Keplerian Elements: {:?}\", state_kep_2);\n    // Outputs:\n    // Recovered Keplerian Elements: [7078136.3, 0.001, 98.7, 15.0, 30.0, 45.0]\n}\n</code></pre></p> <p>Propagating an Orbit: <pre><code>use brahe as bh;\nuse brahe::{Epoch, R_EARTH, KeplerianPropagator, AngleFormat};\nuse brahe::traits::{OrbitPropagator, OrbitalTrajectory, Trajectory};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Define the initial Keplerian elements\n    let a = R_EARTH + 700e3;  // Semi-major axis: 700 km altitude\n    let e = 0.001;            // Eccentricity\n    let i = 98.7;             // Inclination in degrees\n    let raan = 15.0;          // Right Ascension of Ascending Node in degrees\n    let argp = 30.0;          // Argument of Perigee in degrees\n    let mean_anomaly = 75.0;  // Mean Anomaly at epoch in degrees\n\n    let initial_state = Vector6::new(a, e, i, raan, argp, mean_anomaly);\n\n    // Define the epoch time\n    let epoch = Epoch::now();\n\n    // Create the Keplerian Orbit Propagator\n    let dt = 60.0;  // Time step in seconds\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch,\n        initial_state,\n        AngleFormat::Degrees,\n        dt\n    );\n\n    // Propagate the orbit for 3 time steps\n    propagator.propagate_steps(3);\n\n    // States are stored as a Trajectory object\n    assert_eq!(propagator.trajectory.len(), 4);  // Initial state + 3 propagated states\n\n    // Convert trajectory to ECI coordinates\n    let eci_trajectory = propagator.trajectory.to_eci();\n\n    // Iterate over all stored states\n    for i in 0..eci_trajectory.len() {\n        let epoch = eci_trajectory.epochs[i];\n        let state = eci_trajectory.states[i];\n        println!(\n            \"Epoch: {}, Position (ECI): {:.2} km, {:.2} km, {:.2} km\",\n            epoch,\n            state[0] / 1e3,\n            state[1] / 1e3,\n            state[2] / 1e3\n        );\n    }\n    // Output (will vary based on current time):\n    // Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n    // Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n    // Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n    // Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n    // Propagate for 7 days\n    let end_epoch = epoch + 86400.0 * 7.0;  // 7 days later\n    propagator.propagate_to(end_epoch);\n\n    // Confirm the final epoch is close to expected time\n    let time_diff = (propagator.current_epoch() - end_epoch).abs();\n    assert!(time_diff &lt; 1.0e-6, \"Final epoch should be within 1 second of target\");\n    println!(\"Propagation complete. Final epoch: {}\", propagator.current_epoch());\n    // Output (will vary based on current time):\n    // Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n}\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>use brahe as bh;\nuse brahe::{Epoch, PointLocation, ElevationConstraint, location_accesses};\nuse brahe::datasets::celestrak::get_tle_by_id_as_propagator;\nuse brahe::utils::Identifiable;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Set the location\n    let location = PointLocation::new(-122.4194, 37.7749, 0.0)\n        .with_name(\"San Francisco\");\n\n    // Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\n    let propagator = get_tle_by_id_as_propagator(25544, None, 60.0).unwrap();\n\n    // Configure Search Window\n    let epoch_start = Epoch::now();\n    let epoch_end = epoch_start + 7.0 * 86400.0;  // 7 days later\n\n    // Set access constraints -&gt; Must be above 10 degrees elevation\n    let constraint = ElevationConstraint::new(Some(10.0), None).unwrap();\n\n    // Compute access windows\n    let windows = location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None\n    ).unwrap();\n\n    assert!(!windows.is_empty(), \"Should find at least one access window\");\n\n    // Print first 3 access windows\n    for window in windows.iter().take(3) {\n        println!(\n            \"Access Window: {} to {}, Duration: {:.2} minutes\",\n            window.window_open,\n            window.window_close,\n            window.duration() / 60.0\n        );\n    }\n    // Outputs (will vary based on current time and ISS orbit):\n    // Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n    // Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n    // Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n}\n</code></pre></p>"},{"location":"changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"changelog.html#added","title":"Added","text":""},{"location":"changelog.html#changed","title":"Changed","text":""},{"location":"changelog.html#deprecated","title":"Deprecated","text":""},{"location":"changelog.html#removed","title":"Removed","text":""},{"location":"changelog.html#fixed","title":"Fixed","text":""},{"location":"changelog.html#security","title":"Security","text":""},{"location":"code_of_conduct.html","title":"Contributor Covenant 3.0 Code of Conduct","text":""},{"location":"code_of_conduct.html#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>Space has inspired us and continues to inspire the whole world. We are building software to help everyone on this planet explore the universe - regardless of race, creed, or any other distinction. We encourage you to bring your unique perspective to help make us stronger, including those who are traditionally underrepresented in tech. We seek to build a highly collaborative, respectful, inclusive, and curious community. We appreciate contributions from everyone, no prior space experience is needed to participate. We joyously welcome everyone who is excited about tackling seemingly impossible challenges, learning new skills and concepts, and helping each other achieve success.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"code_of_conduct.html#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"code_of_conduct.html#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, directly contact the repository owner, maintainers, or community moderators at: <code>duncan [send-email-symbol] argoinnovations.com</code>.</p> <p>We take reports of violations seriously and will make every effort to respond in a timely manner. We will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. We prioritize safety and confidentiality, while also trying to keep enforcement actions as transparent as possible. In order to honor these values, enforcement actions are carried out in private with the involved parties, but reserve the right to publicly share the outcome of enforcement actions when appropriate for the safety and well-being of the community as a whole.</p>"},{"location":"code_of_conduct.html#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"code_of_conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p>"},{"location":"contributing.html","title":"Contributing to Brahe","text":"<p>Thank you for your interest in contributing to Brahe! We welcome contributions from everyone\u2014whether you're improving documentation, fixing bugs, or adding new features. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p> <p>Checkout the main documentation for the Contributing Guidelines and Code of Conduct.</p>"},{"location":"contributing.html#how-you-can-contribute","title":"How you can contribute","text":"<p>You can contribute in many ways, including: - Reporting bugs or issues. - Suggesting enhancements or new features. - Writing or improving documentation or tutorials. - Adding or improving tests. - Reviewing other contributors\u2019 pull requests.</p>"},{"location":"contributing.html#getting-started","title":"Getting Started","text":"<p>First, check out the development guidelines in the developer guidelines for setting up your development environment, running tests, and the development workflow for implementing new features or fixing bugs.</p>"},{"location":"contributing.html#workflow","title":"Workflow","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally: <code>git clone https://github.com/YOUR_USERNAME/brahe.git</code></li> <li>Create a new branch for your changes: <code>git checkout -b feature/your-feature-name</code></li> <li>Make your changes and commit them with clear, descriptive messages.</li> <li>Push your changes to your fork: <code>git push origin feature/your-feature-name</code></li> <li>Open a pull request against the main branch of the upstream repository.</li> <li>A maintainer will review your contribution; you may be asked to make changes.</li> <li>After approval and CI passing, your pull request will be merged.</li> </ol>"},{"location":"contributing.html#code-style-testing","title":"Code Style &amp; Testing","text":"<ul> <li>Follow the project\u2019s style guidelines (e.g., linting, formatting).</li> <li>Include tests for new functionality, and ensure existing tests pass.</li> <li>Ensure that your changes do not break existing behaviour unless they are intentional, documented, well-motivated, complete, and reviewed. We don't break things without a solution.</li> </ul>"},{"location":"contributing.html#communication-etiquette","title":"Communication &amp; Etiquette","text":"<ul> <li>Please review the Code of Conduct to understand the expected behaviour in our community.</li> <li>If you\u2019re planning a large or complex change, consider opening an issue first to discuss design and get early feedback.</li> <li>Be responsive to review comments. If you need time, it\u2019s okay to say so.</li> <li>Respect the maintainers\u2019 decision. If they decline your change, you\u2019re free to discuss politely or move on.</li> </ul>"},{"location":"contributing.html#license-rights","title":"License &amp; Rights","text":"<p>By submitting a pull request, you agree that your contribution will be available under the project's MIT License and you grant the maintainers the right to apply any necessary changes (e.g., rebase, squash) before merging.</p>"},{"location":"contributing.html#thank-you","title":"Thank You","text":"<p>We appreciate your interest and contribution. Together we build something better!</p>"},{"location":"design.html","title":"Design Philosophy &amp; Decisions","text":"<p>This page documents significant design decisions of the library. Right now this is mostly just what I think is \"good design\" for an astrodynamics library, which is highly subjective and somewhat hard to write down concretely. Over time I hope to expand this page to include more specific design decisions made in the library, along with the reasoning behind them.</p>"},{"location":"design.html#rust-core-with-python-bindings","title":"Rust Core with Python Bindings","text":"<p>The core of the library is implemented in Rust for performance and safety, with Python bindings provided for ease of use and accessibility to the Python community. This design choice allows us to leverage Rust's strengths while still providing a user-friendly interface in Python. Providing Python bindings also opens the library to a wider audience, as Python is a popular language in the scientific and engineering communities.</p>"},{"location":"design.html#tightly-coupled-documentation","title":"Tightly Coupled Documentation","text":"<p>The documentation is designed to be tightly coupled with the codebase, ensuring that users have access to up-to-date and relevant information. This is achieved by organizing the documentation in a way that mirrors the structure of the code, and automatically testing code examples within the documentation to ensure sure that documentation cannot be released without it working. This approach helps maintain consistency between the library's functionality and its documentation, making it easier for users to understand and utilize the library effectively.</p>"},{"location":"design.html#earth-centered-focus","title":"Earth-Centered Focus","text":"<p>Currently the library is focused on Earth-centered applications, while extending to other celestial bodies is not ruled out in the future, they are not a design priority. This choice has enabled us to optimize the design of the library API by dropping support for multiple central bodies, simplifying the user experience for the primary use case.</p>"},{"location":"development_guidelines.html","title":"Development Guidelines","text":""},{"location":"development_guidelines.html#development-workflow","title":"Development Workflow","text":"<p>For all development we recommend using uv to manage your environment. The guidelines for contributing, developing, and extending brahe assume you are using uv.</p>"},{"location":"development_guidelines.html#setting-up-your-environment","title":"Setting up your environment","text":"<p>If you need to setup the development environment, including installing the necessary development dependencies.</p> <p>First, you need to install Rust from rustup.rs.</p> <p>Then you can install the nightly toolchain with:</p> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <p>After this you can now setup your python environment with:</p> <pre><code>uv sync --dev\n</code></pre> <p>Finally, you can install the pre-commit hooks with:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"development_guidelines.html#testing","title":"Testing","text":"<p>The package includes Rust tests, Python tests, and documentation example tests.</p> <p>Run all tests: <pre><code>make test\n</code></pre></p> <p>Individual test suites: <pre><code>make test-rust          # Rust tests only\nmake test-python        # Python tests only\nmake test-examples      # Documentation examples (warn on parity issues)\n</code></pre></p> <p>Pre-ship validation (runs all tests, formatters, linters, and doc builds): <pre><code>make ship-tests\n</code></pre></p>"},{"location":"development_guidelines.html#development-workflow-implementing-a-new-feature","title":"Development Workflow: Implementing a New Feature","text":"<p>When adding new functionality to Brahe, follow this sequence:</p> <p>1. Rust Implementation - Implement functionality in the appropriate module under <code>src/</code> - Use SI base units (meters, radians, seconds) in all public APIs - Follow existing patterns and naming conventions</p> <p>2. Rust Tests - Write comprehensive unit tests in the same file (in <code>#[cfg(test)] mod tests</code>) - Test edge cases and typical use cases - Run: <code>cargo test</code> - Ensure all tests pass before proceeding</p> <p>3. Python Bindings - Create 1:1 Python bindings in <code>src/pymodule/</code> - Use identical function names and parameter names as Rust - Add complete Google-style docstrings with Args, Returns, Examples - Export new classes in <code>src/pymodule/mod.rs</code> - Export in Python package (<code>brahe/*.py</code> files) - Reinstall: <code>uv pip install -e .</code></p> <p>4. Python Tests - Write Python tests that mirror Rust tests in <code>tests/</code> - Follow the same test structure and assertions - Run: <code>uv run pytest tests/ -v</code></p> <p>5. Documentation Examples - Create standalone example files in <code>examples/&lt;module&gt;/</code> - Create both Python and Rust versions (see templates below) - Test: <code>make test-examples</code></p> <p>6. Documentation - Update or create documentation in <code>docs/</code> - Reference examples using snippet includes (see template below) - Build: <code>make build-docs</code> - Preview: <code>make serve-docs</code></p> <p>7. Quality Checks <pre><code>make format      # Auto-format code\nmake lint        # Check for issues\nmake ship-tests  # Full validation\n</code></pre></p>"},{"location":"development_guidelines.html#rust-standards-and-guidelines","title":"Rust Standards and Guidelines","text":""},{"location":"development_guidelines.html#rust-testing-conventions","title":"Rust Testing Conventions","text":"<p>New functions implemented in rust are expected to have unit tests and documentation tests. Unit tests should cover all edge cases and typical use cases for the function. Documentation tests should provide examples of how to use the function.</p> <p>Unit tests should be placed in the same file as the function they are testing, in a module named <code>tests</code>. The names of tests should follow the general convention of <code>test_&lt;struct&gt;_&lt;trait&gt;_&lt;method&gt;_&lt;case&gt;</code> or <code>test_&lt;function&gt;_&lt;case&gt;</code>.</p>"},{"location":"development_guidelines.html#rust-docstring-template","title":"Rust Docstring Template","text":"<p>New functions implemented in rust are expected to use the following docstring to standardize information on functions to enable users to more easily navigate and learn the library.</p> <pre><code>{{ Function Description }}\n\n## Arguments\n\n* `argument_name`: {{ Arugment description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Returns\n\n* `value_name`: {{ Value description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Examples\n\\`\\`\\`\n{{ Implement shor function in language }}\n\\`\\`\\`\n\n## References:\n1. {{ author, *title/journal*, pp. page_number, eq. equation_number, year}}\n2. O. Montenbruck, and E. Gill, *Satellite Orbits: Models, Methods and Applications*, pp. 24, eq. 2.43 &amp; 2.44, 2012.\n</code></pre>"},{"location":"development_guidelines.html#python-standards-and-guidelines","title":"Python Standards and Guidelines","text":""},{"location":"development_guidelines.html#python-testing-conventions","title":"Python Testing Conventions","text":"<p>Python tests should be placed in the <code>tests</code> directory. The test structure and names should mirror the structure of the <code>brahe</code> package. For example, tests for <code>brahe.orbits.keplerian</code> should be placed in <code>tests/orbits/test_keplerian.py</code>.</p> <p>All Python tests should be exact mirrors of the Rust tests, ensuring that both implementations are equivalent and consistent. There are a few exceptions to this rule, such as tests that check for Python-specific functionality or behavior, or capabilities that are not possible to reproduce in Python due to language limitations.</p>"},{"location":"development_guidelines.html#documentation-examples","title":"Documentation Examples","text":"<p>Documentation examples are standalone executable files that demonstrate library functionality. Every example must exist in both Python and Rust versions to ensure API parity.</p>"},{"location":"development_guidelines.html#example-file-structure","title":"Example File Structure","text":"<p>Examples are organized by module in <code>examples/</code>: <pre><code>examples/\n\u251c\u2500\u2500 time/           # Time system examples\n\u251c\u2500\u2500 orbits/         # Orbital mechanics examples\n\u251c\u2500\u2500 coordinates/    # Coordinate transformation examples\n\u251c\u2500\u2500 frames/         # Reference frame examples\n\u251c\u2500\u2500 attitude/       # Attitude representation examples\n\u251c\u2500\u2500 eop/            # Earth orientation parameter examples\n\u251c\u2500\u2500 trajectories/   # Trajectory examples\n\u2514\u2500\u2500 workflows/      # Complete workflow examples\n</code></pre></p>"},{"location":"development_guidelines.html#naming-convention","title":"Naming Convention","text":"<p>Example files should follow this pattern: <pre><code>&lt;module&gt;_&lt;functionality&gt;_&lt;description&gt;.{py,rs}\n</code></pre></p> <p>Examples: - <code>time_epoch_creation.py</code> / <code>time_epoch_creation.rs</code> - <code>orbits_keplerian_conversion.py</code> / <code>orbits_keplerian_conversion.rs</code> - <code>coordinates_geodetic_transform.py</code> / <code>coordinates_geodetic_transform.rs</code></p>"},{"location":"development_guidelines.html#python-example-template","title":"Python Example Template","text":"<p>See <code>examples/TEMPLATE.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"pytest\"]\n# ///\n\"\"\"\nBrief description of what this example demonstrates.\n\"\"\"\nimport brahe as bh\nimport pytest\n\nif __name__ == '__main__':\n    # Setup: Define any input parameters\n    value = 1.0\n\n    # Action: Demonstrate the functionality\n    result = value * 2.0  # Replace with actual brahe function call\n\n    # Validation: Assert the result is correct\n    expected = 2.0\n    assert result == pytest.approx(expected, abs=1e-10)\n\n    print(\"\u2713 Example validated successfully!\")\n</code></pre> <p>Note: The <code># /// script</code> header makes this a uv script, allowing it to be run standalone with <code>uv run example.py</code>.</p>"},{"location":"development_guidelines.html#rust-example-template","title":"Rust Example Template","text":"<p>See <code>examples/TEMPLATE.rs</code>:</p> <pre><code>//! Brief description of what this example demonstrates.\n\nuse approx::assert_abs_diff_eq;\nuse brahe::time::{Epoch, TimeSystem};\n\nfn main() {\n    // Setup: Define any input parameters\n    let value = 1.0;\n\n    // Action: Demonstrate the functionality\n    let result = value * 2.0; // Replace with actual brahe function call\n\n    // Validation: Assert the result is correct\n    let expected = 2.0;\n    assert_abs_diff_eq!(result, expected, epsilon = 1e-10);\n\n    println!(\"\u2713 Example validated successfully!\");\n}\n</code></pre>"},{"location":"development_guidelines.html#testing-examples","title":"Testing Examples","text":"<p>Test examples locally: <pre><code>uv run make.py test-examples\n</code></pre></p> <p>The build system will: 1. Execute all <code>.rs</code> files via <code>rust-script</code> 2. Execute all <code>.py</code> files via <code>uv run python</code> 3. Verify every <code>.rs</code> has a matching <code>.py</code> (and vice versa) 4. Report pass/fail for each example</p>"},{"location":"development_guidelines.html#including-examples-in-documentation","title":"Including Examples in Documentation","text":"<p>Use the <code>pymdownx.snippets</code> directive to include examples in markdown files. See the snippets plugin documentation for additional details on usage.</p> <pre><code>## Example: Creating Epochs\n\n=== \"Python\"\n\n    ``` python\n    ```\n\n=== \"Rust\"\n\n    ``` rust\n    ```\n</code></pre> <p>This will: - Create tabbed interface with Python shown first - Include the actual file contents (always in sync) - Automatically update when examples change</p>"},{"location":"development_guidelines.html#documentation-plots","title":"Documentation Plots","text":"<p>Interactive plots are generated from Python scripts in <code>plots/</code> and embedded in documentation.</p>"},{"location":"development_guidelines.html#plot-naming-convention","title":"Plot Naming Convention","text":"<p>Plot files should follow this pattern: <pre><code>fig_&lt;description&gt;.py\n</code></pre></p> <p>Examples: - <code>fig_time_system_offsets.py</code> - <code>fig_orbital_period.py</code> - <code>fig_anomaly_conversions.py</code></p>"},{"location":"development_guidelines.html#plot-template","title":"Plot Template","text":"<p>See <code>plots/TEMPLATE_plot.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# ///\n\"\"\"\nBrief description of what this plot visualizes.\n\"\"\"\nimport os\nimport pathlib\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport brahe as bh\nimport numpy as np\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\")\nOUTFILE = f\"{OUTDIR}/{SCRIPT_NAME}.html\"\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Replace with actual data\n\n# Create figure\nfig = go.Figure()\nfig.update_layout(\n    title=\"Plot Title\",\n    xaxis_title=\"X Axis Label\",\n    yaxis_title=\"Y Axis Label\",\n    paper_bgcolor='rgba(0,0,0,0)',  # Transparent for dark mode\n    plot_bgcolor='rgba(0,0,0,0)'\n)\n\n# Add traces\nfig.add_trace(go.Scatter(x=x, y=y, name=\"Data\", mode='lines'))\n\n# Write HTML (partial, not full page)\npio.write_html(\n    fig,\n    file=OUTFILE,\n    include_plotlyjs='cdn',\n    full_html=False,\n    auto_play=False\n)\n\nprint(f\"\u2713 Generated {OUTFILE}\")\n</code></pre> <p>Note: The <code># /// script</code> header allows standalone execution with <code>uv run fig_plot.py</code>.</p>"},{"location":"development_guidelines.html#generating-plots","title":"Generating Plots","text":"<p>Generate all plots: <pre><code>uv run make.py make-plots\n</code></pre></p> <p>Plots are written to <code>docs/figures/</code> as partial HTML files for embedding.</p>"},{"location":"development_guidelines.html#including-plots-in-documentation","title":"Including Plots in Documentation","text":"<pre><code>## Time System Offsets\n\nThe following plot shows time system offsets from UTC:\n\n\n??? \"Plot Source\"\n\n    ``` python title=\"fig_time_system_offsets.py\"\n    ```\n</code></pre> <p>This will: - Embed the interactive Plotly plot - Add a collapsible section showing the source code</p>"},{"location":"development_guidelines.html#pull-request-changelog","title":"Pull Request Changelog","text":""},{"location":"development_guidelines.html#automatic-changelog-generation","title":"Automatic Changelog Generation","text":"<p>When you create a pull request, you must fill in the changelog section in the PR description. The changelog uses Keep a Changelog format with four categories:</p> <ul> <li>Added - New features</li> <li>Changed - Changes to existing functionality</li> <li>Fixed - Bug fixes</li> <li>Removed - Removed features or functionality</li> </ul>"},{"location":"development_guidelines.html#how-it-works","title":"How It Works","text":"<ol> <li> <p>Fill in PR description: When opening a PR, add entries under the appropriate changelog section(s)    <pre><code>### Fixed\n- Fixed memory leak in trajectory interpolation\n- Corrected EOP data loading for edge cases\n</code></pre></p> </li> <li> <p>Validation: A GitHub Action checks that at least one changelog section has entries</p> </li> <li>PR will fail validation if all sections are empty</li> <li> <p>You'll receive a comment with instructions if validation fails</p> </li> <li> <p>Automatic fragment creation: When the PR is merged:</p> </li> <li>A GitHub Action parses your changelog entries</li> <li>Creates fragment files in <code>news/</code> directory (e.g., <code>123.added.md</code>, <code>123.fixed.md</code>)</li> <li> <p>Commits the fragments to the main branch</p> </li> <li> <p>Release compilation: During release:</p> </li> <li>Towncrier collects all fragments from <code>news/</code></li> <li>Generates formatted release notes</li> <li>Updates <code>CHANGELOG.md</code> with the new version section</li> <li>Deletes fragment files</li> </ol>"},{"location":"development_guidelines.html#example-pr-changelog","title":"Example PR Changelog","text":"<pre><code>## Changelog\n\n### Added\n- Support for new SGP4 propagation mode\n- EOP data caching to improve performance\n\n### Fixed\n- Memory leak in trajectory interpolation\n- Edge case in geodetic coordinate conversion\n</code></pre> <p>This will automatically create: - <code>news/123.added.md</code> with both Added items - <code>news/123.fixed.md</code> with both Fixed items</p>"},{"location":"development_guidelines.html#manual-fragment-creation-rare","title":"Manual Fragment Creation (Rare)","text":"<p>In rare cases where you need to create fragments manually, see <code>news/README.md</code> for instructions. Fragment files use the format <code>&lt;PR#&gt;.&lt;type&gt;.md</code> where type is one of: <code>added</code>, <code>changed</code>, <code>fixed</code>, <code>removed</code>.</p>"},{"location":"development_guidelines.html#previewing-the-changelog","title":"Previewing the Changelog","text":"<p>To see what changelog fragments are currently queued:</p> <pre><code># List all fragment files\nls -la news/*.md\n\n# Or see just the fragment names\nfind news/ -name '*.md' ! -name '.template.md' ! -name 'README.md'\n</code></pre> <p>To see what the next release changelog would look like without making changes:</p> <pre><code># Preview the changelog for the next release\nuv run towncrier build --version 1.2.3 --draft\n</code></pre> <p>This shows the formatted output without modifying <code>CHANGELOG.md</code> or deleting fragments.</p>"},{"location":"development_guidelines.html#releases-without-changelog-fragments","title":"Releases Without Changelog Fragments","text":"<p>If you create a release when there are no changelog fragments in <code>news/</code>:</p> <ul> <li>The release workflow will succeed</li> <li>A minimal release will be created with \"No significant changes\"</li> <li>This is useful for releases that only contain dependency updates or internal changes</li> </ul>"},{"location":"development_guidelines.html#release-process","title":"Release Process","text":""},{"location":"development_guidelines.html#initiating-a-release","title":"Initiating a Release","text":"<p>Before creating a release:</p> <ol> <li> <p>Update version in <code>Cargo.toml</code>:    <pre><code># Edit version in Cargo.toml\nvim Cargo.toml  # Update version = \"1.2.3\"\n</code></pre></p> </li> <li> <p>Run quality checks:    <pre><code>ruff check &amp;&amp; cargo fmt -- --check &amp;&amp; cargo test &amp;&amp; uv pip install -e \".[all]\" &amp;&amp; uv run pytest &amp;&amp; uv run make.py test-examples &amp;&amp; uv run make.py make-plots &amp;&amp; uv run mkdocs build --strict\n</code></pre></p> </li> <li> <p>Push version tag:    <pre><code>git add Cargo.toml\ngit commit -m \"Prepare release v1.2.3\"\ngit push origin main\ngit tag v1.2.3\ngit push origin v1.2.3\n</code></pre></p> </li> </ol>"},{"location":"development_guidelines.html#automated-workflow","title":"Automated Workflow","text":"<p>Note: Changelog fragments are automatically created from PR descriptions. You don't need to manually create fragment files.</p> <p>Once the tag is pushed, GitHub Actions automatically:</p> <ol> <li>Validates version matches between tag and <code>Cargo.toml</code></li> <li>Runs all tests (Rust, Python, examples)</li> <li>Generates release notes with towncrier (commits CHANGELOG.md)</li> <li>Builds documentation and deploys to GitHub Pages</li> <li>Builds Python wheels and source distribution</li> <li>Publishes to PyPI and crates.io</li> <li>Creates draft GitHub Release with artifacts and release notes</li> <li>Updates \"latest\" tag and release</li> </ol>"},{"location":"development_guidelines.html#completing-the-release","title":"Completing the Release","text":"<p>After automation completes:</p> <ol> <li>Review draft release at <code>https://github.com/duncaneddy/brahe/releases</code></li> <li>Edit release notes (optional):</li> <li>Add highlights or breaking changes</li> <li>Include migration notes if needed</li> <li>Publish release by clicking \"Publish release\"</li> </ol>"},{"location":"development_guidelines.html#verification","title":"Verification","text":"<p>After publishing, verify:</p> <ul> <li>PyPI: https://pypi.org/project/brahe/</li> <li>Crates.io: https://crates.io/crates/brahe</li> <li>Docs: https://duncaneddy.github.io/brahe/latest/</li> <li>GitHub: https://github.com/duncaneddy/brahe/releases</li> </ul>"},{"location":"glossary.html","title":"Glossary","text":"<p>This glossary is meant to provide definitions of common terms. The documentation  attempts to provide introductions to potentially new terminology as encountered, but users may read the documentation in any order therefore this glossary serves as a reference.</p> <p>If there are terms you believe should be included in this glossary, please open an issue or submit a pull request.</p> Term Definition Aphelion Furthest point away for a Sun-orbiting object from the Sun. Apoapsis Furthest point away for an orbiting object from its orbital focus. Apogee Furthest point away for a Earth-orbiting object from the Earth. Earth-Centered Earth-Fixed (ECEF) A rotating reference frame with its coordinate origin at the center of the Earth. Reference frame rotates with Earth's crustal (surface) Earth-Centered Inertial (ECI) An inertial reference frame or system with its coordinate origin at the Earth's center of mass. In an inertial reference frame Newtwon's Laws are applicable, meaning that no corrections for fictitious, observer-based forces like the Coriolis Force have to be performed. Osculating Orbital Elements Instantaneous orbital elements describing the satellite trajectory for a specific time if no perturbations beyond point-mass gravity were present Mean Motion Average angular rate a satellite progresses through its orbit. Periapsis Point of closest approach for an orbiting object with respect to its orbital focus. Perihelion Point of closest approach for an Sun-orbiting object with respect to the Sun. Perigee Point of closest approach for an Earth-orbiting object with respect to the Earth."},{"location":"installation.html","title":"Installation","text":"<p>Brahe is available for both Python and Rust. Choose the installation method that best fits your workflow.</p>"},{"location":"installation.html#python-installation","title":"Python Installation","text":""},{"location":"installation.html#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>The simplest way to install Brahe is using pip from PyPI:</p> <pre><code>pip install brahe\n</code></pre> <p>This will install the latest stable release of Brahe and all required dependencies.</p>"},{"location":"installation.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Brahe includes optional dependencies for enhanced plotting capabilities:</p> <pre><code># Install with scienceplots for publication-quality plots\npip install brahe[plots]\n</code></pre>"},{"location":"installation.html#using-uv-fast-alternative","title":"Using uv (Fast Alternative)","text":"<p>uv is a fast Python package installer. To install Brahe with uv:</p> <pre><code># Install brahe\nuv pip install brahe\n\n# Or with optional plot dependencies\nuv pip install \"brahe[plots]\"\n</code></pre>"},{"location":"installation.html#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that Brahe is working correctly:</p> <pre><code>import brahe as bh\nprint(bh.__version__)\n\n# Test basic functionality\na = bh.R_EARTH + 500e3  # Semi-major axis for 500 km altitude\nT = bh.orbital_period(a)\nprint(f\"Orbital period: {T/60:.2f} minutes\")\n</code></pre>"},{"location":"installation.html#building-from-source-python","title":"Building from Source (Python)","text":"<p>If you want to build Brahe from source (e.g., for development or to use unreleased features), follow these steps:</p>"},{"location":"installation.html#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Rust toolchain (required for building the native extensions):    <pre><code># Install Rust using rustup\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Follow the prompts, then restart your shell\n# Verify installation\nrustc --version\ncargo --version\n</code></pre></p> </li> <li> <p>Configure Rust to Use Nightly:    <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre></p> </li> <li> <p>Python 3.10+ with development headers:    <pre><code># On Ubuntu/Debian\nsudo apt-get install python3-dev\n\n# On macOS (usually included with Python)\n# On Windows, ensure you have Python from python.org\n</code></pre></p> </li> </ol>"},{"location":"installation.html#building-with-uv-recommended","title":"Building with uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Install uv if you haven't already\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Sync dependencies and create virtual environment\nuv sync\n\n# Build and install in editable mode\nuv pip install -e .\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre>"},{"location":"installation.html#building-with-pip-and-maturin","title":"Building with pip and maturin","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Create and activate a virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n\n# Install maturin (the build tool for PyO3)\npip install maturin\n\n# Build and install in development mode\nmaturin develop --release\n\n# Or install normally\npip install -e .\n</code></pre>"},{"location":"installation.html#development-installation","title":"Development Installation","text":"<p>For development work, install with development dependencies:</p> <pre><code># With uv\nuv sync --dev\n\n# With pip\npip install -e \".[dev]\"\n</code></pre> <p>This includes tools for: - Testing (pytest, pytest-cov) - Documentation (mkdocs, mkdocstrings) - Code quality (ruff, pre-commit) - Type stubs generation (pyo3-stubgen)</p>"},{"location":"installation.html#running-tests","title":"Running Tests","text":"<p>After building from source, verify everything works:</p> <pre><code># Run Python tests\npytest tests/ -v\n\n# Run Rust tests\ncargo test\n\n# Run with code coverage\npytest tests/ --cov=brahe --cov-report=html\n</code></pre>"},{"location":"installation.html#updating-type-stubs","title":"Updating Type Stubs","text":"<p>If you modify the Rust Python bindings, regenerate Python type stubs:</p> <pre><code>./scripts/generate_stubs.sh\n</code></pre>"},{"location":"installation.html#rust-installation","title":"Rust Installation","text":"<p>To use Brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre>"},{"location":"installation.html#building-the-rust-library","title":"Building the Rust Library","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Build the library\ncargo build\n\n# Run tests\ncargo test\n\n# Build documentation\ncargo doc --open\n</code></pre>"},{"location":"installation.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation.html#common-issues","title":"Common Issues","text":"<p>\"Failed to build wheel\" (Python) - Ensure Rust is installed: <code>rustc --version</code> - Update Rust: <code>rustup update</code> - Install Python development headers (see prerequisites above)</p> <p>Import errors after installation - Verify installation: <code>pip show brahe</code> - Check Python version: <code>python --version</code> (must be 3.10+) - Try reinstalling: <code>pip install --force-reinstall brahe</code></p> <p>Cartopy installation fails - On Ubuntu/Debian: <code>sudo apt-get install libgeos-dev</code> - On macOS: <code>brew install geos</code> - See Cartopy installation docs</p> <p>Type hints not working in IDE - Ensure type stubs are installed: <code>ls $(python -c \"import brahe; print(brahe.__path__[0])\")/_brahe.pyi</code> - If missing, regenerate: <code>./scripts/generate_stubs.sh</code> (from source installation)</p>"},{"location":"installation.html#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Review the documentation</li> <li>Open a new issue with:</li> <li>Your operating system and version</li> <li>Python/Rust version</li> <li>Complete error message</li> <li>Steps to reproduce</li> </ol>"},{"location":"installation.html#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation.html#macos","title":"macOS","text":"<p>On Apple Silicon (M1/M2/M3): - Brahe builds natively for ARM64 - Ensure you have the ARM64 version of Python</p>"},{"location":"installation.html#windows","title":"Windows","text":"<ul> <li>Install Microsoft C++ Build Tools</li> <li>Consider using WSL2 for a smoother development experience</li> </ul>"},{"location":"installation.html#linux","title":"Linux","text":"<p>Most distributions work out-of-the-box. If you encounter issues: - Install build essentials: <code>sudo apt-get install build-essential</code> - Ensure GEOS library is installed for Cartopy</p>"},{"location":"license.html","title":"License","text":""},{"location":"license.html#brahe-license","title":"Brahe License","text":"<pre><code>MIT License\n\nCopyright (c) 2019-2025 Duncan Eddy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license.html#additional-licenses","title":"Additional Licenses","text":""},{"location":"license.html#blue-marble-image","title":"Blue Marble Image","text":"<p>The Blue Marble images used in Brahe's plotting functions are provided by NASA and are in the public domain. For more information, visit the NASA Blue Marble website.</p>"},{"location":"license.html#natural-earth-data","title":"Natural Earth Data","text":"<p>Some map data used in Brahe's plotting functions is sourced from Natural Earth, which is available under the Public Domain. For more information, visit the Natural Earth website.</p>"},{"location":"roadmap.html","title":"Roadmap","text":"<p>Here you can find an overview of planned features and improvements for Brahe aligned to releases. This roadmap is subject to change based on user feedback, development priorities, and other factors.</p>"},{"location":"roadmap.html#v010-overhaul-rust-migration","title":"v0.1.0 - Overhaul &amp; Rust Migration","text":"<p>This release completes the migration of the Brahe core library from Python to Rust, and matches capabilities with the previous pure-Python version. It also contains many new features, improvements to core functionality, and better documentation.</p> <ul> <li> Complete conversion to Rust core library</li> <li> Datasets Module<ul> <li> Celestrak</li> <li> Ground Stations</li> </ul> </li> <li> Trajectories Module<ul> <li> Core Traits</li> <li> Static Trajectory</li> <li> Dynamic Trajectory</li> </ul> </li> <li> Two Line Element Validation &amp; Parsing</li> <li> Propagators Module<ul> <li> StateProvider</li> <li> OrbitPropagator</li> <li> Keplerian Propagator</li> <li> SGP4 Propagator</li> </ul> </li> <li> Implement Access Computation<ul> <li> Access Constraints</li> <li> Access Properties</li> <li> Parallel Access Computation</li> </ul> </li> <li> Plotting Module<ul> <li> Ground Track Plots</li> <li> State Trajectory Plots</li> <li> 3D Orbit Plots</li> <li> Gabbard Plots</li> </ul> </li> <li> Documentation<ul> <li> Automatically compiled and checked code samples</li> <li> User Guide</li> <li> API Reference</li> <li> Examples</li> </ul> </li> <li> CI/CD Pipeline<ul> <li> Documentation-only fast releases</li> <li> MacOS testing and builds</li> <li> Windows testing and builds</li> <li> Automated latest release deployment</li> <li> Automated wheel builds</li> </ul> </li> <li> Package Quality<ul> <li> Add Code of Conduct</li> <li> Add Contributing Guide</li> </ul> </li> <li> Implement <code>Epoch.now()</code> initialization</li> <li> Caching Earth Orientation Parameters (EOP) data providers</li> <li> Add consistent package caching strategy for data files</li> </ul>"},{"location":"roadmap.html#v100-stable-release-with-foundational-features","title":"v1.0.0 - Stable Release with Foundational Features","text":"<ul> <li> Stable release with foundational features</li> <li> Align with JOSS paper required release</li> </ul>"},{"location":"roadmap.html#v110-advanced-ground-station-operations","title":"v1.1.0 - Advanced Ground Station Operations","text":"<ul> <li> Spacetrack Datasets Module</li> <li> Initialize SGPPropagator from GP Elements</li> <li> OEM File Support<ul> <li> Initialize Trajectory from OEM File</li> <li> Export Trajectory to OEM File</li> </ul> </li> <li> SP3 File Support<ul> <li> Initialize Trajectory from SP3 File</li> <li> Export Trajectory to SP3 File</li> </ul> </li> <li> Plotting Improvements<ul> <li> Access timeline plots</li> </ul> </li> <li> Improved Interpolation Methods for Trajectories<ul> <li> Lagrange Interpolation</li> <li> Hermite Interpolation</li> </ul> </li> <li> Package Maintenance<ul> <li> Add <code>towncrier</code> for automated PR-request changelogs</li> </ul> </li> </ul>"},{"location":"roadmap.html#v120-numerical-integration","title":"v1.2.0 - Numerical Integration","text":"<p>This release adds support for numerical orbit propagation using common perturbation models. It also introduces additional datasets and improves existing functionality.</p> <ul> <li> Add support for numerical integraiton<ul> <li> Fixed-step Runge-Kutta methods (RK4, RKF45)</li> <li> Adaptive-step integrators</li> </ul> </li> <li> Orbital Perturbations<ul> <li> Spherical Harmonic Gravity</li> <li> Third Body Gravity</li> <li> Atmospheric Drag</li> <li> Solar Radiation Pressure</li> <li> Relativity</li> <li> Eclipse Models</li> </ul> </li> <li> Numerical Orbit Propagation Module<ul> <li> Control Input Support<ul> <li> Impulsive Maneuvers</li> <li> Continuous Thrust</li> </ul> </li> </ul> </li> <li> Space Weather Data Management<ul> <li> Data provider classes<ul> <li> Static provider</li> <li> File provider</li> <li> Caching provider</li> </ul> </li> </ul> </li> <li> NRLMSISE 2.0 Atmospheric Model Integration</li> <li> Documentation Improvements</li> </ul>"},{"location":"roadmap.html#v130-estimation-relative-orbits","title":"v1.3.0 - Estimation &amp; Relative Orbits","text":"<ul> <li> Mean Orbital Elements Support<ul> <li> Conversion between Mean and Osculating elements</li> </ul> </li> <li> Relative Orbits<ul> <li> Relative Orbit Representations<ul> <li> RTN Cartesian States</li> <li> Relative Orbital Elements</li> </ul> </li> <li> Propagation of relative motion<ul> <li> Hill-Clohessy-Wiltshire (HCW) Equations</li> <li> Tschauner-Hempel Equations</li> </ul> </li> <li> Plotting Relative Orbits<ul> <li> RTN 3-panel plot</li> <li> RTN 3D plot</li> </ul> </li> </ul> </li> <li> Estimation<ul> <li> Batch Least Squares Estimator</li> <li> Extended Kalman Filter</li> <li> Unscented Kalman Filter</li> <li> Particle Filter</li> </ul> </li> </ul>"},{"location":"roadmap.html#v1x0","title":"v1.X.0","text":"<ul> <li> Continued maintenance and improvements based on user feedback</li> </ul>"},{"location":"roadmap.html#considered-unplanned-features","title":"Considered, Unplanned Features","text":"<p>The following features have been considered for future releases but are not currently planned. They may be revisited based on user demand and development priorities.</p> <ul> <li> Tidal Force Models<ul> <li> Solid Earth Tides</li> <li> Ocean Tides</li> </ul> </li> <li> Albedeo Force Models</li> <li> Probability of Collision Estimation</li> <li> Monte Carlo Simulation Framework</li> <li> Move all rust functions over to generic float types to support f32 and f64</li> <li> Event Detection during Propagation</li> <li> Additional Examples and Tutorials<ul> <li> Mission Analysis Examples</li> <li> Advanced Access Computation Examples</li> <li> Custom Perturbation Models</li> </ul> </li> <li> Attitude dynamics module</li> <li> WASM bindings for web-based applications</li> <li> Datasets module for Jonathan McDowell's Satellite Catalog</li> </ul>"},{"location":"examples/index.html","title":"Examples","text":"<p>Here you will find complete worked examples that showcase some of the problems Brahe can help you solve. Each example includes the full source code so that you can run it yourself and modify it to suit your needs.</p>"},{"location":"examples/doppler_compensation.html","title":"Calculating Doppler Compensation","text":"<p>In this example we'll compute the Doppler compensation required for a ground station to maintain communications with a satellite in low Earth orbit (LEO). We'll simulate the International Space Station (ISS) passing over the Cape Canaveral ground station from the NASA Near Earth Network (NEN) and calculate the frequency shift due to the relative motion between the satellite and ground station during the access window.</p> <p>To accomplish this we'll define a custom access property computer that calculates the Doppler shift in Hz for S-band uplink communications (2.2 GHz) and X-Band downlink communications (8.4 GHz) based on the relative velocity between the satellite and ground station along the line of sight. We'll assume that the satellite uses a fixed carrier frequency for both uplink and downlink, and the ground station must adjust its local oscillator frequency to compensate for the Doppler shift in order to maintain a stable communication link.</p>"},{"location":"examples/doppler_compensation.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the TLE for the ISS (25544) from CelesTrak, and load the NASA Near Earth Network ground station network, and select the Cape Canaveral ground station.</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nbh.initialize_eop()\n</code></pre> <p>We download the ISS TLE directly by NORAD ID and load all NASA NEN ground stations:</p> <pre><code>print(\"Downloading ISS TLE from CelesTrak...\")\n</code></pre> <p>Then select Cape Canaveral from the loaded stations:</p> <pre><code>print(\"\\nLoading NASA Near Earth Network ground stations...\")\nstart_time = time.time()\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n\n# Select Cape Canaveral ground station\ncape_canaveral = None\nfor station in nen_stations:\n    if \"Merrit Island\" in station.get_name():\n</code></pre>"},{"location":"examples/doppler_compensation.html#custom-doppler-shift-property-computer","title":"Custom Doppler Shift Property Computer","text":"<p>Next, we'll define a custom access property computer that calculates the Doppler shift compensation required for maintaining stable communication links.</p>"},{"location":"examples/doppler_compensation.html#doppler-shift-physics","title":"Doppler Shift Physics","text":"<p>For electromagnetic signals traveling between a moving satellite and a stationary ground station, the observed frequency differs from the transmitted frequency due to relative motion along the line-of-sight from the transmitter to the receiver. Using the non-relativistic Doppler approximation (valid when \\(|v_{los}| \\ll c\\)), the received frequency \\(f_r\\) given a transmitted frequency \\(f_x\\) is:</p> \\[ f_r = f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>where \\(f_x\\) is the transmitted carrier frequency, \\(v_{los}\\) is the velocity along the line of sight from the station to the spacecraft (negative when approaching, positive when receding), and \\(c\\) is the speed of light.</p> <p>Sign Convention:</p> <ul> <li>\\(v_{los} &lt; 0\\): satellite approaching \u2192 frequency increases and wavelength decreases (blueshift)</li> <li>\\(v_{los} &gt; 0\\): satellite receeding \u2192 frequency decreases and wavelength increases (redshift)</li> </ul>"},{"location":"examples/doppler_compensation.html#compensation-strategy","title":"Compensation Strategy","text":"<p>To maintain a stable communication link, the ground station must compensate for the Doppler shift that arises from the relative line-of-sight velocity \\(v_{los}\\) between the satellite and the station. Both the satellite and ground station have design frequencies that they expect to operate at for uplink. The challenge is determining how much the ground station must adjust its transmit and receive frequencies to account for the Doppler effect.</p>"},{"location":"examples/doppler_compensation.html#downlink-compensation-satellite-ground","title":"Downlink Compensation (Satellite \u2192 Ground)","text":"<p>The spacecraft transmits at a fixed design frequency \\(f_x^d\\) (e.g., 8.4 GHz for X-band). The ground station's initial receiver frequency \\(f_r^0\\) is initially tuned to \\(f_r^0 = f_x^d\\), expecting to receive at the design frequency. The challenge then is to determine the required frequency adjustment \\(\\Delta f_r = f_r - f_r^0\\) that is added to base the receiver frequency to correctly receive the Doppler-shifted signal.</p> <p>Starting from the Doppler relation:</p> \\[ f_r = f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>where \\(f_r\\) is the actual received frequency, \\(f_x\\) is the transmitted frequency, and \\(v_{los}\\) is the line-of-sight velocity (negative when approaching, positive when receding).</p> <p>Since the spacecraft transmits at the fixed design frequency \\(f_x = f_x^d\\):</p> \\[ f_r = f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>The receiver compensation term is the difference between the actual received frequency and the initial tuning:</p> \\[ \\Delta f_r = f_r - f_r^0 = f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_r^0 \\] <p>Since \\(f_r^0 = f_x^d\\):</p> \\[ \\begin{align} \\Delta f_r &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_r^0 \\\\ &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_x^d \\\\ &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c}  - 1 \\right) \\\\ &amp;= -f_x^d \\frac{v_{los}}{c} \\end{align} \\] <p>Therefore, the downlink compensation is:</p> \\[ \\boxed{\\Delta f_r = -f_x^d \\frac{v_{los}}{c}} \\] <p>Sign interpretation: - When approaching (\\(v_{los} &lt; 0\\)): \\(\\Delta f_r &gt; 0\\) \u2192 tune receiver higher (blueshift) - When receding (\\(v_{los} &gt; 0\\)): \\(\\Delta f_r &lt; 0\\) \u2192 tune receiver lower (redshift)</p>"},{"location":"examples/doppler_compensation.html#uplink-compensation-ground-satellite","title":"Uplink Compensation (Ground \u2192 Satellite)","text":"<p>For uplink, the spacecraft expects to receive at its design frequency \\(f_r^d\\) (e.g., 2.2 GHz for S-band). The ground station initially transmits at \\(f_x^0 = f_r^d\\), but must pre-compensate so that after Doppler shift, the spacecraft receives exactly \\(f_r^d\\). We must determine the required frequency adjustment \\(\\Delta f_x = f_x - f_x^0\\) that the ground station must apply to its transmit frequency.</p> <p>We again start from the Doppler relation:</p> \\[ \\begin{align} f_r^d &amp;= (f_x + \\Delta f_x) \\left( 1 - \\frac{v_{los}}{c} \\right) &amp;= f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right) + \\Delta f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\end{align} \\] <p>Solving for \\(\\Delta f_x\\):</p> \\[ \\Delta f_x \\left( 1 - \\frac{v_{los}}{c} \\right) = f_r^d - f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right) \\] \\[ \\Delta f_x = \\frac{f_r^d - f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right)}{1 - \\frac{v_{los}}{c}} \\] <p>Since we know that \\(f_x^0 = f_r^d\\), we can substitute and simplify:</p> \\[ \\begin{align} \\Delta f_x &amp;= \\frac{f_r^d - f_r^d \\left( 1 - \\frac{v_{los}}{c} \\right)}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= \\frac{f_r^d \\left( 1 - \\left( 1 - \\frac{v_{los}}{c} \\right) \\right)}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= f_r^d \\frac{\\frac{v_{los}}{c}}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= f_x^0 \\frac{\\frac{v_{los}}{c}}{\\frac{c - v_{los}}{c}} \\\\ &amp;= f_x^0 \\frac{v_{los}}{c - v_{los}} \\end{align} \\] <p>And so we find the uplink compensation is:</p> \\[ \\boxed{\\Delta f_x = f_x^0 \\frac{v_{los}}{c - v_{los}}} \\] <p>Frequency Scaling</p> <p>The magnitude of Doppler compensation scales with carrier frequency. X-band (8.4 GHz) experiences about \\(8.4/2.2 \\approx 3.8\\times\\) the frequency shift of S-band (2.2 GHz) for the same line-of-sight velocity.</p>"},{"location":"examples/doppler_compensation.html#implementation","title":"Implementation","text":"<p>We create a custom property computer that calculates the line-of-sight velocity from the satellite state and computes Doppler compensation for both S-band uplink (2.2 GHz) and X-band downlink (8.4 GHz):</p> <pre><code># Communication frequency bands\nS_BAND_FREQ = 2.2e9  # Hz (uplink)\nX_BAND_FREQ = 8.4e9  # Hz (downlink)\n\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"Compute Doppler shift time series for S-band and X-band communications.\"\"\"\n\n    def sampling_config(self):\n        \"\"\"Configure sampling at 10 Hz during access windows.\"\"\"\n        interval_hz = 10.0  # 10 samples per second\n        interval_s = 1.0 / interval_hz\n        return bh.SamplingConfig.fixed_interval(interval_s, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        \"\"\"Calculate Doppler compensation frequencies at each sample point.\n\n        Args:\n            window: AccessWindow with timing information\n            sample_times: Sample epochs in MJD [N]\n            sample_states_ecef: Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef: Location position [3] in ECEF (m)\n            location_geodetic: Location geodetic coords [lon, lat, alt] in (degrees, degrees, m)\n\n        Returns:\n            dict: Time series of Doppler compensation frequencies in Hz\n        \"\"\"\n        loc_pos = np.array(location_ecef)\n\n        # Compute Doppler at each sample point\n        doppler_s_band_list = []\n        doppler_x_band_list = []\n        v_los_list = []\n\n        for state in sample_states_ecef:\n            # Extract satellite position and velocity\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Compute line-of-sight vector (from ground station to satellite)\n            los_vec = sat_pos - loc_pos\n            los_unit = los_vec / np.linalg.norm(los_vec)\n\n            # Compute line-of-sight velocity (negative when approaching, positive when receding)\n            v_los = np.dot(sat_vel, los_unit)\n\n            # Compute Doppler compensation from first principles\n            # Uplink (S-band): \u0394f_x = f_x^0 \u00d7 v_los / (c - v_los)\n            #   Ground pre-compensates transmit frequency so spacecraft receives design frequency\n            # Downlink (X-band): \u0394f_r = -f_x^d \u00d7 v_los / c\n            #   Ground adjusts receive frequency to match Doppler-shifted spacecraft transmission\n            doppler_s = S_BAND_FREQ * v_los / (bh.C_LIGHT - v_los)  # Uplink\n            doppler_x = -X_BAND_FREQ * v_los / bh.C_LIGHT  # Downlink\n\n            doppler_s_band_list.append(doppler_s)\n            doppler_x_band_list.append(doppler_x)\n            v_los_list.append(v_los)\n\n        # Convert sample times to relative times (seconds from window open)\n        relative_times = (sample_times - window.window_open.mjd()) * 86400.0\n\n        # Return as time series\n        return {\n            \"doppler_s_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_s_band_list,\n            },\n            \"doppler_x_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_x_band_list,\n            },\n            \"v_los\": {\n                \"times\": relative_times.tolist(),\n                \"values\": v_los_list,\n            },\n        }\n\n    def property_names(self):\n</code></pre> <p>The property computer extracts the satellite velocity from the provided ECEF state, projects it onto the line-of-sight unit vector to get the line-of-sight velocity, and applies the Doppler formula for both frequency bands.</p>"},{"location":"examples/doppler_compensation.html#access-computation","title":"Access Computation","text":"<p>Next, we'll compute the access windows between the ISS and the Cape Canaveral ground station over a 72-hour period with our custom Doppler shift property computer to calculate the Doppler compensation required to establish S-band and X-band communications during each access.</p> <pre><code>epoch_start = iss.epoch\nepoch_end = epoch_start + 72 * 3600.0  # 72 hours in seconds\n\n# Propagate for full 72-hour period\niss.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation and Doppler properties\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\ndoppler_computer = DopplerComputer()\n\nwindows = bh.location_accesses(\n    [cape_canaveral],\n    [iss],\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler_computer],\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} access windows in {elapsed:.2f} seconds.\")\n</code></pre> <p>This computes all access windows where the ISS rises above 5\u00b0 elevation as viewed from Cape Canaveral, and automatically calculates the Doppler compensation frequencies at the midpoint of each window using our custom property computer.</p>"},{"location":"examples/doppler_compensation.html#ground-track-visualization","title":"Ground Track Visualization","text":"<p>We first visualize the ISS ground track over one orbital period, showing Cape Canaveral's location and its communication cone based on the 5\u00b0 minimum elevation constraint:</p> <pre><code>start_time = time.time()\nprint(\"\\nCreating ground track visualization...\")\norbital_period = bh.orbital_period(iss.semi_major_axis)\niss.propagate_to(iss.epoch + orbital_period)\n\n\n# Create ground track visualization\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": iss.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": [cape_canaveral],\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 8.0,\n        }\n    ],\n    gs_cone_altitude=iss.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n</code></pre> <p>The resulting plot shows the ISS ground track in red and Cape Canaveral with its communication cone in blue:</p>"},{"location":"examples/doppler_compensation.html#doppler-compensation-analysis","title":"Doppler Compensation Analysis","text":"<p>For detailed analysis, we select one access window extract the computed doppler compensation value. This provides a high-resolution profile showing how the Doppler compensation varies as the satellite approaches, reaches closest approach, and recedes:</p> <pre><code>start_time = time.time()\n\ndoppler_s_ts = selected_window.properties.additional[\"doppler_s_band\"]\ndoppler_x_ts = selected_window.properties.additional[\"doppler_x_band\"]\nv_los_ts = selected_window.properties.additional[\"v_los\"]\n\n# Convert relative times to UTC epochs\ntimes_utc = [selected_window.start + t for t in doppler_s_ts[\"times\"]]\n</code></pre> <p>We then visualize the line-of-sight velocity and Doppler compensation requirements over time:</p> <pre><code>start_time = time.time()\n\n# Convert times to minutes relative to window start for better readability\ntimes_rel_min = [t / 60.0 for t in doppler_s_ts[\"times\"]]\ndoppler_s_band_khz = [d / 1000.0 for d in doppler_s_ts[\"values\"]]\ndoppler_x_band_khz = [d / 1000.0 for d in doppler_x_ts[\"values\"]]\nv_los_km_s = [v / 1000.0 for v in v_los_ts[\"values\"]]  # Convert m/s to km/s\n\n# Create figure with three subplots\nfig_doppler = make_subplots(\n    rows=3,\n    cols=1,\n    subplot_titles=(\n        \"Line-of-Sight Velocity (negative = approaching, positive = receding)\",\n        \"S-band Uplink Doppler Compensation (2.2 GHz)\",\n        \"X-band Downlink Doppler Compensation (8.4 GHz)\",\n    ),\n    vertical_spacing=0.12,\n)\n\n# v_los plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=v_los_km_s,\n        mode=\"lines\",\n        name=\"v_los\",\n        line=dict(color=\"green\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;v_los: %{y:.2f} km/s&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=1,\n    col=1,\n)\n\n# S-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_s_band_khz,\n        mode=\"lines\",\n        name=\"S-band (2.2 GHz)\",\n        line=dict(color=\"steelblue\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=2,\n    col=1,\n)\n\n# X-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_x_band_khz,\n        mode=\"lines\",\n        name=\"X-band (8.4 GHz)\",\n        line=dict(color=\"coral\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=3,\n    col=1,\n)\n\n# Add zero reference lines\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=1, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=2, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=3, col=1\n)\n\n# Update axes labels with smaller fonts (matching plot_cartesian_trajectory pattern)\naxis_config = {\n    \"title_font\": {\"size\": 11},\n    \"tickfont\": {\"size\": 10},\n}\nfig_doppler.update_xaxes(\n    title_text=\"Time from AOS (minutes)\", row=3, col=1, **axis_config\n)\nfig_doppler.update_yaxes(title_text=\"v_los (km/s)\", row=1, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=2, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=3, col=1, **axis_config)\n\n# Make subplot titles smaller\nfor annotation in fig_doppler.layout.annotations:\n    annotation.font.size = 11\n\n# Update layout - NO explicit width/height for responsive sizing\nfig_doppler.update_layout(\n    title=\"Doppler Compensation for ISS Pass over Cape Canaveral\",\n</code></pre> <p>The plots below show the line-of-sight velocity and Doppler compensation profiles for a typical ISS pass:</p> <p>The top panel shows \\(v_{los}\\) (line-of-sight velocity from ground station to satellite), confirming our sign convention: negative when approaching (start of pass), crossing through zero at closest approach, then positive when receding (end of pass).</p> <p>The middle and bottom panels show the Doppler compensation frequencies with opposite signs as required:</p> <ul> <li>S-band uplink (middle): Uses \\(\\Delta f_x = f_x^0 v_{los}/(c - v_{los})\\), so it's negative when approaching (transmit lower) and positive when receding (transmit higher)</li> <li>X-band downlink (bottom): Uses \\(\\Delta f_r = -f_x^d v_{los}/c\\), so it's positive when approaching (receive higher) and negative when receding (receive lower)</li> </ul> <p>Note that X-band requires approximately 3.8\u00d7 more compensation than S-band due to its higher carrier frequency (8.4 GHz vs 2.2 GHz). The uplink compensation includes the \\((c - v_{los})\\) denominator term for proper pre-compensation.</p>"},{"location":"examples/doppler_compensation.html#doppler-compensation-data","title":"Doppler Compensation Data","text":"<p>Below is a table of sampled Doppler compensation values during the access window. The compensation frequency indicates the adjustment needed for the ground station equipment:</p> Time (UTC) S-band Doppler (kHz) X-band Doppler (kHz) 2025-11-07 00:06:39 -36.22 138.3 2025-11-07 00:07:15 -31.99 122.13 2025-11-07 00:07:51 -26.29 100.37 2025-11-07 00:08:28 -18.9 72.15 2025-11-07 00:09:04 -9.87 37.69 2025-11-07 00:09:41 0.19 -0.73 2025-11-07 00:10:17 10.24 -39.1 2025-11-07 00:10:53 19.23 -73.41 2025-11-07 00:11:30 26.58 -101.48 2025-11-07 00:12:06 32.24 -123.1 2025-11-07 00:12:43 36.47 -139.23"},{"location":"examples/doppler_compensation.html#full-code-example","title":"Full Code Example","text":"doppler_compensation.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Communication frequency bands\nS_BAND_FREQ = 2.2e9  # Hz (uplink)\nX_BAND_FREQ = 8.4e9  # Hz (downlink)\n\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"Compute Doppler shift time series for S-band and X-band communications.\"\"\"\n\n    def sampling_config(self):\n        \"\"\"Configure sampling at 10 Hz during access windows.\"\"\"\n        interval_hz = 10.0  # 10 samples per second\n        interval_s = 1.0 / interval_hz\n        return bh.SamplingConfig.fixed_interval(interval_s, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        \"\"\"Calculate Doppler compensation frequencies at each sample point.\n\n        Args:\n            window: AccessWindow with timing information\n            sample_times: Sample epochs in MJD [N]\n            sample_states_ecef: Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef: Location position [3] in ECEF (m)\n            location_geodetic: Location geodetic coords [lon, lat, alt] in (degrees, degrees, m)\n\n        Returns:\n            dict: Time series of Doppler compensation frequencies in Hz\n        \"\"\"\n        loc_pos = np.array(location_ecef)\n\n        # Compute Doppler at each sample point\n        doppler_s_band_list = []\n        doppler_x_band_list = []\n        v_los_list = []\n\n        for state in sample_states_ecef:\n            # Extract satellite position and velocity\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Compute line-of-sight vector (from ground station to satellite)\n            los_vec = sat_pos - loc_pos\n            los_unit = los_vec / np.linalg.norm(los_vec)\n\n            # Compute line-of-sight velocity (negative when approaching, positive when receding)\n            v_los = np.dot(sat_vel, los_unit)\n\n            # Compute Doppler compensation from first principles\n            # Uplink (S-band): \u0394f_x = f_x^0 \u00d7 v_los / (c - v_los)\n            #   Ground pre-compensates transmit frequency so spacecraft receives design frequency\n            # Downlink (X-band): \u0394f_r = -f_x^d \u00d7 v_los / c\n            #   Ground adjusts receive frequency to match Doppler-shifted spacecraft transmission\n            doppler_s = S_BAND_FREQ * v_los / (bh.C_LIGHT - v_los)  # Uplink\n            doppler_x = -X_BAND_FREQ * v_los / bh.C_LIGHT  # Downlink\n\n            doppler_s_band_list.append(doppler_s)\n            doppler_x_band_list.append(doppler_x)\n            v_los_list.append(v_los)\n\n        # Convert sample times to relative times (seconds from window open)\n        relative_times = (sample_times - window.window_open.mjd()) * 86400.0\n\n        # Return as time series\n        return {\n            \"doppler_s_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_s_band_list,\n            },\n            \"doppler_x_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_x_band_list,\n            },\n            \"v_los\": {\n                \"times\": relative_times.tolist(),\n                \"values\": v_los_list,\n            },\n        }\n\n    def property_names(self):\n        \"\"\"List properties this computer provides.\"\"\"\n        return [\"doppler_s_band\", \"doppler_x_band\", \"v_los\"]\n\n\n# Download TLE data for ISS from CelesTrak\n# ISS (International Space Station)\n# NORAD ID: 25544\nprint(\"Downloading ISS TLE from CelesTrak...\")\nstart_time = time.time()\niss = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\nelapsed = time.time() - start_time\nprint(f\"Downloaded ISS TLE in {elapsed:.2f} seconds.\")\nprint(f\"Epoch: {iss.epoch}\")\nprint(f\"Semi-major axis: {iss.semi_major_axis / 1000:.1f} km\")\n\n# Load NASA Near Earth Network ground stations\nprint(\"\\nLoading NASA Near Earth Network ground stations...\")\nstart_time = time.time()\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n\n# Select Cape Canaveral ground station\ncape_canaveral = None\nfor station in nen_stations:\n    if \"Merrit Island\" in station.get_name():\n        cape_canaveral = station\n        break\n\nif cape_canaveral is None:\n    print(\"Error: Cape Canaveral ground station not found.\")\n    sys.exit(1)\n\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(nen_stations)} NASA NEN ground stations in {elapsed:.2f} seconds.\")\n\n\n# Propagate ISS for one orbit to create ground track visualization\nstart_time = time.time()\nprint(\"\\nCreating ground track visualization...\")\norbital_period = bh.orbital_period(iss.semi_major_axis)\niss.propagate_to(iss.epoch + orbital_period)\n\n\n# Create ground track visualization\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": iss.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": [cape_canaveral],\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 8.0,\n        }\n    ],\n    gs_cone_altitude=iss.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagator and compute 72-hour access windows with Doppler properties\nstart_time = time.time()\nprint(\"\\nComputing 72-hour access windows with Doppler compensation...\")\niss.reset()\n\nepoch_start = iss.epoch\nepoch_end = epoch_start + 72 * 3600.0  # 72 hours in seconds\n\n# Propagate for full 72-hour period\niss.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation and Doppler properties\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\ndoppler_computer = DopplerComputer()\n\nwindows = bh.location_accesses(\n    [cape_canaveral],\n    [iss],\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler_computer],\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} access windows in {elapsed:.2f} seconds.\")\n\nif len(windows) == 0:\n    print(\"No access windows found. Exiting.\")\n    sys.exit(0)\n\n# Print sample of access windows with Doppler properties\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Sample Access Windows with Doppler Time Series (first 5)\")\nprint(\"=\" * 100)\nprint(\n    f\"{'Start Time':&lt;25} {'Duration':&gt;10} {'Max Elev':&gt;10} {'# Samples':&gt;10} {'Peak S-band':&gt;13} {'Peak X-band':&gt;13}\"\n)\nprint(\"-\" * 100)\nfor i, window in enumerate(windows[:5]):\n    duration_min = window.duration / 60.0\n    max_elev = window.properties.elevation_max\n\n    # Extract time series data\n    doppler_s_ts = window.properties.additional[\"doppler_s_band\"]\n    doppler_x_ts = window.properties.additional[\"doppler_x_band\"]\n\n    n_samples = len(doppler_s_ts[\"values\"])\n    peak_s = max(abs(v) for v in doppler_s_ts[\"values\"]) / 1000.0\n    peak_x = max(abs(v) for v in doppler_x_ts[\"values\"]) / 1000.0\n\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    print(\n        f\"{start_str:&lt;25} {duration_min:&gt;8.1f} m {max_elev:&gt;8.1f}\u00b0 {n_samples:&gt;10} {peak_s:&gt;10.2f} kHz {peak_x:&gt;10.2f} kHz\"\n    )\nprint(\"=\" * 100)\n\n# Select a window with good duration for detailed analysis\nselected_window = None\nfor window in windows:\n    if window.duration &gt; 300:  # At least 5 minutes\n        selected_window = window\n        break\n\nif selected_window is None:\n    # Fallback to first window if none are long enough\n    selected_window = windows[0]\n\nprint(\n    f\"\\nAnalyzing detailed Doppler profile for window starting at {selected_window.start}\"\n)\nprint(f\"Window duration: {selected_window.duration / 60:.1f} minutes\")\n\n# Extract precomputed time series from window properties\nprint(\"Extracting precomputed Doppler time series...\")\nstart_time = time.time()\n\ndoppler_s_ts = selected_window.properties.additional[\"doppler_s_band\"]\ndoppler_x_ts = selected_window.properties.additional[\"doppler_x_band\"]\nv_los_ts = selected_window.properties.additional[\"v_los\"]\n\n# Convert relative times to UTC epochs\ntimes_utc = [selected_window.start + t for t in doppler_s_ts[\"times\"]]\n\nnum_samples = len(doppler_s_ts[\"times\"])\n\nelapsed = time.time() - start_time\nprint(f\"Extracted {num_samples} samples (0.1s interval) in {elapsed:.2f} seconds.\")\n\n# Export ~10 evenly-spaced samples to CSV\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_data.csv\"\nnum_csv_samples = 11\ncsv_indices = np.linspace(0, len(times_utc) - 1, num_csv_samples, dtype=int)\n\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow([\"Time (UTC)\", \"S-band Doppler (kHz)\", \"X-band Doppler (kHz)\"])\n    for idx in csv_indices:\n        time_str = str(times_utc[idx]).split(\".\")[0]  # Remove fractional seconds\n        writer.writerow(\n            [\n                time_str,\n                f\"{doppler_s_ts['values'][idx] / 1000.0:.2f}\",\n                f\"{doppler_x_ts['values'][idx] / 1000.0:.2f}\",\n            ]\n        )\n\nprint(f\"\u2713 Exported {num_csv_samples} samples to {csv_path}\")\n\n# Create Doppler vs time visualization\nprint(\"\\nCreating Doppler compensation visualization...\")\nstart_time = time.time()\n\n# Convert times to minutes relative to window start for better readability\ntimes_rel_min = [t / 60.0 for t in doppler_s_ts[\"times\"]]\ndoppler_s_band_khz = [d / 1000.0 for d in doppler_s_ts[\"values\"]]\ndoppler_x_band_khz = [d / 1000.0 for d in doppler_x_ts[\"values\"]]\nv_los_km_s = [v / 1000.0 for v in v_los_ts[\"values\"]]  # Convert m/s to km/s\n\n# Create figure with three subplots\nfig_doppler = make_subplots(\n    rows=3,\n    cols=1,\n    subplot_titles=(\n        \"Line-of-Sight Velocity (negative = approaching, positive = receding)\",\n        \"S-band Uplink Doppler Compensation (2.2 GHz)\",\n        \"X-band Downlink Doppler Compensation (8.4 GHz)\",\n    ),\n    vertical_spacing=0.12,\n)\n\n# v_los plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=v_los_km_s,\n        mode=\"lines\",\n        name=\"v_los\",\n        line=dict(color=\"green\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;v_los: %{y:.2f} km/s&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=1,\n    col=1,\n)\n\n# S-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_s_band_khz,\n        mode=\"lines\",\n        name=\"S-band (2.2 GHz)\",\n        line=dict(color=\"steelblue\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=2,\n    col=1,\n)\n\n# X-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_x_band_khz,\n        mode=\"lines\",\n        name=\"X-band (8.4 GHz)\",\n        line=dict(color=\"coral\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=3,\n    col=1,\n)\n\n# Add zero reference lines\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=1, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=2, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=3, col=1\n)\n\n# Update axes labels with smaller fonts (matching plot_cartesian_trajectory pattern)\naxis_config = {\n    \"title_font\": {\"size\": 11},\n    \"tickfont\": {\"size\": 10},\n}\nfig_doppler.update_xaxes(\n    title_text=\"Time from AOS (minutes)\", row=3, col=1, **axis_config\n)\nfig_doppler.update_yaxes(title_text=\"v_los (km/s)\", row=1, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=2, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=3, col=1, **axis_config)\n\n# Make subplot titles smaller\nfor annotation in fig_doppler.layout.annotations:\n    annotation.font.size = 11\n\n# Update layout - NO explicit width/height for responsive sizing\nfig_doppler.update_layout(\n    title=\"Doppler Compensation for ISS Pass over Cape Canaveral\",\n    showlegend=False,\n)\n</code></pre>"},{"location":"examples/doppler_compensation.html#see-also","title":"See Also","text":"<ul> <li>Access Properties - Custom property computers and property types</li> <li>Access Computation - Access search algorithms and configuration</li> <li>Predicting Ground Contacts - Similar example with statistical analysis</li> <li>CelesTrak Dataset - Downloading TLE data</li> <li>Ground Station Datasets - Loading ground station networks</li> </ul>"},{"location":"examples/ground_contacts.html","title":"Predicting Ground Contacts","text":"<p>In this example we'll predict ground contacts between the NISAR radar satellite and the NASA Near Earth Network ground stations using Brahe. We'll download the latest TLE data for the satellite from CelesTrak, load the NASA Near Earth Network ground station data, and compute the ground contacts between the satellite and ground stations over a 7-day period. We'll then analyze the statistics of the contact duration and number of contacts per ground station.</p>"},{"location":"examples/ground_contacts.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the TLE for NISAR (NORAD ID 65053) from CelesTrak, and load the NASA Near Earth Network ground station network.</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\nbh.initialize_eop()\n</code></pre> <p>We download the NISAR TLE directly by NORAD ID and load all NASA NEN ground stations:</p> <pre><code>nisar = bh.datasets.celestrak.get_tle_by_id_as_propagator(65053, 60.0)\nnisar = nisar.with_name(\"NISAR\")\n</code></pre> <pre><code>nen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n</code></pre> <p>We then propagate NISAR for 3 orbital periods to prepare for ground track visualization:</p> <pre><code>orbital_period = bh.orbital_period(nisar.semi_major_axis)\nnisar.propagate_to(nisar.epoch + 3 * orbital_period)\n</code></pre>"},{"location":"examples/ground_contacts.html#ground-track-visualization","title":"Ground Track Visualization","text":"<p>Next we'll visualize the ground track and communication cones for NISAR over a 3-orbit period. The communication cones show the coverage area of each ground station based on a 5\u00b0 minimum elevation angle:</p> <pre><code>fig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": nisar.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": nen_stations,\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 5.0,\n        }\n    ],\n    gs_cone_altitude=nisar.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    basemap=\"natural_earth\",\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\n</code></pre> <p>The resulting plot shows NISAR's ground track in red and the NASA Near Earth Network stations with their communication cones in blue:</p>"},{"location":"examples/ground_contacts.html#compute-ground-contacts","title":"Compute Ground Contacts","text":"<p>We'll compute the ground contacts between NISAR and the NASA Near Earth Network ground stations over a 7-day period using Brahe's access computation tools. We use an elevation constraint of 5\u00b0 minimum elevation:</p> <pre><code>nisar.reset()\n\nepoch_start = nisar.epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate for full 7-day period\nnisar.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    nen_stations, [nisar], epoch_start, epoch_end, constraint\n)\n</code></pre> <p>Below is the table of the first 20 contact windows. Click on any column header to sort:</p> Station Start Time (UTC) End Time (UTC) Duration (min) Max Elevation (deg) Singapore 2025-11-06 22:08:00 2025-11-06 22:13:53 5.9 17.2 Svalbard 2025-11-06 22:27:18 2025-11-06 22:39:18 12 61 Kiruna 2025-11-06 22:28:18 2025-11-06 22:37:47 9.5 18.2 Wallops 2025-11-06 22:42:00 2025-11-06 22:53:19 11.3 33.7 Ponce de Leon 2025-11-06 22:45:07 2025-11-06 22:55:28 10.4 22.8 Merrit Island 2025-11-06 22:45:12 2025-11-06 22:55:39 10.5 23.5 Santiago 2025-11-06 23:01:08 2025-11-06 23:12:18 11.2 30.2 McMurdo 2025-11-06 23:18:03 2025-11-06 23:30:17 12.2 65 Dongara 2025-11-06 23:33:42 2025-11-06 23:43:36 9.9 20 Singapore 2025-11-06 23:42:16 2025-11-06 23:52:59 10.7 26.5 Kiruna 2025-11-07 00:05:20 2025-11-07 00:15:30 10.2 22.3 Svalbard 2025-11-07 00:05:48 2025-11-07 00:17:50 12 64.8 Wallops 2025-11-07 00:20:54 2025-11-07 00:31:26 10.5 25.3 Ponce de Leon 2025-11-07 00:23:28 2025-11-07 00:34:18 10.8 28.8 Merrit Island 2025-11-07 00:23:38 2025-11-07 00:34:22 10.7 27.5 White Sands 2025-11-07 00:24:13 2025-11-07 00:34:14 10 20.4 McMurdo 2025-11-07 00:56:34 2025-11-07 01:08:43 12.1 58.2 Kiruna 2025-11-07 01:42:27 2025-11-07 01:53:59 11.5 40.7 Svalbard 2025-11-07 01:44:25 2025-11-07 01:56:35 12.2 86.7 Gilmore Creek 2025-11-07 01:56:11 2025-11-07 02:02:27 6.3 8.8"},{"location":"examples/ground_contacts.html#analyze-contact-statistics","title":"Analyze Contact Statistics","text":"<p>Finally, we'll analyze the contact statistics, including the average daily contacts per station and distribution of contact durations.</p> <p>We group the contact windows by station and compute the average daily contacts:</p> <pre><code># Group contacts by station\nstation_contacts = {}\nfor window in windows:\n    station_name = window.location_name\n    if station_name not in station_contacts:\n        station_contacts[station_name] = []\n    station_contacts[station_name].append(window)\n\n# Calculate average daily contacts per station\ndays = 7.0\nstation_daily_avg = {}\nfor station, contacts in station_contacts.items():\n    avg_per_day = len(contacts) / days\n    station_daily_avg[station] = avg_per_day\n\n# Sort by average daily contacts\nsorted_stations = sorted(station_daily_avg.items(), key=lambda x: x[1], reverse=True)\n\nprint(\"\\nAverage Daily Contacts per Station:\")\nprint(\"-\" * 40)\nfor station, avg in sorted_stations:\n    total = len(station_contacts[station])\n    print(f\"{station:&lt;20}: {avg:&gt;5.1f} contacts/day ({total} total)\")\n\n# Figure 1: Daily contacts per station (bar chart)\nstations_list = [s[0] for s in sorted_stations]\ndaily_avgs = [s[1] for s in sorted_stations]\n</code></pre> <p>Then we create two visualizations: a bar chart of average daily contacts per station, and a histogram of contact duration distribution:</p> <pre><code># Figure 1: Daily contacts per station (bar chart)\nstations_list = [s[0] for s in sorted_stations]\ndaily_avgs = [s[1] for s in sorted_stations]\n\nfig_daily = go.Figure(\n    data=[\n        go.Bar(\n            x=stations_list,\n            y=daily_avgs,\n            marker_color=\"steelblue\",\n            hovertemplate=\"&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;%{y:.1f} contacts/day&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_daily.update_layout(\n    title=\"NISAR Average Daily Contacts by Station (7-day period)\",\n    xaxis_title=\"Ground Station\",\n    yaxis_title=\"Average Daily Contacts\",\n    xaxis_tickangle=-45,\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=120),\n)\n\n# Figure 2: Contact duration distribution (histogram)\ndurations = [w.duration / 60.0 for w in windows]  # Convert to minutes\n\nmean_duration = np.mean(durations)\nmedian_duration = np.median(durations)\nmax_duration = np.max(durations)\n\nfig_duration = go.Figure(\n    data=[\n        go.Histogram(\n            x=durations,\n            nbinsx=30,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Duration: %{x:.1f} min&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_duration.update_layout(\n    title=\"NISAR Contact Duration Distribution\",\n    xaxis_title=\"Contact Duration (minutes)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {mean_duration:.1f} min&lt;br&gt;Median: {median_duration:.1f} min&lt;br&gt;Max: {max_duration:.1f} min\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.05,\n            y=0.97,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n</code></pre> <p>The daily contacts bar chart shows which stations have the most frequent visibility to NISAR:</p> <p>The duration histogram shows the distribution of contact lengths, with statistics overlay:</p>"},{"location":"examples/ground_contacts.html#full-code-example","title":"Full Code Example","text":"ground_contacts.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for NISAR from CelesTrak\n# NISAR (NASA-ISRO SAR) is a joint Earth observation satellite\n# NORAD ID: 65053\nprint(\"Downloading NISAR TLE from CelesTrak...\")\nstart_time = time.time()\nnisar = bh.datasets.celestrak.get_tle_by_id_as_propagator(65053, 60.0)\nnisar = nisar.with_name(\"NISAR\")\nelapsed = time.time() - start_time\nprint(f\"Downloaded NISAR TLE in {elapsed:.2f} seconds.\")\nprint(f\"Epoch: {nisar.epoch}\")\nprint(f\"Semi-major axis: {nisar.semi_major_axis / 1000:.1f} km\")\n\n# Load NASA Near Earth Network ground stations\nprint(\"\\nLoading NASA Near Earth Network ground stations...\")\nstart_time = time.time()\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(nen_stations)} NASA NEN ground stations in {elapsed:.2f} seconds.\")\n\n# Propagate NISAR for 3 orbits to create ground track visualization\nprint(\"\\nPropagating NISAR for 3 orbits...\")\nstart_time = time.time()\norbital_period = bh.orbital_period(nisar.semi_major_axis)\nnisar.propagate_to(nisar.epoch + 3 * orbital_period)\nelapsed = time.time() - start_time\nprint(f\"Orbital period: {orbital_period / 60:.1f} minutes\")\nprint(f\"Propagated NISAR for 3 orbits in {elapsed:.2f} seconds.\")\n\n# Create ground track visualization with communication cones\nprint(\"\\nCreating ground track visualization with communication cones...\")\nstart_time = time.time()\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": nisar.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": nen_stations,\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 5.0,\n        }\n    ],\n    gs_cone_altitude=nisar.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    basemap=\"natural_earth\",\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n\nstart_time = time.time()\n# Reset propagator and compute 7-day access windows\nprint(\"\\nComputing 7-day ground contacts...\")\nnisar.reset()\n\nepoch_start = nisar.epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate for full 7-day period\nnisar.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    nen_stations, [nisar], epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} contact windows in {elapsed:.2f} seconds.\")\n\n# Print sample of contact windows\nprint(\"\\n\" + \"=\" * 80)\nprint(\"Sample Contact Windows (first 10)\")\nprint(\"=\" * 80)\nprint(\n    f\"{'Station':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;10} {'Max Elev':&gt;10}\"\n)\nprint(\"-\" * 80)\nfor i, window in enumerate(windows[:10]):\n    duration_min = window.duration / 60.0\n    max_elev = window.properties.elevation_max\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(window.end).split(\".\")[0]\n    print(\n        f\"{window.location_name:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_min:&gt;8.1f} m {max_elev:&gt;8.1f}\u00b0\"\n    )\nprint(\"=\" * 80)\n\n# Export first 20 contact windows to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_windows.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Station\",\n            \"Start Time (UTC)\",\n            \"End Time (UTC)\",\n            \"Duration (min)\",\n            \"Max Elevation (deg)\",\n        ]\n    )\n    for window in windows[:20]:  # Only export first 20 for documentation\n        duration_min = window.duration / 60.0\n        max_elev = window.properties.elevation_max\n        start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n        end_str = str(window.end).split(\".\")[0]\n        writer.writerow(\n            [\n                window.location_name,\n                start_str,\n                end_str,\n                f\"{duration_min:.1f}\",\n                f\"{max_elev:.1f}\",\n            ]\n        )\nprint(f\"\u2713 Exported first 20 contact windows to {csv_path}\")\n\n# Analyze contact statistics\nprint(\"\\nAnalyzing contact statistics...\")\n\n# Group contacts by station\nstation_contacts = {}\nfor window in windows:\n    station_name = window.location_name\n    if station_name not in station_contacts:\n        station_contacts[station_name] = []\n    station_contacts[station_name].append(window)\n\n# Calculate average daily contacts per station\ndays = 7.0\nstation_daily_avg = {}\nfor station, contacts in station_contacts.items():\n    avg_per_day = len(contacts) / days\n    station_daily_avg[station] = avg_per_day\n\n# Sort by average daily contacts\nsorted_stations = sorted(station_daily_avg.items(), key=lambda x: x[1], reverse=True)\n\nprint(\"\\nAverage Daily Contacts per Station:\")\nprint(\"-\" * 40)\nfor station, avg in sorted_stations:\n    total = len(station_contacts[station])\n    print(f\"{station:&lt;20}: {avg:&gt;5.1f} contacts/day ({total} total)\")\n\n# Figure 1: Daily contacts per station (bar chart)\nstations_list = [s[0] for s in sorted_stations]\ndaily_avgs = [s[1] for s in sorted_stations]\n\nfig_daily = go.Figure(\n    data=[\n        go.Bar(\n            x=stations_list,\n            y=daily_avgs,\n            marker_color=\"steelblue\",\n            hovertemplate=\"&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;%{y:.1f} contacts/day&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_daily.update_layout(\n    title=\"NISAR Average Daily Contacts by Station (7-day period)\",\n    xaxis_title=\"Ground Station\",\n    yaxis_title=\"Average Daily Contacts\",\n    xaxis_tickangle=-45,\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=120),\n)\n\n# Figure 2: Contact duration distribution (histogram)\ndurations = [w.duration / 60.0 for w in windows]  # Convert to minutes\n\nmean_duration = np.mean(durations)\nmedian_duration = np.median(durations)\nmax_duration = np.max(durations)\n\nfig_duration = go.Figure(\n    data=[\n        go.Histogram(\n            x=durations,\n            nbinsx=30,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Duration: %{x:.1f} min&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_duration.update_layout(\n    title=\"NISAR Contact Duration Distribution\",\n    xaxis_title=\"Contact Duration (minutes)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {mean_duration:.1f} min&lt;br&gt;Median: {median_duration:.1f} min&lt;br&gt;Max: {max_duration:.1f} min\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.05,\n            y=0.97,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n\nprint(\"\\nContact Duration Statistics:\")\nprint(f\"  Mean: {mean_duration:.1f} minutes\")\nprint(f\"  Median: {median_duration:.1f} minutes\")\nprint(f\"  Min: {np.min(durations):.1f} minutes\")\nprint(f\"  Max: {max_duration:.1f} minutes\")\n</code></pre>"},{"location":"examples/ground_contacts.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Locations</li> <li>Constraints</li> </ul>"},{"location":"examples/imaging_opportunities.html","title":"Earth Observation Imaging Opportunities","text":"<p>In this example we'll find upcoming imaging opportunities for the ICEYE constellation over San Francisco (lon: -122.4194, lat: 37.7749), subject to specific imaging constraints.</p>"},{"location":"examples/imaging_opportunities.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the latest TLE data for all active spacecraft and filter it to select just the ICEYE spacecraft:</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n</code></pre> <p>We download all active satellites from CelesTrak and filter for ICEYE spacecraft:</p> <pre><code>all_sats = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\niceye_sats = [sat for sat in all_sats if \"ICEYE\" in sat.get_name().upper()]\n</code></pre>"},{"location":"examples/imaging_opportunities.html#constellation-visualization","title":"Constellation Visualization","text":"<p>Before getting further into the analysis, it's useful to visualize the 3D geometry of the constellation. We propagate each satellite for one orbital period and create a 3D visualization:</p> <pre><code>    orbital_period = bh.orbital_period(sat.semi_major_axis)\n    sat.propagate_to(sat.epoch + orbital_period)\n\n# Create 3D constellation visualization\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": sat.trajectory,\n            \"mode\": \"lines\",\n            \"line_width\": 1.5,\n            \"label\": sat.get_name(),\n        }\n        for sat in iceye_sats\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the ICEYE constellation orbits in 3D space:</p>"},{"location":"examples/imaging_opportunities.html#target-location-definition","title":"Target Location Definition","text":"<p>We define San Francisco as our imaging target:</p> <pre><code>san_francisco = bh.PointLocation(\n    lon=-122.4194,  # longitude in degrees\n    lat=37.7749,  # latitude in degrees\n    alt=0.0,  # altitude in meters\n).with_name(\"San Francisco\")\n</code></pre>"},{"location":"examples/imaging_opportunities.html#constraint-specification","title":"Constraint Specification","text":"<p>In this case, we want to collect a descending-pass, right-looking image collected from between 35 and 45 degrees off-nadir angle. We compose these requirements using Brahe's constraint system:</p> <pre><code>constraint = bh.ConstraintAll(\n    constraints=[\n        bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING),\n        bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT),\n        bh.OffNadirConstraint(min_off_nadir_deg=35.0, max_off_nadir_deg=45.0),\n    ]\n)\n</code></pre> <p>This creates a composite constraint that requires all three conditions to be satisfied simultaneously:</p> <ul> <li><code>AscDscConstraint</code>: Filters for descending passes only</li> <li><code>LookDirectionConstraint</code>: Requires right-looking geometry</li> <li><code>OffNadirConstraint</code>: Limits imaging angle to 35-45\u00b0 off-nadir</li> </ul>"},{"location":"examples/imaging_opportunities.html#compute-collection-opportunities","title":"Compute Collection Opportunities","text":"<p>Now we'll compute all imaging opportunities between the constellation and San Francisco over a 7-day period:</p> <pre><code>epoch_start = iceye_sats[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for full 7-day period\nfor sat in iceye_sats:\n    sat.propagate_to(epoch_end)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [san_francisco], iceye_sats, epoch_start, epoch_end, constraint\n)\n</code></pre> <p>Below is a table of the first 10 imaging opportunities. Click on any column header to sort:</p> Spacecraft Start Time (UTC) End Time (UTC) Duration (sec) Off-Nadir Angle (deg) ICEYE-X7 2025-11-06 23:50:57 2025-11-06 23:54:07 190.3 40.3 ICEYE-X51 2025-11-06 23:56:35 2025-11-07 00:09:44 789 45 ICEYE-X13 2025-11-07 00:13:17 2025-11-07 00:18:56 339.3 45 ICEYE-X50 2025-11-07 00:18:46 2025-11-07 00:32:18 812.7 45 ICEYE-X11 2025-11-07 00:21:23 2025-11-07 00:27:04 341.1 45 ICEYE-X6 2025-11-07 00:41:33 2025-11-07 00:47:22 348.7 45 ICEYE-X48 2025-11-07 00:56:45 2025-11-07 01:09:45 780.4 45 ICEYE-X46 2025-11-07 01:03:42 2025-11-07 01:16:30 768.8 45 ICEYE-X7 2025-11-07 01:23:36 2025-11-07 01:30:56 440.2 45 ICEYE-X11 2025-11-07 01:30:56 2025-11-07 01:31:20 23.8 45"},{"location":"examples/imaging_opportunities.html#full-code-example","title":"Full Code Example","text":"imaging_opportunities.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for ICEYE constellation from CelesTrak\n# ICEYE operates a constellation of SAR (Synthetic Aperture Radar) satellites\nprint(\"Downloading ICEYE constellation TLEs from CelesTrak...\")\nstart_time = time.time()\n\n# Get all active satellites and filter for ICEYE\nall_sats = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\niceye_sats = [sat for sat in all_sats if \"ICEYE\" in sat.get_name().upper()]\n\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(iceye_sats)} ICEYE satellites in {elapsed:.2f} seconds.\")\n\nif len(iceye_sats) == 0:\n    print(\"ERROR: No ICEYE satellites found in active constellation data.\")\n    print(\n        \"This may indicate the satellites are not currently in the CelesTrak database.\"\n    )\n    sys.exit(1)\n\n# Print satellite information\nprint(\"\\nICEYE Constellation:\")\nfor i, sat in enumerate(iceye_sats[:5]):  # Show first 5\n    print(f\"  {i + 1}. {sat.get_name()}\")\n    print(f\"     Epoch: {sat.epoch}\")\n    print(f\"     Semi-major axis: {sat.semi_major_axis / 1000:.1f} km\")\nif len(iceye_sats) &gt; 5:\n    print(f\"  ... and {len(iceye_sats) - 5} more\")\n\n# Propagate all satellites for one orbital period for visualization\nprint(\"\\nPropagating constellation for visualization...\")\nstart_time = time.time()\nfor sat in iceye_sats:\n    orbital_period = bh.orbital_period(sat.semi_major_axis)\n    sat.propagate_to(sat.epoch + orbital_period)\n\n# Create 3D constellation visualization\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": sat.trajectory,\n            \"mode\": \"lines\",\n            \"line_width\": 1.5,\n            \"label\": sat.get_name(),\n        }\n        for sat in iceye_sats\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nelapsed = time.time() - start_time\nprint(f\"Created 3D visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagators for access computation\nprint(\"\\nResetting propagators for access computation...\")\nfor sat in iceye_sats:\n    sat.reset()\n\n# Define San Francisco target location\nsan_francisco = bh.PointLocation(\n    lon=-122.4194,  # longitude in degrees\n    lat=37.7749,  # latitude in degrees\n    alt=0.0,  # altitude in meters\n).with_name(\"San Francisco\")\n\nprint(f\"\\nTarget Location: {san_francisco.get_name()}\")\nprint(f\"  Longitude: {san_francisco.lon:.4f}\u00b0\")\nprint(f\"  Latitude: {san_francisco.lat:.4f}\u00b0\")\n\n# Define composite imaging constraint\n# Requirements:\n# - Descending pass only\n# - Right-looking geometry\n# - Off-nadir angle between 35-45 degrees\nprint(\"\\nDefining imaging constraints:\")\nprint(\"  - Descending pass only\")\nprint(\"  - Right-looking geometry\")\nprint(\"  - Off-nadir angle: 35-45 degrees\")\n\nconstraint = bh.ConstraintAll(\n    constraints=[\n        bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING),\n        bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT),\n        bh.OffNadirConstraint(min_off_nadir_deg=35.0, max_off_nadir_deg=45.0),\n    ]\n)\n\n# Compute imaging opportunities over 7-day period\nprint(\"\\nComputing 7-day imaging opportunities...\")\nstart_time = time.time()\n\nepoch_start = iceye_sats[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for full 7-day period\nfor sat in iceye_sats:\n    sat.propagate_to(epoch_end)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [san_francisco], iceye_sats, epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} imaging opportunities in {elapsed:.2f} seconds.\")\n\n# Print sample of imaging opportunities\nprint(\"\\n\" + \"=\" * 90)\nprint(\"Sample Imaging Opportunities (first 10)\")\nprint(\"=\" * 90)\nprint(\n    f\"{'Spacecraft':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;10} {'Off-Nadir':&gt;10}\"\n)\nprint(\"-\" * 90)\nfor i, window in enumerate(windows[:10]):\n    duration_sec = window.duration\n    off_nadir = (\n        window.properties.off_nadir_max - window.properties.off_nadir_min\n    ) / 2 + window.properties.off_nadir_min\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(window.end).split(\".\")[0]\n    print(\n        f\"{window.satellite_name:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_sec:&gt;8.1f} s {off_nadir:&gt;8.1f}\u00b0\"\n    )\nprint(\"=\" * 90)\n\n# Export ~10 imaging opportunities to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_windows.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Spacecraft\",\n            \"Start Time (UTC)\",\n            \"End Time (UTC)\",\n            \"Duration (sec)\",\n            \"Off-Nadir Angle (deg)\",\n        ]\n    )\n    for window in windows[:10]:  # Only export first 10 for documentation\n        duration_sec = window.duration\n        off_nadir = window.properties.off_nadir_max\n        start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n        end_str = str(window.end).split(\".\")[0]\n        writer.writerow(\n            [\n                window.satellite_name,\n                start_str,\n                end_str,\n                f\"{duration_sec:.1f}\",\n                f\"{off_nadir:.1f}\",\n            ]\n        )\nprint(f\"\u2713 Exported first 10 imaging opportunities to {csv_path}\")\n\n# Print statistics\nunique_spacecraft = len(set(w.satellite_name for w in windows))\nprint(\"\\nImaging Opportunity Statistics:\")\nprint(f\"  Total opportunities: {len(windows)}\")\nprint(f\"  Spacecraft with opportunities: {unique_spacecraft}\")\nprint(f\"  Average duration: {np.mean([w.duration for w in windows]):.1f} seconds\")\nprint(f\"  Total imaging time: {sum([w.duration for w in windows]):.1f} seconds\")\n</code></pre>"},{"location":"examples/imaging_opportunities.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Locations</li> <li>Constraints</li> </ul>"},{"location":"examples/max_communications_gap.html","title":"Maximum Communications Gap","text":"<p>In this example we'll analyze the communication gaps between a satellite constellation and supporting ground station network. For this work we'll use the Umbra constellation and 5 KSAT ground stations (Svalbard, Punta Arenas, Hartebeesthoek, Awarua, and Athens).</p> <p>The maximum contact gap is a significant factor in the reactivity (speed from request to uplink) and latency (time from collection to delivery) for satellite imaging constellations.</p>"},{"location":"examples/max_communications_gap.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the latest TLE data for all active spacecraft, and filter to select just the Umbra satellites:</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n</code></pre> <p>We download all active satellite TLEs from CelesTrak as propagators and filter for satellites with \"UMBRA\" in their name:</p> <pre><code>all_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Umbra satellites (name contains \"UMBRA\")\numbra_props = [prop for prop in all_active_props if \"UMBRA\" in prop.get_name().upper()]\n</code></pre> <p>Next, we load the 5 specific KSAT ground stations that will support communications:</p> <pre><code>all_ksat = bh.datasets.groundstations.load(\"ksat\")\n\n# Filter for the 5 specific stations mentioned in the problem\nstation_names = [\"Svalbard\", \"Punta Arenas\", \"Hartebeesthoek\", \"Awarua\", \"Athens\"]\nksat_stations = [s for s in all_ksat if s.get_name() in station_names]\n</code></pre>"},{"location":"examples/max_communications_gap.html#constellation-visualization","title":"Constellation Visualization","text":"<p>Before getting further into the analysis, it's useful to visualize the 3D geometry of the constellation. We propagate each satellite for one orbit and plot their trajectories:</p> <pre><code>for prop in umbra_props:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\n\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in umbra_props\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the complete Umbra constellation orbiting Earth:</p>"},{"location":"examples/max_communications_gap.html#access-computation","title":"Access Computation","text":"<p>To figure out the contact gaps, we first need to compute all ground contacts over the 7-day propagation window. We reset the propagators and compute access windows with a 5\u00b0 minimum elevation constraint:</p> <pre><code>for prop in umbra_props:\n    prop.reset()\n\n# Define analysis period (7 days from first satellite's epoch)\nepoch_start = umbra_props[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for 7 days\nfor prop in umbra_props:\n    prop.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    ksat_stations, umbra_props, epoch_start, epoch_end, constraint\n)\n</code></pre>"},{"location":"examples/max_communications_gap.html#max-gap-computation","title":"Max Gap Computation","text":"<p>Next we'll compute the contact gaps over the course of the simulation. The contact gap is defined as the time between the last contact for a spacecraft and the next contact for that spacecraft. The gap is always computed on a per-spacecraft basis:</p> <pre><code># Group windows by spacecraft\nspacecraft_windows = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in spacecraft_windows:\n        spacecraft_windows[sat_name] = []\n    spacecraft_windows[sat_name].append(window)\n\n# Sort each spacecraft's windows by start time\nfor sat_name in spacecraft_windows:\n    spacecraft_windows[sat_name].sort(key=lambda w: w.start.jd())\n\n# Compute gaps between consecutive contacts\ngaps = []\nfor sat_name, sat_windows in spacecraft_windows.items():\n    for i in range(len(sat_windows) - 1):\n        gap_start = sat_windows[i].end\n        gap_end = sat_windows[i + 1].start\n        gap_duration = gap_end - gap_start  # Duration in seconds\n\n        gaps.append(\n            {\n                \"spacecraft\": sat_name,\n                \"gap_start\": gap_start,\n                \"gap_end\": gap_end,\n                \"duration\": gap_duration,\n                \"last_station\": sat_windows[i].location_name,\n                \"next_station\": sat_windows[i + 1].location_name,\n            }\n        )\n</code></pre> <p>The 10 longest contact gaps are shown below:</p> Spacecraft Gap Start (UTC) Gap End (UTC) Duration Last Station Next Station UMBRA-05 2025-11-09 22:59:29 2025-11-10 02:55:14 3h 55m 45s Svalbard Punta Arenas UMBRA-05 2025-11-08 22:43:05 2025-11-09 02:38:18 3h 55m 12s Svalbard Punta Arenas UMBRA-08 2025-11-11 04:43:40 2025-11-11 08:21:55 3h 38m 14s Punta Arenas Svalbard UMBRA-05 2025-11-08 03:56:53 2025-11-08 07:33:39 3h 36m 45s Punta Arenas Svalbard UMBRA-05 2025-11-07 03:38:10 2025-11-07 07:14:41 3h 36m 30s Punta Arenas Svalbard UMBRA-05 2025-11-12 03:32:20 2025-11-12 07:08:13 3h 35m 53s Punta Arenas Svalbard UMBRA-08 2025-11-12 00:21:54 2025-11-12 03:41:34 3h 19m 39s Awarua Punta Arenas UMBRA-08 2025-11-07 00:15:23 2025-11-07 03:34:59 3h 19m 35s Awarua Punta Arenas UMBRA-08 2025-11-09 00:01:39 2025-11-09 03:20:49 3h 19m 9s Awarua Punta Arenas UMBRA-05 2025-11-07 23:02:40 2025-11-08 02:20:18 3h 17m 38s Awarua Punta Arenas <p>The distribution of gaps for the constellation is shown in this histogram:</p> <pre><code>gap_durations = [g[\"duration\"] for g in gaps]\nmean_gap = np.mean(gap_durations)\nmedian_gap = np.median(gap_durations)\nmin_gap = np.min(gap_durations)\nmax_gap = np.max(gap_durations)\n\nprint(f\"  Mean: {bh.format_time_string(mean_gap)}\")\nprint(f\"  Median: {bh.format_time_string(median_gap)}\")\nprint(f\"  Min: {bh.format_time_string(min_gap)}\")\nprint(f\"  Max: {bh.format_time_string(max_gap)}\")\n\n# Create gap distribution histogram\nprint(\"\\nCreating gap distribution histogram...\")\ngap_durations_hours = [d / 3600.0 for d in gap_durations]  # Convert to hours\n\nfig_histogram = go.Figure(\n    data=[\n        go.Histogram(\n            x=gap_durations_hours,\n            nbinsx=40,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Gap Duration: %{x:.1f} hours&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\nfig_histogram.update_layout(\n    title=\"Umbra Constellation Communication Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {bh.format_time_string(mean_gap)}&lt;br&gt;\"\n            f\"Median: {bh.format_time_string(median_gap)}&lt;br&gt;\"\n            f\"Max: {bh.format_time_string(max_gap)}\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.95,\n            y=0.97,\n            xanchor=\"right\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n</code></pre> <p>To better understand what percentage of gaps fall below a certain duration, we create a cumulative distribution plot. This shows the percentage of gaps that are less than or equal to each duration value:</p> <pre><code>sorted_gap_durations_hours = sorted(gap_durations_hours)\ncumulative_percentages = [\n    (i + 1) / len(sorted_gap_durations_hours) * 100\n    for i in range(len(sorted_gap_durations_hours))\n]\n\n# Create cumulative distribution figure\nfig_cumulative = go.Figure(\n    data=[\n        go.Scatter(\n            x=sorted_gap_durations_hours,\n            y=cumulative_percentages,\n            mode=\"lines\",\n            line=dict(color=\"steelblue\", width=2.5),\n            hovertemplate=\"Gap Duration: %{x:.2f} hours&lt;br&gt;Cumulative: %{y:.1f}%&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\n# Add reference lines for key percentiles\npercentile_values = {\n    25: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.25)],\n    50: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.50)],\n    75: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.75)],\n    90: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.90)],\n}\n\nshapes = []\nannotations = []\nfor percentile, value in percentile_values.items():\n    # Add horizontal line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=0,\n            x1=value,\n            y0=percentile,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add vertical line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=value,\n            x1=value,\n            y0=0,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add annotation\n    annotations.append(\n        dict(\n            x=value,\n            y=percentile,\n            text=f\"P{percentile}: {value:.2f}h\",\n            showarrow=False,\n            xanchor=\"left\",\n            yanchor=\"bottom\",\n            xshift=5,\n            yshift=5,\n            font=dict(size=9, color=\"gray\"),\n        )\n    )\n\nfig_cumulative.update_layout(\n    title=\"Umbra Constellation Cumulative Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Cumulative Percentage (%)\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    shapes=shapes,\n    annotations=annotations,\n    yaxis=dict(range=[0, 105]),\n)\n</code></pre> <p>The cumulative distribution plot includes reference lines at the 25th, 50th, 75th, and 90th percentiles, making it easy to determine what fraction of gaps are below a specific threshold.</p>"},{"location":"examples/max_communications_gap.html#contact-gap-visualization","title":"Contact Gap Visualization","text":"<p>Finally, we'll visualize the 3 longest gaps on a ground track plot to see where they occur. For each gap, we extract the satellite's ground track during that time period and plot it as a colored segment. We also interpolate to the \u00b1180\u00b0 edges to avoid visual gaps at the antimeridian. This type of visualization can be helpful in understanding ground network design and where additional ground stations might help:</p> <pre><code># Get the top 3 gaps\ntop_3_gaps = gaps[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\n# For each gap, we need to extract the ground track segment during that period\n# We'll need to get the propagator for each gap's spacecraft\ngap_segments_all = []\n\nfor gap_idx, gap in enumerate(top_3_gaps):\n    # Create label with spacecraft name and station transition\n    gap_label = f\"{gap['spacecraft']}, {gap['last_station']} \u2192 {gap['next_station']}\"\n\n    # Find the propagator for this gap's spacecraft\n    sat_prop = None\n    for prop in umbra_props:\n        if prop.get_name() == gap[\"spacecraft\"]:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {gap['spacecraft']}\")\n        continue\n\n    # Get states and epochs from the propagator's trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ground track points during this gap period\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if gap[\"gap_start\"] &lt;= ep &lt;= gap[\"gap_end\"]:\n            # Convert to geodetic coordinates\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    # Split ground track at antimeridian crossings for proper plotting\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    # Interpolate segments to the edge at \u00b1180\u00b0 to avoid visual gaps\n    # When a track crosses the antimeridian, add interpolated edge points\n    interpolated_segments = []\n    for seg_idx, (lon_seg, lat_seg) in enumerate(segments):\n        lon_list = list(lon_seg)\n        lat_list = list(lat_seg)\n\n        # Check if this segment needs edge interpolation\n        # If first point is not at edge but previous segment exists, interpolate start\n        if seg_idx &gt; 0 and len(lon_list) &gt; 0:\n            prev_lon, prev_lat = (\n                segments[seg_idx - 1][0][-1],\n                segments[seg_idx - 1][1][-1],\n            )\n            curr_lon, curr_lat = lon_list[0], lat_list[0]\n\n            # Check if there was an antimeridian crossing\n            if abs(curr_lon - prev_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if prev_lon &gt; 0:  # Previous segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon + 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n                else:  # Previous segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon - 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n\n        # Check if segment should be extended to the edge at the end\n        if seg_idx &lt; len(segments) - 1 and len(lon_list) &gt; 0:\n            curr_lon, curr_lat = lon_list[-1], lat_list[-1]\n            next_lon, next_lat = (\n                segments[seg_idx + 1][0][0],\n                segments[seg_idx + 1][1][0],\n            )\n\n            # Check if there will be an antimeridian crossing\n            if abs(next_lon - curr_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if curr_lon &gt; 0:  # Current segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon + 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n                else:  # Current segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon - 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n\n        interpolated_segments.append((lon_list, lat_list))\n\n    gap_segments_all.append(\n        {\n            \"segments\": interpolated_segments,\n            \"color\": gap_colors[gap_idx],\n            \"label\": gap_label,\n            \"spacecraft\": gap[\"spacecraft\"],\n            \"duration\": gap[\"duration\"],\n        }\n    )\n\n    print(\n        f\"  Gap {gap_idx + 1}: {len(gap_lons)} points, {len(interpolated_segments)} segments\"\n    )\n\n# Create base plot with KSAT stations only (matplotlib backend for SVG output)\n\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": ksat_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=500e3,  # Approximate Umbra altitude\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot each gap segment\nax = fig_groundtrack.get_axes()[0]\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        ax.plot(\n            lon_seg,\n            lat_seg,\n            color=gap_data[\"color\"],\n            linewidth=1.5,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=gap_data[\"label\"] if i == 0 else \"\",\n        )\n\n# Add legend with high zorder to render on top\nlegend = ax.legend(loc=\"lower left\", fontsize=10)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Umbra Constellation: Top 3 Longest Communication Gaps\\n\"\n    \"KSAT Network (5 stations, 5\u00b0 elevation)\",\n    fontsize=12,\n)\n</code></pre>"},{"location":"examples/max_communications_gap.html#full-code-example","title":"Full Code Example","text":"max_communications_gap.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for all active satellites as propagators and filter for Umbra\nprint(\"Downloading active satellite TLEs from CelesTrak...\")\nstart_time = time.time()\nall_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Umbra satellites (name contains \"UMBRA\")\numbra_props = [prop for prop in all_active_props if \"UMBRA\" in prop.get_name().upper()]\nprint(f\"Found {len(umbra_props)} Umbra satellites\")\nelapsed = time.time() - start_time\n\n# Load specific KSAT ground stations\nprint(\"\\nLoading KSAT ground stations...\")\nstart_time = time.time()\nall_ksat = bh.datasets.groundstations.load(\"ksat\")\n\n# Filter for the 5 specific stations mentioned in the problem\nstation_names = [\"Svalbard\", \"Punta Arenas\", \"Hartebeesthoek\", \"Awarua\", \"Athens\"]\nksat_stations = [s for s in all_ksat if s.get_name() in station_names]\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(ksat_stations)} KSAT ground stations in {elapsed:.2f} seconds:\")\nfor station in ksat_stations:\n    print(f\"  - {station.get_name()}\")\n\n# Create 3D constellation visualization\nprint(\"\\nPropagating Umbra satellites for one orbit each...\")\nstart_time = time.time()\nfor prop in umbra_props:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\n\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in umbra_props\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nelapsed = time.time() - start_time\nprint(f\"Created 3D visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagators and compute 7-day access windows\nprint(\"\\nComputing 7-day ground contacts...\")\nstart_time = time.time()\n\n# Reset all propagators\nfor prop in umbra_props:\n    prop.reset()\n\n# Define analysis period (7 days from first satellite's epoch)\nepoch_start = umbra_props[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for 7 days\nfor prop in umbra_props:\n    prop.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    ksat_stations, umbra_props, epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} contact windows in {elapsed:.2f} seconds.\")\n\n# Compute communication gaps per spacecraft\nprint(\"\\nComputing communication gaps...\")\nstart_time = time.time()\n\n# Group windows by spacecraft\nspacecraft_windows = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in spacecraft_windows:\n        spacecraft_windows[sat_name] = []\n    spacecraft_windows[sat_name].append(window)\n\n# Sort each spacecraft's windows by start time\nfor sat_name in spacecraft_windows:\n    spacecraft_windows[sat_name].sort(key=lambda w: w.start.jd())\n\n# Compute gaps between consecutive contacts\ngaps = []\nfor sat_name, sat_windows in spacecraft_windows.items():\n    for i in range(len(sat_windows) - 1):\n        gap_start = sat_windows[i].end\n        gap_end = sat_windows[i + 1].start\n        gap_duration = gap_end - gap_start  # Duration in seconds\n\n        gaps.append(\n            {\n                \"spacecraft\": sat_name,\n                \"gap_start\": gap_start,\n                \"gap_end\": gap_end,\n                \"duration\": gap_duration,\n                \"last_station\": sat_windows[i].location_name,\n                \"next_station\": sat_windows[i + 1].location_name,\n            }\n        )\n\n# Sort gaps by duration (longest first)\ngaps.sort(key=lambda g: g[\"duration\"], reverse=True)\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(gaps)} communication gaps in {elapsed:.2f} seconds.\")\n\n# Print top 10 gaps\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Top 10 Longest Communication Gaps\")\nprint(\"=\" * 100)\nprint(\n    f\"{'Spacecraft':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;25} {'Last\u2192Next Station':&lt;30}\"\n)\nprint(\"-\" * 100)\nfor i, gap in enumerate(gaps[:10]):\n    start_str = str(gap[\"gap_start\"]).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(gap[\"gap_end\"]).split(\".\")[0]\n    duration_str = bh.format_time_string(gap[\"duration\"], short=False)\n    station_str = f\"{gap['last_station']} \u2192 {gap['next_station']}\"\n    print(\n        f\"{gap['spacecraft']:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_str:&gt;25} {station_str:&lt;30}\"\n    )\nprint(\"=\" * 100)\n\n# Export top 10 gaps to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_gaps.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Spacecraft\",\n            \"Gap Start (UTC)\",\n            \"Gap End (UTC)\",\n            \"Duration\",\n            \"Last Station\",\n            \"Next Station\",\n        ]\n    )\n    for gap in gaps[:10]:  # Only export top 10\n        start_str = str(gap[\"gap_start\"]).split(\".\")[0]\n        end_str = str(gap[\"gap_end\"]).split(\".\")[0]\n        duration_str = bh.format_time_string(gap[\"duration\"], short=True)\n        writer.writerow(\n            [\n                gap[\"spacecraft\"],\n                start_str,\n                end_str,\n                duration_str,\n                gap[\"last_station\"],\n                gap[\"next_station\"],\n            ]\n        )\nprint(f\"\\n\u2713 Exported top 10 gaps to {csv_path}\")\n\n# Analyze gap distribution statistics\nprint(\"\\nGap Distribution Statistics:\")\ngap_durations = [g[\"duration\"] for g in gaps]\nmean_gap = np.mean(gap_durations)\nmedian_gap = np.median(gap_durations)\nmin_gap = np.min(gap_durations)\nmax_gap = np.max(gap_durations)\n\nprint(f\"  Mean: {bh.format_time_string(mean_gap)}\")\nprint(f\"  Median: {bh.format_time_string(median_gap)}\")\nprint(f\"  Min: {bh.format_time_string(min_gap)}\")\nprint(f\"  Max: {bh.format_time_string(max_gap)}\")\n\n# Create gap distribution histogram\nprint(\"\\nCreating gap distribution histogram...\")\ngap_durations_hours = [d / 3600.0 for d in gap_durations]  # Convert to hours\n\nfig_histogram = go.Figure(\n    data=[\n        go.Histogram(\n            x=gap_durations_hours,\n            nbinsx=40,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Gap Duration: %{x:.1f} hours&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\nfig_histogram.update_layout(\n    title=\"Umbra Constellation Communication Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {bh.format_time_string(mean_gap)}&lt;br&gt;\"\n            f\"Median: {bh.format_time_string(median_gap)}&lt;br&gt;\"\n            f\"Max: {bh.format_time_string(max_gap)}\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.95,\n            y=0.97,\n            xanchor=\"right\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n\n# Create cumulative distribution plot\nprint(\"\\nCreating cumulative distribution plot...\")\n# Sort gap durations and compute cumulative percentages\nsorted_gap_durations_hours = sorted(gap_durations_hours)\ncumulative_percentages = [\n    (i + 1) / len(sorted_gap_durations_hours) * 100\n    for i in range(len(sorted_gap_durations_hours))\n]\n\n# Create cumulative distribution figure\nfig_cumulative = go.Figure(\n    data=[\n        go.Scatter(\n            x=sorted_gap_durations_hours,\n            y=cumulative_percentages,\n            mode=\"lines\",\n            line=dict(color=\"steelblue\", width=2.5),\n            hovertemplate=\"Gap Duration: %{x:.2f} hours&lt;br&gt;Cumulative: %{y:.1f}%&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\n# Add reference lines for key percentiles\npercentile_values = {\n    25: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.25)],\n    50: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.50)],\n    75: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.75)],\n    90: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.90)],\n}\n\nshapes = []\nannotations = []\nfor percentile, value in percentile_values.items():\n    # Add horizontal line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=0,\n            x1=value,\n            y0=percentile,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add vertical line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=value,\n            x1=value,\n            y0=0,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add annotation\n    annotations.append(\n        dict(\n            x=value,\n            y=percentile,\n            text=f\"P{percentile}: {value:.2f}h\",\n            showarrow=False,\n            xanchor=\"left\",\n            yanchor=\"bottom\",\n            xshift=5,\n            yshift=5,\n            font=dict(size=9, color=\"gray\"),\n        )\n    )\n\nfig_cumulative.update_layout(\n    title=\"Umbra Constellation Cumulative Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Cumulative Percentage (%)\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    shapes=shapes,\n    annotations=annotations,\n    yaxis=dict(range=[0, 105]),\n)\n\n# Create ground track visualization for top 3 longest gaps\nprint(\"\\nCreating ground track visualization for top 3 longest gaps...\")\nstart_time = time.time()\n\n# Get the top 3 gaps\ntop_3_gaps = gaps[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\n# For each gap, we need to extract the ground track segment during that period\n# We'll need to get the propagator for each gap's spacecraft\ngap_segments_all = []\n\nfor gap_idx, gap in enumerate(top_3_gaps):\n    # Create label with spacecraft name and station transition\n    gap_label = f\"{gap['spacecraft']}, {gap['last_station']} \u2192 {gap['next_station']}\"\n\n    # Find the propagator for this gap's spacecraft\n    sat_prop = None\n    for prop in umbra_props:\n        if prop.get_name() == gap[\"spacecraft\"]:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {gap['spacecraft']}\")\n        continue\n\n    # Get states and epochs from the propagator's trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ground track points during this gap period\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if gap[\"gap_start\"] &lt;= ep &lt;= gap[\"gap_end\"]:\n            # Convert to geodetic coordinates\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    # Split ground track at antimeridian crossings for proper plotting\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    # Interpolate segments to the edge at \u00b1180\u00b0 to avoid visual gaps\n    # When a track crosses the antimeridian, add interpolated edge points\n    interpolated_segments = []\n    for seg_idx, (lon_seg, lat_seg) in enumerate(segments):\n        lon_list = list(lon_seg)\n        lat_list = list(lat_seg)\n\n        # Check if this segment needs edge interpolation\n        # If first point is not at edge but previous segment exists, interpolate start\n        if seg_idx &gt; 0 and len(lon_list) &gt; 0:\n            prev_lon, prev_lat = (\n                segments[seg_idx - 1][0][-1],\n                segments[seg_idx - 1][1][-1],\n            )\n            curr_lon, curr_lat = lon_list[0], lat_list[0]\n\n            # Check if there was an antimeridian crossing\n            if abs(curr_lon - prev_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if prev_lon &gt; 0:  # Previous segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon + 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n                else:  # Previous segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon - 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n\n        # Check if segment should be extended to the edge at the end\n        if seg_idx &lt; len(segments) - 1 and len(lon_list) &gt; 0:\n            curr_lon, curr_lat = lon_list[-1], lat_list[-1]\n            next_lon, next_lat = (\n                segments[seg_idx + 1][0][0],\n                segments[seg_idx + 1][1][0],\n            )\n\n            # Check if there will be an antimeridian crossing\n            if abs(next_lon - curr_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if curr_lon &gt; 0:  # Current segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon + 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n                else:  # Current segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon - 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n\n        interpolated_segments.append((lon_list, lat_list))\n\n    gap_segments_all.append(\n        {\n            \"segments\": interpolated_segments,\n            \"color\": gap_colors[gap_idx],\n            \"label\": gap_label,\n            \"spacecraft\": gap[\"spacecraft\"],\n            \"duration\": gap[\"duration\"],\n        }\n    )\n\n    print(\n        f\"  Gap {gap_idx + 1}: {len(gap_lons)} points, {len(interpolated_segments)} segments\"\n    )\n\n# Create base plot with KSAT stations only (matplotlib backend for SVG output)\n\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": ksat_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=500e3,  # Approximate Umbra altitude\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot each gap segment\nax = fig_groundtrack.get_axes()[0]\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        ax.plot(\n            lon_seg,\n            lat_seg,\n            color=gap_data[\"color\"],\n            linewidth=1.5,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=gap_data[\"label\"] if i == 0 else \"\",\n        )\n\n# Add legend with high zorder to render on top\nlegend = ax.legend(loc=\"lower left\", fontsize=10)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Umbra Constellation: Top 3 Longest Communication Gaps\\n\"\n    \"KSAT Network (5 stations, 5\u00b0 elevation)\",\n    fontsize=12,\n)\n\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n</code></pre>"},{"location":"examples/max_communications_gap.html#see-also","title":"See Also","text":"<ul> <li>Access Computation - Understanding access windows and constraints</li> <li>KSAT Ground Stations - Ground station dataset documentation</li> <li>CelesTrak Dataset - Downloading TLE data</li> <li>String Formatting - Formatting time durations</li> <li>Predicting Ground Contacts - Related ground contact analysis example</li> </ul>"},{"location":"examples/visualizing_gps.html","title":"Visualizing GPS Satellite Orbits","text":"<p>In this example we'll show how to visualize the orbits of GPS satellites using Brahe. We'll download the latest TLE data for the GPS constellation from CelesTrak, propagate each satellite for one orbit, and create an interactive 3D plot showing their trajectories around Earth.</p> <p>This example is similar to the Downloading &amp; Visualizing TLE Data For Starlink Satellites example, but but adds in propagation for one full orbit before visualization.</p>"},{"location":"examples/visualizing_gps.html#initialize-earth-orientation-parameters","title":"Initialize Earth Orientation Parameters","text":"<p>Before starting, we need to import brahe and ensure that we have Earth orientation parameters initialized. We'll use <code>initialize_eop()</code>, which provides a CachingEOPProvider to deliver up-to-date Earth orientation parameters.</p> <pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n</code></pre>"},{"location":"examples/visualizing_gps.html#download-gps-tles","title":"Download GPS TLEs","text":"<p>We'll use the CelesTrak dataset to fetch the latest TLE data for all GPS satellites. The <code>get_tles_as_propagators</code> function downloads the data and creates SGP4 propagators in one step:</p> <pre><code>start_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"gps-ops\", 60.0)\nelapsed = time.time() - start_time\n</code></pre>"},{"location":"examples/visualizing_gps.html#propagate-orbits","title":"Propagate orbits","text":"<p>Next, we'll propagate each satellite for one full orbit based on its semi-major axis:</p> <pre><code>for prop in propagators:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\nte = time.time() - ts\n</code></pre> <p>The line  <pre><code>    orbital_period = bh.orbital_period(prop.semi_major_axis)\n</code></pre> computes the or orbital period of the satellite by converting the semi-major axis associated with the <code>SGP4Propagator</code> into an orbital period using Brahe's <code>orbital_period</code> function.</p> <p>It then propagates the satellite to one full orbit past its epoch using the <code>propagate_to</code> method to ensure that the trajectory contains position data for one complete orbit.</p>"},{"location":"examples/visualizing_gps.html#visualize-in-3d","title":"Visualize in 3D","text":"<p>We'll create an interactive 3D visualization of the entire Starlink constellation using Plotly. We'll use the Natural Earth 50m texture for a realistic Earth representation:</p> <pre><code>fig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the complete Starlink constellation orbiting Earth. The interactive visualization allows you to rotate, zoom, and pan to explore the satellite positions from different angles.</p>"},{"location":"examples/visualizing_gps.html#full-code-example","title":"Full Code Example","text":"visualizing_gps.py<pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Download TLE data for all GPS satellites from CelesTrak\n# The get_tles_as_propagators function:\n#   - Downloads latest TLE data (cached for 6 hours)\n#   - Parses each TLE into an SGP4 propagator\n#   - Sets default propagation step size (60 seconds)\nprint(\"Downloading GPS TLEs from CelesTrak...\")\nstart_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"gps-ops\", 60.0)\nelapsed = time.time() - start_time\nprint(\n    f\"Initialized propagators for {len(propagators)} GPS satellites in {elapsed:.2f} seconds.\"\n)\n\nts = time.time()\n# Propagate each satellite one orbit\nfor prop in propagators:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\nte = time.time() - ts\nprint(f\"Propagated all satellites to one orbit in {te:.2f} seconds.\")\n\n# Create interactive 3D plot with Earth texture\nprint(\"\\nCreating 3D visualization of satellites...\")\nts = time.time()\nfig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nte = time.time() - ts\nprint(f\"Created base 3D plot in {te:.2f} seconds.\")\n</code></pre>"},{"location":"examples/visualizing_gps.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Dataset - More details on using CelesTrak datasets</li> <li>Two-Line Elements - Understanding TLE format and usage</li> <li>SGP4 Propagator - How SGP4 works for orbit propagation</li> <li>3D Trajectory Plotting - Advanced options for trajectory visualization</li> </ul>"},{"location":"examples/visualizing_starlink.html","title":"Downloading &amp; Visualizing TLE Data For Starlink Satellites","text":"<p>Slow Page</p> <p>This page may load slowly due to the embedded interactive 3D plot. Please be patient while it loads.</p> <p>This example demonstrates how to download Two-Line Element (TLE) data from the CelesTrak dataset using the Brahe library, and then visualize the complete Starlink satellite constellation in an interactive 3D plot.</p>"},{"location":"examples/visualizing_starlink.html#initialize-earth-orientation-parameters","title":"Initialize Earth Orientation Parameters","text":"<p>Before starting, we need to import brahe and ensure that we have Earth orientation parameters initialized. We'll use <code>initialize_eop()</code>, which provides a CachingEOPProvider to deliver up-to-date Earth orientation parameters.</p> <pre><code>import time\nimport brahe as bh\n</code></pre>"},{"location":"examples/visualizing_starlink.html#download-starlink-tles","title":"Download Starlink TLEs","text":"<p>We'll use the CelesTrak dataset to fetch the latest TLE data for all Starlink satellites. The <code>get_tles_as_propagators</code> function downloads the data and creates SGP4 propagators in one step:</p> <pre><code>print(\"Downloading Starlink TLEs from CelesTrak...\")\nstart_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"starlink\", 60.0)\nelapsed = time.time() - start_time\nprint(\n    f\"Initialized propagators for {len(propagators)} Starlink satellites in {elapsed:.2f} seconds.\"\n</code></pre>"},{"location":"examples/visualizing_starlink.html#inspect-satellite-data","title":"Inspect Satellite Data","text":"<p>Let's examine the properties of the first satellite to understand the orbital parameters:</p> <pre><code># Inspect the first satellite\nfirst_sat = propagators[0]\nprint(f\"\\nFirst satellite: {first_sat.get_name()}\")\nprint(f\"Epoch: {first_sat.epoch}\")\nprint(f\"Semi-major axis: {first_sat.semi_major_axis / 1000:.1f} km\")\nprint(f\"Inclination: {first_sat.inclination:.1f} degrees\")\n</code></pre>"},{"location":"examples/visualizing_starlink.html#visualize-in-3d","title":"Visualize in 3D","text":"<p>We'll create an interactive 3D visualization of the entire Starlink constellation using Plotly. We'll use the Natural Earth 50m texture for a realistic Earth representation:</p> <pre><code>ts = time.time()\nfig = bh.plot_trajectory_3d(\n    [],  # Empty trajectory list; we'll add markers for each satellite\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=3.0,\n    sphere_resolution_lon=600,  # Reduce sphere texture resolution for performance\n    sphere_resolution_lat=300,\n</code></pre> <p>Finally, we'll add points for all satellites at the current epoch:</p> <pre><code># Get the current time for display\nepc = bh.Epoch.now()\n\n# For each satellite, add a marker at the current position\nfor prop in propagators:\n    state = prop.state_eci(epc)\n    fig.add_scatter3d(\n        x=[state[0] / 1000],\n        y=[state[1] / 1000],\n        z=[state[2] / 1000],\n        mode=\"markers\",\n        marker=dict(size=2, color=\"white\"),\n        name=prop.get_name(),\n        showlegend=False,\n    )\nte = time.time() - ts\nprint(f\"Added satellite markers in {te:.2f} seconds.\")\n</code></pre> <p>The resulting plot shows the complete Starlink constellation orbiting Earth. The interactive visualization allows you to rotate, zoom, and pan to explore the satellite positions from different angles.</p>"},{"location":"examples/visualizing_starlink.html#full-code-example","title":"Full Code Example","text":"visualizing_starlink.py<pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Download TLE data for all Starlink satellites from CelesTrak\n# The get_tles_as_propagators function:\n#   - Downloads latest TLE data (cached for 6 hours)\n#   - Parses each TLE into an SGP4 propagator\n#   - Sets default propagation step size (60 seconds)\nprint(\"Downloading Starlink TLEs from CelesTrak...\")\nstart_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"starlink\", 60.0)\nelapsed = time.time() - start_time\nprint(\n    f\"Initialized propagators for {len(propagators)} Starlink satellites in {elapsed:.2f} seconds.\"\n)\n\n# Inspect the first satellite\nfirst_sat = propagators[0]\nprint(f\"\\nFirst satellite: {first_sat.get_name()}\")\nprint(f\"Epoch: {first_sat.epoch}\")\nprint(f\"Semi-major axis: {first_sat.semi_major_axis / 1000:.1f} km\")\nprint(f\"Inclination: {first_sat.inclination:.1f} degrees\")\nprint(f\"Eccentricity: {first_sat.eccentricity:.6f}\")\n\n\n# Create interactive 3D plot with Earth texture\nprint(\"\\nCreating 3D visualization of satellites...\")\nts = time.time()\nfig = bh.plot_trajectory_3d(\n    [],  # Empty trajectory list; we'll add markers for each satellite\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=3.0,\n    sphere_resolution_lon=600,  # Reduce sphere texture resolution for performance\n    sphere_resolution_lat=300,\n)\nte = time.time() - ts\nprint(f\"Created base 3D plot in {te:.2f} seconds.\")\n\nts = time.time()\n# Get the current time for display\nepc = bh.Epoch.now()\n\n# For each satellite, add a marker at the current position\nfor prop in propagators:\n    state = prop.state_eci(epc)\n    fig.add_scatter3d(\n        x=[state[0] / 1000],\n        y=[state[1] / 1000],\n        z=[state[2] / 1000],\n        mode=\"markers\",\n        marker=dict(size=2, color=\"white\"),\n        name=prop.get_name(),\n        showlegend=False,\n</code></pre>"},{"location":"examples/visualizing_starlink.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Dataset - More details on using CelesTrak datasets</li> <li>Two-Line Elements - Understanding TLE format and usage</li> <li>SGP4 Propagator - How SGP4 works for orbit propagation</li> <li>3D Trajectory Plotting - Advanced options for trajectory visualization</li> </ul>"},{"location":"learn/index.html","title":"User Guide","text":"<p>Here you will find the introductory and conceptual documentation for Brahe. This is the main user guide for the package, and is intended to help you get started with using Brahe for your work.</p> <p>Contributions Welcome</p> <p>If you find something missing or unclear in this documentation, particularly feedback on the conceptual flow, how things are introduced or otherwise, please consider contributing! We welcome contributions of all kinds, including:</p> <ul> <li>Reporting issues or suggesting improvements</li> <li>Writing new documentation pages or improving existing ones</li> <li>Adding examples or tutorials</li> <li>Enhancing the codebase with new features or bug fixes</li> </ul> <p>Check out our contributing guide to get started.</p>"},{"location":"learn/index.html#module-structure","title":"Module Structure","text":"<p>The Brahe package is organized into several key modules, each providing providing some core functionality. We can generally think of these modules as falling into four main categories: Foundational Modules, Orbit &amp; Attitude Representations, State Propagation &amp; Dynamics, and Applications. Below is an overview of the main modules and their purposes:</p>"},{"location":"learn/index.html#foundational-modules","title":"Foundational Modules","text":"<p>These modules provide the basic building blocks for the package, including utilities for time handling, constants, and Earth Orientation Parameters (EOP).</p> <ul> <li>Constants: This module contains physical and mathematical constants used throughout the package.</li> <li>Time: This module provides tools for representing and dealing with time. It provides the ubiquitous Epoch class which is the basis for all time handling in Brahe.</li> <li>EOP: This module handles Earth Orientation Parameters, which are essential for accurate coordinate transformations and orbit propagation. An Earth Orientation Provider is required for many operations in Brahe. There are multiple kinds provided, but <code>initialize_eop()</code> is the easiest way to get started.</li> </ul>"},{"location":"learn/index.html#orbit-attitude-representations","title":"Orbit &amp; Attitude Representations","text":"<p>These modules help transform between different state and coordinate representations for both spacecraft orbits (position and velocity) and attitudes (orientation).</p> <ul> <li>Coordinates: This module provides functions to convert between different coordinate systems, such as Cartesian, Geocentric, Geodetic, and Topocentric coordinates.</li> <li>Frames: This module deals with reference frames, including Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) frames, and provides rotation matrices and state transformations between them.</li> <li>Orbits: This module provides functions for working with orbital elements, including conversions between Keplerian elements and Cartesian states, as well as handling special orbit types like Sun-synchronous orbits and Two-Line Elements (TLEs).</li> <li>Attitude: This module provides tools for representing and manipulating spacecraft attitudes using rotation matrices, quaternions, Euler angles, and Euler axes.</li> </ul>"},{"location":"learn/index.html#state-propagation-dynamics","title":"State Propagation &amp; Dynamics","text":"<p>These modules focus on propagating spacecraft states over time using various dynamics models. It also provides methods for representing these state trajectories.</p> <ul> <li>Trajectories: This module defines traits and structures for representing dynamics trajectories, including orbit trajectories.</li> <li>Keplerian Propagator: This module implements a simple Keplerian propagator for orbit propagation based on Kepler's laws.</li> <li>SGP Propagator: This module implements the SGP (Simplified General Perturbations) propagator, a widely used method for propagating Earth-orbiting satellites, in particular those defined by TLEs.</li> <li>Orbit Dynamics: This module implements various force models used in orbit propagation, such as gravity, drag, solar radiation pressure, and more.</li> </ul>"},{"location":"learn/index.html#applications","title":"Applications","text":"<p>These modules provide higher-level functionalities for specific applications, such as working with datasets, computing access windows, and plotting.</p> <ul> <li>Datasets: This module provides access to common datasets used in space applications, such as ground stations and satellite ephemeris catalogs (e.g., Celestrak).</li> <li>Access Computation: This module provides tools for computing access windows between satellites and terrestrial locations, including defining access constraints and computing access properties.</li> <li>Plotting: This module offers functions for visualizing satellite data, including ground tracks, state vectors, orbital elements, and access geometry.</li> </ul> <p>Each of these modules are defined to have composable, interoperable interfaces so that you can easily combine functionality from different modules to accomplish your tasks. As you explore the documentation further, you'll find detailed explanations and examples for each module to help you understand how to use them effectively.</p> <p>For detailed information on all functions, classes, and methods available in each module, please refer to the Python API Reference and Rust API Reference.</p>"},{"location":"learn/constants.html","title":"Constants","text":"<p>The Constants module provides frequently occuring fundamental mathematical  and astronomical constants.</p>"},{"location":"learn/constants.html#mathematical","title":"Mathematical","text":"<p>Mathematical constants provide quick-reference to common factors.</p> Constant Description <code>DEG2RAD</code> Factor to convert from degrees and radians. <code>RAD2DEG</code> Factor to convert from radians to degrees. <code>AS2RAD</code> Factor to convert from arc-seconds to radians. <code>RAD2AS</code> Factor to convert from radians to arc-seconds."},{"location":"learn/constants.html#time","title":"Time","text":"<p>Time constants are used for conversions between different time systems.</p> Constant Description Value Units Source <code>MJD_ZERO</code> Offset between Modified Julian Date and Julian Date time scales. $t_{mjd} + {mjd}{0} = t{jd $ \\(2400000.5\\) Days Montenbruck and Gill <sup>1</sup> <code>MJD2000</code> Modified Julian date of J2000 Epoch. January 1, 2000 12:00:00. \\(51544.5\\) Days Montenbruck and Gill <sup>1</sup> <code>GPS_TAI</code> Constant offset from TAI to GPS time scale. \\(t_{gps} = t_{tai} + \\Delta_{GPS-TAI}\\) \\(19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_GPS</code> Constant offset from GPS to TAI time scale. \\(t_{tai} = t_{gps}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; + \\Delta_{TAI-GPS}\\) \\(-19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_TAI</code> Constant offset from TT to TAI time scale. \\(t_{tt} = t_{tai} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-TAI}\\) \\(32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_TT</code> Constant offset from TAI to TT time scale. \\(t_{tai} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TAI-TT}\\) \\(-32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_TT</code> Constant offset from GPS to TT time scale. \\(t_{gps} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{GPS-TT}\\) \\(-51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_GPS</code> Constant offset from TT to GPS time scale. \\(t_{tt} = t_{gps} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-GPS}\\) \\(51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_ZERO</code> Modified Julian Date of the start of the GPS time scale in the GPS time scale. This date is January 6, 1980 00:00:00 hours reckoned in the UTC time scale \\(44244.0\\) Days Montenbruck and Gill <sup>1</sup>"},{"location":"learn/constants.html#physical-constants","title":"Physical Constants","text":"<p>Physical constants are fundamental physical constants or properties of  astronomical bodies. While these values are estimated they are considered to  be well known and do not change frequently.</p> Constant Description Value Units Source <code>C_LIGHT</code> Speed of light in vacuum. \\(299792458.0\\) \\(\\frac{m}{s}\\) Vallado <sup>2</sup> <code>AU</code> Astronominal Unit. TDB reference frame compatible value equal to the mean distance of the Earth from the Sun. \\(1.49597870700 \\times 10^{11}\\) \\(m\\) G\u00e9rard and Luzum <sup>3</sup> <code>R_EARTH</code> Earth's semi-major axis as defined by the Grace GGM05S gravity model. \\(.378136.3\\) \\(m\\) Ries et al. <sup>4</sup> <code>WGS84_A</code> Earth geoid model's semi-major axis as defined by the World Geodetic System 1984 edition. \\(6378137.0\\) \\(m\\) NIMA Technical Report <sup>5</sup> <code>WGS84_F</code> Earth geoid model's flattening as defined by the World Geodetic System 1984 edition. \\(\\frac{1.0}{298.257223563}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>GM_EARTH</code> Gravitational Constant of the Earth. \\(3.986004415 \\times 10^{14}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>ECC_EARTH</code> Earth geoid model's eccentricity. \\(8.1819190842622 \\times 10^{-2}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>J2_EARTH</code> Earth's first zonal harmonic. Also known as Earth's oblateness. \\(0.0010826358191967\\) Dimensionless Montenbruck and Gill <sup>1</sup> <code>OMEGA_EARTH</code> Earth's axial rotation rate. \\(7.292115146706979 \\times 10^{-5}\\) \\(\\frac{rad}{s}\\) Vallado <sup>2</sup> <code>GM_SUN</code> Gravitational constant of the Sun. \\(1.32712440041939400 \\times 10^{20}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Nominal photosphere radius of the Sun. \\(6.957 \\times 10^{8}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>P_SUN</code> Nominal solar radiation pressure at 1 AU. \\(4.560 \\times 10^{-6}\\) \\(\\frac{N}{m^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Equatorial radius of the Moon. \\(1.738 \\times 10^{6}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>GM_MOON</code> Gravitational constant of the Moon. \\(4.902800066 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MERCURY</code> Gravitational constant of the Mercury. \\(2.2031780 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_VENUS</code> Gravitational constant of the Venus. \\(3.248585920 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MARS</code> Gravitational constant of the Mars. \\(4.282837521 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_JUPITER</code> Gravitational constant of the Jupiter. \\(1.267127648 \\times 10^{17}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_SATURN</code> Gravitational constant of the Saturn. \\(3.79405852 \\times 10^{16}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_URANUS</code> Gravitational constant of the Uranus. \\(5.7945486 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_NEPTUNE</code> Gravitational constant of the Neptune. \\(6.836527100580 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_PLUTO</code> Gravitational constant of the Pluto. \\(9.770 \\times 10^{11}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <ol> <li> <p>O. Montenbruck, and E. Gill, Satellite Orbits: Models, Methods and Applications, 2012\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010\u00a0\u21a9\u21a9</p> </li> <li> <p>P. G\u00e9rard and B. Luzum, IERS Technical Note 36, 2010\u00a0\u21a9</p> </li> <li> <p>J. Ries, S. Bettadpur, R. Eanes, Z. Kang, U. Ko, C. McCullough, P. Nagel, N. Pie, S. Poole, T. Richter, H. Save, and B. Tapley, Development and Evaluation of the Global Gravity Model GGM05, 2016\u00a0\u21a9</p> </li> <li> <p>Department of Defense World Geodetic System 1984, Its Definition and Relationships With Local Geodetic Systems\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"learn/frame_transformations.html","title":"Frame Transformations","text":"<p>Reference frame transformations are a fundamental aspect of astrodynamics. Different tasks require working in different reference frames, and accurate transformations between these frames are essential for precise calculations. The two primary reference frames used in orbital mechanics are:</p> <ul> <li>ECI (Earth-Centered Inertial): A non-rotating frame fixed with respect to distant stars. It is an inertial frame and can be used for integration of equations of motion.</li> <li>ECEF (Earth-Centered Earth-Fixed): A rotating frame fixed to the Earth's surface, ideal for computing positions and motions relative to terrestrial locations and observers.</li> </ul> <p>Brahe uses the IAU SOFA (Standards of Fundamental Astronomy) library reference frame transformations under the hood to provide speed, accuracy, and reliability. The implementation follows the IAU 2006/2000A precession-nutation model with Celestial Intermediate Origin (CIO) based transformation. Brahe follows the IERS conventions for reference system definition. To learn more about these models, refer to the IERS Conventions (2010).</p>"},{"location":"learn/frame_transformations.html#reference-frames","title":"Reference Frames","text":""},{"location":"learn/frame_transformations.html#geocentric-celestial-reference-frame-gcrf","title":"Geocentric Celestial Reference Frame (GCRF)","text":"<p>The Geocentric Celestial Reference Frame (GCRF) is the standard modern inertial reference frame for Earth-orbiting satellites. It is aligned with the International Celestial Reference Frame (ICRF) and realized using the positions of distant quasars. The GCRF has its origin at the Earth's center of mass and its axes are fixed with respect to distant stars.</p> <p>The GCRF is an Earth-centered inertial (ECI) frame, meaning it does not rotate with the Earth.</p>"},{"location":"learn/frame_transformations.html#international-terrestrial-reference-frame-itrf","title":"International Terrestrial Reference Frame (ITRF)","text":"<p>The International Terrestrial Reference Frame (ITRF) is the standard Earth-fixed reference frame maintained by the International Earth Rotation and Reference Systems Service (IERS). The ITRF rotates with the Earth and its axes are aligned with the Earth's geographic coordinate system (polar axis and Greenwich meridian).</p> <p>The ITRF is an Earth-centered Earth-fixed (ECEF) frame, meaning it rotates with the Earth.</p> <p>Naming Conventions</p> <p>Brahe provides two sets of function names for frame transformations, both referring to the same underlying implementations:</p> <ul> <li>ECI/ECEF naming: Common coordinate system names (e.g., <code>rotation_eci_to_ecef</code>, <code>state_eci_to_ecef</code>)</li> <li>GCRF/ITRF naming: Explicit reference frame names (e.g., <code>rotation_gcrf_to_itrf</code>, <code>state_gcrf_to_itrf</code>)</li> </ul> <p>Both naming conventions are fully supported and provide identical results. The ECI/ECEF names are intuitive and widely used in the astrodynamics community, while the GCRF/ITRF names explicitly identify the specific reference frame implementations. Users can choose whichever naming convention they prefer - all examples in this documentation use the ECI/ECEF convention for simplicity.</p> <p>The ECI/ECEF implementation will be updated to use whatever the current \"best\" reference frame implementations are, while the GCRF/ITRF implementation will always refer to the specific IAU SOFA implementations described above.</p>"},{"location":"learn/frame_transformations.html#eci-to-ecef","title":"ECI to ECEF","text":"<p>Converting from ECI to ECEF accounts for the Earth's rotation, polar motion, and precession-nutation effects. These transformations are time-dependent and require Earth Orientation Parameters (EOP) for high accuracy.</p>"},{"location":"learn/frame_transformations.html#state-vector","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from ECI to ECEF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-01-01 12:00:00.000 UTC\n\n# Convert to ECI Cartesian state\nstate_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\nprint(\"ECI state vector:\")\nprint(f\"  Position: [{state_eci[0]:.3f}, {state_eci[1]:.3f}, {state_eci[2]:.3f}] m\")\nprint(f\"  Velocity: [{state_eci[3]:.6f}, {state_eci[4]:.6f}, {state_eci[5]:.6f}] m/s\\n\")\n\n# ECI state vector:\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ECEF at specific epoch\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\n\nprint(\"\\nECEF state vector:\")\nprint(f\"  Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}] m/s\"\n)\n# ECEF state vector:\n#   Position: [757164.267, 1725863.563, 6564672.302] m\n#   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-01-01 12:00:00.000 UTC\n\n    // Convert to ECI Cartesian state\n    let state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n\n    println!(\"ECI state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci[0], state_eci[1], state_eci[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eci[3], state_eci[4], state_eci[5]);\n    // ECI state vector:\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ECEF at specific epoch\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"\\nECEF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // ECEF state vector:\n    //   Position: [757164.267, 1725863.563, 6564672.302] m\n    //   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n}\n</code></pre> <p>Caution</p> <p>Simply rotating veloicty vectors will not yield correct velocity components in the ECEF frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes in the ECEF frame due to Earth's rotation.</p>"},{"location":"learn/frame_transformations.html#rotation-matrix","title":"Rotation Matrix","text":"<p>Get the rotation matrix from ECI to ECEF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from ECI to ECEF\nR_eci_to_ecef = bh.rotation_eci_to_ecef(epc)\n\nprint(f\"Epoch: {epc}\")  # Epoch: 2024-01-01 12:00:00 UTC\nprint(\"\\nECI to ECEF rotation matrix:\")\nprint(\n    f\"  [{R_eci_to_ecef[0, 0]:10.7f}, {R_eci_to_ecef[0, 1]:10.7f}, {R_eci_to_ecef[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_eci_to_ecef[1, 0]:10.7f}, {R_eci_to_ecef[1, 1]:10.7f}, {R_eci_to_ecef[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_eci_to_ecef[2, 0]:10.7f}, {R_eci_to_ecef[2, 1]:10.7f}, {R_eci_to_ecef[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538, -0.9837663, -0.0003836]\n# [ 0.9837637,  0.1794542, -0.0022908]\n# [ 0.0023225,  0.0000338,  0.9999973]\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to ECI Cartesian state and extract position\nstate_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npos_eci = state_eci[0:3]\n\nprint(\"Position in ECI:\")\nprint(f\"  [{pos_eci[0]:.3f}, {pos_eci[1]:.3f}, {pos_eci[2]:.3f}] m\\n\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Transform position using rotation matrix\npos_ecef = R_eci_to_ecef @ pos_eci\n\nprint(\"Position in ECEF (using rotation matrix):\")\nprint(f\"  [{pos_ecef[0]:.3f}, {pos_ecef[1]:.3f}, {pos_ecef[2]:.3f}] m\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Verify using position transformation function\npos_ecef_direct = bh.position_eci_to_ecef(epc, pos_eci)\nprint(\"\\nPosition in ECEF (using position_eci_to_ecef):\")\nprint(\n    f\"  [{pos_ecef_direct[0]:.3f}, {pos_ecef_direct[1]:.3f}, {pos_ecef_direct[2]:.3f}] m\"\n)\n# [757164.267, 1725863.563, 6564672.302] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from ECI to ECEF\n    let r_eci_to_ecef = bh::rotation_eci_to_ecef(epc);\n\n    println!(\"Epoch: {}\", epc); // Epoch: 2024-01-01 12:00:00 UTC\n    println!(\"\\nECI to ECEF rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_eci_to_ecef[(0, 0)], r_eci_to_ecef[(0, 1)], r_eci_to_ecef[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_eci_to_ecef[(1, 0)], r_eci_to_ecef[(1, 1)], r_eci_to_ecef[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_eci_to_ecef[(2, 0)], r_eci_to_ecef[(2, 1)], r_eci_to_ecef[(2, 2)]);\n    // [ 0.1794538, -0.9837663, -0.0003836]\n    // [ 0.9837637,  0.1794542, -0.0022908]\n    // [ 0.0023225,  0.0000338,  0.9999973]\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to ECI Cartesian state and extract position\n    let state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n    let pos_eci = na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]);\n\n    println!(\"Position in ECI:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eci[0], pos_eci[1], pos_eci[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform position using rotation matrix\n    let pos_ecef = r_eci_to_ecef * pos_eci;\n\n    println!(\"Position in ECEF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_ecef[0], pos_ecef[1], pos_ecef[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Verify using position transformation function\n    let pos_ecef_direct = bh::position_eci_to_ecef(epc, pos_eci);\n    println!(\"\\nPosition in ECEF (using position_eci_to_ecef):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_ecef_direct[0], pos_ecef_direct[1], pos_ecef_direct[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n}\n</code></pre>"},{"location":"learn/frame_transformations.html#ecef-to-eci","title":"ECEF to ECI","text":"<p>Converting from ECEF to ECI reverses the transformation, converting Earth-fixed coordinates back to the inertial frame.</p>"},{"location":"learn/frame_transformations.html#state-vector_1","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from ECEF to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n\n# Convert to ECI Cartesian state\nstate_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\nprint(\"ECI state vector:\")\nprint(f\"  Position: [{state_eci[0]:.3f}, {state_eci[1]:.3f}, {state_eci[2]:.3f}] m\")\nprint(f\"  Velocity: [{state_eci[3]:.6f}, {state_eci[4]:.6f}, {state_eci[5]:.6f}] m/s\\n\")\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\n\nprint(\"ECEF state vector:\")\nprint(f\"  Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}] m/s\\n\"\n)\n# Position: [757164.267, 1725863.563, 6564672.302] m\n# Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n# Transform back to ECI\nstate_eci_back = bh.state_ecef_to_eci(epc, state_ecef)\n\nprint(\"\\nECI state vector (transformed from ECEF):\")\nprint(\n    f\"  Position: [{state_eci_back[0]:.3f}, {state_eci_back[1]:.3f}, {state_eci_back[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_eci_back[3]:.6f}, {state_eci_back[4]:.6f}, {state_eci_back[5]:.6f}] m/s\"\n)\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Verify round-trip transformation\ndiff_pos = np.linalg.norm(state_eci[0:3] - state_eci_back[0:3])\ndiff_vel = np.linalg.norm(state_eci[3:6] - state_eci_back[3:6])\nprint(\"\\nRound-trip error:\")\nprint(f\"  Position: {diff_pos:.6e} m\")\nprint(f\"  Velocity: {diff_vel:.6e} m/s\")\n\n# Expected output:\n#   Position: 9.617484e-10 m\n#   Velocity: 9.094947e-13 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n\n    // Convert to ECI Cartesian state\n    let state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    println!(\"ECI state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci[0], state_eci[1], state_eci[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eci[3], state_eci[4], state_eci[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ECEF\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Position: [757164.267, 1725863.563, 6564672.302] m\n    // Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n    // Transform back to ECI\n    let state_eci_back = bh::state_ecef_to_eci(epc, state_ecef);\n\n    println!(\"\\nECI state vector (transformed from ECEF):\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci_back[0], state_eci_back[1], state_eci_back[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_eci_back[3], state_eci_back[4], state_eci_back[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Verify round-trip transformation\n    let diff_pos = (na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]) -\n                    na::Vector3::new(state_eci_back[0], state_eci_back[1], state_eci_back[2])).norm();\n    let diff_vel = (na::Vector3::new(state_eci[3], state_eci[4], state_eci[5]) -\n                    na::Vector3::new(state_eci_back[3], state_eci_back[4], state_eci_back[5])).norm();\n    println!(\"\\nRound-trip error:\");\n    println!(\"  Position: {:.6e} m\", diff_pos);\n    println!(\"  Velocity: {:.6e} m/s\", diff_vel);\n\n    // Expected output:\n    //   Position: 9.617484e-10 m\n    //   Velocity: 9.094947e-13 m/s\n}\n</code></pre> <p>Caution</p> <p>Simply rotating velocity vectors will not yield correct velocity components in the ECEF frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes in the ECEF frame due to Earth's rotation.</p>"},{"location":"learn/frame_transformations.html#rotation-matrix_1","title":"Rotation Matrix","text":"<p>Get the rotation matrix from ECEF to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR_ecef_to_eci = bh.rotation_ecef_to_eci(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nECEF to ECI rotation matrix:\")\nprint(\n    f\"  [{R_ecef_to_eci[0, 0]:10.7f}, {R_ecef_to_eci[0, 1]:10.7f}, {R_ecef_to_eci[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_ecef_to_eci[1, 0]:10.7f}, {R_ecef_to_eci[1, 1]:10.7f}, {R_ecef_to_eci[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_ecef_to_eci[2, 0]:10.7f}, {R_ecef_to_eci[2, 1]:10.7f}, {R_ecef_to_eci[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538,  0.9837637,  0.0023225]\n# [-0.9837663,  0.1794542,  0.0000338]\n# [-0.0003836, -0.0022908,  0.9999973]\n\n# Verify it's the transpose of ECI to ECEF rotation\nR_eci_to_ecef = bh.rotation_eci_to_ecef(epc)\nprint(\"Verification: R_ecef_to_eci = R_eci_to_ecef^T\")\nprint(f\"  Max difference: {np.max(np.abs(R_ecef_to_eci - R_eci_to_ecef.T)):.2e}\\n\")\n# Max difference: 0.00e0\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to ECI Cartesian state and extract position\nstate_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\n# Transform to ECEF\npos_ecef = bh.position_eci_to_ecef(epc, state_eci[0:3])\n\nprint(\"Satellite position in ECEF:\")\nprint(f\"  [{pos_ecef[0]:.3f}, {pos_ecef[1]:.3f}, {pos_ecef[2]:.3f}] m\\n\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Transform back to ECI using rotation matrix\npos_eci = R_ecef_to_eci @ pos_ecef\n\nprint(\"Satellite position in ECI (using rotation matrix):\")\nprint(f\"  [{pos_eci[0]:.3f}, {pos_eci[1]:.3f}, {pos_eci[2]:.3f}] m\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Verify using position transformation function\npos_eci_direct = bh.position_ecef_to_eci(epc, pos_ecef)\nprint(\"\\nSatellite position in ECI (using position_ecef_to_eci):\")\nprint(\n    f\"  [{pos_eci_direct[0]:.3f}, {pos_eci_direct[1]:.3f}, {pos_eci_direct[2]:.3f}] m\"\n)\n# [1848964.106, -434937.468, 6560410.530] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from ECEF to ECI\n    let r_ecef_to_eci = bh::rotation_ecef_to_eci(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nECEF to ECI rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_ecef_to_eci[(0, 0)], r_ecef_to_eci[(0, 1)], r_ecef_to_eci[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_ecef_to_eci[(1, 0)], r_ecef_to_eci[(1, 1)], r_ecef_to_eci[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_ecef_to_eci[(2, 0)], r_ecef_to_eci[(2, 1)], r_ecef_to_eci[(2, 2)]);\n    // [ 0.1794538,  0.9837637,  0.0023225]\n    // [-0.9837663,  0.1794542,  0.0000338]\n    // [-0.0003836, -0.0022908,  0.9999973]\n\n    // Verify it's the transpose of ECI to ECEF rotation\n    let r_eci_to_ecef = bh::rotation_eci_to_ecef(epc);\n    let diff = (r_ecef_to_eci - r_eci_to_ecef.transpose()).abs();\n    let max_diff = diff.max();\n    println!(\"Verification: R_ecef_to_eci = R_eci_to_ecef^T\");\n    println!(\"  Max difference: {:.2e}\\n\", max_diff);\n    // Max difference: 0.00e+00\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to ECI Cartesian state and extract position\n    let state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n    let pos_eci_orig = na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]);\n\n    // Transform to ECEF\n    let pos_ecef = bh::position_eci_to_ecef(epc, pos_eci_orig);\n\n    println!(\"Satellite position in ECEF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_ecef[0], pos_ecef[1], pos_ecef[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Transform back to ECI using rotation matrix\n    let pos_eci = r_ecef_to_eci * pos_ecef;\n\n    println!(\"Satellite position in ECI (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eci[0], pos_eci[1], pos_eci[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify using position transformation function\n    let pos_eci_direct = bh::position_ecef_to_eci(epc, pos_ecef);\n    println!(\"\\nSatellite position in ECI (using position_ecef_to_eci):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eci_direct[0], pos_eci_direct[1], pos_eci_direct[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n}\n</code></pre>"},{"location":"learn/frame_transformations.html#intermediate-rotation-matrices","title":"Intermediate Rotation Matrices","text":"<p>The full ECI to ECEF transformation is composed of three sequential rotations. Brahe provides access to these intermediate rotation matrices for advanced applications or for understanding the transformation components.</p> <p>The complete transformation chain is</p> <pre><code>GCRF \u2194 CIRS \u2194 TIRS \u2194 ITRF\n      (BPN)   (ER)   (PM)\n</code></pre> <p>where</p> <ul> <li>BPN = Bias-Precession-Nutation: Accounts for Earth's precession and nutation</li> <li>ER = Earth Rotation: Accounts for Earth's daily rotation</li> <li>PM = Polar Motion: Accounts for polar motion and UT1-UTC corrections</li> </ul>"},{"location":"learn/frame_transformations.html#bias-precession-nutation-matrix","title":"Bias-Precession-Nutation Matrix","text":"<p>Get the bias-precession-nutation matrix (GCRF to CIRS):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get BPN matrix (GCRF to CIRS transformation)\nR_bpn = bh.bias_precession_nutation(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nBias-Precession-Nutation (BPN) matrix:\")\nprint(\"Transforms from GCRF to CIRS\")\nprint(f\"  [{R_bpn[0, 0]:10.7f}, {R_bpn[0, 1]:10.7f}, {R_bpn[0, 2]:10.7f}]\")\nprint(f\"  [{R_bpn[1, 0]:10.7f}, {R_bpn[1, 1]:10.7f}, {R_bpn[1, 2]:10.7f}]\")\nprint(f\"  [{R_bpn[2, 0]:10.7f}, {R_bpn[2, 1]:10.7f}, {R_bpn[2, 2]:10.7f}]\\n\")\n# [ 0.9999973,  0.0000000, -0.0023216]\n# [-0.0000001,  1.0000000, -0.0000329]\n# [ 0.0023216,  0.0000329,  0.9999973]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF (ECI) position\nstate_gcrf = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\n\nprint(\"Satellite position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Transform to CIRS using BPN matrix\npos_cirs = R_bpn @ pos_gcrf\n\nprint(\"Satellite position in CIRS:\")\nprint(f\"  [{pos_cirs[0]:.3f}, {pos_cirs[1]:.3f}, {pos_cirs[2]:.3f}] m\")\n# [1833728.342, -435153.781, 6564671.107] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_gcrf - pos_cirs)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\n# Position change magnitude: 15821.751 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get BPN matrix (GCRF to CIRS transformation)\n    let r_bpn = bh::bias_precession_nutation(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nBias-Precession-Nutation (BPN) matrix:\");\n    println!(\"Transforms from GCRF to CIRS\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_bpn[(0, 0)], r_bpn[(0, 1)], r_bpn[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_bpn[(1, 0)], r_bpn[(1, 1)], r_bpn[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_bpn[(2, 0)], r_bpn[(2, 1)], r_bpn[(2, 2)]);\n    //  [ 0.9999973,  0.0000000, -0.0023216]\n    // [-0.0000001,  1.0000000, -0.0000329]\n    // [ 0.0023216,  0.0000329,  0.9999973]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF (ECI) position\n    let state_gcrf = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    println!(\"Satellite position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform to CIRS using BPN matrix\n    let pos_cirs = r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in CIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_cirs[0], pos_cirs[1], pos_cirs[2]);\n    // [1833728.342, -435153.781, 6564671.107] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_gcrf - pos_cirs).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: BPN effects are typically meters to tens of meters\");\n    // Position change magnitude: 15821.751 m\n}\n</code></pre>"},{"location":"learn/frame_transformations.html#earth-rotation-matrix","title":"Earth Rotation Matrix","text":"<p>Get the Earth rotation matrix (CIRS to TIRS):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get Earth rotation matrix (CIRS to TIRS transformation)\nR_er = bh.earth_rotation(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nEarth Rotation matrix:\")\nprint(\"Transforms from CIRS to TIRS\")\nprint(f\"  [{R_er[0, 0]:10.7f}, {R_er[0, 1]:10.7f}, {R_er[0, 2]:10.7f}]\")\nprint(f\"  [{R_er[1, 0]:10.7f}, {R_er[1, 1]:10.7f}, {R_er[1, 2]:10.7f}]\")\nprint(f\"  [{R_er[2, 0]:10.7f}, {R_er[2, 1]:10.7f}, {R_er[2, 2]:10.7f}]\\n\")\n# [ 0.1794542, -0.9837663,  0.0000000]\n# [ 0.9837663,  0.1794542,  0.0000000]\n# [ 0.0000000,  0.0000000,  1.0000000]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF and then to CIRS\nstate_gcrf = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\nR_bpn = bh.bias_precession_nutation(epc)\npos_cirs = R_bpn @ pos_gcrf\n\nprint(\"Satellite position in CIRS:\")\nprint(f\"  [{pos_cirs[0]:.3f}, {pos_cirs[1]:.3f}, {pos_cirs[2]:.3f}] m\\n\")\n# [1833728.342, -435153.781, 6564671.107] m\n\n# Apply Earth rotation to get TIRS\npos_tirs = R_er @ pos_cirs\n\nprint(\"Satellite position in TIRS:\")\nprint(f\"  [{pos_tirs[0]:.3f}, {pos_tirs[1]:.3f}, {pos_tirs[2]:.3f}] m\")\n# [757159.942, 1725870.003, 6564671.107] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_cirs - pos_tirs)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\nprint(\"Note: Earth rotation causes large position changes (km scale)\")\nprint(f\"      due to ~{np.degrees(bh.OMEGA_EARTH * 3600):.3f}\u00b0 rotation per hour\")\n# Position change magnitude: 2414337.034 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get Earth rotation matrix (CIRS to TIRS transformation)\n    let r_er = bh::earth_rotation(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nEarth Rotation matrix:\");\n    println!(\"Transforms from CIRS to TIRS\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_er[(0, 0)], r_er[(0, 1)], r_er[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_er[(1, 0)], r_er[(1, 1)], r_er[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_er[(2, 0)], r_er[(2, 1)], r_er[(2, 2)]);\n    // [ 0.1794542, -0.9837663,  0.0000000]\n    // [ 0.9837663,  0.1794542,  0.0000000]\n    // [ 0.0000000,  0.0000000,  1.0000000]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF and then to CIRS\n    let state_gcrf = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    let r_bpn = bh::bias_precession_nutation(epc);\n    let pos_cirs = r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in CIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_cirs[0], pos_cirs[1], pos_cirs[2]);\n    // [1833728.342, -435153.781, 6564671.107] m\n\n    // Apply Earth rotation to get TIRS\n    let pos_tirs = r_er * pos_cirs;\n\n    println!(\"Satellite position in TIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_tirs[0], pos_tirs[1], pos_tirs[2]);\n    // [757159.942, 1725870.003, 6564671.107] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_cirs - pos_tirs).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: Earth rotation causes large position changes (km scale)\");\n    println!(\"      due to ~{:.3}\u00b0 rotation per hour\", (bh::OMEGA_EARTH * 3600.0).to_degrees());\n    // Position change magnitude: 2414337.034 m\n}\n</code></pre>"},{"location":"learn/frame_transformations.html#polar-motion-matrix","title":"Polar Motion Matrix","text":"<p>Get the polar motion matrix (TIRS to ITRF):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get polar motion matrix (TIRS to ITRF transformation)\nR_pm = bh.polar_motion(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nPolar Motion matrix:\")\nprint(\"Transforms from TIRS to ITRF\")\nprint(f\"  [{R_pm[0, 0]:10.7f}, {R_pm[0, 1]:10.7f}, {R_pm[0, 2]:10.7f}]\")\nprint(f\"  [{R_pm[1, 0]:10.7f}, {R_pm[1, 1]:10.7f}, {R_pm[1, 2]:10.7f}]\")\nprint(f\"  [{R_pm[2, 0]:10.7f}, {R_pm[2, 1]:10.7f}, {R_pm[2, 2]:10.7f}]\\n\")\n# [ 1.0000000, -0.0000000,  0.0000007]\n# [ 0.0000000,  1.0000000, -0.0000010]\n# [-0.0000007,  0.0000010,  1.0000000]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert through the full chain: GCRF \u2192 CIRS \u2192 TIRS\nstate_gcrf = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\nR_bpn = bh.bias_precession_nutation(epc)\nR_er = bh.earth_rotation(epc)\npos_tirs = R_er @ R_bpn @ pos_gcrf\n\nprint(\"Satellite position in TIRS:\")\nprint(f\"  [{pos_tirs[0]:.3f}, {pos_tirs[1]:.3f}, {pos_tirs[2]:.3f}] m\\n\")\n# [757159.942, 1725870.003, 6564671.107] m\n\n# Apply polar motion to get ITRF (ECEF)\npos_itrf = R_pm @ pos_tirs\n\nprint(\"Satellite position in ITRF (ECEF):\")\nprint(f\"  [{pos_itrf[0]:.3f}, {pos_itrf[1]:.3f}, {pos_itrf[2]:.3f}] m\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_tirs - pos_itrf)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\nprint(\"Note: Polar motion effects are typically centimeters to meters\")\n# Position change magnitude: 7.849 m\n\n# Verify against full transformation\npos_ecef_direct = bh.position_eci_to_ecef(epc, pos_gcrf)\nprint(\"\\nVerification using position_eci_to_ecef:\")\nprint(\n    f\"  [{pos_ecef_direct[0]:.3f}, {pos_ecef_direct[1]:.3f}, {pos_ecef_direct[2]:.3f}] m\"\n)\nprint(f\"  Max difference: {np.max(np.abs(pos_itrf - pos_ecef_direct)):.2e} m\")\n# [757164.267, 1725863.563, 6564672.302] m\n# Max difference: 1.16e-10 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get polar motion matrix (TIRS to ITRF transformation)\n    let r_pm = bh::polar_motion(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nPolar Motion matrix:\");\n    println!(\"Transforms from TIRS to ITRF\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_pm[(0, 0)], r_pm[(0, 1)], r_pm[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_pm[(1, 0)], r_pm[(1, 1)], r_pm[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_pm[(2, 0)], r_pm[(2, 1)], r_pm[(2, 2)]);\n    // [ 1.0000000, -0.0000000,  0.0000007]\n    // [ 0.0000000,  1.0000000, -0.0000010]\n    // [-0.0000007,  0.0000010,  1.0000000]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert through the full chain: GCRF \u2192 CIRS \u2192 TIRS\n    let state_gcrf = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    let r_bpn = bh::bias_precession_nutation(epc);\n    let r_er = bh::earth_rotation(epc);\n    let pos_tirs = r_er * r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in TIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_tirs[0], pos_tirs[1], pos_tirs[2]);\n    // [757159.942, 1725870.003, 6564671.107] m\n\n    // Apply polar motion to get ITRF (ECEF)\n    let pos_itrf = r_pm * pos_tirs;\n\n    println!(\"Satellite position in ITRF (ECEF):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_itrf[0], pos_itrf[1], pos_itrf[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_tirs - pos_itrf).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: Polar motion effects are typically centimeters to meters\");\n    // Position change magnitude: 7.849 m\n\n    // Verify against full transformation\n    let pos_ecef_direct = bh::position_eci_to_ecef(epc, pos_gcrf);\n    println!(\"\\nVerification using position_eci_to_ecef:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_ecef_direct[0], pos_ecef_direct[1], pos_ecef_direct[2]);\n    let max_diff = (pos_itrf - pos_ecef_direct).abs().max();\n    println!(\"  Max difference: {:.2e} m\", max_diff);\n    // [757164.267, 1725863.563, 6564672.302] m\n    // Max difference: 1.16e-10 m\n}\n</code></pre> <p>Note</p> <p>For most applications, use the combined <code>rotation_eci_to_ecef</code> or <code>state_eci_to_ecef</code> functions rather than computing intermediate matrices separately. The intermediate matrices are provided for educational purposes and specialized applications.</p>"},{"location":"learn/access_computation/index.html","title":"Access Computation","text":"<p>Access computation determines when and under what conditions satellites can view, observe, or \"access\" ground locations. This is fundamental for mission planning, ground station contact scheduling, imaging opportunity planning, and other mission operations planning tasks.</p> <p>An access occurs when a satellite has a clear geometric line-of-sight to a ground location and meets all constraints (e.g., minimum elevation angle, local time of day, look direction). Brahe's access computation system identifies time windows where all constraints are met and computes relevant properties (e.g., azimuth, elevation, off-nadir angle) for each access window. The system is designed to be flexible, allowing users to define custom locations, constraints, and properties as needed. Access computation is also parallelized by default to efficiently handle large numbers of locations and satellites.</p>"},{"location":"learn/access_computation/index.html#system-architecture","title":"System Architecture","text":"<p>Brahe's access computation system is built around four major components:</p>"},{"location":"learn/access_computation/index.html#1-locations","title":"1. Locations","text":"<p>Locations define where to check for access. Brahe supports two primary location types:</p> <ul> <li><code>PointLocation</code> - Single geodetic point (e.g., ground station, city)</li> <li><code>PolygonLocation</code> - Closed polygon area (e.g., imaging region, coverage zone)</li> </ul> <p>Both implement the <code>AccessibleLocation</code> trait, which provides coordinate access, property management, and GeoJSON import/export capabilities. Locations can be created from coordinates or loaded from GeoJSON files, and the type supports custom properties for metadata storage.</p> <p>Learn more about Locations \u2192</p>"},{"location":"learn/access_computation/index.html#2-constraints","title":"2. Constraints","text":"<p>Constraints define what conditions must be satisfied for an access to occur. Brahe provides several built-in constraint types including:</p> <ul> <li><code>ElevationConstraint</code> - Minimum/maximum elevation above horizon</li> <li><code>ElevationMaskConstraint</code> - Azimuth-dependent elevation masks (terrain profiles)</li> <li><code>OffNadirConstraint</code> - Minimum/maximum off-nadir angle (imaging satellites)</li> <li><code>LocalTimeConstraint</code> - Local solar time windows (e.g., daylight imaging)</li> <li><code>LookDirectionConstraint</code> - Left/right/either relative to velocity vector</li> <li><code>AscDscConstraint</code> - Ascending/descending pass filter</li> </ul> <p>Constraints can be combined using the <code>ConstraintComposite</code> system to express sophisticated requirements like \"elevation &gt; 10\u00b0 AND (daylight OR look-right)\". Python users can create custom constraints by implementing the <code>AccessConstraintComputer</code> interface.</p> <p>Learn more about Constraints \u2192</p>"},{"location":"learn/access_computation/index.html#3-properties","title":"3. Properties","text":"<p>Properties define what information to compute during each access window. Brahe automatically computes six core geometric properties:</p> <ul> <li><code>azimuth_open</code>, <code>azimuth_close</code> - Azimuth angles at window start/end</li> <li><code>elevation_min</code>, <code>elevation_max</code> - Minimum/maximum elevation during access</li> <li><code>off_nadir_min</code>, <code>off_nadir_max</code> - Minimum/maximum off-nadir angle</li> <li><code>local_time</code> - Local solar time at access midpoint</li> <li><code>look_direction</code> - Satellite look direction (Left/Right)</li> <li><code>asc_dsc</code> - Pass type (Ascending/Descending)</li> </ul> <p>Properties are stored as <code>PropertyValue</code> enums supporting scalar, vector, time-series, boolean, string, and JSON data types. Users can add custom properties or implement <code>AccessPropertyComputer</code> for automated property calculation during access searches.</p> <p>Learn more about Properties \u2192</p>"},{"location":"learn/access_computation/index.html#4-computation","title":"4. Computation","text":"<p>Computation is the algorithm that ties everything together. The primary function <code>location_accesses()</code> performs a two-phase search:</p> <ol> <li>Coarse search - Evaluate access at regular time steps to identify candidate windows</li> <li>Refinement - Use binary search to precisely locate window boundaries</li> </ol> <p>The <code>AccessSearchConfig</code> struct controls algorithm behavior (initial time step, adaptive stepping, etc.) for optimal performance across different scenarios. Results are returned as <code>AccessWindow</code> objects containing start/end times, identifiers, and computed properties.</p> <p>Learn more about Computation \u2192</p>"},{"location":"learn/access_computation/index.html#module-catalog","title":"Module Catalog","text":"<p>This section provides a complete reference of all types, traits, and functions in the access computation module.</p>"},{"location":"learn/access_computation/index.html#location-types","title":"Location Types","text":"<p><code>PointLocation</code> - Single geodetic point location</p> <ul> <li>Create from coordinates: <code>new(lat, lon, alt)</code></li> <li>Load from GeoJSON: <code>from_geojson(geojson_str)</code></li> <li>Access coordinates: <code>lat()</code>, <code>lon()</code>, <code>alt()</code>, <code>longitude()</code>, <code>latitude()</code>, <code>altitude()</code></li> <li>Manage properties: <code>add_property(name, value)</code></li> <li>Export: <code>to_geojson()</code></li> </ul> <p><code>PolygonLocation</code> - Closed polygon area location</p> <ul> <li>Create from vertices: <code>new(vertices)</code></li> <li>Load from GeoJSON: <code>from_geojson(geojson_str)</code></li> <li>Access geometry: <code>vertices()</code>, <code>num_vertices()</code>, center via <code>lat()</code>, <code>lon()</code>, <code>alt()</code></li> <li>Manage properties: <code>add_property(name, value)</code></li> <li>Export: <code>to_geojson()</code></li> </ul> <p><code>AccessibleLocation</code> trait - Common interface for all location types</p> <ul> <li>Get center coordinates: <code>center_geodetic()</code>, <code>center_ecef()</code></li> <li>Access properties: <code>properties()</code>, <code>properties_mut()</code></li> <li>Export: <code>to_geojson()</code></li> </ul>"},{"location":"learn/access_computation/index.html#constraint-types","title":"Constraint Types","text":"<p>Built-in Constraints:</p> <ul> <li><code>ElevationConstraint</code> - Enforce minimum/maximum elevation angles above horizon</li> <li><code>ElevationMaskConstraint</code> - Apply azimuth-dependent elevation masks for terrain modeling</li> <li><code>OffNadirConstraint</code> - Limit off-nadir viewing angles for imaging payloads</li> <li><code>LocalTimeConstraint</code> - Filter by local solar time windows (e.g., daylight-only imaging)</li> <li><code>LookDirectionConstraint</code> - Require left/right/either look direction relative to velocity</li> <li><code>AscDscConstraint</code> - Filter by ascending/descending pass type</li> <li><code>ConstraintComposite</code> - Combine constraints with Boolean logic (All/Any/Not)</li> </ul> <p>Constraint Traits:</p> <ul> <li><code>AccessConstraint</code> trait - Interface for evaluating constraints at specific times</li> <li><code>evaluate(epoch, location, propagator) -&gt; bool</code> - Check if constraint satisfied</li> <li><code>name()</code> - Get constraint name for debugging</li> <li> <p><code>format_string()</code> - Get human-readable constraint description</p> </li> <li> <p><code>AccessConstraintComputer</code> trait - Python interface for custom user-defined constraints</p> </li> <li><code>evaluate(epoch, location, propagator) -&gt; bool</code> - Custom constraint logic</li> <li><code>name()</code> - Constraint identifier</li> </ul>"},{"location":"learn/access_computation/index.html#property-types","title":"Property Types","text":"<p><code>PropertyValue</code> enum - Strongly-typed property values</p> <ul> <li><code>Scalar(f64)</code> - Single floating-point value</li> <li><code>Vector(Vec&lt;f64&gt;)</code> - Array of values</li> <li><code>TimeSeries(Vec&lt;(Epoch, f64)&gt;)</code> - Time-indexed measurements</li> <li><code>Boolean(bool)</code> - True/false flag</li> <li><code>String(String)</code> - Text data</li> <li><code>Json(String)</code> - Arbitrary JSON data</li> </ul> <p><code>AccessProperties</code> struct - Container for access window properties</p> <ul> <li>Core properties: <code>azimuth_open</code>, <code>azimuth_close</code>, <code>elevation_min</code>, <code>elevation_max</code>, <code>off_nadir_min</code>, <code>off_nadir_max</code>, <code>local_time</code>, <code>look_direction</code>, <code>asc_dsc</code></li> <li>Custom properties stored in HashMap</li> <li>Methods: <code>new()</code>, <code>add_property(name, value)</code>, <code>get_property(name)</code></li> </ul> <p><code>AccessPropertyComputer</code> trait - Python interface for custom property calculation</p> <ul> <li><code>compute(window, location, propagator) -&gt; HashMap&lt;String, PropertyValue&gt;</code> - Calculate properties</li> <li><code>property_names() -&gt; Vec&lt;String&gt;</code> - List computed property names</li> </ul>"},{"location":"learn/access_computation/index.html#window-and-configuration-types","title":"Window and Configuration Types","text":"<p><code>AccessWindow</code> struct - Represents a single access opportunity</p> <ul> <li>Time bounds: <code>window_open</code>, <code>window_close</code></li> <li>Identifiers: <code>location_name/id/uuid</code>, <code>satellite_name/id/uuid</code>, <code>name/id/uuid</code></li> <li>Properties: <code>properties</code> (AccessProperties)</li> <li>Methods: <code>new()</code>, <code>start()</code>, <code>end()</code>, <code>midtime()</code>, <code>duration()</code></li> </ul> <p><code>AccessSearchConfig</code> struct - Controls access computation algorithm</p> <ul> <li><code>initial_time_step</code> - Coarse search step size (seconds)</li> <li><code>adaptive_step</code> - Enable adaptive refinement</li> <li><code>adaptive_fraction</code> - Refinement step fraction (0.0-1.0)</li> <li><code>parallel</code> - Enable parallel location/satellite processing</li> <li><code>num_threads</code> - Thread pool size (0 = auto)</li> </ul>"},{"location":"learn/access_computation/index.html#enumerations","title":"Enumerations","text":"<p><code>LookDirection</code> - Satellite look direction</p> <ul> <li><code>Left</code> - Looking left relative to velocity vector</li> <li><code>Right</code> - Looking right relative to velocity vector</li> <li><code>Either</code> - Either direction acceptable</li> </ul> <p><code>AscDsc</code> - Pass type classification</p> <ul> <li><code>Ascending</code> - Satellite moving from south to north</li> <li><code>Descending</code> - Satellite moving from north to south</li> <li><code>Either</code> - Either direction acceptable</li> </ul>"},{"location":"learn/access_computation/index.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and GeoJSON support</li> <li>Constraints - Built-in and custom constraint types</li> <li>Computation - Access algorithms and property computation</li> <li>Example: Predicting Ground Contacts - Complete ground station example</li> <li>Example: Computing Imaging Opportunities - Imaging scenario</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/computation.html","title":"Access Computation","text":"<p>Access computation finds time windows when satellites can observe or communicate with ground locations, subject to geometric and operational constraints. Brahe provides the <code>location_accesses()</code> function as the primary function for finding accesses, with optional search configuration parameters to tune performance and accuracy.</p>"},{"location":"learn/access_computation/computation.html#basic-workflow","title":"Basic Workflow","text":"<p>The simplest access computation requires: a location, a propagator, time bounds, and a constraint.</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize Earth orientation data\nbh.initialize_eop()\n\n# Define ground location (San Francisco, CA)\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\n\n# Create propagator from TLE (example for ISS)\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\n# Define time window (7 days starting from epoch)\nepoch_start = bh.Epoch(2025, 11, 2, 0, 0, 0.0, 0.0)\nepoch_end = epoch_start + 7 * 86400.0\n\n# Define constraint (minimum 10\u00b0 elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(location, propagator, epoch_start, epoch_end, constraint)\n\n# Process results\nprint(f\"Found {len(windows)} access windows\")\nfor i, window in enumerate(windows[:3], 1):\n    duration_min = window.duration / 60.0\n    print(f\"\\nWindow {i}:\")\n    print(f\"  Start: {window.window_open}\")\n    print(f\"  End:   {window.window_close}\")\n    print(f\"  Duration: {duration_min:.2f} minutes\")\n\n    # Access computed properties\n    elev_max = window.properties.elevation_max\n    print(f\"  Max elevation: {elev_max:.1f}\u00b0\")\n\n# Output:\n# Found 35 access windows\n\n# Window 1:\n#   Start: 2025-11-02 05:39:28.345 UTC\n#   End:   2025-11-02 05:44:00.000 UTC\n#   Duration: 4.53 minutes\n#   Max elevation: 18.7\u00b0\n\n# Window 2:\n#   Start: 2025-11-02 07:15:16.033 UTC\n#   End:   2025-11-02 07:21:00.000 UTC\n#   Duration: 5.73 minutes\n#   Max elevation: 38.9\u00b0\n\n# Window 3:\n#   Start: 2025-11-02 08:54:59.619 UTC\n#   End:   2025-11-02 08:56:00.000 UTC\n#   Duration: 1.01 minutes\n#   Max elevation: 10.9\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize EOP\n    bh::initialize_eop()?;\n\n    // Define ground location\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0,\n    )\n    .with_name(\"San Francisco\");\n\n    // Create propagator from TLE\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    // Define time window\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 7.0 * 86400.0;\n\n    // Define constraint\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    // Compute access windows\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None, // Use default config\n        None, // No custom property computers\n        None, // No progress callback\n    )?;\n\n    // Process results\n    println!(\"Found {} access windows\", windows.len());\n    for (i, window) in windows.iter().take(3).enumerate() {\n        let duration_min = window.duration() / 60.0;\n        println!(\"\\nWindow {}:\", i + 1);\n        println!(\"  Start: {}\", window.window_open);\n        println!(\"  End:   {}\", window.window_close);\n        println!(\"  Duration: {:.2} minutes\", duration_min);\n\n        // Access computed properties\n        let elev_max = window.properties.elevation_max;\n        println!(\"  Max elevation: {:.1}\u00b0\", elev_max);\n    }\n\n    Ok(())\n}\n\n// Output:\n// Found 35 access windows\n\n// Window 1:\n//   Start: 2025-11-02 05:39:28.345 UTC\n//   End:   2025-11-02 05:44:00.000 UTC\n//   Duration: 4.53 minutes\n//   Max elevation: 18.7\u00b0\n\n// Window 2:\n//   Start: 2025-11-02 07:15:16.033 UTC\n//   End:   2025-11-02 07:21:00.000 UTC\n//   Duration: 5.73 minutes\n//   Max elevation: 38.9\u00b0\n\n// Window 3:\n//   Start: 2025-11-02 08:54:59.619 UTC\n//   End:   2025-11-02 08:56:00.000 UTC\n//   Duration: 1.01 minutes\n//   Max elevation: 10.9\u00b0\n</code></pre>"},{"location":"learn/access_computation/computation.html#multiple-locations-and-satellites","title":"Multiple Locations and Satellites","text":"<p>Compute access for multiple locations and satellites simultaneously:</p> PythonRust <pre><code>import brahe as bh\nfrom collections import defaultdict\n\nbh.initialize_eop()\n\n# Define multiple ground stations\nlocations = [\n    bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\"),\n    bh.PointLocation(-71.0589, 42.3601, 0.0).with_name(\"Boston\"),\n    bh.PointLocation(15.4038, 78.2232, 458.0).with_name(\"Svalbard\"),\n]\n\n# Define multiple satellites (from TLEs, epoch: 2024-01-01)\ntle_data = [\n    # ISS - LEO, 51.6\u00b0 inclination\n    (\n        \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\",\n        \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\",\n        \"ISS\",\n    ),\n    # Tiangong - LEO, 41.5\u00b0 inclination\n    (\n        \"1 48274U 21035A   25306.17586037  .00031797  00000-0  38131-3 0  9995\",\n        \"2 48274  41.4666 263.0710 0006682 308.7013  51.3228 15.60215133257694\",\n        \"Tiangong\",\n    ),\n]\n\npropagators = [\n    bh.SGPPropagator.from_tle(line1, line2, 60.0).with_name(name)\n    for line1, line2, name in tle_data\n]\n\n# Compute all location-satellite pairs (24 hours from TLE epoch)\nepoch_start = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepoch_end = epoch_start + 86400.0  # 24 hours\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses(\n    locations, propagators, epoch_start, epoch_end, constraint\n)\n\n# Results include windows for all location-satellite combinations\nprint(f\"Total windows: {len(windows)}\")\n\n# Group by location\nby_location = defaultdict(list)\nfor window in windows:\n    by_location[window.location_name].append(window)\n\nfor loc_name, loc_windows in by_location.items():\n    print(f\"\\n{loc_name}: {len(loc_windows)} windows\")\n\n# Output:\n# Total windows: 20\n\n# Boston: 10 windows\n\n# San Francisco: 10 windows\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse std::collections::HashMap;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Define multiple locations\n    let locations = vec![\n        bh::PointLocation::new(\n            -122.4194,\n            37.7749,\n            0.0,\n        )\n        .with_name(\"San Francisco\"),\n        bh::PointLocation::new(-71.0589, 42.3601, 0.0)\n            .with_name(\"Boston\"),\n        bh::PointLocation::new(15.4038, 78.2232, 458.0)\n            .with_name(\"Svalbard\"),\n    ];\n\n    // Define multiple satellites\n    let propagators = vec![\n        bh::SGPPropagator::from_tle(\n            \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\",\n            \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\",\n            60.0,\n        )?\n        .with_name(\"ISS\"),\n        bh::SGPPropagator::from_tle(\n            \"1 48274U 21035A   25306.17586037  .00031797  00000-0  38131-3 0  9995\",\n            \"2 48274  41.4666 263.0710 0006682 308.7013  51.3228 15.60215133257694\",\n            60.0,\n        )?\n        .with_name(\"Tiangong\"),\n    ];\n\n    // Compute access windows\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 2, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    let windows = bh::location_accesses(\n        &amp;locations,\n        &amp;propagators,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    )?;\n\n    println!(\"Total windows: {}\", windows.len());\n\n    // Group by location\n    let mut by_location: HashMap&lt;String, Vec&lt;&amp;bh::AccessWindow&gt;&gt; = HashMap::new();\n    for window in &amp;windows {\n        let loc_name = window.location_name.clone().unwrap_or_else(|| \"Unknown\".to_string());\n        by_location\n            .entry(loc_name)\n            .or_insert_with(Vec::new)\n            .push(window);\n    }\n\n    for (loc_name, loc_windows) in by_location {\n        println!(\"\\n{}: {} windows\", loc_name, loc_windows.len());\n    }\n\n    Ok(())\n}\n\n// Expected output:\n// Total windows: 20\n\n// Boston: 10 windows\n\n// San Francisco: 10 windows\n</code></pre>"},{"location":"learn/access_computation/computation.html#algorithm-explanation","title":"Algorithm Explanation","text":"<p>Brahe uses a two-step search algorithm to balance accuracy and performance:</p>"},{"location":"learn/access_computation/computation.html#phase-1-coarse-search","title":"Phase 1: Coarse Search","text":"<p>The algorithm evaluates the constraint at regular time intervals (<code>initial_time_step</code>) across the entire search period. When the constraint transitions from <code>false</code> to <code>true</code>, a candidate access window has been found. This phase identifies periods of potential access quickly.</p> <p>Optionally, adaptive stepping can be enabled to speed up the search by increasing by increasing the first step after an access window is found. The step size is based on a fraction of the satellite's orbital period (<code>adaptive_fraction</code>). For LEO satellites, this can significantly reduce the number of evaluations needed, as at most one access window occurs per orbit.</p> <p>Example: With a 60-second time step over 24 hours, the algorithm performs ~1,440 constraint evaluations to identify candidate windows.</p>"},{"location":"learn/access_computation/computation.html#phase-2-refinement","title":"Phase 2: Refinement","text":"<p>For each candidate window, the algorithm uses binary search to precisely locate the boundary times:</p> <ol> <li>Start at the coarse boundary estimate</li> <li>Take steps backward/forward at half the previous step size until the constraint changes</li> <li>Evaluate constraint at each step</li> <li>When constraint changes, reduce step size, change direction, and repeat</li> <li>Continue until boundary is located to desired precision</li> </ol>"},{"location":"learn/access_computation/computation.html#configuration","title":"Configuration","text":"<p>The <code>AccessSearchConfig</code> struct controls algorithm behavior:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create custom configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,  # Coarse search: 60-second steps\n    adaptive_step=True,  # Enable adaptive refinement\n    adaptive_fraction=0.75,  # Each step is 75% of orbital period\n    parallel=True,  # Enable parallel processing\n    num_threads=0,  # Auto-detect thread count\n)\n\n# Use custom config with location and propagator\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = bh.Epoch(2025, 11, 2, 0, 0, 0.0, 0.0)\nepoch_end = epoch_start + 86400.0  # 24 hours\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses(\n    location, propagator, epoch_start, epoch_end, constraint, config=config\n)\n\nprint(f\"Found {len(windows)} access windows with custom configuration\")\nprint(\n    f\"Configuration: {config.initial_time_step}s time step, adaptive={config.adaptive_step}\"\n)\n\n# Expected output:\n# Found 5 access windows with custom configuration\n# Configuration: 60s time step, adaptive=True\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Create custom configuration\n    let config = bh::AccessSearchConfig {\n        initial_time_step: 60.0,\n        adaptive_step: true,\n        adaptive_fraction: 0.75,\n        parallel: true,\n        num_threads: Some(0),\n    };\n\n    // Use custom config with location and propagator\n    let location = bh::PointLocation::new(\n       -122.4194,\n       37.7749,\n        0.0,\n    )\n    .with_name(\"San Francisco\");\n\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        Some(&amp;config),\n        None,\n    )?;\n\n    println!(\n        \"Found {} access windows with custom configuration\",\n        windows.len()\n    );\n    println!(\n        \"Configuration: {}s time step, adaptive={}\",\n        config.initial_time_step, config.adaptive_step\n    );\n\n    Ok(())\n}\n\n// Output:\n// Found 5 access windows with custom configuration\n// Configuration: 60s time step, adaptive=true\n</code></pre>"},{"location":"learn/access_computation/computation.html#parameter-guidance","title":"Parameter Guidance","text":"<p><code>initial_time_step</code> - Coarse search step size (seconds)</p> <ul> <li>Smaller values (10-60s): More accurate, slower, for complex constraints or short windows</li> <li>Larger values (60-180s): Faster, risk missing brief access windows</li> <li>Rule of thumb: Use 1/10th of expected minimum window duration</li> </ul> <p><code>adaptive_step</code> - Enable adaptive stepping to speed up coarse search</p> <ul> <li><code>true</code>: Enabled, faster for LEO satellites with regular orbits</li> <li><code>false</code>: Disabled, standard fixed-step search</li> </ul> <p><code>adaptive_fraction</code> - Fraction of orbital period for adaptive step size</p> <ul> <li>Smaller values (0.3-0.6): Smaller adaptive step, less risk of missing windows</li> <li>Larger values (0.6-0.8): Larger adaptive step, faster but riskier</li> <li>Recommended: 0.5-0.75 for LEO satellites</li> </ul> <p><code>parallel</code> - Enable parallel processing</p> <ul> <li><code>true</code>: Process location-satellite pairs in parallel (recommended)</li> <li><code>false</code>: Sequential processing, lower memory usage</li> </ul> <p><code>num_threads</code> - Thread pool size</p> <ul> <li>0: Auto-detect CPU cores (recommended)</li> <li>N &gt; 0: Use exactly N threads for parallel work</li> </ul>"},{"location":"learn/access_computation/computation.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and properties</li> <li>Constraints - Constraint system and composition</li> <li>Access Computation Index - Overview and usage examples</li> <li>Example: Predicting Ground Contacts - Complete workflow</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/constraints.html","title":"Constraints","text":"<p>Constraints define the criteria that must be satisfied for satellite access to ground locations. Brahe provides a comprehensive constraint system with built-in geometric constraints, logical composition operators, and support for custom user-defined constraints.</p> <p>A constraint evaluates to <code>true</code> when access conditions are met and <code>false</code> otherwise. During access computation, the algorithm searches for continuous time periods where constraints remain <code>true</code>, identifying these as access windows.</p>"},{"location":"learn/access_computation/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevation-constraint","title":"Elevation Constraint","text":"<p>The most common constraint - requires satellites to be above a minimum elevation angle. This accounts for terrain obstructions, atmospheric effects, and antenna pointing limits.</p> <p>Basic elevation constraint:</p> PythonRust <pre><code>import brahe as bh\n\n# Require satellite to be at least 10 degrees above horizon\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nprint(f\"Created: {constraint}\")\n# Created:  ElevationConstraint(&gt;= 10.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Require satellite to be at least 10 degrees above horizon\n    let constraint = bh::ElevationConstraint::new(\n        Some(10.0),  // min elevation (degrees)\n        None  // max elevation (defaults to 90\u00b0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 10.00\u00b0)\n}\n</code></pre> <p>With maximum elevation:</p> PythonRust <pre><code>import brahe as bh\n\n# Side-looking sensor with elevation range\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0, max_elevation_deg=80.0)\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(10.00\u00b0 - 80.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Side-looking sensor with elevation range\n    let constraint = bh::ElevationConstraint::new(\n        Some(10.0),\n        Some(80.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(10.00\u00b0 - 80.00\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#elevation-mask-constraint","title":"Elevation Mask Constraint","text":"<p>Models azimuth-dependent elevation masks for terrain profiles, mountains, or buildings blocking low-elevation views in specific directions.</p> PythonRust <pre><code>import brahe as bh\n\n# Define elevation mask: [(azimuth_deg, elevation_deg), ...]\n# Azimuth clockwise from North (0-360)\nmask_points = [\n    (0.0, 5.0),  # North: 5\u00b0 minimum\n    (90.0, 15.0),  # East: 15\u00b0 minimum (mountains)\n    (180.0, 8.0),  # South: 8\u00b0 minimum\n    (270.0, 10.0),  # West: 10\u00b0 minimum\n    (360.0, 5.0),  # Back to North\n]\n\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationMaskConstraint(Min: 5.00\u00b0 at 0.00\u00b0, Max: 15.00\u00b0 at 90.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Define mask points in radians\n    let mask_points = vec![\n        (0.0, 5.0),\n        (90.0, 15.0),\n        (180.0, 8.0),\n        (270.0, 10.0),\n        (360.0, 5.0),\n    ];\n\n    let constraint = bh::ElevationMaskConstraint::new(mask_points);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationMaskConstraint(Min: 5.00\u00b0 at 0.00\u00b0, Max: 15.00\u00b0 at 90.00\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#off-nadir-constraint","title":"Off-Nadir Constraint","text":"<p>Limits the off-nadir viewing angle for imaging satellites. Off-nadir angle is measured from the satellite's nadir (straight down) to the target location.</p> <p>Imaging payload:</p> PythonRust <pre><code>import brahe as bh\n\n# Imaging payload with 30\u00b0 maximum off-nadir\nconstraint = bh.OffNadirConstraint(max_off_nadir_deg=30.0)\n\nprint(f\"Created: {constraint}\")\n# Created: OffNadirConstraint(&lt;= 30.0\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Imaging payload with 30\u00b0 maximum off-nadir\n    let constraint = bh::OffNadirConstraint::new(\n        None,  // min off-nadir (defaults to 0\u00b0)\n        Some(30.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: OffNadirConstraint(&lt;= 30.0\u00b0)\n}\n</code></pre> <p>Side-looking radar:</p> PythonRust <pre><code>import brahe as bh\n\n# Side-looking radar requiring specific geometry\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=20.0, max_off_nadir_deg=45.0)\n\nprint(f\"Created: {constraint}\")\n# Created: OffNadirConstraint(20.0\u00b0 - 45.0\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Side-looking radar\n    let constraint = bh::OffNadirConstraint::new(\n        Some(20.0),\n        Some(45.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: OffNadirCOffNadirConstraint(20.0\u00b0 - 45.0\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#local-time-constraint","title":"Local Time Constraint","text":"<p>Filters access windows by local solar time at the ground location. Useful for daylight-only imaging or night-time astronomy observations.</p> <p>Single time window:</p> PythonRust <pre><code>import brahe as bh\n\n# Daylight imaging: 8:00 AM to 6:00 PM local solar time\n# Times in military format: HHMM\nconstraint = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(08:00-18:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Daylight imaging: 8:00 AM to 6:00 PM\n    let constraint = bh::LocalTimeConstraint::new(\n        vec![(800, 1800)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(08:00-18:00)\n}\n</code></pre> <p>Multiple time windows:</p> PythonRust <pre><code>import brahe as bh\n\n# Multiple windows: dawn and dusk passes\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 800), (1800, 2000)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(06:00-08:00, 18:00-20:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Multiple windows\n    let constraint = bh::LocalTimeConstraint::new(\n        vec![(600, 800), (1800, 2000)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(06:00-08:00, 18:00-20:00)\n}\n</code></pre> <p>Using decimal hours:</p> PythonRust <pre><code>import brahe as bh\n\n# Alternative: specify in decimal hours\nconstraint = bh.LocalTimeConstraint.from_hours(time_windows=[(8.0, 18.0)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(08:00-18:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // From decimal hours\n    let constraint = bh::LocalTimeConstraint::from_hours(\n        vec![(8.0, 18.0)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(08:00-18:00)\n}\n</code></pre> <p>Local Solar Time</p> <p>Local solar time is based on the Sun's position relative to the location, not clock time zones. Noon (1200) is when the Sun is highest in the sky.</p>"},{"location":"learn/access_computation/constraints.html#look-direction-constraint","title":"Look Direction Constraint","text":"<p>Requires the satellite to look in a specific direction relative to its velocity vector - left, right, or either side.</p> <p>Left-looking:</p> PythonRust <pre><code>import brahe as bh\nfrom brahe import LookDirection\n\n# Require left-looking geometry\nconstraint = bh.LookDirectionConstraint(allowed=LookDirection.LEFT)\n\nprint(f\"Created: {constraint}\")\n# Created: LookDirectionConstraint(Left)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Require left-looking geometry\n    let constraint = bh::LookDirectionConstraint::new(\n        bh::LookDirection::Left\n    );\n\n    println!(\"Created: {}\", constraint);\n    // Created: LookDirectionConstraint(Left)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#ascending-descending-constraint","title":"Ascending-Descending Constraint","text":"<p>Filters passes by whether the satellite is ascending (moving south-to-north) or descending (north-to-south) over the location.</p> <p>Ascending passes:</p> PythonRust <pre><code>import brahe as bh\nfrom brahe import AscDsc\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=AscDsc.ASCENDING)\n\nprint(f\"Created: {constraint}\")\n# Created: AscDscConstraint(Ascending)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Only ascending passes\n    let constraint = bh::AscDscConstraint::new(\n        bh::AscDsc::Ascending\n    );\n\n    println!(\"Created: {}\", constraint);\n    // Created: AscDscConstraint(Ascending)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraint-composition","title":"Constraint Composition","text":"<p>Combine constraints using Boolean logic to express complex requirements.</p>"},{"location":"learn/access_computation/constraints.html#constraintall-and-logic","title":"ConstraintAll (AND Logic)","text":"<p>All child constraints must be satisfied simultaneously:</p> PythonRust <pre><code>import brahe as bh\n\n# Elevation &gt; 10\u00b0 AND daylight hours\nelev = bh.ElevationConstraint(min_elevation_deg=10.0)\ndaytime = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\n\nconstraint = bh.ConstraintAll(constraints=[elev, daytime])\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n</code></pre> <pre><code>fn main() {\n    // Elevation &gt; 10\u00b0 AND daylight hours\n    let elev = Box::new(bh::ElevationConstraint::new(Some(10.0), None).unwrap());\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(800, 1800)]).unwrap());\n\n    let constraint = bh::ConstraintComposite::All(vec![elev, daytime]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraintany-or-logic","title":"ConstraintAny (OR Logic)","text":"<p>At least one child constraint must be satisfied:</p> PythonRust <pre><code>import brahe as bh\n\n# High elevation OR right-looking geometry\nhigh_elev = bh.ElevationConstraint(min_elevation_deg=60.0)\nright_look = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\nconstraint = bh.ConstraintAny(constraints=[high_elev, right_look])\n\nprint(f\"Created: {constraint}\")\n# Created: ConstraintAny(constraints: [ElevationConstraint(...), LookDirectionConstraint(...)])\n</code></pre> <pre><code>fn main() {\n    // High elevation OR right-looking geometry\n    let high_elev = Box::new(bh::ElevationConstraint::new(Some(60.0), None).unwrap());\n    let right_look = Box::new(bh::LookDirectionConstraint::new(bh::LookDirection::Right));\n\n    let constraint = bh::ConstraintComposite::Any(vec![high_elev, right_look]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraintnot-negation","title":"ConstraintNot (Negation)","text":"<p>Inverts a constraint - access occurs when the child constraint is NOT satisfied:</p> PythonRust <pre><code>import brahe as bh\n\n# Avoid daylight (e.g., for night-time astronomy)\ndaytime = bh.LocalTimeConstraint(time_windows=[(600, 2000)])\nnight_only = bh.ConstraintNot(constraint=daytime)\n\nprint(f\"Created: {night_only}\")\n# Created: !LocalTimeConstraint(06:00-20:00)\n</code></pre> <pre><code>fn main() {\n    // Avoid daylight (e.g., for night-time astronomy)\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(600, 2000)]).unwrap());\n    let night_only = bh::ConstraintComposite::Not(daytime);\n\n    println!(\"Created: {}\", night_only);\n    // Created: !LocalTimeConstraint(06:00-20:00)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#complex-composition","title":"Complex Composition","text":"<p>Build complex logic by combining multiple constraints:</p> PythonRust <pre><code>import brahe as bh\n\n# Complex constraint: (High elevation AND daylight)\n# Note: Python API currently supports single-level composition\n# For nested constraints, use Rust API with Box&lt;dyn AccessConstraint&gt;\n\n# High elevation AND daylight\nhigh_elev = bh.ElevationConstraint(min_elevation_deg=60.0)\ndaytime = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\nlook_right = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Combine multiple constraints with AND\nconstraint = bh.ConstraintAll(constraints=[high_elev, daytime, look_right])\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(&gt;= 60.00\u00b0) &amp;&amp; LocalTimeConstraint(08:00-18:00) &amp;&amp; LookDirectionConstraint(Right)\n</code></pre> <pre><code>fn main() {\n    // Complex constraint: High elevation AND daylight AND right-looking\n    let high_elev = Box::new(bh::ElevationConstraint::new(Some(60.0), None).unwrap());\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(800, 1800)]).unwrap());\n    let look_right = Box::new(bh::LookDirectionConstraint::new(bh::LookDirection::Right));\n\n    // Combine multiple constraints with AND\n    let constraint = bh::ConstraintComposite::All(vec![high_elev, daytime, look_right]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) &amp;&amp; LocalTimeConstraint(08:00-18:00) &amp;&amp; LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#custom-constraints-python","title":"Custom Constraints (Python)","text":"<p>Python users can create fully custom constraints by implementing the <code>AccessConstraintComputer</code> interface:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n\nclass MaxRangeConstraint(bh.AccessConstraintComputer):\n    \"\"\"Limit access to satellites within a maximum range.\"\"\"\n\n    def __init__(self):\n        self.max_range_m = 2000.0 * 1000.0  # 2000 km in meters\n\n    def evaluate(self, epoch, satellite_state_ecef, location_ecef):\n        \"\"\"Return True when constraint is satisfied\"\"\"\n        # Compute range vector from location to satellite\n        range_vec = satellite_state_ecef[:3] - location_ecef\n        range_m = np.linalg.norm(range_vec)\n\n        return range_m &lt;= self.max_range_m\n\n    def name(self):\n        return f\"MaxRange({self.max_range_m / 1000:.0f}km)\"\n\n\n# Use custom constraint\nconstraint = MaxRangeConstraint()\n\nprint(f\"Created: {constraint.name()}\")\n# Created: MaxRange(2000km)\n</code></pre> <p>Custom Constraints in Rust</p> <p>Rust users implement the <code>AccessConstraint</code> trait directly. This provides maximum performance but requires recompiling the library.</p>"},{"location":"learn/access_computation/constraints.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types</li> <li>Computation - How constraints are evaluated during access search</li> <li>API Reference: Constraints</li> <li>Example: Predicting Ground Contacts</li> <li>Example: Computing Imaging Opportunities</li> </ul>"},{"location":"learn/access_computation/locations.html","title":"Locations","text":"<p>Locations represent ground positions or areas that satellites can access. Brahe provides two fundamental location types\u2014points and polygons\u2014with full GeoJSON interoperability and extensible metadata support.</p> <p>All location types implement the <code>AccessibleLocation</code> trait, which provides a common interface for coordinate access, property management, and GeoJSON import/export. This design allows you to work with different location geometries through a unified API.</p> <p>Coordinate Units</p> <p>All coordinates are specified in geodetic longitude (\u03bb), latitude (\u03c6), and altitude (h) using the WGS84 reference frame. All units are in degrees (for \u03bb and \u03c6) and meters (for h) for consistency with the GeoJSON standard.</p>"},{"location":"learn/access_computation/locations.html#pointlocation","title":"PointLocation","text":"<p>A <code>PointLocation</code> represents a single geodetic point on Earth's surface. This is the most common location type, used for ground stations, cities, or specific observation points.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-coordinates","title":"Initialization from Coordinates","text":"<p>Create a point location from geodetic coordinates (longitude, latitude, altitude):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create location (longitude, latitude, altitude in meters)\n# San Francisco, CA\nsf = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Add an identifier for clarity\nsf = sf.with_name(\"San Francisco\")\n\nprint(f\"Location: {sf.get_name()}\")\nprint(f\"Longitude: {sf.longitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Latitude: {sf.latitude(bh.AngleFormat.DEGREES):.4f} deg\")\n\n# Expected output:\n# Location: San Francisco\n# Longitude: -122.4194 deg\n# Latitude: 37.7749 deg\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create location (longitude, latitude, altitude in meters)\n    // San Francisco, CA\n    let sf = bh::PointLocation::new(\n        -122.4194,  // longitude in degrees\n        37.7749,    // latitude in degrees\n        0.0         // altitude in meters\n    ).with_name(\"San Francisco\");\n\n    let geodetic = sf.center_geodetic();\n    println!(\"Location: {}\", sf.get_name().unwrap_or_default());\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n\n    // Expected output:\n    // Location: San Francisco\n    // Longitude: -122.4194 deg\n    // Latitude: 37.7749 deg\n}\n</code></pre> <p>Coordinate Units</p> <p>Python uses degrees for input convenience. Rust uses radians (SI standard). Both use meters for altitude.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-geojson","title":"Initialization from GeoJSON","text":"<p>Load locations from GeoJSON strings or files:</p> PythonRust <pre><code>import brahe as bh\nimport json\n\nbh.initialize_eop()\n\n# GeoJSON Point feature\ngeojson_str = \"\"\"\n{\n    \"type\": \"Feature\",\n    \"properties\": {\"name\": \"Svalbard Station\"},\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4038, 78.2232, 458.0]\n    }\n}\n\"\"\"\n\nlocation = bh.PointLocation.from_geojson(json.loads(geojson_str))\nprint(f\"Loaded: {location.get_name()}\")\nprint(f\"Longitude: {location.longitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Latitude: {location.latitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Altitude: {location.altitude():.1f} m\")\n\n# Expected output:\n# Loaded: Svalbard Station\n# Longitude: 15.4038 deg\n# Latitude: 78.2232 deg\n# Altitude: 458.0 m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // GeoJSON Point feature\n    let geojson = r#\"\n    {\n        \"type\": \"Feature\",\n        \"properties\": {\"name\": \"Svalbard Station\"},\n        \"geometry\": {\n            \"type\": \"Point\",\n            \"coordinates\": [15.4038, 78.2232, 458.0]\n        }\n    }\n    \"#;\n\n    // Parse JSON string first\n    let json: serde_json::Value = serde_json::from_str(geojson).unwrap();\n    let location = bh::PointLocation::from_geojson(&amp;json).unwrap();\n    let geodetic = location.center_geodetic();\n    println!(\"Loaded: {}\", location.get_name().unwrap_or_default());\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n    println!(\"Altitude: {:.1} m\", geodetic[2]);\n\n    // Expected output:\n    // Loaded: Svalbard Station\n    // Longitude: 15.4038 deg\n    // Latitude: 78.2232 deg\n    // Altitude: 458.0 m\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#accessing-coordinates","title":"Accessing Coordinates","text":"<p>Retrieve coordinates in different formats:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Access in degrees\nprint(f\"Longitude: {location.longitude(bh.AngleFormat.DEGREES)} deg\")\nprint(f\"Latitude: {location.latitude(bh.AngleFormat.DEGREES)} deg\")\nprint(f\"Altitude: {location.altitude()} m\")\n\n# Shorthand access (in degrees)\nprint(f\"Lon (deg): {location.lon:.6f}\")\nprint(f\"Lat (deg): {location.lat:.6f}\")\n\n# Get geodetic array [lat, lon, alt] in radians and meters\ngeodetic = location.center_geodetic()\nprint(f\"Geodetic: [{geodetic[0]:.6f}, {geodetic[1]:.6f}, {geodetic[2]:.1f}]\")\n\n# Get ECEF Cartesian position [x, y, z] in meters\necef = location.center_ecef()\nprint(f\"ECEF: [{ecef[0]:.1f}, {ecef[1]:.1f}, {ecef[2]:.1f}] m\")\n\n# Expected output:\n# Longitude: -122.4194 deg\n# Latitude: 37.7749 deg\n# Altitude: 0.0 m\n# Lon (deg): -122.419400\n# Lat (deg): 37.774900\n# Geodetic: [-122.419400, 37.774900, 0.0]\n# ECEF: [-2706174.8, -4261059.5, 3885725.5] m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0\n    );\n\n    // Access geodetic coordinates (in degrees)\n    let geodetic = location.center_geodetic();\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n    println!(\"Altitude: {:.1} m\", geodetic[2]);\n\n\n    // Get ECEF Cartesian position [x, y, z] in meters\n    let ecef = location.center_ecef();\n    println!(\"ECEF: [{:.1}, {:.1}, {:.1}] m\", ecef[0], ecef[1], ecef[2]);\n\n    // Expected output:\n    // Longitude: -122.4194 deg\n    // Latitude: 37.7749 deg\n    // Altitude: 0.0 m\n    // ECEF: [-2706174.8, -4261059.5, 3885725.5] m\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#polygonlocation","title":"PolygonLocation","text":"<p>A <code>PolygonLocation</code> represents a closed polygon area on Earth's surface. This is useful for imaging regions, coverage zones, or geographic areas of interest.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-vertices","title":"Initialization from Vertices","text":"<p>Create a polygon from a list of vertices:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define polygon vertices (longitude, latitude, altitude)\n# Simple rectangular region\nvertices = [\n    [-122.5, 37.7, 0.0],\n    [-122.35, 37.7, 0.0],\n    [-122.35, 37.8, 0.0],\n    [-122.5, 37.8, 0.0],\n    [-122.5, 37.7, 0.0],  # Close the polygon\n]\n\npolygon = bh.PolygonLocation(vertices).with_name(\"SF Region\")\n\nprint(f\"Name: {polygon.get_name()}\")\nprint(f\"Vertices: {polygon.num_vertices}\")\nprint(\n    f\"Center: ({polygon.longitude(bh.AngleFormat.DEGREES):.4f}, {polygon.latitude(bh.AngleFormat.DEGREES):.4f})\"\n)\n\n# Expected output:\n# Name: SF Region\n# Vertices: 4\n# Center: (-122.4250, 37.7500)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define polygon vertices (lon, lat, alt in degrees and meters)\n    let vertices = vec![\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.7, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.35, 37.7, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.35, 37.8, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.8, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.7, 0.0),\n    ];\n\n    let polygon = bh::PolygonLocation::new(vertices).unwrap()\n        .with_name(\"SF Region\");\n\n    let center = polygon.center_geodetic();\n    println!(\"Name: {}\", polygon.get_name().unwrap_or_default());\n    println!(\"Vertices: {}\", polygon.num_vertices());\n    println!(\"Center: ({:.4}, {:.4})\", center[0], center[1]);\n\n    // Expected output:\n    // Name: SF Region\n    // Vertices: 4\n    // Center: (-122.4250, 37.7500)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#initialization-from-geojson_1","title":"Initialization from GeoJSON","text":"<p>Load polygon areas from GeoJSON:</p> PythonRust <pre><code>import brahe as bh\nimport json\n\nbh.initialize_eop()\n\n# GeoJSON Polygon feature\ngeojson_str = \"\"\"\n{\n    \"type\": \"Feature\",\n    \"properties\": {\"name\": \"Target Area\"},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [-122.5, 37.7, 0],\n            [-122.35, 37.7, 0],\n            [-122.35, 37.8, 0],\n            [-122.5, 37.8, 0],\n            [-122.5, 37.7, 0]\n        ]]\n    }\n}\n\"\"\"\n\npolygon = bh.PolygonLocation.from_geojson(json.loads(geojson_str))\n\nprint(f\"Name: {polygon.get_name()}\")\nprint(f\"Vertices: {polygon.num_vertices}\")\nprint(\n    f\"Center: ({polygon.longitude(bh.AngleFormat.DEGREES):.4f}, {polygon.latitude(bh.AngleFormat.DEGREES):.4f})\"\n)\n\n# Expected output:\n# Name: Target Area\n# Vertices: 5\n# Center: (-122.4250, 37.7500)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let geojson = r#\"\n    {\n        \"type\": \"Feature\",\n        \"properties\": {\"name\": \"Target Area\"},\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [[\n                [-122.5, 37.7, 0],\n                [-122.35, 37.7, 0],\n                [-122.35, 37.8, 0],\n                [-122.5, 37.8, 0],\n                [-122.5, 37.7, 0]\n            ]]\n        }\n    }\n    \"#;\n\n    // Parse JSON string first\n    let json: serde_json::Value = serde_json::from_str(geojson).unwrap();\n    let polygon = bh::PolygonLocation::from_geojson(&amp;json).unwrap();\n\n    let center = polygon.center_geodetic();\n    println!(\"Name: {}\", polygon.get_name().unwrap_or_default());\n    println!(\"Vertices: {}\", polygon.num_vertices());\n    println!(\"Center: ({:.4}, {:.4})\", center[0], center[1]);\n\n    // Expected output:\n    // Name: Target Area\n    // Vertices: 4\n    // Center: (-122.4250, 37.7500)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#working-with-properties","title":"Working with Properties","text":"<p>Both location types support custom properties for storing metadata:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Add scalar properties\nlocation.add_property(\"antenna_gain_db\", 42.5)\nlocation.add_property(\"frequency_mhz\", 8450.0)\n\n# Add string properties\nlocation.add_property(\"operator\", \"NOAA\")\n\n# Add boolean flags\nlocation.add_property(\"uplink_enabled\", True)\n\n# Retrieve properties\nprops = location.properties\ngain = props.get(\"antenna_gain_db\")\noperator = props.get(\"operator\")\nuplink = props.get(\"uplink_enabled\")\n\nprint(f\"Antenna Gain: {gain}\")\nprint(f\"Operator: {operator}\")\nprint(f\"Uplink Enabled: {uplink}\")\n\n# Expected output:\n# Antenna Gain: 42.5\n# Operator: NOAA\n# Uplink Enabled: True\n</code></pre> <pre><code>use brahe as bh;\nuse bh::AccessibleLocation;\nuse serde_json::json;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(-122.4194, 37.7749, 0.0)\n        .add_property(\"antenna_gain_db\", json!(42.5))\n        .add_property(\"frequency_mhz\", json!(8450.0))\n        .add_property(\"operator\", json!(\"NOAA\"))\n        .add_property(\"uplink_enabled\", json!(true));\n\n    // Access properties\n    let props = location.properties();\n    if let Some(gain) = props.get(\"antenna_gain_db\") {\n        println!(\"Antenna Gain: {}\", gain);\n    }\n    if let Some(operator) = props.get(\"operator\") {\n        println!(\"Operator: {}\", operator);\n    }\n    if let Some(uplink) = props.get(\"uplink_enabled\") {\n        println!(\"Uplink Enabled: {}\", uplink);\n    }\n\n    // Expected output:\n    // Antenna Gain: 42.5\n    // Operator: \"NOAA\"\n    // Uplink Enabled: true\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#exporting-to-geojson","title":"Exporting to GeoJSON","text":"<p>Convert locations back to GeoJSON format:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = (\n    bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\").with_id(1)\n)\n\n# Export to GeoJSON dict\ngeojson = location.to_geojson()\nprint(\"Exported GeoJSON:\")\nprint(geojson)\n\n# The output includes all properties and identifiers\n# Can be loaded back with from_geojson()\nreloaded = bh.PointLocation.from_geojson(geojson)\nprint(f\"\\nReloaded: {reloaded.get_name()} (ID: {reloaded.get_id()})\")\n\n# Expected output:\n# Exported GeoJSON:\n# {'geometry': {'coordinates': [-122.4194, 37.7749, 0.0], 'type': 'Point'}, 'properties': {'id': 1, 'name': 'San Francisco'}, 'type': 'Feature'}\n#\n# Reloaded: San Francisco (ID: 1)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(-122.4194, 37.7749, 0.0)\n        .with_name(\"San Francisco\")\n        .with_id(1);\n\n    // Export to GeoJSON\n    let geojson = location.to_geojson();\n    println!(\"Exported GeoJSON:\");\n    println!(\"{}\", geojson);\n\n    // The output includes all properties and identifiers\n    // Can be loaded back with from_geojson()\n    let reloaded = bh::PointLocation::from_geojson(&amp;geojson).unwrap();\n    println!(\"\\nReloaded: {} (ID: {})\",\n        reloaded.get_name().unwrap_or_default(),\n        reloaded.get_id().unwrap_or(0));\n\n    // Expected output:\n    // Exported GeoJSON:\n    // {\"geometry\":{\"coordinates\":[-122.4194,37.7749,0.0],\"type\":\"Point\"},\"properties\":{\"id\":1,\"name\":\"San Francisco\"},\"type\":\"Feature\"}\n    //\n    // Reloaded: San Francisco (ID: 1)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#see-also","title":"See Also","text":"<ul> <li>Constraints - Defining access criteria for locations</li> <li>Computation - Access algorithms and property computation</li> <li>API Reference: Locations</li> <li>Example: Predicting Ground Contacts</li> </ul>"},{"location":"learn/access_computation/properties.html","title":"Access Properties","text":"<p>Access properties are geometric and temporal measurements computed for each access window. Brahe automatically calculates core properties during access searches, and provides both built-in and custom property computers for mission-specific analysis.</p>"},{"location":"learn/access_computation/properties.html#core-properties","title":"Core Properties","text":"<p>Brahe automatically computes these temporal and geometric properties for every access window:</p> Name Type Description <code>window_open</code> <code>Epoch</code> UTC time when access window starts <code>window_close</code> <code>Epoch</code> UTC time when access window ends <code>duration</code> <code>float</code> Total duration of access window in seconds <code>midtime</code> <code>Epoch</code> UTC time at midpoint of access window <code>azimuth_open</code> <code>float</code> Azimuth angle from location to satellite at window start (degrees) <code>azimuth_close</code> <code>float</code> Azimuth angle from location to satellite at window end (degrees) <code>elevation_min</code> <code>float</code> Minimum elevation angle during access window (degrees) <code>elevation_max</code> <code>float</code> Maximum elevation angle during access window (degrees) <code>local_time</code> <code>float</code> Local solar time at window midpoint in seconds \\(\\left[0, 86400\\right)\\) <code>look_direction</code> <code>LookDirection</code> Satellite look direction relative to velocity <code>asc_dsc</code> <code>AscDsc</code> Pass classification based on satellite motion <p>Core properties are attributes of the <code>AccessWindow</code> object returned by access computations and can be accessed directly like <code>window.window_open</code> or <code>window.elevation_max</code>.</p> <p>Below are examples of accessing core properties in Python and Rust.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create location (San Francisco area)\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Create propagator from TLE (ISS example)\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0)\n\n# Define time period (24 hours from epoch)\nepoch_start = bh.Epoch.from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch_end = epoch_start + 86400.0\n\n# Create elevation constraint\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [location], [propagator], epoch_start, epoch_end, constraint\n)\n\n# Access core properties from first window\nif windows:\n    window = windows[0]\n    props = window.properties\n\n    print(\"Window \")\n    t_start = window.window_open\n    t_end = window.window_close\n    print(f\"  Start: {t_start}\")\n    print(f\"  End:   {t_end}\")\n    print(f\"  Duration: {window.duration:.1f} seconds\")\n    print(f\"  Midtime: {window.midtime}\")\n\n    print(\"\\nProperties:\")\n\n    # Azimuth values (open and close)\n    az_open = props.azimuth_open\n    az_close = props.azimuth_close\n    print(f\"  Azimuth - Min: {az_open:.1f}\u00b0, Max: {az_close:.1f}\u00b0\")\n\n    # Elevation range (min and max)\n    elev_min = props.elevation_min\n    elev_max = props.elevation_max\n    print(f\"  Elevation - Min: {elev_min:.1f}\u00b0, Max: {elev_max:.1f}\u00b0\")\n\n    # Off-nadir range (min and max)\n    off_nadir_min = props.off_nadir_min\n    off_nadir_max = props.off_nadir_max\n    print(f\"  Off-nadir - Min: {off_nadir_min:.1f}\u00b0, Max: {off_nadir_max:.1f}\u00b0\")\n\n    # Local solar time at midpoint\n    local_time = props.local_time\n    hours = int(local_time // 3600)\n    minutes = (local_time - hours * 3600) / 60\n    print(f\"  Local time: {hours:02d}:{minutes:02.2f}\")\n\n    # Look direction\n    look = props.look_direction\n    print(f\"  Look direction: {look}\")\n\n    # Ascending/Descending\n    asc_dsc = props.asc_dsc\n    print(f\"  Ascending/Descending: {asc_dsc}\")\n\n# Expected output (values will vary based on TLE and time):\n# Window\n#   Start: 2025-11-02 05:39:28.345 UTC\n#   End:   2025-11-02 05:44:00.000 UTC\n#   Duration: 271.7 seconds\n#   Midtime: 2025-11-02 05:41:44.172 UTC\n\n# Properties:\n#   Azimuth - Min: 177.0\u00b0, Max: 87.3\u00b0\n#   Elevation - Min: 10.0\u00b0, Max: 18.7\u00b0\n#   Off-nadir - Min: 62.6\u00b0, Max: 67.4\u00b0\n#   Local time: 05:37.24\n#   Look direction: Left\n#   Ascending/Descending: Ascending\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Create location (San Francisco area)\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0\n    );\n\n    // Create propagator from TLE (ISS example)\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?;\n\n    // Define time period (24 hours from epoch)\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n\n    // Create elevation constraint\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    // Compute access windows\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    )?;\n\n    // Access core properties from first window\n    if !windows.is_empty() {\n        let window = &amp;windows[0];\n        let props = &amp;window.properties;\n\n        println!(\"Window \");\n        let t_start = window.window_open;\n        let t_end = window.window_close;\n        println!(\"  Start: {}\", t_start);\n        println!(\"  End:   {}\", t_end);\n        println!(\"  Duration: {:.1} seconds\", window.duration());\n        println!(\"  Midtime: {}\", window.midtime());\n\n        println!(\"\\nProperties:\");\n\n        // Azimuth values (open and close)\n        let az_open = props.azimuth_open;\n        let az_close = props.azimuth_close;\n        println!(\"  Azimuth - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", az_open, az_close);\n\n        // Elevation range (min and max)\n        let elev_min = props.elevation_min;\n        let elev_max = props.elevation_max;\n        println!(\"  Elevation - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", elev_min, elev_max);\n\n        // Off-nadir range (min and max)\n        let off_nadir_min = props.off_nadir_min;\n        let off_nadir_max = props.off_nadir_max;\n        println!(\"  Off-nadir - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", off_nadir_min, off_nadir_max);\n\n        // Local solar time at midpoint (local_time is in seconds since midnight)\n        let local_time = props.local_time;\n        let hours = (local_time / 3600.0).floor() as i32;\n        let minutes = (local_time - hours as f64 * 3600.0) / 60.0;\n        println!(\"  Local time: {:02}:{:05.2}\", hours, minutes);\n\n        // Look direction\n        let look = &amp;props.look_direction;\n        println!(\"  Look direction: {}\", look);\n\n        // Ascending/Descending\n        let asc_dsc = &amp;props.asc_dsc;\n        println!(\"  Ascending/Descending: {}\", asc_dsc);\n    }\n\n    Ok(())\n}\n// Expected output (values will vary based on TLE and time):\n// Window \n//   Start: 2025-11-02 05:39:28.345 UTC\n//   End:   2025-11-02 05:44:00.000 UTC\n//   Duration: 271.7 seconds\n//   Midtime: 2025-11-02 05:41:44.172 UTC\n\n// Properties:\n//   Azimuth - Min: 177.0\u00b0, Max: 87.3\u00b0\n//   Elevation - Min: 10.0\u00b0, Max: 18.7\u00b0\n//   Off-nadir - Min: 62.6\u00b0, Max: 67.4\u00b0\n//   Local time: 05:37.24\n//   Look direction: Left\n//   Ascending/Descending: Ascending\n</code></pre>"},{"location":"learn/access_computation/properties.html#property-computers","title":"Property Computers","text":"<p>Property computers allow users to extend the access computation system to define and compute custom properties for each access window beyond the core set. These computations are performed after access windows are identified and refined. </p> <p>Python users can implement property computers by subclassing <code>AccessPropertyComputer</code>, while in Rust you implement the <code>AccessPropertyComputer</code> trait. These traits require the implementation of the <code>sampling_config</code> and <code>compute</code> methods. <code>sampling_config</code> defines how satellite states are sampled during the access window, and <code>compute</code> performs the actual property calculation using those sampled states.</p> <p>Brahe defines a few built-in property computers for common use cases, and users can create custom property computers for application-specific needs.</p>"},{"location":"learn/access_computation/properties.html#sampling-configuration","title":"Sampling Configuration","text":"<p>Property computers use <code>SamplingConfig</code> to determine when satellite states are sampled within the access window. That is, what <code>epoch, state</code> pairs are provided to the computer for its calculations.</p> <p>You can choose from several sampling modes:</p> <ul> <li><code>relative_points([0.0, 0.5, 1.0])</code> - Samples at specified fractions of the window duration with 0.0 being the start and 1.0 being the end</li> <li><code>fixed_count(n)</code> - Samples a fixed number of evenly spaced points within the window</li> <li><code>fixed_interval(interval, offset)</code> - Samples at regular time intervals (defined by seconds between samples) throughout the window with an optional offset</li> <li><code>midpoint</code> - Samples only at the midpoint of the window</li> </ul> <p>This allows you to compute time-series data at specific intervals or points.</p>"},{"location":"learn/access_computation/properties.html#sampling-modes","title":"Sampling Modes","text":"PythonRust <pre><code>import brahe as bh\n\n# Single sample at window midpoint (default)\nconfig = bh.SamplingConfig.midpoint()\nprint(f\"Midpoint: {config}\")\n# Midpoint: SamplingConfig.Midpoint\n\n# Specific relative points [0.0, 1.0] from window start to end\nconfig = bh.SamplingConfig.relative_points([0.0, 0.25, 0.5, 0.75, 1.0])\nprint(f\"Relative points: {config}\")\n# Relative points: SamplingConfig.RelativePoints([0.0, 0.25, 0.5, 0.75, 1.0])\n\n# Fixed time interval in seconds\nconfig = bh.SamplingConfig.fixed_interval(1.0, offset=0.0)  # 1 second\nprint(f\"Fixed interval (1s): {config}\")\n# Fixed interval (1s): SamplingConfig.FixedInterval(interval=1.0, offset=0.0)\n\n# Fixed number of evenly-spaced points\nconfig = bh.SamplingConfig.fixed_count(50)\nprint(f\"Fixed count (50): {config}\")\n# Fixed count (50): SamplingConfig.FixedCount(50)\n</code></pre> <pre><code>//! ```\n\nuse brahe::access::SamplingConfig;\n\nfn main() {\n    // Single sample at window midpoint (default)\n    let config = SamplingConfig::Midpoint;\n    println!(\"Midpoint: {:?}\", config);\n    // Midpoint: Midpoint\n\n    // Specific relative points [0.0, 1.0] from window start to end\n    let config = SamplingConfig::RelativePoints(vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    println!(\"Relative points: {:?}\", config);\n    // Relative points: RelativePoints([0.0, 0.25, 0.5, 0.75, 1.0])\n\n    // Fixed time interval in seconds\n    let config = SamplingConfig::FixedInterval {\n        interval: 1.0,  // 1 second\n        offset: 0.0\n    };\n    println!(\"Fixed interval (1s): {:?}\", config);\n    // Fixed interval (1s): FixedInterval { interval: 1.0, offset: 0.0 }\n\n    // Fixed number of evenly-spaced points\n    let config = SamplingConfig::FixedCount(50);\n    println!(\"Fixed count (50): {:?}\", config);\n    // Fixed count (50): FixedCount(50)\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#built-in-property-computers","title":"Built-in Property Computers","text":"<p>Brahe provides three commonly-used property computers optimized in Rust:</p>"},{"location":"learn/access_computation/properties.html#dopplercomputer","title":"DopplerComputer","text":"<p>Computes Doppler frequency shifts for uplink and/or downlink communications:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# S-band downlink only (8.4 GHz)\ndoppler = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=8.4e9,\n    sampling_config=bh.SamplingConfig.fixed_interval(0.1, 0.0),  # 0.1 seconds\n)\nprint(f\"Downlink only: {doppler}\")\n# Downlink only: DopplerComputer(uplink=None, downlink=8.4e9 Hz, ...)\n\n# Both uplink (2.0 GHz) and downlink (8.4 GHz)\ndoppler = bh.DopplerComputer(\n    uplink_frequency=2.0e9,\n    downlink_frequency=8.4e9,\n    sampling_config=bh.SamplingConfig.fixed_count(100),\n)\nprint(f\"Both frequencies: {doppler}\")\n# Both frequencies: DopplerComputer(uplink=2.0e9 Hz, downlink=8.4e9 Hz, ...)\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station (lon, lat, alt)\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with Doppler\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler],\n)\n\n# Access computed properties\nwindow = windows[0]\ndoppler_data = window.properties.additional[\"doppler_downlink\"]\ntimes = doppler_data[\"times\"]  # Seconds from window start\nvalues = doppler_data[\"values\"]  # Hz\nprint(\n    f\"\\nFirst pass downlink Doppler shift range: {min(values):.1f} to {max(values):.1f} Hz\"\n)\n# First pass Doppler shift range: -189220.9 to 189239.8 Hz\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{DopplerComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // S-band downlink only (8.4 GHz)\n    let _doppler = DopplerComputer::new(\n        None,  // No uplink\n        Some(8.4e9),  // Downlink frequency\n        SamplingConfig::FixedInterval { interval: 0.1, offset: 0.0 }  // 0.1 seconds\n    );\n    println!(\"Downlink only: uplink=None, downlink=8.4e9 Hz\");\n    // Downlink only: uplink=None, downlink=8.4e9 Hz\n\n    // Both uplink (2.0 GHz) and downlink (8.4 GHz)\n    let doppler = DopplerComputer::new(\n        Some(2.0e9),  // Uplink frequency\n        Some(8.4e9),  // Downlink frequency\n        SamplingConfig::FixedCount(100)\n    );\n    println!(\"Both frequencies: uplink=2.0e9 Hz, downlink=8.4e9 Hz\");\n    // Both frequencies: uplink=2.0e9 Hz, downlink=8.4e9 Hz\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station (lon, lat, alt)\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with Doppler\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;doppler]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let doppler_data = window.properties.additional.get(\"doppler_downlink\").unwrap();\n\n    // Extract values from TimeSeries\n    let values = match doppler_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    let min_val = values.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b));\n    let max_val = values.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b));\n\n    println!(\"\\nFirst pass downlink Doppler shift range: {:.1} to {:.1} Hz\", min_val, max_val);\n    // First pass Doppler shift range: -189220.9 to 189239.8 Hz\n\n    Ok(())\n}\n</code></pre> <p>Doppler Physics:</p> <ul> <li>Uplink: \\(\\Delta f = f_0\\frac{v_{los}}{c - v_{los}}\\) - Ground station pre-compensates transmit frequency</li> <li>Downlink: \\(\\Delta f = -f_0\\frac{v_{los}}{c}\\) - Ground station adjusts receive frequency</li> <li>Where \\(v_{los}\\) is the velocity of the object along the line of sight from the observer. With \\(v_{los} &lt; 0\\) when approaching and \\(v_{los} &gt; 0\\) when receding.</li> </ul>"},{"location":"learn/access_computation/properties.html#rangecomputer","title":"RangeComputer","text":"<p>Computes slant range (distance) from the location to the satellite:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute range at 50 evenly-spaced points\nrange_comp = bh.RangeComputer(sampling_config=bh.SamplingConfig.fixed_count(50))\nprint(f\"Range computer: {range_comp}\")\n# Range computer: RangeComputer(sampling=FixedCount(50))\n\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with range\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[range_comp],\n)\n\n# Access computed properties\nwindow = windows[0]\nrange_data = window.properties.additional[\"range\"]\ndistances_m = range_data[\"values\"]  # meters\ndistances_km = [d / 1000.0 for d in distances_m]\nprint(f\"\\nRange varies from {min(distances_km):.1f} to {max(distances_km):.1f} km\")\n# Range varies from 658.9 to 1501.0 km\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{RangeComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Compute range at 50 evenly-spaced points\n    let range_comp = RangeComputer::new(\n        SamplingConfig::FixedCount(50)\n    );\n    println!(\"Range computer: sampling=FixedCount(50)\");\n    // Range computer: sampling=FixedCount(50)\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with range\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;range_comp]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let range_data = window.properties.additional.get(\"range\").unwrap();\n\n    // Extract values from TimeSeries\n    let distances_m = match range_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    // Convert to km\n    let min_km = distances_m.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b)) / 1000.0;\n    let max_km = distances_m.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b)) / 1000.0;\n\n    println!(\"\\nRange varies from {:.1} to {:.1} km\", min_km, max_km);\n    // Range varies from 658.9 to 1501.0 km\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#rangeratecomputer","title":"RangeRateComputer","text":"<p>Computes line-of-sight velocity (range rate) with the convention that positive values indicate increasing range (satellite receding) and negative values indicate decreasing range (satellite approaching):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute range rate every 0.5 seconds\nrange_rate = bh.RangeRateComputer(\n    sampling_config=bh.SamplingConfig.fixed_interval(0.5, 0.0)  # 0.5 seconds\n)\nprint(f\"Range rate computer: {range_rate}\")\n# Range rate computer: RangeRateComputer()\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with range rate\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[range_rate],\n)\n\n# Access computed properties\nwindow = windows[0]\nrr_data = window.properties.additional[\"range_rate\"]\nvelocities_mps = rr_data[\"values\"]  # m/s (positive=receding)\nprint(\n    f\"\\nRange rate varies from {min(velocities_mps):.1f} to {max(velocities_mps):.1f} m/s\"\n)\nprint(\"Negative = approaching (decreasing distance)\")\nprint(\"Positive = receding (increasing distance)\")\n# Range rate varies from -6382.0 to 6372.9 m/s\n# Negative = approaching (decreasing distance)\n# Positive = receding (increasing distance)\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{RangeRateComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Compute range rate every 0.5 seconds\n    let range_rate = RangeRateComputer::new(\n        SamplingConfig::FixedInterval { interval: 0.5, offset: 0.0 }  // 0.5 seconds\n    );\n    println!(\"Range rate computer: sampling=FixedInterval(0.5s)\");\n    // Range rate computer: sampling=FixedInterval(0.5s)\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with range rate\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;range_rate]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let rr_data = window.properties.additional.get(\"range_rate\").unwrap();\n\n    // Extract values from TimeSeries\n    let velocities_mps = match rr_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    let min_vel = velocities_mps.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b));\n    let max_vel = velocities_mps.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b));\n\n    println!(\"\\nRange rate varies from {:.1} to {:.1} m/s\", min_vel, max_vel);\n    println!(\"Negative = approaching (decreasing distance)\");\n    println!(\"Positive = receding (increasing distance)\");\n    // Range rate varies from -6382.0 to 6372.9 m/s\n    // Negative = approaching (decreasing distance)\n    // Positive = receding (increasing distance)\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#custom-property-computers","title":"Custom Property Computers","text":"<p>You can also create your own property computer to compute application-specific properties values. The system will pre-sample the satellite state at the specified times defined by your <code>SamplingConfig</code>, so you don't need to manually propagate the trajectory.</p> <p>This section provides examples of custom property computers in both Python and Rust.</p>"},{"location":"learn/access_computation/properties.html#python-implementation","title":"Python Implementation","text":"<p>In python you subclass <code>AccessPropertyComputer</code> and implement three methods:</p> Python <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n\nclass MaxSpeedComputer(bh.AccessPropertyComputer):\n    \"\"\"Computes maximum ground speed during access.\"\"\"\n\n    def sampling_config(self):\n        # Sample every 0.5 seconds\n        return bh.SamplingConfig.fixed_interval(0.5, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        # Extract velocities from states\n        velocities = sample_states_ecef[:, 3:6]\n        speeds = np.linalg.norm(velocities, axis=1)\n        max_speed = np.max(speeds)\n\n        # Single value -&gt; returns as scalar\n        return {\n            \"max_ground_speed\": max_speed,  # Will be stored as Scalar\n        }\n\n    def property_names(self):\n        return [\"max_ground_speed\"]\n\n\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute with custom property\nmax_speed = MaxSpeedComputer()\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[max_speed],\n)\n\nfor window in windows:\n    speed = window.properties.additional[\"max_ground_speed\"]\n    print(f\"Max speed: {speed:.1f} m/s\")\n\n# Output example:\n# Max speed: 7360.1 m/s\n# Max speed: 7365.5 m/s\n# Max speed: 7361.2 m/s\n# Max speed: 7357.5 m/s\n# Max speed: 7357.8 m/s\n# Max speed: 7360.0 m/s\n</code></pre>"},{"location":"learn/access_computation/properties.html#combining-multiple-computers","title":"Combining Multiple Computers","text":"<p>Pass multiple computers to compute different properties simultaneously:</p> Python <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n\nclass MaxSpeedComputer(bh.AccessPropertyComputer):\n    \"\"\"Computes maximum ground speed during access.\"\"\"\n\n    def sampling_config(self):\n        return bh.SamplingConfig.fixed_interval(0.5, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        velocities = sample_states_ecef[:, 3:6]\n        speeds = np.linalg.norm(velocities, axis=1)\n        max_speed = np.max(speeds)\n        return {\"max_ground_speed\": max_speed}\n\n    def property_names(self):\n        return [\"max_ground_speed\"]\n\n\n# Mix built-in and custom computers\ndoppler = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=2.2e9,\n    sampling_config=bh.SamplingConfig.fixed_interval(0.1, 0.0),\n)\n\nrange_comp = bh.RangeComputer(sampling_config=bh.SamplingConfig.midpoint())\n\ncustom_comp = MaxSpeedComputer()\n\n# Setup scenario\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute with all property computers\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler, range_comp, custom_comp],\n)\n\n# All properties available in results\nwindow = windows[0]\nprops = window.properties.additional\n\ndoppler_data = props[\"doppler_downlink\"]\nrange_data = props[\"range\"]\nmax_speed = props[\"max_ground_speed\"]\n\nprint(f\"Doppler: {len(doppler_data['values'])} samples\")\nprint(f\"Range: {range_data / 1000:.1f} km\")\nprint(f\"Max speed: {max_speed:.1f} m/s\")\n# Doppler: 3777 samples\n# Range: 658.4 km\n# Max speed: 7360.1 m/s\n</code></pre>"},{"location":"learn/access_computation/properties.html#rust-implementation","title":"Rust Implementation","text":"<p>To implement a custom property computer in Rust, create a struct that implements the <code>AccessPropertyComputer</code> trait by defining the <code>sampling_config</code> and <code>compute</code> methods.</p> Rust <pre><code>use brahe as bh;\nuse bh::access::{AccessPropertyComputer, AccessWindow, PropertyValue, SamplingConfig};\nuse bh::utils::{BraheError, Identifiable};\nuse std::collections::HashMap;\n\nstruct MaxSpeedComputer {\n    sampling_config: SamplingConfig,\n}\n\nimpl AccessPropertyComputer for MaxSpeedComputer {\n    fn sampling_config(&amp;self) -&gt; SamplingConfig {\n        self.sampling_config.clone()\n    }\n\n    fn compute(\n        &amp;self,\n        _window: &amp;AccessWindow,\n        _sample_epochs: &amp;[f64],\n        sample_states_ecef: &amp;[nalgebra::SVector&lt;f64, 6&gt;],\n        _location_ecef: &amp;nalgebra::Vector3&lt;f64&gt;,\n        _location_geodetic: &amp;nalgebra::Vector3&lt;f64&gt;,\n    ) -&gt; Result&lt;HashMap&lt;String, PropertyValue&gt;, BraheError&gt; {\n        let mut max_speed = 0.0;\n\n        for state in sample_states_ecef {\n            let velocity = state.fixed_rows::&lt;3&gt;(3);\n            let speed = velocity.norm();\n            if speed &gt; max_speed {\n                max_speed = speed;\n            }\n        }\n\n        let mut props = HashMap::new();\n        props.insert(\"max_ground_speed\".to_string(), PropertyValue::Scalar(max_speed));\n        Ok(props)\n    }\n\n    fn property_names(&amp;self) -&gt; Vec&lt;String&gt; {\n        vec![\"max_ground_speed\".to_string()]\n    }\n}\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute with custom property\n    let max_speed = MaxSpeedComputer {\n        sampling_config: SamplingConfig::FixedInterval {\n            interval: 0.5,  // 0.5 seconds\n            offset: 0.0,\n        },\n    };\n\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;max_speed]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    for window in &amp;windows {\n        let speed = match window.properties.additional.get(\"max_ground_speed\").unwrap() {\n            PropertyValue::Scalar(s) =&gt; s,\n            _ =&gt; panic!(\"Expected Scalar\"),\n        };\n        println!(\"Max speed: {:.1} m/s\", speed);\n    }\n\n    // Output example:\n    // Max speed: 7360.1 m/s\n    // Max speed: 7365.5 m/s\n    // Max speed: 7361.2 m/s\n    // Max speed: 7357.5 m/s\n    // Max speed: 7357.8 m/s\n    // Max speed: 7360.0 m/s\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#see-also","title":"See Also","text":"<ul> <li>Access Computation Overview</li> <li>Constraints</li> <li>Locations</li> <li>Computation Configuration</li> </ul>"},{"location":"learn/attitude_representations/index.html","title":"Attitude Representations","text":"<p>Brahe supports multiple mathematical representations for the attitude, or orientation, of 3D objects such as spacecraft. Each representation has its own advantages and disadvantages depending on the application. These representations are implemented based on the comprehensive treatment found in Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors by James Diebel.</p>"},{"location":"learn/attitude_representations/index.html#overview","title":"Overview","text":"<p>Attitude representation is fundamental to spacecraft dynamics and control. Brahe provides four different representations, each with their own advantages:</p> <ul> <li>Quaternions: Singularity-free, compact representation (4 parameters)</li> <li>Rotation Matrices: Direct transformation matrices (9 parameters)</li> <li>Euler Angles: Intuitive angular representation (3 parameters, but with singularities)</li> <li>Euler Axis: Axis-angle representation (4 parameters)</li> </ul>"},{"location":"learn/attitude_representations/index.html#conversions","title":"Conversions","text":"<p>Brahe provides functions to convert between all attitude representations. You can initialize an attitude in one representation and convert it to any other one as needed.</p>"},{"location":"learn/attitude_representations/index.html#choosing-a-representation","title":"Choosing a Representation","text":"<p>Use Quaternions when:</p> <ul> <li>Numerical stability is critical</li> <li>Interpolating between attitudes</li> <li>Propagating attitude dynamics</li> </ul> <p>Use Rotation Matrices when:</p> <ul> <li>Transforming vectors between frames</li> </ul> <p>Use Euler Angles when:</p> <ul> <li>Human readability is important</li> </ul> <p>Use Euler Axis when:</p> <ul> <li>Representing single rotations about an axis</li> </ul>"},{"location":"learn/attitude_representations/index.html#see-also","title":"See Also","text":"<ul> <li>API Reference - Attitude</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html","title":"Euler Angles","text":"<p>Euler angles represent rotations as three sequential rotations about coordinate axes.</p>"},{"location":"learn/attitude_representations/euler_angles.html#overview","title":"Overview","text":"<p>Euler angles describe orientation using three angles representing sequential rotations about specified axes. Brahe supports all 12 possible Euler angle sequences (e.g., XYZ, ZYX, ZYZ).</p>"},{"location":"learn/attitude_representations/euler_angles.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler angle rotation is specified by:</p> <ul> <li>Three angles: \\((\\phi, \\theta, \\psi)\\)</li> <li>A rotation sequence (e.g., XYZ, ZYX)</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#sequences","title":"Sequences","text":"<p>Brahe supports all valid Euler angle sequences, though some are more commonly used are:</p> <ul> <li>ZYX (3-2-1): Common in aerospace applications. Known as yaw-pitch-roll.</li> <li>XYZ (1-2-3): Common in robotics</li> <li>ZYZ (3-1-3): Common in classical mechanics</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#initialization","title":"Initialization","text":"<p>Euler angles can be created from individual angles with a specified rotation sequence, or converted from other attitude representations. When creating a new <code>EulerAngle</code> object, the rotation sequence of the created object must be specified.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from individual angles with ZYX sequence (yaw-pitch-roll)\n# 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll\nea_zyx = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    45.0,  # Yaw (Z)\n    30.0,  # Pitch (Y)\n    15.0,  # Roll (X)\n    bh.AngleFormat.DEGREES,\n)\nprint(\"ZYX Euler angles (yaw-pitch-roll):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_zyx.order}\")\n\n# Initialize from vector with XYZ sequence\nangles_vec = np.array([15.0, 30.0, 45.0])\nea_xyz = bh.EulerAngle.from_vector(\n    angles_vec, bh.EulerAngleOrder.XYZ, bh.AngleFormat.DEGREES\n)\nprint(\"\\nXYZ Euler angles (from vector):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_xyz.order}\")\n\n# Simple rotation about single axis (45\u00b0 about Z using ZYX)\nea_z_only = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    45.0,  # Z\n    0.0,  # Y\n    0.0,  # X\n    bh.AngleFormat.DEGREES,\n)\nprint(\"\\nSingle-axis rotation (45\u00b0 about Z using ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_z_only.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_z_only.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_z_only.psi):.1f}\u00b0\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(math.cos(math.pi / 8), 0.0, 0.0, math.sin(math.pi / 8))\nea_from_q = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\nprint(\"\\nFrom quaternion (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_q.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_q.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_q.psi):.1f}\u00b0\")\n\n# Initialize from Rotation Matrix\nrm = bh.RotationMatrix.Rz(45.0, bh.AngleFormat.DEGREES)\nea_from_rm = bh.EulerAngle.from_rotation_matrix(rm, bh.EulerAngleOrder.ZYX)\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_rm.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_rm.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_rm.psi):.1f}\u00b0\")\n\n# Initialize from Euler Axis\neuler_axis = bh.EulerAxis(np.array([0.0, 0.0, 1.0]), 45.0, bh.AngleFormat.DEGREES)\nea_from_ea = bh.EulerAngle.from_euler_axis(euler_axis, bh.EulerAngleOrder.ZYX)\n\nprint(\"\\nFrom Euler axis (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_ea.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_ea.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_ea.psi):.1f}\u00b0\")\n\n# Initialize from one EulerAngle to another with different order\n# Start with XZY order\nea_xzy = bh.EulerAngle.from_euler_angle(ea_zyx, bh.EulerAngleOrder.XZY)\nprint(\"\\nXZY Euler angles from ZYX:\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xzy.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Z): {math.degrees(ea_xzy.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (Y): {math.degrees(ea_xzy.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_xzy.order}\")\n\n# Convert to ZYX order (same physical rotation, different representation)\n# Go through quaternion as intermediate representation\nq_xzy = ea_xzy.to_quaternion()\nea_zyx_converted = bh.EulerAngle.from_quaternion(q_xzy, bh.EulerAngleOrder.ZYX)\nprint(\"\\nConverted back to ZYX order (same rotation):\")\nprint(f\"  Angle 1 (Z): {math.degrees(ea_zyx_converted.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_zyx_converted.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (X): {math.degrees(ea_zyx_converted.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_zyx_converted.order}\")\n\n# Expected output:\n# ZYX Euler angles (yaw-pitch-roll):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 30.0\u00b0\n#   Roll (X):  15.0\u00b0\n#   Order: ZYX\n#\n# XYZ Euler angles (from vector):\n#   Angle 1 (X): 15.0\u00b0\n#   Angle 2 (Y): 30.0\u00b0\n#   Angle 3 (Z): 45.0\u00b0\n#   Order: XYZ\n#\n# Single-axis rotation (45\u00b0 about Z using ZYX):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From quaternion (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From rotation matrix (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From Euler axis (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  -0.0\u00b0\n#\n# XZY Euler angles from ZYX:\n#   Angle 1 (X): 20.8\u00b0\n#   Angle 2 (Z): 50.8\u00b0\n#   Angle 3 (Y): 14.5\u00b0\n#   Order: XZY\n#\n# Converted back to ZYX order (same rotation):\n#   Angle 1 (Z): 45.0\u00b0\n#   Angle 2 (Y): 30.0\u00b0\n#   Angle 3 (X): 15.0\u00b0\n#   Order: ZYX\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::ToAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from individual angles with ZYX sequence (yaw-pitch-roll)\n    // 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll\n    let ea_zyx = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),  // Yaw (Z)\n        (30.0_f64).to_radians(),  // Pitch (Y)\n        (15.0_f64).to_radians(),  // Roll (X)\n        bh::AngleFormat::Radians\n    );\n    println!(\"ZYX Euler angles (yaw-pitch-roll):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_zyx.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_zyx.order);\n\n    // Initialize from vector with XYZ sequence\n    let angles_vec = na::SVector::&lt;f64, 3&gt;::new(\n        (15.0_f64).to_radians(),\n        (30.0_f64).to_radians(),\n        (45.0_f64).to_radians()\n    );\n    let ea_xyz = bh::EulerAngle::from_vector(angles_vec, bh::EulerAngleOrder::XYZ, bh::AngleFormat::Radians);\n    println!(\"\\nXYZ Euler angles (from vector):\");\n    println!(\"  Angle 1 (X): {:.1}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.1}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.1}\u00b0\", ea_xyz.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_xyz.order);\n\n    // Simple rotation about single axis (45\u00b0 about Z using ZYX)\n    let ea_z_only = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),  // Z\n        0.0,                       // Y\n        0.0,                       // X\n        bh::AngleFormat::Radians\n    );\n    println!(\"\\nSingle-axis rotation (45\u00b0 about Z using ZYX):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_z_only.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_z_only.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_z_only.psi.to_degrees());\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n    let ea_from_q = bh::EulerAngle::from_quaternion(q, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom quaternion (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_q.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_q.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_q.psi.to_degrees());\n\n    // Initialize from Rotation Matrix\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let ea_from_rm = bh::EulerAngle::from_rotation_matrix(rm, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_rm.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_rm.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_rm.psi.to_degrees());\n\n    // Initialize from Euler Axis\n    let euler_axis = bh::EulerAxis::new(na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0), 45.0, bh::AngleFormat::Degrees);\n    let ea_from_ea = bh::EulerAngle::from_euler_axis(euler_axis, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom Euler axis (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_ea.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_ea.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_ea.psi.to_degrees());\n\n    // Initialize from one EulerAngle to another with different order\n    // Start with XZY order\n    let ea_xzy = bh::EulerAngle::from_euler_angle(ea_zyx, bh::EulerAngleOrder::XZY);\n    println!(\"\\nXZY Euler angles from ZYX:\");\n    println!(\"  Angle 1 (X): {:.1}\u00b0\", ea_xzy.phi.to_degrees());\n    println!(\"  Angle 2 (Z): {:.1}\u00b0\", ea_xzy.theta.to_degrees());\n    println!(\"  Angle 3 (Y): {:.1}\u00b0\", ea_xzy.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_xzy.order);\n\n    // Convert to ZYX order (same physical rotation, different representation)\n    // Go through quaternion as intermediate representation\n    let q_xzy = ea_xzy.to_quaternion();\n    let ea_zyx_converted = bh::EulerAngle::from_quaternion(q_xzy, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nConverted back to ZYX order (same rotation):\");\n    println!(\"  Angle 1 (Z): {:.1}\u00b0\", ea_zyx_converted.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.1}\u00b0\", ea_zyx_converted.theta.to_degrees());\n    println!(\"  Angle 3 (X): {:.1}\u00b0\", ea_zyx_converted.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_zyx_converted.order);\n}\n\n// Expected output:\n// ZYX Euler angles (yaw-pitch-roll):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 30.0\u00b0\n//   Roll (X):  15.0\u00b0\n//   Order: ZYX\n//\n// XYZ Euler angles (from vector):\n//   Angle 1 (X): 15.0\u00b0\n//   Angle 2 (Y): 30.0\u00b0\n//   Angle 3 (Z): 45.0\u00b0\n//   Order: XYZ\n//\n// Single-axis rotation (45\u00b0 about Z using ZYX):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From quaternion (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From rotation matrix (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From Euler axis (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  -0.0\u00b0\n//\n// XZY Euler angles from ZYX:\n//   Angle 1 (X): 20.8\u00b0\n//   Angle 2 (Z): 50.8\u00b0\n//   Angle 3 (Y): 14.5\u00b0\n//   Order: XZY::132\n//\n// Converted back to ZYX order (same rotation):\n//   Angle 1 (Z): 45.0\u00b0\n//   Angle 2 (Y): 30.0\u00b0\n//   Angle 3 (X): 15.0\u00b0\n//   Order: ZYX::321\n</code></pre>"},{"location":"learn/attitude_representations/euler_angles.html#conversions","title":"Conversions","text":"<p>Convert between Euler angles and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create Euler angles (ZYX: 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll)\nea = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    math.radians(45.0),\n    math.radians(30.0),\n    math.radians(15.0),\n    bh.AngleFormat.RADIANS,\n)\n\nprint(\"Original Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea.psi):.1f}\u00b0\")\n\n# Convert to quaternion\nq = ea.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = ea.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler axis (axis-angle)\nea_axis = ea.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea_axis.axis[0]:.6f}, {ea_axis.axis[1]:.6f}, {ea_axis.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea_axis.angle):.3f}\u00b0\")\n\n# Expected output:\n# Original Euler angles (ZYX):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 30.0\u00b0\n#   Roll (X):  15.0\u00b0\n\n# To quaternion:\n#   q = [0.871836, 0.214680, 0.188824, 0.397693]\n\n# To rotation matrix:\n#   [0.612372, 0.774519, -0.158494]\n#   [-0.612372, 0.591506, 0.524519]\n#   [0.500000, -0.224144, 0.836516]\n\n# To Euler axis:\n#   Axis: [0.438304, 0.385514, 0.811954]\n#   Angle: 58.654\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::ToAttitude;\n\nfn main() {\n    // Create Euler angles (ZYX: 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll)\n    let ea = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),\n        (30.0_f64).to_radians(),\n        (15.0_f64).to_radians(),\n        bh::AngleFormat::Radians\n    );\n\n    println!(\"Original Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea.psi.to_degrees());\n\n    // Convert to quaternion\n    let q = ea.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = ea.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler axis (axis-angle)\n    let ea_axis = ea.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea_axis.axis[0], ea_axis.axis[1], ea_axis.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea_axis.angle.to_degrees());\n}\n\n// Expected output:\n// Original Euler angles (ZYX):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 30.0\u00b0\n//   Roll (X):  15.0\u00b0\n\n// To quaternion:\n//   q = [0.871836, 0.214680, 0.188824, 0.397693]\n\n// To rotation matrix:\n//   [0.612372, 0.774519, -0.158494]\n//   [-0.612372, 0.591506, 0.524519]\n//   [0.500000, -0.224144, 0.836516]\n\n// To Euler axis:\n//   Axis: [0.438304, 0.385514, 0.811954]\n//   Angle: 58.654\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_angles.html#see-also","title":"See Also","text":"<ul> <li>Euler Angles API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html","title":"Euler Axis (Axis-Angle)","text":"<p>The Euler axis representation describes rotations using a rotation axis and angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#overview","title":"Overview","text":"<p>Also known as axis-angle representation, this describes any rotation as a single rotation about a unit vector (axis) by a specified angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler axis rotation is specified by:</p> <ul> <li>Unit vector (axis): \\(\\hat{n} = [n_x, n_y, n_z]\\) where \\(|\\hat{n}| = 1\\)</li> <li>Rotation angle: \\(\\theta\\) (in radians)</li> </ul> <p>Together: \\([\\theta, n_x, n_y, n_z]\\) (4 parameters)</p>"},{"location":"learn/attitude_representations/euler_axis.html#initialization","title":"Initialization","text":"<p>Euler axis representations can be created from an axis vector and angle, or converted from other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from axis vector and angle\n# 45\u00b0 rotation about Z-axis\naxis_z = np.array([0.0, 0.0, 1.0])\nangle = math.radians(45.0)\nea_z = bh.EulerAxis(axis_z, angle, bh.AngleFormat.RADIANS)\n\nprint(\"45\u00b0 rotation about Z-axis:\")\nprint(f\"  Axis: [{ea_z.axis[0]:.3f}, {ea_z.axis[1]:.3f}, {ea_z.axis[2]:.3f}]\")\nprint(f\"  Angle: {math.degrees(ea_z.angle):.1f}\u00b0\")\n\n# 90\u00b0 rotation about X-axis\naxis_x = np.array([1.0, 0.0, 0.0])\nea_x = bh.EulerAxis(axis_x, math.radians(90.0), bh.AngleFormat.RADIANS)\n\nprint(\"\\n90\u00b0 rotation about X-axis:\")\nprint(f\"  Axis: [{ea_x.axis[0]:.3f}, {ea_x.axis[1]:.3f}, {ea_x.axis[2]:.3f}]\")\nprint(f\"  Angle: {math.degrees(ea_x.angle):.1f}\u00b0\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(math.cos(math.pi / 8), 0.0, 0.0, math.sin(math.pi / 8))\nea_from_q = bh.EulerAxis.from_quaternion(q)\n\nprint(\"\\nFrom quaternion (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_q.axis[0]:.6f}, {ea_from_q.axis[1]:.6f}, {ea_from_q.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_q.angle):.1f}\u00b0\")\n\n# Initialize from rotation matrix\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\nea_from_rm = bh.EulerAxis.from_rotation_matrix(rm)\n\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_rm.axis[0]:.6f}, {ea_from_rm.axis[1]:.6f}, {ea_from_rm.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_rm.angle):.1f}\u00b0\")\n\n# Initialize from EulerAngle\neuler_angle = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, 45.0, 0.0, 0.0, bh.AngleFormat.DEGREES\n)\nea_from_euler = bh.EulerAxis.from_euler_angle(euler_angle)\n\nprint(\"\\nFrom EulerAngle (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_euler.axis[0]:.6f}, {ea_from_euler.axis[1]:.6f}, {ea_from_euler.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_euler.angle):.1f}\u00b0\")\n\n# Expected output:\n# 45\u00b0 rotation about Z-axis:\n#   Axis: [0.000, 0.000, 1.000]\n#   Angle: 45.0\u00b0\n\n# 90\u00b0 rotation about X-axis:\n#   Axis: [1.000, 0.000, 0.000]\n#   Angle: 90.0\u00b0\n\n# From quaternion (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# From rotation matrix (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# From EulerAngle (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from axis vector and angle\n    // 45\u00b0 rotation about Z-axis\n    let axis_z = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0);\n    let angle = (45.0_f64).to_radians();\n    let ea_z = bh::EulerAxis::new(axis_z, angle, bh::AngleFormat::Radians);\n\n    println!(\"45\u00b0 rotation about Z-axis:\");\n    println!(\"  Axis: [{:.3}, {:.3}, {:.3}]\", ea_z.axis[0], ea_z.axis[1], ea_z.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_z.angle.to_degrees());\n\n    // 90\u00b0 rotation about X-axis\n    let axis_x = na::SVector::&lt;f64, 3&gt;::new(1.0, 0.0, 0.0);\n    let ea_x = bh::EulerAxis::new(axis_x, (90.0_f64).to_radians(), bh::AngleFormat::Radians);\n\n    println!(\"\\n90\u00b0 rotation about X-axis:\");\n    println!(\"  Axis: [{:.3}, {:.3}, {:.3}]\", ea_x.axis[0], ea_x.axis[1], ea_x.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_x.angle.to_degrees());\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n    let ea_from_q = bh::EulerAxis::from_quaternion(q);\n\n    println!(\"\\nFrom quaternion (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_q.axis[0], ea_from_q.axis[1], ea_from_q.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_q.angle.to_degrees());\n\n    // Initialize from rotation matrix\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let ea_from_rm = bh::EulerAxis::from_rotation_matrix(rm);\n\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_rm.axis[0], ea_from_rm.axis[1], ea_from_rm.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_rm.angle.to_degrees());\n\n    // Initialize from EulerAngle\n    let euler_angle = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),\n        0.0,\n        0.0,\n        bh::AngleFormat::Radians\n    );\n    let ea_from_euler = bh::EulerAxis::from_euler_angle(euler_angle);\n\n    println!(\"\\nFrom EulerAngle (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_euler.axis[0], ea_from_euler.axis[1], ea_from_euler.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_euler.angle.to_degrees());\n}\n\n// Expected output:\n// 45\u00b0 rotation about Z-axis:\n//   Axis: [0.000, 0.000, 1.000]\n//   Angle: 45.0\u00b0\n//\n// 90\u00b0 rotation about X-axis:\n//   Axis: [1.000, 0.000, 0.000]\n//   Angle: 90.0\u00b0\n//\n// From quaternion (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n//\n// From rotation matrix (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n//\n// From EulerAngle (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_axis.html#conversions","title":"Conversions","text":"<p>Convert between Euler axis and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Create an Euler axis (45\u00b0 rotation about Z-axis)\nea = bh.EulerAxis(np.array([0.0, 0.0, 1.0]), math.radians(45.0), bh.AngleFormat.RADIANS)\n\nprint(\"Original Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.1f}\u00b0\")\n\n# Convert to quaternion\nq = ea.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = ea.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_angles_zyx = ea.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_angles_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_angles_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_angles_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_angles_xyz = ea.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_angles_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_angles_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_angles_xyz.psi):.3f}\u00b0\")\n\n# Round-trip conversion test\nq_roundtrip = ea.to_quaternion()\nea_roundtrip = bh.EulerAxis.from_quaternion(q_roundtrip)\nprint(\"\\nRound-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\")\nprint(\n    f\"  Axis: [{ea_roundtrip.axis[0]:.6f}, {ea_roundtrip.axis[1]:.6f}, {ea_roundtrip.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_roundtrip.angle):.1f}\u00b0\")\n\n# Expected output:\n# Original Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# To quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n# To rotation matrix:\n#   [0.707107, 0.707107, 0.000000]\n#   [-0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  -0.000\u00b0\n\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): -0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n\n# Round-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\nuse nalgebra as na;\n\nfn main() {\n    // Create an Euler axis (45\u00b0 rotation about Z-axis)\n    let ea = bh::EulerAxis::new(\n        na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0),\n        (45.0_f64).to_radians(),\n        bh::AngleFormat::Radians\n    );\n\n    println!(\"Original Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea.angle.to_degrees());\n\n    // Convert to quaternion\n    let q = ea.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = ea.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_angles_zyx = ea.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_angles_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_angles_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_angles_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_angles_xyz = ea.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_angles_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_angles_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_angles_xyz.psi.to_degrees());\n\n    // Round-trip conversion test\n    let q_roundtrip = ea.to_quaternion();\n    let ea_roundtrip = bh::EulerAxis::from_quaternion(q_roundtrip);\n    println!(\"\\nRound-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_roundtrip.axis[0], ea_roundtrip.axis[1], ea_roundtrip.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_roundtrip.angle.to_degrees());\n}\n\n// Expected output:\n// Original Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n\n// To quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n// To rotation matrix:\n//   [0.707107, 0.707107, 0.000000]\n//   [-0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  -0.000\u00b0\n\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): -0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n\n// Round-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_axis.html#see-also","title":"See Also","text":"<ul> <li>Euler Axis API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/quaternions.html","title":"Quaternions","text":"<p>A quaternion is a four-element mathematical object that can represent any 3D rotation without singularities. In Brahe, quaternions use the scalar-first convention: <code>[w, x, y, z]</code>.</p>"},{"location":"learn/attitude_representations/quaternions.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A unit quaternion is defined as:</p> \\[q = [w, x, y, z]\\] <p>where \\(w^2 + x^2 + y^2 + z^2 = 1\\) for unit quaternions. \\(w\\) is the scalar part, and \\((x, y, z)\\) is the vector part. Quaternions can also be formulated with the scalar part as the last element, which brahe also supports for input/output.</p>"},{"location":"learn/attitude_representations/quaternions.html#initialization","title":"Initialization","text":"<p>Quaternions can be initialized in several ways, including directly from all other attitude representations:</p> PythonRust <pre><code>import math\nimport brahe as bh\nimport numpy as np\n\n\n# Initialize from individual components (w, x, y, z)\n# Always scalar-first in constructor\nq1 = bh.Quaternion(0.924, 0.0, 0.0, 0.383)\nprint(\"From components (identity):\")\nprint(f\"  q = [{q1.w:.3f}, {q1.x:.3f}, {q1.y:.3f}, {q1.z:.3f}]\")\n\n# Initialize from vector/array [w, x, y, z]\n# Can specify if scalar is first or last\nq2 = bh.Quaternion.from_vector(np.array([0.924, 0.0, 0.0, 0.383]), scalar_first=True)\nprint(\"\\nFrom vector:\")\nprint(f\"  q = [{q2.w:.3f}, {q2.x:.3f}, {q2.y:.3f}, {q2.z:.3f}]\")\n\n# Initialize from another representation (rotation matrix)\n# 90\u00b0 rotation about Z-axis\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\nq3 = bh.Quaternion.from_rotation_matrix(rm)\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z-axis):\")\nprint(f\"  q = [{q3.w:.3f}, {q3.x:.3f}, {q3.y:.3f}, {q3.z:.3f}]\")\n\n# Initialize from Euler angles (ZYX sequence)\nea = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, math.pi / 4, 0.0, 0.0, bh.AngleFormat.RADIANS\n)\nq4 = bh.Quaternion.from_euler_angle(ea)\nprint(\"\\nFrom Euler angles (45\u00b0 yaw, ZYX):\")\nprint(f\"  q = [{q4.w:.3f}, {q4.x:.3f}, {q4.y:.3f}, {q4.z:.3f}]\")\n\n# Initialize from Euler axis (axis-angle representation)\naxis = np.array([0.0, 0.0, 1.0])  # Z-axis\nangle = math.pi / 4  # 45\u00b0\nea_rep = bh.EulerAxis(axis, angle, bh.AngleFormat.RADIANS)\nq5 = bh.Quaternion.from_euler_axis(ea_rep)\nprint(\"\\nFrom Euler axis (45\u00b0 about Z-axis):\")\nprint(f\"  q = [{q5.w:.3f}, {q5.x:.3f}, {q5.y:.3f}, {q5.z:.3f}]\")\n\n# Expected output:\n# From components (identity):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From vector:\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From rotation matrix (45\u00b0 about Z-axis):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From Euler angles (45\u00b0 yaw, ZYX):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From Euler axis (45\u00b0 about Z-axis):\n#   q = [0.924, 0.000, 0.000, 0.383]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from individual components (w, x, y, z)\n    // Always scalar-first in constructor\n    let q1 = bh::Quaternion::new(0.924, 0.0, 0.0, 0.383);\n    println!(\"From components (identity):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q1[0], q1[1], q1[2], q1[3]);\n\n    // Initialize from vector/array [w, x, y, z]\n    // Can specify if scalar is first or last\n    let vec = na::SVector::&lt;f64, 4&gt;::new(0.924, 0.0, 0.0, 0.383);\n    let q2 = bh::Quaternion::from_vector(vec, true);  // scalar_first = true\n    println!(\"\\nFrom vector:\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q2[0], q2[1], q2[2], q2[3]);\n\n    // Initialize from another representation (rotation matrix)\n    // 45\u00b0 rotation about Z-axis\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let q3 = bh::Quaternion::from_rotation_matrix(rm);\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z-axis):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q3[0], q3[1], q3[2], q3[3]);\n\n    // Initialize from Euler angles (ZYX sequence)\n    let ea = bh::EulerAngle::new(bh::EulerAngleOrder::ZYX, PI/4.0, 0.0, 0.0, bh::AngleFormat::Radians);\n    let q4 = bh::Quaternion::from_euler_angle(ea);\n    println!(\"\\nFrom Euler angles (45\u00b0 yaw, ZYX):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q4[0], q4[1], q4[2], q4[3]);\n\n    // Initialize from Euler axis (axis-angle representation)\n    let axis = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0);  // Z-axis\n    let angle = PI / 4.0;  // 45\u00b0\n    let ea_rep = bh::EulerAxis::new(axis, angle, bh::AngleFormat::Radians);\n    let q5 = bh::Quaternion::from_euler_axis(ea_rep);\n    println!(\"\\nFrom Euler axis (45\u00b0 about Z-axis):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q5[0], q5[1], q5[2], q5[3]);\n}\n\n// Expected output:\n// From components (identity):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From vector:\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From rotation matrix (45\u00b0 about Z-axis):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From Euler angles (45\u00b0 yaw, ZYX):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From Euler axis (45\u00b0 about Z-axis):\n//   q = [0.924, 0.000, 0.000, 0.383]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#output-and-access","title":"Output and Access","text":"<p>You can access quaternion components directly or convert them to other data formats:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a quaternion (45\u00b0 rotation about Z-axis)\nq = bh.Quaternion.from_rotation_matrix(bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES))\n\n# Access individual components\nprint(\"Individual components:\")\nprint(f\"  w (scalar): {q.w:.6f}\")\nprint(f\"  x: {q.x:.6f}\")\nprint(f\"  y: {q.y:.6f}\")\nprint(f\"  z: {q.z:.6f}\")\n\n# Directly access as a vector/array\nvec = q.data\nprint(\"\\nAs vector [w, x, y, z]:\")\nprint(f\"  {vec}: {type(vec)}\")\n\n# Or return copy as a NumPy array\nvec_np = q.to_vector(scalar_first=True)\nprint(\"\\nAs vector [w, x, y, z]:\")\nprint(f\"  {vec_np}: {type(vec_np)}\")\n\n# Return in different order (scalar last)\nvec_np_last = q.to_vector(scalar_first=False)\nprint(\"\\nAs scalar-last [x, y, z, w]:\")\nprint(f\"  {vec_np_last}: {type(vec_np_last)}\")\n\n# Display as string\nprint(\"\\nString representation:\")\nprint(f\"  {q}\")\n\nprint(\"\\Repr representation:\")\nprint(f\"  {repr(q)}\")\n\n# Expected output:\n# Individual components:\n#   w (scalar): 0.923880\n#   x: 0.000000\n#   y: 0.000000\n#   z: 0.382683\n\n# As vector :\n#   [0.92387953 0.         0.         0.38268343]: &lt;class 'numpy.ndarray'&gt;\n\n# As vector :\n#   [0.92387953 0.         0.         0.38268343]: &lt;class 'numpy.ndarray'&gt;\n\n# As scalar-last :\n#   [0.         0.         0.38268343 0.92387953]: &lt;class 'numpy.ndarray'&gt;\n\n# String representation:\n#   Quaternion: [s: 0.9238795325112867, v: [0, 0, 0.3826834323650897]]\n# \\Repr representation:\n#   Quaternion&lt;0.9238795325112867, 0, 0, 0.3826834323650897&gt;\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\n\nfn main() {\n    // Create a quaternion (45\u00b0 rotation about Z-axis)\n    let q = bh::Quaternion::from_rotation_matrix(\n        bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees)\n    );\n\n    // Access individual components\n    println!(\"Individual components:\");\n    println!(\"  w (scalar): {:.6}\", q[0]);\n    println!(\"  x: {:.6}\", q[1]);\n    println!(\"  y: {:.6}\", q[2]);\n    println!(\"  z: {:.6}\", q[3]);\n\n    // Directly access as a vector/array\n    let vec = q.to_vector(true);\n    println!(\"\\nAs vector [w, x, y, z]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec[0], vec[1], vec[2], vec[3]);\n\n    // Or return copy as a vector\n    let vec_np = q.to_vector(true);\n    println!(\"\\nAs vector [w, x, y, z]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec_np[0], vec_np[1], vec_np[2], vec_np[3]);\n\n    // Return in different order (scalar last)\n    let vec_np_last = q.to_vector(false);\n    println!(\"\\nAs scalar-last [x, y, z, w]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec_np_last[0], vec_np_last[1], vec_np_last[2], vec_np_last[3]);\n\n    // Display as string (Debug)\n    println!(\"\\nString representation:\");\n    println!(\"  {}\", q);\n\n    println!(\"\\nDebug representation:\");\n    println!(\"  {:?}\", q);\n}\n\n// Expected output:\n// Individual components:\n//   w (scalar): 0.923880\n//   x: 0.000000\n//   y: 0.000000\n//   z: 0.382683\n\n// As vector :\n//   [0.9238795325112867, 0, 0, 0.3826834323650897]\n\n// As vector :\n//   [0.9238795325112867, 0, 0, 0.3826834323650897]\n\n// As scalar-last :\n//   [0, 0, 0.3826834323650897, 0.9238795325112867]\n\n// String representation:\n//   Quaternion: [s: 0.9238795325112867, v: [0, 0, 0.3826834323650897]]\n\n// Debug representation:\n//   Quaternion&lt;0.9238795325112867, 0, 0, 0.3826834323650897&gt;\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#operations","title":"Operations","text":"<p>Quaternions support multiplication, normalization, conjugation, inversion, and interpolation (through Spherical Linear Interpolation (SLERP)):</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a quaternion from rotation matrix (90\u00b0 about X, then 45\u00b0 about Z)\nq = bh.Quaternion.from_rotation_matrix(\n    bh.RotationMatrix.Rx(90, bh.AngleFormat.DEGREES)\n    * bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n)\n\nprint(\"Original quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Compute norm\nnorm = q.norm()\nprint(f\"\\nNorm: {norm:.6f}\")\n\n# Normalize quaternion (in-place)\nq.normalize()  # In-place normalization (This shouldn't really do anything here since q already applies normalization on creation)\nprint(\"After normalization:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\nprint(f\"  Norm: {q.norm():.6f}\")\n\n# Compute conjugate\nq_conj = q.conjugate()\nprint(\"\\nConjugate:\")\nprint(f\"  q* = [{q_conj.w:.6f}, {q_conj.x:.6f}, {q_conj.y:.6f}, {q_conj.z:.6f}]\")\n\n# Compute inverse (same as conjugate for normalized quaternions)\nq_inv = q.inverse()\nprint(\"\\nInverse:\")\nprint(f\"  q^-1 = [{q_inv.w:.6f}, {q_inv.x:.6f}, {q_inv.y:.6f}, {q_inv.z:.6f}]\")\n\n# Quaternion multiplication (compose rotations)\n# 90\u00b0 about X, then 90\u00b0 about Z\nq_x = bh.Quaternion(math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0)\nq_z = bh.Quaternion(math.cos(math.pi / 4), 0.0, 0.0, math.sin(math.pi / 4))\nq_composed = q_z * q_x  # Apply q_x first, then q_z\nprint(\"\\nComposed rotation (90\u00b0 X then 90\u00b0 Z):\")\nprint(f\"  q_x = [{q_x.w:.6f}, {q_x.x:.6f}, {q_x.y:.6f}, {q_x.z:.6f}]\")\nprint(f\"  q_z = [{q_z.w:.6f}, {q_z.x:.6f}, {q_z.y:.6f}, {q_z.z:.6f}]\")\nprint(\n    f\"  q_composed = [{q_composed.w:.6f}, {q_composed.x:.6f}, {q_composed.y:.6f}, {q_composed.z:.6f}]\"\n)\n\n# Multiply q and its inverse to verify identity\nidentity = q * q_inv\nprint(\"\\nq * q^-1 (should be identity):\")\nprint(\n    f\"  q_identity = [{identity.w:.6f}, {identity.x:.6f}, {identity.y:.6f}, {identity.z:.6f}]\"\n)\n\n# SLERP (Spherical Linear Interpolation) between two quaternions\n# Interpolate from q_x (90\u00b0 about X) to q_z (90\u00b0 about Z)\nprint(\"\\nSLERP interpolation from q_x to q_z:\")\nq_slerp_0 = q_x.slerp(q_z, 0.0)  # t=0, should equal q_x\nprint(\n    f\"  t=0.0: [{q_slerp_0.w:.6f}, {q_slerp_0.x:.6f}, {q_slerp_0.y:.6f}, {q_slerp_0.z:.6f}]\"\n)\nq_slerp_25 = q_x.slerp(q_z, 0.25)\nprint(\n    f\"  t=0.25: [{q_slerp_25.w:.6f}, {q_slerp_25.x:.6f}, {q_slerp_25.y:.6f}, {q_slerp_25.z:.6f}]\"\n)\nq_slerp_5 = q_x.slerp(q_z, 0.5)  # t=0.5, halfway\nprint(\n    f\"  t=0.5: [{q_slerp_5.w:.6f}, {q_slerp_5.x:.6f}, {q_slerp_5.y:.6f}, {q_slerp_5.z:.6f}]\"\n)\nq_slerp_75 = q_x.slerp(q_z, 0.75)\nprint(\n    f\"  t=0.75: [{q_slerp_75.w:.6f}, {q_slerp_75.x:.6f}, {q_slerp_75.y:.6f}, {q_slerp_75.z:.6f}]\"\n)\nq_slerp_1 = q_x.slerp(q_z, 1.0)  # t=1, should equal q_z\nprint(\n    f\"  t=1.0: [{q_slerp_1.w:.6f}, {q_slerp_1.x:.6f}, {q_slerp_1.y:.6f}, {q_slerp_1.z:.6f}]\"\n)\n\n# Expected output:\n# Original quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n# To rotation matrix:\n#   [0.707107, 0.707107, 0.000000]\n#   [-0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  -0.000\u00b0\n\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): -0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n\n# Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n#   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Create a quaternion from rotation matrix (90\u00b0 about X, then 45\u00b0 about Z)\n    let mut q = bh::Quaternion::from_rotation_matrix(\n        bh::RotationMatrix::Rx(90.0, bh::AngleFormat::Degrees) * bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees)\n    );\n\n    println!(\"Original quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Compute norm\n    let norm = q.norm();\n    println!(\"\\nNorm: {:.6}\", norm);\n\n    // Normalize quaternion (in-place)\n    q.normalize();  // In-place normalization (This shouldn't really do anything here since q already applies normalization on creation)\n    println!(\"After normalization:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n    println!(\"  Norm: {:.6}\", q.norm());\n\n    // Compute conjugate\n    let q_conj = q.conjugate();\n    println!(\"\\nConjugate:\");\n    println!(\"  q* = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_conj[0], q_conj[1], q_conj[2], q_conj[3]);\n\n    // Compute inverse (same as conjugate for normalized quaternions)\n    let q_inv = q.inverse();\n    println!(\"\\nInverse:\");\n    println!(\"  q^-1 = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_inv[0], q_inv[1], q_inv[2], q_inv[3]);\n\n    // Quaternion multiplication (compose rotations)\n    // 90\u00b0 about X, then 90\u00b0 about Z\n    let q_x = bh::Quaternion::new((PI/4.0).cos(), (PI/4.0).sin(), 0.0, 0.0);\n    let q_z = bh::Quaternion::new((PI/4.0).cos(), 0.0, 0.0, (PI/4.0).sin());\n    let q_composed = q_z * q_x;  // Apply q_x first, then q_z\n    println!(\"\\nComposed rotation (90\u00b0 X then 90\u00b0 Z):\");\n    println!(\"  q_x = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_x[0], q_x[1], q_x[2], q_x[3]);\n    println!(\"  q_z = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_z[0], q_z[1], q_z[2], q_z[3]);\n    println!(\"  q_composed = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_composed[0], q_composed[1], q_composed[2], q_composed[3]);\n\n    // Multiply q and its inverse to verify identity\n    let identity = q * q_inv;\n    println!(\"\\nq * q^-1 (should be identity):\");\n    println!(\"  q_identity = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             identity[0], identity[1], identity[2], identity[3]);\n\n    // SLERP (Spherical Linear Interpolation) between two quaternions\n    // Interpolate from q_x (90\u00b0 about X) to q_z (90\u00b0 about Z)\n    println!(\"\\nSLERP interpolation from q_x to q_z:\");\n    let q_slerp_0 = q_x.slerp(q_z, 0.0);  // t=0, should equal q_x\n    println!(\"  t=0.0: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_0[0], q_slerp_0[1], q_slerp_0[2], q_slerp_0[3]);\n    let q_slerp_25 = q_x.slerp(q_z, 0.25);\n    println!(\"  t=0.25: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_25[0], q_slerp_25[1], q_slerp_25[2], q_slerp_25[3]);\n    let q_slerp_5 = q_x.slerp(q_z, 0.5);  // t=0.5, halfway\n    println!(\"  t=0.5: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_5[0], q_slerp_5[1], q_slerp_5[2], q_slerp_5[3]);\n    let q_slerp_75 = q_x.slerp(q_z, 0.75);\n    println!(\"  t=0.75: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_75[0], q_slerp_75[1], q_slerp_75[2], q_slerp_75[3]);\n    let q_slerp_1 = q_x.slerp(q_z, 1.0);  // t=1, should equal q_z\n    println!(\"  t=1.0: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_1[0], q_slerp_1[1], q_slerp_1[2], q_slerp_1[3]);\n}\n\n// Expected output:\n// Original quaternion:\n//   q = [0.653281, 0.653281, 0.270598, 0.270598]\n//\n// Norm: 1.000000\n// After normalization:\n//   q = [0.653281, 0.653281, 0.270598, 0.270598]\n//   Norm: 1.000000\n//\n// Conjugate:\n//   q* = [0.653281, -0.653281, -0.270598, -0.270598]\n//\n// Inverse:\n//   q^-1 = [0.653281, -0.653281, -0.270598, -0.270598]\n//\n// Composed rotation (90\u00b0 X then 90\u00b0 Z):\n//   q_x = [0.707107, 0.707107, 0.000000, 0.000000]\n//   q_z = [0.707107, 0.000000, 0.000000, 0.707107]\n//   q_composed = [0.500000, 0.500000, 0.500000, 0.500000]\n//\n// q * q^-1 (should be identity):\n//   q_identity = [1.000000, 0.000000, 0.000000, 0.000000]\n//\n// SLERP interpolation from q_x to q_z:\n//   t=0.0: [0.707107, 0.707107, 0.000000, 0.000000]\n//   t=0.25: [0.788675, 0.577350, 0.000000, 0.211325]\n//   t=0.5: [0.816497, 0.408248, 0.000000, 0.408248]\n//   t=0.75: [0.788675, 0.211325, 0.000000, 0.577350]\n//   t=1.0: [0.707107, 0.000000, 0.000000, 0.707107]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#conversions","title":"Conversions","text":"<p>You can convert quaternions to all other attitude representations and vice versa:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a quaternion (45\u00b0 rotation about Z-axis)\nq = bh.Quaternion.from_rotation_matrix(bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES))\n\nprint(\"Original quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = q.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_zyx = q.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_xyz = q.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.3f}\u00b0\")\n\n# Convert to Euler axis (axis-angle)\nea = q.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.3f}\u00b0\")\n\n# Round-trip conversion test\nq_roundtrip = bh.Quaternion.from_rotation_matrix(rm)\nprint(\"\\nRound-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\")\nprint(\n    f\"  q_rt = [{q_roundtrip.w:.6f}, {q_roundtrip.x:.6f}, {q_roundtrip.y:.6f}, {q_roundtrip.z:.6f}]\"\n)\n\n# Expected output:\n# Original quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n#\n# To rotation matrix:\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n#\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  0.000\u00b0\n#\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): 0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n#\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n#\n# Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n#   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Create a quaternion (45\u00b0 rotation about Z-axis)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n\n    println!(\"Original quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = q.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_zyx = q.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_xyz = q.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_xyz.psi.to_degrees());\n\n    // Convert to Euler axis (axis-angle)\n    let ea = q.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea.angle.to_degrees());\n\n    // Round-trip conversion test\n    let q_roundtrip = bh::Quaternion::from_rotation_matrix(rm);\n    println!(\"\\nRound-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\");\n    println!(\"  q_rt = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_roundtrip[0], q_roundtrip[1], q_roundtrip[2], q_roundtrip[3]);\n}\n\n// Expected output:\n// Original quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n// To rotation matrix:\n//   [0.707107, 0.707107, 0.000000]\n//   [-0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  -0.000\u00b0\n\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): -0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n\n// To Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.000\u00b0\n\n// Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n//   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#see-also","title":"See Also","text":"<ul> <li>Quaternion API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html","title":"Rotation Matrices","text":"<p>A rotation matrix is a 3\u00d73 matrix that transforms vectors from one coordinate frame to another. Also known as Direction Cosine Matrices (DCM).</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A rotation matrix is represented as:</p> \\[ R = \\begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} \\\\ r_{21} &amp; r_{22} &amp; r_{23} \\\\ r_{31} &amp; r_{32} &amp; r_{33} \\end{bmatrix} \\] <p>A rotation matrix \\(R\\) satisfies the properties:</p> \\[R^T R = I\\] \\[\\det(R) = 1\\] <p>where \\(I\\) is the identity matrix.</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#initialization","title":"Initialization","text":"<p>Rotation matrices can be created directly from elements, elementary rotations, or converted from other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from 9 individual elements (row-major order)\n# Identity rotation\nrm_identity = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\nprint(\"Identity rotation matrix:\")\nprint(f\"  [{rm_identity.r11:.3f}, {rm_identity.r12:.3f}, {rm_identity.r13:.3f}]\")\nprint(f\"  [{rm_identity.r21:.3f}, {rm_identity.r22:.3f}, {rm_identity.r23:.3f}]\")\nprint(f\"  [{rm_identity.r31:.3f}, {rm_identity.r32:.3f}, {rm_identity.r33:.3f}]\")\n\n# Initialize from a matrix of elements\nmatrix_elements = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\nrm_from_matrix = bh.RotationMatrix.from_matrix(matrix_elements)\nprint(\"\\nFrom matrix of elements:\")\nprint(\n    f\"  [{rm_from_matrix.r11:.3f}, {rm_from_matrix.r12:.3f}, {rm_from_matrix.r13:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_matrix.r21:.3f}, {rm_from_matrix.r22:.3f}, {rm_from_matrix.r23:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_matrix.r31:.3f}, {rm_from_matrix.r32:.3f}, {rm_from_matrix.r33:.3f}]\"\n)\n\n# Common rotation: 90\u00b0 about X-axis\nangle_x = 30\nrm_x = bh.RotationMatrix.Rx(angle_x, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_x}\u00b0 rotation about X-axis:\")\nprint(f\"  [{rm_x.r11:.3f}, {rm_x.r12:.3f}, {rm_x.r13:.3f}]\")\nprint(f\"  [{rm_x.r21:.3f}, {rm_x.r22:.3f}, {rm_x.r23:.3f}]\")\nprint(f\"  [{rm_x.r31:.3f}, {rm_x.r32:.3f}, {rm_x.r33:.3f}]\")\n\n# Common rotation: 90\u00b0 about Y-axis\nangle_y = 60\nrm_y = bh.RotationMatrix.Ry(angle_y, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_y}\u00b0 rotation about Y-axis:\")\nprint(f\"  [{rm_y.r11:.3f}, {rm_y.r12:.3f}, {rm_y.r13:.3f}]\")\nprint(f\"  [{rm_y.r21:.3f}, {rm_y.r22:.3f}, {rm_y.r23:.3f}]\")\nprint(f\"  [{rm_y.r31:.3f}, {rm_y.r32:.3f}, {rm_y.r33:.3f}]\")\n\n# Common rotation: 90\u00b0 about Z-axis\nangle_z = 45\nrm_z = bh.RotationMatrix.Rz(angle_z, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_z}\u00b0 rotation about Z-axis:\")\nprint(f\"  [{rm_z.r11:.3f}, {rm_z.r12:.3f}, {rm_z.r13:.3f}]\")\nprint(f\"  [{rm_z.r21:.3f}, {rm_z.r22:.3f}, {rm_z.r23:.3f}]\")\nprint(f\"  [{rm_z.r31:.3f}, {rm_z.r32:.3f}, {rm_z.r33:.3f}]\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(\n    math.cos(math.radians(angle_z) / 2), 0, 0, math.sin(math.radians(angle_z) / 2)\n)  # 90\u00b0 about Z-axis\nrm_from_q = bh.RotationMatrix.from_quaternion(q)\nprint(f\"\\nFrom quaternion ({angle_z}\u00b0 about Z-axis):\")\nprint(f\"  [{rm_from_q.r11:.3f}, {rm_from_q.r12:.3f}, {rm_from_q.r13:.3f}]\")\nprint(f\"  [{rm_from_q.r21:.3f}, {rm_from_q.r22:.3f}, {rm_from_q.r23:.3f}]\")\nprint(f\"  [{rm_from_q.r31:.3f}, {rm_from_q.r32:.3f}, {rm_from_q.r33:.3f}]\")\n\n# Initialize from Euler angles (ZYX sequence)\neuler_angles = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, angle_z, 0, 0, bh.AngleFormat.DEGREES\n)\nrm_from_euler = bh.RotationMatrix.from_euler_angle(euler_angles)\nprint(f\"\\nFrom Euler angles ({angle_z}\u00b0 about Z-axis):\")\nprint(f\"  [{rm_from_euler.r11:.3f}, {rm_from_euler.r12:.3f}, {rm_from_euler.r13:.3f}]\")\nprint(f\"  [{rm_from_euler.r21:.3f}, {rm_from_euler.r22:.3f}, {rm_from_euler.r23:.3f}]\")\nprint(f\"  [{rm_from_euler.r31:.3f}, {rm_from_euler.r32:.3f}, {rm_from_euler.r33:.3f}]\")\n\n# Initialize from Euler axis and angle\naxis = np.array([0, 0, 1])  # Z-axis\neuler_axis = bh.EulerAxis(axis, angle_z, bh.AngleFormat.DEGREES)\nrm_from_axis_angle = bh.RotationMatrix.from_euler_axis(euler_axis)\nprint(f\"\\nFrom Euler axis ({angle_z}\u00b0 about Z-axis):\")\nprint(\n    f\"  [{rm_from_axis_angle.r11:.3f}, {rm_from_axis_angle.r12:.3f}, {rm_from_axis_angle.r13:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_axis_angle.r21:.3f}, {rm_from_axis_angle.r22:.3f}, {rm_from_axis_angle.r23:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_axis_angle.r31:.3f}, {rm_from_axis_angle.r32:.3f}, {rm_from_axis_angle.r33:.3f}]\"\n)\n\n# Expected output:\n# Identity rotation matrix:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From matrix of elements:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# 30\u00b0 rotation about X-axis:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.866, 0.500]\n#   [0.000, -0.500, 0.866]\n\n# 60\u00b0 rotation about Y-axis:\n#   [0.500, 0.000, -0.866]\n#   [0.000, 1.000, 0.000]\n#   [0.866, 0.000, 0.500]\n\n# 45\u00b0 rotation about Z-axis:\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From quaternion (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From Euler angles (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From Euler axis (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::AngleFormat;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize from 9 individual elements (row-major order)\n    // Identity rotation\n    let rm_identity = bh::RotationMatrix::new(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    ).unwrap();\n    println!(\"Identity rotation matrix:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(0, 0)], rm_identity[(0, 1)], rm_identity[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(1, 0)], rm_identity[(1, 1)], rm_identity[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(2, 0)], rm_identity[(2, 1)], rm_identity[(2, 2)]);\n\n    // Initialize from a matrix of elements\n    let matrix_elements = na::SMatrix::&lt;f64, 3, 3&gt;::new(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    let rm_from_matrix = bh::RotationMatrix::from_matrix(matrix_elements).unwrap();\n    println!(\"\\nFrom matrix of elements:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(0, 0)], rm_from_matrix[(0, 1)], rm_from_matrix[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(1, 0)], rm_from_matrix[(1, 1)], rm_from_matrix[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(2, 0)], rm_from_matrix[(2, 1)], rm_from_matrix[(2, 2)]);\n\n    // Common rotation: 30\u00b0 about X-axis\n    let angle_x = 30.0;\n    let rm_x = bh::RotationMatrix::Rx(angle_x, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about X-axis:\", angle_x as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(0, 0)], rm_x[(0, 1)], rm_x[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(1, 0)], rm_x[(1, 1)], rm_x[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(2, 0)], rm_x[(2, 1)], rm_x[(2, 2)]);\n\n    // Common rotation: 60\u00b0 about Y-axis\n    let angle_y = 60.0;\n    let rm_y = bh::RotationMatrix::Ry(angle_y, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about Y-axis:\", angle_y as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(0, 0)], rm_y[(0, 1)], rm_y[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(1, 0)], rm_y[(1, 1)], rm_y[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(2, 0)], rm_y[(2, 1)], rm_y[(2, 2)]);\n\n    // Common rotation: 45\u00b0 about Z-axis\n    let angle_z = 45.0;\n    let rm_z = bh::RotationMatrix::Rz(angle_z, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about Z-axis:\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(0, 0)], rm_z[(0, 1)], rm_z[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(1, 0)], rm_z[(1, 1)], rm_z[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(2, 0)], rm_z[(2, 1)], rm_z[(2, 2)]);\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new(\n        (angle_z.to_radians() / 2.0).cos(),\n        0.0,\n        0.0,\n        (angle_z.to_radians() / 2.0).sin()\n    );\n    let rm_from_q = bh::RotationMatrix::from_quaternion(q);\n    println!(\"\\nFrom quaternion ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(0, 0)], rm_from_q[(0, 1)], rm_from_q[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(1, 0)], rm_from_q[(1, 1)], rm_from_q[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(2, 0)], rm_from_q[(2, 1)], rm_from_q[(2, 2)]);\n\n    // Initialize from Euler angles (ZYX sequence)\n    let euler_angles = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        angle_z,\n        0.0,\n        0.0,\n        AngleFormat::Degrees\n    );\n    let rm_from_euler = bh::RotationMatrix::from_euler_angle(euler_angles);\n    println!(\"\\nFrom Euler angles ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(0, 0)], rm_from_euler[(0, 1)], rm_from_euler[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(1, 0)], rm_from_euler[(1, 1)], rm_from_euler[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(2, 0)], rm_from_euler[(2, 1)], rm_from_euler[(2, 2)]);\n\n    // Initialize from Euler axis and angle\n    let axis = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0); // Z-axis\n    let euler_axis = bh::EulerAxis::new(axis, angle_z, AngleFormat::Degrees);\n    let rm_from_axis_angle = bh::RotationMatrix::from_euler_axis(euler_axis);\n    println!(\"\\nFrom Euler axis ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(0, 0)], rm_from_axis_angle[(0, 1)], rm_from_axis_angle[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(1, 0)], rm_from_axis_angle[(1, 1)], rm_from_axis_angle[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(2, 0)], rm_from_axis_angle[(2, 1)], rm_from_axis_angle[(2, 2)]);\n}\n\n// Expected output:\n// Identity rotation matrix:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From matrix of elements:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// 30\u00b0 rotation about X-axis:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.866, 0.500]\n//   [0.000, -0.500, 0.866]\n//\n// 60\u00b0 rotation about Y-axis:\n//   [0.500, 0.000, -0.866]\n//   [0.000, 1.000, 0.000]\n//   [0.866, 0.000, 0.500]\n//\n// 45\u00b0 rotation about Z-axis:\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From quaternion (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From Euler angles (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From Euler axis (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n</code></pre> <p>Tip</p> <p>Brahe provides convenient methods to create rotation matrices for elementary rotations about the X, Y, and Z axes:</p> <ul> <li><code>RotationMatrix.Rx(angle, format)</code></li> <li><code>RotationMatrix.Ry(angle, format)</code></li> <li><code>RotationMatrix.Rz(angle, format)</code></li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html#output-and-access","title":"Output and Access","text":"<p>Access rotation matrix elements and convert to other formats:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a rotation matrix (45\u00b0 about Z-axis)\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n\n# Access individual elements\nprint(\"Individual elements (row-by-row):\")\nprint(f\"  r11: {rm.r11:.6f}, r12: {rm.r12:.6f}, r13: {rm.r13:.6f}\")\nprint(f\"  r21: {rm.r21:.6f}, r22: {rm.r22:.6f}, r23: {rm.r23:.6f}\")\nprint(f\"  r31: {rm.r31:.6f}, r32: {rm.r32:.6f}, r33: {rm.r33:.6f}\")\n# String representation\nprint(\"\\nString representation:\")\nprint(f\"  {rm}\")\n\n# Expected output:\n# Individual elements (row-by-row):\n#   r11: 0.707107, r12: 0.707107, r13: 0.000000\n#   r21: -0.707107, r22: 0.707107, r23: 0.000000\n#   r31: 0.000000, r32: 0.000000, r33: 1.000000\n\n# String representation:\n#   RotationMatrix:\n\n#   \u250c                                                             \u2510\n#   \u2502  0.7071067811865476  0.7071067811865475                   0 \u2502\n#   \u2502 -0.7071067811865475  0.7071067811865476                   0 \u2502\n#   \u2502                   0                   0                   1 \u2502\n#   \u2514                                                             \u2518\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Create a rotation matrix (45\u00b0 about Z-axis)\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n\n    // Access individual elements\n    println!(\"Individual elements (row-by-row):\");\n    println!(\"  r11: {:.6}, r12: {:.6}, r13: {:.6}\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  r21: {:.6}, r22: {:.6}, r23: {:.6}\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  r31: {:.6}, r32: {:.6}, r33: {:.6}\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // String representation\n    println!(\"\\nString representation:\");\n    println!(\"  {:?}\", rm);\n}\n\n// Expected output:\n// Individual elements (row-by-row):\n//   r11: 0.707107, r12: 0.707107, r13: 0.000000\n//   r21: -0.707107, r22: 0.707107, r23: 0.000000\n//   r31: 0.000000, r32: 0.000000, r33: 1.000000\n\n// String representation:\n//   RotationMatrix: \n// [[0.7071067811865476, -0.7071067811865475, 0.0], [0.7071067811865475, 0.7071067811865476, 0.0], [0.0, 0.0, 1.0]]\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#operations","title":"Operations","text":"<p>Rotation matrices support composition through matrix multiplication and vector rotation:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Create two rotation matrices\n# 90\u00b0 rotation about X-axis\nrm_x = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0)\n\n# 90\u00b0 rotation about Z-axis\nrm_z = bh.RotationMatrix(0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n\nprint(\"Rotation matrix X (90\u00b0 about X):\")\nprint(f\"  [{rm_x.r11:.3f}, {rm_x.r12:.3f}, {rm_x.r13:.3f}]\")\nprint(f\"  [{rm_x.r21:.3f}, {rm_x.r22:.3f}, {rm_x.r23:.3f}]\")\nprint(f\"  [{rm_x.r31:.3f}, {rm_x.r32:.3f}, {rm_x.r33:.3f}]\")\n\nprint(\"\\nRotation matrix Z (90\u00b0 about Z):\")\nprint(f\"  [{rm_z.r11:.3f}, {rm_z.r12:.3f}, {rm_z.r13:.3f}]\")\nprint(f\"  [{rm_z.r21:.3f}, {rm_z.r22:.3f}, {rm_z.r23:.3f}]\")\nprint(f\"  [{rm_z.r31:.3f}, {rm_z.r32:.3f}, {rm_z.r33:.3f}]\")\n\n# Matrix multiplication (compose rotations)\n# Apply rm_x first, then rm_z\nrm_composed = rm_z * rm_x\nprint(\"\\nComposed rotation (X then Z):\")\nprint(f\"  [{rm_composed.r11:.3f}, {rm_composed.r12:.3f}, {rm_composed.r13:.3f}]\")\nprint(f\"  [{rm_composed.r21:.3f}, {rm_composed.r22:.3f}, {rm_composed.r23:.3f}]\")\nprint(f\"  [{rm_composed.r31:.3f}, {rm_composed.r32:.3f}, {rm_composed.r33:.3f}]\")\n\n# Transform a vector using rotation matrix\n# Rotate vector [1, 0, 0] by 90\u00b0 about Z-axis using matrix multiplication\nR_z = rm_z.to_matrix()  # Get 3x3 numpy array\nvector = np.array([1.0, 0.0, 0.0])\nrotated = R_z @ vector  # Matrix-vector multiplication\nprint(\"\\nVector transformation:\")\nprint(f\"  Original: [{vector[0]:.3f}, {vector[1]:.3f}, {vector[2]:.3f}]\")\nprint(f\"  Rotated:  [{rotated[0]:.3f}, {rotated[1]:.3f}, {rotated[2]:.3f}]\")\n\n# Transform another vector\nvector2 = np.array([0.0, 1.0, 0.0])\nrotated2 = R_z @ vector2\nprint(f\"\\n  Original: [{vector2[0]:.3f}, {vector2[1]:.3f}, {vector2[2]:.3f}]\")\nprint(f\"  Rotated:  [{rotated2[0]:.3f}, {rotated2[1]:.3f}, {rotated2[2]:.3f}]\")\n\n# Equality comparison\neq_result = rm_x == rm_z\nneq_result = rm_x != rm_z\nprint(\"\\nEquality comparison:\")\nprint(f\"  rm_x == rm_z: {eq_result}\")\nprint(f\"  rm_x != rm_z: {neq_result}\")\n\n# Expected output:\n# Rotation matrix X (90\u00b0 about X):\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.000, -1.000]\n#   [0.000, 1.000, 0.000]\n\n# Rotation matrix Z (90\u00b0 about Z):\n#   [0.000, -1.000, 0.000]\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# Composed rotation (X then Z):\n#   [0.000, 0.000, 1.000]\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n\n# Vector transformation:\n#   Original: [1.000, 0.000, 0.000]\n#   Rotated:  [0.000, 1.000, 0.000]\n\n#   Original: [0.000, 1.000, 0.000]\n#   Rotated:  [-1.000, 0.000, 0.000]\n\n# Equality comparison:\n#   rm_x == rm_z: False\n#   rm_x != rm_z: True\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    // Create two rotation matrices\n    // 90\u00b0 rotation about X-axis\n    let rm_x = bh::RotationMatrix::new(\n        1.0, 0.0, 0.0,\n        0.0, 0.0, -1.0,\n        0.0, 1.0, 0.0\n    ).unwrap();\n\n    // 90\u00b0 rotation about Z-axis\n    let rm_z = bh::RotationMatrix::new(\n        0.0, -1.0, 0.0,\n        1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    ).unwrap();\n\n    println!(\"Rotation matrix X (90\u00b0 about X):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(0, 0)], rm_x[(0, 1)], rm_x[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(1, 0)], rm_x[(1, 1)], rm_x[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(2, 0)], rm_x[(2, 1)], rm_x[(2, 2)]);\n\n    println!(\"\\nRotation matrix Z (90\u00b0 about Z):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(0, 0)], rm_z[(0, 1)], rm_z[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(1, 0)], rm_z[(1, 1)], rm_z[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(2, 0)], rm_z[(2, 1)], rm_z[(2, 2)]);\n\n    // Matrix multiplication (compose rotations)\n    // Apply rm_x first, then rm_z\n    let rm_composed = rm_z * rm_x;\n    println!(\"\\nComposed rotation (X then Z):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(0, 0)], rm_composed[(0, 1)], rm_composed[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(1, 0)], rm_composed[(1, 1)], rm_composed[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(2, 0)], rm_composed[(2, 1)], rm_composed[(2, 2)]);\n\n    // Transform a vector using rotation matrix\n    // Rotate vector [1, 0, 0] by 90\u00b0 about Z-axis using matrix multiplication\n    let vector = na::SVector::&lt;f64, 3&gt;::new(1.0, 0.0, 0.0);\n    let rotated = rm_z.to_matrix() * vector;  // Matrix-vector multiplication\n    println!(\"\\nVector transformation:\");\n    println!(\"  Original: [{:.3}, {:.3}, {:.3}]\", vector[0], vector[1], vector[2]);\n    println!(\"  Rotated:  [{:.3}, {:.3}, {:.3}]\", rotated[0], rotated[1], rotated[2]);\n\n    // Transform another vector\n    let vector2 = na::SVector::&lt;f64, 3&gt;::new(0.0, 1.0, 0.0);\n    let rotated2 = rm_z.to_matrix() * vector2;\n    println!(\"\\n  Original: [{:.3}, {:.3}, {:.3}]\", vector2[0], vector2[1], vector2[2]);\n    println!(\"  Rotated:  [{:.3}, {:.3}, {:.3}]\", rotated2[0], rotated2[1], rotated2[2]);\n\n    let eq_result = rm_x == rm_z;\n    let neq_result = rm_x != rm_z;\n    println!(\"\\nEquality comparison:\");\n    println!(\"  rm_x == rm_z: {}\", eq_result);\n    println!(\"  rm_x != rm_z: {}\", neq_result);\n}\n\n// Expected output:\n// Rotation matrix X (90\u00b0 about X):\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.000, -1.000]\n//   [0.000, 1.000, 0.000]\n\n// Rotation matrix Z (90\u00b0 about Z):\n//   [0.000, -1.000, 0.000]\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.000, 1.000]\n\n// Composed rotation (X then Z):\n//   [0.000, 0.000, 1.000]\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n\n// Vector transformation:\n//   Original: [1.000, 0.000, 0.000]\n//   Rotated:  [0.000, 1.000, 0.000]\n\n//   Original: [0.000, 1.000, 0.000]\n//   Rotated:  [-1.000, 0.000, 0.000]\n\n// Equality comparison:\n//   rm_x == rm_z: false\n//   rm_x != rm_z: true\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#conversions","title":"Conversions","text":"<p>Convert between rotation matrices and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a rotation matrix (45\u00b0 about Z-axis)\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n\nprint(\"Original rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to quaternion\nq = rm.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_zyx = rm.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_xyz = rm.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.3f}\u00b0\")\n\n# Convert to Euler axis (axis-angle)\nea = rm.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.3f}\u00b0\")\n\n# Round-trip conversion test\nrm_roundtrip = bh.RotationMatrix.from_quaternion(q)\nprint(\"\\nRound-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\")\nprint(f\"  [{rm_roundtrip.r11:.6f}, {rm_roundtrip.r12:.6f}, {rm_roundtrip.r13:.6f}]\")\nprint(f\"  [{rm_roundtrip.r21:.6f}, {rm_roundtrip.r22:.6f}, {rm_roundtrip.r23:.6f}]\")\nprint(f\"  [{rm_roundtrip.r31:.6f}, {rm_roundtrip.r32:.6f}, {rm_roundtrip.r33:.6f}]\")\n\n# Expected output:\n# Original rotation matrix:\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n#\n# To quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n#\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  0.000\u00b0\n#\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): 0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n#\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n#\n# Round-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\n\nfn main() {\n    // Create a rotation matrix (45\u00b0 about Z-axis)\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n\n    println!(\"Original rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to quaternion\n    let q = rm.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_zyx = rm.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_xyz = rm.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_xyz.psi.to_degrees());\n\n    // Convert to Euler axis (axis-angle)\n    let ea = rm.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea.angle.to_degrees());\n\n    // Round-trip conversion test\n    let rm_roundtrip = bh::RotationMatrix::from_quaternion(q);\n    println!(\"\\nRound-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(0, 0)], rm_roundtrip[(0, 1)], rm_roundtrip[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(1, 0)], rm_roundtrip[(1, 1)], rm_roundtrip[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(2, 0)], rm_roundtrip[(2, 1)], rm_roundtrip[(2, 2)]);\n}\n\n// Expected output:\n// Original rotation matrix:\n//   [0.707107, -0.707107, 0.000000]\n//   [0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n//\n// To quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n//\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  0.000\u00b0\n//\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): 0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n//\n// To Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.000\u00b0\n//\n// Round-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\n//   [0.707107, -0.707107, 0.000000]\n//   [0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#see-also","title":"See Also","text":"<ul> <li>Rotation Matrix API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/cli/index.html","title":"Brahe CLI","text":"<p>The Brahe command-line interface provides tools for quick-access time, coordinate, and orbital mechanics calculations directly from the terminal. It also provides functions to download Earth Orientation Parameters (EOP) and satellite datasets.</p>"},{"location":"learn/cli/index.html#installation","title":"Installation","text":"<p>The CLI is included with the Brahe Python package:</p> <pre><code>pip install brahe\n# or\nuv pip install brahe\n</code></pre>"},{"location":"learn/cli/index.html#quick-start","title":"Quick Start","text":"<pre><code># Get help\nbrahe --help\n\n# Convert between time formats\nbrahe time convert \"2024-01-01T00:00:00Z\" string mjd\n# 60310.00042824074\n\n# Calculate orbital period\nbrahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n# 94.616286\n\n# Transform coordinates between representations\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n# [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055\n\n# Compute satellite access windows\nbrahe access compute 25544 --lon -122.4194 --lat 37.7749\n# Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 37.7749\u00b0 lat, -122.4194\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 17 access window(s)\n# ...\n</code></pre>"},{"location":"learn/cli/index.html#command-groups","title":"Command Groups","text":""},{"location":"learn/cli/index.html#eop","title":"eop","text":"<p>Earth Orientation Parameter operations: - <code>download</code> - Download EOP data from IERS - <code>get-utc-ut1</code> - Get UTC-UT1 offset - <code>get-polar-motion</code> - Get polar motion parameters - <code>get-cip-offset</code> - Get CIP offset - <code>get-lod</code> - Get length of day</p>"},{"location":"learn/cli/index.html#datasets","title":"datasets","text":"<p>Download and query satellite data: - <code>celestrak</code> - CelesTrak TLE data operations - <code>groundstations</code> - Ground station database operations</p>"},{"location":"learn/cli/index.html#time","title":"time","text":"<p>Time system operations and conversions:</p> <ul> <li><code>convert</code> - Convert between time formats (MJD, JD, GPS, ISO-8601)</li> <li><code>add</code> - Add time offsets to epochs</li> <li><code>time-system-offset</code> - Calculate offsets between time systems</li> <li><code>range</code> - Generate time ranges</li> </ul>"},{"location":"learn/cli/index.html#orbits","title":"orbits","text":"<p>Orbital mechanics calculations:</p> <ul> <li><code>orbital-period</code> - Calculate orbital period from semi-major axis</li> <li><code>sma-from-period</code> - Calculate semi-major axis from period</li> <li><code>mean-motion</code> - Calculate mean motion</li> <li><code>anomaly-conversion</code> - Convert between anomaly types</li> <li><code>sun-sync-inclination</code> - Calculate sun-synchronous inclination</li> <li><code>perigee-velocity</code> / <code>apogee-velocity</code> - Calculate velocities at apsides</li> </ul>"},{"location":"learn/cli/index.html#transform","title":"transform","text":"<p>Convert between coordinate systems and reference frames:</p> <ul> <li><code>coordinates</code> - Convert between Keplerian, Cartesian, Geodetic, and Geocentric representations</li> </ul>"},{"location":"learn/cli/index.html#access","title":"access","text":"<p>Satellite access window calculations: - <code>compute</code> - Calculate visibility windows for ground stations</p>"},{"location":"learn/cli/index.html#global-options","title":"Global Options","text":"<pre><code>--verbose, -v    Enable verbose output (INFO level)\n--debug, -d      Enable debug output (DEBUG level)\n--help           Show help message\n</code></pre>"},{"location":"learn/cli/index.html#features","title":"Features","text":""},{"location":"learn/cli/index.html#constant-expressions","title":"Constant Expressions","text":"<p>Many numeric arguments support mathematical expressions using Brahe constants:</p> <pre><code># Use R_EARTH constant for semi-major axis (500km altitude LEO)\nbrahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n# 94.616286\n</code></pre> <p>Available constants include: - <code>R_EARTH</code>, <code>R_SUN</code>, <code>R_MOON</code> - Body radii (meters) - <code>GM_EARTH</code>, <code>GM_SUN</code>, <code>GM_MOON</code> - Gravitational parameters (m\u00b3/s\u00b2) - <code>DEG2RAD</code>, <code>RAD2DEG</code> - Angular conversions - <code>MJD_ZERO</code>, <code>MJD2000</code>, <code>GPS_ZERO</code> - Time epoch constants</p> <p>See the Constants documentation for the complete list.</p>"},{"location":"learn/cli/index.html#see-also","title":"See Also","text":"<ul> <li>Python API Documentation</li> <li>Coordinate Systems</li> <li>Time Systems</li> <li>Orbital Mechanics</li> </ul>"},{"location":"learn/cli/access.html","title":"Access Commands","text":"<p>The <code>access</code> command group calculates when satellites are visible from ground locations, considering elevation constraints and other visibility criteria.</p>"},{"location":"learn/cli/access.html#commands","title":"Commands","text":""},{"location":"learn/cli/access.html#compute","title":"<code>compute</code>","text":"<p>Compute satellite access windows for a ground location.</p> <p>Syntax: <pre><code>brahe access compute &lt;NORAD_ID&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID of the satellite (integer)</p> <p>Location Options (choose one):</p> <p>Location coordinates: - <code>--lat &lt;degrees&gt;</code> - Latitude in degrees (-90 to 90) - <code>--lon &lt;degrees&gt;</code> - Longitude in degrees (-180 to 180) - <code>--alt &lt;meters&gt;</code> - Altitude above WGS84 ellipsoid (default: 0.0)</p> <p>Or ground station lookup: - <code>--gs-provider &lt;name&gt;</code> - Ground station provider (e.g., 'ksat', 'atlas', 'aws') - <code>--gs-name &lt;name&gt;</code> - Ground station name to lookup</p> <p>Time Range Options:</p> <ul> <li><code>--start-time &lt;epoch&gt;</code> - Start time (ISO-8601). Default: now</li> <li><code>--end-time &lt;epoch&gt;</code> - End time (ISO-8601)</li> <li><code>--duration &lt;days&gt;</code> - Duration in days (default: 7)</li> </ul> <p>Constraint Options:</p> <ul> <li><code>--min-elevation &lt;degrees&gt;</code> - Minimum elevation angle (default: 10.0)</li> </ul> <p>Output Options:</p> <ul> <li><code>--output-format [table|rich|simple]</code> - Output format (default: <code>table</code>)</li> <li><code>--sort-by [contact_number|start_time|end_time|duration|max_elevation|start_azimuth|end_azimuth]</code> - Sort field (default: <code>start_time</code>)</li> <li><code>--sort-order [ascending|descending]</code> - Sort order (default: <code>ascending</code>)</li> <li><code>--max-results &lt;count&gt;</code> - Maximum number of windows to display</li> <li><code>--output-file &lt;path&gt;</code> - Export results to JSON file</li> </ul> <p>Examples:</p> <p>ISS passes over New York City (next 7 days): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n...\n</code></pre></p> <p>GPS satellite passes (15\u00b0 minimum elevation): <pre><code>brahe access compute 32260 --lat 40.7128 --lon -74.0060 --min-elevation 15\n</code></pre> Output: <pre><code># Access Windows for NAVSTAR 60 (USA 196) (NORAD ID: 32260)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 15.0\u00b0\n# Found 8 access window(s)\n</code></pre></p> <p>Custom time range: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --start-time \"2024-06-01T00:00:00Z\" \\\n  --duration 1\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 2 access window(s)\n</code></pre></p> <p>Use ground station database: <pre><code>brahe access compute 25544 --gs-provider ksat --gs-name \"Svalbard\"\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 78.2300\u00b0 lat, 15.4100\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 19 access window(s)\n</code></pre></p> <p>Simple output format: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-format simple\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n\n# 1. 2025-11-03 18:36:18.197 UTC | 2025-11-03 18:38:16.000 UTC | 1m 57s | Max Elev: 11.9\u00b0 | Az: 150\u00b0-114\u00b0\n# 2. 2025-11-03 20:11:37.226 UTC | 2025-11-03 20:16:16.000 UTC | 4m 38s | Max Elev: 20.6\u00b0 | Az: 255\u00b0-351\u00b0\n</code></pre></p> <p>Export to JSON: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-file passes.json\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n</code></pre></p> <p>Sort by maximum elevation (highest first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by max_elevation --sort-order descending --max-results 5\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 5 access window(s)\n\n# \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503         \u2503 Start   \u2503 End    \u2503         \u2503    Max \u2503   Start \u2503        \u2503\n# \u2503 Contact \u2503 Time    \u2503 Time   \u2503         \u2503   Elev \u2503      Az \u2503 End Az \u2503\n# \u2503       # \u2503 (UTC)   \u2503 (UTC)  \u2503 Durati\u2026 \u2503  (deg) \u2503   (deg) \u2503  (deg) \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502       1 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   77.0 \u2502     321 \u2502    148 \u2502\n# \u2502         \u2502 05:22:\u2026 \u2502 05:28\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 31.74   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       2 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   69.8 \u2502     319 \u2502    151 \u2502\n# \u2502         \u2502 06:58:\u2026 \u2502 07:04\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 30.04   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       3 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   57.9 \u2502     206 \u2502     46 \u2502\n# \u2502         \u2502 18:34:\u2026 \u2502 18:40\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 7.79    \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       4 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   52.9 \u2502     204 \u2502     48 \u2502\n# \u2502         \u2502 16:58:\u2026 \u2502 17:04\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 9.76    \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       5 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 5       \u2502   52.6 \u2502     227 \u2502     22 \u2502\n# \u2502         \u2502 17:46:\u2026 \u2502 17:52\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 59.45   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Sort by duration (longest passes first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by duration --sort-order descending\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n\n# \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503         \u2503 Start   \u2503 End    \u2503         \u2503    Max \u2503   Start \u2503        \u2503\n# \u2503 Contact \u2503 Time    \u2503 Time   \u2503         \u2503   Elev \u2503      Az \u2503 End Az \u2503\n# \u2503       # \u2503 (UTC)   \u2503 (UTC)  \u2503 Durati\u2026 \u2503  (deg) \u2503   (deg) \u2503  (deg) \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502       1 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   53.8 \u2502     204 \u2502     47 \u2502\n# \u2502         \u2502 16:58:\u2026 \u2502 17:05\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 24.76   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       2 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   59.5 \u2502     206 \u2502     45 \u2502\n# \u2502         \u2502 18:34:\u2026 \u2502 18:41\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/access.html#tips","title":"Tips","text":""},{"location":"learn/cli/access.html#norad-catalog-ids","title":"NORAD Catalog IDs","text":"<p>Find NORAD IDs using the datasets command: <pre><code># Search for satellite by name\nbrahe datasets celestrak lookup \"ISS\"\n\n# Show TLE with NORAD ID\nbrahe datasets celestrak show 25544\n</code></pre></p> <p>See Datasets CLI for more details.</p>"},{"location":"learn/cli/access.html#negative-longitudes","title":"Negative Longitudes","text":"<p>For westerly longitudes, use negative values with <code>=</code> or <code>--</code>: <pre><code># Method 1: Negative longitude\nbrahe access compute 25544 --lat 40.7128 --lon=-74.0060\n\n# Method 2: After -- separator\nbrahe access compute 25544 -- --lat 40.7128 --lon -74.0060\n</code></pre></p>"},{"location":"learn/cli/access.html#output-formats","title":"Output Formats","text":"<p>table (default): - ASCII table with columns - Good for terminal viewing - Aligned columns</p> <p>rich: - Enhanced table with colors - Better readability in modern terminals</p> <p>simple: - Plain text, one line per pass - Easy to parse with scripts</p> <p>JSON (via <code>--output-file</code>): - Machine-readable - Complete data structure - For further processing</p>"},{"location":"learn/cli/access.html#performance","title":"Performance","text":"<p>Computing access windows requires: 1. Downloading TLE data from CelesTrak (cached) 2. Downloading EOP data (cached) 3. Propagating orbit over time range</p> <p>Longer durations take more time: - 1 day: ~1-2 seconds - 7 days: ~5-10 seconds - 30 days: ~20-30 seconds</p>"},{"location":"learn/cli/access.html#see-also","title":"See Also","text":"<ul> <li>Ground Contacts Example - Detailed access computation examples</li> <li>Datasets CLI - Find NORAD IDs and download TLEs</li> <li>Groundstations Dataset - Ground station database</li> <li>Access API - Python access computation functions</li> </ul>"},{"location":"learn/cli/datasets.html","title":"Datasets Commands","text":"<p>Download and query satellite ephemeris data and ground station information.</p>"},{"location":"learn/cli/datasets.html#overview","title":"Overview","text":"<p>The <code>datasets</code> command group provides access to: - CelesTrak - Satellite TLE (Two-Line Element) data - Ground Stations - Commercial ground station network databases</p>"},{"location":"learn/cli/datasets.html#celestrak-commands","title":"CelesTrak Commands","text":""},{"location":"learn/cli/datasets.html#celestrak-download","title":"<code>celestrak download</code>","text":"<p>Download satellite ephemeris data from CelesTrak and save to file.</p> <p>Syntax: <pre><code>brahe datasets celestrak download &lt;GROUP&gt; &lt;FILEPATH&gt;\n</code></pre></p> <p>Arguments: - <code>GROUP</code> - Satellite group name (e.g., 'stations', 'starlink', 'gps-ops') - <code>FILEPATH</code> - Output file path for TLE data</p> <p>Examples:</p> <p>Download space station TLEs: <pre><code>brahe datasets celestrak download --group stations ~/satellite_data/stations.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/stations.txt\n</code></pre></p> <p>Download Starlink constellation: <pre><code>brahe datasets celestrak download --group starlink ~/satellite_data/starlink.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/starlink.txt\n</code></pre></p> <p>Download GPS satellites: <pre><code>brahe datasets celestrak download --group gps-ops ~/satellite_data/gps.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/gps.txt\n</code></pre></p> <p>See available groups: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-lookup","title":"<code>celestrak lookup</code>","text":"<p>Look up a satellite by name and display its NORAD ID and TLE.</p> <p>Syntax: <pre><code>brahe datasets celestrak lookup &lt;NAME&gt;\n</code></pre></p> <p>Arguments: - <code>NAME</code> - Satellite name (partial match supported)</p> <p>Examples:</p> <p>Find ISS: <pre><code>brahe datasets celestrak lookup \"ISS\"\n</code></pre> Output: <pre><code># ISS (ZARYA) [NORAD ID: 25544]\n\n# TLE Lines:\n#   1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# \u2713 Found satellite 'ISS (ZARYA)'\n</code></pre></p> <p>Find Hubble Space Telescope: <pre><code>brahe datasets celestrak lookup \"HST\"\n</code></pre> Output: <pre><code># HST [NORAD ID: 20580]\n\n# TLE Lines:\n#   1 20580U 90037B   25306.35384425  .00007204  00000+0  25387-3 0  9994\n#   2 20580  28.4668 187.2184 0001915 134.9270 225.1481 15.27276544753814\n\n# \u2713 Found satellite 'HST'\n</code></pre></p> <p>Find by partial name: <pre><code>brahe datasets celestrak lookup \"CAPELLA\"\n</code></pre> Output: <pre><code># CAPELLA-11 (ACADIA-1) [NORAD ID: 57693]\n\n# TLE Lines:\n#   1 57693U 23126A   25306.12190313 -.00002119  00000+0 -25509-3 0  9998\n#   2 57693  53.0104  84.6427 0002550 126.4571 233.6640 14.78979627118491\n\n# \u2713 Found satellite 'CAPELLA-11 (ACADIA-1)'\n</code></pre> (Shows first match)</p>"},{"location":"learn/cli/datasets.html#celestrak-show","title":"<code>celestrak show</code>","text":"<p>Display TLE information and computed orbital parameters for a satellite.</p> <p>Syntax: <pre><code>brahe datasets celestrak show &lt;NORAD_ID&gt;\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID (integer)</p> <p>Examples:</p> <p>Show ISS TLE and orbit info: <pre><code>brahe datasets celestrak show 25544 -s\n</code></pre> Output: <pre><code># ISS (ZARYA) [NORAD ID: 25544]\n\n# TLE Lines:\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# Orbital Elements:\n#   Epoch:              2025-11-02 10:09:34.283 UTC\n#   Ephemeris Age:      21h 16m 13s\n#   Semi-major axis:    6795.7 km\n#   Eccentricity:       0.0004969\n#   Inclination:        51.6344\u00b0\n#   RAAN:               342.0717\u00b0\n#   Arg of Perigee:     8.9436\u00b0\n#   Mean Anomaly:       351.1640\u00b0\n\n# Orbital Characteristics:\n#   Orbital Period:     92.9 min (1.55 hours)\n#   Mean Motion:        15.497 rev/day\n#   Perigee Altitude:   414.2 km\n#   Apogee Altitude:    421.0 km\n</code></pre></p> <p>Show GPS satellite: <pre><code># brahe datasets celestrak show 32260\n</code></pre> Output: <pre><code># \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502 NAVSTAR 60 (USA 196)                                                                 \u2502\n# \u2502 NORAD ID: 32260                                                                      \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 TLE Lines \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Line 1:  1 32260U 07047A   25305.87057871  .00000045  00000+0  00000+0 0  9996      \u2502\n# \u2502  Line 2:  2 32260  53.9265  89.4464 0164696  84.6485 277.2299  2.00566111132250      \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Orbital Elements \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Epoch            2025-11-01 20:53:38.001 UTC                                        \u2502\n# \u2502  Ephemeris Age                 1d 10h 32m 23s                                        \u2502\n# \u2502  Semi-major axis                   26560.1 km                                        \u2502\n# \u2502  Eccentricity                       0.0164696                                        \u2502\n# \u2502  Inclination                         53.9265\u00b0                                        \u2502\n# \u2502  RAAN                                89.4464\u00b0                                        \u2502\n# \u2502  Arg of Perigee                      84.6485\u00b0                                        \u2502\n# \u2502  Mean Anomaly                       277.2299\u00b0                                        \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Orbital Characteristics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Orbital Period    718.0 min (11.97 hours)                                           \u2502\n# \u2502  Mean Motion                 2.006 rev/day                                           \u2502\n# \u2502  Perigee Altitude               19744.6 km                                           \u2502\n# \u2502  Apogee Altitude                20619.4 km                                           \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-list-groups","title":"<code>celestrak list-groups</code>","text":"<p>List commonly used CelesTrak satellite groups.</p> <p>Syntax: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p> <p>Examples: <pre><code>brahe datasets celestrak list-groups\n</code></pre> Output: <pre><code>Common CelesTrak Satellite Groups\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Group Name           \u2503 Description                                         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 active               \u2502 All active satellites                               \u2502\n\u2502 stations             \u2502 Space stations (ISS, Tiangong, etc.)                \u2502\n\u2502 last-30-days         \u2502 Satellites launched in the last 30 days             \u2502\n\u2502 gnss                 \u2502 All GNSS satellites (GPS, Galileo, GLONASS, Beidou) \u2502\n\u2502 gps-ops              \u2502 Operational GPS satellites                          \u2502\n\u2502 galileo              \u2502 Galileo navigation satellites                       \u2502\n\u2502 beidou               \u2502 Beidou navigation satellites                        \u2502\n\u2502 glo-ops              \u2502 Operational GLONASS satellites                      \u2502\n\u2502 geo                  \u2502 Geostationary satellites                            \u2502\n\u2502 gpz                  \u2502 Geostationary protected zone satellites             \u2502\n\u2502 gpz-plus             \u2502 Geostationary protected zone plus satellites        \u2502\n\u2502 weather              \u2502 Weather satellites                                  \u2502\n\u2502 noaa                 \u2502 NOAA satellites                                     \u2502\n\u2502 goes                 \u2502 GOES weather satellites                             \u2502\n\u2502 starlink             \u2502 SpaceX Starlink constellation                       \u2502\n\u2502 oneweb               \u2502 OneWeb constellation                                \u2502\n\u2502 kuiper               \u2502 Amazon Kuiper constellation                         \u2502\n\u2502 qianfan              \u2502 Qianfan constellation                               \u2502\n\u2502 hulianwang           \u2502 Hulianwang constellation                            \u2502\n\u2502 planet               \u2502 Planet Labs imaging satellites                      \u2502\n\u2502 iridium              \u2502 Iridium constellation                               \u2502\n\u2502 iridium-NEXT         \u2502 Iridium NEXT constellation                          \u2502\n\u2502 intelsat             \u2502 Intelsat satellites                                 \u2502\n\u2502 eutelsat             \u2502 Eutelsat satellites                                 \u2502\n\u2502 ses                  \u2502 SES satellites                                      \u2502\n\u2502 orbcomm              \u2502 Orbcomm satellites                                  \u2502\n\u2502 globalstar           \u2502 Globalstar satellites                               \u2502\n\u2502 sarsat               \u2502 Search and rescue satellites                        \u2502\n\u2502 cubesat              \u2502 CubeSats                                            \u2502\n\u2502 amateur              \u2502 Amateur radio satellites                            \u2502\n\u2502 science              \u2502 Science satellites                                  \u2502\n\u2502 weather              \u2502 Weather satellites                                  \u2502\n\u2502 geodetic             \u2502 Geodetic satellites                                 \u2502\n\u2502 cosmos-2251-debris   \u2502 Debris from Cosmos 2251 collision                   \u2502\n\u2502 iridium-33-debris    \u2502 Debris from Iridium 33 collision                    \u2502\n\u2502 fengyun-1c-debris    \u2502 Debris from Fengyun-1C ASAT test                    \u2502\n\u2502 cosmos-1408-debris   \u2502 Debris from Cosmos 1408 ASAT test                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-search","title":"<code>celestrak search</code>","text":"<p>Search for satellites by name pattern within a group.</p> <p>Syntax: <pre><code>brahe datasets celestrak search &lt;PATTERN&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PATTERN</code> - Name search pattern (case-insensitive)</p> <p>Options: - <code>--group &lt;name&gt;</code> - Satellite group to search (default: \"active\") - <code>--table, -t</code> - Display results as table - <code>--columns &lt;preset&gt;</code> - Columns to display: 'minimal', 'default', 'all', or comma-separated list</p> <p>Examples:</p> <p>Search for Capella satellites: <pre><code>brahe datasets celestrak search \"Capella\"\n</code></pre> Output: <pre><code># CAPELLA-11 (ACADIA-1) (NORAD: 57693)\n# CAPELLA-14 (ACADIA-4) (NORAD: 59444)\n# CAPELLA-13 (ACADIA-3) (NORAD: 60419)\n# CAPELLA-15 (ACADIA-5) (NORAD: 60544)\n# CAPELLA-17 (ACADIA-7) (NORAD: 64583)\n# CAPELLA-16 (ACADIA-6) (NORAD: 65318)\n</code></pre></p> <p>Search for GPS satellites in specific group: <pre><code>brahe datasets celestrak search \"GPS II\" --group gps-ops\n</code></pre> Output: <pre><code># GPS BIIR-2  (PRN 13) (NORAD: 24876)\n# GPS BIIR-4  (PRN 20) (NORAD: 26360)\n# GPS BIIR-5  (PRN 22) (NORAD: 26407)\n# GPS BIIR-8  (PRN 16) (NORAD: 27663)\n# GPS BIIR-11 (PRN 19) (NORAD: 28190)\n# GPS BIIR-13 (PRN 02) (NORAD: 28474)\n# GPS BIIRM-1 (PRN 17) (NORAD: 28874)\n# GPS BIIRM-2 (PRN 31) (NORAD: 29486)\n# GPS BIIRM-3 (PRN 12) (NORAD: 29601)\n# GPS BIIRM-4 (PRN 15) (NORAD: 32260)\n# GPS BIIRM-5 (PRN 29) (NORAD: 32384)\n# GPS BIIRM-6 (PRN 07) (NORAD: 32711)\n# GPS BIIRM-8 (PRN 05) (NORAD: 35752)\n</code></pre></p> <p>Search with table output: <pre><code>brahe datasets celestrak search \"CAPELLA\" --group active --table\n</code></pre> Output: <pre><code># \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503 Name               \u2503 ID     \u2503 Epoch                \u2503 Age        \u2503 Period (min) \u2503 SMA (km)  \u2503 Ecc      \u2503 Inc (\u00b0) \u2503 RAAN (\u00b0)  \u2503 ArgP (\u00b0)  \u2503 MA (\u00b0)  \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502 CAPELLA-11         \u2502 57693  \u2502 2025-11-02           \u2502 1d 5h 13m  \u2502 97.4         \u2502 7010.7    \u2502 0.000255 \u2502 53.01   \u2502 84.64     \u2502 126.46    \u2502 233.66  \u2502\n# \u2502 (ACADIA-1)         \u2502        \u2502 02:55:32.430 UTC     \u2502 39s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-14         \u2502 59444  \u2502 2025-11-02           \u2502 20h 33m 2s \u2502 95.7         \u2502 6930.2    \u2502 0.000330 \u2502 45.61   \u2502 6.37      \u2502 226.89    \u2502 133.18  \u2502\n# \u2502 (ACADIA-4)         \u2502        \u2502 11:36:09.001 UTC     \u2502            \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-13         \u2502 60419  \u2502 2025-11-01           \u2502 1d 23h 48m \u2502 96.8         \u2502 6983.4    \u2502 0.000158 \u2502 53.00   \u2502 332.08    \u2502 93.30     \u2502 266.82  \u2502\n# \u2502 (ACADIA-3)         \u2502        \u2502 08:20:23.000 UTC     \u2502 48s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-15         \u2502 60544  \u2502 2025-11-01           \u2502 2d 4h 11m  \u2502 96.5         \u2502 6968.5    \u2502 0.000478 \u2502 97.70   \u2502 18.46     \u2502 121.04    \u2502 239.13  \u2502\n# \u2502 (ACADIA-5)         \u2502        \u2502 03:57:45.954 UTC     \u2502 25s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-17         \u2502 64583  \u2502 2025-11-02           \u2502 1d 31m 29s \u2502 96.4         \u2502 6963.2    \u2502 0.000327 \u2502 97.76   \u2502 58.71     \u2502 21.22     \u2502 338.91  \u2502\n# \u2502 (ACADIA-7)         \u2502        \u2502 07:37:41.806 UTC     \u2502            \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-16         \u2502 65318  \u2502 2025-11-02           \u2502 1d 3h 57m  \u2502 96.6         \u2502 6973.1    \u2502 0.000296 \u2502 97.76   \u2502 19.81     \u2502 275.26    \u2502 84.83   \u2502\n# \u2502 (ACADIA-6)         \u2502        \u2502 04:11:12.548 UTC     \u2502 58s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/datasets.html#ground-station-commands","title":"Ground Station Commands","text":""},{"location":"learn/cli/datasets.html#groundstations-list-providers","title":"<code>groundstations list-providers</code>","text":"<p>List available ground station providers.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-providers\n</code></pre></p> <p>Examples: <pre><code>brahe datasets groundstations list-providers\n</code></pre> Output: <pre><code># Available groundstation providers:\n#   - atlas\n#   - aws\n#   - ksat\n#   - leaf\n#   - ssc\n#   - viasat\n</code></pre></p>"},{"location":"learn/cli/datasets.html#groundstations-list-stations","title":"<code>groundstations list-stations</code>","text":"<p>List ground stations, optionally filtered by provider.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-stations [OPTIONS]\n</code></pre></p> <p>Options: - <code>--provider &lt;name&gt;</code> - Filter by provider name</p> <p>Examples:</p> <p>List all ground stations: <pre><code>brahe datasets groundstations list-stations\n</code></pre> Output: <pre><code># All Groundstations (96 total):\n#   Absheron: 40.470\u00b0 lat, 49.490\u00b0 lon, 0 m alt [S, X]\n#   Accra: 5.600\u00b0 lat, -0.300\u00b0 lon, 0 m alt [L, S, X, Ka]\n</code></pre></p> <p>List KSAT stations only: <pre><code>brahe datasets groundstations list-stations --provider ksat\n</code></pre> Output: <pre><code># KSAT Groundstations (36 total):\n#   Athens: 37.850\u00b0 lat, 22.620\u00b0 lon, 0 m alt [S, X, Optical]\n#   Awarua: -46.530\u00b0 lat, 168.380\u00b0 lon, 0 m alt [S, X, Ka]\n</code></pre></p>"},{"location":"learn/cli/datasets.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak - Official TLE data source</li> <li>Two-Line Elements - Understanding Two-Line Elements</li> <li>SGP Propagation - TLE-based orbit propagation</li> <li>Access CLI - Compute satellite passes (uses TLE data)</li> <li>Datasets API - Python dataset functions</li> </ul>"},{"location":"learn/cli/eop.html","title":"EOP Commands","text":"<p>The <code>eop</code> command group provides access to Earth Orientation Parameters (EOP) data from IERS (International Earth Rotation and Reference Systems Service). EOP data is required for accurate transformations between ECI and ECEF reference frames.</p>"},{"location":"learn/cli/eop.html#commands","title":"Commands","text":""},{"location":"learn/cli/eop.html#download","title":"<code>download</code>","text":"<p>Download EOP data from IERS and save to file.</p> <p>Syntax: <pre><code>brahe eop download &lt;FILEPATH&gt; --product &lt;PRODUCT&gt;\n</code></pre></p> <p>Arguments: - <code>FILEPATH</code> - Output file path for EOP data</p> <p>Options: - <code>--product [standard|c04]</code> - Data product type (required)   - <code>standard</code> - Standard rapid EOP data (daily updates, ~1 year of predictions)   - <code>c04</code> - EOP 14 C04 long-term series (high accuracy, historical)</p> <p>Examples:</p> <p>Download standard EOP data: <pre><code>brahe eop download ~/.cache/brahe/eop/iau2000_standard.txt --product standard\n</code></pre></p> <p>Download C04 long-term series: <pre><code>brahe eop download ~/.cache/brahe/eop/iau2000_c04_20.txt --product c04\n</code></pre></p> <p>Update local EOP file: <pre><code>brahe eop download /path/to/eop_data.txt --product standard\n</code></pre></p> <p>Tip</p> <p>It's usually not necessary to manually download EOP data. If you are using a caching file provider, the package data will automatically download and cache EOP data as needed.</p>"},{"location":"learn/cli/eop.html#get-utc-ut1","title":"<code>get-utc-ut1</code>","text":"<p>Get the UTC-UT1 offset (\u0394UT1) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-utc-ut1 &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get \u0394UT1 for a specific date: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\"\n# 0.0087837\n</code></pre></p> <p>Use custom EOP file: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --source file --filepath /path/to/eop.txt\n</code></pre></p> <p>Use C04 product: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --product c04\n# 0.0087572\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-polar-motion","title":"<code>get-polar-motion</code>","text":"<p>Get polar motion parameters (x_p, y_p) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-polar-motion &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get polar motion parameters: <pre><code>brahe eop get-polar-motion \"2024-01-01T00:00:00Z\"\n# 6.63768107080688e-07, 9.802447818353709e-07\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-cip-offset","title":"<code>get-cip-offset</code>","text":"<p>Get Celestial Intermediate Pole (CIP) offset (dX, dY) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-cip-offset &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get CIP offset: <pre><code>brahe eop get-cip-offset \"2024-01-01T00:00:00Z\"\n# 1.4302003592731312e-09, -4.6057299705405924e-10\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-lod","title":"<code>get-lod</code>","text":"<p>Get Length of Day (LOD) variation at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-lod &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get LOD variation: <pre><code>brahe eop get-lod \"2024-01-01T00:00:00Z\"\n# 0.00023750000000000003\n</code></pre></p>"},{"location":"learn/cli/eop.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - Conceptual overview</li> <li>Reference Frames - ECI/ECEF transformations</li> <li>Transform CLI - Frame transformations (use EOP)</li> <li>Time CLI - UT1 time system</li> <li>EOP API - Python EOP provider classes</li> </ul>"},{"location":"learn/cli/orbits.html","title":"Orbits Commands","text":"<p>The <code>orbits</code> command group provides calculations for: - Orbital period and semi-major axis - Mean motion - Anomaly conversions (mean, eccentric, true) - Sun-synchronous orbit design - Perigee and apogee velocities</p> <p>All commands support constant expressions (e.g., <code>R_EARTH+500e3</code>).</p>"},{"location":"learn/cli/orbits.html#commands","title":"Commands","text":""},{"location":"learn/cli/orbits.html#orbital-period","title":"<code>orbital-period</code>","text":"<p>Calculate the orbital period from semi-major axis.</p> <p>Syntax: <pre><code>brahe orbits orbital-period &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--units [seconds|minutes|hours|days|years]</code> - Output time units (default: <code>seconds</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>LEO orbit period (500km altitude): <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code># 5676.977164\n</code></pre> (Period: ~94.6 minutes)</p> <p>With different units: <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n</code></pre> Output: <pre><code># 94.616286\n</code></pre></p> <p>GEO orbit period (should be ~24 hours): <pre><code>brahe orbits orbital-period \"R_EARTH+35786e3\" --units hours\n</code></pre> Output: <pre><code># 23.934441\n</code></pre></p> <p>Moon's orbit (using GM_EARTH): <pre><code>brahe orbits orbital-period 384400e3 --units days\n</code></pre> Output: <pre><code># 27.451894\n</code></pre></p> <p>Mars orbit (using GM_SUN): <pre><code>brahe orbits orbital-period 227.9e9 --gm GM_SUN --units days\n</code></pre> Output: <pre><code># 686.794481\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sma-from-period","title":"<code>sma-from-period</code>","text":"<p>Calculate semi-major axis from orbital period.</p> <p>Syntax: <pre><code>brahe orbits sma-from-period &lt;PERIOD&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PERIOD</code> - Orbital period (supports expressions)</p> <p>Options: - <code>--units [seconds|minutes|hours|days|years]</code> - Input time units (default: <code>seconds</code>) - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Find altitude for 90-minute orbit: <pre><code>brahe orbits sma-from-period 90 --units minutes\n</code></pre> Output: <pre><code># 6652555.699659\n</code></pre> (Semi-major axis: ~6653 km \u2192 altitude ~275 km)</p> <p>Find GEO altitude (24-hour period): <pre><code>brahe orbits sma-from-period 24 --units hours\n</code></pre> Output: <pre><code># 42241095.663660\n</code></pre> (Semi-major axis: ~42164 km \u2192 altitude ~35786 km above Earth surface)</p> <p>Calculate altitude: <pre><code># SMA - R_EARTH = altitude\necho \"scale=2; ($(brahe orbits sma-from-period 90 --units minutes) - 6378137) / 1000\" | bc\n</code></pre> Output: <pre><code># 274.41\n</code></pre></p>"},{"location":"learn/cli/orbits.html#mean-motion","title":"<code>mean-motion</code>","text":"<p>Calculate mean motion (radians per second).</p> <p>Syntax: <pre><code>brahe orbits mean-motion &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean motion for LEO (500km): <pre><code>brahe orbits mean-motion \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code># 0.001107\n</code></pre></p>"},{"location":"learn/cli/orbits.html#anomaly-conversion","title":"<code>anomaly-conversion</code>","text":"<p>Convert between mean, eccentric, and true anomaly.</p> <p>Syntax: <pre><code>brahe orbits anomaly-conversion &lt;ANOMALY&gt; &lt;ECCENTRICITY&gt; &lt;INPUT_ANOMALY&gt; &lt;OUTPUT_ANOMALY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>ANOMALY</code> - Anomaly value to convert (supports expressions) - <code>ECCENTRICITY</code> - Orbital eccentricity (supports expressions) - <code>INPUT_ANOMALY</code> - Input type: <code>mean</code>, <code>eccentric</code>, or <code>true</code> - <code>OUTPUT_ANOMALY</code> - Output type: <code>mean</code>, <code>eccentric</code>, or <code>true</code></p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Use degrees (default: <code>--no-as-degrees</code> = radians) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean anomaly to true anomaly (circular orbit): <pre><code>brahe orbits anomaly-conversion 0.785 0.0 mean true\n</code></pre> Output: <pre><code># 0.785000\n</code></pre> (For circular orbit, mean = eccentric = true)</p> <p>Mean to true (eccentric orbit): <pre><code>brahe orbits anomaly-conversion --as-degrees 45.0 0.1 mean true\n</code></pre> Output: <pre><code># 53.849399\n</code></pre></p> <p>True to mean anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 90.0 0.05 true mean\n</code></pre> Output: <pre><code># 84.272810\n</code></pre></p> <p>Eccentric to true anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 60.0 0.2 eccentric true\n</code></pre> Output: <pre><code># 70.528779\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sun-sync-inclination","title":"<code>sun-sync-inclination</code>","text":"<p>Calculate the inclination required for a sun-synchronous orbit.</p> <p>Syntax: <pre><code>brahe orbits sun-sync-inclination &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Output in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Sun-sync inclination for 500km circular orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 97.401744\n</code></pre> (Inclination: ~97.42\u00b0)</p> <p>Sun-sync for 600km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+600e3\" 0.001\n</code></pre> Output: <pre><code># 97.787587\n</code></pre></p> <p>Sun-sync for 800km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+800e3\" 0.0\n</code></pre> Output: <pre><code># 98.603036\n</code></pre></p> <p>Output in radians: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0 --no-as-degrees\n</code></pre> Output: <pre><code># 1.699981\n</code></pre></p>"},{"location":"learn/cli/orbits.html#perigee-velocity","title":"<code>perigee-velocity</code>","text":"<p>Calculate orbital velocity at perigee (closest approach).</p> <p>Syntax: <pre><code>brahe orbits perigee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit velocity (500km): <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 7612.608558\n</code></pre></p> <p>Eccentric orbit perigee velocity: <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code># 8416.055421\n</code></pre></p> <p>GTO perigee velocity (highly eccentric): <pre><code>brahe orbits perigee-velocity \"R_EARTH+24000e3\" 0.73\n</code></pre> Output: <pre><code># 9169.158794\n</code></pre></p>"},{"location":"learn/cli/orbits.html#apogee-velocity","title":"<code>apogee-velocity</code>","text":"<p>Calculate orbital velocity at apogee (farthest point).</p> <p>Syntax: <pre><code>brahe orbits apogee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit (apogee = perigee): <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 7612.608558\n</code></pre></p> <p>Eccentric orbit apogee velocity: <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code># 6885.863526\n</code></pre> (Lower velocity at apogee)</p> <p>Compare perigee vs apogee: <pre><code>echo \"Perigee: $(brahe orbits perigee-velocity 'R_EARTH+500e3' 0.1) m/s\"\necho \"Apogee:  $(brahe orbits apogee-velocity 'R_EARTH+500e3' 0.1) m/s\"\n</code></pre> Output: <pre><code># Perigee: 8416.055421 m/s\n# Apogee:  6885.863526 m/s\n</code></pre></p>"},{"location":"learn/cli/orbits.html#see-also","title":"See Also","text":"<ul> <li>Anomaly Conversions - True, eccentric, and mean anomaly conversions</li> <li>Orbital Properties - Orbital period, sun-synchronous inclination, etc.</li> <li>Orbits API - Python orbital mechanics functions</li> <li>Transform CLI - Coordinate conversions</li> <li>Constants - Physical constants for calculations</li> </ul>"},{"location":"learn/cli/time.html","title":"Time Commands","text":"<p>The <code>time</code> command group provides: - Conversion between time formats (MJD, JD, ISO-8601, GPS) - Conversion between time systems (UTC, TAI, GPS, UT1, TT) - Time arithmetic (adding/subtracting durations) - Time range generation</p>"},{"location":"learn/cli/time.html#commands","title":"Commands","text":""},{"location":"learn/cli/time.html#convert","title":"<code>convert</code>","text":"<p>Convert between time formats and time systems.</p> <p>Syntax: <pre><code>brahe time convert &lt;EPOCH&gt; &lt;INPUT_FORMAT&gt; &lt;OUTPUT_FORMAT&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Time value to convert - <code>INPUT_FORMAT</code> - Format of input: <code>mjd</code>, <code>jd</code>, <code>string</code>, <code>gps_date</code>, <code>gps_nanoseconds</code> - <code>OUTPUT_FORMAT</code> - Desired output format (same options as input)</p> <p>Options: - <code>--input-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of input - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of output</p> <p>Examples:</p> <p>Convert ISO-8601 string to Modified Julian Date: <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string mjd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code># 60310.0\n</code></pre></p> <p>Convert MJD to Julian Date: <pre><code>brahe time convert 60310.0 mjd jd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code># 2460310.5\n</code></pre></p> <p>Convert between time systems (UTC to TAI): <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string string --input-time-system UTC --output-time-system TAI\n</code></pre> Output: <pre><code># 2024-01-01 00:00:37.000 TAI\n</code></pre></p> <p>Convert GPS time to UTC: <pre><code>brahe time convert \"1356998418000000000\" gps_nanoseconds string --output-time-system UTC\n</code></pre> Output: <pre><code># 2023-01-06 00:00:00.000 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#add","title":"<code>add</code>","text":"<p>Add a time offset to an epoch.</p> <p>Syntax: <pre><code>brahe time add &lt;EPOCH&gt; &lt;SECONDS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Starting epoch (ISO-8601 string, MJD, or JD) - <code>SECONDS</code> - Number of seconds to add (can be negative)</p> <p>Options: - <code>--output-format [mjd|jd|string|gps_date|gps_nanoseconds]</code> - Output format (default: <code>string</code>) - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Output time system (default: <code>UTC</code>)</p> <p>Examples:</p> <p>Add 1 hour (3600 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 3600\n</code></pre> Output: <pre><code># 2024-01-01 01:00:00.000 UTC\n</code></pre></p> <p>Add 1 day (86400 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400\n</code></pre> Output: <pre><code># 2024-01-02 00:00:00.000 UTC\n</code></pre></p> <p>Subtract 30 minutes (negative seconds): <pre><code>brahe time add \"2024-01-01T12:00:00Z\" -- -1800\n</code></pre> Output: <pre><code># 2024-01-01 11:30:00.000 UTC\n</code></pre></p> <p>Output as MJD: <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400 --output-format mjd\n</code></pre> Output: <pre><code># 60311.0\n</code></pre></p>"},{"location":"learn/cli/time.html#time-system-offset","title":"<code>time-system-offset</code>","text":"<p>Calculate the offset between two time systems at a given epoch.</p> <p>Syntax: <pre><code>brahe time time-system-offset &lt;EPOCH&gt; &lt;SOURCE&gt; &lt;TARGET&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to calculate offset at (ISO-8601 string) - <code>SOURCE</code> - Source time system: <code>UTC</code>, <code>GPS</code>, <code>TAI</code>, <code>UT1</code>, <code>TT</code> - <code>TARGET</code> - Target time system (same options)</p> <p>Examples:</p> <p>UTC to TAI offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" UTC TAI\n</code></pre> Output: <pre><code># 37.0\n</code></pre> (TAI is 37 seconds ahead of UTC in 2024)</p> <p>GPS to UTC offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" GPS UTC\n</code></pre> Output: <pre><code># -18.0\n</code></pre></p> <p>TAI to TT offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" TAI TT\n</code></pre> Output: <pre><code># 32.184\n</code></pre></p>"},{"location":"learn/cli/time.html#range","title":"<code>range</code>","text":"<p>Generate a sequence of epochs over a time range.</p> <p>Syntax: <pre><code>brahe time range &lt;EPOCH_START&gt; &lt;EPOCH_END&gt; &lt;STEP&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH_START</code> - Start of time range (ISO-8601 string) - <code>EPOCH_END</code> - End of time range (ISO-8601 string) - <code>STEP</code> - Step size in seconds</p> <p>Examples:</p> <p>Generate epochs every 30 minutes for 1 hour: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-01T01:00:00Z\" 1800\n</code></pre> Output: <pre><code># 2024-01-01 00:00:00.000 UTC\n# 2024-01-01 00:30:00.000 UTC\n</code></pre></p> <p>Generate epochs every 6 hours for 1 day: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-02T00:00:00Z\" 21600\n</code></pre> Output: <pre><code># 2024-01-01 00:00:00.000 UTC\n# 2024-01-01 06:00:00.000 UTC\n# 2024-01-01 12:00:00.000 UTC\n# 2024-01-01 18:00:00.000 UTC\n</code></pre></p> <p>Generate epochs every minute for 5 minutes: <pre><code>brahe time range \"2024-01-01T12:00:00Z\" \"2024-01-01T12:05:00Z\" 60\n</code></pre> Output: <pre><code># 2024-01-01 12:00:00.000 UTC\n# 2024-01-01 12:01:00.000 UTC\n# 2024-01-01 12:02:00.000 UTC\n# 2024-01-01 12:03:00.000 UTC\n# 2024-01-01 12:04:00.000 UTC\n# 2024-01-01 12:05:00.000 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#time-systems","title":"Time Systems","text":""},{"location":"learn/cli/time.html#utc-coordinated-universal-time","title":"UTC (Coordinated Universal Time)","text":"<ul> <li>Civil time standard</li> <li>Includes leap seconds</li> <li>Most common for human-readable timestamps</li> </ul>"},{"location":"learn/cli/time.html#tai-international-atomic-time","title":"TAI (International Atomic Time)","text":"<ul> <li>Continuous atomic time scale</li> <li>No leap seconds</li> <li>Ahead of UTC by IERS-defined leap seconds (37s as of 2024)</li> </ul>"},{"location":"learn/cli/time.html#gps-global-positioning-system-time","title":"GPS (Global Positioning System Time)","text":"<ul> <li>Used by GPS satellites</li> <li>Started at 1980-01-06 00:00:00 UTC</li> <li>19 seconds behind TAI (fixed offset)</li> </ul>"},{"location":"learn/cli/time.html#ut1-universal-time-1","title":"UT1 (Universal Time 1)","text":"<ul> <li>Based on Earth's rotation</li> <li>Irregular due to Earth rotation variations</li> <li>Requires Earth Orientation Parameters (EOP)</li> </ul>"},{"location":"learn/cli/time.html#tt-terrestrial-time","title":"TT (Terrestrial Time)","text":"<ul> <li>Ideal time for Earth-based observations</li> <li>Always 32.184 seconds ahead of TAI</li> </ul>"},{"location":"learn/cli/time.html#offset-relationships","title":"Offset Relationships","text":"<pre><code>TT  = TAI + 32.184s\nTAI = GPS + 19s\nTAI = UTC + (leap seconds, currently 37s)\nUT1 = UTC + (DUT1, from EOP data)\n</code></pre>"},{"location":"learn/cli/time.html#time-formats","title":"Time Formats","text":""},{"location":"learn/cli/time.html#iso-8601-string-string","title":"ISO-8601 String (<code>string</code>)","text":"<p>Human-readable format with timezone: <pre><code>2024-01-01T00:00:00Z\n2024-12-31T23:59:59.123Z\n</code></pre></p>"},{"location":"learn/cli/time.html#modified-julian-date-mjd","title":"Modified Julian Date (<code>mjd</code>)","text":"<p>Days since 1858-11-17 00:00:00 UTC: <pre><code>60310.0         # 2024-01-01 00:00:00 UTC\n60310.5         # 2024-01-01 12:00:00 UTC\n60310.25        # 2024-01-01 06:00:00 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#julian-date-jd","title":"Julian Date (<code>jd</code>)","text":"<p>Days since -4712-01-01 12:00:00 UTC: <pre><code>2460310.5       # 2024-01-01 00:00:00 UTC\n2460311.0       # 2024-01-01 12:00:00 UTC\n</code></pre></p> <p>Relationship: <code>JD = MJD + 2400000.5</code></p>"},{"location":"learn/cli/time.html#gps-date-gps_date","title":"GPS Date (<code>gps_date</code>)","text":"<p>GPS week number and seconds: <pre><code>2295:0.0        # GPS Week 2295, 0 seconds\n</code></pre></p>"},{"location":"learn/cli/time.html#gps-nanoseconds-gps_nanoseconds","title":"GPS Nanoseconds (<code>gps_nanoseconds</code>)","text":"<p>Nanoseconds since GPS epoch (1980-01-06 00:00:00 UTC): <pre><code>1356998418000000000\n</code></pre></p>"},{"location":"learn/cli/time.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - EOP and UT1</li> <li>Epoch API - Python Epoch class</li> <li>EOP CLI - Earth Orientation Parameters</li> <li>Transform CLI - Coordinate transformations (require epochs)</li> </ul>"},{"location":"learn/cli/transform.html","title":"Transform Commands","text":"<p>Convert between coordinate systems and reference frames.</p>"},{"location":"learn/cli/transform.html#overview","title":"Overview","text":"<p>The <code>transform</code> command group provides conversions between: - Reference frames: ECI (Earth-Centered Inertial) \u2194 ECEF (Earth-Centered Earth-Fixed) - Coordinate systems: Keplerian, Cartesian, Geodetic, Geocentric - Attitude representations: Quaternions, Euler angles, rotation matrices (planned)</p>"},{"location":"learn/cli/transform.html#commands","title":"Commands","text":""},{"location":"learn/cli/transform.html#frame","title":"<code>frame</code>","text":"<p>Transform state vectors between ECI and ECEF reference frames.</p> <p>Syntax: <pre><code>brahe transform frame &lt;FROM_FRAME&gt; &lt;TO_FRAME&gt; &lt;EPOCH&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;vx&gt; &lt;vy&gt; &lt;vz&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>FROM_FRAME</code> - Source reference frame: <code>ECI</code> or <code>ECEF</code> - <code>TO_FRAME</code> - Target reference frame: <code>ECI</code> or <code>ECEF</code> - <code>EPOCH</code> - Epoch for the transformation (ISO-8601 format with timezone) - <code>x y z vx vy vz</code> - State vector [m, m, m, m/s, m/s, m/s]</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Convert ECI state to ECEF at a specific epoch: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code># [-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Convert ECEF back to ECI: <pre><code>brahe transform frame ECEF ECI \"2024-01-01T00:00:00Z\" -- -1176064.179 -6776827.197 15961.825 6895.377 -1196.637 0.241\n</code></pre> Output: <pre><code># [6878137.000016, 0.000312, -0.000213, 0.000018, 7500.000440, 0.000398]\n</code></pre></p> <p>Low-precision output: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T12:00:00Z\" 6878137 0 0 0 7500 0 --format .2f\n</code></pre> Output: <pre><code># [1234308.01, 6766461.20, 15974.24, -6884.83, 1255.90, 0.25]\n</code></pre></p>"},{"location":"learn/cli/transform.html#coordinates","title":"<code>coordinates</code>","text":"<p>Convert between coordinate system representations.</p> <p>Syntax: <pre><code>brahe transform coordinates [OPTIONS] &lt;FROM_SYSTEM&gt; &lt;TO_SYSTEM&gt; &lt;EPOCH&gt; &lt;x1&gt; &lt;x2&gt; &lt;x3&gt; &lt;x4&gt; &lt;x5&gt; &lt;x6&gt;\n</code></pre></p> <p>Arguments: - <code>FROM_SYSTEM</code> - Source coordinate system (see below) - <code>TO_SYSTEM</code> - Target coordinate system (see below) - <code>EPOCH</code> - Epoch (ISO-8601 format). Use <code>\"\"</code> if not needed for the conversion - <code>x1 x2 x3 x4 x5 x6</code> - Coordinate values (interpretation depends on system)</p> <p>Coordinate Systems: - <code>keplerian</code> - Keplerian orbital elements [a, e, i, \u03a9, \u03c9, \u03bd] - <code>cartesian</code> - Cartesian state [x, y, z, vx, vy, vz] - <code>geodetic</code> - Geodetic coordinates [lon, lat, alt, 0, 0, 0] - <code>geocentric</code> - Geocentric spherical [lat, lon, radius, 0, 0, 0]</p> <p>Options: - <code>--from-frame [ECI|ECEF]</code> - Reference frame for cartesian input (default: <code>ECI</code>) - <code>--to-frame [ECI|ECEF]</code> - Reference frame for cartesian output (default: <code>ECI</code>) - <code>--as-degrees / --no-as-degrees</code> - Interpret/output angles in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p>"},{"location":"learn/cli/transform.html#keplerian-to-cartesian-eci","title":"Keplerian to Cartesian (ECI)","text":"<p>Convert orbital elements to ECI state (no epoch required): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre> Output: <pre><code># [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055]\n</code></pre></p> <p>With different true anomaly (45\u00b0): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 45 --as-degrees\n</code></pre> Output: <pre><code># [4853256.459155, -660529.749078, 4821984.763637, -5390.543500, -730.545720, 5333.113819]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-to-keplerian","title":"Cartesian to Keplerian","text":"<p>Convert ECI state back to orbital elements: <pre><code>brahe transform coordinates --as-degrees cartesian keplerian \"\" -- 6871258.863 0.0 0.0 0.0 -1034.183 7549.721\n</code></pre> Output: <pre><code># [6878136.866355, 0.001000, 97.799999, 0.000000, 0.000000, 0.000000]\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-to-cartesian-ecef","title":"Geodetic to Cartesian (ECEF)","text":"<p>Convert geodetic coordinates (New York City) to ECEF: <pre><code>brahe transform coordinates --as-degrees --to-frame ECEF geodetic cartesian \"\" 286.0060 40.7128 10 0 0 0\n</code></pre> Output: <pre><code># [1334224.912305, -4651969.287142, 4140677.827068]\n</code></pre></p> <p>Note: Order is [lon, lat, alt]. Longitude 286\u00b0 = -74\u00b0 (use positive east longitude, or handle negative with <code>--</code>)</p>"},{"location":"learn/cli/transform.html#ecef-cartesian-to-geodetic","title":"ECEF Cartesian to Geodetic","text":"<p><pre><code>brahe transform coordinates --as-degrees --from-frame ECEF cartesian geodetic \"2024-01-01T00:00:00Z\" 1334915.0 4652372.0 4075345.0 0 0 0\n</code></pre> Output: <pre><code># [73.990114, 40.288227, -41917.492259]\n</code></pre></p>"},{"location":"learn/cli/transform.html#keplerian-to-geodetic-via-ecef","title":"Keplerian to Geodetic (via ECEF)","text":"<p>Convert satellite orbital elements to ground track position at epoch: <pre><code># First to cartesian ECI, then specify ECEF and geodetic\nbrahe transform coordinates --as-degrees --to-frame ECEF keplerian geodetic \"2024-01-01T00:00:00Z\" 6878137 0.001 97.8 0 0 0\n</code></pre> Output: <pre><code># [-99.845171, 0.133796, 493121.978692]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eci-to-ecef-frame-change","title":"Cartesian ECI to ECEF (frame change)","text":"<p><pre><code>brahe transform coordinates --from-frame ECI --to-frame ECEF cartesian cartesian \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code># [-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Alternative: Use <code>brahe transform frame</code> for dedicated ECI\u2194ECEF transformations.</p>"},{"location":"learn/cli/transform.html#coordinate-system-details","title":"Coordinate System Details","text":""},{"location":"learn/cli/transform.html#keplerian-elements","title":"Keplerian Elements","text":"<p>Format: <code>[a, e, i, \u03a9, \u03c9, M]</code></p> <ul> <li><code>a</code> - Semi-major axis (meters)</li> <li><code>e</code> - Eccentricity (dimensionless, 0 \u2264 e &lt; 1)</li> <li><code>i</code> - Inclination (degrees or radians)</li> <li><code>\u03a9</code> - Right Ascension of Ascending Node / RAAN (degrees or radians)</li> <li><code>\u03c9</code> - Argument of periapsis (degrees or radians)</li> <li><code>M</code> - Mean anomaly (degrees or radians)</li> </ul> <p>Standard orbits: - LEO (500km): <code>a = R_EARTH + 500e3 = 6878137 m</code> - GEO (35786km): <code>a = R_EARTH + 35786e3 = 42164137 m</code> - SSO inclination: ~97.8\u00b0 (for 500km altitude)</p> <p>Example: <pre><code># Sun-synchronous orbit, 500km altitude, 97.8\u00b0 inclination\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre> Output: <pre><code># [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eciecef","title":"Cartesian (ECI/ECEF)","text":"<p>Format: <code>[x, y, z, vx, vy, vz]</code></p> <ul> <li><code>x, y, z</code> - Position (meters)</li> <li><code>vx, vy, vz</code> - Velocity (meters/second)</li> </ul> <p>ECI (Earth-Centered Inertial): - Inertial reference frame - Z-axis aligned with Earth's rotation axis - X-axis points to vernal equinox</p> <p>ECEF (Earth-Centered Earth-Fixed): - Rotating with Earth - Z-axis aligned with Earth's rotation axis - X-axis through 0\u00b0 latitude, 0\u00b0 longitude</p> <p>Example: <pre><code># Circular equatorial orbit in ECI\nbrahe transform coordinates cartesian keplerian \"\" 6878137 0 0 0 7668 0 --as-degrees\n</code></pre> Output: <pre><code># [6980085.332943, 0.014606, 0.000000, 180.000000, 0.000000, 0.000000]\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Format: <code>[lon, lat, alt, 0, 0, 0]</code></p> <ul> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>lat</code> - Geodetic latitude (degrees or radians)</li> <li><code>alt</code> - Altitude above WGS84 ellipsoid (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul> <p>Geodetic vs Geocentric: - Geodetic: Perpendicular to WGS84 ellipsoid - Geocentric: Angle from Earth's center</p>"},{"location":"learn/cli/transform.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Format: <code>[lat, lon, radius, 0, 0, 0]</code></p> <ul> <li><code>lat</code> - Geocentric latitude (degrees or radians)</li> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>radius</code> - Distance from Earth center (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul>"},{"location":"learn/cli/transform.html#see-also","title":"See Also","text":"<ul> <li>Coordinate Systems - Conceptual overview</li> <li>Reference Frames - ECI/ECEF details</li> <li>Coordinates API - Python API</li> <li>Frames API - Frame conversion functions</li> <li>Orbits API - Orbital elements</li> <li>Time CLI - Time conversions</li> <li>Orbits CLI - Orbital mechanics calculations</li> </ul>"},{"location":"learn/coordinates/index.html","title":"Coordinate Transformations","text":"<p>Coordinate systems and transformations are fundamental to astrodynamics. Different coordinate systems are used depending on the application - some are better for orbital mechanics, others for ground station tracking, and still others for describing positions on Earth's surface.</p> <p>Brahe provides coordinate transformation functions for converting between different coordinate representations and reference frames.</p>"},{"location":"learn/coordinates/index.html#coordinate-systems-in-brahe","title":"Coordinate Systems in Brahe","text":""},{"location":"learn/coordinates/index.html#cartesian-state-vectors","title":"Cartesian State Vectors","text":"<p>Cartesian coordinates represent positions and velocities as vectors in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code>. In astrodynamics, these are typically used to represent the state in Earth-Centered Inertial (ECI) frames or Earth-Centered Earth-Fixed (ECEF) frames. </p> <p>While Cartesian coordinates are mathematically convenient for numerical integration and propagation, orbital elements are often more intuitive for understanding orbits. Therefore, Brahe provides functions to convert between ECI Cartesian states and Keplerian orbital elements.</p> <p>Learn more: Cartesian Transformations</p>"},{"location":"learn/coordinates/index.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Geocentric coordinates use a spherical Earth model to represent positions using longitude, latitude, and altitude from Earth's center: <code>[lon, lat, alt]</code>. Applications generally convert between ECEF Cartesian coordinates and geocentric spherical coordinates.</p> <p>Learn more: Geocentric Transformations</p>"},{"location":"learn/coordinates/index.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Geodetic coordinates use the WGS84 ellipsoid model to represent positions: <code>[lon, lat, alt]</code>. Unlike geocentric coordinates, geodetic coordinates account for Earth's equatorial bulge (flattening), providing much more accurate resulting ECEF Cartesian positions for points on or near Earth's surface. Similar to geocentric coordinates, applications typically convert between ECEF Cartesian coordinates and geodetic coordinates.</p> <p>Learn more: Geodetic Transformations</p>"},{"location":"learn/coordinates/index.html#topocentric-coordinates","title":"Topocentric Coordinates","text":"<p>Topocentric coordinate systems are local horizon-based systems centered on an observer (like a ground station on the Earth). They represent the position of objects relative to the local horizon, tagent to the body's surface.</p> <p>Two of the most common topocentric coodinate systems are the East-North-Zenith (ENZ) or South-East-Zenith (SEZ) systems. These systems are essential for computing satellite visibility, tracking angles (azimuth and elevation), and determining when satellites are observable from a specific location.</p> <p>Learn more: Topocentric Transformations</p>"},{"location":"learn/coordinates/index.html#common-transformation-patterns","title":"Common Transformation Patterns","text":""},{"location":"learn/coordinates/index.html#orbital-mechanics","title":"Orbital Mechanics","text":"<p>To work with orbital elements:</p> <ol> <li>Define or receive Keplerian elements <code>[a, e, i, \u03a9, \u03c9, M]</code></li> <li>Convert to Cartesian state <code>[x, y, z, vx, vy, vz]</code> in ECI frame</li> </ol>"},{"location":"learn/coordinates/index.html#ground-station-observations","title":"Ground Station Observations","text":"<p>To compute satellite location from a ground station:</p> <ol> <li>Start with station location in geodetic coordinates <code>[lon, lat, alt]</code></li> <li>Convert the Satellite ECI positions from to the ECEF frame at the observation time</li> <li>Convert the station location to ECEF coordinates</li> <li>Transform the satellite and location ECEF coordinates to the local ENZ</li> <li>Convert ENZ to azimuth-elevation-range</li> </ol>"},{"location":"learn/coordinates/index.html#see-also","title":"See Also","text":"<ul> <li>Cartesian Transformations - Orbital elements and Cartesian states</li> <li>Geocentric Transformations - Spherical Earth coordinates</li> <li>Geodetic Transformations - WGS84 ellipsoid coordinates</li> <li>Topocentric Transformations - Local horizon systems</li> <li>Coordinates API Reference - Complete API documentation</li> </ul>"},{"location":"learn/coordinates/cartesian_transformations.html","title":"Cartesian \u2194 Orbital Element Transformations","text":"<p>The functions described here convert between Keplerian orbital elements and Cartesian state vectors. While these transformations are part of the \"coordinates\" module, they specifically deal with orbital mechanics - converting between two different coordinate representations of a satellite's orbit.</p> <p>Understanding both representations is essential: Keplerian elements provide intuitive orbital parameters like size, shape, and orientation, while Cartesian states are necessary for numerical orbit propagation and applying perturbations.</p> <p>For complete API details, see the Cartesian Coordinates API Reference.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#orbital-representations","title":"Orbital Representations","text":""},{"location":"learn/coordinates/cartesian_transformations.html#keplerian-orbital-elements","title":"Keplerian Orbital Elements","text":"<p>Keplerian elements describe an orbit using six classical parameters:</p> <ul> <li>\\(a\\): Semi-major axis (meters) - defines the orbit's size</li> <li>\\(e\\): Eccentricity (dimensionless) - defines the orbit's shape (0 = circular, 0 &lt; e &lt; 1 = elliptical)</li> <li>\\(i\\): Inclination (radians or degrees) - tilt of orbital plane relative to equator</li> <li>\\(\\Omega\\): Right ascension of ascending node (radians or degrees) - where orbit crosses equator going north</li> <li>\\(\\omega\\): Argument of periapsis (radians or degrees) - where orbit is closest to Earth</li> <li>\\(M\\): Mean anomaly (radians or degrees) - position of satellite along orbit</li> </ul> <p>In brahe, the combined vector has ordering <code>[a, e, i, \u03a9, \u03c9, M]</code></p> <p>Info</p> <p>Brahe uses mean anomaly as the default anomaly representation for Keplerian elements. Other anomaly types (eccentric, true) can be converted using the anomaly conversion functions in the Orbits module.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#cartesian-state-vectors","title":"Cartesian State Vectors","text":"<p>Cartesian states represent position and velocity in three-dimensional space:</p> <ul> <li>Position: \\([p_x, p_y, p_z]\\) in meters</li> <li>Velocity: \\([v_x, v_y, v_z]\\) in meters per second</li> </ul> <p>In brahe, the state vector is combined as <code>[p_x, p_y, p_z, v_x, v_y, v_z]</code></p> <p>Cartesian states are typically expressed in an inertial reference frame like Earth-Centered Inertial (ECI), where the axes are fixed with respect to the stars rather than rotating with Earth.</p> <p>Info</p> <p>All position and velocity components in Cartesian states are in SI base units (meters and meters per second).</p> <p>They must be in SI base units for inputs and are always returned in SI base units.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#converting-orbital-elements-to-cartesian","title":"Converting Orbital Elements to Cartesian","text":"<p>The most common workflow is to start with intuitive orbital parameters and convert them to Cartesian states for propagation.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#using-degrees","title":"Using Degrees","text":"<p>When working with human-readable orbital parameters, degrees are more intuitive:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n# LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\noe_deg = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert orbital elements to Cartesian state using degrees\nstate = bh.state_osculating_to_cartesian(oe_deg, bh.AngleFormat.DEGREES)\nprint(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state[0]:.3f}, {state[1]:.3f}, {state[2]:.3f}]\")\nprint(f\"Velocity: [{state[3]:.6f}, {state[4]:.6f}, {state[5]:.6f}]\")\n# Cartesian state  (m, m/s):\n# Position: [1848964.106, -434937.468, 6560410.530]\n# Velocity: [-7098.379734, -2173.344867, 1913.333385]\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n    // LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\n    let oe_deg = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                 // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of periapsis (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Convert orbital elements to Cartesian state using degrees\n    let state = bh::state_osculating_to_cartesian(oe_deg, bh::AngleFormat::Degrees);\n\n    println!(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state[0], state[1], state[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\", state[3], state[4], state[5]);\n    // Cartesian state  (m, m/s):\n    // Position: [1848964.106, -434937.468, 6560410.530]\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385]\n}\n</code></pre>"},{"location":"learn/coordinates/cartesian_transformations.html#using-radians","title":"Using Radians","text":"<p>For mathematical consistency or when working with data already in radians:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nfrom math import pi\n\nbh.initialize_eop()\n\n# Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n# LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\noe_deg = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        pi / 4,  # Inclination (rad)\n        pi / 8,  # Right ascension of ascending node (rad)\n        pi / 2,  # Argument of periapsis (rad)\n        3 * pi / 4,  # Mean anomaly (rad)\n    ]\n)\n\n# Convert orbital elements to Cartesian state using degrees\nstate = bh.state_osculating_to_cartesian(oe_deg, bh.AngleFormat.RADIANS)\nprint(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state[0]:.3f}, {state[1]:.3f}, {state[2]:.3f}]\")\nprint(f\"Velocity: [{state[3]:.6f}, {state[4]:.6f}, {state[5]:.6f}]\")\n# Cartesian state  (m, m/s):\n# Position: [-3117582.037, -5092452.343, -3511765.495]\n# Velocity: [6408.435846, -1407.501408, -3752.763969]\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and radians\n    // LEO satellite: 500 km altitude, 45\u00b0 inclination\n    let oe_rad = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                 // Eccentricity\n        PI/4.0,               // Inclination (rad)\n        PI/8.0,               // Right ascension of ascending node (rad)\n        PI/2.0,               // Argument of periapsis (rad)\n        3.0*PI/4.0            // Mean anomaly (rad)\n    );\n\n    // Convert orbital elements to Cartesian state using radians\n    let state = bh::state_osculating_to_cartesian(oe_rad, bh::AngleFormat::Radians);\n\n    println!(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state[0], state[1], state[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\", state[3], state[4], state[5]);\n    // Cartesian state  (m, m/s):\n    // Position: [-3117582.037, -5092452.343, -3511765.495]\n    // Velocity: [6408.435846, -1407.501408, -3752.763969]\n}\n</code></pre> <p>Info</p> <p>The <code>AngleFormat</code> parameter only affects the three angular elements (i, \u03a9, \u03c9, M). Semi-major axis is always in meters, and eccentricity is always dimensionless.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#converting-cartesian-to-orbital-elements","title":"Converting Cartesian to Orbital Elements","text":"<p>After propagating or receiving Cartesian state data, you often want to convert back to orbital elements for interpretation and analysis.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define Cartesian state vector [px, py, pz, vx, vy, vz] in meters and meters per second\nstate = np.array(\n    [1848964.106, -434937.468, 6560410.530, -7098.379734, -2173.344867, 1913.333385]\n)\n\n# Convert orbital elements to Cartesian state using degrees\noe_deg = bh.state_cartesian_to_osculating(state, bh.AngleFormat.DEGREES)\nprint(\"Osculating state [a, e, i, \u03a9, \u03c9, M] (deg):\")\nprint(f\"Semi-major axis (m): {oe_deg[0]:.3f}\")\nprint(f\"Eccentricity: {oe_deg[1]:.6f}\")\nprint(f\"Inclination (deg): {oe_deg[2]:.6f}\")\nprint(f\"RA of ascending node (deg): {oe_deg[3]:.6f}\")\nprint(f\"Argument of periapsis (deg): {oe_deg[4]:.6f}\")\nprint(f\"Mean anomaly (deg): {oe_deg[5]:.6f}\")\n# Osculating state  (deg):\n# Semi-major axis (m): 6878136.299\n# Eccentricity: 0.010000\n# Inclination (deg): 97.800000\n# RA of ascending node (deg): 15.000000\n# Argument of periapsis (deg): 30.000000\n# Mean anomaly (deg): 45.000000\n\n# You can also convert using radians\noe_rad = bh.state_cartesian_to_osculating(state, bh.AngleFormat.RADIANS)\nprint(\"\\nOsculating state [a, e, i, \u03a9, \u03c9, M] (rad):\")\nprint(f\"Semi-major axis (m): {oe_rad[0]:.3f}\")\nprint(f\"Eccentricity: {oe_rad[1]:.6f}\")\nprint(f\"Inclination (rad): {oe_rad[2]:.6f}\")\nprint(f\"RA of ascending node (rad): {oe_rad[3]:.6f}\")\nprint(f\"Argument of periapsis (rad): {oe_rad[4]:.6f}\")\nprint(f\"Mean anomaly (rad): {oe_rad[5]:.6f}\")\n# Osculating state  (rad):\n# Semi-major axis (m): 6878136.299\n# Eccentricity: 0.010000\n# Inclination (rad): 1.706932\n# RA of ascending node (rad): 0.261799\n# Argument of periapsis (rad): 0.523599\n# Mean anomaly (rad): 0.785398\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define Cartesian state vector [px, py, pz, vx, vy, vz] in meters and meters per second\n    let state = na::SVector::&lt;f64, 6&gt;::new(\n        1848964.106,\n        -434937.468,\n        6560410.530,\n        -7098.379734,\n        -2173.344867,\n        1913.333385\n    );\n\n    // Convert Cartesian state to orbital elements using degrees\n    let oe_deg = bh::state_cartesian_to_osculating(state, bh::AngleFormat::Degrees);\n\n    println!(\"Osculating state [a, e, i, \u03a9, \u03c9, M] (deg):\");\n    println!(\"Semi-major axis (m): {:.3}\", oe_deg[0]);\n    println!(\"Eccentricity: {:.6}\", oe_deg[1]);\n    println!(\"Inclination (deg): {:.6}\", oe_deg[2]);\n    println!(\"RA of ascending node (deg): {:.6}\", oe_deg[3]);\n    println!(\"Argument of periapsis (deg): {:.6}\", oe_deg[4]);\n    println!(\"Mean anomaly (deg): {:.6}\", oe_deg[5]);\n    // Osculating state  (deg):\n    // Semi-major axis (m): 6878136.299\n    // Eccentricity: 0.010000\n    // Inclination (deg): 97.800000\n    // RA of ascending node (deg): 15.000000\n    // Argument of periapsis (deg): 30.000000\n    // Mean anomaly (deg): 45.000000\n\n    // You can also convert using radians\n    let oe_rad = bh::state_cartesian_to_osculating(state, bh::AngleFormat::Radians);\n\n    println!(\"\\nOsculating state [a, e, i, \u03a9, \u03c9, M] (rad):\");\n    println!(\"Semi-major axis (m): {:.3}\", oe_rad[0]);\n    println!(\"Eccentricity: {:.6}\", oe_rad[1]);\n    println!(\"Inclination (rad): {:.6}\", oe_rad[2]);\n    println!(\"RA of ascending node (rad): {:.6}\", oe_rad[3]);\n    println!(\"Argument of periapsis (rad): {:.6}\", oe_rad[4]);\n    println!(\"Mean anomaly (rad): {:.6}\", oe_rad[5]);\n    // Osculating state  (rad):\n    // Semi-major axis (m): 6878136.299\n    // Eccentricity: 0.010000\n    // Inclination (rad): 1.706932\n    // RA of ascending node (rad): 0.261799\n    // Argument of periapsis (rad): 0.523599\n    // Mean anomaly (rad): 0.785398\n}\n</code></pre>"},{"location":"learn/coordinates/cartesian_transformations.html#see-also","title":"See Also","text":"<ul> <li>Cartesian Coordinates API Reference - Complete function documentation</li> <li>Orbital Mechanics - Related orbital mechanics functions</li> <li>Anomaly Conversions - Converting between mean, eccentric, and true anomaly</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html","title":"Geocentric Transformations","text":"<p>Geocentric longitude, latitude, altitude coordinates represent positions relative to a spherical Earth's surface. These coordinates can be converted to and from Earth-Centered Earth-Fixed (ECEF) Cartesian coordinates. This coordinate system is simpler and computationally faster than the geodetic system, but less accurate for near-surface applications because it assumes Earth is a perfect sphere.</p> <p>For complete API details, see the Geocentric Coordinates API Reference.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#geocentric-coordinate-system","title":"Geocentric Coordinate System","text":"<p>Geocentric coordinates represent a position using:</p> <ul> <li>Longitude (\\(\\lambda\\)): East-west angle from the prime meridian, in degrees [-180\u00b0, +180\u00b0] or radians \\([-\\pi, +\\pi]\\)</li> <li>Latitude (\\(\\varphi\\)): North-south angle from the equatorial plane, in degrees [-90\u00b0, +90\u00b0] or radians \\([-\\frac{\\pi}{2}, +\\frac{\\pi}{2}]\\)</li> <li>Altitude (\\(h\\)): Height above the spherical Earth surface, in meters</li> </ul> <p>Combined as: <code>[longitude, latitude, altitude]</code>, often abbreviated as <code>[lon, lat, alt]</code>.</p> <p>Info</p> <p>The spherical Earth model uses an Earth radius of <code>6378137.0</code> meters, which is the WGS84 semi-major axis. This means the geocentric \"surface\" is a sphere with Earth's equatorial radius.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#spherical-vs-ellipsoidal-earth","title":"Spherical vs Ellipsoidal Earth","text":"<p>The key difference between geocentric and geodetic coordinates is the Earth model:</p> <ul> <li>Geocentric: Earth is a perfect sphere of radius <code>WGS84_A</code></li> <li>Geodetic: Earth is an ellipsoid (oblate spheroid) with equatorial bulge</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html#converting-geocentric-to-ecef","title":"Converting Geocentric to ECEF","text":"<p>Earth-Centered Earth-Fixed (ECEF) is a Cartesian coordinate system with:</p> <ul> <li>Origin at Earth's center of mass</li> <li>X-axis through the intersection of the prime meridian and equator</li> <li>Z-axis through the North Pole</li> <li>Y-axis completing a right-handed system</li> </ul> <p>You can convert geocentric spherical coordinates to ECEF Cartesian coordinates using following:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a location in geocentric coordinates (spherical Earth model)\n# Boulder, Colorado (approximately)\nlon = -122.4194  # Longitude (deg)\nlat = 37.7749  # Latitude (deg)\nalt = 13.8  # Altitude above spherical Earth surface (m)\n\nprint(\"Geocentric coordinates (spherical Earth model):\")\nprint(f\"Longitude: {lon:.4f}\u00b0 = {np.radians(lon):.6f} rad\")\nprint(f\"Latitude:  {lat:.4f}\u00b0 = {np.radians(lat):.6f} rad\")\nprint(f\"Altitude:  {alt:.1f} m\\n\")\n# Longitude: -122.4194\u00b0 = -2.136622 rad\n# Latitude:  37.7749\u00b0 = 0.659296 rad\n# Altitude:  13.8 m\n\n# Convert geocentric to ECEF Cartesian\ngeocentric = np.array([lon, lat, alt])\necef = bh.position_geocentric_to_ecef(geocentric, bh.AngleFormat.DEGREES)\n\nprint(\"ECEF Cartesian coordinates:\")\nprint(f\"x = {ecef[0]:.3f} m\")\nprint(f\"y = {ecef[1]:.3f} m\")\nprint(f\"z = {ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(ecef):.3f} m\\n\")\n# x = -2702779.686 m\n# y = -4255713.575 m\n# z = 3907005.447 m\n# Distance from Earth center: 6378150.800 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a location in geocentric coordinates (spherical Earth model)\n    // Boulder, Colorado (approximately)\n    let lon = -122.4194_f64;  // Longitude (deg)\n    let lat = 37.7749_f64;    // Latitude (deg)\n    let alt = 13.8;           // Altitude above spherical Earth surface (m)\n\n    println!(\"Geocentric coordinates (spherical Earth model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", lon, lon.to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", lat, lat.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt);\n    // Expected output:\n    // Longitude: -122.4194\u00b0 = -2.136622 rad\n    // Latitude:  37.7749\u00b0 = 0.659296 rad\n    // Altitude:  13.8 m\n\n    // Convert geocentric to ECEF Cartesian\n    let geocentric = na::Vector3::new(lon, lat, alt);\n    let ecef = bh::position_geocentric_to_ecef(geocentric, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"ECEF Cartesian coordinates:\");\n    println!(\"x = {:.3} m\", ecef[0]);\n    println!(\"y = {:.3} m\", ecef[1]);\n    println!(\"z = {:.3} m\", ecef[2]);\n    let distance = (ecef[0].powi(2) + ecef[1].powi(2) + ecef[2].powi(2)).sqrt();\n    println!(\"Distance from Earth center: {:.3} m\", distance);\n    // Expected output:\n    // x = -2702779.686 m\n    // y = -4255713.575 m\n    // z = 3907005.447 m\n    // Distance from Earth center: 6378150.800 m\n}\n</code></pre>"},{"location":"learn/coordinates/geocentric_transformations.html#converting-ecef-to-geocentric","title":"Converting ECEF to Geocentric","text":"<p>The reverse transformation converts Cartesian ECEF coordinates back to geocentric spherical coordinates:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a satellite state (convert orbital elements to ECEF state)\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC)\nstate_oe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.0,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\nstate_ecef = bh.state_eci_to_ecef(\n    epc, bh.state_osculating_to_cartesian(state_oe, bh.AngleFormat.DEGREES)\n)\nprint(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}]\")\nprint(f\"Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}]\\n\")\n# Position: [-735665.465, -1838913.314, 6586801.432]\n# Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n# Convert ECEF Cartesian to geocentric position\necef_pos = state_ecef[0:3]\ngeocentric = bh.position_ecef_to_geocentric(ecef_pos, bh.AngleFormat.DEGREES)\nprint(\"Geocentric coordinates (spherical Earth model):\")\nprint(f\"Longitude: {geocentric[0]:.4f}\u00b0 = {np.radians(geocentric[0]):.6f} rad\")\nprint(f\"Latitude:  {geocentric[1]:.4f}\u00b0 = {np.radians(geocentric[1]):.6f} rad\")\nprint(f\"Altitude:  {geocentric[2]:.1f} m\")\n# Longitude: -111.8041\u00b0 = -1.951350 rad\n# Latitude:  73.2643\u00b0 = 1.278704 rad\n# Altitude:  499999.3 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a satellite state (convert orbital elements to ECEF state)\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let state_oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.0,                  // Eccentricity\n        97.8_f64,             // Inclination (deg)\n        15.0_f64,             // Right ascension of ascending node (deg)\n        30.0_f64,             // Argument of periapsis (deg)\n        45.0_f64              // Mean anomaly (deg)\n    );\n    let state_eci = bh::state_osculating_to_cartesian(state_oe, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Expected output:\n    // Position: [-735665.465, -1838913.314, 6586801.432]\n    // Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n    // Convert ECEF Cartesian to geocentric position\n    let ecef_pos = na::Vector3::new(state_ecef[0], state_ecef[1], state_ecef[2]);\n    let geocentric = bh::position_ecef_to_geocentric(ecef_pos, bh::AngleFormat::Degrees);\n\n    println!(\"Geocentric coordinates (spherical Earth model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", geocentric[0], geocentric[0].to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", geocentric[1], geocentric[1].to_radians());\n    println!(\"Altitude:  {:.1} m\", geocentric[2]);\n    // Expected output:\n    // Longitude: -111.8041\u00b0 = -1.951350 rad\n    // Latitude:  73.2643\u00b0 = 1.278704 rad\n    // Altitude:  499999.3 m\n}\n</code></pre> <p>Info</p> <p>Latitude values are automatically constrained to the valid range [-90\u00b0, +90\u00b0] or [\\(-\\frac{\\pi}{2}\\), \\(+\\frac{\\pi}{2}\\)] during conversion.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Geocentric Coordinates API Reference - Complete function documentation</li> <li>Geodetic Transformations - More accurate WGS84 ellipsoid model</li> <li>Topocentric Transformations - Local horizon coordinate systems</li> </ul>"},{"location":"learn/coordinates/geodetic_transformations.html","title":"Geodetic Transformations","text":"<p>Geodetic longitude, latitude, altitude coordinates represent positions relative to the WGS84 ellipsoidal Earth model. These coordinates can be converted to and from Earth-Centered Earth-Fixed (ECEF) Cartesian coordinates. This coordinate system is more accurate than the geocentric system for near-surface applications because it accounts for Earth's equatorial bulge.</p> <p>For complete API details, see the Geodetic Coordinates API Reference.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#geodetic-coordinate-system","title":"Geodetic Coordinate System","text":"<p>Geodetic coordinates represent a position using:</p> <ul> <li>Longitude (\\(\\lambda\\)): East-west angle from the prime meridian, in degrees [-180\u00b0, +180\u00b0] or radians \\([-\\pi, +\\pi]\\)</li> <li>Latitude (\\(\\varphi\\)): North-south angle from the equatorial plane, measured perpendicular to the ellipsoid surface, in degrees [-90\u00b0, +90\u00b0] or radians [\\(-\\frac{\\pi}{2}\\), \\(+\\frac{\\pi}{2}\\)]</li> <li>Altitude (\\(h\\)): Height above the WGS84 ellipsoid surface, in meters</li> </ul> <p>Combined as: <code>[longitude, latitude, altitude]</code>, often abbreviated as <code>[lon, lat, alt]</code>.</p> <p>Info</p> <p>Geodetic latitude is measured perpendicular to the ellipsoid surface, not from Earth's center. This differs from geocentric latitude, which is measured from the center. For a point on the surface, these can differ by up to 11 arcminutes (about 0.2\u00b0).</p>"},{"location":"learn/coordinates/geodetic_transformations.html#wgs84-ellipsoid-model","title":"WGS84 Ellipsoid Model","text":"<p>The key difference between geodetic and geocentric coordinates is the Earth model:</p> <ul> <li>Geodetic: Earth is an ellipsoid (oblate spheroid) with parameters:<ul> <li>Semi-major axis: <code>WGS84_A = 6378137.0</code> meters (equatorial radius)</li> <li>Flattening: <code>WGS84_F = 1/298.257223563</code></li> </ul> </li> <li>Geocentric: Earth is a perfect sphere of radius <code>WGS84_A</code></li> </ul> <p>The difference between equatorial and polar radii is approximately 21 km, which significantly affects position calculations near Earth's surface.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#converting-geodetic-to-ecef","title":"Converting Geodetic to ECEF","text":"<p>Earth-Centered Earth-Fixed (ECEF) is a Cartesian coordinate system with:</p> <ul> <li>Origin at Earth's center of mass</li> <li>X-axis through the intersection of the prime meridian and equator</li> <li>Z-axis through the North Pole</li> <li>Y-axis completing a right-handed system</li> </ul> <p>You can convert geodetic coordinates to ECEF Cartesian coordinates using the following:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a location in geodetic coordinates (WGS84 ellipsoid model)\n# Boulder, Colorado (approximately)\nlon = -122.4194  # Longitude (deg)\nlat = 37.7749  # Latitude (deg)\nalt = 16.0  # Altitude above WGS84 ellipsoid (m)\n\nprint(\"Geodetic coordinates (WGS84 ellipsoid model):\")\nprint(f\"Longitude: {lon:.4f}\u00b0 = {np.radians(lon):.6f} rad\")\nprint(f\"Latitude:  {lat:.4f}\u00b0 = {np.radians(lat):.6f} rad\")\nprint(f\"Altitude:  {alt:.1f} m\\n\")\n# Longitude: -122.4194\u00b0 = -2.136622 rad\n# Latitude:  37.7749\u00b0 = 0.659296 rad\n# Altitude:  16.0 m\n\n# Convert geodetic to ECEF Cartesian\ngeodetic = np.array([lon, lat, alt])\necef = bh.position_geodetic_to_ecef(geodetic, bh.AngleFormat.DEGREES)\n\nprint(\"ECEF Cartesian coordinates:\")\nprint(f\"x = {ecef[0]:.3f} m\")\nprint(f\"y = {ecef[1]:.3f} m\")\nprint(f\"z = {ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(ecef):.3f} m\\n\")\n# x = -2706181.627 m\n# y = -4261070.165 m\n# z = 3885735.291 m\n# Distance from Earth center: 6370170.853 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a location in geodetic coordinates (WGS84 ellipsoid model)\n    // Boulder, Colorado (approximately)\n    let lon = -122.4194_f64;  // Longitude (deg)\n    let lat = 37.7749_f64;    // Latitude (deg)\n    let alt = 16.0;           // Altitude above WGS84 ellipsoid (m)\n\n    println!(\"Geodetic coordinates (WGS84 ellipsoid model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", lon, lon.to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", lat, lat.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt);\n    // Expected output:\n    // Longitude: -122.4194\u00b0 = -2.136622 rad\n    // Latitude:  37.7749\u00b0 = 0.659296 rad\n    // Altitude:  16.0 m\n\n    // Convert geodetic to ECEF Cartesian\n    let geodetic = na::Vector3::new(lon, lat, alt);\n    let ecef = bh::position_geodetic_to_ecef(geodetic, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"ECEF Cartesian coordinates:\");\n    println!(\"x = {:.3} m\", ecef[0]);\n    println!(\"y = {:.3} m\", ecef[1]);\n    println!(\"z = {:.3} m\", ecef[2]);\n    let distance = (ecef[0].powi(2) + ecef[1].powi(2) + ecef[2].powi(2)).sqrt();\n    println!(\"Distance from Earth center: {:.3} m\", distance);\n    // Expected output:\n    // x = -2706181.627 m\n    // y = -4261070.165 m\n    // z = 3885735.291 m\n    // Distance from Earth center: 6370170.853 m\n}\n</code></pre> <p>Info</p> <p>The conversion from geodetic to ECEF accounts for the ellipsoidal shape using the radius of curvature in the prime vertical and the first eccentricity of the ellipsoid.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#converting-ecef-to-geodetic","title":"Converting ECEF to Geodetic","text":"<p>The reverse transformation converts Cartesian ECEF coordinates back to geodetic coordinates. This requires an iterative algorithm due to the ellipsoidal geometry:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a satellite state (convert orbital elements to ECEF state)\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC)\nstate_oe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.0,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\nstate_ecef = bh.state_eci_to_ecef(\n    epc, bh.state_osculating_to_cartesian(state_oe, bh.AngleFormat.DEGREES)\n)\nprint(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}]\")\nprint(f\"Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}]\\n\")\n# Position: [-735665.465, -1838913.314, 6586801.432]\n# Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n# Convert ECEF Cartesian to geodetic position\necef_pos = state_ecef[0:3]\ngeodetic = bh.position_ecef_to_geodetic(ecef_pos, bh.AngleFormat.DEGREES)\nprint(\"Geodetic coordinates (WGS84 ellipsoid model):\")\nprint(f\"Longitude: {geodetic[0]:.4f}\u00b0 = {np.radians(geodetic[0]):.6f} rad\")\nprint(f\"Latitude:  {geodetic[1]:.4f}\u00b0 = {np.radians(geodetic[1]):.6f} rad\")\nprint(f\"Altitude:  {geodetic[2]:.1f} m\")\n# Longitude: -111.8041\u00b0 = -1.951350 rad\n# Latitude:  73.3622\u00b0 = 1.280412 rad\n# Altitude:  519618.1 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a satellite state (convert orbital elements to ECEF state)\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let state_oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.0,                  // Eccentricity\n        97.8_f64,             // Inclination (deg)\n        15.0_f64,             // Right ascension of ascending node (deg)\n        30.0_f64,             // Argument of periapsis (deg)\n        45.0_f64              // Mean anomaly (deg)\n    );\n    let state_eci = bh::state_osculating_to_cartesian(state_oe, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Expected output:\n    // Position: [-735665.465, -1838913.314, 6586801.432]\n    // Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n    // Convert ECEF Cartesian to geodetic position\n    let ecef_pos = na::Vector3::new(state_ecef[0], state_ecef[1], state_ecef[2]);\n    let geodetic = bh::position_ecef_to_geodetic(ecef_pos, bh::AngleFormat::Degrees);\n\n    println!(\"Geodetic coordinates (WGS84 ellipsoid model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", geodetic[0], geodetic[0].to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", geodetic[1], geodetic[1].to_radians());\n    println!(\"Altitude:  {:.1} m\", geodetic[2]);\n    // Expected output:\n    // Longitude: -111.8041\u00b0 = -1.951350 rad\n    // Latitude:  73.3622\u00b0 = 1.280412 rad\n    // Altitude:  519618.1 m\n}\n</code></pre> <p>Info</p> <p>The ECEF to geodetic conversion uses an iterative algorithm that typically converges in 3-5 iterations to sub-millimeter precision.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#geodetic-vs-geocentric-accuracy","title":"Geodetic vs Geocentric Accuracy","text":"<p>For the same longitude, latitude, and altitude values, geodetic and geocentric coordinates produce different ECEF positions. The difference is smallest near the equator and largest near the poles.</p> <p>For most applications, it's best to use geodetic coordinates since any computational overhead is negligible compared to the improved accuracy near Earth's surface.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#see-also","title":"See Also","text":"<ul> <li>Geodetic Coordinates API Reference - Complete function documentation</li> <li>Geocentric Transformations - Simpler spherical Earth model</li> <li>Topocentric Transformations - Local horizon coordinate systems</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html","title":"Topocentric Coordinate Transformations","text":"<p>Topocentric coordinate systems are local horizon-based reference frames centered on an observer, such as a ground station or radar site. These coordinate systems are essential for satellite tracking, visibility analysis, and determining where to point antennas or telescopes.</p> <p>Unlike global coordinate systems (ECEF, ECI), topocentric systems define positions relative to a specific location on Earth, making it easy to determine whether a satellite is visible and where to look in the sky.</p> <p>For complete API details, see the Topocentric Coordinates API Reference.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#topocentric-coordinate-systems","title":"Topocentric Coordinate Systems","text":"<p>Brahe supports two local horizon coordinate systems:</p>"},{"location":"learn/coordinates/topocentric_transformations.html#enz-east-north-zenith","title":"ENZ (East-North-Zenith)","text":"<ul> <li>East (E): Positive toward geographic east</li> <li>North (N): Positive toward geographic north</li> <li>Zenith (Z): Positive upward (toward the sky)</li> </ul> <p>This is the most common topocentric system for satellite tracking and is aligned with geographic directions.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#sez-south-east-zenith","title":"SEZ (South-East-Zenith)","text":"<ul> <li>South (S): Positive toward geographic south</li> <li>East (E): Positive toward geographic east</li> <li>Zenith (Z): Positive upward (toward the sky)</li> </ul> <p>The SEZ system is sometimes used in radar and missile tracking applications. The main difference from ENZ is that the first two axes are rotated 180\u00b0 around the zenith axis.</p> <p>Info</p> <p>Both ENZ and SEZ use a right-handed coordinate system with the zenith axis pointing up. The choice between them is typically driven by convention in your specific field or application.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#station-location-interpretation","title":"Station Location Interpretation","text":"<p>When specifying the observer (ground station) location, you must choose whether the coordinates represent:</p> <ul> <li>Geodetic (<code>EllipsoidalConversionType.GEODETIC</code>): Station coordinates use WGS84 ellipsoid (recommended for accuracy)</li> <li>Geocentric (<code>EllipsoidalConversionType.GEOCENTRIC</code>): Station coordinates use spherical Earth model</li> </ul> <p>For ground stations, geodetic interpretation is almost always preferred for accuracy.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#enz-transformations","title":"ENZ Transformations","text":""},{"location":"learn/coordinates/topocentric_transformations.html#converting-ecef-to-enz","title":"Converting ECEF to ENZ","text":"<p>To get the position of an object relative to a location, you need to convert the object's ECEF position to the local ENZ frame centered on the location:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define satellite in sun-synchronous orbit at 500 km altitude\n# SSO orbit passes over Stanford at approximately 10:30 AM local time\n# Orbital elements: [a, e, i, RAAN, omega, M]\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 240.0, 0.0, 90.0])\n\n# Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Convert orbital elements to ECI state\nsat_state_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\n# Convert ECI state to ECEF at the given epoch\nsat_state_ecef = bh.state_eci_to_ecef(epoch, sat_state_eci)\nsat_ecef = sat_state_ecef[0:3]  # Extract position only\n\nyear, month, day, hour, minute, second, ns = epoch.to_datetime()\nprint(f\"Epoch: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f} UTC\")\nprint(\"Satellite ECEF:\")\nprint(f\"x = {sat_ecef[0]:.3f} m\")\nprint(f\"y = {sat_ecef[1]:.3f} m\")\nprint(f\"z = {sat_ecef[2]:.3f} m\\n\")\n\n# Convert satellite position to ENZ coordinates relative to ground station\nenz = bh.relative_position_ecef_to_enz(\n    station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Satellite position in ENZ frame (relative to Stanford):\")\nprint(f\"East:   {enz[0] / 1000:.3f} km\")\nprint(f\"North:  {enz[1] / 1000:.3f} km\")\nprint(f\"Zenith: {enz[2] / 1000:.3f} km\")\nprint(f\"Range:  {np.linalg.norm(enz) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define satellite in sun-synchronous orbit at 500 km altitude\n    // SSO orbit passes over Stanford at approximately 10:30 AM local time\n    // Orbital elements: [a, e, i, RAAN, omega, M]\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8_f64,\n        240.0_f64,\n        0.0_f64,\n        90.0_f64,\n    );\n\n    // Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Convert orbital elements to ECI state\n    let sat_state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n\n    // Convert ECI state to ECEF at the given epoch\n    let sat_state_ecef = bh::state_eci_to_ecef(epoch, sat_state_eci);\n    let sat_ecef = na::Vector3::new(sat_state_ecef[0], sat_state_ecef[1], sat_state_ecef[2]);\n\n    let (year, month, day, hour, minute, second, _ns) = epoch.to_datetime();\n    println!(\"Epoch: {}-{:02}-{:02} {:02}:{:02}:{:06.3} UTC\", year, month, day, hour, minute, second);\n    println!(\"Satellite ECEF:\");\n    println!(\"x = {:.3} m\", sat_ecef[0]);\n    println!(\"y = {:.3} m\", sat_ecef[1]);\n    println!(\"z = {:.3} m\\n\", sat_ecef[2]);\n\n    // Convert satellite position to ENZ coordinates relative to ground station\n    let enz = bh::relative_position_ecef_to_enz(\n        station_ecef,\n        sat_ecef,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Satellite position in ENZ frame (relative to Stanford):\");\n    println!(\"East:   {:.3} km\", enz[0] / 1000.0);\n    println!(\"North:  {:.3} km\", enz[1] / 1000.0);\n    println!(\"Zenith: {:.3} km\", enz[2] / 1000.0);\n    println!(\"Range:  {:.3} km\", enz.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#converting-enz-to-ecef","title":"Converting ENZ to ECEF","text":"<p>The reverse transformation converts a relative ENZ position back to an absolute ECEF position:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define relative position in ENZ coordinates\n# Example: 50 km East, 100 km North, 200 km Up from station\nenz = np.array([50e3, 100e3, 200e3])\n\nprint(\"Relative position in ENZ frame:\")\nprint(f\"East:   {enz[0] / 1000:.1f} km\")\nprint(f\"North:  {enz[1] / 1000:.1f} km\")\nprint(f\"Zenith: {enz[2] / 1000:.1f} km\\n\")\n# East:   50.0 km\n# North:  100.0 km\n# Zenith: 200.0 km\n\n# Convert ENZ relative position to absolute ECEF position\ntarget_ecef = bh.relative_position_enz_to_ecef(\n    station_ecef, enz, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Target position in ECEF:\")\nprint(f\"x = {target_ecef[0]:.3f} m\")\nprint(f\"y = {target_ecef[1]:.3f} m\")\nprint(f\"z = {target_ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(target_ecef) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define relative position in ENZ coordinates\n    // Example: 50 km East, 100 km North, 200 km Up from station\n    let enz = na::Vector3::new(50e3, 100e3, 200e3);\n\n    println!(\"Relative position in ENZ frame:\");\n    println!(\"East:   {:.1} km\", enz[0] / 1000.0);\n    println!(\"North:  {:.1} km\", enz[1] / 1000.0);\n    println!(\"Zenith: {:.1} km\\n\", enz[2] / 1000.0);\n    // Expected output:\n    // East:   50.0 km\n    // North:  100.0 km\n    // Zenith: 200.0 km\n\n    // Convert ENZ relative position to absolute ECEF position\n    let target_ecef = bh::relative_position_enz_to_ecef(\n        station_ecef,\n        enz,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Target position in ECEF:\");\n    println!(\"x = {:.3} m\", target_ecef[0]);\n    println!(\"y = {:.3} m\", target_ecef[1]);\n    println!(\"z = {:.3} m\", target_ecef[2]);\n    println!(\"Distance from Earth center: {:.3} km\", target_ecef.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#sez-transformations","title":"SEZ Transformations","text":""},{"location":"learn/coordinates/topocentric_transformations.html#converting-ecef-to-sez","title":"Converting ECEF to SEZ","text":"<p>Similar to ENZ, you can convert ECEF positions to the SEZ frame:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define satellite in sun-synchronous orbit at 500 km altitude\n# SSO orbit passes over Stanford at approximately 10:30 AM local time\n# Orbital elements: [a, e, i, RAAN, omega, M]\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 240.0, 0.0, 90.0])\n\n# Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Convert orbital elements to ECI state\nsat_state_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\n# Convert ECI state to ECEF at the given epoch\nsat_state_ecef = bh.state_eci_to_ecef(epoch, sat_state_eci)\nsat_ecef = sat_state_ecef[0:3]  # Extract position only\n\nyear, month, day, hour, minute, second, ns = epoch.to_datetime()\nprint(f\"Epoch: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f} UTC\")\nprint(\"Satellite ECEF:\")\nprint(f\"x = {sat_ecef[0]:.3f} m\")\nprint(f\"y = {sat_ecef[1]:.3f} m\")\nprint(f\"z = {sat_ecef[2]:.3f} m\\n\")\n\n# Convert satellite position to SEZ coordinates relative to ground station\nsez = bh.relative_position_ecef_to_sez(\n    station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Satellite position in SEZ frame (relative to Stanford):\")\nprint(f\"South:  {sez[0] / 1000:.3f} km\")\nprint(f\"East:   {sez[1] / 1000:.3f} km\")\nprint(f\"Zenith: {sez[2] / 1000:.3f} km\")\nprint(f\"Range:  {np.linalg.norm(sez) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define satellite in sun-synchronous orbit at 500 km altitude\n    // SSO orbit passes over Stanford at approximately 10:30 AM local time\n    // Orbital elements: [a, e, i, RAAN, omega, M]\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8_f64,\n        240.0_f64,\n        0.0_f64,\n        90.0_f64,\n    );\n\n    // Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Convert orbital elements to ECI state\n    let sat_state_eci = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Degrees);\n\n    // Convert ECI state to ECEF at the given epoch\n    let sat_state_ecef = bh::state_eci_to_ecef(epoch, sat_state_eci);\n    let sat_ecef = na::Vector3::new(sat_state_ecef[0], sat_state_ecef[1], sat_state_ecef[2]);\n\n    let (year, month, day, hour, minute, second, _ns) = epoch.to_datetime();\n    println!(\"Epoch: {}-{:02}-{:02} {:02}:{:02}:{:06.3} UTC\", year, month, day, hour, minute, second);\n    println!(\"Satellite ECEF:\");\n    println!(\"x = {:.3} m\", sat_ecef[0]);\n    println!(\"y = {:.3} m\", sat_ecef[1]);\n    println!(\"z = {:.3} m\\n\", sat_ecef[2]);\n\n    // Convert satellite position to SEZ coordinates relative to ground station\n    let sez = bh::relative_position_ecef_to_sez(\n        station_ecef,\n        sat_ecef,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Satellite position in SEZ frame (relative to Stanford):\");\n    println!(\"South:  {:.3} km\", sez[0] / 1000.0);\n    println!(\"East:   {:.3} km\", sez[1] / 1000.0);\n    println!(\"Zenith: {:.3} km\", sez[2] / 1000.0);\n    println!(\"Range:  {:.3} km\", sez.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#converting-sez-to-ecef","title":"Converting SEZ to ECEF","text":"<p>The reverse transformation converts a relative SEZ position back to an absolute ECEF position:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define relative position in SEZ coordinates\n# Example: 30 km South, 50 km East, 100 km Up from station\nsez = np.array([30e3, 50e3, 100e3])\n\nprint(\"Relative position in SEZ frame:\")\nprint(f\"South:  {sez[0] / 1000:.1f} km\")\nprint(f\"East:   {sez[1] / 1000:.1f} km\")\nprint(f\"Zenith: {sez[2] / 1000:.1f} km\\n\")\n# South:  30.0 km\n# East:   50.0 km\n# Zenith: 100.0 km\n\n# Convert SEZ relative position to absolute ECEF position\ntarget_ecef = bh.relative_position_sez_to_ecef(\n    station_ecef, sez, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Target position in ECEF:\")\nprint(f\"x = {target_ecef[0]:.3f} m\")\nprint(f\"y = {target_ecef[1]:.3f} m\")\nprint(f\"z = {target_ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(target_ecef) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define relative position in SEZ coordinates\n    // Example: 30 km South, 50 km East, 100 km Up from station\n    let sez = na::Vector3::new(30e3, 50e3, 100e3);\n\n    println!(\"Relative position in SEZ frame:\");\n    println!(\"South:  {:.1} km\", sez[0] / 1000.0);\n    println!(\"East:   {:.1} km\", sez[1] / 1000.0);\n    println!(\"Zenith: {:.1} km\\n\", sez[2] / 1000.0);\n    // Expected output:\n    // South:  30.0 km\n    // East:   50.0 km\n    // Zenith: 100.0 km\n\n    // Convert SEZ relative position to absolute ECEF position\n    let target_ecef = bh::relative_position_sez_to_ecef(\n        station_ecef,\n        sez,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Target position in ECEF:\");\n    println!(\"x = {:.3} m\", target_ecef[0]);\n    println!(\"y = {:.3} m\", target_ecef[1]);\n    println!(\"z = {:.3} m\", target_ecef[2]);\n    println!(\"Distance from Earth center: {:.3} km\", target_ecef.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#azimuth-and-elevation-from-topocentric-coordinates","title":"Azimuth and Elevation from Topocentric Coordinates","text":"<p>For object tracking, it's often more intuitive to work with azimuth (compass direction) and elevation (angle above the horizon) rather than Cartesian ENZ or SEZ coordinates. Both ENZ and SEZ topocentric systems can be converted to azimuth-elevation-range format.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#from-enz-coordinates","title":"From ENZ Coordinates","text":"<p>Convert ENZ positions to azimuth (measured clockwise from North), elevation (angle above horizon), and range:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define several relative positions in ENZ coordinates\ntest_cases = [\n    (\"Directly overhead\", np.array([0.0, 0.0, 100e3])),\n    (\"North horizon\", np.array([0.0, 100e3, 0.0])),\n    (\"East horizon\", np.array([100e3, 0.0, 0.0])),\n    (\"South horizon\", np.array([0.0, -100e3, 0.0])),\n    (\"West horizon\", np.array([-100e3, 0.0, 0.0])),\n    (\"Northeast at 45\u00b0 elevation\", np.array([50e3, 50e3, 70.7e3])),\n]\n\nprint(\"Converting ENZ coordinates to Azimuth-Elevation-Range:\\n\")\n\nfor name, enz in test_cases:\n    # Convert to azimuth-elevation-range\n    azel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\n\n    print(f\"{name}:\")\n    print(\n        f\"  ENZ:   E={enz[0] / 1000:.1f}km, N={enz[1] / 1000:.1f}km, Z={enz[2] / 1000:.1f}km\"\n    )\n    print(\n        f\"  Az/El: Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2] / 1000:.1f}km\\n\"\n    )\n\n# Expected outputs:\n# Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n# North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n# East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n# South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n# West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define several relative positions in ENZ coordinates\n    let test_cases = vec![\n        (\"Directly overhead\", na::Vector3::new(0.0, 0.0, 100e3)),\n        (\"North horizon\", na::Vector3::new(0.0, 100e3, 0.0)),\n        (\"East horizon\", na::Vector3::new(100e3, 0.0, 0.0)),\n        (\"South horizon\", na::Vector3::new(0.0, -100e3, 0.0)),\n        (\"West horizon\", na::Vector3::new(-100e3, 0.0, 0.0)),\n        (\"Northeast at 45\u00b0 elevation\", na::Vector3::new(50e3, 50e3, 70.7e3)),\n    ];\n\n    println!(\"Converting ENZ coordinates to Azimuth-Elevation-Range:\\n\");\n\n    for (name, enz) in test_cases {\n        // Convert to azimuth-elevation-range\n        let azel = bh::position_enz_to_azel(enz, bh::AngleFormat::Degrees);\n\n        println!(\"{}:\", name);\n        println!(\"  ENZ:   E={:.1}km, N={:.1}km, Z={:.1}km\",\n                 enz[0] / 1000.0, enz[1] / 1000.0, enz[2] / 1000.0);\n        println!(\"  Az/El: Az={:.1}\u00b0, El={:.1}\u00b0, Range={:.1}km\\n\",\n                 azel[0], azel[1], azel[2] / 1000.0);\n    }\n\n    // Expected outputs:\n    // Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n    // North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n}\n</code></pre> <p>Info</p> <p>Azimuth is measured clockwise from North (0\u00b0 = North, 90\u00b0 = East, 180\u00b0 = South, 270\u00b0 = West). Elevation is the angle above the horizon (0\u00b0 = horizon, 90\u00b0 = directly overhead).</p>"},{"location":"learn/coordinates/topocentric_transformations.html#from-sez-coordinates","title":"From SEZ Coordinates","text":"<p>The same conversion is available from SEZ coordinates:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define several relative positions in SEZ coordinates\ntest_cases = [\n    (\"Directly overhead\", np.array([0.0, 0.0, 100e3])),\n    (\"North horizon\", np.array([-100e3, 0.0, 0.0])),\n    (\"East horizon\", np.array([0.0, 100e3, 0.0])),\n    (\"South horizon\", np.array([100e3, 0.0, 0.0])),\n    (\"West horizon\", np.array([0.0, -100e3, 0.0])),\n    (\"Northeast at 45\u00b0 elevation\", np.array([-50e3, 50e3, 70.7e3])),\n]\n\nprint(\"Converting SEZ coordinates to Azimuth-Elevation-Range:\\n\")\n\nfor name, sez in test_cases:\n    # Convert to azimuth-elevation-range\n    azel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\n\n    print(f\"{name}:\")\n    print(\n        f\"  SEZ:   S={sez[0] / 1000:.1f}km, E={sez[1] / 1000:.1f}km, Z={sez[2] / 1000:.1f}km\"\n    )\n    print(\n        f\"  Az/El: Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2] / 1000:.1f}km\\n\"\n    )\n\n# Expected outputs:\n# Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n# North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n# East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n# South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n# West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define several relative positions in SEZ coordinates\n    let test_cases = vec![\n        (\"Directly overhead\", na::Vector3::new(0.0, 0.0, 100e3)),\n        (\"North horizon\", na::Vector3::new(-100e3, 0.0, 0.0)),\n        (\"East horizon\", na::Vector3::new(0.0, 100e3, 0.0)),\n        (\"South horizon\", na::Vector3::new(100e3, 0.0, 0.0)),\n        (\"West horizon\", na::Vector3::new(0.0, -100e3, 0.0)),\n        (\"Northeast at 45\u00b0 elevation\", na::Vector3::new(-50e3, 50e3, 70.7e3)),\n    ];\n\n    println!(\"Converting SEZ coordinates to Azimuth-Elevation-Range:\\n\");\n\n    for (name, sez) in test_cases {\n        // Convert to azimuth-elevation-range\n        let azel = bh::position_sez_to_azel(sez, bh::AngleFormat::Degrees);\n\n        println!(\"{}:\", name);\n        println!(\"  SEZ:   S={:.1}km, E={:.1}km, Z={:.1}km\",\n                 sez[0] / 1000.0, sez[1] / 1000.0, sez[2] / 1000.0);\n        println!(\"  Az/El: Az={:.1}\u00b0, El={:.1}\u00b0, Range={:.1}km\\n\",\n                 azel[0], azel[1], azel[2] / 1000.0);\n    }\n\n    // Expected outputs:\n    // Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n    // North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n}\n</code></pre> <p>Info</p> <p>Both ENZ and SEZ produce identical azimuth-elevation-range results for the same physical position. The choice between them is purely a matter of intermediate representation.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates API Reference - Complete function documentation</li> <li>Geodetic Transformations - Converting station locations to ECEF</li> <li>Frame Transformations - Converting satellite positions from ECI to ECEF</li> <li>Access Analysis - Higher-level tools for computing satellite visibility windows</li> </ul>"},{"location":"learn/datasets/index.html","title":"Datasets","text":"<p>The datasets module in Brahe provides easy access to common data sources used in astrodynamics, space mission analysis, and research. This includes ephemeris data for Earth-orbiting satellites and locations of ground stations.</p>"},{"location":"learn/datasets/index.html#overview","title":"Overview","text":"<p>Working with satellite data typically requires gathering information from multiple sources:</p> <ul> <li>Orbital elements (TLEs) for satellite tracking and propagation</li> <li>Groundstation locations for computing contact opportunities</li> <li>Satellite metadata for mission planning and analysis</li> </ul> <p>Brahe's datasets module centralizes access to these data sources, handling the details of fetching, parsing, and caching so you can focus on analysis rather than data wrangling.</p>"},{"location":"learn/datasets/index.html#available-data-sources","title":"Available Data Sources","text":""},{"location":"learn/datasets/index.html#celestrak","title":"CelesTrak","text":"<p>CelesTrak provides Two-Line Element (TLE) data for thousands of Earth-orbiting satellites. The brahe interface supports:</p> <ul> <li>Group downloads: Fetch entire satellite constellations (Starlink, OneWeb, GPS, etc.)</li> <li>Individual lookups: Get specific satellites by NORAD ID or name</li> <li>Direct propagation: Convert TLEs to SGP4 propagators in one step</li> </ul> <p>Best for: Satellite analysis, orbit propagation, space situational awareness</p>"},{"location":"learn/datasets/index.html#groundstations","title":"Groundstations","text":"<p>Embedded GeoJSON data for commercial groundstation networks. Includes 6 major providers:</p> <ul> <li>Atlas Space Operations</li> <li>Amazon Web Services Ground Station</li> <li>Kongsberg Satellite Services (KSAT)</li> <li>Leaf Space</li> <li>Swedish Space Corporation (SSC)</li> <li>Viasat</li> </ul> <p>Best for: Contact opportunity analysis, network planning, coverage studies</p>"},{"location":"learn/datasets/index.html#data-philosophy","title":"Data Philosophy","text":"<p>Brahe's datasets module aims to:</p> <ul> <li>Reduce friction: Provide easy access to commonly needed data</li> <li>No surprises: Data sources are clearly documented with known limitations</li> <li>Offline capable: Prefer embedded data when feasible</li> <li>Respect providers: Follow best practices and rate limiting</li> <li>Stay current: Update data sources as the ecosystem evolves</li> </ul>"},{"location":"learn/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Data Source - TLE ephemeris data</li> <li>Groundstation Datasets - Ground facility locations</li> <li>Datasets API Reference - Complete function documentation</li> </ul>"},{"location":"learn/datasets/celestrak.html","title":"CelesTrak Data Source","text":"<p>CelesTrak is a public source for satellite Two-Line Element (TLE) data, maintained by T.S. Kelso since 1985. It provides free, frequently updated orbital element sets for thousands of satellites, making it a useful resource for satellite tracking, orbit determination, and space situational awareness.</p> <p>Respectful Usage</p> <p>CelesTrak is freely available for public use, but users should be respectful of the service. Avoid excessive automated requests, and design your calls to take advantage of caching to minimize repeated queries. For large-scale or commercial applications, consider setting up a single download and local caching strategy to disribute ephemeris data internally.</p>"},{"location":"learn/datasets/celestrak.html#overview","title":"Overview","text":""},{"location":"learn/datasets/celestrak.html#what-is-celestrak","title":"What is CelesTrak?","text":"<p>CelesTrak is a public data source for satellite orbital elements, maintained by Dr. T.S. Kelso since 1985. It provides free, frequently updated Two-Line Element (TLE) data for thousands of satellites, making it an essential resource for satellite tracking, orbit determination, and space situational awareness.</p>"},{"location":"learn/datasets/celestrak.html#tle-format","title":"TLE Format","text":"<p>Two-Line Elements (TLEs) are a compact text format for encoding satellite orbital parameters compatible with the SGP4/SDP4 propagation models. For more information on TLEs, see the Two-Line Elements documentation.</p>"},{"location":"learn/datasets/celestrak.html#caching","title":"Caching","text":"<p>To minimize load on CelesTrak's servers and improve performance, brahe implements a 6-hour cache for downloaded data:</p> <ul> <li>Cache key: Satellite group name (e.g., \"starlink\", \"stations\")</li> <li>Cache duration: 6 hours (default, configurable)</li> <li>Cache location: System temp directory</li> </ul> <p>When you request a satellite by ID or name with a group hint, brahe checks if that group was recently downloaded and uses cached data if available. This is much faster and more respectful than making individual requests.</p> <p>Customizing Cache</p> <p>See the Caching documentation for details on customizing cache behavior.</p>"},{"location":"learn/datasets/celestrak.html#usage","title":"Usage","text":""},{"location":"learn/datasets/celestrak.html#getting-ephemeris-by-group","title":"Getting Ephemeris by Group","text":"<p>The most efficient way to get TLE data is by downloading entire groups. This minimizes API requests and leverages caching:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Download TLE data for the Starlink group\n# This fetches all Starlink satellites in one request\ntles = bh.datasets.celestrak.get_tles(\"starlink\")\n\nprint(f\"Downloaded {len(tles)} Starlink TLEs\")\n\n# Each TLE is a tuple of (name, line1, line2)\nname, line1, line2 = tles[0]\nprint(\"\\nFirst TLE:\")\nprint(f\"  Name: {name}\")\nprint(f\"  Line 1: {line1}\")\nprint(f\"  Line 2: {line2}\")\n\n# Expected output:\n# Downloaded 8647 Starlink TLEs\n\n# First TLE:\n#   Name: STARLINK-1008\n#   Line 1: 1 44714U 19074B   25306.45157821  .00002551  00000+0  19011-3 0  9997\n#   Line 2: 2 44714  53.0544  37.8105 0001365  79.2826 280.8316 15.06391189329573\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Download TLE data for the Starlink group\n    // This fetches all Starlink satellites in one request\n    let tles = bh::datasets::celestrak::get_tles(\"starlink\").unwrap();\n\n    println!(\"Downloaded {} Starlink TLEs\", tles.len());\n\n    // Each TLE is a tuple of (name, line1, line2)\n    let (name, line1, line2) = &amp;tles[0];\n    println!(\"\\nFirst TLE:\");\n    println!(\"  Name: {}\", name);\n    println!(\"  Line 1: {}\", line1);\n    println!(\"  Line 2: {}\", line2);\n\n    // Expected output:\n    // Downloaded 8647 Starlink TLEs\n\n    // First TLE:\n    //   Name: STARLINK-1008\n    //   Line 1: 1 44714U 19074B   25306.45157821  .00002551  00000+0  19011-3 0  9997\n    //   Line 2: 2 44714  53.0544  37.8105 0001365  79.2826 280.8316 15.06391189329573\n}\n</code></pre>"},{"location":"learn/datasets/celestrak.html#getting-a-satellite-by-id","title":"Getting a Satellite by ID","text":"<p>To get a specific satellite, provide its NORAD ID. Always include a group hint to enable cache-efficient lookups:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get ISS TLE by NORAD ID\n# The group hint (\"stations\") allows brahe to check cached data first\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_id(25544, \"stations\")\n\n# Parse TLE data to get epoch and orbital elements\nepoch, oe = bh.keplerian_elements_from_tle(line1, line2)\n\nprint(\"ISS TLE:\")\nprint(f\"  Name: {name}\")\nprint(f\"  Epoch: {epoch}\")\nprint(f\"  Inclination: {oe[2]:.2f}\u00b0\")\nprint(f\"  RAAN: {oe[3]:.2f}\u00b0\")\nprint(f\"  Eccentricity: {oe[1]:.6f}\")\n\n# Expected output:\n# ISS TLE:\n#   Name: ISS (ZARYA)\n#   Epoch: 2025-11-02 10:09:34.283 UTC\n#   Inclination: 51.63\u00b0\n#   RAAN: 342.07\u00b0\n#   Eccentricity: 0.000497\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get ISS TLE by NORAD ID\n    // The group hint (\"stations\") allows brahe to check cached data first\n    let (name, line1, line2) = bh::datasets::celestrak::get_tle_by_id(25544, Some(\"stations\")).unwrap();\n\n    // Parse TLE data to get epoch and orbital elements\n    let (epoch, oe) = bh::keplerian_elements_from_tle(&amp;line1, &amp;line2).unwrap();\n\n    println!(\"ISS TLE:\");\n    println!(\"  Name: {}\", name);\n    println!(\"  Epoch: {}\", epoch);\n    println!(\"  Inclination: {:.2}\u00b0\", oe[2]);\n    println!(\"  RAAN: {:.2}\u00b0\", oe[3]);\n    println!(\"  Eccentricity: {:.6}\", oe[1]);\n\n    // Expected output:\n    // ISS TLE:\n    //   Name: ISS (ZARYA)\n    //   Epoch: 2025-11-02 10:09:34.283 UTC\n    //   Inclination: 51.63\u00b0\n    //   RAAN: 342.07\u00b0\n    //   Eccentricity: 0.000497\n}\n</code></pre> <p>Cache-Efficient Pattern</p> <p>The most efficient workflow is:</p> <ol> <li>Download the group once: <code>get_tles(\"stations\")</code></li> <li>Query specific satellites with the group hint: <code>get_tle_by_id(25544, \"stations\")</code></li> </ol> <p>This pattern uses cached data and avoids redundant downloads.</p>"},{"location":"learn/datasets/celestrak.html#converting-to-propagators","title":"Converting to Propagators","text":"<p>For most applications, you'll want to convert TLEs directly to SGP propagators. Brahe provides convenience functions that do this in one step:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get ISS as a propagator with 60-second step size\n# The group hint (\"stations\") uses cached data for efficiency\niss_prop = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"stations\")\n\nprint(f\"Created propagator: {iss_prop.get_name()}\")\nprint(f\"Epoch: {iss_prop.epoch}\")\n\n# Propagate forward 1 orbit period (~93 minutes for ISS)\niss_prop.propagate_to(iss_prop.epoch + bh.orbital_period(iss_prop.semi_major_axis))\nstate = iss_prop.current_state()\n\nprint(\"\\nState after 1 orbit:\")\nprint(f\"  Position: [{state[0]:.1f}, {state[1]:.1f}, {state[2]:.1f}] m\")\nprint(f\"  Velocity: [{state[3]:.1f}, {state[4]:.1f}, {state[5]:.1f}] m/s\")\n\n# Expected output:\n# Created propagator: ISS (ZARYA)\n# Epoch: 2025-11-02 10:09:34.283 UTC\n\n# State after 1 orbit:\n#   Position: [6451630.2, -2126316.1, 34427.2] m\n#   Velocity: [2019.6, 5281.4, 6006.2] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::OrbitPropagator;\nuse bh::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get ISS as a propagator with 60-second step size\n    // The group hint (\"stations\") uses cached data for efficiency\n    let mut iss_prop = bh::datasets::celestrak::get_tle_by_id_as_propagator(\n        25544,\n        Some(\"stations\"),\n        60.0,\n    )\n    .unwrap();\n\n    println!(\"Created propagator: {}\", iss_prop.get_name().unwrap_or(\"Unknown\"));\n    println!(\"Epoch: {}\", iss_prop.epoch);\n\n    // Propagate forward 1 orbit period (~93 minutes for ISS)\n    iss_prop.propagate_to(iss_prop.epoch + bh::orbital_period(iss_prop.semi_major_axis()));\n    let state = iss_prop.current_state();\n\n    println!(\"\\nState after 1 orbit:\");\n    println!(\n        \"  Position: [{:.1}, {:.1}, {:.1}] m\",\n        state[0], state[1], state[2]\n    );\n    println!(\n        \"  Velocity: [{:.1}, {:.1}, {:.1}] m/s\",\n        state[3], state[4], state[5]\n    );\n\n    // Expected output:\n    // Created propagator: ISS (ZARYA)\n    // Epoch: 2025-11-02 10:09:34.283 UTC\n\n    // State after 1 orbit:\n    //   Position: [6451630.2, -2126316.1, 34427.2] m\n    //   Velocity: [2019.6, 5281.4, 6006.2] m/s\n}\n</code></pre>"},{"location":"learn/datasets/celestrak.html#getting-by-name","title":"Getting by Name","text":"<p>You can also search for satellites by name. This performs a cascading search across groups:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Search by name (checks common groups automatically)\niss_name, iss_line1, iss_line2 = bh.datasets.celestrak.get_tle_by_name(\"ISS\")\n\nprint(\"Search without group hint:\")\nprint(f\"  Found: {iss_name}\")\nprint(f\"  Line 1: {iss_line1}\")\nprint(f\"  Line 2: {iss_line2}\")\n\n# Or provide a group hint for faster lookup\niss_name2, iss_line2_1, iss_line2_2 = bh.datasets.celestrak.get_tle_by_name(\n    \"ISS\", \"stations\"\n)\n\nprint(\"\\nSearch with group hint:\")\nprint(f\"  Found: {iss_name2}\")\nprint(f\"  Line 1: {iss_line2_1}\")\nprint(f\"  Line 2: {iss_line2_2}\")\n\n# Expected output:\n# Search without group hint:\n#   Found: ISS (ZARYA)\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# Search with group hint:\n#   Found: ISS (ZARYA)\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Search by name (checks common groups automatically)\n    let (iss_name, iss_line1, iss_line2) =\n        bh::datasets::celestrak::get_tle_by_name(\"ISS\", None).unwrap();\n\n    println!(\"Search without group hint:\");\n    println!(\"  Found: {}\", iss_name);\n    println!(\"  Line 1: {}\", &amp;iss_line1);\n    println!(\"  Line 2: {}\", &amp;iss_line2);\n\n    // Or provide a group hint for faster lookup\n    let (iss_name2, iss_line2_1, iss_line2_2) =\n        bh::datasets::celestrak::get_tle_by_name(\"ISS\", Some(\"stations\")).unwrap();\n\n    println!(\"\\nSearch with group hint:\");\n    println!(\"  Found: {}\", iss_name2);\n    println!(\"  Line 1: {}\", &amp;iss_line2_1);\n    println!(\"  Line 2: {}\", &amp;iss_line2_2);\n\n    // Expected output:\n    // Search without group hint:\n    //   Found: ISS (ZARYA)\n    //   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n    //   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n    // Search with group hint:\n    //   Found: ISS (ZARYA)\n    //   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n    //   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n}\n</code></pre> <p>Name Matching</p> <p>Name searches are case-insensitive and support partial matches. If multiple satellites match, the function returns the first match. </p>"},{"location":"learn/datasets/celestrak.html#satellite-groups","title":"Satellite Groups","text":"<p>CelesTrak organizes satellites into logical groups accessible via simple names. These groups are updated as active constellations evolve. It is best to download TLEs by group name rather than ID to minimize the number of distinct requests.</p>"},{"location":"learn/datasets/celestrak.html#temporal-groups","title":"Temporal Groups","text":"Group Description <code>active</code> All active satellites <code>last-30-days</code> Recently launched satellites <code>tle-new</code> Newly added TLEs (last 15 days)"},{"location":"learn/datasets/celestrak.html#communications","title":"Communications","text":"Group Description <code>starlink</code> SpaceX Starlink constellation <code>oneweb</code> OneWeb constellation <code>kuiper</code> Amazon Kuiper constellation <code>intelsat</code> Intelsat satellites <code>eutelsat</code> Eutelsat constellation <code>orbcomm</code> ORBCOMM constellation <code>telesat</code> Telesat constellation <code>globalstar</code> Globalstar constellation <code>iridium-NEXT</code> Iridium constellation <code>qianfan</code> Qianfan constellation <code>hulianwang</code> Hulianwang Digui constellation"},{"location":"learn/datasets/celestrak.html#earth-observation","title":"Earth Observation","text":"Group Description <code>weather</code> Weather satellites (NOAA, GOES, Metop, etc.) <code>earth-resources</code> Earth observation (Landsat, Sentinel, etc.) <code>planet</code> Planet Labs imaging satellites <code>spire</code> Spire Global satellites"},{"location":"learn/datasets/celestrak.html#navigation","title":"Navigation","text":"Group Description <code>gnss</code> All navigation satellites (GPS, GLONASS, Galileo, BeiDou, QZSS, IRNSS) <code>gps-ops</code> Operational GPS satellites only <code>glonass-ops</code> Operational GLONASS satellites only <code>galileo</code> European Galileo constellation <code>beidou</code> Chinese BeiDou/COMPASS constellation <code>sbas</code> Satellite-Based Augmentation System (WAAS/EGNOS/MSAS)"},{"location":"learn/datasets/celestrak.html#scientific-and-special-purpose","title":"Scientific and Special Purpose","text":"Group Description <code>science</code> Scientific research satellites <code>noaa</code> NOAA satellites <code>stations</code> Space stations (ISS, Tiangong) <code>analyst</code> Analyst satellites (tracking placeholder IDs) <code>visual</code> 100 (or so) brightest objects <code>gpz</code> Geostationary Protected Zone <code>gpz-plus</code> Geostationary Protected Zone Plus <p>Note: Group names and contents evolve as missions launch, deorbit, or change status. Visit CelesTrak GP Element Sets for the current complete list.</p>"},{"location":"learn/datasets/celestrak.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding satellite ephemeris datasets</li> <li>Two-Line Elements - TLE and 3LE format details</li> <li>Downloading TLE Data - Practical examples</li> <li>CelesTrak API Reference - Function documentation</li> </ul>"},{"location":"learn/datasets/groundstations.html","title":"Groundstation Datasets","text":""},{"location":"learn/datasets/groundstations.html#overview","title":"Overview","text":"<p>Groundstation datasets provide geographic locations and metadata for commercial satellite ground facilities worldwide. This data is essential for:</p> <ul> <li>Computing contact opportunities: Determine when satellites are visible from ground stations</li> <li>Network planning: Analyze coverage and redundancy across multiple providers</li> <li>Mission design: Evaluate downlink opportunities for different orbit configurations</li> </ul> <p>Brahe includes embedded GeoJSON data for 6 major commercial groundstation providers, totaling 50+ facilities globally. All data is:</p> <ul> <li>Offline-capable: No network requests required</li> <li>Comprehensive: Global coverage across multiple providers</li> <li>Standardized: Consistent format with geographic coordinates and metadata</li> <li>Up-to-date: Maintained as provider networks evolve</li> </ul>"},{"location":"learn/datasets/groundstations.html#when-to-use","title":"When to Use","text":"<p>Use groundstation datasets when you need to:</p> <ul> <li>Compute visibility windows for satellite-to-ground contacts</li> <li>Plan downlink schedules for data collection</li> <li>Analyze network coverage and redundancy</li> <li>Compare provider capabilities across different locations</li> </ul>"},{"location":"learn/datasets/groundstations.html#available-providers","title":"Available Providers","text":"<p>Brahe includes groundstation data from six major commercial providers:</p> Provider Description Atlas Atlas Space Operations AWS Amazon Web Services Ground Station KSAT Kongsberg Satellite Services Leaf Leaf Space SSC Swedish Space Corporation Viasat Viasat"},{"location":"learn/datasets/groundstations.html#usage","title":"Usage","text":""},{"location":"learn/datasets/groundstations.html#loading-groundstations","title":"Loading Groundstations","text":"<p>Load groundstation data from one or more providers:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load groundstations from a single provider\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"KSAT stations: {len(ksat_stations)}\")\n\n# Load all available providers at once\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Total stations (all providers): {len(all_stations)}\")\n\n# List available providers\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"\\nAvailable providers: {', '.join(providers)}\")\n\n# Load multiple specific providers\naws_stations = bh.datasets.groundstations.load(\"aws\")\nssc_stations = bh.datasets.groundstations.load(\"ssc\")\ncombined = aws_stations + ssc_stations\nprint(f\"\\nCombined AWS + SSC: {len(combined)} stations\")\n\n# Expected output:\n# KSAT stations: 36\n# Total stations (all providers): 96\n\n# Available providers: atlas, aws, ksat, leaf, ssc, viasat\n\n# Combined AWS + SSC: 22 stations\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load groundstations from a single provider\n    let ksat_stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n    println!(\"KSAT stations: {}\", ksat_stations.len());\n\n    // Load all available providers at once\n    let all_stations = bh::datasets::groundstations::load_all_groundstations().unwrap();\n    println!(\"Total stations (all providers): {}\", all_stations.len());\n\n    // List available providers\n    let providers = bh::datasets::groundstations::list_providers();\n    println!(\"\\nAvailable providers: {}\", providers.join(\", \"));\n\n    // Load multiple specific providers\n    let aws_stations = bh::datasets::groundstations::load_groundstations(\"aws\").unwrap();\n    let ssc_stations = bh::datasets::groundstations::load_groundstations(\"ssc\").unwrap();\n    let combined: Vec&lt;_&gt; = aws_stations\n        .iter()\n        .chain(ssc_stations.iter())\n        .cloned()\n        .collect();\n    println!(\"\\nCombined AWS + SSC: {} stations\", combined.len());\n\n    // Expected output:\n    // KSAT stations: 36\n    // Total stations (all providers): 96\n\n    // Available providers: atlas, aws, ksat, leaf, ssc, viasat\n\n    // Combined AWS + SSC: 22 stations\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#accessing-properties","title":"Accessing Properties","text":"<p>Each groundstation includes geographic coordinates and metadata:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load KSAT groundstations\nstations = bh.datasets.groundstations.load(\"ksat\")\n\n# Access the first station\nstation = stations[0]\n\n# Geographic coordinates (degrees and meters)\nname = station.get_name() if station.get_name() else \"Unknown\"\nprint(f\"Station: {name}\")\nprint(f\"Latitude: {station.lat:.4f}\u00b0\")\nprint(f\"Longitude: {station.lon:.4f}\u00b0\")\nprint(f\"Altitude: {station.alt:.1f} m\")\n\n# Access metadata properties\nprops = station.properties\nprint(f\"\\nProvider: {props['provider']}\")\nprint(f\"Frequency bands: {', '.join(props['frequency_bands'])}\")\n\n# Show all stations with their locations\nprint(f\"\\n{len(stations)} KSAT Stations:\")\nfor i, gs in enumerate(stations, 1):\n    gs_name = gs.get_name() if gs.get_name() else \"Unknown\"\n    print(f\"{i:2d}. {gs_name:30s} ({gs.lat:7.3f}\u00b0, {gs.lon:8.3f}\u00b0)\")\n\n# Expected output:\n# Station: Prudhoe Bay\n# Latitude: 70.2000\u00b0\n# Longitude: -148.4700\u00b0\n# Altitude: 0.0 m\n\n# Provider: KSAT\n# Frequency bands: S, X\n\n# 36 KSAT Stations:\n#  1. Prudhoe Bay                    ( 70.200\u00b0, -148.470\u00b0)\n#  2. Athens                         ( 37.850\u00b0,   22.620\u00b0)\n#  3. Awarua                         (-46.530\u00b0,  168.380\u00b0)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load KSAT groundstations\n    let stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n\n    // Access the first station\n    let station = &amp;stations[0];\n\n    // Geographic coordinates (degrees and meters)\n    let name = station.get_name().unwrap_or(\"Unknown\");\n    println!(\"Station: {}\", name);\n    println!(\"Latitude: {:.4}\u00b0\", station.lat());\n    println!(\"Longitude: {:.4}\u00b0\", station.lon());\n    println!(\"Altitude: {:.1} m\", station.alt());\n\n    // Show all stations with their locations\n    println!(\"\\n{} KSAT Stations:\", stations.len());\n    for (i, gs) in stations.iter().enumerate() {\n        let gs_name = gs.get_name().unwrap_or(\"Unknown\");\n        println!(\n            \"{:2}. {:30} ({:7.3}\u00b0, {:8.3}\u00b0)\",\n            i + 1,\n            gs_name,\n            gs.lat(),\n            gs.lon()\n        );\n    }\n\n    // Expected output:\n    // Station: Prudhoe Bay\n    // Latitude: 70.2000\u00b0\n    // Longitude: -148.4700\u00b0\n    // Altitude: 0.0 m\n\n    // 36 KSAT Stations:\n    //  1. Prudhoe Bay                    ( 70.200\u00b0, -148.470\u00b0)\n    //  2. Athens                         ( 37.850\u00b0,   22.620\u00b0)\n    //  3. Awarua                         (-46.530\u00b0,  168.380\u00b0)\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#computing-access-windows","title":"Computing Access Windows","text":"<p>Use groundstation data with brahe's access computation to find contact opportunities:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load groundstations from a provider\nstations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"Computing access for {len(stations)} KSAT stations\")\n\n# Create a sun-synchronous orbit satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"EO-Sat\")\n\n# Define access constraint (minimum 5\u00b0 elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\n\n# Compute access windows for 24 hours\nduration = 24.0 * 3600.0  # seconds\nwindows = bh.location_accesses(\n    stations, [propagator], epoch, epoch + duration, constraint\n)\n\n# Display results\nprint(f\"\\nTotal access windows: {len(windows)}\")\nprint(\"\\nFirst 5 windows:\")\nfor i, window in enumerate(windows[:5], 1):\n    duration_min = (window.end - window.start) / 60.0\n    print(f\"{i}. {window.location_name:20s} -&gt; {window.satellite_name:10s}\")\n    print(f\"   Start: {window.start}\")\n    print(f\"   Duration: {duration_min:.1f} minutes\")\n\n# Expected output:\n# Computing access for 36 KSAT stations\n\n# Total access windows: 213\n\n# First 5 windows:\n# 1. Long Beach           -&gt; EO-Sat\n#    Start: 2024-01-01 00:05:08.313 UTC\n#    Duration: 8.9 minutes\n# 2. Thomaston            -&gt; EO-Sat\n#    Start: 2024-01-01 00:07:15.029 UTC\n#    Duration: 1.7 minutes\n# 3. Inuvik               -&gt; EO-Sat\n#    Start: 2024-01-01 00:13:53.159 UTC\n#    Duration: 10.1 minutes\n# 4. Fairbanks            -&gt; EO-Sat\n#    Start: 2024-01-01 00:14:39.836 UTC\n#    Duration: 8.3 minutes\n# 5. Prudhoe Bay          -&gt; EO-Sat\n#    Start: 2024-01-01 00:15:18.853 UTC\n#    Duration: 9.7 minutes\n</code></pre> <pre><code>use brahe as bh;\nuse bh::access::location_accesses;\nuse bh::utils::Identifiable;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load groundstations from a provider\n    let stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n    println!(\"Computing access for {} KSAT stations\", stations.len());\n\n    // Create a sun-synchronous orbit satellite\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 600e3,\n        0.001,\n        97.8_f64.to_radians(),\n        0.0,\n        0.0,\n        0.0,\n    );\n    let state = bh::state_osculating_to_cartesian(oe, bh::AngleFormat::Radians);\n    let propagator =\n        bh::KeplerianPropagator::from_eci(epoch, state, 60.0).with_name(\"EO-Sat\");\n\n    // Define access constraint (minimum 5\u00b0 elevation)\n    let constraint = bh::ElevationConstraint::new(Some(5.0), None).unwrap();\n\n    // Compute access windows for 24 hours\n    let duration = 24.0 * 3600.0; // seconds\n    let windows = location_accesses(\n        &amp;stations,\n        &amp;vec![propagator],\n        epoch,\n        epoch + duration,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    ).unwrap();\n\n    // Display results\n    println!(\"\\nTotal access windows: {}\", windows.len());\n    println!(\"\\nFirst 5 windows:\");\n    for (i, window) in windows.iter().take(5).enumerate() {\n        let duration_min = (window.end() - window.start()) / 60.0;\n        let loc_name = window.location_name.as_deref().unwrap_or(\"Unknown\");\n        let sat_name = window.satellite_name.as_deref().unwrap_or(\"Unknown\");\n        println!(\n            \"{}. {:20} -&gt; {:10}\",\n            i + 1,\n            loc_name,\n            sat_name\n        );\n        println!(\"   Start: {}\", window.start());\n        println!(\"   Duration: {:.1} minutes\", duration_min);\n    }\n\n    // Expected output:\n    // Computing access for 36 KSAT stations\n\n    // Total access windows: 213\n\n    // First 5 windows:\n    // 1. Long Beach           -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:05:08.313 UTC\n    //    Duration: 8.9 minutes\n    // 2. Thomaston            -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:07:15.029 UTC\n    //    Duration: 1.7 minutes\n    // 3. Inuvik               -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:13:53.159 UTC\n    //    Duration: 10.1 minutes\n    // 4. Fairbanks            -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:14:39.836 UTC\n    //    Duration: 8.3 minutes\n    // 5. Prudhoe Bay          -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:15:18.853 UTC\n    //    Duration: 9.7 minutes\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#data-format","title":"Data Format","text":"<p>Each groundstation is represented as a <code>PointLocation</code> with standardized properties:</p> <pre><code>import brahe as bh\n\nstations = bh.datasets.groundstations.load(\"ksat\")\nstation = stations[0]\n\n# Geographic coordinates (WGS84)\nlon = station.lon()      # Longitude in degrees\nlat = station.lat()      # Latitude in degrees\nalt = station.alt()      # Altitude in meters\n\n# Metadata properties\nprops = station.properties\nname = station.get_name()              # Station name\nprovider = props[\"provider\"]            # Provider name (e.g., \"KSAT\")\nbands = props[\"frequency_bands\"]        # Supported bands (e.g., [\"S\", \"X\"])\n</code></pre> <p>All groundstations include these standard properties:</p> <ul> <li><code>provider</code>: Provider name (string, e.g., \"KSAT\", \"Atlas\")</li> <li><code>frequency_bands</code>: List of supported frequency bands (e.g., <code>[\"S\", \"X\", \"Ka\"]</code>)</li> </ul> <p>Additional properties may be included in future releases as data becomes available.</p>"},{"location":"learn/datasets/groundstations.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets in Brahe</li> <li>Groundstation API Reference - Complete function documentation</li> </ul>"},{"location":"learn/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth Orientation Parameters (EOP) are essential corrections that account for irregularities in Earth's rotation. They are required for high-precision transformations between inertial (ECI) and Earth-fixed (ECEF) reference frames.</p>"},{"location":"learn/eop/index.html#overview","title":"Overview","text":"<p>Earth's rotation is not perfectly uniform or predictable due to:</p> <ul> <li>Polar motion: Wobble of Earth's rotation axis relative to its crust</li> <li>UT1-UTC offset: Variations in Earth's rotation rate</li> <li>Nutation: Short-period oscillations in Earth's axis orientation</li> </ul> <p>EOP data provides the corrections needed to accurately transform between coordinate systems, which is critical for:</p> <ul> <li>Satellite orbit determination</li> <li>Ground station tracking</li> <li>Precision timing</li> <li>Navigation and geodesy</li> </ul>"},{"location":"learn/eop/index.html#why-eop-matters","title":"Why EOP Matters","text":""},{"location":"learn/eop/index.html#without-eop","title":"Without EOP","text":"<p>Coordinate transformations using only theoretical models (precession, nutation) can have errors of:</p> <ul> <li>Position errors: 10-30 meters</li> <li>Velocity errors: mm/s level</li> <li>Timing errors: Milliseconds to seconds</li> </ul>"},{"location":"learn/eop/index.html#with-eop","title":"With EOP","text":"<p>Including measured EOP values reduces errors to:</p> <ul> <li>Position errors: &lt; 1 meter</li> <li>Velocity errors: Sub-mm/s</li> <li>Timing accuracy: Sub-millisecond</li> </ul> <p>For most satellite applications, EOP is required for accurate results.</p>"},{"location":"learn/eop/index.html#eop-parameters","title":"EOP Parameters","text":"<p>Brahe uses five primary EOP parameters:</p> Parameter Description Typical Range Units <code>x_p</code> Polar motion X component \u00b10.7 arcsec arcseconds <code>y_p</code> Polar motion Y component \u00b10.7 arcsec arcseconds <code>UT1_UTC</code> UT1 minus UTC time offset \u00b10.9 seconds seconds <code>dX</code> Celestial pole X offset \u00b10.0003 arcsec arcseconds <code>dY</code> Celestial pole Y offset \u00b10.0003 arcsec arcseconds <p>Additionally, derivatives are used for interpolation: - <code>LOD</code>: Length of day variations - Rates of change for <code>x_p</code> and <code>y_p</code></p>"},{"location":"learn/eop/index.html#eop-data-sources","title":"EOP Data Sources","text":"<p>EOP values are measured by the International Earth Rotation and Reference Systems Service (IERS) using:</p> <ul> <li>Very Long Baseline Interferometry (VLBI)</li> <li>Satellite Laser Ranging (SLR)</li> <li>Global Navigation Satellite Systems (GNSS)</li> <li>Doppler Orbitography and Radiopositioning Integrated by Satellite (DORIS)</li> </ul> <p>IERS publishes several data products:</p> <ul> <li>Finals2000A.all: Combined observed + predicted values (recommended)</li> <li>EOP C04: Long-term series with consistent processing</li> <li>Rapid: Near real-time values updated daily</li> <li>Predictions: Future values (lower accuracy)</li> </ul>"},{"location":"learn/eop/index.html#managing-eop-in-brahe","title":"Managing EOP in Brahe","text":"<p>Brahe provides three EOP provider types:</p>"},{"location":"learn/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Loads EOP data from IERS files for production use:</p> <pre><code>import brahe as bh\n\n# Download latest EOP data\nbh.download_iers_eop_data()\n\n# Load from standard location\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# Set as global provider\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: Production applications requiring maximum accuracy.</p>"},{"location":"learn/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Uses built-in historical EOP data or constant values:</p> <pre><code># Use built-in data (covers ~1990-2024)\neop = bh.StaticEOPProvider.from_static_data()\n\n# Or use constant values (for testing)\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: - Testing and development - Historical analysis within built-in data range - Applications where 10-30m accuracy is acceptable</p>"},{"location":"learn/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Wraps another provider with caching for performance:</p> <pre><code># Wrap file provider with cache\nfile_provider = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\ncached_provider = bh.CachingEOPProvider(file_provider, cache_size=1000)\n\nbh.set_global_eop_provider(cached_provider)\n</code></pre> <p>When to use: High-frequency EOP queries at similar epochs (e.g., batch processing).</p> <p>See: Managing EOP Data</p>"},{"location":"learn/eop/index.html#global-eop-provider","title":"Global EOP Provider","text":"<p>Brahe uses a global EOP provider that is accessed automatically during frame transformations:</p> <pre><code># Set global provider (do this once at program start)\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# Frame transformations automatically use global EOP\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)  # Uses global EOP\n</code></pre> <p>Important: The global provider must be set before any frame transformations, or an error will occur.</p>"},{"location":"learn/eop/index.html#workflow","title":"Workflow","text":""},{"location":"learn/eop/index.html#production-application","title":"Production Application","text":"<pre><code>import brahe as bh\n\n# 1. Download latest EOP data (run periodically, e.g., weekly)\nbh.download_iers_eop_data()\n\n# 2. Load EOP provider at program startup\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# 3. Perform frame transformations (EOP used automatically)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n</code></pre>"},{"location":"learn/eop/index.html#testingdevelopment","title":"Testing/Development","text":"<pre><code>import brahe as bh\n\n# Use static EOP for reproducible tests\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider(eop)\n\n# All transformations use zero EOP values\n# Results are deterministic but less accurate\n</code></pre>"},{"location":"learn/eop/index.html#eop-data-management","title":"EOP Data Management","text":""},{"location":"learn/eop/index.html#downloading-updates","title":"Downloading Updates","text":"<p>EOP data should be updated periodically:</p> <pre><code># Download latest data\nbh.download_iers_eop_data()\n\n# Reload provider with new data\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n</code></pre> <p>Update frequency: - Real-time applications: Daily - Planning applications: Weekly - Historical analysis: Not needed (use archived data)</p>"},{"location":"learn/eop/index.html#data-file-location","title":"Data File Location","text":"<p>By default, EOP files are stored in: - Unix/Linux/macOS: <code>~/.brahe/</code> - Windows: <code>C:\\Users\\&lt;username&gt;\\.brahe\\</code></p> <p>Files are cached locally and reused until updated.</p>"},{"location":"learn/eop/index.html#eop-data-coverage","title":"EOP Data Coverage","text":"<p>IERS publishes: - Historical: Observed values from 1973 to ~7 days ago - Recent: Rapid service values (updated daily) - Future: Predictions up to 1 year ahead (less accurate)</p> <p>For dates beyond prediction range, extrapolation is used (accuracy degrades).</p>"},{"location":"learn/eop/index.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/eop/index.html#eop-query-cost","title":"EOP Query Cost","text":"<p>Querying EOP data requires: 1. Date conversion (epoch \u2192 MJD) 2. Table lookup or interpolation 3. Parameter extraction</p> <p>Typical cost: 1-10 microseconds per query</p>"},{"location":"learn/eop/index.html#caching-strategy","title":"Caching Strategy","text":"<p>For repeated transformations at similar epochs:</p> <pre><code># Without caching: ~10 \u03bcs per EOP query\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# With caching: ~0.1 \u03bcs per cached query\ncached_eop = bh.CachingEOPProvider(eop, cache_size=1000)\n</code></pre> <p>Caching provides 100\u00d7 speedup for repeated queries.</p>"},{"location":"learn/eop/index.html#batch-operations","title":"Batch Operations","text":"<p>When transforming many states at the same epoch:</p> <pre><code># Query EOP once, reuse for all transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# EOP queried once internally\nfor state in states:\n    state_ecef = bh.state_eci_to_ecef(state, epoch)  # Reuses cached EOP\n</code></pre>"},{"location":"learn/eop/index.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/eop/index.html#startup-initialization","title":"Startup Initialization","text":"<pre><code>def initialize_eop():\n    \"\"\"Initialize EOP provider at application startup\"\"\"\n    try:\n        # Try to use file-based EOP\n        eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    except Exception:\n        # Fall back to static EOP if file not found\n        print(\"Warning: Using static EOP data (reduced accuracy)\")\n        eop = bh.StaticEOPProvider.from_static_data()\n\n    bh.set_global_eop_provider(eop)\n\n# Call at program start\ninitialize_eop()\n</code></pre>"},{"location":"learn/eop/index.html#periodic-updates","title":"Periodic Updates","text":"<pre><code>import schedule\nimport brahe as bh\n\ndef update_eop_data():\n    \"\"\"Download and reload EOP data\"\"\"\n    bh.download_iers_eop_data()\n    eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    bh.set_global_eop_provider(eop)\n    print(\"EOP data updated\")\n\n# Schedule weekly updates\nschedule.every().monday.at(\"02:00\").do(update_eop_data)\n</code></pre>"},{"location":"learn/eop/index.html#testing-with-controlled-eop","title":"Testing with Controlled EOP","text":"<pre><code>import pytest\nimport brahe as bh\n\n@pytest.fixture(autouse=True)\ndef setup_eop():\n    \"\"\"Setup zero EOP for deterministic tests\"\"\"\n    eop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    bh.set_global_eop_provider(eop)\n    yield\n    # Cleanup if needed\n\ndef test_frame_transformation():\n    # Test uses zero EOP values (deterministic)\n    epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n    state_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n    # Assert expected values...\n</code></pre>"},{"location":"learn/eop/index.html#see-also","title":"See Also","text":"<ul> <li>What is EOP Data? - Detailed explanation of EOP parameters and why they matter</li> <li>Managing EOP Data - Practical guide to EOP providers and data management</li> <li>Frame Transformations - How EOP is used in coordinate transformations</li> <li>EOP API Reference - Complete EOP provider documentation</li> <li>IERS Website - Official source for EOP data</li> </ul>"},{"location":"learn/eop/managing_eop_data.html","title":"Managing EOP Data","text":"<p>Generally, users of brahe will not need to directly manage Earth orientation data. The package provides default data files and the <code>CachingEOPProvider</code> to automatically update data as needed. However, for advanced users or those with specific data requirements, brahe provides functionality to load and manage Earth orientation data manually.</p> <p>To make the package interface ergonommic, brahe functions do not explicitly accept Earth orientation data as input parameters. Instead, there is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions.</p> <p>If you want to skip understanding Earth orientation data for now, you can initialize the global provider with zeroed values using the <code>initialize_eop()</code> function:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n}\n</code></pre> <p>Warning</p> <p>Earth orientation data MUST be initialized before using any functionality in brahe that requires Earth orientation data. If no data is initialized, brahe will panic and terminate the program when Earth orientation data is requested.</p>"},{"location":"learn/eop/managing_eop_data.html#earth-orientation-providers","title":"Earth Orientation Providers","text":"<p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>For the most accurate Earth orientation data modeling in scripts, you should download the latest available Earth orientation data for the desired model and the using the file-based loading methods. Alternatively you can the <code>CachingEOPProvider</code> to initialize the Earth orientation data which will automatically download and update the latest data files as needed.</p>"},{"location":"learn/eop/managing_eop_data.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>A static provider is one that just uses fixed values for Earth orientation parameters. This provider is useful for testing and development or if your application only requires low accuracy.</p> PythonRust <pre><code>import brahe as bh\n\n\n# Method 1: Static EOP Provider - All Zeros\neop_static_zeros = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(eop_static_zeros)\n\n# Method 2: Static EOP Provider - Constant Values\neop_static_values = bh.StaticEOPProvider.from_values(\n    0.001, 0.002, 0.003, 0.004, 0.005, 0.006\n)\nbh.set_global_eop_provider(eop_static_values)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Static EOP Provider - All Zeros\n    let eop_static_zeros = bh::eop::StaticEOPProvider::from_zero();\n    bh::eop::set_global_eop_provider(eop_static_zeros);\n\n    // Method 2: Static EOP Provider - Constant Values\n    let eop_static_values = bh::eop::StaticEOPProvider::from_values((0.001, 0.002, 0.003, 0.004, 0.005, 0.006));\n    bh::eop::set_global_eop_provider(eop_static_values);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#fileeopprovider","title":"FileEOPProvider","text":"<p>If you want to use high-accuracy Earth orientation data, you can load data from IERS files using the <code>FileEOPProvider</code>. Brahe provides functions to load default IERS data files provided with the package, or you can specify your own file paths.</p> <p>When creating any new file-based data provider there are two parameters that are set at loading time which will determine how the EOP instances handles data returns for times not in the loaded data.</p> <p>The first parameter is the <code>interpolate</code> setting. When <code>interpolate</code> is set to <code>True</code> and data set will be linearly interpolated to the desired time. When set to <code>False</code>, the function call will return the last value prior to the requested data. Given that IERS data is typically provided at daily intervals, it is generally recommended to enable interpolation for most applications.</p> <p>The second parameter is the <code>extrapolate</code> parameter, which can have a value of <code>Zero</code>, <code>Hold</code>, or <code>Error</code>. This value will determine how requests for data points beyond the end of the loaded data are handled. The possible behaviors are</p> <ul> <li><code>Zero</code>: Returned values will be <code>0.0</code> where data is not available</li> <li><code>Hold</code>: Will return the last available returned value when data is not available</li> <li><code>Error</code>: Data access attempts where data is not present will panic and terminate the program</li> </ul> <p>You can create a file-based Earth orientation provider by specifying the file paths to the desired data files as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n# File-based EOP Provider - Default IERS Standard with Hold Extrapolation\neop_file_default = bh.FileEOPProvider.from_default_standard(\n    True,  # Interpolation -&gt; if True times between data points are interpolated\n    \"Hold\",  # Extrapolation method -&gt; How accesses outside data range are handled\n)\nbh.set_global_eop_provider(eop_file_default)\n\n# File-based EOP Provider - Default C04 Standard with Zero Extrapolation\neop_file_c04 = bh.FileEOPProvider.from_default_c04(False, \"Zero\")\nbh.set_global_eop_provider(eop_file_c04)\n\n# Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\nif False:  # Change to True to enable custom file examples\n    # File-based EOP Provider - Custom Standard File\n    eop_file_custom = bh.FileEOPProvider.from_standard_file(\n        \"path_to_standard_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom)\n\n    # File-based EOP Provider - Custom C04 File\n    eop_file_custom_c04 = bh.FileEOPProvider.from_c04_file(\n        \"path_to_c04_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom_c04)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n    // File-based EOP Provider - Default IERS Standard with Hold Extrapolation\n    let eop_file_default = bh::eop::FileEOPProvider::from_default_standard(\n        true,                                   // Interpolation -&gt; if True times between data points are interpolated\n        bh::eop::EOPExtrapolation::Hold        // Extrapolation method -&gt; How accesses outside data range are handled\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_default);\n\n    // File-based EOP Provider - Default C04 Standard with Zero Extrapolation\n    let eop_file_c04 = bh::eop::FileEOPProvider::from_default_c04(\n        false,\n        bh::eop::EOPExtrapolation::Zero\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_c04);\n\n    // Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\n    if false {  // Change to true to enable custom file examples\n        // File-based EOP Provider - Custom Standard File\n        let eop_file_custom = bh::eop::FileEOPProvider::from_standard_file(\n            std::path::Path::new(\"path_to_standard_file.txt\"),  // Replace with actual file path\n            true,                                                 // Interpolation\n            bh::eop::EOPExtrapolation::Hold                      // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom);\n\n        // File-based EOP Provider - Custom C04 File\n        let eop_file_custom_c04 = bh::eop::FileEOPProvider::from_c04_file(\n            std::path::Path::new(\"path_to_c04_file.txt\"),  // Replace with actual file path\n            true,                                           // Interpolation\n            bh::eop::EOPExtrapolation::Hold                // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom_c04);\n    }\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>The <code>CachingEOPProvider</code> is a <code>FileEOPProvider</code> that automatically downloads and caches the latest Earth orientation data files from the IERS website as needed. It checks the age of the cached data and if the data is older than a specified threshold, it downloads the latest files, then loads them for use. This provider can also be configured to check for a stale cache on use and update the data if needed, which is useful for long-running applications.</p> <p>The <code>CachingEOPProvider</code> is the recommended provider for most applications as it provides high-accuracy Earth orientation data without requiring manual management of data files. <code>initialize_eop()</code> uses this provider by default.</p> <p>The interpolation and extrapolation parameters are also available when creating a <code>CachingEOPProvider</code>, with the same behavior as described for the <code>FileEOPProvider</code>.</p> PythonRust <pre><code>from pathlib import Path\nimport brahe as bh\n\n# Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider)\n\n# Method 2: Initialize from Caching EOP Provider with custom location\nprovider_custom = bh.CachingEOPProvider(\n    filepath=str(\n        Path(bh.get_brahe_cache_dir()) / \"my_eop.txt\"\n    ),  # Replace with desired file path to load / save from\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider_custom)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\n    let provider = bh::eop::CachingEOPProvider::new(\n        None,                                   // filepath (None for default cache location)\n        bh::eop::EOPType::StandardBulletinA,   // eop_type\n        7 * 86400,                             // max_age_seconds - Maximum age of file before refreshing\n        false,                                 // auto_refresh - Check staleness of every access\n        true,                                  // interpolate\n        bh::eop::EOPExtrapolation::Hold       // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider);\n\n    // Method 2: Initialize from Caching EOP Provider with custom location\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    let custom_filepath = std::path::Path::new(&amp;cache_dir).join(\"my_eop.txt\");\n    let provider_custom = bh::eop::CachingEOPProvider::new(\n        Some(&amp;custom_filepath),                        // Replace with desired file path to load / save from\n        bh::eop::EOPType::StandardBulletinA,           // eop_type\n        7 * 86400,                                     // max_age_seconds - Maximum age of file before refreshing\n        false,                                         // auto_refresh - Check staleness of every access\n        true,                                          // interpolate\n        bh::eop::EOPExtrapolation::Hold               // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider_custom);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#downloading-eop-data-files","title":"Downloading EOP Data Files","text":"<p>If you want to manually download Earth orientation data files to store or save them, brahe provides two means of doing so. The first is through the command-line interface (CLI) tool included with brahe. The second is through direct function calls in either the Rust or Python APIs.</p>"},{"location":"learn/eop/managing_eop_data.html#cli","title":"CLI","text":"<p>The brahe CLI command includes an <code>eop download</code> subcommand which can be used to download the latest Earth orientation data files from IERS servers.</p> <p>To download the latest standard product file, use the following command:</p> <pre><code>brahe eop download --product standard &lt;output_filepath&gt;\n</code></pre> <p>To download the latest C04 final product file, use the following command:</p> <pre><code>brahe eop download --product c04 &lt;output_filepath&gt;\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#functions","title":"Functions","text":"<p>You can also download Earth orientation data files directly using the <code>download_standard_eop_file</code> and <code>download_c04_eop_file</code> functions in the <code>brahe.eop</code> module.</p> <p>You can download the latest standard EOP data file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre> <pre><code>use brahe::eop::download_standard_eop_file;\n\n// Download latest C04 EOP data\ndownload_standard_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <p>Or download the latest C04 final product file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <pre><code>use brahe::eop::download_c04_eop_file;\n\n// Download latest C04 EOP data\ndownload_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#accessing-eop-parameters","title":"Accessing EOP Parameters","text":"<p>While not common it is possible to directly access Earth orientation parameters from the currently loaded global Earth orientation provider. This can be useful for debugging or analysis purposes.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Get current time\nepc = bh.Epoch.now()\n\nxp, yp, dut1, lod, dX, dY = bh.get_global_eop(epc.mjd())\n\nprint(f\"At epoch {epc}:\")\nprint(f\"  x_pole: {xp} arcseconds\")\nprint(f\"  y_pole: {yp} arcseconds\")\nprint(f\"  dut1: {dut1} seconds\")\nprint(f\"  length of day: {lod} seconds\")\nprint(f\"  dX: {dX} arcseconds\")\nprint(f\"  dY: {dY} arcseconds\")\n</code></pre> <pre><code>#[allow(unused_imports)]\nuse brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epc = bh::Epoch::now();\n    let (xp, yp, dut1, lod, dx, dy) = bh::get_global_eop(epc.mjd()).unwrap();\n\n    println!(\"At epoch {}:\", epc.to_string());\n    println!(\"xp:  {}\", xp);\n    println!(\"yp:  {}\", yp);\n    println!(\"dut1: {}\", dut1);\n    println!(\"lod:  {}\", lod);\n    println!(\"dX:   {}\", dx);\n    println!(\"dY:   {}\", dy);\n}\n</code></pre> <p>You can find more functions to access specific subsets of Earth orientation data in the API Reference.</p>"},{"location":"learn/eop/managing_eop_data.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider API Reference</li> <li>FileEOPProvider API Reference</li> <li>CachingEOPProvider API Reference</li> </ul>"},{"location":"learn/eop/what_is_eop_data.html","title":"What is EOP Data?","text":"<p>Earth Orientation Parameters are empirically observed, estimated parameters that describe the irregularities in Earth's rotation in space. When combined with their specific related models they provide the mechanism to transform between an Earth-Centered Earth-Fixed (ECEF) reference frame and an Earth-Centered Inertial (ECI) reference frame. These transformations are essential for accurate orbit propagation, coordinate transformations, and other space-related applications.</p> <p>Earth Orientation Parameters are stochastic meaning that they are random and cannot be predicted with perfect accuracy into the future. Therefore, Earth orientation data is continually observed, estimated, and updated by various international organizations. The International Earth Rotation and Reference Systems Service (IERS) is the primary organization responsible for providing Earth orientation data products and maintaining the associated reference frames and systems.</p> <p>For example the predicted evolution of the offset between solar time (UT1) and Coordinated Universal Time (UTC) is show below. The difference between UT1 and UTC is primarily driven by variations in Earth's rotation rate, which are influenced by factors such as tidal forces, atmospheric dynamics, and core-mantle interactions. As a result, the UT1-UTC offset exhibits irregular fluctuations that cannot be precisely predicted far into the future.</p> Plot Source fig_ut1_utc_offset.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# ------------------------------\n# Configuration\n# ------------------------------\n\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# ------------------------------\n\n# Initialize IERS EOP Data\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(eop)\n\n## Generate plot data\n\n# Get range of dates stored in EOP data\nmjd_min = bh.get_global_eop_mjd_min()\nmjd_max = bh.get_global_eop_mjd_max()\nmjd_now = bh.Epoch.now().mjd()\n\nprint(\"EOP MJD Range:\", mjd_min, \"to\", mjd_max)\nprint(\"Current MJD (now):\", mjd_now)\n\n# Split data into past (solid) and predicted (dashed)\ndays_past = np.arange(mjd_min, min(mjd_now, mjd_max), 1)\ndays_predicted = np.arange(max(mjd_now, mjd_min), mjd_max, 1)\n\n# Get UT1-UTC offsets\nut1_utc_past = [bh.get_global_ut1_utc(mjd) for mjd in days_past]\nut1_utc_predicted = [bh.get_global_ut1_utc(mjd) for mjd in days_predicted]\n\n# Get year range for x-axis tick labels\nepoch_min = bh.Epoch.from_mjd(mjd_min, bh.TimeSystem.UTC)\nepoch_max = bh.Epoch.from_mjd(mjd_max, bh.TimeSystem.UTC)\nyear_min = epoch_min.to_datetime()[0]\nyear_max = epoch_max.to_datetime()[0]\n\n\n## Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Plot past data (solid line) - use primary color\n    fig.add_trace(\n        go.Scatter(\n            x=days_past,\n            y=ut1_utc_past,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n            name=\"Past (Measured)\",\n            showlegend=True,\n        )\n    )\n\n    # Plot predicted data (dashed line) - use error color\n    fig.add_trace(\n        go.Scatter(\n            x=days_predicted,\n            y=ut1_utc_predicted,\n            mode=\"lines\",\n            line=dict(color=colors[\"error\"], width=2, dash=\"dash\"),\n            name=\"Future (Predicted)\",\n            showlegend=True,\n        )\n    )\n\n    # Create custom tick values and labels for x-axis (years)\n    # Generate tick positions every 5 years\n    tick_mjds = []\n    tick_labels = []\n    for year in range(year_min, year_max + 1, 5):\n        epoch = bh.Epoch.from_datetime(year, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n        tick_mjds.append(epoch.mjd())\n        tick_labels.append(str(year))\n\n    # Configure axes (theme-agnostic settings)\n    fig.update_xaxes(\n        tickmode=\"array\",\n        tickvals=tick_mjds,\n        ticktext=tick_labels,\n        title_text=\"Year\",\n        range=[mjd_min, mjd_max],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"array\",\n        tickvals=[-1.0, -0.5, 0.0, 0.5, 1.0],\n        title_text=\"UT1-UTC Offset Magnitude [s]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/eop/what_is_eop_data.html#iers","title":"IERS","text":"<p>The International Earth Rotation Service (IERS) was established in 1987 by the International Astronomical Union and the International Union of Geodesy and Geophysics. The IERS provides data on Earth orientation, on the International Celestial Reference System/Frame, and on the International Terrestrial Reference System/Frame. The IERS also maintains conventions containing models, constants, and standards used for modeling Earth orientation.</p> <p>The IERS deals with reference systems and reference frames. A reference system is an idealized mathematical concept for defining a reference used to represent the state of objects in that system. The two primary reference systems developed by the IERS are the International Celestial Reference System (ICRS) and International Terrestrial Reference System (ITRS). The ICRS is an inertial reference system and the one we used to define Earth-centered inertial (ECI) reference frames in brahe. The ITRS is a rotating reference system fixed to the Earth and is used to define Earth-centered, Earth-fixed (ECEF*) reference frames in the packge.</p> <p>A reference system is a concept and cannot be used directly. For example you can say that you'll represent all coordinates in the world with respect to the the North Star, but to actually use that reference you need to define how to measure positions with respect to it. Therefore the IERS develops reference frames, which are specific realizations of a given reference system. A reference frame realization defines the models, standards, and associated data products for users to actually interact and usethat reference system. The primary reference frames of the IERS are the International Celestial Reference Frame (ICRF) and International Terrestrial Reference Frame (ITRF).</p> <p>The ICRS and ITRS models are defined with respect to the solar system barycenter<sup>1</sup>. However, for many satellite-specific engineering applications we are primarily concerned with geocentric references, centered at Earth. Therefore, brahe primarily deals with the Geocentric Celestial Reference Frame (GCRF) and Geocentric Terrestrial Reference Frame (GTRF). For most intents and purposes the international and geocentric references are identical as there is no rotation component between ICRS and GCRS (or ITRF and GCRF)<sup>2</sup>. The transformation between the two reference systems and frames is simply a pure translation.</p> <p>For a more detailed discussion of reference frames and systems please read IERS Technical Note 36 provides an in-depth discussion of the concepts presented and discussed here.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-products","title":"Earth Orientation Products","text":"<p>The IERS provides various Earth orientation products which are derived from Very Long Baseline Interferometry (VLBI) or a network of terrestrial GPS<sup>3</sup>  reference stations. The continual observations made by these stations are  combined with specific reference frame realizations (e.g. the IAU 2010  conventions) to model Earth orientation and enable the transformation between  inertial and Earth-fixed reference frames.</p> <p>The Earth orientation parameter products come in multiple variations, all of which can be found at the IERS data products site. These variations arise from the selection of precession-nutation model, ITRF realization, the data sources, and data processing time span. There are two precession-nutation models widely in use today: IAU 1980 nutation theory andthe IAU2006/2000A precession-nutation model. The ITRF 2014 realization is the most recent realization and preferred in most cases.</p> <p>For data products there are two primary distinctions: standard products and long term products. Standard products, which are produced daily, to provide a daily estimate of the past Earth orientation along with forward-looking predictions available for use in planning. Long term data products are only available for past days, and are produced less frequently, but provider higher accurate estimates of Earth orientation. </p> <p>For most purposes the standard products provide sufficient accuracy along with the benefit of having fairly accurate forward-looking predictions. Therefore, brahe defaults to using standard Earth Orientation data products wherever possible. Unless otherwise stated or specified, brahe uses IERS standard product generated with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-parameters","title":"Earth Orientation Parameters","text":"<p>The primary Earth orientation parameters provided by the IERS are polar motion coefficients (\\(x_p\\), \\(y_p\\)), UTC-UT1 time system offset (\\(\\Delta_{UTC}\\)), celestial pole offsets (\\(dX\\), \\(dY\\)), and length of day (\\(LOD\\)) corrections. These parameters are used in combination with specific models to compute the transformation between ECEF and ECI reference frames.</p> <p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>There is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions. See the Managing EOP Data page for more information on loading and managing Earth orientation data in brahe.</p> <ol> <li> <p>A barycenter is the center of mass of two or more bodies. The solar  system barycenter is the center of mass of the entire solar system. Due to  significant mass contributions and distances of Jupiter and Saturn, the  solar system barycenter evolves in time and is sometimes outside of the  Sun's outer radius.\u00a0\u21a9</p> </li> <li> <p>For applications requiring the highest levels of fidelity, the  equations of motion of an Earth satellite, with respect to the  GCRS will contain a relativistic Coriolis force due to geodesic precession  not present in the ICRS.\u00a0\u21a9</p> </li> <li> <p>Now frequently GNSS receivers\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/orbit_propagation/index.html","title":"Orbit Propagation","text":"<p>Orbit propagation is the process of computing a satellite's trajectory over time from an initial state. Brahe's propagation system is built on a set of Rust traits that define common functionality. This design allows for common usage patterns making it easy to switch between different propagator implementations.</p> <p>All propagators in Brahe implement the <code>OrbitPropagator</code> trait, which provides methods for stepping through time, managing trajectory history, and accessing the current state. All propagators store their state history in an <code>OrbitTrajectory</code>, which implements the <code>Trajectory</code> and <code>Interpolatable</code> traits for state storage and interpolation. See the Trajectory documentation for more details on these traits and the methods they provide.</p> <p>There is also the <code>StateProvider</code> trait, which extends propagators with the ability to compute states directly at arbitrary epochs. How this is implemented depends on the specific propagator. Analytic propagators like <code>KeplerianPropagator</code> and <code>SGPPropagator</code> can compute states at any time using closed-form solutions, while numerical propagators typically require time-stepping to the desired epoch, then interpolating the result.</p> <p>The <code>IdentifiableStateProvider</code> trait combines <code>StateProvider</code> with <code>Identifiable</code>, enabling identification of Propagators by name, ID, or UUID. This is useful for tracking multiple satellites in applications like ground station access computation or conjunction analysis.</p>"},{"location":"learn/orbit_propagation/index.html#orbitpropagator-trait","title":"OrbitPropagator Trait","text":"<p>The <code>OrbitPropagator</code> trait is the foundation for all propagator implementations. It defines the core interface for stepping through time, managing state, and controlling trajectory accumulation.</p> <p>Stepping Operations:</p> <ul> <li><code>step()</code> - Advance by the default step size</li> <li><code>step_by(step_size)</code> - Advance by a specified duration (seconds)</li> <li><code>step_past(target_epoch)</code> - Step until the given Epoch is passed</li> <li><code>propagate_steps(n)</code> - Take N steps of default step size</li> <li><code>propagate_to(target_epoch)</code> - Propagate precisely to a target epoch</li> </ul> <p>State Access:</p> <ul> <li><code>current_epoch()</code> - Get the most recent propagated epoch</li> <li><code>current_state()</code> - Get the most recent propagated state</li> <li><code>initial_epoch()</code> - Get the initial epoch</li> <li><code>initial_state()</code> - Get the initial state</li> </ul> <p>Configuration:</p> <ul> <li><code>step_size()</code> - Get the default step size (seconds)</li> <li><code>set_step_size(step_size)</code> - Set the default step size (seconds)</li> <li><code>reset()</code> - Reset propagator to initial conditions</li> <li><code>set_initial_conditions(epoch, state, frame, representation, angle_format)</code> - Update initial conditions</li> </ul> <p>Trajectory Management:</p> <ul> <li><code>propagate_trajectory(epochs)</code> - Propagate to multiple epochs with <code>propagate_to()</code> calls for each provided epoch</li> <li><code>set_eviction_policy_max_size(n)</code> - Keep only N most recent states</li> <li><code>set_eviction_policy_max_age(duration)</code> - Keep only states within time window (seconds)</li> </ul>"},{"location":"learn/orbit_propagation/index.html#stateprovider-trait","title":"StateProvider Trait","text":"<p>The <code>StateProvider</code> trait extends propagators with methods to get the state at arbitrary epochs. For analytic propagators, this is done using closed-form solutions which immediately compute the state without time-stepping. Numerical propagators typically step to the desired epoch and interpolate the result. This trait provides both single-epoch and multi-epoch (batch) query methods.</p> <p>Single Epoch Queries:</p> <ul> <li><code>state(epoch)</code> - Get state in propagator's native format</li> <li><code>state_eci(epoch)</code> - Get Cartesian state in ECI frame</li> <li><code>state_ecef(epoch)</code> - Get Cartesian state in ECEF frame</li> <li><code>state_as_osculating_elements(epoch, angle_format)</code> - Get Keplerian elements</li> </ul> <p>Multi-Epoch Queries (Batch Operations):</p> <ul> <li><code>states(epochs)</code> - Get states at multiple epochs in native format</li> <li><code>states_eci(epochs)</code> - Get ECI Cartesian states at multiple epochs</li> <li><code>states_ecef(epochs)</code> - Get ECEF Cartesian states at multiple epochs</li> <li><code>states_as_osculating_elements(epochs, angle_format)</code> - Get Keplerian elements at multiple epochs</li> </ul>"},{"location":"learn/orbit_propagation/index.html#identifiablestateprovider-trait","title":"IdentifiableStateProvider Trait","text":"<p>The <code>IdentifiableStateProvider</code> trait combines <code>StateProvider</code> with <code>Identifiable</code>, identifying propagator objects by name, ID, or UUID. This trait inherits all methods from: - <code>StateProvider</code>: All state query methods - <code>Identifiable</code>: <code>with_name()</code>, <code>with_id()</code>, <code>with_uuid()</code>, <code>get_name()</code>, <code>get_id()</code>, <code>get_uuid()</code></p>"},{"location":"learn/orbit_propagation/index.html#choosing-a-propagator","title":"Choosing a Propagator","text":"<p>Brahe currently provides two propagator implementations: - <code>KeplerianPropagator</code>: An analytic two-body propagator using Keplerian orbital elements. Suitable for high-level mission design and long-term propagation where perturbations are negligible. - <code>SGPPropagator</code>: An analytic propagator based on the SGP4/SDP4 models using TLE data. Suitable for tracking Earth-orbiting satellites with moderate accuracy.</p>"},{"location":"learn/orbit_propagation/index.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Propagation - Analytical two-body propagator</li> <li>SGP Propagation - TLE-based SGP4/SDP4 propagator</li> <li>Trajectories - Trajectory storage and management</li> <li>Frame Transformations - ECI/ECEF conversions</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"learn/orbit_propagation/keplerian_propagation.html","title":"Keplerian Propagation","text":"<p>The <code>KeplerianPropagator</code> provides fast, analytical two-body orbital propagation using Kepler's equations. It assumes only gravitational attraction from a central body (Earth) with no perturbations, making it ideal for rapid trajectory generation, high-altitude orbits, or when perturbations are negligible.</p> <p>For complete API documentation, see the KeplerianPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#initialization","title":"Initialization","text":"<p>The <code>KeplerianPropagator</code> can be initialized from several state representations.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-keplerian-elements","title":"From Keplerian Elements","text":"<p>The most direct initialization method uses classical Keplerian orbital elements.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define Keplerian elements [a, e, i, \u03a9, \u03c9, M]\nelements = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (degrees)\n        15.0,  # RAAN (degrees)\n        30.0,  # Argument of perigee (degrees)\n        45.0,  # Mean anomaly (degrees)\n    ]\n)\n\n# Create propagator with 60-second step size\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\nprint(f\"Orbital period: {bh.orbital_period(elements[0]):.1f} seconds\")\n# Orbital period: 5677.0 seconds\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define Keplerian elements [a, e, i, \u03a9, \u03c9, M]\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (degrees)\n        15.0,                 // RAAN (degrees)\n        30.0,                 // Argument of perigee (degrees)\n        45.0                  // Mean anomaly (degrees)\n    );\n\n    // Create propagator with 60-second step size\n    let _prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    println!(\"Orbital period: {:.1} seconds\", bh::orbital_period(elements[0]));\n    // Orbital period: 5677.0 seconds\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-eci-cartesian-state","title":"From ECI Cartesian State","text":"<p>Initialize from position and velocity vectors in the Earth-Centered Inertial (ECI) frame.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define Cartesian state in ECI frame [x, y, z, vx, vy, vz]\n# Convert from Keplerian elements for this example\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate_eci = bh.state_osculating_to_cartesian(elements, bh.AngleFormat.DEGREES)\n\n# Create propagator from ECI state\nprop = bh.KeplerianPropagator.from_eci(epoch, state_eci, 60.0)\n\nprint(f\"Initial position magnitude: {np.linalg.norm(state_eci[:3]) / 1e3:.1f} km\")\n# Initial position magnitude: 6873.3 km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define Cartesian state in ECI frame [x, y, z, vx, vy, vz]\n    // Convert from Keplerian elements for this example\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let state_eci = bh::state_osculating_to_cartesian(elements, bh::AngleFormat::Degrees);\n\n    // Create propagator from ECI state\n    let _prop = bh::KeplerianPropagator::from_eci(epoch, state_eci, 60.0);\n\n    println!(\"Initial position magnitude: {:.1} km\",\n             state_eci.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // Initial position magnitude: 6873.3 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-ecef-cartesian-state","title":"From ECEF Cartesian State","text":"<p>Initialize from position and velocity vectors in the Earth-Centered Earth-Fixed (ECEF) frame. The propagator will automatically convert to ECI internally.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for ECEF \u2194 ECI transformations\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get state in ECI, then convert to ECEF for demonstration\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate_eci = bh.state_osculating_to_cartesian(elements, bh.AngleFormat.DEGREES)\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\n\n# Create propagator from ECEF state\nprop = bh.KeplerianPropagator.from_ecef(epoch, state_ecef, 60.0)\n\nprint(f\"ECEF position magnitude: {np.linalg.norm(state_ecef[:3]) / 1e3:.1f} km\")\n# ECEF position magnitude: 6873.3 km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for ECEF \u2194 ECI transformations\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Get state in ECI, then convert to ECEF for demonstration\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let state_eci = bh::state_osculating_to_cartesian(elements, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epoch, state_eci);\n\n    // Create propagator from ECEF state\n    let _prop = bh::KeplerianPropagator::from_ecef(epoch, state_ecef, 60.0);\n\n    println!(\"ECEF position magnitude: {:.1} km\",\n             state_ecef.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECEF position magnitude: 6873.3 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#stepping-through-time","title":"Stepping Through Time","text":"<p>One of the primary functions of propagators is to step forward in time, generating new states at regular intervals. There are several methods to advance the propagator's internal state. Each stepping operation adds new state(s) to the internal trajectory.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#single-steps","title":"Single Steps","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Take one step (60 seconds)\nprop.step()\nprint(f\"After 1 step: {prop.current_epoch}\")\n# After 1 step: 2024-01-01 00:01:00.000 UTC\n\n# Step by custom duration (120 seconds)\nprop.step_by(120.0)\nprint(f\"After custom step: {prop.current_epoch}\")\n# After custom step: 2024-01-01 00:03:00.000 UTC\n\n# Trajectory now contains 3 states (initial + 2 steps)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create propagator\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Take one step (60 seconds)\n    prop.step();\n    println!(\"After 1 step: {}\", prop.current_epoch());\n    // After 1 step: 2024-01-01 00:01:00.000 UTC\n\n    // Step by custom duration (120 seconds)\n    prop.step_by(120.0);\n    println!(\"After custom step: {}\", prop.current_epoch());\n    // After custom step: 2024-01-01 00:03:00.000 UTC\n\n    // Trajectory now contains 3 states (initial + 2 steps)\n    println!(\"Trajectory length: {}\", prop.trajectory.len());\n    // Trajectory length: 3\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#multiple-steps","title":"Multiple Steps","text":"<p>The <code>propagate_steps()</code> method allows taking multiple fixed-size steps in one call.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Take 10 steps (10 \u00d7 60 = 600 seconds)\nprop.propagate_steps(10)\nprint(f\"After 10 steps: {(prop.current_epoch - epoch):.1f} seconds elapsed\")\n# After 10 steps: 600.0 seconds elapsed\nprint(f\"Trajectory length: {len(prop.trajectory)}\")\n# Trajectory length: 11\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Take 10 steps (10 \u00d7 60 = 600 seconds)\n    prop.propagate_steps(10);\n    println!(\"After 10 steps: {:.1} seconds elapsed\",\n             prop.current_epoch() - epoch);\n    // After 10 steps: 600.0 seconds elapsed\n    println!(\"Trajectory length: {}\", prop.trajectory.len());\n    // Trajectory length: 11\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#propagate-to-target-epoch","title":"Propagate to Target Epoch","text":"<p>For precise time targeting, use <code>propagate_to()</code> which adjusts the final step size to exactly reach the target epoch.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate exactly 500 seconds (not evenly divisible by step size)\ntarget = epoch + 500.0\nprop.propagate_to(target)\n\nprint(f\"Target epoch: {target}\")\n# Target epoch: 2024-01-01 00:08:20.000 UTC\nprint(f\"Current epoch: {prop.current_epoch}\")\n# Current epoch: 2024-01-01 00:08:20.000 UTC\nprint(f\"Difference: {abs(prop.current_epoch - target):.10f} seconds\")\n# Difference: 0.0000000000 seconds\n# Output shows machine precision agreement\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::OrbitPropagator;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate exactly 500 seconds (not evenly divisible by step size)\n    let target = epoch + 500.0;\n    prop.propagate_to(target);\n\n    println!(\"Target epoch: {}\", target);\n    // Target epoch: 2024-01-01 00:08:20.000 UTC\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    // Current epoch: 2024-01-01 00:08:20.000 UTC\n    println!(\"Difference: {:.10} seconds\",\n             (prop.current_epoch() - target).abs());\n    // Difference: 0.0000000000 seconds\n    // Output shows machine precision agreement\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#direct-state-queries","title":"Direct State Queries","text":"<p>The <code>StateProvider</code> trait allows computing states at arbitrary epochs without building a trajectory. This is useful for sparse sampling or parallel batch computation.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#single-epoch-queries","title":"Single Epoch Queries","text":"<p>Single epoch queries like <code>state()</code>, <code>state_eci()</code>, and <code>state_ecef()</code> compute the state at a specific epoch on demand.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for frame transformations\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Query state 1 hour later (doesn't add to trajectory)\nquery_epoch = epoch + 3600.0\nstate_native = prop.state(\n    query_epoch\n)  # Native format of propagator internal state (Keplerian)\nstate_eci = prop.state_eci(query_epoch)  # ECI Cartesian\nstate_ecef = prop.state_ecef(query_epoch)  # ECEF Cartesian\nstate_kep = prop.state_as_osculating_elements(query_epoch, bh.AngleFormat.DEGREES)\n\nprint(f\"Native state (Keplerian): a={state_native[0] / 1e3:.1f} km\")\n# Native state (Keplerian): a=6878.1 km\nprint(f\"ECI position magnitude: {np.linalg.norm(state_eci[:3]) / 1e3:.1f} km\")\n# ECI position magnitude: 6877.7 km\nprint(f\"ECEF position magnitude: {np.linalg.norm(state_ecef[:3]) / 1e3:.1f} km\")\n# ECEF position magnitude: 6877.7 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::StateProvider;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for frame transformations\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Query state 1 hour later (doesn't add to trajectory)\n    let query_epoch = epoch + 3600.0;\n    let state_native = prop.state(query_epoch);       // Native format of propagator internal state  (Keplerian)\n    let state_eci = prop.state_eci(query_epoch);      // ECI Cartesian\n    let state_ecef = prop.state_ecef(query_epoch);    // ECEF Cartesian\n    let _state_kep = prop.state_as_osculating_elements(\n        query_epoch, bh::AngleFormat::Degrees\n    );\n\n    println!(\"Native state (Keplerian): a={:.1} km\", state_native[0] / 1e3);\n    // Native state (Keplerian): a=6878.1 km\n    println!(\"ECI position magnitude: {:.1} km\",\n             state_eci.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECI position magnitude: 6877.7 km\n    println!(\"ECEF position magnitude: {:.1} km\",\n             state_ecef.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECEF position magnitude: 6877.7 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#batch-queries","title":"Batch Queries","text":"<p>Batch queries like <code>states()</code> and <code>states_eci()</code> compute states at each epoch in a provided list.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Generate states at irregular intervals\nquery_epochs = [epoch + t for t in [0.0, 100.0, 500.0, 1000.0, 3600.0]]\nstates_eci = prop.states_eci(query_epochs)\n\nprint(f\"Generated {len(states_eci)} states\")\n# Generated 5 states\nfor i, state in enumerate(states_eci):\n    print(f\"  Epoch {i}: position magnitude = {np.linalg.norm(state[:3]) / 1e3:.1f} km\")\n\n# Output:\n# Generated 5 states\n#   Epoch 0: position magnitude = 6873.3 km\n#   Epoch 1: position magnitude = 6873.8 km\n#   Epoch 2: position magnitude = 6876.6 km\n#   Epoch 3: position magnitude = 6880.3 km\n#   Epoch 4: position magnitude = 6877.7 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::StateProvider;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Generate states at irregular intervals\n    let query_epochs = vec![\n        epoch, epoch + 100.0, epoch + 500.0, epoch + 1000.0, epoch + 3600.0\n    ];\n    let states_eci = prop.states_eci(&amp;query_epochs);\n\n    println!(\"Generated {} states\", states_eci.len());\n    // Generated 5 states\n    for (i, state) in states_eci.iter().enumerate() {\n        println!(\"  Epoch {}: position magnitude = {:.1} km\",\n                 i, state.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    }\n}\n\n// Output:\n// Generated 5 states\n//   Epoch 0: position magnitude = 6873.3 km\n//   Epoch 1: position magnitude = 6873.8 km\n//   Epoch 2: position magnitude = 6876.6 km\n//   Epoch 3: position magnitude = 6880.3 km\n//   Epoch 4: position magnitude = 6877.7 km\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#trajectory-management","title":"Trajectory Management","text":"<p>The propagator stores all stepped states in an internal <code>OrbitTrajectory</code>. This trajectory can be accessed, converted, and managed.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#accessing-the-trajectory","title":"Accessing the Trajectory","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate for several steps\nprop.propagate_steps(5)\n\n# Access trajectory\ntraj = prop.trajectory\nprint(f\"Trajectory contains {len(traj)} states\")\n# Trajectory contains 6 states\n\n# Iterate over epoch-state pairs\nfor epoch, state in traj:\n    print(f\"Epoch: {epoch}, semi-major axis: {state[0] / 1e3:.1f} km\")\n# Epoch: 2024-01-01 00:00:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:01:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:02:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:03:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:04:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:05:00.000 UTC, semi-major axis: 6878.1 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate for several steps\n    prop.propagate_steps(5);\n\n    // Access trajectory\n    let traj = &amp;prop.trajectory;\n    println!(\"Trajectory contains {} states\", traj.len());\n    // Trajectory contains 6 states\n\n    // Access by index\n    for i in 0..traj.len() {\n        let epoch = traj.epoch_at_idx(i).unwrap();\n        let state = traj.state_at_idx(i).unwrap();\n        println!(\"Epoch: {}, semi-major axis: {:.1} km\", epoch, state[0] / 1e3);\n    }\n    // Epoch: 2024-01-01 00:00:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:01:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:02:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:03:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:04:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:05:00.000 UTC, semi-major axis: 6878.1 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#frame-conversions","title":"Frame Conversions","text":"<p>You can use the OrbitTrajectory's frame conversion methods to get the trajectory in different reference frames.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for ECEF conversions\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\nprop.propagate_steps(10)\n\n# Convert entire trajectory to different frames\ntraj_eci = prop.trajectory.to_eci()  # ECI Cartesian\ntraj_ecef = prop.trajectory.to_ecef()  # ECEF Cartesian\ntraj_kep = prop.trajectory.to_keplerian(bh.AngleFormat.RADIANS)\n\nprint(f\"ECI trajectory: {len(traj_eci)} states\")\n# ECI trajectory: 11 states\nprint(f\"ECEF trajectory: {len(traj_ecef)} states\")\n# ECEF trajectory: 11 states\nprint(f\"Keplerian trajectory: {len(traj_kep)} states\")\n# Keplerian trajectory: 11 states\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitalTrajectory, OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for ECEF conversions\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n    prop.propagate_steps(10);\n\n    // Convert entire trajectory to different frames\n    let traj_eci = prop.trajectory.to_eci();       // ECI Cartesian\n    let traj_ecef = prop.trajectory.to_ecef();     // ECEF Cartesian\n    let traj_kep = prop.trajectory.to_keplerian(bh::AngleFormat::Radians);\n\n    println!(\"ECI trajectory: {} states\", traj_eci.len());\n    // ECI trajectory: 11 states\n    println!(\"ECEF trajectory: {} states\", traj_ecef.len());\n    // ECEF trajectory: 11 states\n    println!(\"Keplerian trajectory: {} states\", traj_kep.len());\n    // Keplerian trajectory: 11 states\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#memory-management","title":"Memory Management","text":"<p>Propagators support trajectory memory management via eviction policies to limit memory usage for long-running applications.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Keep only 100 most recent states\nprop.set_eviction_policy_max_size(100)\n\n# Propagate many steps\nprop.propagate_steps(500)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")  # Will be 100\n# Trajectory length: 100\n\n# Alternative: Keep only states within 1 hour of current time\nprop.reset()\nprop.set_eviction_policy_max_age(3600.0)  # 3600 seconds = 1 hour\nprop.propagate_steps(500)\nprint(f\"Trajectory length after age policy: {len(prop.trajectory)}\")\n# Trajectory length after age policy: 61\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Keep only 100 most recent states\n    prop.set_eviction_policy_max_size(100).unwrap();\n\n    // Propagate many steps\n    prop.propagate_steps(500);\n    println!(\"Trajectory length: {}\", prop.trajectory.len());  // Will be 100\n    // Trajectory length: 100\n\n    // Alternative: Keep only states within 1 hour of current time\n    prop.reset();\n    prop.set_eviction_policy_max_age(3600.0).unwrap();  // 3600 seconds = 1 hour\n    prop.propagate_steps(500);\n    println!(\"Trajectory length after age policy: {}\", prop.trajectory.len());\n    // Trajectory length after age policy: 61\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#configuration-and-control","title":"Configuration and Control","text":"<p>There are several methods to manage and configure the propagator during its lifecycle.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#resetting-the-propagator","title":"Resetting the Propagator","text":"<p>You can reset the propagator to its initial conditions using the <code>reset()</code> method.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate forward\nprop.propagate_steps(100)\nprint(f\"After propagation: {len(prop.trajectory)} states\")\n# After propagation: 101 states\n\n# Reset to initial conditions\nprop.reset()\nprint(f\"After reset: {len(prop.trajectory)} states\")\n# After reset: 1 states\nprint(f\"Current epoch: {prop.current_epoch}\")\n# Current epoch: 2024-01-01 00:00:00.000 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{OrbitPropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate forward\n    prop.propagate_steps(100);\n    println!(\"After propagation: {} states\", prop.trajectory.len());\n    // After propagation: 101 states\n\n    // Reset to initial conditions\n    prop.reset();\n    println!(\"After reset: {} states\", prop.trajectory.len());\n    // After reset: 1 states\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    // Current epoch: 2024-01-01 00:00:00.000 UTC\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#changing-step-size","title":"Changing Step Size","text":"<p>If you need to adjust the default step size during propagation, use the <code>set_step_size()</code> method.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\nprint(f\"Initial step size: {prop.step_size} seconds\")\n# Initial step size: 60.0 seconds\n\n# Change step size\nprop.set_step_size(120.0)\nprint(f\"New step size: {prop.step_size} seconds\")\n# New step size: 120.0 seconds\n\n# Subsequent steps use new step size\nprop.step()  # Advances 120 seconds\nprint(f\"After step: {(prop.current_epoch - epoch):.1f} seconds elapsed\")\n# After step: 120.0 seconds elapsed\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::OrbitPropagator;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    println!(\"Initial step size: {} seconds\", prop.step_size());\n    // Initial step size: 60 seconds\n\n    // Change step size\n    prop.set_step_size(120.0);\n    println!(\"New step size: {} seconds\", prop.step_size());\n    // New step size: 120 seconds\n\n    // Subsequent steps use new step size\n    prop.step();  // Advances 120 seconds\n    println!(\"After step: {:.1} seconds elapsed\", prop.current_epoch() - epoch);\n    // After step: 120.0 seconds elapsed\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#identity-tracking","title":"Identity Tracking","text":"<p>Finally, the <code>IdentifiableStateProvider</code> trait allows you to set and get identity information for the propagator. This can be useful when managing multiple propagators in an application.</p> <p>Track propagators with names, IDs, or UUIDs for multi-satellite scenarios.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\n\n# Create propagator with identity (builder pattern)\nprop = (\n    bh.KeplerianPropagator.from_keplerian(epoch, elements, bh.AngleFormat.DEGREES, 60.0)\n    .with_name(\"Satellite-A\")\n    .with_id(12345)\n)\n\nprint(f\"Name: {prop.get_name()}\")\n# Name: Satellite-A\nprint(f\"ID: {prop.get_id()}\")\n# ID: 12345\nprint(f\"UUID: {prop.get_uuid()}\")\n# UUID: None (because not set)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n\n    // Create propagator with identity (builder pattern)\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    ).with_name(\"Satellite-A\").with_id(12345);\n\n    println!(\"Name: {:?}\", prop.get_name());\n    // Name: Some(\"Satellite-A\")\n    println!(\"ID: {:?}\", prop.get_id());\n    // ID: Some(12345)\n    println!(\"UUID: {:?}\", prop.get_uuid());\n    // UUID: None (because not set)\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#see-also","title":"See Also","text":"<ul> <li>Orbit Propagation Overview - Propagation concepts and trait hierarchy</li> <li>SGP Propagation - TLE-based SGP4/SDP4 propagator</li> <li>Trajectories - Trajectory storage and operations</li> <li>KeplerianPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/sgp_propagation.html","title":"SGP Propagation","text":"<p>The <code>SGPPropagator</code> implements the SGP4/SDP4 propagation models for orbital prediction. SGP4 is a standard method for satellite tracking and includes simplified perturbations from Earth oblateness and atmospheric drag, making it suitable for operational satellite tracking and near-Earth orbit propagation. It is widely used with Two-Line Element (TLE) data provided by NORAD and other space tracking organizations.</p> <p>For complete API documentation, see the SGPPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#tle-format-support","title":"TLE Format Support","text":"<p>SGP4 propagation is based on Two-Line Element (TLE) sets, a compact data format for orbital elements. Brahe supports both traditional and modern TLE formats:</p> <ul> <li>Classic Format: Traditional numeric NORAD catalog numbers (5 digits, up to 99999)</li> <li>Alpha-5 Format: Extended alphanumeric catalog numbers for satellites beyond 99999</li> </ul> <p>The initialization automatically detects and handles both formats.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#initialization","title":"Initialization","text":"<p>The <code>SGPPropagator</code> is initialized from TLE data. The TLE lines contain all orbital parameters needed for propagation.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#from-two-line-elements-tle","title":"From Two Line Elements (TLE)","text":"<p>The most common initialization uses two lines of TLE data.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for accurate frame transformations\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator with 60-second step size\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\nprint(f\"NORAD ID: {prop.norad_id}\")\nprint(f\"TLE epoch: {prop.epoch}\")\nprint(\n    f\"Initial position magnitude: {np.linalg.norm(prop.initial_state()[:3]) / 1e3:.1f} km\"\n)\n# Expected output:\n# NORAD ID: 25544\n# TLE epoch: 2008-09-20 12:25:40.104 UTC\n# Initial position magnitude: 6720.2 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::OrbitPropagator;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for accurate frame transformations\n\n    // ISS TLE data (example)\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator with 60-second step size\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    println!(\"NORAD ID: {}\", prop.norad_id);\n    println!(\"TLE epoch: {}\", prop.epoch);\n    println!(\"Initial position magnitude: {:.1} km\",\n             prop.initial_state().fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // Expected output:\n    // NORAD ID: 25544\n    // TLE epoch: 2008-09-20 12:25:40.104 UTC\n    // Initial position magnitude: 6720.2 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#from-3-line-elements-3le","title":"From 3-Line Elements (3LE)","text":"<p>Three-line TLE format includes an optional satellite name on the first line.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# 3-line TLE with satellite name\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator with satellite name\nprop = bh.SGPPropagator.from_3le(name, line1, line2, 60.0)\n\nprint(f\"Satellite name: {prop.satellite_name}\")\nprint(f\"NORAD ID: {prop.norad_id}\")\n# Expected output:\n# Satellite name: ISS (ZARYA)\n# NORAD ID: 25544\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // 3-line TLE with satellite name\n    let name = \"ISS (ZARYA)\";\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator with satellite name\n    let prop = bh::SGPPropagator::from_3le(Some(name), line1, line2, 60.0).unwrap();\n\n    println!(\"Satellite name: {:?}\", prop.satellite_name);\n    println!(\"NORAD ID: {}\", prop.norad_id);\n    // Expected output:\n    // Satellite name: Some(\"ISS (ZARYA)\")\n    // NORAD ID: 25544\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#configuring-output-format","title":"Configuring Output Format","text":"<p>By default, SGP4 outputs states in ECI Cartesian coordinates. Use <code>with_output_format()</code> to configure the output frame and representation.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create with ECEF Cartesian output\nprop_ecef = bh.SGPPropagator.from_tle(line1, line2, 60.0)\nprop_ecef.set_output_format(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\n\n# Or with Keplerian output (ECI only)\nprop_kep = bh.SGPPropagator.from_tle(line1, line2, 60.0)\nprop_kep.set_output_format(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES\n)\n\n# Propagate to 1 hour after epoch\ndt = 3600.0\nprop_ecef.propagate_to(prop_ecef.epoch + dt)\nprop_kep.propagate_to(prop_kep.epoch + dt)\nprint(f\"ECEF position (km): {prop_ecef.current_state()[:3] / 1e3}\")\nstate_kep = prop_kep.current_state()\nprint(\n    f\"Keplerian elements: [{state_kep[0]:.1f} km, {state_kep[1]:.4f}, {state_kep[2]:.4f}, \"\n    f\"{state_kep[3]:.4f} deg, {state_kep[4]:.4f} deg, {state_kep[5]:.4f} deg]\"\n)\n\n# Expected output:\n# ECEF position (km): [ 5548.63233725  2869.31027561 -2526.64252368]\n# Keplerian elements: [8198150.8 km, 0.1789, 47.9402, 249.8056 deg, 323.0545 deg, 4.5675 deg]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{OrbitFrame, OrbitPropagator, OrbitRepresentation};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create with ECEF Cartesian output\n    let mut prop_ecef = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap()\n        .with_output_format(OrbitFrame::ECEF, OrbitRepresentation::Cartesian, None);\n\n    // Or with Keplerian output (ECI only)\n    let mut prop_kep = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap()\n        .with_output_format(OrbitFrame::ECI, OrbitRepresentation::Keplerian, Some(bh::AngleFormat::Degrees));\n\n    // Propagate to 1 hour after epoch\n    let dt = 3600.0;\n    prop_ecef.propagate_to(prop_ecef.epoch + dt);\n    prop_kep.propagate_to(prop_kep.epoch + dt);\n\n    let state_ecef = prop_ecef.current_state();\n    println!(\"ECEF position (km): [{:.3}, {:.3}, {:.3}]\",\n             state_ecef[0] / 1e3, state_ecef[1] / 1e3, state_ecef[2] / 1e3);\n\n    let state_kep = prop_kep.current_state();\n    println!(\"Keplerian elements: [{:.1} km, {:.4}, {:.4}, {:.4} deg, {:.4} deg, {:.4} deg]\",\n             state_kep[0] / 1e3, state_kep[1], state_kep[2],\n             state_kep[3], state_kep[4], state_kep[5]);\n}\n\n// Output:\n// ECEF position (km): [5548.632, 2869.310, -2526.643]\n// Keplerian elements: [8198.2 km, 0.1789, 47.9402, 249.8056 deg, 323.0545 deg, 4.5675 deg]\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#stepping-through-time","title":"Stepping Through Time","text":"<p>The SGP propagator uses the same stepping interface as other propagators through the <code>OrbitPropagator</code> trait.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#single-and-multiple-steps","title":"Single and Multiple Steps","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Single step (60 seconds)\nprop.step()\nprint(f\"After 1 step: {prop.current_epoch}\")\n\n# Multiple steps\nprop.propagate_steps(10)\nprint(f\"After 11 total steps: {len(prop.trajectory)} states\")\n\n# Step by custom duration\nprop.step_by(120.0)\nprint(f\"After custom step: {prop.current_epoch}\")\n\n# Expected output:\n# After 1 step: 2008-09-20 12:26:40.104 UTC\n# After 11 total steps: 12 states\n# After custom step: 2008-09-20 12:38:40.104 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{OrbitPropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Single step (60 seconds)\n    prop.step();\n    println!(\"After 1 step: {}\", prop.current_epoch());\n\n    // Multiple steps\n    prop.propagate_steps(10);\n    println!(\"After 11 total steps: {} states\", prop.trajectory.len());\n\n    // Step by custom duration\n    prop.step_by(120.0);\n    println!(\"After custom step: {}\", prop.current_epoch());\n}\n\n// Output\n// After 1 step: 2008-09-20 12:26:40.104 UTC\n// After 11 total steps: 12 states\n// After custom step: 2008-09-20 12:38:40.104 UTC\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#propagate-to-target-epoch","title":"Propagate to Target Epoch","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Propagate to specific epoch\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\n\nprint(f\"Target epoch: {target}\")\nprint(f\"Current epoch: {prop.current_epoch}\")\nprint(f\"Trajectory contains {len(prop.trajectory)} states\")\n\n# Expected output:\n# Target epoch: 2008-09-20 14:25:40.104 UTC\n# Current epoch: 2008-09-20 14:25:40.104 UTC\n# Trajectory contains 121 states\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{OrbitPropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Propagate to specific epoch\n    let target = prop.epoch + 7200.0;  // 2 hours later\n    prop.propagate_to(target);\n\n    println!(\"Target epoch: {}\", target);\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    println!(\"Trajectory contains {} states\", prop.trajectory.len());\n\n    // Expected output:\n    // Target epoch: 2008-09-20 14:25:40.104 UTC\n    // Current epoch: 2008-09-20 14:25:40.104 UTC\n    // Trajectory contains 121 states\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#direct-state-queries","title":"Direct State Queries","text":"<p>The SGP propagator implements the <code>StateProvider</code> trait, allowing direct state computation at arbitrary epochs without stepping. Because SGP4 uses closed-form solutions, state queries are efficient and do not require building a trajectory.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#single-epoch-queries","title":"Single Epoch Queries","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Query state 1 orbit later (doesn't add to trajectory)\nquery_epoch = prop.epoch + 5400.0  # ~90 minutes\n\nstate_eci = prop.state_eci(query_epoch)  # ECI Cartesian\nstate_ecef = prop.state_ecef(query_epoch)  # ECEF Cartesian\nstate_kep = prop.state_as_osculating_elements(\n    query_epoch, bh.AngleFormat.DEGREES\n)  # Osculating Keplerian\n\nprint(\n    f\"ECI position: [{state_eci[0] / 1e3:.1f}, {state_eci[1] / 1e3:.1f}, \"\n    f\"{state_eci[2] / 1e3:.1f}] km\"\n)\nprint(f\"Osculating semi-major axis: {state_kep[0] / 1e3:.1f} km\")\n\n# Expected output:\n# ECI position: [3822.2, -1684.2, 5264.9] km\n# Osculating semi-major axis: 6725.4 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::StateProvider;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Query state 1 orbit later (doesn't add to trajectory)\n    let query_epoch = prop.epoch + 5400.0;  // ~90 minutes\n\n    let state_eci = prop.state_eci(query_epoch);          // ECI Cartesian\n    let _state_ecef = prop.state_ecef(query_epoch);        // ECEF Cartesian\n    let state_kep = prop.state_as_osculating_elements(query_epoch, bh::AngleFormat::Degrees);    // Osculating Keplerian\n\n    println!(\"ECI position: [{:.1}, {:.1}, {:.1}] km\",\n             state_eci[0]/1e3, state_eci[1]/1e3, state_eci[2]/1e3);\n    println!(\"Osculating semi-major axis: {:.1} km\", state_kep[0]/1e3);\n\n    // Expected output:\n    // ECI position: [3822.2, -1684.2, 5264.9] km\n    // Osculating semi-major axis: 6725.4 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#batch-queries","title":"Batch Queries","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Generate states for multiple orbits\norbital_period = 5400.0  # Approximate ISS period (seconds)\nquery_epochs = [prop.epoch + i * orbital_period for i in range(5)]\nstates_eci = prop.states_eci(query_epochs)\n\nprint(f\"Generated {len(states_eci)} states over {len(query_epochs)} orbits\")\nfor i, state in enumerate(states_eci):\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1e3\n    print(f\"  Orbit {i}: altitude = {altitude:.1f} km\")\n# Expected output:\n# Generated 5 states over 5 orbits\n#   Orbit 0: altitude = 342.1 km\n#   Orbit 1: altitude = 342.3 km\n#   Orbit 2: altitude = 342.7 km\n#   Orbit 3: altitude = 343.3 km\n#   Orbit 4: altitude = 344.0 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::StateProvider;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Generate states for multiple orbits\n    let orbital_period = 5400.0;  // Approximate ISS period (seconds)\n    let query_epochs: Vec&lt;bh::Epoch&gt; = (0..5)\n        .map(|i| prop.epoch + i as f64 * orbital_period)\n        .collect();\n    let states_eci = prop.states_eci(&amp;query_epochs);\n\n    println!(\"Generated {} states over {} orbits\", states_eci.len(), query_epochs.len());\n    for (i, state) in states_eci.iter().enumerate() {\n        let altitude = (state.fixed_rows::&lt;3&gt;(0).norm() - bh::R_EARTH) / 1e3;\n        println!(\"  Orbit {}: altitude = {:.1} km\", i, altitude);\n    }\n    // Expected output:\n    // Generated 5 states over 5 orbits\n    //   Orbit 0: altitude = 342.1 km\n    //   Orbit 1: altitude = 342.3 km\n    //   Orbit 2: altitude = 342.7 km\n    //   Orbit 3: altitude = 343.3 km\n    //   Orbit 4: altitude = 344.0 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#special-pef-frame","title":"Special: PEF Frame","text":"<p>SGP4 natively outputs states in the TEME (True Equator Mean Equinox) frame. For specialized applications, you can access states in the intermediate PEF (Pseudo-Earth-Fixed) frame:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Get state in PEF frame (TEME rotated by GMST)\nstate_pef = prop.state_pef(prop.epoch)\nprint(f\"PEF position: {state_pef[:3] / 1e3}\")\n# Expected output:\n# PEF position: [-3953.20574821  1427.51460044  5243.61453697]\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Get state in PEF frame (TEME rotated by GMST)\n    let state_pef = prop.state_pef(prop.epoch);\n    println!(\"PEF position: {:?}\", state_pef.fixed_rows::&lt;3&gt;(0) / 1e3);\n    // Expected output:\n    // PEF position: [[-3953.2057482107907, 1427.514600436758, 5243.614536966578]]\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#extracting-orbital-elements-from-tle","title":"Extracting Orbital Elements from TLE","text":"<p>The propagator can extract Keplerian orbital elements directly from the TLE data:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Extract Keplerian elements from TLE\nelements_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nelements_rad = prop.get_elements(bh.AngleFormat.RADIANS)\n\nprint(f\"Semi-major axis: {elements_deg[0] / 1e3:.1f} km\")\nprint(f\"Eccentricity: {elements_deg[1]:.6f}\")\nprint(f\"Inclination: {elements_deg[2]:.4f} degrees\")\nprint(f\"RAAN: {elements_deg[3]:.4f} degrees\")\nprint(f\"Argument of perigee: {elements_deg[4]:.4f} degrees\")\nprint(f\"Mean anomaly: {elements_deg[5]:.4f} degrees\")\n# Expected output:\n# Semi-major axis: 6758.7 km\n# Eccentricity: 0.000670\n# Inclination: 51.6416 degrees\n# RAAN: 247.4627 degrees\n# Argument of perigee: 130.5360 degrees\n# Mean anomaly: 325.0288 degrees\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Extract Keplerian elements from TLE\n    let elements_deg = prop.get_elements(bh::AngleFormat::Degrees).unwrap();\n    let _elements_rad = prop.get_elements(bh::AngleFormat::Radians).unwrap();\n\n    println!(\"Semi-major axis: {:.1} km\", elements_deg[0]/1e3);\n    println!(\"Eccentricity: {:.6}\", elements_deg[1]);\n    println!(\"Inclination: {:.4} degrees\", elements_deg[2]);\n    println!(\"RAAN: {:.4} degrees\", elements_deg[3]);\n    println!(\"Argument of perigee: {:.4} degrees\", elements_deg[4]);\n    println!(\"Mean anomaly: {:.4} degrees\", elements_deg[5]);\n    // Expected output:\n    // Semi-major axis: 6758.7 km\n    // Eccentricity: 0.000670\n    // Inclination: 51.6416 degrees\n    // RAAN: 247.4627 degrees\n    // Argument of perigee: 130.5360 degrees\n    // Mean anomaly: 325.0288 degrees\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#trajectory-management","title":"Trajectory Management","text":"<p>SGP propagators support the same trajectory management as Keplerian propagators, including frame conversions and memory management.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#memory-management","title":"Memory Management","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Keep only 50 most recent states for memory efficiency\nprop.set_eviction_policy_max_size(50)\n\n# Propagate many steps\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")  # Will be 50\n\n# Alternative: Keep states within 30 minutes of current\nprop.reset()\nprop.set_eviction_policy_max_age(1800.0)  # 1800 seconds = 30 minutes\nprop.propagate_steps(200)\nprint(f\"Trajectory length with age policy: {len(prop.trajectory)}\")\n# Expected output:\n# Trajectory length: 50\n# Trajectory length with age policy: 31\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{OrbitPropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Keep only 50 most recent states for memory efficiency\n    prop.set_eviction_policy_max_size(50).unwrap();\n\n    // Propagate many steps\n    prop.propagate_steps(200);\n    println!(\"Trajectory length: {}\", prop.trajectory.len());  // Will be 50\n\n    // Alternative: Keep states within 30 minutes of current\n    prop.reset();\n    prop.set_eviction_policy_max_age(1800.0).unwrap();  // 1800 seconds = 30 minutes\n    prop.propagate_steps(200);\n    println!(\"Trajectory length with age policy: {}\", prop.trajectory.len());\n    // Expected output:\n    // Trajectory length: 50\n    // Trajectory length with age policy: 31\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#limitations-and-considerations","title":"Limitations and Considerations","text":""},{"location":"learn/orbit_propagation/sgp_propagation.html#immutable-initial-conditions","title":"Immutable Initial Conditions","text":"<p>Unlike the Keplerian propagator, SGP4 initial conditions are derived from the TLE and cannot be changed. Attempting to call <code>set_initial_conditions()</code> will result in a panic:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# This will raise an error - SGP initial conditions come from TLE\n# prop.set_initial_conditions(...)  # Don't do this!\n\n# To use different orbital elements, create a KeplerianPropagator instead\n</code></pre> <pre><code>// This will panic - SGP initial conditions come from TLE\n// prop.set_initial_conditions(...);  // Don't do this!\n\n// To use different orbital elements, create a KeplerianPropagator instead\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#identity-tracking","title":"Identity Tracking","text":"<p>Like Keplerian propagators, SGP propagators support identity tracking:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline0 = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator and set identity\nprop = bh.SGPPropagator.from_3le(line0, line1, line2, 60.0)\n\nprint(f\"Name: {prop.get_name()}\")\nprint(f\"ID: {prop.get_id()}\")\nprint(f\"NORAD ID from TLE: {prop.norad_id}\")\n# Expected output:\n# Name: ISS (ZARYA)\n# ID: 25544\n# NORAD ID from TLE: 25544\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line0 = \"ISS (ZARYA)\";\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator and set identity\n    let prop = bh::SGPPropagator::from_3le(Some(line0), line1, line2, 60.0).unwrap();\n\n    println!(\"Name: {:?}\", prop.get_name());\n    println!(\"ID: {:?}\", prop.get_id());\n    println!(\"NORAD ID from TLE: {}\", prop.norad_id);\n    // Expected output:\n    // Name:  Some(\"ISS (ZARYA)\")\n    // ID: Some(25544)\n    // NORAD ID from TLE: 25544\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#see-also","title":"See Also","text":"<ul> <li>Orbit Propagation Overview - Propagation concepts and trait hierarchy</li> <li>Keplerian Propagation - Analytical two-body propagator</li> <li>Trajectories - Trajectory storage and operations</li> <li>Two-Line Elements - Working with TLE data</li> <li>SGPPropagator API Reference</li> </ul>"},{"location":"learn/orbits/index.html","title":"Orbital Elements","text":"<p>In orbital mechanics, describing the motion of a satellite requires representing its position and velocity at any given time. There are two primary ways to represent an orbit:</p> <ol> <li>Cartesian state vectors - Position and velocity in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code></li> <li>Keplerian orbital elements - Six parameters that describe the orbit's shape, orientation, and the satellite's position within it: <code>[a, e, i, \u03a9, \u03c9, \u03bd]</code></li> </ol> <p>Both representations contain the same information, but each has advantages for different applications. Cartesian states are ideal for numerical propagation and reference frame transformations, while Keplerian elements provide intuitive understanding of orbital characteristics like size, shape, and orientation.</p> <p>The <code>brahe.orbits</code> module provides tools for working with Keplerian orbital elements, computing orbital properties, and handling the Two-Line Element (TLE) format used for distributing satellite orbit information.</p>"},{"location":"learn/orbits/index.html#orbital-representations","title":"Orbital Representations","text":""},{"location":"learn/orbits/index.html#keplerian-elements","title":"Keplerian Elements","text":"<p>Keplerian orbital elements describe an orbit using six parameters:</p> <ul> <li>Semi-major axis (a) - Defines the size of the orbit [meters]</li> <li>Eccentricity (e) - Defines the shape (0 = circular, 0 &lt; e &lt; 1 = elliptical) [dimensionless]</li> <li>Inclination (i) - Angle between orbital plane and equator [radians or degrees]</li> <li>Right Ascension of Ascending Node (\u03a9) - Orientation of the orbital plane [radians or degrees]</li> <li>Argument of Periapsis (\u03c9) - Orientation of the orbit within its plane [radians or degrees]</li> <li>Anomaly - Satellite's position along the orbit [radians or degrees]</li> </ul> <p>In Brahe, Keplerian elements are represented as arrays: <code>[a, e, i, \u03a9, \u03c9, anomaly]</code> where the semi-major axis is in meters and angles are in radians (unless using the <code>AngleFormat</code> enum to specify degrees).</p> <p>The anomaly can be expressed in three forms - true, eccentric, or mean anomaly - each useful for different calculations. See Anomaly Conversions for details.</p> <p>Tip</p> <p>For all functions in the <code>brahe.orbits</code> module, the anomaly is assumed to be the mean anomaly unless otherwise specified.</p>"},{"location":"learn/orbits/index.html#cartesian-states","title":"Cartesian States","text":"<p>Cartesian state vectors represent position and velocity in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code>. In Brahe, position components are in meters and velocity components are in meters per second.</p> <p>Brahe provides functions to convert between Keplerian elements and Cartesian states:</p> <ul> <li><code>state_osculating_to_cartesian()</code> - Convert orbital elements to Cartesian state</li> <li><code>state_cartesian_to_osculating()</code> - Convert Cartesian state to orbital elements</li> </ul> <p>These functions are found in the coordinates module but are essential for working with orbits.</p>"},{"location":"learn/orbits/index.html#topics-in-this-section","title":"Topics in This Section","text":""},{"location":"learn/orbits/index.html#orbital-properties","title":"Orbital Properties","text":"<p>Learn about computing fundamental orbital properties including:</p> <ul> <li>Orbital period and mean motion</li> <li>Semi-major axis from period or mean motion</li> <li>Periapsis and apoapsis distances, altitudes, and velocities</li> <li>Sun-synchronous orbit inclination</li> </ul>"},{"location":"learn/orbits/index.html#anomaly-conversions","title":"Anomaly Conversions","text":"<p>Understand the three types of orbital anomaly and how to convert between them:</p> <ul> <li>True anomaly - Actual angular position from periapsis</li> <li>Eccentric anomaly - Auxiliary angle used in elliptical orbit calculations</li> <li>Mean anomaly - Linearly increasing angle representing average motion</li> </ul>"},{"location":"learn/orbits/index.html#two-line-elements","title":"Two-Line Elements","text":"<p>Work with the TLE format for distributing satellite orbital information:</p> <ul> <li>TLE structure and parsing</li> <li>TLE validation and checksums</li> <li>Extracting orbital elements from TLEs</li> <li>Creating TLEs from Keplerian elements</li> <li>NORAD satellite catalog number conversions</li> </ul>"},{"location":"learn/orbits/index.html#see-also","title":"See Also","text":"<ul> <li>Orbits API Reference - Complete orbital functions documentation</li> <li>Coordinates - Cartesian and Keplerian conversions</li> <li>Orbit Propagation - Propagating orbits over time</li> <li>Physical Constants - Gravitational parameters and radii</li> </ul>"},{"location":"learn/orbits/anomalies.html","title":"True, Eccentric, and Mean Anomaly","text":"<p>This section deals with the conversion between true, eccentric, and mean  anomaly. </p> <p>True anomaly, frequently denoted \\(\\nu\\), is the angular parameter that defines  the position of an object moving along a Keplerian orbit. It is the angle  between the eccentricity vector (vector pointing from the main pericenter to  the periapsis) and the current position of the body in the orbital plane itself.</p> <p>The eccentric anomaly, \\(E\\), is another angular parameter that defines the position  of an object moving along a Keplerian orbit if viewed from the center of the  ellipse. </p> <p>Finally, the mean anomaly, \\(M\\), defines the fraction of an orbital period that has  elapsed since the orbiting object has passed its periapsis. It is the angle  from the pericenter an object moving on a fictitious circular orbit with the  same semi-major axis would have progressed through in the same time as the  body on the true elliptical orbit.</p> <p>Conversion between all types of angular anomaly is possible. However, there is  no known direct conversion between true and mean anomaly. Conversion between the two is  accomplished by transformation through eccentric anomaly.</p>"},{"location":"learn/orbits/anomalies.html#true-and-eccentric-anomaly-conversions","title":"True and Eccentric Anomaly Conversions","text":"<p>To convert from true anomaly to eccentric anomaly, you can use the function  <code>anomaly_eccentric_to_true</code>. To perform the reverse conversion use  <code>anomaly_true_to_eccentric</code>.</p> <p>Eccentric anomaly can be converted to true anomaly by using equations derived using equations  from Vallado<sup>1</sup>. Starting from Equation (2-12) $$ \\sin{\\nu} = \\frac{\\sin{E}\\sqrt{1-e^2}}{1 - e\\cos{E}} $$ can be divided by $$ \\cos{\\nu} =  \\frac{\\cos{E}-e}{1 - e\\cos{E}} $$ and rearrange to get $$ \\nu = \\arctan{\\frac{\\sin{E}\\sqrt{1-e^2}}{\\cos{E}-e}} $$</p> <p>This conversion is what is implemented by <code>anomaly_eccentric_to_true</code>. Similarly, we can derive $$ E = \\arctan{\\frac{\\sin{\\nu}\\sqrt{1-e^2}}{\\cos{\\nu}+e}} $$ which allows for conversion from true anomaly to eccentric anomaly and is implemented in  <code>anomaly_true_to_eccentric</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nnu = 45.0  # Starting true anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to eccentric anomaly\necc_anomaly = bh.anomaly_true_to_eccentric(nu, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"True anomaly:      {nu:.3f} deg\")\nprint(f\"Eccentric anomaly: {ecc_anomaly:.3f} deg\")\n\n# Convert back from eccentric to true anomaly\nnu_2 = bh.anomaly_eccentric_to_true(ecc_anomaly, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Round-trip result: {nu_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(nu - nu_2):.2e} deg\")\n\n# Expected output:\n# True anomaly:      45.000 deg\n# Eccentric anomaly: 44.596 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let nu = 45.0; // Starting true anomaly (degrees)\n    let e = 0.01;  // Eccentricity\n\n    // Convert to eccentric anomaly\n    let ecc_anomaly = bh::orbits::anomaly_true_to_eccentric(nu, e, bh::constants::AngleFormat::Degrees);\n    println!(\"True anomaly:      {:.3} deg\", nu);\n    println!(\"Eccentric anomaly: {:.3} deg\", ecc_anomaly);\n\n    // Convert back from eccentric to true anomaly\n    let nu_2 = bh::orbits::anomaly_eccentric_to_true(ecc_anomaly, e, bh::constants::AngleFormat::Degrees);\n    println!(\"Round-trip result: {:.3} deg\", nu_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (nu - nu_2).abs());\n\n    // Expected output:\n    // True anomaly:      45.000 deg\n    // Eccentric anomaly: 44.596 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_true_eccentric.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of true anomalies (degrees)\nnu = [x for x in range(0, 360)]\n\n# Compute eccentric anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\necc_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    ecc_data[e] = [\n        bh.anomaly_true_to_eccentric(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in nu\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=nu,\n                y=ecc_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"True Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Eccentric Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/anomalies.html#eccentric-and-mean-anomaly-conversions","title":"Eccentric and Mean Anomaly Conversions","text":"<p>To convert from true anomaly to eccentric anomaly, you can use the function <code>anomaly_eccentric_to_mean</code>. To perform the reverse conversion use <code>anomaly_mean_to_eccentric</code>. </p> <p>Conversion from eccentric anomaly to mean anomaly is accomplished by application of Kepler's  equation $$ M = E - e\\sin{E} $$ which is implemented in <code>anomaly_eccentric_to_mean</code>.</p> <p>Converting back from mean anomaly to eccentric anomaly is more challenging. There is no known closed-form solution to convert from mean anomaly to eccentric anomaly.  Instead, we introduce the auxiliary equation $$ f(E) = E - e\\sin(E) - M $$ And treat the problem as numerically solving for the root of \\(f\\) for a given \\(M\\). This iteration  can be accomplished using Newton's method. Starting from an initial guess \\(E_0\\) the value of  \\(E_*\\) can be iteratively updated using $$ E_{i+1} = \\frac{f(E_i)}{f^\\prime(E_i)}= E_i - \\frac{E_i - e\\sin{E_i} - M}{1 - e\\cos{E_i}} $$ This update is performed until a coverage threshold of $$ |E_{i+1} - E_i| \\leq \\Delta_{\\text{tol}} $$ is reached. The threshold set as 100 times floating-point machine precision <code>100 * f64::epsilon</code>. This conversion is provided by <code>anomaly_mean_to_eccentric</code>.</p> <p>Warning</p> <p>Because this is a numerical method, convergence is not guaranteed. There is an upper  limit of 10 iterations to reach convergence. Since convergence may not occur the output of  the function is a <code>Result</code>, forcing the user to explicitly handle the case where the algorithm  does not converage.</p> <p>Since Python lacks Rust's same error handling mechanisms, non-convergence will result in a  runtime error.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\necc = 45.0  # Starting eccentric anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to mean anomaly\nmean_anomaly = bh.anomaly_eccentric_to_mean(ecc, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Eccentric anomaly: {ecc:.3f} deg\")\nprint(f\"Mean anomaly:      {mean_anomaly:.3f} deg\")\n\n# Convert back from mean to eccentric anomaly\necc_2 = bh.anomaly_mean_to_eccentric(\n    mean_anomaly, e, angle_format=bh.AngleFormat.DEGREES\n)\nprint(f\"Round-trip result: {ecc_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(ecc - ecc_2):.2e} deg\")\n\n# Expected output:\n# Eccentric anomaly: 45.000 deg\n# Mean anomaly:      44.595 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let ecc = 45.0; // Starting eccentric anomaly (degrees)\n    let e = 0.01;   // Eccentricity\n\n    // Convert to mean anomaly\n    let mean_anomaly = bh::orbits::anomaly_eccentric_to_mean(ecc, e, bh::constants::AngleFormat::Degrees);\n    println!(\"Eccentric anomaly: {:.3} deg\", ecc);\n    println!(\"Mean anomaly:      {:.3} deg\", mean_anomaly);\n\n    // Convert back from mean to eccentric anomaly\n    let ecc_2 = bh::orbits::anomaly_mean_to_eccentric(mean_anomaly, e, bh::constants::AngleFormat::Degrees).unwrap();\n    println!(\"Round-trip result: {:.3} deg\", ecc_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (ecc - ecc_2).abs());\n\n    // Expected output:\n    // Eccentric anomaly: 45.000 deg\n    // Mean anomaly:      44.595 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_eccentric_mean.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of eccentric anomalies (degrees)\necc = [x for x in range(0, 360)]\n\n# Compute mean anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\nmean_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    mean_data[e] = [\n        bh.anomaly_eccentric_to_mean(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in ecc\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=ecc,\n                y=mean_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Eccentric Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Mean Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/anomalies.html#true-and-mean-anomaly-conversions","title":"True and Mean Anomaly Conversions","text":"<p>Methods to convert from true anomaly to mean anomaly are  provided for convenience. These methods simply wrap successive calls to two  <code>anomaly_true_to_mean</code>. To perform the reverse conversion use <code>anomaly_mean_to_true</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nnu = 45.0  # Starting true anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to mean anomaly\nmean_anomaly = bh.anomaly_true_to_mean(nu, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"True anomaly:      {nu:.3f} deg\")\nprint(f\"Mean anomaly:      {mean_anomaly:.3f} deg\")\n\n# Convert back from mean to true anomaly\nnu_2 = bh.anomaly_mean_to_true(mean_anomaly, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Round-trip result: {nu_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(nu - nu_2):.2e} deg\")\n\n# Expected output:\n# True anomaly:      45.000 deg\n# Mean anomaly:      44.194 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let nu = 45.0; // Starting true anomaly (degrees)\n    let e = 0.01;  // Eccentricity\n\n    // Convert to mean anomaly\n    let mean_anomaly = bh::orbits::anomaly_true_to_mean(nu, e, bh::constants::AngleFormat::Degrees);\n    println!(\"True anomaly:      {:.3} deg\", nu);\n    println!(\"Mean anomaly:      {:.3} deg\", mean_anomaly);\n\n    // Convert back from mean to true anomaly\n    let nu_2 = bh::orbits::anomaly_mean_to_true(mean_anomaly, e, bh::constants::AngleFormat::Degrees).unwrap();\n    println!(\"Round-trip result: {:.3} deg\", nu_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (nu - nu_2).abs());\n\n    // Expected output:\n    // True anomaly:      45.000 deg\n    // Mean anomaly:      44.194 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_true_mean.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of true anomalies (degrees)\nnu = [x for x in range(0, 360)]\n\n# Compute mean anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\nmean_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    mean_data[e] = [\n        bh.anomaly_true_to_mean(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in nu\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=nu,\n                y=mean_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"True Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Mean Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <ol> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010 https://celestrak.com/software/vallado-sw.php \u21a9</p> </li> </ol>"},{"location":"learn/orbits/properties.html","title":"Orbital Properties","text":"<p>The <code>orbits</code> module provides functions to compute essential properties of satellite orbits, including orbital period, mean motion, periapsis/apoapsis characteristics, and specialized orbits like sun-synchronous configurations. These properties are fundamental for mission design, orbit determination, and trajectory analysis.</p> <p>For complete API documentation, see Orbits API Reference.</p>"},{"location":"learn/orbits/properties.html#orbital-period","title":"Orbital Period","text":"<p>The orbital period \\(T\\) of a satellite is the time it takes to complete one full revolution around the central body. It is related to the semi-major axis \\(a\\) and gravitational parameter \\(\\mu\\) by:</p> \\[ T = 2\\pi\\sqrt{\\frac{a^3}{\\mu}} \\] <p>The <code>orbital_period</code> function computes the period for Earth-orbiting objects, while <code>orbital_period_general</code> accepts an explicit gravitational parameter for any celestial body.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m) - LEO orbit at 500 km altitude\n\n# Compute orbital period for Earth orbit (uses GM_EARTH internally)\nperiod_earth = bh.orbital_period(a)\nprint(f\"Orbital period (Earth): {period_earth:.3f} s\")\nprint(f\"Orbital period (Earth): {period_earth / 60:.3f} min\")\n\n# Compute orbital period for general body (explicit GM)\nperiod_general = bh.orbital_period_general(a, bh.GM_EARTH)\nprint(f\"Orbital period (general): {period_general:.3f} s\")\n\n# Verify they match\nprint(f\"Difference: {abs(period_earth - period_general):.2e} s\")\n\n# Example with approximate GEO altitude\na_geo = bh.R_EARTH + 35786e3\nperiod_geo = bh.orbital_period(a_geo)\nprint(f\"\\nGEO orbital period: {period_geo / 3600:.3f} hours\")\n\n# Expected output:\n# Orbital period (Earth): 5676.977 s\n# Orbital period (Earth): 94.616 min\n# Orbital period (general): 5676.977 s\n# Difference: 0.00e0 s\n\n# GEO orbital period: 23.934 hours\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m) - LEO orbit at 500 km altitude\n\n    // Compute orbital period for Earth orbit (uses GM_EARTH internally)\n    let period_earth = bh::orbits::orbital_period(a);\n    println!(\"Orbital period (Earth): {:.3} s\", period_earth);\n    println!(\"Orbital period (Earth): {:.3} min\", period_earth / 60.0);\n\n    // Compute orbital period for general body (explicit GM)\n    let period_general = bh::orbits::orbital_period_general(a, bh::constants::GM_EARTH);\n    println!(\"Orbital period (general): {:.3} s\", period_general);\n\n    // Verify they match\n    println!(\"Difference: {:.2e} s\", (period_earth - period_general).abs());\n\n    // Example with approximate GEO altitude\n    let a_geo = bh::constants::R_EARTH + 35786e3;\n    let period_geo = bh::orbits::orbital_period(a_geo);\n    println!(\"\\nGEO orbital period: {:.3} hours\", period_geo / 3600.0);\n\n    // Expected output:\n    // Orbital period (Earth): 5676.977 s\n    // Orbital period (Earth): 94.616 min\n    // Orbital period (general): 5676.977 s\n    // Difference: 0.00e0 s\n\n    // GEO orbital period: 23.934 hours\n}\n</code></pre> <p>The plot below shows how orbital period and velocity vary with altitude for circular Earth orbits:</p> Plot Source fig_orbital_period.py<pre><code>import os\nimport pathlib\nimport sys\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of altitudes from 0 to 40,000 km in 500 km increments\nalt = np.arange(0, 41000 * 1e3, 500 * 1e3)\n\n# Compute velocity over altitude (km/s)\nvp = [bh.perigee_velocity(bh.R_EARTH + a, 0.0) / 1e3 for a in alt]\n\n# Compute orbital period over altitude (hours)\nperiod = [bh.orbital_period(bh.R_EARTH + a) / 3600 for a in alt]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    # Create subplot with secondary y-axis\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n    # Add velocity trace (primary y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=alt / 1e6,\n            y=vp,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n            name=\"Velocity\",\n            showlegend=True,\n        ),\n        secondary_y=False,\n    )\n\n    # Add orbital period trace (secondary y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=alt / 1e6,\n            y=period,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=2),\n            name=\"Orbital Period\",\n            showlegend=True,\n        ),\n        secondary_y=True,\n    )\n\n    # Configure primary x-axis\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=5,\n        title_text=\"Satellite Altitude [1000 km]\",\n        range=[0, 40],\n        showgrid=False,\n    )\n\n    # Configure primary y-axis (velocity)\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=1,\n        title_text=\"Velocity [km/s]\",\n        range=[0, 10],\n        showgrid=False,\n        secondary_y=False,\n    )\n\n    # Configure secondary y-axis (period)\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=5,\n        title_text=\"Orbital Period [hours]\",\n        range=[0, 30],\n        showgrid=False,\n        secondary_y=True,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/properties.html#from-state-vector","title":"From State Vector","text":"<p>When orbital elements are unknown but you have a Cartesian state vector, <code>orbital_period_from_state</code> computes the period directly from position and velocity:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements for a LEO satellite\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\ni = 97.8  # Inclination (degrees)\nraan = 15.0  # Right ascension of ascending node (degrees)\nargp = 30.0  # Argument of periapsis (degrees)\nnu = 45.0  # True anomaly (degrees)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate_eci = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\nprint(\"ECI State (position in km, velocity in km/s):\")\nprint(\n    f\"  r = [{state_eci[0] / 1e3:.3f}, {state_eci[1] / 1e3:.3f}, {state_eci[2] / 1e3:.3f}] km\"\n)\nprint(\n    f\"  v = [{state_eci[3] / 1e3:.3f}, {state_eci[4] / 1e3:.3f}, {state_eci[5] / 1e3:.3f}] km/s\"\n)\n\n# Compute orbital period from state vector\nperiod = bh.orbital_period_from_state(state_eci, bh.GM_EARTH)\nprint(f\"\\nOrbital period from state: {period:.3f} s\")\nprint(f\"Orbital period from state: {period / 60:.3f} min\")\n\n# Verify against period computed from semi-major axis\nperiod_from_sma = bh.orbital_period(a)\nprint(f\"\\nOrbital period from SMA: {period_from_sma:.3f} s\")\nprint(f\"Difference: {abs(period - period_from_sma):.2e} s\")\n\n# Expected output:\n# ECI State (position in km, velocity in km/s):\n#   r = [1848.964, -434.937, 6560.411] km\n#   v = [-7.098, -2.173, 1.913] km/s\n\n# Orbital period from state: 5676.977 s\n# Orbital period from state: 94.616 min\n\n# Orbital period from SMA: 5676.977 s\n# Difference: 3.64e-12 s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements for a LEO satellite\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n    let i = 97.8; // Inclination (degrees)\n    let raan = 15.0; // Right ascension of ascending node (degrees)\n    let argp = 30.0; // Argument of periapsis (degrees)\n    let nu = 45.0; // True anomaly (degrees)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state_eci = bh::state_osculating_to_cartesian(oe, bh::constants::AngleFormat::Degrees);\n\n    println!(\"ECI State (position in km, velocity in km/s):\");\n    println!(\"  r = [{:.3}, {:.3}, {:.3}] km\", state_eci[0]/1e3, state_eci[1]/1e3, state_eci[2]/1e3);\n    println!(\"  v = [{:.3}, {:.3}, {:.3}] km/s\", state_eci[3]/1e3, state_eci[4]/1e3, state_eci[5]/1e3);\n\n    // Compute orbital period from state vector\n    let period = bh::orbits::orbital_period_from_state(&amp;state_eci, bh::constants::GM_EARTH);\n    println!(\"\\nOrbital period from state: {:.3} s\", period);\n    println!(\"Orbital period from state: {:.3} min\", period / 60.0);\n\n    // Verify against period computed from semi-major axis\n    let period_from_sma = bh::orbits::orbital_period(a);\n    println!(\"\\nOrbital period from SMA: {:.3} s\", period_from_sma);\n    println!(\"Difference: {:.2e} s\", (period - period_from_sma).abs());\n\n    // Expected output:\n    // ECI State (position in km, velocity in km/s):\n    // r = [1848.964, -434.937, 6560.411] km\n    // v = [-7.098, -2.173, 1.913] km/s\n\n    // Orbital period from state: 5676.977 s\n    // Orbital period from state: 94.616 min\n\n    // Orbital period from SMA: 5676.977 s\n    // Difference: 3.64e-12 s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#semi-major-axis-from-period","title":"Semi-major Axis from Period","text":"<p>The inverse relationship allows computing semi-major axis when orbital period is known (useful for mission design):</p> \\[ a = \\sqrt[3]{\\frac{\\mu T^2}{4\\pi^2}} \\] PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: LEO satellite with 98-minute period\nperiod_leo = 98 * 60  # 98 minutes in seconds\na_leo = bh.semimajor_axis_from_orbital_period(period_leo)\naltitude_leo = a_leo - bh.R_EARTH\n\nprint(\"LEO Satellite (98 min period):\")\nprint(f\"  Semi-major axis: {a_leo:.3f} m\")\nprint(f\"  Altitude: {altitude_leo / 1e3:.3f} km\")\n\n# Example 2: Geosynchronous orbit (24-hour period)\nperiod_geo = 24 * 3600  # 24 hours in seconds\na_geo = bh.semimajor_axis_from_orbital_period(period_geo)\naltitude_geo = a_geo - bh.R_EARTH\n\nprint(\"\\nGeosynchronous Orbit (24 hour period):\")\nprint(f\"  Semi-major axis: {a_geo:.3f} m\")\nprint(f\"  Altitude: {altitude_geo / 1e3:.3f} km\")\n\n# Example 3: Using general function for Moon orbit\nperiod_moon = 27.3 * 24 * 3600  # 27.3 days in seconds\na_moon = bh.semimajor_axis_from_orbital_period_general(period_moon, bh.GM_EARTH)\n\nprint(\"\\nMoon's orbit (27.3 day period):\")\nprint(f\"  Semi-major axis: {a_moon / 1e3:.3f} km\")\n\n# Verify round-trip conversion\nperiod_verify = bh.orbital_period(a_leo)\nprint(\"\\nRound-trip verification:\")\nprint(f\"  Original period: {period_leo:.3f} s\")\nprint(f\"  Computed period: {period_verify:.3f} s\")\nprint(f\"  Difference: {abs(period_leo - period_verify):.2e} s\")\n\n# Expected output:\n# LEO Satellite (98 min period):\n#   Semi-major axis: 7041160.278 m\n#   Altitude: 663.024 km\n\n# Geosynchronous Orbit (24 hour period):\n#   Semi-major axis: 42241095.664 m\n#   Altitude: 35862.959 km\n\n# Moon's orbit (27.3 day period):\n#   Semi-major axis: 382980.745 km\n\n# Round-trip verification:\n#   Original period: 5880.000 s\n#   Computed period: 5880.000 s\n#   Difference: 8.19e-12 s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: LEO satellite with 98-minute period\n    let period_leo = 98.0 * 60.0; // 98 minutes in seconds\n    let a_leo = bh::orbits::semimajor_axis_from_orbital_period(period_leo);\n    let altitude_leo = a_leo - bh::constants::R_EARTH;\n\n    println!(\"LEO Satellite (98 min period):\");\n    println!(\"  Semi-major axis: {:.3} m\", a_leo);\n    println!(\"  Altitude: {:.3} km\", altitude_leo / 1e3);\n\n    // Example 2: Geosynchronous orbit (24-hour period)\n    let period_geo = 24.0 * 3600.0; // 24 hours in seconds\n    let a_geo = bh::orbits::semimajor_axis_from_orbital_period(period_geo);\n    let altitude_geo = a_geo - bh::constants::R_EARTH;\n\n    println!(\"\\nGeosynchronous Orbit (24 hour period):\");\n    println!(\"  Semi-major axis: {:.3} m\", a_geo);\n    println!(\"  Altitude: {:.3} km\", altitude_geo / 1e3);\n\n    // Example 3: Using general function for Moon orbit\n    let period_moon = 27.3 * 24.0 * 3600.0; // 27.3 days in seconds\n    let a_moon = bh::orbits::semimajor_axis_from_orbital_period_general(period_moon, bh::constants::GM_EARTH);\n\n    println!(\"\\nMoon's orbit (27.3 day period):\");\n    println!(\"  Semi-major axis: {:.3} km\", a_moon / 1e3);\n\n    // Verify round-trip conversion\n    let period_verify = bh::orbits::orbital_period(a_leo);\n    println!(\"\\nRound-trip verification:\");\n    println!(\"  Original period: {:.3} s\", period_leo);\n    println!(\"  Computed period: {:.3} s\", period_verify);\n    println!(\"  Difference: {:.2e} s\", (period_leo - period_verify).abs());\n\n    // Expected output:\n    // LEO Satellite (98 min period):\n    //   Semi-major axis: 7041160.278 m\n    //   Altitude: 663.024 km\n\n    // Geosynchronous Orbit (24 hour period):\n    //   Semi-major axis: 42241095.664 m\n    //   Altitude: 35862.959 km\n\n    // Moon's orbit (27.3 day period):\n    //   Semi-major axis: 382980.745 km\n\n    // Round-trip verification:\n    //   Original period: 5880.000 s\n    //   Computed period: 5880.000 s\n    //   Difference: 8.19e-12 s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#mean-motion","title":"Mean Motion","text":"<p>A satellite's average angular rate over one orbit is its mean motion \\(n\\), calculated from the semi-major axis and gravitational parameter:</p> \\[ n = \\sqrt{\\frac{\\mu}{a^3}} \\] <p>The <code>mean_motion</code> function computes this for Earth-orbiting objects, while <code>mean_motion_general</code> works for any celestial body. Both functions support output in radians or degrees per second via the <code>angle_format</code> parameter.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na_leo = bh.R_EARTH + 500.0e3  # LEO satellite at 500 km altitude\na_geo = bh.R_EARTH + 35786e3  # GEO satellite\n\n# Compute mean motion in radians/s (Earth-specific)\nn_leo_rad = bh.mean_motion(a_leo, bh.AngleFormat.RADIANS)\nn_geo_rad = bh.mean_motion(a_geo, bh.AngleFormat.RADIANS)\n\nprint(\"Mean Motion in radians/second:\")\nprint(f\"  LEO (500 km): {n_leo_rad:.6f} rad/s\")\nprint(f\"  GEO:          {n_geo_rad:.6f} rad/s\")\n\n# Compute mean motion in degrees/s\nn_leo_deg = bh.mean_motion(a_leo, bh.AngleFormat.DEGREES)\nn_geo_deg = bh.mean_motion(a_geo, bh.AngleFormat.DEGREES)\n\nprint(\"\\nMean Motion in degrees/second:\")\nprint(f\"  LEO (500 km): {n_leo_deg:.6f} deg/s\")\nprint(f\"  GEO:          {n_geo_deg:.6f} deg/s\")\n\n# Convert to degrees/day (common unit for TLEs)\nprint(\"\\nMean Motion in degrees/day:\")\nprint(f\"  LEO (500 km): {n_leo_deg * 86400:.3f} deg/day\")\nprint(f\"  GEO:          {n_geo_deg * 86400:.3f} deg/day\")\n\n# Verify using general function\nn_leo_general = bh.mean_motion_general(a_leo, bh.GM_EARTH, bh.AngleFormat.RADIANS)\nprint(f\"\\nVerification (general function): {n_leo_general:.6f} rad/s\")\nprint(f\"Difference: {abs(n_leo_rad - n_leo_general):.2e} rad/s\")\n\n# Expected output:\n# Mean Motion in radians/second:\n#   LEO (500 km): 0.001107 rad/s\n#   GEO:          0.000073 rad/s\n\n# Mean Motion in degrees/second:\n#   LEO (500 km): 0.063414 deg/s\n#   GEO:          0.004178 deg/s\n\n# Mean Motion in degrees/day:\n#   LEO (500 km): 5478.972 deg/day\n#   GEO:          360.986 deg/day\n\n# Verification (general function): 0.001107 rad/s\n# Difference: 0.00e+00 rad/s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a_leo = bh::constants::R_EARTH + 500.0e3; // LEO satellite at 500 km altitude\n    let a_geo = bh::constants::R_EARTH + 35786e3; // GEO satellite\n\n    // Compute mean motion in radians/s (Earth-specific)\n    let n_leo_rad = bh::orbits::mean_motion(a_leo, bh::constants::AngleFormat::Radians);\n    let n_geo_rad = bh::orbits::mean_motion(a_geo, bh::constants::AngleFormat::Radians);\n\n    println!(\"Mean Motion in radians/second:\");\n    println!(\"  LEO (500 km): {:.6} rad/s\", n_leo_rad);\n    println!(\"  GEO:          {:.6} rad/s\", n_geo_rad);\n\n    // Compute mean motion in degrees/s\n    let n_leo_deg = bh::orbits::mean_motion(a_leo, bh::constants::AngleFormat::Degrees);\n    let n_geo_deg = bh::orbits::mean_motion(a_geo, bh::constants::AngleFormat::Degrees);\n\n    println!(\"\\nMean Motion in degrees/second:\");\n    println!(\"  LEO (500 km): {:.6} deg/s\", n_leo_deg);\n    println!(\"  GEO:          {:.6} deg/s\", n_geo_deg);\n\n    // Convert to degrees/day (common unit for TLEs)\n    println!(\"\\nMean Motion in degrees/day:\");\n    println!(\"  LEO (500 km): {:.3} deg/day\", n_leo_deg * 86400.0);\n    println!(\"  GEO:          {:.3} deg/day\", n_geo_deg * 86400.0);\n\n    // Verify using general function\n    let n_leo_general = bh::orbits::mean_motion_general(a_leo, bh::constants::GM_EARTH, bh::constants::AngleFormat::Radians);\n    println!(\"\\nVerification (general function): {:.6} rad/s\", n_leo_general);\n    println!(\"Difference: {:.2e} rad/s\", (n_leo_rad - n_leo_general).abs());\n\n    // Expected output:\n    // Mean Motion in radians/second:\n    //   LEO (500 km): 0.001107 rad/s\n    //   GEO:          0.000073 rad/s\n\n    // Mean Motion in degrees/second:\n    //   LEO (500 km): 0.063414 deg/s\n    //   GEO:          0.004178 deg/s\n\n    // Mean Motion in degrees/day:\n    //   LEO (500 km): 5478.972 deg/day\n    //   GEO:          360.986 deg/day\n\n    // Verification (general function): 0.001107 rad/s\n    // Difference: 0.00e+00 rad/s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#semi-major-axis-from-mean-motion","title":"Semi-major Axis from Mean Motion","text":"<p>Since orbital data formats like TLEs specify mean motion instead of semi-major axis, the inverse computation is essential:</p> \\[ a = \\sqrt[3]{\\frac{\\mu}{n^2}} \\] PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: ISS-like orbit with ~15.5 revolutions per day\nn_iss = 15.5 * 360.0 / 86400.0  # Convert revs/day to deg/s\na_iss = bh.semimajor_axis(n_iss, bh.AngleFormat.DEGREES)\naltitude_iss = a_iss - bh.R_EARTH\n\nprint(\"ISS-like Orbit (15.5 revs/day):\")\nprint(f\"  Mean motion: {n_iss:.6f} deg/s\")\nprint(f\"  Semi-major axis: {a_iss:.3f} m\")\nprint(f\"  Altitude: {altitude_iss / 1e3:.3f} km\")\n\n# Example 2: Geosynchronous orbit (1 revolution per day)\nn_geo = 1.0 * 360.0 / 86400.0  # 1 rev/day in deg/s\na_geo = bh.semimajor_axis(n_geo, bh.AngleFormat.DEGREES)\naltitude_geo = a_geo - bh.R_EARTH\n\nprint(\"\\nGeosynchronous Orbit (1 rev/day):\")\nprint(f\"  Mean motion: {n_geo:.6f} deg/s\")\nprint(f\"  Semi-major axis: {a_geo:.3f} m\")\nprint(f\"  Altitude: {altitude_geo / 1e3:.3f} km\")\n\n# Example 3: Using radians\nn_leo_rad = 0.001  # rad/s\na_leo = bh.semimajor_axis(n_leo_rad, bh.AngleFormat.RADIANS)\n\nprint(\"\\nLEO from radians/s:\")\nprint(f\"  Mean motion: {n_leo_rad:.6f} rad/s\")\nprint(f\"  Semi-major axis: {a_leo:.3f} m\")\nprint(f\"  Altitude: {(a_leo - bh.R_EARTH) / 1e3:.3f} km\")\n\n# Verify round-trip conversion\nn_verify = bh.mean_motion(a_iss, bh.AngleFormat.DEGREES)\nprint(\"\\nRound-trip verification:\")\nprint(f\"  Original mean motion: {n_iss:.6f} deg/s\")\nprint(f\"  Computed mean motion: {n_verify:.6f} deg/s\")\nprint(f\"  Difference: {abs(n_iss - n_verify):.2e} deg/s\")\n\n# Expected output:\n# ISS-like Orbit (15.5 revs/day):\n#   Mean motion: 0.064583 deg/s\n#   Semi-major axis: 6794863.068 m\n#   Altitude: 416.727 km\n\n# Geosynchronous Orbit (1 rev/day):\n#   Mean motion: 0.004167 deg/s\n#   Semi-major axis: 42241095.664 m\n#   Altitude: 35862.959 km\n\n# LEO from radians/s:\n#   Mean motion: 0.001000 rad/s\n#   Semi-major axis: 7359459.593 m\n#   Altitude: 981.323 km\n\n# Round-trip verification:\n#   Original mean motion: 0.064583 deg/s\n#   Computed mean motion: 0.064583 deg/s\n#   Difference: 9.71e-17 deg/s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: ISS-like orbit with ~15.5 revolutions per day\n    let n_iss = 15.5 * 360.0 / 86400.0; // Convert revs/day to deg/s\n    let a_iss = bh::orbits::semimajor_axis(n_iss, bh::constants::AngleFormat::Degrees);\n    let altitude_iss = a_iss - bh::constants::R_EARTH;\n\n    println!(\"ISS-like Orbit (15.5 revs/day):\");\n    println!(\"  Mean motion: {:.6} deg/s\", n_iss);\n    println!(\"  Semi-major axis: {:.3} m\", a_iss);\n    println!(\"  Altitude: {:.3} km\", altitude_iss / 1e3);\n\n    // Example 2: Geosynchronous orbit (1 revolution per day)\n    let n_geo = 1.0 * 360.0 / 86400.0; // 1 rev/day in deg/s\n    let a_geo = bh::orbits::semimajor_axis(n_geo, bh::constants::AngleFormat::Degrees);\n    let altitude_geo = a_geo - bh::constants::R_EARTH;\n\n    println!(\"\\nGeosynchronous Orbit (1 rev/day):\");\n    println!(\"  Mean motion: {:.6} deg/s\", n_geo);\n    println!(\"  Semi-major axis: {:.3} m\", a_geo);\n    println!(\"  Altitude: {:.3} km\", altitude_geo / 1e3);\n\n    // Example 3: Using radians\n    let n_leo_rad = 0.001; // rad/s\n    let a_leo = bh::orbits::semimajor_axis(n_leo_rad, bh::constants::AngleFormat::Radians);\n\n    println!(\"\\nLEO from radians/s:\");\n    println!(\"  Mean motion: {:.6} rad/s\", n_leo_rad);\n    println!(\"  Semi-major axis: {:.3} m\", a_leo);\n    println!(\"  Altitude: {:.3} km\", (a_leo - bh::constants::R_EARTH) / 1e3);\n\n    // Verify round-trip conversion\n    let n_verify = bh::orbits::mean_motion(a_iss, bh::constants::AngleFormat::Degrees);\n    println!(\"\\nRound-trip verification:\");\n    println!(\"  Original mean motion: {:.6} deg/s\", n_iss);\n    println!(\"  Computed mean motion: {:.6} deg/s\", n_verify);\n    println!(\"  Difference: {:.2e} deg/s\", (n_iss - n_verify).abs());\n\n    // Expected output:\n    // ISS-like Orbit (15.5 revs/day):\n    //   Mean motion: 0.064583 deg/s\n    //   Semi-major axis: 6794863.068 m\n    //   Altitude: 416.727 km\n\n    // Geosynchronous Orbit (1 rev/day):\n    //   Mean motion: 0.004167 deg/s\n    //   Semi-major axis: 42241095.664 m\n    //   Altitude: 35862.959 km\n\n    // LEO from radians/s:\n    //   Mean motion: 0.001000 rad/s\n    //   Semi-major axis: 7359459.593 m\n    //   Altitude: 981.323 km\n\n    // Round-trip verification:\n    //   Original mean motion: 0.064583 deg/s\n    //   Computed mean motion: 0.064583 deg/s\n    //   Difference: 9.71e-17 deg/s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#periapsis-properties","title":"Periapsis Properties","text":"<p>The periapsis is the point of closest approach to the central body, where orbital velocity is greatest.</p> Info <p>The word periapsis is formed by combination of the Greek words \"peri-\" (meaning around, about) and \"apsis\" (meaning \"arch or vault\"). An apsis is the farthest or nearest point in the orbit of a planetary body about its primary body.</p> <p>Therefore periapsis is the point of closest approach of the orbiting body with respect to its central body. The suffix can be modified to indicate the closest approach to a specific celestial body: perigee for Earth, perihelion for the Sun.</p> <p>Brahe provides functions to compute periapsis velocity, distance, and altitude based on orbital elements.</p>"},{"location":"learn/orbits/properties.html#velocity","title":"Velocity","text":"<p>The periapsis velocity is given by:</p> \\[ v_{p} = \\sqrt{\\frac{\\mu}{a}}\\sqrt{\\frac{1+e}{1-e}} \\] <p>where \\(\\mu\\) is the gravitational parameter, \\(a\\) is the semi-major axis, and \\(e\\) is the eccentricity.</p>"},{"location":"learn/orbits/properties.html#distance","title":"Distance","text":"<p>The periapsis distance from the center of the central body is (from Vallado<sup>1</sup> Equation 2-75):</p> \\[ r_p = \\frac{a(1-e^2)}{1+e} = a(1-e) \\]"},{"location":"learn/orbits/properties.html#altitude","title":"Altitude","text":"<p>The periapsis altitude is the height above the surface of the central body:</p> \\[ h_p = r_p - R_{body} = a(1-e) - R_{body} \\] <p>where \\(R_{body}\\) is the radius of the central body. For Earth orbits, the <code>perigee_altitude</code> function provides a convenient wrapper using \\(R_{\\oplus}\\).</p>"},{"location":"learn/orbits/properties.html#code-example","title":"Code Example","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\n\n# Compute periapsis velocity (generic)\nperiapsis_velocity = bh.periapsis_velocity(a, e, gm=bh.GM_EARTH)\nprint(f\"Periapsis velocity: {periapsis_velocity:.3f} m/s\")\n\n# Compute as a perigee velocity (Earth-specific)\nperigee_velocity = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity:   {perigee_velocity:.3f} m/s\")\n\n# Compute periapsis distance\nperiapsis_distance = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {periapsis_distance / 1e3:.3f} km\")\n\n# Compute periapsis altitude (generic)\nperiapsis_altitude = bh.periapsis_altitude(a, e, r_body=bh.R_EARTH)\nprint(f\"Periapsis altitude: {periapsis_altitude / 1e3:.3f} km\")\n\n# Compute as a perigee altitude (Earth-specific)\nperigee_altitude = bh.perigee_altitude(a, e)\nprint(f\"Perigee altitude:   {perigee_altitude / 1e3:.3f} km\")\n\n# Expected output:\n# Periapsis velocity: 7689.119 m/s\n# Perigee velocity:   7689.119 m/s\n# Periapsis distance: 6809.355 km\n# Periapsis altitude: 431.219 km\n# Perigee altitude:   431.219 km\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n\n    // Compute periapsis velocity (generic)\n    let periapsis_velocity = bh::orbits::periapsis_velocity(a, e, bh::constants::GM_EARTH);\n    println!(\"Periapsis velocity: {:.3} m/s\", periapsis_velocity);\n\n    // Compute as a perigee velocity (Earth-specific)\n    let perigee_velocity = bh::orbits::perigee_velocity(a, e);\n    println!(\"Perigee velocity:   {:.3} m/s\", perigee_velocity);\n\n    // Compute periapsis distance\n    let periapsis_distance = bh::orbits::periapsis_distance(a, e);\n    println!(\"Periapsis distance: {:.3} km\", periapsis_distance / 1e3);\n\n    // Compute periapsis altitude (generic)\n    let periapsis_altitude = bh::orbits::periapsis_altitude(a, e, bh::constants::R_EARTH);\n    println!(\"Periapsis altitude: {:.3} km\", periapsis_altitude / 1e3);\n\n    // Compute as a perigee altitude (Earth-specific)\n    let perigee_altitude = bh::orbits::perigee_altitude(a, e);\n    println!(\"Perigee altitude:   {:.3} km\", perigee_altitude / 1e3);\n\n    // Expected output:\n    // Periapsis velocity: 7689.119 m/s\n    // Perigee velocity:   7689.119 m/s\n    // Periapsis distance: 6809.355 km\n    // Periapsis altitude: 431.219 km\n    // Perigee altitude:   431.219 km\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#apoapsis-properties","title":"Apoapsis Properties","text":"<p>The apoapsis is the farthest point from the central body, where orbital velocity is lowest.</p> Info <p>The word apoapsis is formed by combination of the Greek words \"apo-\" (meaning away from, separate, or apart from) and \"apsis\".</p> <p>Therefore apoapsis is the farthest point of an orbiting body with respect to its central body. The suffix can be modified to indicate the farthest point from a specific celestial body: apogee for Earth, aphelion for the Sun.</p> <p>Brahe provides functions to compute apoapsis velocity, distance, and altitude based on orbital elements.</p> <p>Warning</p> <p>Apoapsis position, velocity, and altitude are only defined for elliptic and circular orbits. For parabolic and hyperbolic orbits, these quantities are undefined.</p>"},{"location":"learn/orbits/properties.html#velocity_1","title":"Velocity","text":"<p>The apoapsis velocity is given by:</p> \\[ v_{a} = \\sqrt{\\frac{\\mu}{a}}\\sqrt{\\frac{1-e}{1+e}} \\]"},{"location":"learn/orbits/properties.html#distance_1","title":"Distance","text":"<p>The apoapsis distance from the center of the central body is:</p> \\[ r_a = \\frac{a(1-e^2)}{1-e} = a(1+e) \\]"},{"location":"learn/orbits/properties.html#altitude_1","title":"Altitude","text":"<p>The apoapsis altitude is the height above the surface of the central body:</p> \\[ h_a = r_a - R_{body} = a(1+e) - R_{body} \\] <p>where \\(R_{body}\\) is the radius of the central body. For Earth orbits, the <code>apogee_altitude</code> function provides a convenient wrapper using \\(R_{\\oplus}\\).</p>"},{"location":"learn/orbits/properties.html#code-example_1","title":"Code Example","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\n\n# Compute apoapsis velocity (generic)\napoapsis_velocity = bh.apoapsis_velocity(a, e, gm=bh.GM_EARTH)\nprint(f\"Apoapsis velocity: {apoapsis_velocity:.3f} m/s\")\n\n# Compute as an apogee velocity (Earth-specific)\napogee_velocity = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity:   {apogee_velocity:.3f} m/s\")\n\n# Compute apoapsis distance\napoapsis_distance = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {apoapsis_distance / 1e3:.3f} km\")\n\n# Compute apoapsis altitude (generic)\napoapsis_altitude = bh.apoapsis_altitude(a, e, r_body=bh.R_EARTH)\nprint(f\"Apoapsis altitude: {apoapsis_altitude / 1e3:.3f} km\")\n\n# Compute as an apogee altitude (Earth-specific)\napogee_altitude = bh.apogee_altitude(a, e)\nprint(f\"Apogee altitude:   {apogee_altitude / 1e3:.3f} km\")\n\n# Expected output:\n# Apoapsis velocity: 7536.859 m/s\n# Apogee velocity:   7536.859 m/s\n# Apoapsis distance: 6946.918 km\n# Apoapsis altitude: 568.781 km\n# Apogee altitude:   568.781 km\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n\n    // Compute apoapsis velocity (generic)\n    let apoapsis_velocity = bh::orbits::apoapsis_velocity(a, e, bh::constants::GM_EARTH);\n    println!(\"Apoapsis velocity: {:.3} m/s\", apoapsis_velocity);\n\n    // Compute as an apogee velocity (Earth-specific)\n    let apogee_velocity = bh::orbits::apogee_velocity(a, e);\n    println!(\"Apogee velocity:   {:.3} m/s\", apogee_velocity);\n\n    // Compute apoapsis distance\n    let apoapsis_distance = bh::orbits::apoapsis_distance(a, e);\n    println!(\"Apoapsis distance: {:.3} km\", apoapsis_distance / 1e3);\n\n    // Compute apoapsis altitude (generic)\n    let apoapsis_altitude = bh::orbits::apoapsis_altitude(a, e, bh::constants::R_EARTH);\n    println!(\"Apoapsis altitude: {:.3} km\", apoapsis_altitude / 1e3);\n\n    // Compute as an apogee altitude (Earth-specific)\n    let apogee_altitude = bh::orbits::apogee_altitude(a, e);\n    println!(\"Apogee altitude:   {:.3} km\", apogee_altitude / 1e3);\n\n    // Expected output:\n    // Apoapsis velocity: 7536.859 m/s\n    // Apogee velocity:   7536.859 m/s\n    // Apoapsis distance: 6946.918 km\n    // Apoapsis altitude: 568.781 km\n    // Apogee altitude:   568.781 km\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#sun-synchronous-inclination","title":"Sun-Synchronous Inclination","text":"<p>A sun-synchronous orbit maintains a constant angle relative to the Sun by matching its nodal precession rate to Earth's annual revolution. The right ascension of the ascending node (\\(\\Omega\\)) advances at the same rate as the Sun's apparent motion: approximately 0.9856\u00b0/day. This configuration is highly valuable for Earth observation satellites requiring consistent illumination conditions\u2014a sun-synchronous satellite crosses the equator at the same local time on each pass (e.g., always at 2 PM).</p> <p>Earth's oblateness, characterized by the \\(J_2\\) zonal harmonic, causes secular drift in \\(\\Omega\\):</p> \\[ \\dot{\\Omega} = -\\frac{3nR^2_EJ_2}{2a^2(1-e^2)^2}\\cos{i} \\] <p>For sun-synchronicity, this must equal:</p> \\[ \\dot{\\Omega}_{ss} = \\frac{360\u00b0}{1 \\text{ year}} = 0.9856473598\u00b0/\\text{day} \\] <p>Solving for inclination as a function of semi-major axis and eccentricity:</p> \\[ i = \\arccos{\\left(-\\frac{2a^{7/2}\\dot{\\Omega}_{ss}(1-e^2)^2}{3R^2_EJ_2\\sqrt{\\mu}}\\right)} \\] <p>The <code>sun_synchronous_inclination</code> function computes this required inclination:</p> PythonRust <pre><code>\"\"\"\n\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: Typical sun-synchronous LEO at 800 km altitude\na_leo = bh.R_EARTH + 800e3  # Semi-major axis\ne_leo = 0.0  # Circular orbit\n\ninc_leo_deg = bh.sun_synchronous_inclination(\n    a_leo, e_leo, angle_format=bh.AngleFormat.DEGREES\n)\ninc_leo_rad = bh.sun_synchronous_inclination(\n    a_leo, e_leo, angle_format=bh.AngleFormat.RADIANS\n)\n\nprint(\"Sun-synchronous LEO (800 km, circular):\")\nprint(f\"  Inclination: {inc_leo_deg:.3f} degrees\")\nprint(f\"  Inclination: {inc_leo_rad:.6f} radians\")\n\n# Example 2: Different altitudes\naltitudes = [500, 600, 700, 800, 900, 1000]  # km\nprint(\"\\nSun-synchronous inclination vs altitude (circular orbits):\")\nfor alt_km in altitudes:\n    a = bh.R_EARTH + alt_km * 1e3\n    inc = bh.sun_synchronous_inclination(a, 0.0, angle_format=bh.AngleFormat.DEGREES)\n    print(f\"  {alt_km:4d} km: {inc:.3f} deg\")\n\n# Example 3: Effect of eccentricity\na_fixed = bh.R_EARTH + 700e3\neccentricities = [0.0, 0.001, 0.005, 0.01, 0.02]\n\nprint(\"\\nSun-synchronous inclination vs eccentricity (700 km orbit):\")\nfor e in eccentricities:\n    inc = bh.sun_synchronous_inclination(\n        a_fixed, e, angle_format=bh.AngleFormat.DEGREES\n    )\n    print(f\"  e = {e:.3f}: {inc:.3f} deg\")\n\n# Example 4: Practical mission example (Landsat-like)\na_landsat = bh.R_EARTH + 705e3\ne_landsat = 0.0001\ninc_landsat = bh.sun_synchronous_inclination(\n    a_landsat, e_landsat, angle_format=bh.AngleFormat.DEGREES\n)\n\nprint(\"\\nLandsat-like orbit (705 km, nearly circular):\")\nprint(f\"  Inclination: {inc_landsat:.3f} deg\")\nprint(f\"  Period: {bh.orbital_period(a_landsat) / 60:.3f} min\")\n\n# Expected output:\n# Sun-synchronous LEO (800 km, circular):\n#   Inclination: 98.603 degrees\n#   Inclination: 1.720948 radians\n\n# Sun-synchronous inclination vs altitude (circular orbits):\n#    500 km: 97.402 deg\n#    600 km: 97.788 deg\n#    700 km: 98.188 deg\n#    800 km: 98.603 deg\n#    900 km: 99.033 deg\n#   1000 km: 99.479 deg\n\n# Sun-synchronous inclination vs eccentricity (700 km orbit):\n#   e = 0.000: 98.188 deg\n#   e = 0.001: 98.188 deg\n#   e = 0.005: 98.187 deg\n#   e = 0.010: 98.186 deg\n#   e = 0.020: 98.181 deg\n\n# Landsat-like orbit (705 km, nearly circular):\n#   Inclination: 98.208 deg\n#   Period: 98.878 min\n</code></pre> <pre><code>#[allow(unused_imports)]\nuse brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: Typical sun-synchronous LEO at 800 km altitude\n    let a_leo = bh::constants::R_EARTH + 800e3; // Semi-major axis\n    let e_leo = 0.0; // Circular orbit\n\n    let inc_leo_deg = bh::orbits::sun_synchronous_inclination(a_leo, e_leo, bh::constants::AngleFormat::Degrees);\n    let inc_leo_rad = bh::orbits::sun_synchronous_inclination(a_leo, e_leo, bh::constants::AngleFormat::Radians);\n\n    println!(\"Sun-synchronous LEO (800 km, circular):\");\n    println!(\"  Inclination: {:.3} degrees\", inc_leo_deg);\n    println!(\"  Inclination: {:.6} radians\", inc_leo_rad);\n\n    // Example 2: Different altitudes\n    let altitudes = [500.0, 600.0, 700.0, 800.0, 900.0, 1000.0]; // km\n    println!(\"\\nSun-synchronous inclination vs altitude (circular orbits):\");\n    for alt_km in altitudes.iter() {\n        let a = bh::constants::R_EARTH + alt_km * 1e3;\n        let inc = bh::orbits::sun_synchronous_inclination(a, 0.0, bh::constants::AngleFormat::Degrees);\n        println!(\"  {:4} km: {:.3} deg\", *alt_km as i32, inc);\n    }\n\n    // Example 3: Effect of eccentricity\n    let a_fixed = bh::constants::R_EARTH + 700e3;\n    let eccentricities = [0.0, 0.001, 0.005, 0.01, 0.02];\n\n    println!(\"\\nSun-synchronous inclination vs eccentricity (700 km orbit):\");\n    for e in eccentricities.iter() {\n        let inc = bh::orbits::sun_synchronous_inclination(a_fixed, *e, bh::constants::AngleFormat::Degrees);\n        println!(\"  e = {:.3}: {:.3} deg\", e, inc);\n    }\n\n    // Example 4: Practical mission example (Landsat-like)\n    let a_landsat = bh::constants::R_EARTH + 705e3;\n    let e_landsat = 0.0001;\n    let inc_landsat = bh::orbits::sun_synchronous_inclination(a_landsat, e_landsat, bh::constants::AngleFormat::Degrees);\n\n    println!(\"\\nLandsat-like orbit (705 km, nearly circular):\");\n    println!(\"  Inclination: {:.3} deg\", inc_landsat);\n    println!(\"  Period: {:.3} min\", bh::orbits::orbital_period(a_landsat) / 60.0);\n\n    // Expected output:\n    // Sun-synchronous LEO (800 km, circular):\n    //   Inclination: 98.603 degrees\n    //   Inclination: 1.720948 radians\n\n    // Sun-synchronous inclination vs altitude (circular orbits):\n    //    500 km: 97.402 deg\n    //    600 km: 97.788 deg\n    //    700 km: 98.188 deg\n    //    800 km: 98.603 deg\n    //    900 km: 99.033 deg\n    //   1000 km: 99.479 deg\n\n    // Sun-synchronous inclination vs eccentricity (700 km orbit):\n    //   e = 0.000: 98.188 deg\n    //   e = 0.001: 98.188 deg\n    //   e = 0.005: 98.187 deg\n    //   e = 0.010: 98.186 deg\n    //   e = 0.020: 98.181 deg\n\n    // Landsat-like orbit (705 km, nearly circular):\n    //   Inclination: 98.208 deg\n    //   Period: 98.878 min\n}\n</code></pre> <p>The plot below shows how the required inclination varies with altitude for sun-synchronous orbits:</p> Plot Source fig_sun_synchronous_inclination.py<pre><code>import os\nimport pathlib\nimport sys\nimport numpy as np\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of altitudes from 300 to 1000 km in 1 km increments\nalt = np.arange(300e3, 1000e3, 1e3)\n\n# Compute sun-synchronous inclination for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5]\nssi_data = {}\nfor e in eccentricities:\n    ssi_data[e] = [\n        bh.sun_synchronous_inclination(\n            bh.R_EARTH + a, e, angle_format=bh.AngleFormat.DEGREES\n        )\n        for a in alt\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=alt / 1e3,\n                y=ssi_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=300,\n        dtick=100,\n        title_text=\"Satellite Altitude [km]\",\n        range=[300, 1000],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        title_text=\"Inclination [deg]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>Most sun-synchronous Earth observation missions operate at altitudes between 500-1000 km with near-zero eccentricity. The launch provider selects the precise inclination based on the above equation to achieve the desired sun-synchronous behavior.</p>"},{"location":"learn/orbits/properties.html#see-also","title":"See Also","text":"<ul> <li>Orbits API Reference - Complete Python API documentation</li> <li>Anomaly Conversions - Converting between true, eccentric, and mean anomaly</li> </ul> <ol> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/orbits/two_line_elements.html","title":"Two-Line Elements (TLE)","text":"<p>Two-Line Element sets (TLEs) are a standardized format for representing satellite orbital data. Originally developed by NORAD (North American Aerospace Defense Command), TLEs encode an epoch, Keplerian orbital elements, and additional parameters needed for SGP4/SDP4 propagation into two 69-character ASCII lines.</p> <p>An example of a TLE set for the International Space Station (ISS) is:</p> <pre><code>1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\n2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\n</code></pre> <p>TLEs are still widely used for satellite tracking and orbit prediction, distributed by organizations like CelesTrak and Space-Track.</p> <p>For additional information on the TLE format and field definitions, see the CelesTrak TLE documentation or the Wikipedia TLE article.</p> <p>For complete API documentation, see the TLE reference.</p> <p>TLE Accuracy Limitations</p> <p>TLEs are designed for near-Earth satellites and have limited accuracy due to simplifications in the SGP4/SDP4 models. They ARE NOT suitable for high-precision orbit determination or long-term predictions.</p> <p>NORAID ID Exhaustion</p> <p>TLEs were originally designed for a maximum of 99,999 cataloged objects. However with the rise of mega-constellations and recent anti-satellite tests by Russia and China, the number of tracked objects is rapidly approaching this limit. </p> <p>The Alpha-5 NORAD ID format extends the range by using letters A-Z (excluding I and O) as the leading character, allowing for up to 339,999 objects. This is a temporary solution however, and generally organizations should plan to transition to using formats like General Perturbations (GP) elements, CCSDS Orbit Ephemeris Messages (OEM), or other modern representations.</p> <p>A common variant of TLEs is the Three-Line Element set (3LE), which adds a title line above the standard two lines for the object name. Brahe's TLE functions work with both TLE and 3LE formats interchangeably.</p> <p>The same TLE data in 3LE format would be:</p> <pre><code>ISS (ZARYA)             \n1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\n2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#validating-tles","title":"Validating TLEs","text":"<p>Before parsing TLE data, you can validate the format and checksums to ensure data integrity.</p>"},{"location":"learn/orbits/two_line_elements.html#validating-a-tle-set","title":"Validating a TLE Set","text":"PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Validate the complete TLE set (both lines must have matching NORAD IDs)\nis_valid = bh.validate_tle_lines(line1, line2)\nprint(f\"TLE set valid: {is_valid}\")\n\n# Validate individual lines\nline1_valid = bh.validate_tle_line(line1)\nline2_valid = bh.validate_tle_line(line2)\nprint(f\"Line 1 valid: {line1_valid}\")\nprint(f\"Line 2 valid: {line2_valid}\")\n\n# Expected output:\n# TLE set valid: True\n# Line 1 valid: True\n# Line 2 valid: True\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Validate the complete TLE set (both lines must have matching NORAD IDs)\n    let is_valid = bh::validate_tle_lines(line1, line2);\n    println!(\"TLE set valid: {}\", is_valid);\n\n    // Validate individual lines\n    let line1_valid = bh::validate_tle_line(line1);\n    let line2_valid = bh::validate_tle_line(line2);\n    println!(\"Line 1 valid: {}\", line1_valid);\n    println!(\"Line 2 valid: {}\", line2_valid);\n\n    // Expected output:\n    // TLE set valid: true\n    // Line 1 valid: true\n    // Line 2 valid: true\n}\n</code></pre> <p>The <code>validate_tle_lines</code> function checks that both lines have the correct format, valid checksums, and matching NORAD catalog numbers.</p>"},{"location":"learn/orbits/two_line_elements.html#calculating-checksums","title":"Calculating Checksums","text":"<p>Each TLE line ends with a modulo-10 checksum. You can calculate this checksum to verify data integrity or when creating custom TLEs:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Calculate checksums for each line\nchecksum1 = bh.calculate_tle_line_checksum(line1)\nchecksum2 = bh.calculate_tle_line_checksum(line2)\nprint(f\"Line 1 checksum: {checksum1}\")\nprint(f\"Line 2 checksum: {checksum2}\")\n\n# Example with corrupted TLE (wrong checksum)\ncorrupted_line1 = (\n    \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9990\"\n)\nis_corrupted_valid = bh.validate_tle_line(corrupted_line1)\nprint(f\"\\nCorrupted line valid: {is_corrupted_valid}\")\n\n# Expected output:\n# Line 1 checksum: 5\n# Line 2 checksum: 9\n#\n# Corrupted line valid: False\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Calculate checksums for each line\n    let checksum1 = bh::calculate_tle_line_checksum(line1);\n    let checksum2 = bh::calculate_tle_line_checksum(line2);\n    println!(\"Line 1 checksum: {}\", checksum1);\n    println!(\"Line 2 checksum: {}\", checksum2);\n\n    // Example with corrupted TLE (wrong checksum)\n    let corrupted_line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9990\";\n    let is_corrupted_valid = bh::validate_tle_line(corrupted_line1);\n    println!(\"\\nCorrupted line valid: {}\", is_corrupted_valid);\n\n    // Expected output:\n    // Line 1 checksum: 5\n    // Line 2 checksum: 9\n    //\n    // Corrupted line valid: false\n}\n</code></pre> <p>Checksum Algorithm</p> <p>The checksum is calculated by summing all digits in the line (treating minus signs as 1) and taking the result modulo 10. All other characters (letters, spaces, periods) are ignored in the checksum calculation.</p>"},{"location":"learn/orbits/two_line_elements.html#parsing-tles","title":"Parsing TLEs","text":""},{"location":"learn/orbits/two_line_elements.html#extracting-orbital-elements","title":"Extracting Orbital Elements","text":"<p>The most common operation is parsing a TLE to extract the epoch and orbital elements:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Parse TLE to extract epoch and orbital elements\nepoch, elements = bh.keplerian_elements_from_tle(line1, line2)\n\n# Extract individual orbital elements\n# Note: Angles are returned in degrees (exception to library convention)\na = elements[0]  # Semi-major axis (m)\ne = elements[1]  # Eccentricity\ni = elements[2]  # Inclination (deg)\nraan = elements[3]  # Right Ascension of Ascending Node (deg)\nargp = elements[4]  # Argument of Periapsis (deg)\nM = elements[5]  # Mean Anomaly (deg)\n\nprint(f\"ISS Orbital Elements (Epoch: {epoch})\")\nprint(f\"  Semi-major axis: {a / 1000:.3f} km\")\nprint(f\"  Eccentricity: {e:.6f}\")\nprint(f\"  Inclination: {i:.4f} deg\")\nprint(f\"  RAAN: {raan:.4f} deg\")\nprint(f\"  Arg of Perigee: {argp:.4f} deg\")\nprint(f\"  Mean Anomaly: {M:.4f} deg\")\n\n# Expected output:\n# ISS Orbital Elements (Epoch: 2025-10-29 11:44:55.862 UTC)\n#   Semi-major axis: 6796.092 km\n#   Eccentricity: 0.000481\n#   Inclination: 51.6347 deg\n#   RAAN: 1.5519 deg\n#   Arg of Perigee: 353.3325 deg\n#   Mean Anomaly: 6.7599 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Parse TLE to extract epoch and orbital elements\n    let (epoch, elements) = bh::keplerian_elements_from_tle(line1, line2).unwrap();\n\n    // Extract individual orbital elements\n    let a = elements[0];  // Semi-major axis (m)\n    let e = elements[1];  // Eccentricity\n    let i = elements[2];  // Inclination (deg)\n    let raan = elements[3];  // Right Ascension of Ascending Node (deg)\n    let argp = elements[4];  // Argument of Periapsis (deg)\n    let mean_anom = elements[5];  // Mean Anomaly (deg)\n\n    println!(\"ISS Orbital Elements (Epoch: {})\", epoch);\n    println!(\"  Semi-major axis: {:.3} km\", a / 1000.0);\n    println!(\"  Eccentricity: {:.6}\", e);\n    println!(\"  Inclination: {:.4} deg\", i);\n    println!(\"  RAAN: {:.4} deg\", raan);\n    println!(\"  Arg of Perigee: {:.4} deg\", argp);\n    println!(\"  Mean Anomaly: {:.4} deg\", mean_anom);\n\n    // Expected output:\n    // ISS Orbital Elements (Epoch: 2025-10-29 11:44:55.862 UTC)\n    //   Semi-major axis: 6796.092 km\n    //   Eccentricity: 0.000481\n    //   Inclination: 51.6347 deg\n    //   RAAN: 1.5519 deg\n    //   Arg of Perigee: 353.3325 deg\n    //   Mean Anomaly: 6.7599 deg\n}\n</code></pre> <p>The returned elements follow the standard Brahe order: <code>[a, e, i, \u03a9, \u03c9, M]</code> where:</p> <ul> <li>\\(a\\) - Semi-major axis (meters)</li> <li>\\(e\\) - Eccentricity (dimensionless)</li> <li>\\(i\\) - Inclination (degrees)</li> <li>\\(\\Omega\\) - Right Ascension of Ascending Node (degrees)</li> <li>\\(\\omega\\) - Argument of Periapsis (degrees)</li> <li>\\(M\\) - Mean Anomaly (degrees)</li> </ul> <p>Angle Units Convention</p> <p>TLE functions use degrees for all angles. This matches the TLE format standard and makes it easier to work with TLE data directly.</p>"},{"location":"learn/orbits/two_line_elements.html#extracting-just-the-epoch","title":"Extracting Just the Epoch","text":"<p>If you only need the epoch timestamp without the full orbital elements:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\n\n# Extract epoch from line 1 (epoch is encoded in line 1 only)\nepoch = bh.epoch_from_tle(line1)\n\nprint(f\"TLE Epoch: {epoch}\")\nprint(f\"Time System: {epoch.time_system}\")\n\n# Expected output:\n# TLE Epoch: 2025-10-29 11:44:55.862 UTC\n# Time System: UTC\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n\n    // Extract epoch from line 1 (epoch is encoded in line 1 only)\n    let epoch = bh::epoch_from_tle(line1).unwrap();\n\n    println!(\"TLE Epoch: {}\", epoch);\n    println!(\"Time System: {:?}\", epoch.time_system);\n\n    // Expected output:\n    // TLE Epoch: 2025-10-29 11:44:55.862 UTC\n    // Time System: UTC\n}\n</code></pre> <p>The epoch is always returned in the UTC time system.</p>"},{"location":"learn/orbits/two_line_elements.html#creating-tles","title":"Creating TLEs","text":""},{"location":"learn/orbits/two_line_elements.html#from-keplerian-elements","title":"From Keplerian Elements","text":"<p>You can generate TLE lines from an epoch and mean orbital elements:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital epoch\nepoch = bh.Epoch.from_datetime(2025, 10, 29, 11, 44, 55.766182, 0, bh.TimeSystem.UTC)\n\n# Define ISS orbital elements\n# Order: [a, e, i, raan, argp, M]\n# Note: Angles must be in DEGREES for TLE creation (exception to library convention)\nelements = np.array(\n    [\n        6795445.0,  # Semi-major axis (m)\n        0.0004808,  # Eccentricity\n        51.6347,  # Inclination (deg)\n        1.5519,  # Right Ascension of Ascending Node (deg)\n        353.3325,  # Argument of Periapsis (deg)\n        6.7599,  # Mean Anomaly (deg)\n    ]\n)\n\n# Create TLE lines with NORAD ID\nnorad_id = \"25544\"\nline1, line2 = bh.keplerian_elements_to_tle(epoch, elements, norad_id)\n\nprint(\"Generated TLE:\")\nprint(line1)\nprint(line2)\n\n# Expected output:\n# Generated TLE:\n# 1 25544U          25302.48953433  .00000000  00000+0  00000+0 0 00002\n# 2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49800901000006\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital epoch\n    let epoch = bh::Epoch::from_datetime(\n        2025, 10, 29, 11, 44, 55.766182, 0.0, bh::TimeSystem::UTC\n    );\n\n    // Define ISS orbital elements\n    // Order: [a, e, i, raan, argp, M]\n    // Note: Angles must be in DEGREES for TLE creation (exception to library convention)\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        6795445.0,      // Semi-major axis (m)\n        0.0004808,      // Eccentricity\n        51.6347,        // Inclination (deg)\n        1.5519,         // Right Ascension of Ascending Node (deg)\n        353.3325,       // Argument of Periapsis (deg)\n        6.7599          // Mean Anomaly (deg)\n    );\n\n    // Create TLE lines with NORAD ID\n    let norad_id = \"25544\";\n    let (line1, line2) = bh::keplerian_elements_to_tle(&amp;epoch, &amp;elements, norad_id).unwrap();\n\n    println!(\"Generated TLE:\");\n    println!(\"{}\", line1);\n    println!(\"{}\", line2);\n\n    // Expected output:\n    // Generated TLE:\n    // 1 25544U          25302.48953433  .00000000  00000+0  00000+0 0 00002\n    // 2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49800901000006\n}\n</code></pre> <p>Default Values</p> <p>The <code>keplerian_elements_to_tle</code> function uses zero for fields like drag terms and derivatives. For complete control over all TLE fields, use the <code>create_tle_lines</code> function with its full parameter set.</p> <p>Mean Element Representation</p> <p>The TLE format encodes the orbital state as mean orbital elements estimated from orbit propgation using the SGP4/SDP4 models.</p> <p>While the package allows for direclty creating TLEs from arbitrary Keplerian elements, the resulting TLEs WILL NOT accurate propagation results with the SGP4/SDP4 models unless the input elements are already mean elements derived from those models.</p> <p>If you need to create TLEs for real satellites it's best to estimate the mean elements from observed data using orbit determination techniques using the SGP4/SDP4 models.</p> <p>You can verify generated TLEs by parsing them back:</p> PythonRust <pre><code># Define orbital epoch\nepoch = bh.Epoch.from_datetime(2025, 10, 29, 11, 44, 55.766182, 0, bh.TimeSystem.UTC)\n\n# Define ISS orbital elements (angles in degrees)\nelements = np.array(\n    [\n        6795445.0,  # Semi-major axis (m)\n        0.0004808,  # Eccentricity\n        51.6347,  # Inclination (deg)\n        1.5519,  # RAAN (deg)\n        353.3325,  # Argument of Periapsis (deg)\n        6.7599,  # Mean Anomaly (deg)\n    ]\n)\n\n# Create TLE\n</code></pre> <pre><code>    // Define orbital epoch\n    let epoch = bh::Epoch::from_datetime(\n        2025, 10, 29, 11, 44, 55.766182, 0.0, bh::TimeSystem::UTC\n    );\n\n    // Define ISS orbital elements (angles in degrees)\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        6795445.0,      // Semi-major axis (m)\n        0.0004808,      // Eccentricity\n        51.6347,        // Inclination (deg)\n        1.5519,         // RAAN (deg)\n        353.3325,       // Argument of Periapsis (deg)\n        6.7599          // Mean Anomaly (deg)\n    );\n\n    // Create TLE\n    let norad_id = \"25544\";\n    let (line1, line2) = bh::keplerian_elements_to_tle(&amp;epoch, &amp;elements, norad_id).unwrap();\n\n    // Verify by parsing the generated TLE back\n    let (parsed_epoch, parsed_elements) = bh::keplerian_elements_from_tle(&amp;line1, &amp;line2).unwrap();\n\n    println!(\"Verification:\");\n    println!(\"Epoch matches: {}\", (epoch.jd() - parsed_epoch.jd()).abs() &lt; 1e-9);\n\n    let elements_match = elements.iter()\n        .zip(parsed_elements.iter())\n        .all(|(a, b)| (a - b).abs() / a.abs().max(1e-10) &lt; 1e-5);\n    println!(\"Elements match: {}\", elements_match);\n\n    // Expected output:\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#norad-id-formats","title":"NORAD ID Formats","text":"<p>TLEs support two formats for NORAD catalog numbers:</p> <ul> <li>Numeric: 5-digit numbers (00001-99999)</li> <li>Alpha-5: 5-character alphanumeric (A0000-Z9999)</li> </ul> <p>The Alpha-5 format extends the catalog beyond 99,999 satellites by using letters A-Z (excluding I and O to avoid confusion with 1 and 0).</p>"},{"location":"learn/orbits/two_line_elements.html#converting-between-formats","title":"Converting Between Formats","text":"PythonRust <pre><code>import brahe as bh\n\nprint(\"NORAD ID Format Conversions\\n\")\n\n# Convert numeric to Alpha-5 (only works for IDs &gt;= 100000)\nprint(\"Numeric to Alpha-5:\")\nalpha5_low = bh.norad_id_numeric_to_alpha5(25544)\nprint(f\"  25544 -&gt; {alpha5_low}\")\n\nalpha5_high = bh.norad_id_numeric_to_alpha5(100000)\nprint(f\"  100000 -&gt; {alpha5_high}\")\n\nalpha5_higher = bh.norad_id_numeric_to_alpha5(123456)\nprint(f\"  123456 -&gt; {alpha5_higher}\")\n\n# Convert Alpha-5 to numeric\nprint(\"\\nAlpha-5 to Numeric:\")\nnumeric_1 = bh.norad_id_alpha5_to_numeric(\"A0001\")\nprint(f\"  'A0001' -&gt; {numeric_1}\")\n\nnumeric_2 = bh.norad_id_alpha5_to_numeric(\"L0000\")\nprint(f\"  'L0000' -&gt; {numeric_2}\")\n\n# Round-trip conversion\nprint(\"\\nRound-trip Conversion:\")\noriginal = 200000\nalpha5 = bh.norad_id_numeric_to_alpha5(original)\nback_to_numeric = bh.norad_id_alpha5_to_numeric(alpha5)\nprint(f\"  {original} -&gt; '{alpha5}' -&gt; {back_to_numeric}\")\nprint(f\"  Match: {original == back_to_numeric}\")\n\n# Expected output:\n# NORAD ID Format Conversions\n#\n</code></pre> <pre><code>    bh::initialize_eop().unwrap();\n\n    println!(\"NORAD ID Format Conversions\\n\");\n\n    // Convert numeric to Alpha-5 (only works for IDs &gt;= 100000)\n    println!(\"Numeric to Alpha-5:\");\n    let alpha5_low = bh::norad_id_numeric_to_alpha5(25544).unwrap();\n    println!(\"  25544 -&gt; {}\", alpha5_low);\n\n    let alpha5_high = bh::norad_id_numeric_to_alpha5(100000).unwrap();\n    println!(\"  100000 -&gt; {}\", alpha5_high);\n\n    let alpha5_higher = bh::norad_id_numeric_to_alpha5(123456).unwrap();\n    println!(\"  123456 -&gt; {}\", alpha5_higher);\n\n    // Convert Alpha-5 to numeric\n    println!(\"\\nAlpha-5 to Numeric:\");\n    let numeric_1 = bh::norad_id_alpha5_to_numeric(\"A0001\").unwrap();\n    println!(\"  'A0001' -&gt; {}\", numeric_1);\n\n    let numeric_2 = bh::norad_id_alpha5_to_numeric(\"L0000\").unwrap();\n    println!(\"  'L0000' -&gt; {}\", numeric_2);\n\n    // Round-trip conversion\n    println!(\"\\nRound-trip Conversion:\");\n    let original = 200000;\n    let alpha5 = bh::norad_id_numeric_to_alpha5(original).unwrap();\n    let back_to_numeric = bh::norad_id_alpha5_to_numeric(&amp;alpha5).unwrap();\n    println!(\"  {} -&gt; '{}' -&gt; {}\", original, alpha5, back_to_numeric);\n    println!(\"  Match: {}\", original == back_to_numeric);\n\n    // Expected output:\n    // NORAD ID Format Conversions\n    //\n    // Numeric to Alpha-5:\n    //   25544 -&gt; 25544\n    //   100000 -&gt; A0000\n</code></pre> <p>Alpha-5 Range</p> <p>Alpha-5 format is only valid for NORAD IDs &gt;= 100,000. The range is 100,000 (A0000) to 339,999 (Z9999).</p>"},{"location":"learn/orbits/two_line_elements.html#parsing-mixed-formats","title":"Parsing Mixed Formats","text":"<p>The <code>parse_norad_id</code> function automatically detects whether a NORAD ID is in numeric or Alpha-5 format:</p> PythonRust <pre><code>import brahe as bh\n\n# Parse NORAD IDs in different formats\nprint(\"Parsing NORAD IDs:\")\n\n# Numeric format (standard)\nnorad_numeric = bh.parse_norad_id(\"25544\")\nprint(f\"  '25544' -&gt; {norad_numeric}\")\n</code></pre> <pre><code>    bh::initialize_eop().unwrap();\n\n    // Parse NORAD IDs in different formats\n    println!(\"Parsing NORAD IDs:\");\n\n    // Numeric format (standard)\n    let norad_numeric = bh::parse_norad_id(\"25544\").unwrap();\n    println!(\"  '25544' -&gt; {}\", norad_numeric);\n\n    // Alpha-5 format (for IDs &gt;= 100000)\n    let norad_alpha5 = bh::parse_norad_id(\"A0001\").unwrap();\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#see-also","title":"See Also","text":"<ul> <li>SGP Propagator - Use TLEs with SGP4/SDP4 propagation</li> <li>Keplerian Elements - Working with orbital elements</li> <li>Downloading TLE Data - How to fetch current TLEs from online sources</li> <li>Epoch - Understanding time representation in Brahe</li> </ul>"},{"location":"learn/plots/index.html","title":"Plotting &amp; Visualization","text":"<p>Brahe provides quick and convenient plotting functions for visualizing orbital trajectories, ground tracks, access windows, and other astrodynamics data. The plotting module is designed to make it easy to generate publication-quality figures with minimal code while offering flexibility for customization.</p> <p>Experimental API</p> <p>The plotting API in brahe is currently experimental and may undergo significant changes in future releases. While we strive to maintain backward compatibility, functions, parameters, or behaviors may change as we refine the plotting capabilities based on user feedback and evolving best practices in data visualization. These changes may occur in minor or patch releases.</p>"},{"location":"learn/plots/index.html#dual-backend-system","title":"Dual Backend System","text":"<p>All plotting functions in brahe support two rendering backends, allowing you to choose the best tool for your workflow:</p>"},{"location":"learn/plots/index.html#matplotlib-backend","title":"Matplotlib Backend","text":"<p>The matplotlib backend generates static, publication-ready figures. This is the default backend and is ideal for academic papers and technical reports.</p> <pre><code>import brahe as bh\n\n# Use matplotlib backend (default)\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    backend=\"matplotlib\"\n)\nfig.savefig(\"groundtrack.png\", dpi=300)\n</code></pre>"},{"location":"learn/plots/index.html#science-plots-styling","title":"Science Plots Styling","text":"<p>Brahe integrates with the <code>scienceplots</code> package to provide publication-quality matplotlib styling. When <code>scienceplots</code> is installed, brahe automatically applies clean, professional styling to matplotlib plots.</p> <p>To enable science plots styling either install brahe with all optional dependencies:</p> <pre><code>pip install brahe[all]\n</code></pre> <p>Or install <code>scienceplots</code> separately:</p> <pre><code>pip install scienceplots\n</code></pre> <p>To take full advantage of science plots styling, you can need a \\(\\LaTeX\\) installation on your system, as <code>scienceplots</code> uses LaTeX for rendering text in plots. See the scienceplots documentation for guidance on setting up LaTeX.</p> <p>If <code>scienceplots</code> is not installed, brahe falls back to standard matplotlib styling.</p>"},{"location":"learn/plots/index.html#plotly-backend","title":"Plotly Backend","text":"<p>The plotly backend creates interactive HTML figures that can be explored in a web browser. This backend is perfect for interactive exploration of data or sharing results via web pages or notebooks.</p> <pre><code>import brahe as bh\n\n# Use plotly backend for interactive plots\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    backend=\"plotly\"\n)\nfig.write_html(\"groundtrack.html\")\nfig.show()  # Opens in browser\n</code></pre> <p>Both backends use the same function signatures and parameters, making it trivial to switch between static and interactive outputs.</p>"},{"location":"learn/plots/index.html#available-plot-types","title":"Available Plot Types","text":"<p>Brahe provides specialized plotting functions for common astrodynamics visualization tasks:</p>"},{"location":"learn/plots/index.html#ground-track-plots","title":"Ground Track Plots","text":"<p>Visualize satellite ground tracks on a world map with ground stations and communication coverage zones.</p> <pre><code>fig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": orbit_traj}],\n    ground_stations=[{\"stations\": [station1, station2]}]\n)\n</code></pre>"},{"location":"learn/plots/index.html#3d-trajectory-plots","title":"3D Trajectory Plots","text":"<p>Visualize orbital trajectories in 3D space with an optional Earth sphere.</p> <pre><code>fig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    show_earth=True\n)\n</code></pre>"},{"location":"learn/plots/index.html#access-geometry-plots","title":"Access Geometry Plots","text":"<p>Visualize satellite visibility from ground stations using polar plots (azimuth/elevation) or elevation profiles over time.</p> <pre><code># Polar plot showing satellite path in sky\nfig = bh.plot_access_polar(access_window)\n\n# Elevation angle over time\nfig = bh.plot_access_elevation(access_window)\n</code></pre>"},{"location":"learn/plots/index.html#orbital-element-plots","title":"Orbital Element Plots","text":"<p>Track how orbital elements evolve over time in both Cartesian and Keplerian representations.</p> <pre><code># Plot position and velocity components\nfig = bh.plot_cartesian_trajectory([{\"trajectory\": traj}])\n\n# Plot Keplerian elements (a, e, i, \u03a9, \u03c9, \u03bd)\nfig = bh.plot_keplerian_trajectory([{\"trajectory\": traj}])\n</code></pre>"},{"location":"learn/plots/index.html#gabbard-diagrams","title":"Gabbard Diagrams","text":"<p>Analyze debris clouds or satellite constellations by plotting orbital period versus apogee/perigee altitude.</p> <pre><code>fig = bh.plot_gabbard_diagram(\n    propagators=[prop1, prop2, prop3],\n    epoch=epoch\n)\n</code></pre>"},{"location":"learn/plots/index.html#common-features","title":"Common Features","text":"<p>All plotting functions share consistent design patterns:</p> <ul> <li>Grouped plotting: Plot multiple trajectories, stations, or objects with different colors and labels</li> <li>Flexible inputs: Accept propagators, trajectories, or raw numpy arrays</li> <li>Unit conversion: Automatic handling of meters/kilometers, radians/degrees, etc.</li> <li>Time filtering: Optional time range filtering for all trajectory plots</li> <li>Customization: Control colors, line widths, markers, and other visual properties</li> </ul>"},{"location":"learn/plots/index.html#quick-start-example","title":"Quick Start Example","text":"<p>This example shows how to create a simple LEO orbit and visualize it in 3D. It demonstrates the core plotting workflow: define an orbit, propagate it, and visualize the results. Both plotly and matplotlib backends are shown.</p> <p>Matplotlib 3D Visualization Limitations</p> <p>The matplotlib 3D backend does not have a true 3D perspective camera model. Instead is uses a 2D layering system where entire objects (e.g., the entire orbit line, the entire sphere surface) are drawn one on top of the other based on a single, fixed <code>zorder</code> value. </p> <p>This can lead to visual artifacts where parts of objects that should be behind other objects are incorrectly drawn in front. For example, the far side of an orbit may appear in front of the Earth sphere.</p>"},{"location":"learn/plots/index.html#interactive-plot-plotly","title":"Interactive Plot (Plotly)","text":"Plot Source quickstart_example_plotly.py<pre><code>OUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create a simple LEO orbit\nepoch = bh.Epoch.from_datetime(2025, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\n\n# Create propagator and generate trajectory\nprop = bh.KeplerianPropagator.from_keplerian(epoch, oe, bh.AngleFormat.DEGREES, 5.0)\nprop.propagate_to(epoch + bh.orbital_period(oe[0]))\ntraj = prop.trajectory\n\n# Create an interactive 3D plot\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n    show_earth=True,\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/index.html#static-plot-matplotlib","title":"Static Plot (Matplotlib)","text":"Plot Source quickstart_example_matplotlib.py<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create a simple LEO orbit\nepoch = bh.Epoch.from_datetime(2025, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n\n# Create propagator and generate trajectory\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\nprop.propagate_to(epoch + bh.orbital_period(oe[0]))\ntraj = prop.trajectory\n\n# Create a 3D plot in light mode\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n    show_earth=True,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_quickstart_example_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Quick start example plot (matplotlib, light mode) saved to: docs/figures/plot_quickstart_example_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create a 3D plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_trajectory_3d(\n        [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n        show_earth=True,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_quickstart_example_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Quick start example plot (matplotlib, dark mode) saved to: docs/figures/plot_quickstart_example_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n</code></pre>"},{"location":"learn/plots/index.html#see-also","title":"See Also","text":"<ul> <li>Ground Track Plotting - Satellite ground tracks and coverage</li> <li>Gabbard Diagrams - Debris cloud analysis</li> <li>3D Trajectories - Orbital paths in 3D space</li> <li>Access Geometry - Ground station visibility</li> <li>Orbital Elements - Element evolution over time</li> <li>API Reference - Complete function documentation</li> </ul>"},{"location":"learn/plots/3d_trajectory.html","title":"3D Trajectory Visualization","text":"<p>Three-dimensional trajectory plots display orbital paths in Earth-Centered Inertial (ECI) coordinates, providing intuitive spatial understanding of satellite motion. The <code>plot_trajectory_3d</code> function renders trajectories with optional Earth sphere visualization, camera controls, and support for multiple orbits with different colors and labels.</p>"},{"location":"learn/plots/3d_trajectory.html#interactive-3d-trajectory-plotly","title":"Interactive 3D Trajectory (Plotly)","text":"<p>The plotly backend creates fully interactive 3D plots. Click and drag to rotate, scroll to zoom, and double-click to reset the view.</p>"},{"location":"learn/plots/3d_trajectory.html#simple-texture-interactive","title":"Simple Texture (Interactive)","text":""},{"location":"learn/plots/3d_trajectory.html#blue-marble-texture","title":"Blue Marble Texture","text":"<p>Note</p> <p>Textues are provided as image-only in documentation to reduce page load times. Interactive versions can be generated using the provided code.</p>"},{"location":"learn/plots/3d_trajectory.html#natural-earth-texture","title":"Natural Earth Texture","text":"Plot Source trajectory_3d_plotly.py<pre><code>#!/usr/bin/env python\n# /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# TIMEOUT = 600\n# ///\n\"\"\"\n3D Trajectory Plotting Example - Plotly Backend\n\nThis script demonstrates how to create an interactive 3D trajectory plot in the ECI frame\nusing the plotly backend. Shows the ISS orbit around Earth with different texture options.\n\"\"\"\n\nimport numpy as np\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, save_themed_static_image\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ISS-like orbit (LEO, 51.6\u00b0 inclination, ~400 km altitude)\noe_iss = np.array(\n    [\n        bh.R_EARTH + 420e3,  # Semi-major axis (m)\n        0.0005,  # Eccentricity\n        51.6,  # Inclination\n        45.0,  # RAAN\n        30.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_iss = bh.state_osculating_to_cartesian(oe_iss, bh.AngleFormat.DEGREES)\nprop_iss = bh.KeplerianPropagator.from_eci(epoch, state_iss, 60.0)\n\n# Polar orbit (Sun-synchronous-like, ~550 km altitude)\noe_polar = np.array(\n    [\n        bh.R_EARTH + 550e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (near-polar)\n        180.0,  # RAAN\n        60.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_polar = bh.state_osculating_to_cartesian(oe_polar, bh.AngleFormat.DEGREES)\nprop_polar = bh.KeplerianPropagator.from_eci(epoch, state_polar, 60.0)\n\n# Generate trajectories\nprop_iss.propagate_to(epoch + bh.orbital_period(oe_iss[0]))\ntraj_iss = prop_iss.trajectory\n\nprop_polar.propagate_to(epoch + bh.orbital_period(oe_polar[0]))\ntraj_polar = prop_polar.trajectory\n\n# Create 3D trajectory plot with Blue Marble texture (default for plotly)\nfig = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"blue_marble\",\n    backend=\"plotly\",\n)\n\n# Save as static images (SVG) - large texture, save as static to reduce file size\nlight_path, dark_path = save_themed_static_image(\n    fig, OUTDIR / SCRIPT_NAME, format=\"svg\", width=1400, height=900\n)\nprint(f\"\u2713 Generated {light_path} (Blue Marble texture - static SVG)\")\nprint(f\"\u2713 Generated {dark_path} (Blue Marble texture - static SVG)\")\n\n# Create 3D trajectory plot with simple texture\nfig_simple = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"simple\",\n    backend=\"plotly\",\n)\n\n# Save simple texture version as interactive HTML (small file size)\nlight_path, dark_path = save_themed_html(fig_simple, OUTDIR / f\"{SCRIPT_NAME}_simple\")\nprint(f\"\u2713 Generated {light_path} (Simple texture - interactive HTML)\")\nprint(f\"\u2713 Generated {dark_path} (Simple texture - interactive HTML)\")\n\nfig_ne = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n)\n\n# Save Natural Earth texture version as static images (SVG)\nlight_path, dark_path = save_themed_static_image(\n    fig_ne,\n    OUTDIR / f\"{SCRIPT_NAME}_natural_earth\",\n    format=\"svg\",\n    width=1400,\n    height=900,\n)\nprint(f\"\u2713 Generated {light_path} (Natural Earth texture - static SVG)\")\nprint(f\"\u2713 Generated {dark_path} (Natural Earth texture - static SVG)\")\n\nprint(\"\\nAll plotly figures generated successfully!\")\n</code></pre> <p>The interactive visualization shows the ISS orbit in 3D space with Earth at the origin. You can:</p> <ul> <li>Rotate: Click and drag to change viewing angle</li> <li>Zoom: Scroll or pinch to zoom in/out</li> <li>Pan: Right-click and drag to pan</li> <li>Reset: Double-click to return to default view</li> </ul>"},{"location":"learn/plots/3d_trajectory.html#static-3d-trajectory-matplotlib","title":"Static 3D Trajectory (Matplotlib)","text":"<p>Matplotlib 3D Visualization Limitations</p> <p>The matplotlib 3D backend does not have a true 3D perspective camera model. Instead is uses a 2D layering system where entire objects (e.g., the entire orbit line, the entire sphere surface) are drawn one on top of the other based on a single, fixed <code>zorder</code> value. </p> <p>This can lead to visual artifacts where parts of objects that should be behind other objects are incorrectly drawn in front. For example, the far side of an orbit may appear in front of the Earth sphere.</p> <p>The matplotlib backend produces publication-ready 3D figures with customizable viewing angles.</p> Plot Source trajectory_3d_matplotlib.py<pre><code>#!/usr/bin/env python\n# /// script\n# dependencies = [\"brahe\", \"matplotlib\", \"numpy\"]\n# TIMEOUT = 600\n# ///\n\"\"\"\n3D Trajectory Plotting Example - Matplotlib Backend\n\nThis script demonstrates how to create a 3D trajectory plot in the ECI frame\nusing the matplotlib backend. Shows the ISS orbit around Earth with different\ntexture options for Earth visualization.\n\"\"\"\n\nimport numpy as np\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ISS-like orbit (LEO, 51.6\u00b0 inclination, ~400 km altitude)\noe_iss = np.array(\n    [\n        bh.R_EARTH + 420e3,  # Semi-major axis (m)\n        0.0005,  # Eccentricity\n        51.6,  # Inclination\n        45.0,  # RAAN\n        30.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_iss = bh.state_osculating_to_cartesian(oe_iss, bh.AngleFormat.DEGREES)\nprop_iss = bh.KeplerianPropagator.from_eci(epoch, state_iss, 60.0)\n\n# Polar orbit (Sun-synchronous-like, ~550 km altitude)\noe_polar = np.array(\n    [\n        bh.R_EARTH + 550e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (near-polar)\n        180.0,  # RAAN\n        60.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_polar = bh.state_osculating_to_cartesian(oe_polar, bh.AngleFormat.DEGREES)\nprop_polar = bh.KeplerianPropagator.from_eci(epoch, state_polar, 60.0)\n\n# Define time range - one orbital period of the lower orbit\n# Generate trajectories\nprop_iss.propagate_to(epoch + bh.orbital_period(oe_iss[0]))\ntraj_iss = prop_iss.trajectory\n\nprop_polar.propagate_to(epoch + bh.orbital_period(oe_polar[0]))\ntraj_polar = prop_polar.trajectory\n\n# Create 3D trajectory plot in light mode with matplotlib\nfig = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_trajectory_3d_matplotlib_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(\n    \"3D trajectory plot (matplotlib) saved to: docs/figures/plot_trajectory_3d_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create 3D trajectory plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_trajectory_3d(\n        [\n            {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n            {\n                \"trajectory\": traj_polar,\n                \"color\": \"cyan\",\n                \"label\": \"Polar 97.8\u00b0 (~550 km)\",\n            },\n        ],\n        units=\"km\",\n        show_earth=True,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_trajectory_3d_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"3D trajectory plot (matplotlib, dark mode, Blue Marble) saved to: docs/figures/plot_trajectory_3d_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n\nprint(\"\\nAll matplotlib figures generated successfully!\")\n</code></pre>"},{"location":"learn/plots/3d_trajectory.html#see-also","title":"See Also","text":"<ul> <li>plot_trajectory_3d API Reference</li> <li>Ground Tracks - 2D projection on Earth's surface</li> <li>Orbital Elements - Element evolution over time</li> <li>Coordinate Systems - Understanding ECI frames</li> </ul>"},{"location":"learn/plots/access_geometry.html","title":"Access Geometry","text":"<p>Access geometry plots visualize satellite visibility from ground stations, showing where satellites appear in the sky and how their elevation changes over time. Brahe provides three complementary views: polar plots showing azimuth and elevation, elevation vs azimuth plots showing the observed horizon, and time-series plots tracking elevation angle during passes.</p> <p>All plot types support optional elevation masks to visualize terrain obstructions, antenna constraints, or other azimuth-dependent visibility limits.</p>"},{"location":"learn/plots/access_geometry.html#polar-access-plot-azimuthelevation","title":"Polar Access Plot (Azimuth/Elevation)","text":"<p>Polar plots display the satellite's path across the sky in azimuth-elevation coordinates, providing an intuitive \"looking up\" view from the ground station.</p>"},{"location":"learn/plots/access_geometry.html#interactive-polar-plot-plotly","title":"Interactive Polar Plot (Plotly)","text":"Plot Source access_polar_plotly.py<pre><code>\"\"\"\nAccess Polar Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive polar access plot using the plotly backend.\nShows satellite azimuth and elevation during ground station passes.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create polar access plot\nif len(accesses) &gt; 0:\n    # Use first 3 access windows\n    num_windows = min(3, len(accesses))\n    windows_to_plot = [\n        {\"access_window\": accesses[i], \"label\": f\"Access {i + 1}\"}\n        for i in range(num_windows)\n    ]\n\n    fig = bh.plot_access_polar(\n        windows_to_plot,\n        prop,  # Propagator for interpolation\n        min_elevation=10.0,\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-polar-plot-matplotlib","title":"Static Polar Plot (Matplotlib)","text":"Plot Source access_polar_matplotlib.py<pre><code>\"\"\"\nAccess Polar Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create a polar access plot using the matplotlib backend.\nShows satellite azimuth and elevation during ground station passes.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create polar access plots (light and dark mode)\nif len(accesses) &gt; 0:\n    # Use first 3 access windows\n    num_windows = min(3, len(accesses))\n    windows_to_plot = [\n        {\"access_window\": accesses[i], \"label\": f\"Access {i + 1}\"}\n        for i in range(num_windows)\n    ]\n\n    # Light mode\n    fig = bh.plot_access_polar(\n        windows_to_plot,\n        prop,  # Propagator for interpolation\n        min_elevation=10.0,\n        backend=\"matplotlib\",\n    )\n\n    # Save light mode figure\n    fig.savefig(\n        \"docs/figures/plot_access_polar_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access polar plot (matplotlib, light mode) saved to: docs/figures/plot_access_polar_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_polar(\n            windows_to_plot,\n            prop,  # Propagator for interpolation\n            min_elevation=10.0,\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        # Save dark mode figure\n        fig.savefig(\n            \"docs/figures/plot_access_polar_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access polar plot (matplotlib, dark mode) saved to: docs/figures/plot_access_polar_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre> <p>The polar plot shows:</p> <ul> <li>Radial axis: Elevation angle (0\u00b0 at edge, 90\u00b0 at center)</li> <li>Angular axis: Azimuth (0\u00b0 = North, 90\u00b0 = East, 180\u00b0 = South, 270\u00b0 = West)</li> <li>Satellite path: Track showing where the satellite appears in the sky</li> </ul>"},{"location":"learn/plots/access_geometry.html#elevation-vs-azimuth-plot-observed-horizon","title":"Elevation vs Azimuth Plot (Observed Horizon)","text":"<p>Elevation vs azimuth plots show satellite paths across the observed horizon, with azimuth on the X-axis and elevation on the Y-axis. This view is particularly useful for visualizing terrain obstructions and azimuth-dependent visibility constraints using elevation masks.</p>"},{"location":"learn/plots/access_geometry.html#interactive-elevation-vs-azimuth-plot-plotly","title":"Interactive Elevation vs Azimuth Plot (Plotly)","text":"Plot Source access_elevation_azimuth_plotly.py<pre><code>\"\"\"\nAccess Elevation vs Azimuth Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive elevation vs azimuth plot using the plotly backend.\nShows the satellite's trajectory across the observed horizon with a sinusoidal elevation mask.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = 28.4740  # Latitude in degrees\nlon = -80.5772  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 7.0 * 24.0 * 3600.0  # 24 hours in seconds\n\n\n# Define sinusoidal elevation mask: 15\u00b0 + 10\u00b0 * sin(2*azimuth)\n# This varies between 5\u00b0 and 25\u00b0 around the horizon\ndef elevation_mask(az):\n    return 15.0 + 10.0 * np.sin(np.radians(2 * az)) + 5.0 * np.sin(np.radians(3 * az))\n\n\n# Create ElevationMaskConstraint from the sinusoidal mask function\n# Sample the mask at 36 points around the horizon (every 10 degrees)\nmask_azimuths = np.arange(0, 360, 10)\nmask_points = [(az, elevation_mask(az)) for az in mask_azimuths]\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\n# Compute access windows using the elevation mask constraint\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\nprint(f\"Computed {len(accesses)} access windows\")\n\n# Filter for passes longer than 5 minutes (300 seconds) to show complete passes\nmin_duration = 300.0  # seconds\nlong_passes = [acc for acc in accesses if acc.duration &gt; min_duration]\nprint(f\"Filtered to {len(long_passes)} long passes (&gt; {min_duration} seconds)\")\n\n# Create elevation vs azimuth plot\nif len(long_passes) &gt; 0:\n    # Use first 3 long passes for better visualization\n    passes = long_passes[: min(3, len(long_passes))]\n    window_configs = [\n        {\"access_window\": passes[i], \"label\": f\"Pass {i + 1}\"}\n        for i in range(len(passes))\n    ]\n\n    fig = bh.plot_access_elevation_azimuth(\n        window_configs,\n        prop,  # Propagator for interpolation\n        elevation_mask=elevation_mask,\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-elevation-vs-azimuth-plot-matplotlib","title":"Static Elevation vs Azimuth Plot (Matplotlib)","text":"Plot Source access_elevation_azimuth_matplotlib.py<pre><code>\"\"\"\nAccess Elevation vs Azimuth Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create an elevation vs azimuth plot using the matplotlib backend.\nShows the satellite's trajectory across the observed horizon with a sinusoidal elevation mask.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = 28.4740  # Latitude in degrees\nlon = -80.5772  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 7.0 * 24.0 * 3600.0  # 24 hours in seconds\n\n\n# Define sinusoidal elevation mask: 15\u00b0 + 10\u00b0 * sin(2*azimuth)\n# This varies between 5\u00b0 and 25\u00b0 around the horizon\ndef elevation_mask(az):\n    return 15.0 + 10.0 * np.sin(np.radians(2 * az)) + 5.0 * np.sin(np.radians(3 * az))\n\n\n# Create ElevationMaskConstraint from the sinusoidal mask function\n# Sample the mask at 36 points around the horizon (every 10 degrees)\nmask_azimuths = np.arange(0, 360, 10)\nmask_points = [(az, elevation_mask(az)) for az in mask_azimuths]\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\n# Compute access windows using the elevation mask constraint\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\nprint(f\"Computed {len(accesses)} access windows\")\n\n# Filter for passes longer than 5 minutes (300 seconds) to show complete passes\nmin_duration = 300.0  # seconds\nlong_passes = [acc for acc in accesses if acc.duration &gt; min_duration]\nprint(f\"Filtered to {len(long_passes)} long passes (&gt; {min_duration} seconds)\")\n\n# Create elevation vs azimuth plots (light and dark mode)\nif len(long_passes) &gt; 0:\n    # Use first 3 long passes for better visualization\n    passes = long_passes[: min(3, len(long_passes))]\n    window_configs = [\n        {\"access_window\": passes[i], \"label\": f\"Pass {i + 1}\"}\n        for i in range(len(passes))\n    ]\n\n    # Light mode\n    fig = bh.plot_access_elevation_azimuth(\n        window_configs,\n        prop,  # Propagator for interpolation\n        elevation_mask=elevation_mask,\n        backend=\"matplotlib\",\n    )\n\n    fig.savefig(\n        \"docs/figures/plot_access_elevation_azimuth_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access elevation vs azimuth plot (matplotlib, light mode) saved to: \"\n        \"docs/figures/plot_access_elevation_azimuth_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_elevation_azimuth(\n            window_configs,\n            prop,  # Propagator for interpolation\n            elevation_mask=elevation_mask,\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        fig.savefig(\n            \"docs/figures/plot_access_elevation_azimuth_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access elevation vs azimuth plot (matplotlib, dark mode) saved to: \"\n            \"docs/figures/plot_access_elevation_azimuth_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre> <p>The elevation vs azimuth plot shows:</p> <ul> <li>X-axis: Azimuth angle (0\u00b0 to 360\u00b0, North = 0\u00b0/360\u00b0)</li> <li>Y-axis: Elevation angle (0\u00b0 to 90\u00b0)</li> <li>Satellite trajectory: Path across the sky from observer's perspective</li> <li>Elevation mask (shaded region): Visibility constraints varying with azimuth</li> <li>Discontinuity handling: Trajectories crossing 0\u00b0/360\u00b0 azimuth are split to avoid artifacts</li> </ul>"},{"location":"learn/plots/access_geometry.html#elevation-masks","title":"Elevation Masks","text":"<p>Elevation masks define azimuth-dependent minimum elevation constraints. They can represent:</p> <ul> <li>Terrain obstructions: Mountains, buildings, trees</li> <li>Antenna constraints: Dish beamwidth, gimbal limits</li> <li>Operational requirements: RF interference avoidance zones</li> </ul> <p>The example above uses a sinusoidal mask: 15\u00b0 + 10\u00b0 sin(2\u00d7azimuth), varying between 5\u00b0 and 25\u00b0 around the horizon.</p>"},{"location":"learn/plots/access_geometry.html#using-elevation-masks","title":"Using Elevation Masks","text":"<p>Elevation masks can be specified in three ways:</p> <pre><code># Constant elevation (simple threshold)\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=10.0,  # 10\u00b0 everywhere\n    backend=\"matplotlib\"\n)\n\n# Function of azimuth (variable constraint)\nmask_fn = lambda az: 15.0 + 10.0 * np.sin(np.radians(2 * az))\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=mask_fn,\n    backend=\"matplotlib\"\n)\n\n# Array of values (measured terrain profile)\nazimuths = np.linspace(0, 360, 361)\nelevations = [measured_elevation(az) for az in azimuths]\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=elevations,  # Must match azimuth sampling\n    backend=\"matplotlib\"\n)\n</code></pre> <p>Elevation masks are also supported in polar plots (<code>plot_access_polar</code>) where they appear as shaded regions around the plot edge.</p>"},{"location":"learn/plots/access_geometry.html#elevation-vs-time-plot","title":"Elevation vs Time Plot","text":"<p>Time-series plots show how elevation angle changes throughout a satellite pass, useful for link budget analysis and antenna pointing.</p>"},{"location":"learn/plots/access_geometry.html#interactive-elevation-plot-plotly","title":"Interactive Elevation Plot (Plotly)","text":"Plot Source access_elevation_plotly.py<pre><code>\"\"\"\nAccess Elevation Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive elevation vs time plot using the plotly backend.\nShows satellite elevation angle during a ground station pass.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create elevation plot\nif len(accesses) &gt; 0:\n    fig = bh.plot_access_elevation(\n        [{\"access_window\": accesses[0]}],  # Use first access window\n        prop,  # Propagator for interpolation\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-elevation-plot-matplotlib","title":"Static Elevation Plot (Matplotlib)","text":"Plot Source access_elevation_matplotlib.py<pre><code>\"\"\"\nAccess Elevation Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create an elevation vs time plot using the matplotlib backend.\nShows satellite elevation angle during a ground station pass.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create elevation plots (light and dark mode)\nif len(accesses) &gt; 0:\n    # Light mode\n    fig = bh.plot_access_elevation(\n        [{\"access_window\": accesses[0]}],  # Use first access window\n        prop,  # Propagator for interpolation\n        backend=\"matplotlib\",\n    )\n\n    # Save light mode figure\n    fig.savefig(\n        \"docs/figures/plot_access_elevation_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access elevation plot (matplotlib, light mode) saved to: docs/figures/plot_access_elevation_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_elevation(\n            [{\"access_window\": accesses[0]}],  # Use first access window\n            prop,  # Propagator for interpolation\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        # Save dark mode figure\n        fig.savefig(\n            \"docs/figures/plot_access_elevation_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access elevation plot (matplotlib, dark mode) saved to: docs/figures/plot_access_elevation_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#see-also","title":"See Also","text":"<ul> <li>plot_access_polar API Reference</li> <li>plot_access_elevation_azimuth API Reference</li> <li>plot_access_elevation API Reference</li> <li>location_accesses - Computing access windows</li> <li>Ground Tracks - Visualizing coverage on maps</li> <li>Access Constraints - Defining visibility rules</li> </ul>"},{"location":"learn/plots/gabbard_plot.html","title":"Gabbard Diagrams","text":"<p>A Gabbard diagram plots orbital period versus apogee and perigee altitude, providing a unique visualization for analyzing debris clouds, satellite breakups, and orbital constellations. Each object appears as two points: one for apogee altitude and one for perigee altitude, both at the same orbital period. This creates a characteristic pattern that reveals the distribution and evolution of orbital populations.</p>"},{"location":"learn/plots/gabbard_plot.html#interactive-gabbard-diagram-plotly","title":"Interactive Gabbard Diagram (Plotly)","text":"<p>The plotly backend allows you to zoom into specific regions and hover over points to see exact values.</p> Plot Source gabbard_plotly.py<pre><code>\"\"\"\nGabbard Diagram Example - Plotly Backend\n\nThis script demonstrates how to create an interactive Gabbard diagram using the plotly backend.\nA Gabbard diagram plots orbital period vs apogee/perigee altitude, useful for analyzing\ndebris clouds or satellite constellations.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get Ephmeris and debris for major events:\ncosmos_1408_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-1408-debris\", 60.0)\nfengyun_debris = bh.celestrak.get_tles_as_propagators(\"fengyun-1c-debris\", 60.0)\niridium_debris = bh.celestrak.get_tles_as_propagators(\"iridium-33-debris\", 60.0)\ncosmos_2251_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-2251-debris\", 60.0)\nall_debris = cosmos_1408_debris + fengyun_debris + iridium_debris + cosmos_2251_debris\n\nprint(f\"Cosmos 1408 debris objects: {len(cosmos_1408_debris)}\")\nprint(f\"Fengyun-1C debris objects: {len(fengyun_debris)}\")\nprint(f\"Iridium 33 debris objects: {len(iridium_debris)}\")\nprint(f\"Cosmos 2251 debris objects: {len(cosmos_2251_debris)}\")\nprint(f\"Total debris objects loaded: {len(all_debris)}\")\n\n# Get epoch of first debris object\nepoch = all_debris[0].epoch\n\n# Get ISS ephemeris for reference altitude line\niss = bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\")\niss_state = iss.state_eci(epoch)\niss_oe = bh.state_cartesian_to_osculating(iss_state, bh.AngleFormat.RADIANS)\niss_altitude_km = (iss_oe[0] - bh.R_EARTH) / 1e3  # Convert to km\n\nprint(f\"ISS altitude at epoch: {iss_altitude_km:.1f} km\")\n\n# Create Gabbard diagram\nfig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"plotly\")\n\n# Add ISS altitude reference line\nfig.add_hline(\n    y=iss_altitude_km,\n    line_dash=\"dash\",\n    line_color=\"orange\",\n    line_width=2,\n    annotation_text=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n    annotation_position=\"right\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/gabbard_plot.html#static-gabbard-diagram-matplotlib","title":"Static Gabbard Diagram (Matplotlib)","text":"<p>The matplotlib backend produces publication-quality figures for research papers and technical reports.</p> Plot Source gabbard_matplotlib.py<pre><code>\"\"\"\nGabbard Diagram Example - Matplotlib Backend\n\nThis script demonstrates how to create a Gabbard diagram using the matplotlib backend.\nA Gabbard diagram plots orbital period vs apogee/perigee altitude, useful for analyzing\ndebris clouds or satellite constellations.\n\"\"\"\n\nimport os\nimport pathlib\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get Ephmeris and debris for major events:\ncosmos_1408_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-1408-debris\", 60.0)\nfengyun_debris = bh.celestrak.get_tles_as_propagators(\"fengyun-1c-debris\", 60.0)\niridium_debris = bh.celestrak.get_tles_as_propagators(\"iridium-33-debris\", 60.0)\ncosmos_2251_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-2251-debris\", 60.0)\nall_debris = cosmos_1408_debris + fengyun_debris + iridium_debris + cosmos_2251_debris\n\nprint(f\"Cosmos 1408 debris objects: {len(cosmos_1408_debris)}\")\nprint(f\"Fengyun-1C debris objects: {len(fengyun_debris)}\")\nprint(f\"Iridium 33 debris objects: {len(iridium_debris)}\")\nprint(f\"Cosmos 2251 debris objects: {len(cosmos_2251_debris)}\")\nprint(f\"Total debris objects loaded: {len(all_debris)}\")\n\n# Get epoch of first debris object\nepoch = all_debris[0].epoch\n\n# Get ISS ephemeris for reference altitude line\niss = bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\")\niss_state = iss.state_eci(epoch)\niss_oe = bh.state_cartesian_to_osculating(iss_state, bh.AngleFormat.RADIANS)\niss_altitude_km = (iss_oe[0] - bh.R_EARTH) / 1e3  # Convert to km\n\nprint(f\"ISS altitude at epoch: {iss_altitude_km:.1f} km\")\n\n# Create Gabbard diagram in light mode\nfig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"matplotlib\")\n\n# Add ISS altitude reference line\nax = fig.get_axes()[0]\nax.axhline(\n    y=iss_altitude_km,\n    color=\"green\",\n    linestyle=\"--\",\n    linewidth=2,\n    label=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n)\nax.legend()\n\n# Save light mode figure\nlight_path = OUTDIR / f\"{SCRIPT_NAME}_light.svg\"\nfig.savefig(light_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"\u2713 Generated {light_path}\")\nplt.close(fig)\n\n# Create Gabbard diagram in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"matplotlib\")\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Add ISS altitude reference line\n    ax = fig.get_axes()[0]\n    ax.axhline(\n        y=iss_altitude_km,\n        color=\"orange\",\n        linestyle=\"--\",\n        linewidth=2,\n        label=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n    )\n    ax.legend()\n\n    # Save dark mode figure\n    dark_path = OUTDIR / f\"{SCRIPT_NAME}_dark.svg\"\n    fig.savefig(dark_path, dpi=300, bbox_inches=\"tight\")\n    print(f\"\u2713 Generated {dark_path}\")\n    plt.close(fig)\n</code></pre>"},{"location":"learn/plots/gabbard_plot.html#understanding-the-diagram","title":"Understanding the Diagram","text":""},{"location":"learn/plots/gabbard_plot.html#reading-the-plot","title":"Reading the Plot","text":"<ul> <li>X-axis: Orbital period (minutes or hours)</li> <li>Y-axis: Altitude (km)</li> <li>Each object creates TWO points:<ul> <li>Upper point: Apogee altitude</li> <li>Lower point: Perigee altitude</li> </ul> </li> </ul>"},{"location":"learn/plots/gabbard_plot.html#interpreting-patterns","title":"Interpreting Patterns","text":"<p>Tight vertical pairs: Low eccentricity (near-circular orbits)</p> <p>Wide vertical separation: High eccentricity (elliptical orbits)</p>"},{"location":"learn/plots/gabbard_plot.html#tips","title":"Tips","text":"<ul> <li>Use <code>backend=\"plotly\"</code> to identify outliers and explore specific objects interactively</li> <li>Add reference lines for altitude constraints (e.g., ISS orbit, debris-heavy regions)</li> </ul>"},{"location":"learn/plots/gabbard_plot.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Elements - Understanding orbital parameters</li> <li>Propagators - Creating propagators from TLEs</li> </ul>"},{"location":"learn/plots/ground_tracks.html","title":"Ground Tracks","text":"<p>Ground track plotting visualizes the path a satellite traces over Earth's surface. This is essential for mission planning, coverage analysis, and understanding when and where a satellite can communicate with ground stations. Brahe's <code>plot_groundtrack</code> function renders satellite trajectories on a world map with optional ground station markers and communication coverage cones.</p>"},{"location":"learn/plots/ground_tracks.html#interactive-ground-track-plotly","title":"Interactive Ground Track (Plotly)","text":"<p>The plotly backend creates interactive maps that you can pan, zoom, and explore. Hover over the satellite track to see precise coordinates.</p> Plot Source groundtrack_plotly.py<pre><code>\"\"\"\nGround Track Plotting Example - Plotly Backend\n\nThis script demonstrates how to create an interactive ground track plot using the plotly backend.\nIt shows the ISS ground track with a ground station communication cone.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create ground track plot\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n    ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n    gs_cone_altitude=420e3,  # ISS altitude\n    gs_min_elevation=10.0,\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example shows:</p> <ul> <li>ISS ground track over one orbital period (red line)</li> <li>Cape Canaveral ground station (blue marker)</li> <li>Communication cone showing the region where the ISS is visible above 10\u00b0 elevation</li> </ul> <p>The interactive plot allows you to:</p> <ul> <li>Zoom into specific regions</li> <li>Pan across the map</li> <li>Hover to see exact coordinates</li> <li>Toggle layers on/off</li> </ul>"},{"location":"learn/plots/ground_tracks.html#static-ground-track-matplotlib","title":"Static Ground Track (Matplotlib)","text":"<p>The matplotlib backend produces publication-ready static figures ideal for reports and papers.</p> Plot Source groundtrack_matplotlib.py<pre><code>\"\"\"\nGround Track Plotting Example - Matplotlib Backend\n\nThis script demonstrates how to create a ground track plot using the matplotlib backend.\nIt shows the ISS ground track with a ground station communication cone.\n\"\"\"\n\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (San Francisco)\nlat = 37.7749  # Latitude in degrees\nlon = -122.4194  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create ground track plot in light mode\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n    ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n    gs_cone_altitude=420e3,  # ISS altitude\n    gs_min_elevation=10.0,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_groundtrack_matplotlib_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(\n    \"Ground track plot (matplotlib, light mode) saved to: docs/figures/plot_groundtrack_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create ground track plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n        ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n        gs_cone_altitude=420e3,  # ISS altitude\n        gs_min_elevation=10.0,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_groundtrack_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Ground track plot (matplotlib, dark mode) saved to: docs/figures/plot_groundtrack_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n</code></pre> <p>The static plot shows the same information in a clean, professional format suitable for:</p> <ul> <li>Academic publications</li> <li>Technical reports</li> <li>Batch figure generation</li> <li>Custom post-processing with matplotlib</li> </ul>"},{"location":"learn/plots/ground_tracks.html#configuration-and-customization","title":"Configuration and Customization","text":""},{"location":"learn/plots/ground_tracks.html#multiple-spacecraft","title":"Multiple Spacecraft","text":"<p>Plot multiple satellites simultaneously to compare orbits or analyze constellations:</p> Plot Source groundtrack_multiple_spacecraft.py<pre><code>\"\"\"\nGround Track Multiple Spacecraft Example\n\nThis script demonstrates how to plot ground tracks for multiple satellites simultaneously\nwith different colors and line styles.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create three different LEO satellites with different orbits\n\n# Satellite 1: Sun-synchronous orbit (polar, high inclination)\noe1 = np.array([bh.R_EARTH + 700e3, 0.001, 98.0, 0.0, 0.0, 0.0])\nstate1 = bh.state_osculating_to_cartesian(oe1, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator.from_eci(epoch, state1, 60.0).with_name(\"Sun-Sync\")\n\n# Satellite 2: Medium inclination orbit\noe2 = np.array(\n    [\n        bh.R_EARTH + 600e3,\n        0.001,\n        55.0,\n        45.0,\n        0.0,\n        90.0,\n    ]\n)\nstate2 = bh.state_osculating_to_cartesian(oe2, bh.AngleFormat.DEGREES)\nprop2 = bh.KeplerianPropagator.from_eci(epoch, state2, 60.0).with_name(\"Mid-Inc\")\n\n# Satellite 3: Equatorial orbit\noe3 = np.array(\n    [\n        bh.R_EARTH + 800e3,\n        0.001,\n        5.0,\n        90.0,\n        0.0,\n        180.0,\n    ]\n)\nstate3 = bh.state_osculating_to_cartesian(oe3, bh.AngleFormat.DEGREES)\nprop3 = bh.KeplerianPropagator.from_eci(epoch, state3, 60.0).with_name(\"Equatorial\")\n\n# Propagate all satellites for 2 orbits\nduration = 2 * bh.orbital_period(oe1[0])\n\nprop1.propagate_to(epoch + duration)\nprop2.propagate_to(epoch + duration)\nprop3.propagate_to(epoch + duration)\n\n# Create ground track plot with all three satellites\nfig = bh.plot_groundtrack(\n    trajectories=[\n        {\"trajectory\": prop1.trajectory, \"color\": \"red\", \"line_width\": 2},\n        {\"trajectory\": prop2.trajectory, \"color\": \"blue\", \"line_width\": 2},\n        {\"trajectory\": prop3.trajectory, \"color\": \"green\", \"line_width\": 2},\n    ],\n    basemap=\"natural_earth\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example shows three different LEO orbits: - Red: Sun-synchronous orbit (98\u00b0 inclination, 700km altitude) - Blue: Medium inclination (55\u00b0, 600km altitude) - Green: Equatorial orbit (5\u00b0 inclination, 800km altitude)</p>"},{"location":"learn/plots/ground_tracks.html#ground-station-networks","title":"Ground Station Networks","text":"<p>Visualize satellite visibility over ground station networks with geodetic coverage zones:</p> Plot Source groundtrack_nasa_nen.py<pre><code>\"\"\"\nGround Track with NASA NEN Ground Stations Example\n\nThis script demonstrates plotting ground tracks with the NASA Near Earth Network (NEN)\nground stations, showing communication coverage at 550km altitude with 10\u00b0 minimum elevation.\nThe coverage cones are displayed as geodetic polygons showing actual ground footprints.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load NASA NEN ground stations\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nprint(f\"Loaded {len(nen_stations)} NASA NEN stations\")\n\n# Create a LEO satellite at 550km altitude\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 550e3, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"LEO Sat\")\n\n# Propagate for 2 orbits\nduration = 2 * bh.orbital_period(oe[0])\nprop.propagate_to(epoch + duration)\n\n# Create ground track plot with NASA NEN stations and communication cones\n# The coverage cones are automatically computed using proper geodesic geometry,\n# which correctly handles high latitudes and antimeridian crossings\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": prop.trajectory, \"color\": \"red\", \"line_width\": 2}],\n    ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.15}],\n    gs_cone_altitude=550e3,  # Satellite altitude for cone calculation\n    gs_min_elevation=10.0,  # Minimum elevation angle in degrees\n    basemap=\"natural_earth\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example demonstrates: - Loading the NASA Near Earth Network (NEN) ground stations from built-in datasets - Computing geodetic coverage zones for each station at 10\u00b0 minimum elevation - Displaying coverage as semi-transparent filled polygons on the map - Visualizing actual ground footprints for a 550km altitude LEO satellite</p> <p>The coverage zones are computed as properly transformed geodetic shapes, showing the actual region on Earth's surface where the satellite is visible above the minimum elevation angle.</p> <p>Available ground station networks include: <code>\"atlas\"</code>, <code>\"aws\"</code>, <code>\"ksat\"</code>, <code>\"leaf\"</code>, <code>\"nasa dsn\"</code>, <code>\"nasa nen\"</code>, <code>\"ssc\"</code>, and <code>\"viasat\"</code>.</p>"},{"location":"learn/plots/ground_tracks.html#map-styles","title":"Map Styles","text":"<p>Choose from different basemap styles to suit your presentation needs:</p>"},{"location":"learn/plots/ground_tracks.html#natural-earth-high-quality-vector","title":"Natural Earth (High-Quality Vector)","text":""},{"location":"learn/plots/ground_tracks.html#stock-cartopy-built-in-minimal","title":"Stock (Cartopy Built-in, Minimal)","text":""},{"location":"learn/plots/ground_tracks.html#blue-marble-satellite-imagery","title":"Blue Marble (Satellite Imagery)","text":"Plot Source groundtrack_basemaps.py<pre><code>\"\"\"\nGround Track Basemap Styles Example\n\nThis script demonstrates different basemap styles available for ground track plots:\n- natural_earth: High-quality vector basemap from Natural Earth Data\n- stock: Cartopy's built-in coastlines only\n- blue_marble: NASA Blue Marble satellite imagery background\n\"\"\"\n\nimport os\nimport pathlib\nimport brahe as bh\nimport matplotlib.pyplot as plt\nfrom brahe.plots.texture_utils import get_blue_marble_texture_path\nfrom PIL import Image\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop.epoch\n\n# Propagate for one orbital period\nduration = 92.0 * 60.0  # ~92 minutes for ISS\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create three versions with different basemaps\n\n# 1. Natural Earth - High-quality vector basemap\nfig_ne = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=\"natural_earth\",\n    backend=\"matplotlib\",\n)\nfig_ne.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_natural_earth_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_natural_earth_light.svg\")\nplt.close(fig_ne)\n\n# 2. Stock - Cartopy built-in features (no outlines)\nfig_stock = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=\"stock\",\n    show_borders=False,  # Remove country borders\n    show_coastlines=False,  # Remove coastlines\n    backend=\"matplotlib\",\n)\nfig_stock.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_stock_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_stock_light.svg\")\nplt.close(fig_stock)\n\n# 3. Blue Marble - NASA satellite imagery\n# Load Blue Marble texture\nblue_marble_path = get_blue_marble_texture_path()\nblue_marble_img = Image.open(blue_marble_path)\n\nfig_bluemarble = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=None,  # No basemap, we'll add the image manually\n    show_borders=False,  # Remove country borders\n    show_coastlines=False,  # Remove coastlines\n    backend=\"matplotlib\",\n)\nax_bm = fig_bluemarble.get_axes()[0]\n# Display Blue Marble as background\nax_bm.imshow(\n    blue_marble_img,\n    origin=\"upper\",\n    extent=[-180, 180, -90, 90],\n    transform=ax_bm.projection,\n    zorder=0,\n)\nfig_bluemarble.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_blue_marble_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_blue_marble_light.svg\")\nplt.close(fig_bluemarble)\n\n# Generate dark mode versions\nwith plt.style.context(\"dark_background\"):\n    # Natural Earth (dark)\n    fig_ne_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=\"natural_earth\",\n        backend=\"matplotlib\",\n    )\n    fig_ne_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_ne_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_ne_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_natural_earth_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_natural_earth_dark.svg\")\n    plt.close(fig_ne_dark)\n\n    # Stock (dark)\n    fig_stock_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=\"stock\",\n        show_borders=False,  # Remove country borders\n        show_coastlines=False,  # Remove coastlines\n        backend=\"matplotlib\",\n    )\n    fig_stock_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_stock_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_stock_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_stock_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_stock_dark.svg\")\n    plt.close(fig_stock_dark)\n\n    # Blue Marble (dark)\n    fig_bluemarble_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=None,  # No basemap, we'll add the image manually\n        show_borders=False,  # Remove country borders\n        show_coastlines=False,  # Remove coastlines\n        backend=\"matplotlib\",\n    )\n    ax_bm_dark = fig_bluemarble_dark.get_axes()[0]\n    ax_bm_dark.imshow(\n        blue_marble_img,\n        origin=\"upper\",\n        extent=[-180, 180, -90, 90],\n        transform=ax_bm_dark.projection,\n        zorder=0,\n    )\n    fig_bluemarble_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_bluemarble_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_bluemarble_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_blue_marble_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_blue_marble_dark.svg\")\n    plt.close(fig_bluemarble_dark)\n</code></pre> <p>The basemap styles offer different visualization approaches: - Natural Earth: High-quality vector map with political boundaries and natural features (default) - Stock: Minimal Cartopy background without geographic features, ideal for clean presentations - Blue Marble: NASA satellite imagery texture provides photorealistic Earth background</p> <p>Set the <code>basemap</code> parameter to <code>\"natural_earth\"</code> (default), <code>\"stock\"</code>, or <code>None</code> to control the map style. For Blue Marble, use <code>basemap=None</code> and manually overlay the texture image.</p> <p>Backend Capabilities</p> <p>Matplotlib backend supports all basemap styles including Natural Earth shapefiles and Blue Marble textures.</p> <p>Plotly backend uses Scattergeo which only supports outline-based maps with solid colors. Custom textures (Natural Earth shapefiles, Blue Marble imagery) are not available in the plotly backend. Use <code>basemap=\"natural_earth\"</code> for a light gray landmass color or <code>basemap=\"stock\"</code> for tan.</p>"},{"location":"learn/plots/ground_tracks.html#advanced-examples","title":"Advanced Examples","text":""},{"location":"learn/plots/ground_tracks.html#maximum-coverage-gap-analysis","title":"Maximum Coverage Gap Analysis","text":"<p>This advanced example identifies the longest period without ground station contact and visualizes only that critical gap segment:</p> <p>This demonstrates how to: - Compute access windows between a satellite and ground network - Find the longest gap between consecutive contacts - Extract and plot only the gap segment (without the full 24-hour ground track) - Handle antimeridian wraparound with custom plotting</p> Plot Source groundtrack_max_gap.py<pre><code>\"\"\"\nGround Track Maximum Coverage Gap Analysis\n\nThis advanced example demonstrates how to:\n1. Compute access windows between a satellite and ground station network\n2. Find the maximum gap between consecutive accesses\n3. Extract and plot the ground track segment during that gap\n4. Handle antimeridian wraparound in custom plotting\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load NASA NEN ground stations\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nprint(f\"Loaded {len(nen_stations)} NASA NEN stations\")\n\n# Create ISS propagator using TLE\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop.epoch\n\n# Define 24-hour analysis period\nduration = 24.0 * 3600.0  # 24 hours in seconds\nsearch_end = epoch + duration\n\n# Compute access windows with 10\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses(nen_stations, [prop], epoch, search_end, constraint)\n\nprint(f\"Found {len(accesses)} access windows over 24 hours\")\n\n# Find the longest gap between consecutive accesses\nmax_gap_duration = 0.0\nmax_gap_start = None\nmax_gap_end = None\n\nif len(accesses) &gt; 1:\n    # Sort accesses by start time\n    sorted_accesses = sorted(accesses, key=lambda a: a.start.jd())\n\n    for i in range(len(sorted_accesses) - 1):\n        gap_start = sorted_accesses[i].end\n        gap_end = sorted_accesses[i + 1].start\n        gap_duration = gap_end - gap_start  # Difference in seconds\n\n        if gap_duration &gt; max_gap_duration:\n            max_gap_duration = gap_duration\n            max_gap_start = gap_start\n            max_gap_end = gap_end\n\n# Check gap from last access to end of period\nif len(sorted_accesses) &gt; 0:\n    final_gap_start = sorted_accesses[-1].end\n    final_gap_end = search_end\n    final_gap_duration = final_gap_end - final_gap_start\n\n    if final_gap_duration &gt; max_gap_duration:\n        max_gap_duration = final_gap_duration\n        max_gap_start = final_gap_start\n        max_gap_end = final_gap_end\n\nprint(\"\\nMaximum coverage gap:\")\nprint(f\"  Duration: {max_gap_duration / 60.0:.2f} minutes\")\nstart_dt = max_gap_start.to_datetime()\nend_dt = max_gap_end.to_datetime()\nprint(\n    f\"  Start: {start_dt[0]}-{start_dt[1]:02d}-{start_dt[2]:02d} {start_dt[3]:02d}:{start_dt[4]:02d}:{start_dt[5]:02.0f}\"\n)\nprint(\n    f\"  End: {end_dt[0]}-{end_dt[1]:02d}-{end_dt[2]:02d} {end_dt[3]:02d}:{end_dt[4]:02d}:{end_dt[5]:02.0f}\"\n)\n\n# Propagate satellite for full 24 hours to get complete trajectory\nprop.propagate_to(search_end)\nfull_traj = prop.trajectory\n\n# Extract ground track segment during maximum gap\n# Get states and epochs from trajectory\nstates = full_traj.to_matrix()\nepochs = full_traj.epochs()\n\n# Find indices corresponding to gap period\ngap_states = []\ngap_epochs = []\ngap_lons = []\ngap_lats = []\n\nfor i, ep in enumerate(epochs):\n    if max_gap_start &lt;= ep &lt;= max_gap_end:\n        gap_epochs.append(ep)\n        gap_states.append(states[i])\n\n        # Convert to geodetic coordinates\n        ecef_state = bh.state_eci_to_ecef(ep, states[i])\n        lon, lat, alt = bh.position_ecef_to_geodetic(\n            ecef_state[:3], bh.AngleFormat.RADIANS\n        )\n        gap_lons.append(np.degrees(lon))\n        gap_lats.append(np.degrees(lat))\n\nprint(f\"  Points in gap segment: {len(gap_lons)}\")\n\n# Split ground track at antimeridian crossings for proper plotting\nsegments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\nprint(f\"  Track segments (after wraparound split): {len(segments)}\")\n\n# Create base plot with stations only (no full trajectory)\nfig = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=420e3,\n    gs_min_elevation=10.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot only the maximum gap segment in red using custom plotting\nax = fig.get_axes()[0]\nfor i, (lon_seg, lat_seg) in enumerate(segments):\n    ax.plot(\n        lon_seg,\n        lat_seg,\n        color=\"red\",\n        linewidth=3,\n        transform=ccrs.Geodetic(),\n        zorder=10,\n        label=\"Max Gap\" if i == 0 else \"\",\n    )\n\n# Add legend\nax.legend(loc=\"lower left\")\n\n# Add title with gap duration\nax.set_title(\n    f\"ISS Maximum Coverage Gap: {max_gap_duration / 60.0:.1f} minutes\\n\"\n    f\"NASA NEN Network (10\u00b0 elevation)\",\n    fontsize=12,\n)\n\n# Save light mode\nfig.savefig(OUTDIR / f\"{SCRIPT_NAME}_light.svg\", dpi=300, bbox_inches=\"tight\")\nprint(f\"\\n\u2713 Generated {SCRIPT_NAME}_light.svg\")\nplt.close(fig)\n\n# Create dark mode version\nwith plt.style.context(\"dark_background\"):\n    fig_dark = bh.plot_groundtrack(\n        ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n        gs_cone_altitude=420e3,\n        gs_min_elevation=10.0,\n        basemap=\"stock\",\n        show_borders=False,\n        show_coastlines=False,\n        backend=\"matplotlib\",\n    )\n\n    # Plot only the maximum gap segment\n    ax_dark = fig_dark.get_axes()[0]\n    for i, (lon_seg, lat_seg) in enumerate(segments):\n        ax_dark.plot(\n            lon_seg,\n            lat_seg,\n            color=\"red\",\n            linewidth=3,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=\"Max Gap\" if i == 0 else \"\",\n        )\n\n    ax_dark.legend(loc=\"lower left\")\n    ax_dark.set_title(\n        f\"ISS Maximum Coverage Gap: {max_gap_duration / 60.0:.1f} minutes\\n\"\n        f\"NASA NEN Network (10\u00b0 elevation)\",\n        fontsize=12,\n    )\n\n    # Set dark background\n    fig_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    fig_dark.savefig(OUTDIR / f\"{SCRIPT_NAME}_dark.svg\", dpi=300, bbox_inches=\"tight\")\n    print(f\"\u2713 Generated {SCRIPT_NAME}_dark.svg\")\n    plt.close(fig_dark)\n</code></pre> <p>This example uses the <code>split_ground_track_at_antimeridian()</code> helper function to properly handle longitude wraparound when plotting custom ground track segments. The helper function detects jumps across the \u00b1180\u00b0 boundary and splits the track into separate segments for correct rendering.</p>"},{"location":"learn/plots/ground_tracks.html#additional-features","title":"Additional Features","text":""},{"location":"learn/plots/ground_tracks.html#coverage-zones","title":"Coverage Zones","text":"<p>Add polygon zones for restricted areas, target regions, or sensor footprints:</p> <pre><code>import numpy as np\n\n# Define a restricted zone\nvertices = [\n    (np.radians(30.0), np.radians(-100.0)),  # lat, lon\n    (np.radians(35.0), np.radians(-100.0)),\n    (np.radians(35.0), np.radians(-95.0)),\n    (np.radians(30.0), np.radians(-95.0))\n]\nzone = bh.PolygonLocation(vertices)\n\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    zones=[{\n        \"zone\": zone,\n        \"fill\": True,\n        \"fill_color\": \"red\",\n        \"fill_alpha\": 0.2,\n        \"edge\": True,\n        \"edge_color\": \"red\"\n    }]\n)\n</code></pre>"},{"location":"learn/plots/ground_tracks.html#map-extent","title":"Map Extent","text":"<p>Zoom into specific regions using the <code>extent</code> parameter:</p> <pre><code># Focus on North America\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    extent=[-130, -60, 20, 50],  # [lon_min, lon_max, lat_min, lat_max]\n    backend=\"matplotlib\"\n)\n</code></pre>"},{"location":"learn/plots/ground_tracks.html#tips","title":"Tips","text":"<ul> <li>Use <code>backend=\"plotly\"</code> for interactive exploration and presentations</li> <li>Use <code>backend=\"matplotlib\"</code> for publication-quality static figures</li> <li>Set <code>gs_cone_altitude</code> to your satellite's altitude for accurate coverage visualization</li> <li>Adjust <code>gs_min_elevation</code> based on antenna pointing constraints (typically 5-15\u00b0)</li> <li>Use <code>extent</code> parameter to zoom into specific regions of interest</li> <li>Control displayed track length with <code>track_length</code> and <code>track_units</code> parameters</li> <li>Use <code>split_ground_track_at_antimeridian()</code> when creating custom ground track overlays to handle longitude wraparound</li> <li>Choose basemap style based on your audience: <code>\"natural_earth\"</code> for presentations, <code>\"stock\"</code> for quick analysis, <code>None</code> for minimal distraction</li> </ul>"},{"location":"learn/plots/ground_tracks.html#see-also","title":"See Also","text":"<ul> <li>plot_groundtrack API Reference - Complete function documentation</li> <li>split_ground_track_at_antimeridian API Reference - Wraparound handling</li> <li>Access Geometry - Detailed visibility analysis</li> <li>PointLocation - Ground station definitions</li> <li>PolygonLocation - Zone definitions</li> </ul>"},{"location":"learn/plots/orbital_trajectories.html","title":"Orbital Element Trajectories","text":"<p>Orbital element trajectory plots track how position, velocity, and orbital parameters evolve over time. Brahe provides two complementary views: Cartesian plots showing state vectors (x, y, z, vx, vy, vz) and Keplerian plots showing classical elements (a, e, i, \u03a9, \u03c9, \u03bd). These visualizations are essential for analyzing perturbations, verifying propagators, and understanding orbital dynamics.</p>"},{"location":"learn/plots/orbital_trajectories.html#cartesian-state-vector-plots","title":"Cartesian State Vector Plots","text":"<p>Cartesian plots display position and velocity components in ECI coordinates, useful for debugging propagators and analyzing state evolution.</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-cartesian-plot-plotly","title":"Interactive Cartesian Plot (Plotly)","text":"Plot Source cartesian_trajectory_plotly.py<pre><code>\"\"\"\nCartesian Trajectory Plot Example - Plotly Backend\n\nThis script demonstrates how to plot Cartesian state elements (x, y, z, vx, vy, vz) vs time\nusing the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period\nepoch = prop.epoch\nduration = bh.orbital_period(prop.semi_major_axis)\nprint(f\"Propagating from {epoch} for {duration} seconds.\")\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Cartesian trajectory plot\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-cartesian-plot-matplotlib","title":"Static Cartesian Plot (Matplotlib)","text":"Plot Source cartesian_trajectory_matplotlib.py<pre><code>\"\"\"\nCartesian Trajectory Plot Example - Matplotlib Backend\n\nThis script demonstrates how to plot Cartesian state elements (x, y, z, vx, vy, vz) vs time\nusing the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = bh.orbital_period(prop.semi_major_axis)\nprint(f\"Propagating from {epoch} for {duration} seconds.\")\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Cartesian trajectory plot in light mode\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_cartesian_trajectory_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Cartesian trajectory plot (matplotlib, light mode) saved to: docs/figures/plot_cartesian_trajectory_matplotlib_light.svg\"\n)\n\n# Create Cartesian trajectory plot in dark mode\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/plot_cartesian_trajectory_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Cartesian trajectory plot (matplotlib, dark mode) saved to: docs/figures/plot_cartesian_trajectory_matplotlib_dark.svg\"\n)\n</code></pre> <p>The 2\u00d73 subplot layout shows:</p> <ul> <li>Top row: x, y, z position components (km)</li> <li>Bottom row: vx, vy, vz velocity components (km/s)</li> </ul> <p>For circular orbits, you'll see sinusoidal patterns. Elliptical orbits show variations in velocity magnitude.</p>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-orbital-element-plots","title":"Keplerian Orbital Element Plots","text":"<p>Keplerian plots display classical orbital elements, ideal for understanding long-term evolution and perturbation effects.</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-keplerian-plot-plotly","title":"Interactive Keplerian Plot (Plotly)","text":"Plot Source keplerian_trajectory_plotly.py<pre><code>\"\"\"\nKeplerian Trajectory Plot Example - Plotly Backend\n\nThis script demonstrates how to plot Keplerian orbital elements (a, e, i, \u03a9, \u03c9, \u03bd) vs time\nusing the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Keplerian trajectory plot\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"plotly\",\n    plotly_config={\"set_angle_ylim\": True},\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-keplerian-plot-matplotlib","title":"Static Keplerian Plot (Matplotlib)","text":"Plot Source keplerian_trajectory_matplotlib.py<pre><code>\"\"\"\nKeplerian Trajectory Plot Example - Matplotlib Backend\n\nThis script demonstrates how to plot Keplerian orbital elements (a, e, i, \u03a9, \u03c9, \u03bd) vs time\nusing the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Keplerian trajectory plot in light mode\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False, \"set_angle_ylim\": True},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_keplerian_trajectory_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Keplerian trajectory plot (matplotlib, light mode) saved to: docs/figures/plot_keplerian_trajectory_matplotlib_light.svg\"\n)\n\n# Create Keplerian trajectory plot in dark mode\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True, \"set_angle_ylim\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/plot_keplerian_trajectory_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Keplerian trajectory plot (matplotlib, dark mode) saved to: docs/figures/plot_keplerian_trajectory_matplotlib_dark.svg\"\n)\n</code></pre> <p>The 2\u00d73 subplot layout shows:</p> <ul> <li>Semi-major axis (a): Average orbital radius</li> <li>Eccentricity (e): Orbit shape (0 = circular, &gt;0 = elliptical)</li> <li>Inclination (i): Orbital plane tilt</li> <li>RAAN (\u03a9): Right ascension of ascending node</li> <li>Argument of periapsis (\u03c9): Orbit orientation in plane</li> <li>Mean anomaly (M): Position along orbit</li> </ul>"},{"location":"learn/plots/orbital_trajectories.html#comparing-different-propagators","title":"Comparing Different Propagators","text":"<p>Compare different propagators to verify agreement or identify perturbation effects. These examples show how Keplerian (two-body) and SGP4 propagators diverge over time due to atmospheric drag and other perturbations.</p> <p>The plots show how the two propagation methods diverge:</p> <ul> <li>Keplerian (blue): Assumes pure two-body dynamics with no perturbations</li> <li>SGP4 (red): Includes atmospheric drag and other perturbations</li> </ul> <p>For near-circular LEO orbits, we notice there is significant variation in the argument of perigee (\u03c9) and mean anomaly (M) over time due to numerical instability and ill-conditioning of these elements for near-circular orbits.</p>"},{"location":"learn/plots/orbital_trajectories.html#cartesian-state-comparison","title":"Cartesian State Comparison","text":"<p>Comparing propagators in Cartesian space shows position and velocity component differences:</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-cartesian-comparison-plotly","title":"Interactive Cartesian Comparison (Plotly)","text":"Plot Source comparing_propagators_cartesian_plotly.py<pre><code>\"\"\"\nComparing Propagators (Cartesian) Example - Plotly Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Cartesian state trajectories side-by-side using the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial state\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\nprint(\n    f\"Propagating from {epoch} for {duration:.0f} seconds ({duration / 3600:.1f} hours).\"\n)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-cartesian-comparison-matplotlib","title":"Static Cartesian Comparison (Matplotlib)","text":"Plot Source comparing_propagators_cartesian_matplotlib.py<pre><code>\"\"\"\nComparing Propagators (Cartesian) Example - Matplotlib Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Cartesian state trajectories side-by-side using the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial state\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\nprint(\n    f\"Propagating from {epoch} for {duration:.0f} seconds ({duration / 3600:.1f} hours).\"\n)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\nprint(f\"Keplerian trajectory: {len(traj_kep)} states\")\nprint(f\"SGP4 trajectory: {len(traj_sgp)} states\")\n\n# Create comparison plot in light mode\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_cartesian_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Cartesian) plot (matplotlib, light mode) saved to: docs/figures/comparing_propagators_cartesian_matplotlib_light.svg\"\n)\n\n# Create comparison plot in dark mode\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_cartesian_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Cartesian) plot (matplotlib, dark mode) saved to: docs/figures/comparing_propagators_cartesian_matplotlib_dark.svg\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-element-comparison","title":"Keplerian Element Comparison","text":"<p>Comparing propagators using Keplerian elements reveals how orbital parameters evolve differently:</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-keplerian-comparison-plotly","title":"Interactive Keplerian Comparison (Plotly)","text":"Plot Source comparing_propagators_keplerian_plotly.py<pre><code>\"\"\"\nComparing Propagators (Keplerian) Example - Plotly Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Keplerian element trajectories side-by-side using the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Create Keplerian propagator with same initial Cartesian state as SGP4\n# This ensures both propagators store states in the same representation (Cartesian)\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, prop_sgp.state_eci(epoch), 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot using Keplerian elements with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": prop_kep.trajectory, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": prop_sgp.trajectory, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"plotly\",\n    plotly_config={\"set_angle_ylim\": True, \"set_eccentricity_ylim\": True},\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-keplerian-comparison-matplotlib","title":"Static Keplerian Comparison (Matplotlib)","text":"Plot Source comparing_propagators_keplerian_matplotlib.py<pre><code>\"\"\"\nComparing Propagators (Keplerian) Example - Matplotlib Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Keplerian element trajectories side-by-side using the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\n# Using state_eci() to ensure we get Cartesian coordinates\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial Cartesian state\n# This ensures both propagators store states in the same representation (Cartesian)\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot using Keplerian elements in light mode with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\n        \"dark_mode\": False,\n        \"set_angle_ylim\": True,\n        \"set_eccentricity_ylim\": True,\n    },\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_keplerian_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Keplerian) plot (matplotlib, light mode) saved to: docs/figures/comparing_propagators_keplerian_matplotlib_light.svg\"\n)\n\n# Create comparison plot using Keplerian elements in dark mode with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\n        \"dark_mode\": True,\n        \"set_angle_ylim\": True,\n        \"set_eccentricity_ylim\": True,\n    },\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_keplerian_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Keplerian) plot (matplotlib, dark mode) saved to: docs/figures/comparing_propagators_keplerian_matplotlib_dark.svg\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#unit-customization","title":"Unit Customization","text":""},{"location":"learn/plots/orbital_trajectories.html#cartesian-plots","title":"Cartesian Plots","text":"<pre><code># Meters and m/s\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj}],\n    position_units=\"m\",\n    velocity_units=\"m/s\"\n)\n\n# Kilometers and km/s (default)\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj}],\n    position_units=\"km\",\n    velocity_units=\"km/s\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-plots","title":"Keplerian Plots","text":"<pre><code># Degrees (default)\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj}],\n    sma_units=\"km\",\n    angle_units=\"deg\"\n)\n\n# Radians\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj}],\n    sma_units=\"km\",\n    angle_units=\"rad\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#see-also","title":"See Also","text":"<ul> <li>plot_cartesian_trajectory API Reference</li> <li>plot_keplerian_trajectory API Reference</li> <li>3D Trajectories - Spatial visualization</li> <li>Orbital Anomalies - Understanding orbital parameters</li> <li>Propagators - Orbit propagation</li> </ul>"},{"location":"learn/time/index.html","title":"Time Systems and Representations","text":"<p>In the beginning the Universe was created. This has made a lot of people very angry and has been widely regarded as a bad move</p> <ul> <li>Douglas Adams</li> </ul> <p>Astrodynamics is the study of motion in space, which is inextricably linked with the concept of time. You cannot have motion without time. The trajectory of an object is defined by how it's state (location) changes between different points in time. As one might therefore expect, accurate timekeeping and the ability to convert between different representations of time are crucial for calculations in orbital mechanics.</p> <p>The <code>time</code> module provides functions for the handling of time. The package makes the distinction between the representation of a specific time and the conversion between different time scales. Precise specification of an instant in time requires the specification of both a time representation and time scale.</p>"},{"location":"learn/time/index.html#time-representation","title":"Time Representation","text":"<p>A single instance in time can be represented in multiple different formats. For examples The J2000 Epoch can be represented as a calendar date in terms of years, months, days, hours, minutes, and seconds as <code>2000-01-01T12:00:00</code>. The same instant can also be represented in terms of Modified Julian Days as <code>51544.5</code>. Both of these representations refer to the same instant in time.</p>"},{"location":"learn/time/index.html#time-scales","title":"Time Scales","text":"<p>In addition to representing time in different manners, there are also different time scales. A time scale is a standard to reckoning and resolving instances in time. Multimple time scales have been introduced due to the criticality of being able to correctly measure and understand when specific events occur in science and engineering.  </p> <p>Within a time scale it is possible to compare different instances in time to determine if one is before, after, or at the same time as another instant. It is also possible to compare between time scales, however you must know how to properly convert between them. It is assumed that all time scales use the same definition of the SI second, and therefore advance at the same rate.</p> <p>Athough the calendar date representations of time <code>2000-01-01T12:00:00 UTC</code> and <code>2000-01-01T12:00:00 GPS</code> have the same values, they are actually  different instances in time!. This is because while the calendar date representations are the same there are actually offsets between the different time scales.</p> <p>The time scales currently supported by brahe are</p> Time Scale Description <code>GPS</code> <code>GPS</code> stands for Global Positioning System time. It is specifically, the time scale used by the US GPS satellites. It is different from TAI and TT by constant, fixed offsets. <code>TAI</code> <code>TAI</code> is a French acronym for temps atomique international. It is an atomic time scale meant to track the proper time on the Earth's surface. <code>UTC</code> <code>UTC</code> stands for Universal Coordinated Time. <code>UTC</code> tracks the solar day, accounting for long term variations due to changes in Earth's rotation to within +/- 1 second. Tracking the solar day in this manner introduces an offset between <code>TAI</code> and <code>UTC</code> of a fixed number of leap seconds. <code>UT1</code> <code>UT1</code> stands for Universal Time 1. <code>UT1</code> represents the time as determined by the true solar day. Due to Earth's rotation rate constantly changing UT1 itself is constantly changing. The difference between <code>UT1</code> and <code>UTC</code> is empirically estimated on a daily basis as an Earth orientation parameter. <code>TT</code> <code>TT</code> is Terrestrial Time, a time scale used historically to model the motion of planets and other solar system bodies. These models are still in wide use."},{"location":"learn/time/index.html#epoch","title":"Epoch","text":"<p>The <code>Epoch</code> type represents a specific instant in time, defined by both a time representation and a time scale. The <code>Epoch</code> type provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>It is the core type used throughout the brahe package to represent time and provides many advandages as </p>"},{"location":"learn/time/index.html#see-also","title":"See Also","text":"<ul> <li>Epoch - Complete guide to the Epoch type</li> <li>Time API Reference - Complete time function documentation</li> <li>Time Constants - Important time-related constants</li> </ul>"},{"location":"learn/time/epoch.html","title":"Epoch","text":"<p>The Epoch class is the fundamental time representation in Brahe. It encapsulates a specific instant in time, defined by both a time representation and a time scale. The Epoch class provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>There are even more capabilities and features of the Epoch class beyond what is covered in this guide. For a complete reference of all available methods and properties, please refer to the Epoch API Reference.</p>"},{"location":"learn/time/epoch.html#initialization","title":"Initialization","text":"<p>There are all sorts of ways you can initialize an Epoch instance. The most common methods are described below.</p>"},{"location":"learn/time/epoch.html#date-time","title":"Date Time","text":"<p>The most common way to create an Epoch is from date and time components. You can specify just a date (which defaults to midnight), or provide the full date and time including fractional seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from date only (midnight)\nepc1 = bh.Epoch(2024, 1, 1)\nprint(f\"Date only: {epc1}\")\n# Date only: 2024-01-01 00:00:00.000 UTC\n\n# Create epoch from full datetime components\nepc2 = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Full datetime: {epc2}\")\n# Full datetime: 2024-06-15 14:30:45.500 UTC\n\n# Create epoch with different time system\nepc3 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TimeSystem.GPS)\nprint(f\"GPS time system: {epc3}\")\n# GPS time system: 2024-12-25 18:00:00.000 GPS\n\n# In Python you can also use the direct datetime constant\nepc4 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TAI)\nprint(f\"GPS time system: {epc4}\")\n# GPS time system: 2024-12-25 18:00:00.000 TAI\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from date only (midnight)\n    let epc1 = bh::Epoch::from_date(2024, 1, 1, bh::TimeSystem::UTC);\n    println!(\"Date only: {}\", epc1);\n\n    // Create epoch from full datetime components\n    let epc2 = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Full datetime: {}\", epc2);\n\n    // Create epoch with different time system\n    let epc3 = bh::Epoch::from_datetime(2024, 12, 25, 18, 0, 0.0, 0.0, bh::TimeSystem::GPS);\n    println!(\"GPS time system: {}\", epc3);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#mjd","title":"MJD","text":"<p>Modified Julian Date (MJD) is a commonly used time representation in astronomy and astrodynamics. MJD is defined as JD - 2400000.5, which makes it more convenient for modern dates.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from MJD\nmjd = 61041.5\nepc2 = bh.Epoch.from_mjd(mjd, bh.UTC)\nprint(f\"MJD {mjd}: {epc2}\")\n# MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n# Verify round-trip conversion\nmjd_out = epc2.mjd()\nprint(f\"Round-trip MJD: {mjd_out:.6f}\")\n# Round-trip MJD: 61041.500000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from MJD\n    let mjd = 61041.5; // 2024-01-01 12:00:00 UTC\n    let epc2 = bh::Epoch::from_mjd(mjd, bh::TimeSystem::UTC);\n    println!(\"MJD {}: {}\", mjd, epc2);\n    // MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let mjd_out = epc2.mjd();\n    println!(\"Round-trip MJD: {:.6}\", mjd_out);\n    // Round-trip MJD: 61041.500000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#jd","title":"JD","text":"<p>Julian Date (JD) is a continuous count of days since the beginning of the Julian Period. It's widely used in astronomy for precise time calculations.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from JD\njd = 2460310.5\nepc = bh.Epoch.from_jd(jd, bh.UTC)\nprint(f\"JD {jd}: {epc}\")\n# JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"Round-trip JD: {jd_out:.10f}\")\n# Round-trip JD: 2460310.5000000000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from JD\n    let jd = 2460310.5;\n    let epc = bh::Epoch::from_jd(jd, bh::TimeSystem::UTC);\n    println!(\"JD {}: {}\", jd, epc);\n    // JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let jd_out = epc.jd();\n    println!(\"Round-trip JD: {:.10}\", jd_out);\n    // Round-trip JD: 2460310.5000000000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string","title":"String","text":"<p>Epoch instances can be created from ISO 8601 formatted strings or simple date-time strings. The time system can be specified in the string.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# The string can be an ISO 8601 format\nepc1 = bh.Epoch.from_string(\"2025-01-02T04:56:54.123Z\")\nprint(f\"ISO 8601: {epc1}\")\n\n# It can be a simple space-separated format with a time system\nepc2 = bh.Epoch.from_string(\"2024-06-15 14:30:45.500 GPS\")\nprint(f\"Simple format: {epc2}\")\n\n# It can be a datetime without a time system (defaults to UTC)\nepc3 = bh.Epoch.from_string(\"2023-12-31 23:59:59\")\nprint(f\"Datetime without time system: {epc3}\")\n\n# Or it can just be a date\nepc4 = bh.Epoch.from_string(\"2022-07-04\")\nprint(f\"Date only: {epc4}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // The string can be an ISO 8601 format\n    let epc1 = bh::Epoch::from_string(\"2025-01-02T04:56:54.123Z\").unwrap();\n    println!(\"ISO 8601: {}\", epc1);\n\n    // It can be a simple space-separated format with a time system\n    let epc2 = bh::Epoch::from_string(\"2024-06-15 14:30:45.500 GPS\").unwrap();\n    println!(\"Simple format: {}\", epc2);\n\n    // It can be a datetime without a time system (defaults to UTC)\n    let epc3 = bh::Epoch::from_string(\"2023-12-31 23:59:59\").unwrap();\n    println!(\"Datetime without time system: {}\", epc3);\n\n    // Or it can just be a date\n    let epc4 = bh::Epoch::from_string(\"2022-07-04\").unwrap();\n    println!(\"Date only: {}\", epc4);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#gps-week-and-seconds","title":"GPS Week and Seconds","text":"<p>For GPS applications, you can create epochs from GPS week number and seconds into the week, or from GPS seconds since the GPS epoch (January 6, 1980).</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from GPS week and seconds\n# Week 2390, day 2 (October 28, 2025)\nweek = 2390\nseconds = 2 * 86400.0\nepc1 = bh.Epoch.from_gps_date(week, seconds)\nprint(f\"GPS Week {week}, Seconds {seconds}: {epc1}\")\n# GPS Week 2390, Seconds 172800.0: 2025-10-28 00:00:00.000 GPS\n\n# Verify round-trip conversion\nweek_out, sec_out = epc1.gps_date()\nprint(f\"Round-trip: Week {week_out}, Seconds {sec_out:.1f}\")\n# Round-trip: Week 2390, Seconds 172800.0\n\n# Create from GPS seconds since GPS epoch\ngps_seconds = week * 7 * 86400.0 + seconds\nepc2 = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"GPS Seconds {gps_seconds}: {epc2}\")\n# GPS Seconds 1445644800.0: 2025-10-28 00:00:00.000 GPS\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from GPS week and seconds\n    // Week 2390, day 2 (October 28, 2025)\n    let week = 2390;\n    let seconds = 2.0 * 86400.0; // 3 days + 12 hours\n    let epc1 = bh::Epoch::from_gps_date(week, seconds);\n    println!(\"GPS Week {}, Seconds {}: {}\", week, seconds, epc1);\n    // GPS Week 2390, Seconds 172800: 2025-10-28 00:00:00.000 GPS\n\n    // Verify round-trip conversion\n    let (week_out, sec_out) = epc1.gps_date();\n    println!(\"Round-trip: Week {}, Seconds {:.1}\", week_out, sec_out);\n    // Round-trip: Week 2390, Seconds 172800.0\n\n    // Create from GPS seconds since GPS epoch\n    let gps_seconds = week as f64 * 7.0 * 86400.0 + seconds;\n    let epc2 = bh::Epoch::from_gps_seconds(gps_seconds);\n    println!(\"GPS Seconds {}: {}\", gps_seconds, epc2);\n    // 1445644800: 2025-10-28 00:00:00.000 GPS\n}\n</code></pre>"},{"location":"learn/time/epoch.html#operations","title":"Operations","text":"<p>Once you have an epoch class instance you can add and subtract time as you would expect.</p> <p>Info</p> <p>When performing arithmetic the other operand is always interpreted as a time duration in seconds.</p>"},{"location":"learn/time/epoch.html#addition","title":"Addition","text":"<p>You can add a time duration (in seconds) to an Epoch to get a new Epoch at a later time.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2025, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"Original epoch: {epc}\")\n# Original epoch: 2025-01-01 12:00:00.000 UTC\n\n# You can add time in seconds to an Epoch and get a new Epoch back\n\n# Add 1 hour (3600 seconds)\nepc_plus_hour = epc + 3600.0\nprint(f\"Plus 1 hour: {epc_plus_hour}\")\n# Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n# Add 1 day (86400 seconds)\nepc_plus_day = epc + 86400.0\nprint(f\"Plus 1 day: {epc_plus_day}\")\n# Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n# You can also do in-place addition\n\n# Add 1 second in-place\nepc += 1.0\nprint(f\"In-place plus 1 second: {epc}\")\n# In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n# Add 1 milisecond in-place\nepc += 0.001\nprint(f\"In-place plus 1 millisecond: {epc}\")\n# In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2025, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Original epoch: {}\", epc);\n    // Original epoch: 2025-01-01 12:00:00.000 UTC\n\n    // You can add time in seconds to an Epoch and get a new Epoch back\n\n    // Add 1 hour (3600 seconds)\n    let epc_plus_hour = epc + 3600.0;\n    println!(\"Plus 1 hour: {}\", epc_plus_hour);\n    // Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n    // Add 1 day (86400 seconds)\n    let epc_plus_day = epc + 86400.0;\n    println!(\"Plus 1 day: {}\", epc_plus_day);\n    // Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n    // You can also do in-place addition\n\n    // Add 1 second in-place\n    let mut epc = epc;\n    epc += 1.0;\n    println!(\"In-place plus 1 second: {}\", epc);\n    // In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n    // Add 1 millisecond in-place\n    epc += 0.001;\n    println!(\"In-place plus 1 millisecond: {}\", epc);\n    // In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#subtraction","title":"Subtraction","text":"<p>Subtracting two Epoch instances returns the time difference between them in seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# You can subtract two Epoch instances to get the time difference in seconds\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(2024, 1, 2, 12, 1, 1.0, 0.0)\n\ndt = epc2 - epc1\nprint(f\"Time difference: {dt:.1f} seconds\")\n\n\n# You can also subtract a float (in seconds) from an Epoch to get a new Epoch\nepc = bh.Epoch(2024, 6, 15, 10, 30, 0.0, 0.0)\n\n# Subtract 1 hour (3600 seconds)\nepc_minus_hour = epc - 3600.0\nprint(f\"Minus 1 hour: {epc_minus_hour}\")\n\n# You can also update an Epoch in-place by subtracting seconds\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, 0.0)\nepc -= 61.0  # Subtract 61 seconds\nprint(f\"In-place minus 61 seconds: {epc}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create two epochs\n    let epc1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc2 = bh::Epoch::from_datetime(2024, 1, 2, 13, 1, 1.0, 0.0, bh::TimeSystem::UTC);\n\n    // Compute time difference in seconds\n    let dt = epc2 - epc1;\n    println!(\"Time difference: {:.1} seconds\", dt);\n    // Time difference: 90061.0 seconds\n\n    // You can also subtract a float (in seconds) from an Epoch to get a new Epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 10, 30, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_minus_hour = epc - 3600.0;\n    println!(\"Minus 1 hour: {}\", epc_minus_hour);\n    // Minus 1 hour: 2024-06-15 09:30:00.000 UTC\n\n    // You can also update an Epoch in-place by subtracting seconds\n    let mut epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    epc -= 61.0; // Subtract 61 seconds\n    println!(\"In-place minus 61 seconds: {}\", epc);\n    // In-place minus 61 seconds: 2023-12-31 23:58:59.000 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#other-operations","title":"Other Operations","text":"<p>The Epoch class also supports comparison operations (e.g., equality, less than, greater than) to compare different time instances. It also supports methods for getting string representations using language-specific formatting options.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc_1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc_2 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 1.0)\nepc_3 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\n\n# You can compare two Epoch instances for equality\nprint(f\"epc_1 == epc_2: {epc_1 == epc_2}\")\n# epc_1 == epc_2: False\nprint(f\"epc_1 == epc_3: {epc_1 == epc_3}\")\n# epc_1 == epc_3: True\n\n# You can also use inequality and comparison operators\nprint(f\"epc_1 != epc_2: {epc_1 != epc_2}\")\n# epc_1 != epc_2: True\nprint(f\"epc_1 &lt; epc_2: {epc_1 &lt; epc_2}\")\n# epc_1 &lt; epc_2: True\nprint(f\"epc_2 &lt; epc_1: {epc_2 &lt; epc_1}\")\n# epc_2 &gt; epc_1: False\nprint(f\"epc_2 &gt; epc_1: {epc_2 &gt; epc_1}\")\n# epc_2 &gt; epc_1: True\nprint(f\"epc_1 &lt;= epc_3: {epc_1 &lt;= epc_3}\")\n# epc_1 &lt;= epc_3: True\nprint(f\"epc_2 &gt;= epc_1: {epc_2 &gt;= epc_1}\")\n# epc_2 &gt;= epc_1: True\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc_1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_2 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 1.0, bh::TimeSystem::UTC);\n    let epc_3 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // You can compare two Epoch instances for equality\n    println!(\"epc_1 == epc_2: {}\", epc_1 == epc_2);\n    // epc_1 == epc_2: false\n    println!(\"epc_1 == epc_3: {}\", epc_1 == epc_3);\n    // epc_1 == epc_3: true\n\n    // You can also use inequality and comparison operators\n    println!(\"epc_1 != epc_2: {}\", epc_1 != epc_2);\n    // epc_1 != epc_2: true\n    println!(\"epc_1 &lt; epc_2: {}\", epc_1 &lt; epc_2);\n    // epc_1 &lt; epc_2: true\n    println!(\"epc_2 &lt; epc_1: {}\", epc_2 &lt; epc_1);\n    // epc_2 &gt; epc_1: false\n    println!(\"epc_2 &gt; epc_1: {}\", epc_2 &gt; epc_1);\n    // epc_2 &gt; epc_1: true\n    println!(\"epc_1 &lt;= epc_3: {}\", epc_1 &lt;= epc_3);\n    // epc_1 &lt;= epc_3: true\n    println!(\"epc_2 &gt;= epc_1: {}\", epc_2 &gt;= epc_1);\n    // epc_2 &gt;= epc_1: true\n}\n</code></pre>"},{"location":"learn/time/epoch.html#output-and-formatting","title":"Output and Formatting","text":"<p>Finally, you can take any Epoch instance and then output it in different representations.</p>"},{"location":"learn/time/epoch.html#date-time_1","title":"Date Time","text":"<p>You can extract the date and time components from an Epoch, optionally converting to a different time system.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-06-15 14:30:45.500 UTC\n\n# Output the equivalent Julian Date\njd = epc.jd()\nprint(f\"Julian Date: {jd:.6f}\")\n# Julian Date: 2460477.104693\n\n# Get the Julian Date in a different time system (e.g., TT)\njd_tt = epc.jd_as_time_system(time_system=bh.TT)\nprint(f\"Julian Date (TT): {jd_tt:.6f}\")\n# Julian Date (TT): 2460477.105494\n\n# Output the equivalent Modified Julian Date\nmjd = epc.mjd()\nprint(f\"Modified Julian Date: {mjd:.6f}\")\n# Modified Julian Date: 60476.604693\n\n# Get the Modified Julian Date in a different time system (e.g., GPS)\nmjd_gps = epc.mjd_as_time_system(time_system=bh.GPS)\nprint(f\"Modified Julian Date (GPS): {mjd_gps:.6f}\")\n# Modified Julian Date (GPS): 60476.604902\n\n# Get the GPS Week and Seconds of Week\ngps_week, gps_sow = epc.gps_date()\nprint(f\"GPS Week: {gps_week}, Seconds of Week: {gps_sow:.3f}\")\n# GPS Week: 2318, Seconds of Week: 570663.500\n\n# The Epoch as GPS seconds since the GPS epoch\ngps_seconds = epc.gps_seconds()\nprint(f\"GPS Seconds since epoch: {gps_seconds:.3f}\")\n# GPS Seconds since epoch: 1402497063.500\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-06-15 14:30:45.500 UTC\n\n    // Output the equivalent Julian Date\n    let jd = epc.jd();\n    println!(\"Julian Date: {:.6}\", jd);\n    // Julian Date: 2460477.104693\n\n    // Get the Julian Date in a different time system (e.g., TT)\n    let jd_tt = epc.jd_as_time_system(bh::TimeSystem::TT);\n    println!(\"Julian Date (TT): {:.6}\", jd_tt);\n    // Julian Date (TT): 2460477.105494\n\n    // Output the equivalent Modified Julian Date\n    let mjd = epc.mjd();\n    println!(\"Modified Julian Date: {:.6}\", mjd);\n    // Modified Julian Date: 60476.604693\n\n    // Get the Modified Julian Date in a different time system (e.g., GPS)\n    let mjd_gps = epc.mjd_as_time_system(bh::TimeSystem::GPS);\n    println!(\"Modified Julian Date (GPS): {:.6}\", mjd_gps);\n    // Modified Julian Date (GPS): 60476.604902\n\n    // Get the GPS Week and Seconds of Week\n    let (gps_week, gps_sow) = epc.gps_date();\n    println!(\"GPS Week: {}, Seconds of Week: {:.3}\", gps_week, gps_sow);\n    // GPS Week: 2318, Seconds of Week: 570663.500\n\n    // The Epoch as GPS seconds since the GPS epoch\n    let gps_seconds = epc.gps_seconds();\n    println!(\"GPS Seconds since epoch: {:.3}\", gps_seconds);\n    // GPS Seconds since epoch: 1402497063.500\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string-representation","title":"String Representation","text":"<p>Epochs can be converted to human-readable strings in various formats and time systems.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.123456789, 0.0)\n\n# Default string representation\nprint(f\"Default: {epc}\")\n# Default: 2024-06-15 14:30:45.123 UTC\n\n# Explicit string conversion\nprint(f\"String: {str(epc)}\")\n# String: 2024-06-15 14:30:45.123 UTC\n\n# Debug representation\nprint(f\"Debug: {repr(epc)}\")\n# Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n# Get string in a different time system\nprint(f\"TT: {epc.to_string_as_time_system(bh.TimeSystem.TT)}\")\n# TT: 2024-06-15 14:31:54.307 TT\n\n# Get as ISO 8601 formatted string\nprint(f\"ISO 8601: {epc.isostring()}\")\n# ISO 8601: 2024-06-15T14:30:45Z\n\n# Get as ISO 8601 with different number of decimal places\nprint(f\"ISO 8601 (0 decimal places): {epc.isostring_with_decimals(0)}\")\nprint(f\"ISO 8601 (3 decimal places): {epc.isostring_with_decimals(3)}\")\nprint(f\"ISO 8601 (6 decimal places): {epc.isostring_with_decimals(6)}\")\n# ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n# ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n# ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.123456789, 0.0, bh::TimeSystem::UTC);\n\n    // Default string representation\n    println!(\"Default: {}\", epc);\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Explicit string conversion (same as default in Rust)\n    println!(\"String: {}\", epc.to_string());\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Debug representation\n    println!(\"Debug: {:?}\", epc);\n    // Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n    // Get string in a different time system\n    println!(\"TT: {}\", epc.to_string_as_time_system(bh::TimeSystem::TT));\n    // TT: 2024-06-15 14:31:54.307 TT\n\n    // Get as ISO 8601 formatted string\n    println!(\"ISO 8601: {}\", epc.isostring());\n    // ISO 8601: 2024-06-15T14:30:45Z\n\n    // Get as ISO 8601 with different number of decimal places\n    println!(\"ISO 8601 (0 decimal places): {}\", epc.isostring_with_decimals(0));\n    println!(\"ISO 8601 (3 decimal places): {}\", epc.isostring_with_decimals(3));\n    println!(\"ISO 8601 (6 decimal places): {}\", epc.isostring_with_decimals(6));\n    // ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n    // ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n    // ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n}\n</code></pre>"},{"location":"learn/time/epoch.html#see-also","title":"See Also","text":"<ul> <li>Epoch API Reference</li> </ul>"},{"location":"learn/time/time_range.html","title":"Time Range","text":"<p>The <code>TimeRange</code> class provides an easy way to iterate over a range of time instances. You can specify a start and end <code>Epoch</code>, along with a time step in seconds, and the <code>TimeRange</code> will generate all the <code>Epoch</code> instances within that range at the specified intervals.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nfor epc in bh.TimeRange(\n    bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC),\n    bh.Epoch(2024, 1, 2, 0, 0, 0.0, time_system=bh.UTC),\n    3600.0,\n):\n    print(epc)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    for epc in bh::TimeRange::new(\n        bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        bh::Epoch::from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        3600.0\n    ) {\n        println!(\"{}\", epc);\n    }\n}\n</code></pre>"},{"location":"learn/trajectories/index.html","title":"Trajectories","text":"<p>Brahe provides trajectory containers for storing and managing time-series state data. A trajectory is a sequence of state vectors (positions, velocities, or other multi-dimensional data) indexed by time epochs. Trajectories store the dynamic state evolution and provide a number of convenience methods for accessing, querying, and manipulating the data.</p>"},{"location":"learn/trajectories/index.html#trajectory-traits","title":"Trajectory Traits","text":"<p>Brahe's trajectory system is built on a set of Rust traits that define common functionality. This design allows for common access patterns across different trajectory implementations, while enabling specialized behavior for specific use cases.</p> <p>Generally, a \"state\" is a vector of floating-point numbers representing some dynamic quantity. For most applications in Brahe, states are 6-dimensional vectors representing the satellite position and velocity in 3D space. However, the trajectory system is flexible enough to handle arbitrary state definitions.</p>"},{"location":"learn/trajectories/index.html#trajectory-trait","title":"<code>Trajectory</code> Trait","text":"<p>The <code>Trajectory</code> trait is the foundation of all trajectory implementations. It defines the core interface for storing, accessing, and managing time-series state data. Any Trajectory implementation must implement this trait which requires the implementation of the following methods:</p> <p>Creation:</p> <ul> <li><code>from_data(epochs, states)</code> - Create trajectory from vectors of epochs and states</li> <li><code>add(epoch, state)</code> - Add a single state at a specific epoch</li> </ul> <p>Access:</p> <ul> <li><code>epoch_at_idx(index)</code> - Get epoch at a specific index</li> <li><code>state_at_idx(index)</code> - Get state at a specific index</li> <li><code>get(epoch)</code> - Get exact state if epoch exists</li> <li><code>nearest_state(epoch)</code> - Get state at nearest epoch to query time</li> </ul> <p>Querying:</p> <ul> <li><code>len()</code> - Number of states in trajectory</li> <li><code>is_empty()</code> - Check if trajectory contains no states</li> <li><code>start_epoch()</code> - First epoch in trajectory</li> <li><code>end_epoch()</code> - Last epoch in trajectory</li> <li><code>timespan()</code> - Duration between first and last epochs (seconds)</li> <li><code>first()</code> - Get first epoch-state pair</li> <li><code>last()</code> - Get last epoch-state pair</li> </ul> <p>Modification:</p> <ul> <li><code>clear()</code> - Remove all states</li> <li><code>remove_epoch(epoch)</code> - Remove state at specific epoch</li> <li><code>remove(index)</code> - Remove state at specific index</li> </ul> <p>Temporal Indexing:</p> <ul> <li><code>index_before_epoch(epoch)</code> - Find index of state before query epoch</li> <li><code>index_after_epoch(epoch)</code> - Find index of state after query epoch</li> <li><code>state_before_epoch(epoch)</code> - Get state before query epoch</li> <li><code>state_after_epoch(epoch)</code> - Get state after query epoch</li> </ul> <p>Memory Management:</p> <ul> <li><code>set_eviction_policy_max_size(size)</code> - Limit trajectory to N most recent states</li> <li><code>set_eviction_policy_max_age(duration_seconds)</code> - Keep only states within time window</li> <li><code>get_eviction_policy()</code> - Get current eviction policy</li> </ul>"},{"location":"learn/trajectories/index.html#interpolatable-trait","title":"<code>Interpolatable</code> Trait","text":"<p>Since trajectories often store states at discrete epochs, the <code>Interpolatable</code> trait provides methods for interpolating states at arbitrary times between stored data points. This is useful for applications that require continuous state estimates.</p> <p>Methods:</p> <ul> <li><code>interpolate(epoch)</code> - Get interpolated state at arbitrary epoch</li> <li><code>set_interpolation_method(method)</code> - Configure interpolation algorithm</li> <li><code>get_interpolation_method()</code> - Get current interpolation method</li> </ul> <p>Supported Interpolation Methods (via <code>InterpolationMethod</code> enum):</p> <ul> <li><code>Linear</code> - Linear interpolation between adjacent states (default)</li> </ul>"},{"location":"learn/trajectories/index.html#orbitaltrajectory-trait","title":"<code>OrbitalTrajectory</code> Trait","text":"<p>The <code>OrbitalTrajectory</code> trait specializes trajectories for orbital mechanics applications. It adds awareness of reference frames (ECI/ECEF) and orbital representations (Cartesian/Keplerian), enabling automatic conversions of the stored states to different frames or representations.</p> <p>Creation:</p> <ul> <li><code>from_orbital_data(epochs, states, frame, representation, angle_format)</code> - Create from orbital data with frame/representation metadata</li> </ul> <p>Frame Conversions:</p> <ul> <li><code>to_eci()</code> - Convert all states to Earth-Centered Inertial frame</li> <li><code>to_ecef()</code> - Convert all states to Earth-Centered Earth-Fixed frame</li> </ul> <p>Representation Conversions:</p> <ul> <li><code>to_keplerian(angle_format)</code> - Convert Cartesian states to Keplerian orbital elements</li> </ul>"},{"location":"learn/trajectories/index.html#supporting-types","title":"Supporting Types","text":""},{"location":"learn/trajectories/index.html#interpolationmethod","title":"InterpolationMethod","text":"<p>Defines interpolation algorithms available for computing states at arbitrary epochs:</p> <ul> <li><code>Linear</code> - Linear interpolation between adjacent state vectors (default)</li> </ul>"},{"location":"learn/trajectories/index.html#trajectoryevictionpolicy","title":"TrajectoryEvictionPolicy","text":"<p>Controls automatic memory management for long-running applications:</p> <ul> <li><code>None</code> - Keep all states indefinitely (default)</li> <li><code>KeepCount(n)</code> - Keep only the N most recent states, removing older ones</li> <li><code>KeepWithinDuration(seconds)</code> - Keep only states within time window from most recent epoch</li> </ul> <p>Eviction policies are useful for real-time applications where memory must be bounded, such as satellite ground station passes or long-term simulations.</p>"},{"location":"learn/trajectories/index.html#orbitframe","title":"OrbitFrame","text":"<p>Specifies the reference frame for orbital states:</p> <ul> <li><code>ECI</code> - Earth-Centered Inertial frame (GCRF/J2000)</li> <li><code>ECEF</code> - Earth-Centered Earth-Fixed frame</li> </ul>"},{"location":"learn/trajectories/index.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies how orbital states are represented:</p> <ul> <li><code>Cartesian</code> - Position and velocity vectors \\(\\[p_x, p_y, p_z, v_x, v_y, v_z\\]\\) in meters and m/s</li> <li><code>Keplerian</code> - Classical orbital elements \\(\\[a, e, i, \\Omega, \\omega, M\\]\\) where:<ul> <li>\\(a\\) - Semi-major axis (meters)</li> <li>\\(e\\) - Eccentricity (dimensionless)</li> <li>\\(i\\) - Inclination (radians or degrees)</li> <li>\\(\\Omega\\) - Right ascension of ascending node (radians or degrees)</li> <li>\\(\\omega\\) - Argument of periapsis (radians or degrees)</li> <li>\\(M\\) - Mean anomaly (radians or degrees)</li> </ul> </li> </ul>"},{"location":"learn/trajectories/index.html#choosing-a-trajectory-implementation","title":"Choosing a Trajectory Implementation","text":"<p>Brahe provides three trajectory implementations, each optimized for different use cases:</p>"},{"location":"learn/trajectories/index.html#dtrajectory-dynamic-dimensions","title":"DTrajectory - Dynamic Dimensions","text":"<p>The <code>DTrajectory</code> implementation supports runtime-sized state vectors, allowing for arbitrary state dimensions. This makes it able to accomodate applications where users may want to augment the state vector with additional parameters beyond standard position/velocity.</p> <p>Features:</p> <ul> <li>Runtime-sized state vectors (any dimension)</li> <li>Frame-agnostic storage</li> <li>Flexible for arbitrary state data</li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code></li> </ul>"},{"location":"learn/trajectories/index.html#strajectory-static-dimensions","title":"STrajectory - Static Dimensions <p>The <code>STrajectory&lt;R&gt;</code> implementation uses compile-time sized state vectors, providing maximum performance for applications where the state dimension is known ahead of time. The generic parameter <code>R</code> specifies the number of state dimensions.</p> <p>Features:</p> <ul> <li>Compile-time sized state vectors (maximum performance)</li> <li>Type-safe dimensions</li> <li>Common type aliases: <code>STrajectory3</code>, <code>STrajectory4</code>, <code>STrajectory6</code></li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code></li> </ul>  <p>Tip</p> <p>Because <code>STrajectory</code> uses compile-time dimensions python bindings are only provided for common sizes of <code>STrajectory3</code>, <code>STrajectory4</code>, and <code>STrajectory6</code>.</p> <p>Rust users can create <code>STrajectory</code> instances with any dimension using the generic type.</p>","text":""},{"location":"learn/trajectories/index.html#orbittrajectory-orbital-mechanics","title":"OrbitTrajectory - Orbital Mechanics <p>The <code>OrbitTrajectory</code> implementation is specialized for orbital mechanics applications. It always 6-dimensional state vectors (position + velocity or orbital elements) and tracks the reference frame (ECI/ECEF) and representation (Cartesian/Keplerian). It provides built-in methods for converting between frames and representations. The <code>OrbitTrajectory</code> is ideal for satellite orbit propagation and analysis where you expect to need frame conversions.</p> <p>Features:</p> <ul> <li>Always 6-dimensional (position + velocity)</li> <li>Tracks reference frame (ECI/ECEF)</li> <li>Tracks representation (Cartesian/Keplerian)</li> <li>Frame conversions: ECI \u2194 ECEF</li> <li>Representation conversions: Cartesian \u2194 Keplerian</li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code>, <code>OrbitalTrajectory</code></li> </ul>","text":""},{"location":"learn/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory - Dynamic-dimension trajectory implementation</li> <li>STrajectory6 - Static 6D trajectory implementation</li> <li>OrbitTrajectory - Orbital mechanics trajectory with frame conversions</li> <li>API Reference</li> </ul>"},{"location":"learn/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p><code>DTrajectory</code> is a dynamically sized trajectory container that stores time-series state data with runtime-determined dimensions. Unlike static trajectory types, <code>DTrajectory</code> allows you to specify the state vector dimension at creation time, making it ideal for applications where the dimension varies or is not known at compile time.</p> <p>Use <code>DTrajectory</code> when:</p> <ul> <li>State dimension is determined at runtime</li> <li>You need flexibility to work with different dimensions in the same codebase</li> <li>State vectors are non-standard (not 3D or 6D)</li> <li>Flexibility is prioritized over maximum performance</li> </ul> <p>For fixed-dimension orbital mechanics applications, consider using <code>STrajectory6</code> or <code>OrbitTrajectory</code> instead for better performance.</p>"},{"location":"learn/trajectories/dtrajectory.html#initialization","title":"Initialization","text":""},{"location":"learn/trajectories/dtrajectory.html#empty-trajectory","title":"Empty Trajectory","text":"<p>Create an empty trajectory by specifying the state dimension. The default dimension is 6 (suitable for position + velocity states):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create 6D trajectory (default)\ntraj = bh.DTrajectory()\nprint(f\"Dimension: {traj.dimension()}\")\n# Dimension: 6\n\n# Create 3D trajectory (position only)\ntraj_3d = bh.DTrajectory(3)\nprint(f\"Dimension: {traj_3d.dimension()}\")\n# Dimension: 3\n\n# Create 12D trajectory (custom)\ntraj_12d = bh.DTrajectory(12)\nprint(f\"Dimension: {traj_12d.dimension()}\")\n# Dimension: 12\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::DTrajectory;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create 6D trajectory (default)\n    let traj = DTrajectory::default();\n    println!(\"Dimension: {}\", traj.dimension());\n    // Output: 6\n\n    // Create 3D trajectory\n    let traj_3d = DTrajectory::new(3);\n    println!(\"Dimension: {}\", traj_3d.dimension());\n    // Output: 3\n\n    // Create 12D trajectory\n    let traj_12d = DTrajectory::new(12);\n    println!(\"Dimension: {}\", traj_12d.dimension());\n    // Output: 12\n}\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#from-existing-data","title":"From Existing Data","text":"<p>Create a trajectory from existing epochs and states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create epochs\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch1 = epoch0 + 60.0  # 1 minute later\nepoch2 = epoch0 + 120.0  # 2 minutes later\n\n# Create states (6D: position + velocity)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\nstate2 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\n\n# Create trajectory from data\nepochs = [epoch0, epoch1, epoch2]\nstates = np.array([state0, state1, state2])\ntraj = bh.DTrajectory.from_data(epochs, states)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epochs\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let epoch1 = epoch0 + 60.0;  // 1 minute later\n    let epoch2 = epoch0 + 120.0;  // 2 minutes later\n\n    // Create states\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    let state2 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    ]);\n\n    // Create trajectory from data\n    let epochs = vec![epoch0, epoch1, epoch2];\n    let states = vec![state0, state1, state2];\n    let traj = DTrajectory::from_data(epochs, states).unwrap();\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Output: 3\n}\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#adding-and-accessing-states","title":"Adding and Accessing States","text":""},{"location":"learn/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<p>Add states to a trajectory one at a time:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create empty trajectory\ntraj = bh.DTrajectory(6)\n\n# Add states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 1\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 2\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create empty trajectory\n    let mut traj = DTrajectory::new(6);\n\n    // Add states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    traj.add(epoch0, state0);\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 1\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    traj.add(epoch1, state1);\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 2\n}\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#accessing-by-index","title":"Accessing by Index","text":"<p>Retrieve states and epochs by their index:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 600e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nepoch2 = epoch0 + 120.0\nstate2 = np.array([bh.R_EARTH + 700e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\ntraj.add(epoch2, state2)\n\n# Access by index\nretrieved_epoch = traj.epoch_at_idx(1)\nretrieved_state = traj.state_at_idx(1)\n\nprint(f\"Epoch: {retrieved_epoch}\")\nprint(f\"Altitude: {retrieved_state[0] - bh.R_EARTH:.2f} m\")\n\n# Output:\n# Epoch: 2024-01-01 00:01:00.000 UTC\n# Altitude: 600000.00 m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    traj.add(epoch0, state0);\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 600e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    traj.add(epoch1, state1);\n\n    let epoch2 = epoch0 + 120.0;\n    let state2 = na::DVector::from_vec(vec![\n        R_EARTH + 700e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    ]);\n    traj.add(epoch2, state2);\n\n    // Access by index\n    let retrieved_epoch = traj.epoch_at_idx(1).unwrap();\n    let retrieved_state = traj.state_at_idx(1).unwrap();\n\n    println!(\"Epoch: {}\", retrieved_epoch);\n    println!(\"Altitude: {:.2} m\", retrieved_state[0] - R_EARTH);\n}\n\n// Output:\n// Epoch: 2024-01-01 00:01:00.000 UTC\n// Altitude: 600000.00 m\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#accessing-by-epoch","title":"Accessing by Epoch","text":"<p>Get states at or near specific epochs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with multiple states\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Get nearest state to a specific epoch\nquery_epoch = epoch0 + 120.0  # 2 minutes after start\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(\n    f\"Nearest state at t+120s altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\"\n)\n\n# Get nearest state between stored epochs\nquery_epoch = epoch0 + 125.0  # Between stored epochs\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(\n    f\"Nearest state at t+125s altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\"\n)\n\n# Output:\n# Nearest state at t+120s altitude: 502.00 km\n# Nearest state at t+125s altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with multiple states\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Get nearest state to a specific epoch\n    let query_epoch1 = epoch0 + 120.0;  // 2 minutes after start\n    let (_, nearest_state) = traj.nearest_state(&amp;query_epoch1).unwrap();\n    println!(\"Nearest state at t+120s altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n\n    // Get nearest state between stored epochs\n    let query_epoch2 = epoch0 + 125.0;  // Between stored epochs\n    let (_, nearest_state) = traj.nearest_state(&amp;query_epoch2).unwrap();\n    println!(\"Nearest state at t+125s altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n}\n\n// Output:\n// Nearest state at t+120s altitude: 502.00 km\n// Nearest state at t+125s altitude: 502.00 km\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#querying-trajectory-properties","title":"Querying Trajectory Properties","text":""},{"location":"learn/trajectories/dtrajectory.html#time-span-and-bounds","title":"Time Span and Bounds","text":"<p>Query the temporal extent of a trajectory:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory spanning 5 minutes\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(6):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Query properties\nprint(f\"Number of states: {len(traj)}\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"End epoch: {traj.end_epoch()}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\nprint(f\"Is empty: {traj.is_empty()}\")\n\n# Access first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\nprint(f\"First epoch: {first_epoch}\")\nprint(f\"Last epoch: {last_epoch}\")\n\n# Output:\n# Number of states: 6\n# Start epoch: 2024-01-01 00:00:00.000 UTC\n# End epoch: 2024-01-01 00:05:00.000 UTC\n# Timespan: 300.0 seconds\n# Is empty: False\n# First epoch: 2024-01-01 00:00:00.000 UTC\n# Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory spanning 5 minutes\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..6 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Query properties\n    println!(\"Number of states: {}\", traj.len());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"End epoch: {}\", traj.end_epoch().unwrap());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    println!(\"Is empty: {}\", traj.is_empty());\n\n    // Access first and last states\n    let (first_epoch, _first_state) = traj.first().unwrap();\n    let (last_epoch, _last_state) = traj.last().unwrap();\n    println!(\"First epoch: {}\", first_epoch);\n    println!(\"Last epoch: {}\", last_epoch);\n}\n\n// Output:\n// Number of states: 6\n// Start epoch: 2024-01-01 00:00:00.000 UTC\n// End epoch: 2024-01-01 00:05:00.000 UTC\n// Timespan: 300.0 seconds\n// Is empty: false\n// First epoch: 2024-01-01 00:00:00.000 UTC\n// Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#interpolation","title":"Interpolation","text":"<p>DTrajectory supports linear interpolation to estimate states at arbitrary epochs between stored data points:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with sparse data\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states every 60 seconds\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    # Simplified motion: position changes linearly with time\n    state = np.array([bh.R_EARTH + 500e3 + i * 10000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Interpolate state at intermediate time\nquery_epoch = epoch0 + 30.0  # Halfway between first two states\ninterpolated_state = traj.interpolate(query_epoch)\n\nprint(f\"Interpolated altitude: {(interpolated_state[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Expected: approximately 505 km (halfway between 500 and 510 km)\n\n# Output:\n# Interpolated altitude: 505.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::{Trajectory, Interpolatable};\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with sparse data\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add states every 60 seconds\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 10000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Interpolate state at intermediate time\n    let query_epoch = epoch0 + 30.0;  // Halfway between first two states\n    let interpolated_state = traj.interpolate(&amp;query_epoch).unwrap();\n\n    println!(\"Interpolated altitude: {:.2} km\",\n        (interpolated_state[0] - R_EARTH) / 1e3);\n    // Expected: approximately 505 km (halfway between 500 and 510 km)\n}\n\n// Output:\n// Interpolated altitude: 505.00 km\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#memory-management","title":"Memory Management","text":"<p>DTrajectory supports eviction policies to automatically manage memory in long-running applications:</p>"},{"location":"learn/trajectories/dtrajectory.html#maximum-size-policy","title":"Maximum Size Policy","text":"<p>Keep only the N most recent states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with max size limit\ntraj = bh.DTrajectory(6).with_eviction_policy_max_size(3)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add 5 states\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only the 3 most recent states are kept\nprint(f\"Trajectory length: {len(traj)}\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"Start altitude: {(traj.state_at_idx(0)[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Output: ~502 km (states 0 and 1 were evicted)\n\n# Output\n# Trajectory length: 3\n# Start epoch: 2024-01-01 00:02:00.000 UTC\n# Start altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with max size limit\n    let mut traj = DTrajectory::new(6)\n        .with_eviction_policy_max_size(3);\n\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add 5 states\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Only the 3 most recent states are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"Start altitude: {:.2} km\",\n        (traj.state_at_idx(0).unwrap()[0] - R_EARTH) / 1e3);\n    // Output: ~502 km (states 0 and 1 were evicted)\n}\n\n// Output\n// Trajectory length: 3\n// Start epoch: 2024-01-01 00:02:00.000 UTC\n// Start altitude: 502.00 km\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#maximum-age-policy","title":"Maximum Age Policy","text":"<p>Keep only states within a time window:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Keep only states within last 2 minutes (120 seconds)\ntraj = bh.DTrajectory(6).with_eviction_policy_max_age(120.0)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states spanning 4 minutes\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only states within 120 seconds of the most recent are kept\nprint(f\"Trajectory length: {len(traj)}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\n\n# Output:\n# Trajectory length: 3\n# Timespan: 120.0 seconds\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Keep only states within last 2 minutes (120 seconds)\n    let mut traj = DTrajectory::new(6)\n        .with_eviction_policy_max_age(120.0);\n\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add states spanning 4 minutes\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Only states within 120 seconds of the most recent are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n}\n\n// Output:\n// Trajectory length: 3\n// Timespan: 120.0 seconds\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#iteration","title":"Iteration","text":"<p>Trajectories can be iterated to process all epoch-state pairs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Iterate over all states\nfor epoch, state in traj:\n    altitude = (state[0] - bh.R_EARTH) / 1e3\n    print(f\"Epoch: {epoch}, Altitude: {altitude:.2f} km\")\n\n# Output:\n# Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km\n# Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km\n# Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Iterate over all states\n    for (epoch, state) in &amp;traj {\n        let altitude = (state[0] - R_EARTH) / 1e3;\n        println!(\"Epoch: {}, Altitude: {:.2} km\", epoch, altitude);\n    }\n\n    // Output:\n    // Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km\n    // Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km\n    // Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km\n}\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#matrix-export","title":"Matrix Export","text":"<p>Convert trajectory data to matrix format for analysis or export:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory\ntraj = bh.DTrajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + i * 10, 0.0])\n    traj.add(epoch, state)\n\n# Convert to matrix (rows are states, columns are dimensions)\nmatrix = traj.to_matrix()\nprint(f\"Matrix type: {type(matrix)}\")\nprint(f\"Matrix shape: {matrix.shape}\")\nprint(f\"First state velocity: {matrix[0, 4]:.1f} m/s\")\n\n# Output:\n# Matrix type: &lt;class 'numpy.ndarray'&gt;\n# Matrix shape: (3, 6)\n# First state velocity: 7600.0 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + (i as f64) * 10.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Convert to matrix (rows are states, columns are dimensions)\n    let matrix = traj.to_matrix().unwrap();\n    println!(\"Matrix shape: ({}, {})\", matrix.nrows(), matrix.ncols());\n    println!(\"First state velocity: {:.1} m/s\", matrix[(0, 4)]);\n}\n\n// Output:\n// Matrix shape: (3, 6)\n// First state velocity: 7600.0 m/s\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>Trajectories Overview - Trait hierarchy and implementation guide</li> <li>STrajectory6 - Fixed 6D trajectory for better performance</li> <li>OrbitTrajectory - Orbital trajectory with frame conversions</li> <li>DTrajectory API Reference</li> </ul>"},{"location":"learn/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that tracks reference frames (ECI/ECEF) and orbital representations (Cartesian/Keplerian). Unlike <code>DTrajectory</code> and <code>STrajectory6</code> which store frame-agnostic data, <code>OrbitTrajectory</code> understands orbital mechanics and enables automatic conversions between reference frames and representations.</p> <p>Use <code>OrbitTrajectory</code> when:</p> <ul> <li>Working with orbital mechanics applications</li> <li>Need to convert between ECI and ECEF frames</li> <li>Need to convert between Cartesian and Keplerian representations</li> <li>Want frame/representation metadata tracked automatically</li> <li>Working with propagators that output orbital trajectories</li> </ul> <p><code>OrbitTrajectory</code> implements the <code>OrbitalTrajectory</code> trait in addition to <code>Trajectory</code> and <code>Interpolatable</code>, providing orbital-specific functionality on top of the standard trajectory interface.</p>"},{"location":"learn/trajectories/orbit_trajectory.html#initialization","title":"Initialization","text":""},{"location":"learn/trajectories/orbit_trajectory.html#empty-trajectory-cartesian-representation","title":"Empty Trajectory - Cartesian Representation","text":"<p>For cartesian representation, the frame can be <code>ECI</code> or <code>ECEF</code>. The <code>AngleFormat</code> must be <code>None</code> for Cartesian representations</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame, Cartesian representation\ntraj_eci = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    None,  # No angle format for Cartesian\n)\nprint(f\"Frame (str): {traj_eci.frame}\")  # Output: ECI\nprint(\n    f\"Frame (repr): {repr(traj_eci.frame)}\"\n)  # Output: OrbitFrame(Earth-Centered Inertial)\nprint(f\"Representation (str): {traj_eci.representation}\")  # Output: Cartesian\nprint(\n    f\"Representation (repr): {repr(traj_eci.representation)}\"\n)  # Output: OrbitRepresentation(Cartesian)\n\n# Create trajectory in ECEF frame, Cartesian representation\ntraj_ecef = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None\n)\nprint(f\"Frame (str): {traj_ecef.frame}\")  # Output: ECEF\nprint(\n    f\"Frame (repr): {repr(traj_ecef.frame)}\"\n)  # Output: OrbitFrame(Earth-Centered Earth-Fixed)\n\n# Output:\n# Frame (str): ECI\n# Frame (repr): OrbitFrame(Earth-Centered Inertial)\n# Representation (str): Cartesian\n# Representation (repr): OrbitRepresentation(Cartesian)\n# Frame (str): ECEF\n# Frame (repr): OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame, Cartesian representation\n    let traj_eci = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n    println!(\"Frame (Display): {}\", traj_eci.frame);\n    println!(\"Frame (Debug): {:?}\", traj_eci.frame);\n    println!(\"Representation (Display): {}\", traj_eci.representation);\n    println!(\"Representation (Debug): {:?}\", traj_eci.representation);\n\n    // Create trajectory in ECEF frame, Cartesian representation\n    let traj_ecef = OrbitTrajectory::new(\n        OrbitFrame::ECEF,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n    println!(\"Frame (Display): {}\", traj_ecef.frame);\n    println!(\"Frame (Debug): {:?}\", traj_ecef.frame);\n}\n\n// Output:\n// Frame (Display): ECI\n// Frame (Debug): OrbitFrame(Earth-Centered Inertial)\n// Representation (Display): OrbitRepresentation(Cartesian)\n// Representation (Debug): Cartesian\n// Frame (Display): ECEF\n// Frame (Debug): OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#empty-trajectory-keplerian-elements","title":"Empty Trajectory - Keplerian Elements","text":"<p>To create an empty trajectory in Keplerian representation you must specify the frame as <code>ECI</code> and provide an <code>AngleFormat</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame, Keplerian representation with radians\ntraj_kep_rad = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.KEPLERIAN,\n    bh.AngleFormat.RADIANS,  # Required for Keplerian\n)\n\n# Create trajectory in ECI frame, Keplerian representation with degrees\ntraj_kep_deg = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES\n)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\nuse bh::AngleFormat;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame, Keplerian representation with radians\n    let _traj_kep_rad = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Keplerian,\n        Some(AngleFormat::Radians)\n    );\n\n    // Create trajectory in ECI frame, Keplerian representation with degrees\n    let _traj_kep_deg = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Keplerian,\n        Some(AngleFormat::Degrees)\n    );\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#from-existing-data","title":"From Existing Data","text":"<p>You can also initialize an <code>OrbitTrajectory</code> from existing epoch and state data:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create epochs\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch1 = epoch0 + 60.0\nepoch2 = epoch0 + 120.0\n\n# Create Cartesian states in ECI\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\nstate2 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\n\n# Create trajectory from data\nepochs = [epoch0, epoch1, epoch2]\nstates = np.array([state0, state1, state2])  # Flattened array\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    epochs, states, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epochs\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let epoch1 = epoch0 + 60.0;\n    let epoch2 = epoch0 + 120.0;\n\n    // Create Cartesian states\n    let state0 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    let state1 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    );\n    let state2 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    );\n\n    // Create trajectory from data\n    let epochs = vec![epoch0, epoch1, epoch2];\n    let states = vec![state0, state1, state2];\n    let traj = OrbitTrajectory::from_orbital_data(\n        epochs,\n        states,\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    println!(\"Trajectory length: {}\", traj.len());  \n    // Trajectory length: 3\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#from-propagator","title":"From Propagator","text":"<p>The most common way to get an <code>OrbitTrajectory</code> from a propagator. All orbit propagators in Brahe have a <code>*.trajectory</code> attribute which is an <code>OrbitTrajectory</code>.</p> <p>See the Propagators section for more details on propagators.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements for a 500 km circular orbit\na = bh.R_EARTH + 500e3\ne = 0.001\ni = 97.8  # Sun-synchronous\nraan = 15.0\nargp = 30.0\nM = 0.0\noe = np.array([a, e, i, raan, argp, M])\n\n# Create epoch and propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, oe, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate for several steps\npropagator.propagate_steps(10)\n\n# Access the trajectory\ntraj = propagator.trajectory\nprint(f\"Trajectory length: {len(traj)}\")  # Output: 11 (initial + 10 steps)\nprint(f\"Frame: {traj.frame}\")  # Output: OrbitFrame.ECI\nprint(f\"Representation: {traj.representation}\")  # Output: Keplerian\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::traits::{Trajectory, OrbitPropagator};\nuse bh::{KeplerianPropagator, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 97.8_f64.to_radians(),\n        15.0_f64.to_radians(), 30.0_f64.to_radians(), 0.0\n    );\n\n    // Create epoch and propagator\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch, oe, AngleFormat::Radians, 60.0\n    );\n\n    // Propagate for several steps\n    propagator.propagate_steps(10);\n\n    // Access the trajectory\n    let traj = &amp;propagator.trajectory;\n    println!(\"Trajectory length: {}\", traj.len());  // Output: 11\n    println!(\"Frame: {}\", traj.frame);  // Output: ECI\n    println!(\"Representation: {}\", traj.representation);  // Output: Keplerian\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#frame-conversions","title":"Frame Conversions","text":"<p>The key feature of <code>OrbitTrajectory</code> is automatic frame conversions of the trajectory data to different reference frames and representations. In particular, with a single method call you can convert between ECI and ECEF frames, and between Cartesian and Keplerian representations.</p>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-eci-to-ecef","title":"Converting ECI to ECEF","text":"<p>Convert a trajectory from Earth-Centered Inertial (ECI) to Earth-Centered Earth-Fixed (ECEF):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame\ntraj_eci = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\n\n# Add states in ECI\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    # Define state at epoch\n    state_eci = np.array([bh.R_EARTH + 500e3, i * 100e3, 0.0, 0.0, 7600.0, 0.0])\n    traj_eci.add(epoch, state_eci)\n\nprint(f\"Original frame: {traj_eci.frame}\")\nprint(f\"Original representation: {traj_eci.representation}\")\n\n# Convert all states in trajectory to ECEF\ntraj_ecef = traj_eci.to_ecef()\n\nprint(f\"\\nConverted frame: {traj_ecef.frame}\")\nprint(f\"Converted representation: {traj_ecef.representation}\")\nprint(f\"Same number of states: {len(traj_ecef)}\")\n\n# Compare first states\n_, state_eci = traj_eci.first()\n_, state_ecef = traj_ecef.first()\nprint(\n    f\"\\nFirst ECI state: [{state_eci[0]:.2f}, {state_eci[1]:.2f}, {state_eci[2]:.2f}] m\"\n)\nprint(\n    f\"First ECEF state: [{state_ecef[0]:.2f}, {state_ecef[1]:.2f}, {state_ecef[2]:.2f}] m\"\n)\n\n# Output:\n# Original frame: ECI\n# Original representation: Cartesian\n\n# Converted frame: ECEF\n# Converted representation: Cartesian\n# Same number of states: 5\n\n# First ECI state: [6878136.30, 0.00, 0.00] m\n# First ECEF state: [-1176064.06, -6776826.51, 15961.82] m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame\n    let mut traj_eci = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states in ECI\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state_eci = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, (i as f64) * 100e3, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj_eci.add(epoch, state_eci);\n    }\n\n    println!(\"Original frame: {:?}\", traj_eci.frame);\n    println!(\"Original representation: {:?}\", traj_eci.representation);\n\n    // Convert all states in trajectory to ECEF\n    let traj_ecef = traj_eci.to_ecef();\n\n    println!(\"\\nConverted frame: {:?}\", traj_ecef.frame);\n    println!(\"Converted representation: {:?}\", traj_ecef.representation);\n    println!(\"Same number of states: {}\", traj_ecef.len());\n\n    // Compare first states\n    let state_eci_first = traj_eci.state_at_idx(0).unwrap();\n    let state_ecef_first = traj_ecef.state_at_idx(0).unwrap();\n    println!(\"\\nFirst state ECI: [{}, {}, {}] m\",\n        state_eci_first[0], state_eci_first[1], state_eci_first[2]\n    );\n    println!(\"First state ECEF: [{}, {}, {}] m\",\n        state_ecef_first[0], state_ecef_first[1], state_ecef_first[2]\n    );\n}\n\n// Output:\n// Original frame: OrbitFrame(Earth-Centered Inertial)\n// Original representation: OrbitRepresentation(Cartesian)\n\n// Converted frame: OrbitFrame(Earth-Centered Earth-Fixed)\n// Converted representation: OrbitRepresentation(Cartesian)\n// Same number of states: 5\n\n// First state ECI: [6878136.3, 0, 0] m\n// First state ECEF: [-1176064.0596141217, -6776826.507241379, 15961.82358860613] m\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-ecef-to-eci","title":"Converting ECEF to ECI","text":"<p>Convert from ECEF back to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECEF frame\ntraj_ecef = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add dummy states in ECEF\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    # Define state at epoch\n    state_ecef = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 7600.0])\n    traj_ecef.add(epoch, state_ecef)\n\nprint(f\"Original frame: {traj_ecef.frame}\")  # Output: OrbitFrame.ECEF\n\n# Convert to ECI\ntraj_eci = traj_ecef.to_eci()\n\nprint(f\"Converted frame: {traj_eci.frame}\")  # Output: OrbitFrame.ECI\nprint(f\"Trajectory length: {len(traj_eci)}\")  # Output: 3\n\n# Iterate over converted states\nfor epoch, state_eci in traj_eci:\n    pos_mag = np.linalg.norm(state_eci[0:3])\n    vel_mag = np.linalg.norm(state_eci[3:6])\n    print(f\"Epoch: {epoch}\")\n    print(f\"  Position magnitude: {pos_mag / 1e3:.2f} km\")\n    print(f\"  Velocity magnitude: {vel_mag:.2f} m/s\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECEF frame\n    let mut traj_ecef = OrbitTrajectory::new(\n        OrbitFrame::ECEF,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add dummy states in ECEF\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state_ecef = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 7600.0\n        );\n        traj_ecef.add(epoch, state_ecef);\n    }\n\n    println!(\"Original frame: {:?}\", traj_ecef.frame);\n\n    // Convert to ECI\n    let traj_eci = traj_ecef.to_eci();\n\n    println!(\"Converted frame: {:?}\", traj_eci.frame);\n    println!(\"Trajectory length: {}\", traj_eci.len());\n\n    // Iterate over converted states\n    for (epoch, state_eci) in &amp;traj_eci {\n        let pos_mag = state_eci.fixed_rows::&lt;3&gt;(0).norm();\n        let vel_mag = state_eci.fixed_rows::&lt;3&gt;(3).norm();\n        println!(\"Epoch: {}\", epoch);\n        println!(\"  Position magnitude: {:.2} km\", pos_mag / 1e3);\n        println!(\"  Velocity magnitude: {:.2} m/s\", vel_mag);\n    }\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#round-trip-frame-conversion","title":"Round-Trip Frame Conversion","text":"<p>Convert from ECI to ECEF and back to verify consistency:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI\ntraj_eci_original = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add a state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_original = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj_eci_original.add(epoch, state_original)\n\n# Convert to ECEF and back to ECI\ntraj_ecef = traj_eci_original.to_ecef()\ntraj_eci_roundtrip = traj_ecef.to_eci()\n\n# Compare original and round-trip states\n_, state_roundtrip = traj_eci_roundtrip.first()\ndiff = np.abs(state_original - state_roundtrip)\n\nprint(f\"Position difference: {np.linalg.norm(diff[0:3]):.6e} m\")\nprint(f\"Velocity difference: {np.linalg.norm(diff[3:6]):.6e} m/s\")\n# Expected: Very small differences (numerical precision)\n\n# Output:\n# Position difference: 2.499882e-10 m\n# Velocity difference: 1.829382e-12 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI\n    let mut traj_eci_original = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add a state\n    let epoch = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state_original = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    traj_eci_original.add(epoch, state_original);\n\n    // Convert to ECEF and back to ECI\n    let traj_ecef = traj_eci_original.to_ecef();\n    let traj_eci_roundtrip = traj_ecef.to_eci();\n\n    // Compare original and round-trip states\n    let (_, state_roundtrip) = traj_eci_roundtrip.first().unwrap();\n    let diff = state_original - state_roundtrip;\n\n    println!(\"Position difference: {:.6e} m\",\n        diff.fixed_rows::&lt;3&gt;(0).norm());\n    println!(\"Velocity difference: {:.6e} m/s\",\n        diff.fixed_rows::&lt;3&gt;(3).norm());\n    // Expected: Very small differences (numerical precision)\n}\n\n// Output:\n// Position difference: 2.499882e-10 m\n// Velocity difference: 1.829382e-12 m/s\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-cartesian-to-keplerian","title":"Converting Cartesian to Keplerian","text":"<p>Convert from Cartesian position/velocity to Keplerian orbital elements:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI Cartesian\ntraj_cart = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add Cartesian states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(3):\n    epoch = epoch0 + i * 300.0  # 5-minute intervals\n    # Use orbital elements to create realistic Cartesian states\n    oe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, i * 10.0])\n    state_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n    traj_cart.add(epoch, state_cart)\n\nprint(f\"Original representation: {traj_cart.representation}\")\n# Output: OrbitRepresentation.CARTESIAN\n\n# Convert to Keplerian with degrees\ntraj_kep = traj_cart.to_keplerian(bh.AngleFormat.DEGREES)\n\nprint(f\"Converted representation: {traj_kep.representation}\")\n# Output: OrbitRepresentation.KEPLERIAN\nprint(f\"Angle format: {traj_kep.angle_format}\")\n# Output: AngleFormat.DEGREES\n\n# Examine Keplerian elements\nfor epoch, oe in traj_kep:\n    print(f\"\\nEpoch: {epoch}\")\n    print(f\"  Semi-major axis: {oe[0] / 1e3:.2f} km\")\n    print(f\"  Eccentricity: {oe[1]:.6f}\")\n    print(f\"  Inclination: {oe[2]:.2f}\u00b0\")\n    print(f\"  RAAN: {oe[3]:.2f}\u00b0\")\n    print(f\"  Argument of perigee: {oe[4]:.2f}\u00b0\")\n    print(f\"  Mean anomaly: {oe[5]:.2f}\u00b0\")\n\n# Output:\n# Original representation: Cartesian\n# Converted representation: Keplerian\n# Angle format: Degrees\n\n# Epoch: 2024-01-01 00:00:00.000 UTC\n#   Semi-major axis: 6878.14 km\n#   Eccentricity: 0.001000\n#   Inclination: 97.80\u00b0\n#   RAAN: 15.00\u00b0\n#   Argument of perigee: 30.00\u00b0\n#   True anomaly: 0.00\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_osculating_to_cartesian, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI Cartesian\n    let mut traj_cart = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add Cartesian states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 300.0;\n        let oe = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, (i as f64) * 10.0\n        );\n        let state_cart = state_osculating_to_cartesian(oe, AngleFormat::Degrees);\n        traj_cart.add(epoch, state_cart);\n    }\n\n    println!(\"Original representation: {:?}\", traj_cart.representation);\n\n    // Convert to Keplerian with radians\n    let traj_kep = traj_cart.to_keplerian(AngleFormat::Degrees);\n\n    println!(\"Converted representation: {:?}\", traj_kep.representation);\n    println!(\"Angle format: {:?}\", traj_kep.angle_format);\n\n    // Examine Keplerian elements\n    for (epoch, oe) in &amp;traj_kep {\n        println!(\"\\nEpoch: {}\", epoch);\n        println!(\"  Semi-major axis: {:.2} km\", oe[0] / 1e3);\n        println!(\"  Eccentricity: {:.6}\", oe[1]);\n        println!(\"  Inclination: {:.2}\u00b0\", oe[2]);\n        println!(\"  RAAN: {:.2}\u00b0\", oe[3]);\n        println!(\"  Argument of perigee: {:.2}\u00b0\", oe[4]);\n        println!(\"  Mean Anomaly: {:.2}\u00b0\", oe[5]);\n    }\n}\n\n// Output:\n// Original representation: OrbitRepresentation(Cartesian)\n// Converted representation: OrbitRepresentation(Keplerian)\n// Angle format: Some(Degrees)\n\n// Epoch: 2024-01-01 00:00:00.000 UTC\n//   Semi-major axis: 6878.14 km\n//   Eccentricity: 0.001000\n//   Inclination: 97.80\u00b0\n//   RAAN: 15.00\u00b0\n//   Argument of perigee: 30.00\u00b0\n//   Mean Anomaly: 0.00\u00b0\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-with-different-angle-formats","title":"Converting with Different Angle Formats","text":"<p>Convert to Keplerian with different angle formats:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI Cartesian\ntraj_cart = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add a state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0])\nstate_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\ntraj_cart.add(epoch, state_cart)\n\n# Convert to Keplerian with radians\ntraj_kep_rad = traj_cart.to_keplerian(bh.AngleFormat.RADIANS)\n_, oe_rad = traj_kep_rad.first()\n\n# Convert to Keplerian with degrees\ntraj_kep_deg = traj_cart.to_keplerian(bh.AngleFormat.DEGREES)\n_, oe_deg = traj_kep_deg.first()\n\nprint(\"Radians version:\")\nprint(f\"  Inclination: {oe_rad[2]:.6f} rad = {np.degrees(oe_rad[2]):.2f}\u00b0\")\n\nprint(\"\\nDegrees version:\")\nprint(f\"  Inclination: {oe_deg[2]:.2f}\u00b0\")\n\n# Output:\n# Radians version:\n#   Inclination: 0.900000 rad = 51.57\u00b0\n\n# Degrees version:\n#   Inclination: 51.57\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_osculating_to_cartesian, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI Cartesian\n    let mut traj_cart = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add a state\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0\n    );\n    let state_cart = state_osculating_to_cartesian(oe, AngleFormat::Radians);\n    traj_cart.add(epoch, state_cart);\n\n    // Convert to Keplerian with radians\n    let traj_kep_rad = traj_cart.to_keplerian(AngleFormat::Radians);\n    let (_, oe_rad) = traj_kep_rad.first().unwrap();\n\n    // Convert to Keplerian with degrees\n    let traj_kep_deg = traj_cart.to_keplerian(AngleFormat::Degrees);\n    let (_, oe_deg) = traj_kep_deg.first().unwrap();\n\n    println!(\"Radians version:\");\n    println!(\"  Inclination: {:.6} rad = {:.2}\u00b0\", oe_rad[2], oe_rad[2].to_degrees());\n\n    println!(\"\\nDegrees version:\");\n    println!(\"  Inclination: {:.2}\u00b0\", oe_deg[2]);\n}\n\n// Output:\n// Radians version:\n//   Inclination: 0.900000 rad = 51.57\u00b0\n\n// Degrees version:\n//   Inclination: 51.57\u00b0\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#combined-frame-and-representation-conversions","title":"Combined Frame and Representation Conversions","text":"<p>Every conversion method returns a new <code>OrbitTrajectory</code> instance, so you can chain conversions together if desired:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Start with ECI Cartesian trajectory\ntraj_eci_cart = bh.OrbitTrajectory(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add states\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0])\nstate_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\ntraj_eci_cart.add(epoch, state_cart)\n\nprint(\"Original:\")\nprint(f\"  Frame: {traj_eci_cart.frame}\")\nprint(f\"  Representation: {traj_eci_cart.representation}\")\n\n# Convert to ECEF frame (stays Cartesian)\ntraj_ecef_cart = traj_eci_cart.to_ecef()\nprint(\"\\nAfter to_ecef():\")\nprint(f\"  Frame: {traj_ecef_cart.frame}\")\nprint(f\"  Representation: {traj_ecef_cart.representation}\")\n\n# Convert back to ECI\ntraj_eci_cart2 = traj_ecef_cart.to_eci()\nprint(\"\\nAfter to_eci():\")\nprint(f\"  Frame: {traj_eci_cart2.frame}\")\nprint(f\"  Representation: {traj_eci_cart2.representation}\")\n\n# Convert to Keplerian (in ECI frame)\ntraj_eci_kep = traj_eci_cart2.to_keplerian(bh.AngleFormat.DEGREES)\nprint(\"\\nAfter to_keplerian():\")\nprint(f\"  Frame: {traj_eci_kep.frame}\")\nprint(f\"  Representation: {traj_eci_kep.representation}\")\nprint(f\"  Angle format: {traj_eci_kep.angle_format}\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_osculating_to_cartesian, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Start with ECI Cartesian trajectory\n    let mut traj_eci_cart = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0\n    );\n    let state_cart = state_osculating_to_cartesian(oe, AngleFormat::Radians);\n    traj_eci_cart.add(epoch, state_cart);\n\n    println!(\"Original:\");\n    println!(\"  Frame: {:?}\", traj_eci_cart.frame);\n    println!(\"  Representation: {:?}\", traj_eci_cart.representation);\n\n    // Convert to ECEF frame (stays Cartesian)\n    let traj_ecef_cart = traj_eci_cart.to_ecef();\n    println!(\"\\nAfter to_ecef():\");\n    println!(\"  Frame: {:?}\", traj_ecef_cart.frame);\n    println!(\"  Representation: {:?}\", traj_ecef_cart.representation);\n\n    // Convert back to ECI\n    let traj_eci_cart2 = traj_ecef_cart.to_eci();\n    println!(\"\\nAfter to_eci():\");\n    println!(\"  Frame: {:?}\", traj_eci_cart2.frame);\n    println!(\"  Representation: {:?}\", traj_eci_cart2.representation);\n\n    // Convert to Keplerian (in ECI frame)\n    let traj_eci_kep = traj_eci_cart2.to_keplerian(AngleFormat::Radians);\n    println!(\"\\nAfter to_keplerian():\");\n    println!(\"  Frame: {:?}\", traj_eci_kep.frame);\n    println!(\"  Representation: {:?}\", traj_eci_kep.representation);\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#standard-trajectory-operations","title":"Standard Trajectory Operations","text":"<p><code>OrbitTrajectory</code> supports all standard trajectory operations since it implements the <code>Trajectory</code> and <code>Interpolatable</code> traits:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\n\n# Add states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(10):\n    epoch = epoch0 + i * 60.0\n    oe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, i * 0.1])\n    state = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n    traj.add(epoch, state)\n\n# Query properties\nprint(f\"Length: {len(traj)}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"End epoch: {traj.end_epoch()}\")\n\n# Interpolate at intermediate time\ninterp_epoch = epoch0 + 45.0\ninterp_state = traj.interpolate(interp_epoch)\nprint(f\"\\nInterpolated state at {interp_epoch}:\")\nprint(f\"  Position (km): {interp_state[0:3] / 1e3}\")\nprint(f\"  Velocity (m/s): {interp_state[3:6]}\")\n\n# Iterate over states\nfor i, (epoch, state) in enumerate(traj):\n    if i &lt; 2:  # Just show first two\n        print(\n            f\"State {i}: Epoch={epoch}, Position magnitude={np.linalg.norm(state[0:3]) / 1e3:.2f} km\"\n        )\n\n# Output:\n# Length: 10\n# Timespan: 540.0 seconds\n# Start epoch: 2024-01-01 00:00:00.000 UTC\n# End epoch: 2024-01-01 00:09:00.000 UTC\n\n# Interpolated state at 2024-01-01 00:00:45.000 UTC:\n#   Position (km): [1159.01597302 6101.29789026 2925.16369358]\n#   Velocity (m/s): [-5578.86734152 -1338.77483001  5004.22925364]\n# State 0: Epoch=2024-01-01 00:00:00.000 UTC, Position magnitude=6871.26 km\n# State 1: Epoch=2024-01-01 00:01:00.000 UTC, Position magnitude=6871.29 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::OrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\nuse bh::traits::{Trajectory, Interpolatable};\nuse bh::{state_osculating_to_cartesian, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory\n    let mut traj = OrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..10 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let oe = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, (i as f64) * 0.1\n        );\n        let state = state_osculating_to_cartesian(oe, AngleFormat::Radians);\n        traj.add(epoch, state);\n    }\n\n    // Query properties\n    println!(\"Length: {}\", traj.len());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"End epoch: {}\", traj.end_epoch().unwrap());\n\n    // Interpolate at intermediate time\n    let interp_epoch = epoch0 + 45.0;\n    let interp_state = traj.interpolate(&amp;interp_epoch).unwrap();\n    println!(\"\\nInterpolated state at {}:\", interp_epoch);\n    println!(\"  Position (km): [{}, {}, {}] km\",\n        interp_state[0] / 1e3, interp_state[1] / 1e3, interp_state[2] / 1e3\n    );\n    println!(\"  Velocity (m/s): [{}, {}, {}] m/s\",\n        interp_state[3], interp_state[4], interp_state[5]\n    );\n\n    // Iterate over states\n    for (i, (epoch, state)) in traj.into_iter().enumerate().take(2) {\n        let pos_mag = state.fixed_rows::&lt;3&gt;(0).norm();\n        println!(\"State {}: Epoch={}, Position magnitude={:.2} km\",\n            i, epoch, pos_mag / 1e3);\n    }\n}\n\n// Output:\n// Length: 10\n// Timespan: 540.0 seconds\n// Start epoch: 2024-01-01 00:00:00.000 UTC\n// End epoch: 2024-01-01 00:09:00.000 UTC\n\n// Interpolated state at 2024-01-01 00:00:45.000 UTC:\n//   Position (km): [1159.0159730226278, 6101.297890257402, 2925.16369357997] km\n//   Velocity (m/s): [-5578.867341523014, -1338.7748300095711, 5004.22925363932] m/s\n// State 0: Epoch=2024-01-01 00:00:00.000 UTC, Position magnitude=6871.26 km\n// State 1: Epoch=2024-01-01 00:01:00.000 UTC, Position magnitude=6871.29 km\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#practical-workflow-example","title":"Practical Workflow Example","text":"<p>A complete example showing propagation, frame conversion, and analysis:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# 1. Define orbit and create propagator\na = bh.R_EARTH + 500e3  # 500 km altitude\ne = 0.001  # Nearly circular\ni = 97.8  # Sun-synchronous\nraan = 15.0\nargp = 30.0\nM = 0.0\noe = np.array([a, e, i, raan, argp, M])\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, oe, bh.AngleFormat.DEGREES, 60.0\n)\n\n# 2. Propagate for one orbit period\nperiod = bh.orbital_period(a)\nend_epoch = epoch + period\npropagator.propagate_to(end_epoch)\n\n# 3. Get trajectory in ECI Cartesian\ntraj_eci = propagator.trajectory\nprint(f\"Propagated {len(traj_eci)} states over {traj_eci.timespan() / 60:.1f} minutes\")\n\n# 4. Convert to ECEF to analyze ground track\ntraj_ecef = traj_eci.to_ecef()\nprint(\"\\nGround track in ECEF frame:\")\nfor i, (epoch, state_ecef) in enumerate(traj_ecef):\n    if i % 10 == 0:  # Sample every 10 states\n        # Convert ECEF to geodetic for latitude/longitude\n        lat, lon, alt = bh.position_ecef_to_geodetic(\n            state_ecef[0:3], bh.AngleFormat.DEGREES\n        )\n        print(f\"  {epoch}: Lat={lat:6.2f}\u00b0, Lon={lon:7.2f}\u00b0, Alt={alt / 1e3:6.2f} km\")\n\n# 5. Convert to Keplerian to analyze orbital evolution\ntraj_kep = traj_eci.to_keplerian(bh.AngleFormat.DEGREES)\nfirst_oe = traj_kep.state_at_idx(0)\nlast_oe = traj_kep.state_at_idx(len(traj_kep) - 1)\n\nprint(\"\\nOrbital element evolution:\")\nprint(f\"  Semi-major axis: {first_oe[0] / 1e3:.2f} km \u2192 {last_oe[0] / 1e3:.2f} km\")\nprint(f\"  Eccentricity: {first_oe[1]:.6f} \u2192 {last_oe[1]:.6f}\")\nprint(f\"  Inclination: {first_oe[2]:.2f}\u00b0 \u2192 {last_oe[2]:.2f}\u00b0\")\nprint(f\"  True anomaly: {first_oe[5]:.2f}\u00b0 \u2192 {last_oe[5]:.2f}\u00b0\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::traits::{Trajectory, OrbitPropagator};\nuse bh::trajectories::traits::OrbitalTrajectory;\nuse bh::{KeplerianPropagator, orbital_period, position_ecef_to_geodetic, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // 1. Define orbit and create propagator\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 97.8_f64.to_radians(),\n        15.0_f64.to_radians(), 30.0_f64.to_radians(), 0.0\n    );\n\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch, oe, AngleFormat::Radians, 60.0\n    );\n\n    // 2. Propagate for one orbit period\n    let period = orbital_period(R_EARTH + 500e3);\n    let end_epoch = epoch + period;\n    propagator.propagate_to(end_epoch);\n\n    // 3. Get trajectory in ECI Cartesian\n    let traj_eci = &amp;propagator.trajectory;\n    println!(\"Propagated {} states over {:.1} minutes\",\n        traj_eci.len(), traj_eci.timespan().unwrap() / 60.0);\n\n    // 4. Convert to ECEF\n    let traj_ecef = traj_eci.to_ecef();\n    println!(\"\\nGround track in ECEF frame:\");\n    for (i, (epoch, state_ecef)) in traj_ecef.into_iter().enumerate() {\n        if i % 10 == 0 {\n            let pos_ecef: na::Vector3&lt;f64&gt; = state_ecef.fixed_rows::&lt;3&gt;(0).into();\n            let lla = position_ecef_to_geodetic(pos_ecef, AngleFormat::Degrees);\n            println!(\"  {}: Lat={:6.2}\u00b0, Lon={:7.2}\u00b0, Alt={:6.2} km\",\n                epoch, lla[0], lla[1], lla[2] / 1e3);\n        }\n    }\n\n    // 5. Convert to Keplerian\n    let traj_kep = traj_eci.to_keplerian(AngleFormat::Radians);\n    let first_oe = traj_kep.state_at_idx(0).unwrap();\n    let last_oe = traj_kep.state_at_idx(traj_kep.len() - 1).unwrap();\n\n    println!(\"\\nOrbital element evolution:\");\n    println!(\"  Semi-major axis: {:.2} km \u2192 {:.2} km\",\n        first_oe[0] / 1e3, last_oe[0] / 1e3);\n    println!(\"  Eccentricity: {:.6} \u2192 {:.6}\",\n        first_oe[1], last_oe[1]);\n    println!(\"  Inclination: {:.2}\u00b0 \u2192 {:.2}\u00b0\",\n        first_oe[2].to_degrees(), last_oe[2].to_degrees());\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>Trajectories Overview - Trait hierarchy and implementation guide</li> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>STrajectory6 - Static 6D trajectory</li> <li>OrbitTrajectory API Reference</li> </ul>"},{"location":"learn/trajectories/strajectory6.html","title":"STrajectory6","text":"<p><code>STrajectory6</code> is a static, compile-time sized trajectory container optimized for 6-dimensional state vectors (position + velocity). Unlike <code>DTrajectory</code> which determines dimension at runtime, <code>STrajectory6</code> uses compile-time sizing for maximum performance and type safety.</p> <p>Use <code>STrajectory6</code> when:</p> <ul> <li>Working with 6D orbital states (position + velocity or orbital elements)</li> <li>State dimension is always fixed at 6</li> <li>Performance is critical</li> <li>You want compile-time dimension checking</li> </ul> <p><code>STrajectory6</code> is part of the <code>STrajectory&lt;R&gt;</code> family which includes <code>STrajectory3</code> (3D, position only) and <code>STrajectory4</code> (4D, quaternions). For applications requiring frame or representation conversions, consider using <code>OrbitTrajectory</code>.</p>"},{"location":"learn/trajectories/strajectory6.html#initialization","title":"Initialization","text":""},{"location":"learn/trajectories/strajectory6.html#empty-trajectory","title":"Empty Trajectory","text":"<p>Create an empty 6D trajectory:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create empty 6D trajectory\ntraj = bh.STrajectory6()\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 0\n\nprint(f\"Is empty: {traj.is_empty()}\")\n# Is empty: True\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create empty 6D trajectory\n    let traj = bh::STrajectory6::new();\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 0\n\n    println!(\"Is empty: {}\", traj.is_empty());\n    // Is empty: true\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#from-existing-data","title":"From Existing Data","text":"<p>Create a trajectory from existing epochs and 6D states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create epochs\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch1 = epoch0 + 60.0  # 1 minute later\nepoch2 = epoch0 + 120.0  # 2 minutes later\n\n# Create 6D states (position + velocity in meters and m/s)\n# Each row is one state vector\nstates = np.array(\n    [\n        [bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0],\n        [bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0],\n        [bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0],\n    ]\n)\n\n# Create trajectory from data\nepochs = [epoch0, epoch1, epoch2]\ntraj = bh.STrajectory6.from_data(epochs, states)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epochs\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n    let epoch1 = epoch0 + 60.0;\n    let epoch2 = epoch0 + 120.0;\n\n    // Create 6D states\n    let state0 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    let state1 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    );\n    let state2 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    );\n\n    // Create trajectory from data\n    let epochs = vec![epoch0, epoch1, epoch2];\n    let states = vec![state0, state1, state2];\n    let traj = bh::STrajectory6::from_data(epochs, states).unwrap();\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 3\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#adding-and-accessing-states","title":"Adding and Accessing States","text":""},{"location":"learn/trajectories/strajectory6.html#adding-states","title":"Adding States","text":"<p>Add 6D states to a trajectory:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create empty trajectory\ntraj = bh.STrajectory6()\n\n# Add states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 2\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create empty trajectory\n    let mut traj = bh::STrajectory6::new();\n\n    // Add states\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n    let state0 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    traj.add(epoch0, state0);\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    );\n    traj.add(epoch1, state1);\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 2\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#accessing-by-index","title":"Accessing by Index","text":"<p>Retrieve states and epochs by their index:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nepoch2 = epoch1 + 60.0\nstate2 = np.array([bh.R_EARTH + 500e3, 912000.0, 0.0, 0.0, -7600.0, 0.0])\ntraj.add(epoch2, state2)\n\n# Access by index\nretrieved_epoch = traj.epoch_at_idx(1)\nretrieved_state = traj.state_at_idx(1)\n\nprint(f\"Epoch: {retrieved_epoch}\")\nprint(\n    f\"Position: [{retrieved_state[0]:.2f}, {retrieved_state[1]:.2f}, {retrieved_state[2]:.2f}] m\"\n)\nprint(\n    f\"Velocity: [{retrieved_state[3]:.2f}, {retrieved_state[4]:.2f}, {retrieved_state[5]:.2f}] m/s\"\n)\n\n# Output:\n# Epoch: 2024-01-01 00:01:00.000 UTC\n# Position: [6878136.30, 456000.00, 0.00] m\n# Velocity: [-7600.00, 0.00, 0.00] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n    let state0 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    traj.add(epoch0, state0);\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    );\n    traj.add(epoch1, state1);\n\n    let epoch2 = epoch1 + 60.0;\n    let state2 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 912000.0, 0.0, 0.0, -7600.0, 0.0\n    );\n    traj.add(epoch2, state2);\n\n    // Access by index\n    let retrieved_epoch = traj.epoch_at_idx(1).unwrap();\n    let retrieved_state = traj.state_at_idx(1).unwrap();\n\n    println!(\"Epoch: {}\", retrieved_epoch);\n    println!(\"Position: [{:.2}, {:.2}, {:.2}] m\",\n        retrieved_state[0], retrieved_state[1], retrieved_state[2]);\n    println!(\"Velocity: [{:.2}, {:.2}, {:.2}] m/s\",\n        retrieved_state[3], retrieved_state[4], retrieved_state[5]);\n}\n\n// Output:\n// Epoch: 2024-01-01 00:01:00.000 UTC\n// Position: [6878136.30, 456000.00, 0.00] m\n// Velocity: [-7600.00, 0.00, 0.00] m/s\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#accessing-by-epoch","title":"Accessing by Epoch","text":"<p>Get states at or near specific epochs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with multiple states\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Get nearest state (exact match)\nquery_epoch = epoch0 + 120.0  # 2 minutes after start\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(f\"Exact match found at altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\")\n\n# Get nearest state (between stored epochs)\nquery_epoch = epoch0 + 125.0  # Between stored epochs\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(f\"Nearest state altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\")\n\n# Output:\n# Exact match found at altitude: 502.00 km\n# Nearest state altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with multiple states\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Get nearest state (exact match)\n    let query_epoch = epoch0 + 120.0;\n    let (_nearest_epoch, nearest_state) = traj.nearest_state(&amp;query_epoch).unwrap();\n    println!(\"Exact match found at altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n\n    // Get nearest state (between stored epochs)\n    let query_epoch = epoch0 + 125.0;\n    let (_nearest_epoch, nearest_state) = traj.nearest_state(&amp;query_epoch).unwrap();\n    println!(\"Nearest state altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n}\n\n// Output:\n// Exact match found at altitude: 502.00 km\n// Nearest state altitude: 502.00 km\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#querying-trajectory-properties","title":"Querying Trajectory Properties","text":"<p>Query the temporal extent and properties of a trajectory:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory spanning 5 minutes\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(6):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Query properties\nprint(f\"Number of states: {len(traj)}\")\n# Number of states: 6\n\nprint(f\"Start epoch: {traj.start_epoch}\")\nprint(f\"End epoch: {traj.end_epoch}\")\nprint(f\"Timespan: {traj.time_span:.1f} seconds\")\n# Timespan: 300.0 seconds\n\nprint(f\"Is empty: {traj.is_empty()}\")\n# Is empty: False\n\n# Access first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\nprint(f\"First epoch: {first_epoch}\")\nprint(f\"Last epoch: {last_epoch}\")\n\n# Output:\n# Number of states: 6\n# Start epoch: 2024-01-01 00:00:00.000 UTC\n# End epoch: 2024-01-01 00:05:00.000 UTC\n# Timespan: 300.0 seconds\n# Is empty: False\n# First epoch: 2024-01-01 00:00:00.000 UTC\n# Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory spanning 5 minutes\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    for i in 0..6 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Query properties\n    println!(\"Number of states: {}\", traj.len());\n    // Number of states: 6\n\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"End epoch: {}\", traj.end_epoch().unwrap());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    // Timespan: 300.0 seconds\n\n    println!(\"Is empty: {}\", traj.is_empty());\n    // Is empty: false\n\n    // Access first and last states\n    let (first_epoch, _first_state) = traj.first().unwrap();\n    let (last_epoch, _last_state) = traj.last().unwrap();\n    println!(\"First epoch: {}\", first_epoch);\n    println!(\"Last epoch: {}\", last_epoch);\n}\n\n// Output:\n// Number of states: 6\n// Start epoch: 2024-01-01 00:00:00.000 UTC\n// End epoch: 2024-01-01 00:05:00.000 UTC\n// Timespan: 300.0 seconds\n// Is empty: false\n// First epoch: 2024-01-01 00:00:00.000 UTC\n// Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#interpolation","title":"Interpolation","text":"<p>STrajectory6 supports linear interpolation to estimate states at arbitrary epochs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with sparse data\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states every 60 seconds\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    # Simplified motion: position changes linearly with time\n    state = np.array([bh.R_EARTH + 500e3 + i * 10000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Interpolate state at intermediate time\nquery_epoch = epoch0 + 30.0  # Halfway between first two states\ninterpolated_state = traj.interpolate(query_epoch)\n\nprint(f\"Interpolated altitude: {(interpolated_state[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Interpolated altitude: 505.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{Trajectory, Interpolatable};\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with sparse data\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    // Add states every 60 seconds\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3 + (i as f64) * 10000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Interpolate state at intermediate time\n    let query_epoch = epoch0 + 30.0;\n    let interpolated_state = traj.interpolate(&amp;query_epoch).unwrap();\n\n    println!(\"Interpolated altitude: {:.2} km\",\n        (interpolated_state[0] - R_EARTH) / 1e3);\n    // Interpolated altitude: 505.00 km\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#memory-management","title":"Memory Management","text":"<p>STrajectory6 supports eviction policies for automatic memory management:</p>"},{"location":"learn/trajectories/strajectory6.html#maximum-size-policy","title":"Maximum Size Policy","text":"<p>Keep only the N most recent states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with max size limit\ntraj = bh.STrajectory6().with_eviction_policy_max_size(3)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add 5 states\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only the 3 most recent states are kept\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n\nprint(f\"Start altitude: {(traj.state_at_idx(0)[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Start altitude: 502.00 km (states 0 and 1 were evicted)\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with max size limit\n    let mut traj = bh::STrajectory6::new()\n        .with_eviction_policy_max_size(3);\n\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    // Add 5 states\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Only the 3 most recent states are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 3\n\n    println!(\"Start altitude: {:.2} km\",\n        (traj.state_at_idx(0).unwrap()[0] - R_EARTH) / 1e3);\n    // Start altitude: 502.00 km (states 0 and 1 were evicted)\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#maximum-age-policy","title":"Maximum Age Policy","text":"<p>Keep only states within a time window:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Keep only states within last 2 minutes (120 seconds)\ntraj = bh.STrajectory6().with_eviction_policy_max_age(120.0)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states spanning 4 minutes\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only states within 120 seconds of the most recent are kept\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n\nprint(f\"Timespan: {traj.time_span:.1f} seconds\")\n# Timespan: 120.0 seconds\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Keep only states within last 2 minutes (120 seconds)\n    let mut traj = bh::STrajectory6::new()\n        .with_eviction_policy_max_age(120.0);\n\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    // Add states spanning 4 minutes\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Only states within 120 seconds of the most recent are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 3\n\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    // Timespan: 120.0 seconds\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#iteration","title":"Iteration","text":"<p>Trajectories can be iterated to process all epoch-state pairs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Iterate over all states\nfor epoch, state in traj:\n    altitude = (state[0] - bh.R_EARTH) / 1e3\n    velocity = np.linalg.norm(state[3:6])\n    print(f\"Epoch: {epoch}, Altitude: {altitude:.2f} km, Speed: {velocity:.0f} m/s\")\n# Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km, Speed: 7600 m/s\n# Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km, Speed: 7600 m/s\n# Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km, Speed: 7600 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Iterate over all states\n    for (epoch, state) in &amp;traj {\n        let altitude = (state[0] - R_EARTH) / 1e3;\n        let velocity = state.fixed_rows::&lt;3&gt;(3).norm();\n        println!(\"Epoch: {}, Altitude: {:.2} km, Speed: {:.0} m/s\",\n            epoch, altitude, velocity);\n    }\n    // Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km, Speed: 7600 m/s\n    // Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km, Speed: 7600 m/s\n    // Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km, Speed: 7600 m/s\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#matrix-export","title":"Matrix Export","text":"<p>Convert trajectory data to matrix format for analysis or export:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory\ntraj = bh.STrajectory6()\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + i * 10, 0.0])\n    traj.add(epoch, state)\n\n# Convert to matrix (rows are states, columns are dimensions)\nmatrix = traj.to_matrix()\nprint(f\"Matrix shape: {matrix.shape}\")\n# Matrix shape: (3, 6)\n\nprint(f\"First state velocity: {matrix[0, 4]:.1f} m/s\")\n# First state velocity: 7600.0 m/s\n\nprint(f\"Last state velocity: {matrix[2, 4]:.1f} m/s\")\n# Last state velocity: 7620.0 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory\n    let mut traj = bh::STrajectory6::new();\n    let epoch0 = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + (i as f64) * 10.0, 0.0\n        );\n        traj.add(epoch, state);\n    }\n\n    // Convert to matrix (rows are states, columns are dimensions)\n    let matrix = traj.to_matrix().unwrap();\n    println!(\"Matrix shape: ({}, {})\", matrix.nrows(), matrix.ncols());\n    // Matrix shape: (3, 6)\n\n    println!(\"First state velocity: {:.1} m/s\", matrix[(0, 4)]);\n    // First state velocity: 7600.0 m/s\n\n    println!(\"Last state velocity: {:.1} m/s\", matrix[(2, 4)]);\n    // Last state velocity: 7620.0 m/s\n}\n</code></pre>"},{"location":"learn/trajectories/strajectory6.html#performance-benefits","title":"Performance Benefits","text":"<p><code>STrajectory6</code> uses compile-time sized vectors (<code>SVector&lt;f64, 6&gt;</code> in Rust, fixed-size arrays in Python) which provide several benefits:</p> <p>Memory Layout: Contiguous memory allocation enables better cache utilization and SIMD optimizations.</p> <p>Type Safety: Dimension mismatches are caught at compile time in Rust, preventing runtime errors.</p> <p>Optimization: Compilers can optimize operations on fixed-size arrays more aggressively than dynamic allocations.</p> <p>Stack Allocation: Small fixed-size vectors can be allocated on the stack, avoiding heap allocations.</p> <p>For most orbital mechanics applications with 6D states, <code>STrajectory6</code> provides the best balance of performance and ease of use.</p>"},{"location":"learn/trajectories/strajectory6.html#other-static-trajectory-types","title":"Other Static Trajectory Types","text":"<p>The <code>STrajectory&lt;R&gt;</code> family includes other compile-time sized variants:</p> <ul> <li><code>STrajectory3</code>: 3D states (position only, or other 3D data)</li> <li><code>STrajectory4</code>: 4D states (quaternions for attitude)</li> <li><code>STrajectory6</code>: 6D states (position + velocity, most common)</li> </ul> <p>All variants share the same API and support the same operations.</p>"},{"location":"learn/trajectories/strajectory6.html#see-also","title":"See Also","text":"<ul> <li>Trajectories Overview - Trait hierarchy and implementation guide</li> <li>DTrajectory - Dynamic-dimension trajectory for variable sizes</li> <li>OrbitTrajectory - Orbital trajectory with frame conversions</li> <li>STrajectory6 API Reference</li> </ul>"},{"location":"learn/utilities/index.html","title":"Utilities","text":"<p>The <code>utils</code> module provides utility functions that support core functionality of the Brahe library. While most users won't need to interact with these functions directly, they offer control over caching, parallel computation, and output formatting.</p>"},{"location":"learn/utilities/index.html#caching","title":"Caching","text":"<p>Brahe automatically manages a local cache directory to store downloaded data such as Earth Orientation Parameters (EOP) and TLE data. Caching both minimizes the load and impact that brahe-related requests have on host servers as well as improve performance for users by eliminating unneeded network requests. The caching utilities provide functions to locate and manage these cache directories.</p> <p>By default, cache data is stored in <code>~/.cache/brahe</code> on Unix systems or the equivalent on other platforms. The location can be customized using the <code>BRAHE_CACHE</code> environment variable. Cache directories are automatically created on first access and organized into subdirectories for different data types (e.g., <code>eop/</code>, <code>celestrak/</code>).</p> <p>See Caching for complete details.</p>"},{"location":"learn/utilities/index.html#threading","title":"Threading","text":"<p>Brahe uses a global thread pool to parallelize computationally intensive operations, such as computing access windows between satellites and ground locations. The threading utilities allow you to configure the number of threads used by the thread pool.</p> <p>By default, Brahe uses 90% of available CPU cores, but you can manually set the thread count to optimize performance based on your workload and system resources. The thread pool can be reconfigured at any time during program execution.</p> <p>See Multithreading for complete details.</p>"},{"location":"learn/utilities/index.html#string-formatting","title":"String Formatting","text":"<p>The string formatting utilities provide functions for converting numerical values into human-readable strings. Currently, this includes formatting time durations (in seconds) into strings like \"2 hours and 30.5 minutes\" or \"2h 30m\" (short form).</p> <p>These utilities are useful for displaying results to users in a more intuitive format than raw numerical values.</p> <p>See String Formatting for complete details.</p>"},{"location":"learn/utilities/index.html#see-also","title":"See Also","text":"<ul> <li>Caching - Cache directory management</li> <li>Multithreading - Thread pool configuration</li> <li>String Formatting - Human-readable output formatting</li> <li>Utilities API Reference - Complete utilities function documentation</li> </ul>"},{"location":"learn/utilities/caching.html","title":"Caching","text":"<p>Brahe automatically manages a local cache directory to store downloaded data such as Earth Orientation Parameters (EOP) and TLE data. The caching utilities provide functions to locate and manage these cache directories.</p> <p>For complete API details, see the Caching API Reference.</p>"},{"location":"learn/utilities/caching.html#default-cache-location","title":"Default Cache Location","text":"<p>By default, Brahe stores cache data in a platform-specific location:</p> <ul> <li>Unix/Linux/macOS: <code>~/.cache/brahe</code></li> <li>Windows: <code>%LOCALAPPDATA%\\brahe\\cache</code></li> </ul> <p>All cache directories are automatically created on first access, so you don't need to manually create them.</p>"},{"location":"learn/utilities/caching.html#environment-variable-override","title":"Environment Variable Override","text":"<p>You can customize the cache location by setting the <code>BRAHE_CACHE</code> environment variable:</p> <pre><code>export BRAHE_CACHE=/custom/path/to/cache\n</code></pre> <p>This is useful for:</p> <ul> <li>Using a different storage location with more space</li> <li>Sharing cache data across multiple users</li> <li>Testing with isolated cache directories</li> </ul>"},{"location":"learn/utilities/caching.html#getting-cache-directories","title":"Getting Cache Directories","text":""},{"location":"learn/utilities/caching.html#main-cache-directory","title":"Main Cache Directory","text":"<p>The main cache directory is the root location for all Brahe cache data:</p> PythonRust <pre><code># Get main cache directory\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Main cache directory: {cache_dir}\")\n</code></pre> <pre><code>    // Get main cache directory\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    println!(\"Main cache directory: {}\", cache_dir);\n</code></pre>"},{"location":"learn/utilities/caching.html#eop-cache-directory","title":"EOP Cache Directory","text":"<p>Earth Orientation Parameters are stored in a dedicated subdirectory:</p> PythonRust <pre><code># Get cache subdirectory for EOP data\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache directory: {eop_cache}\")\n</code></pre> <pre><code>    // Get cache subdirectory for EOP data\n    let eop_cache = bh::utils::get_eop_cache_dir().unwrap();\n    println!(\"EOP cache directory: {}\", eop_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#celestrak-cache-directory","title":"CelesTrak Cache Directory","text":"<p>Satellite TLE data downloaded from CelesTrak is stored in its own subdirectory:</p> PythonRust <pre><code># Get cache subdirectory for CelesTrak data\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache directory: {celestrak_cache}\")\n</code></pre> <pre><code>    // Get cache subdirectory for CelesTrak data\n    let celestrak_cache = bh::utils::get_celestrak_cache_dir().unwrap();\n    println!(\"CelesTrak cache directory: {}\", celestrak_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#custom-subdirectories","title":"Custom Subdirectories","text":"<p>You can create custom subdirectories within the cache for your own data:</p> PythonRust <pre><code># Get a custom subdirectory within the cache\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"custom_data\")\nprint(f\"Custom cache subdirectory: {custom_cache}\")\n</code></pre> <pre><code>    // Get a custom subdirectory within the cache\n    let custom_cache = bh::utils::get_brahe_cache_dir_with_subdir(Some(\"custom_data\")).unwrap();\n    println!(\"Custom cache subdirectory: {}\", custom_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating all cache directory functions:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Get main cache directory\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Main cache directory: {cache_dir}\")\n\n# Get cache subdirectory for EOP data\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache directory: {eop_cache}\")\n\n# Get cache subdirectory for CelesTrak data\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache directory: {celestrak_cache}\")\n\n# Get a custom subdirectory within the cache\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"custom_data\")\nprint(f\"Custom cache subdirectory: {custom_cache}\")\n\n# Note: All directories are automatically created if they don't exist\n# You can override the default location by setting the BRAHE_CACHE\n# environment variable\n\n# Expected output (paths will vary by system):\n# Main cache directory: /home/USER/.cache/brahe\n# EOP cache directory: /home/USER/.cache/brahe/eop\n# CelesTrak cache directory: /home/USER/.cache/brahe/celestrak\n# Custom cache subdirectory: /home/USER/.cache/brahe/custom_data\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get main cache directory\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    println!(\"Main cache directory: {}\", cache_dir);\n\n    // Get cache subdirectory for EOP data\n    let eop_cache = bh::utils::get_eop_cache_dir().unwrap();\n    println!(\"EOP cache directory: {}\", eop_cache);\n\n    // Get cache subdirectory for CelesTrak data\n    let celestrak_cache = bh::utils::get_celestrak_cache_dir().unwrap();\n    println!(\"CelesTrak cache directory: {}\", celestrak_cache);\n\n    // Get a custom subdirectory within the cache\n    let custom_cache = bh::utils::get_brahe_cache_dir_with_subdir(Some(\"custom_data\")).unwrap();\n    println!(\"Custom cache subdirectory: {}\", custom_cache);\n\n    // Note: All directories are automatically created if they don't exist\n    // You can override the default location by setting the BRAHE_CACHE\n    // environment variable\n\n    // Expected output (paths will vary by system):\n    // Main cache directory: /home/USER/.cache/brahe\n    // EOP cache directory: /home/USER/.cache/brahe/eop\n    // CelesTrak cache directory: /home/USER/.cache/brahe/celestrak\n    // Custom cache subdirectory: /home/USER/.cache/brahe/custom_data\n}\n</code></pre>"},{"location":"learn/utilities/caching.html#cache-management","title":"Cache Management","text":"<p>Automatic Cleanup</p> <p>Brahe does not automatically clean up old cache files. If you need to free up disk space, you can manually delete files from the cache directory. Brahe will re-download any needed data on the next request.</p> <p>Sharing Cache Between Users</p> <p>If you're working on server with multiple users using Brahe, you can share the same cache directory by setting the <code>BRAHE_CACHE</code> environment variable to a common location. This avoids duplicate downloads of EOP and TLE data.</p>"},{"location":"learn/utilities/caching.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>Caching API Reference - Complete caching function documentation</li> </ul>"},{"location":"learn/utilities/string_formatting.html","title":"String Formatting","text":"<p>The string formatting utilities provide functions for converting numerical values into human-readable strings. This makes it easier to display results to users in an intuitive format.</p> <p>For complete API details, see the String Formatting API Reference.</p>"},{"location":"learn/utilities/string_formatting.html#time-duration-formatting","title":"Time Duration Formatting","text":"<p>The primary formatting utility is <code>format_time_string()</code>, which converts a time duration in seconds into a human-readable string.</p>"},{"location":"learn/utilities/string_formatting.html#long-format-default","title":"Long Format (Default)","text":"<p>The long format provides a full description with proper units and grammar:</p> PythonRust <pre><code># Format various time durations in long format (default)\nprint(\"Long format (default):\")\nprint(f\"  30 seconds: {bh.format_time_string(30)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000)}\")\n</code></pre> <pre><code>    // Format various time durations in long format (default)\n    println!(\"Long format (default):\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, false));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, false));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, false));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, false));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, false));\n</code></pre> <p>The long format uses proper grammar and includes fractional seconds:</p> <ul> <li><code>30.00 seconds</code></li> <li><code>1 minute and 30.00 seconds</code></li> <li><code>6 minutes and 2.00 seconds</code></li> <li><code>1 hour, 1 minute and 5.00 seconds</code></li> <li><code>1 day, 1 hour and 0.00 seconds</code></li> </ul>"},{"location":"learn/utilities/string_formatting.html#short-format","title":"Short Format","text":"<p>The short format provides a more compact representation suitable for tables or limited space:</p> PythonRust <pre><code># Format the same durations in short format\nprint(\"\\nShort format:\")\nprint(f\"  30 seconds: {bh.format_time_string(30, short=True)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90, short=True)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362, short=True)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665, short=True)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000, short=True)}\")\n</code></pre> <pre><code>    // Format the same durations in short format\n    println!(\"\\nShort format:\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, true));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, true));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, true));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, true));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, true));\n</code></pre> <p>The short format uses abbreviations without fractional seconds:</p> <ul> <li><code>30s</code></li> <li><code>1m 30s</code></li> <li><code>6m 2s</code></li> <li><code>1h 1m 5s</code></li> <li><code>1d 1h 0m</code></li> </ul>"},{"location":"learn/utilities/string_formatting.html#practical-example","title":"Practical Example","text":"<p>Here's a practical example formatting an orbital period:</p> PythonRust <pre><code># Practical use case: format orbital period\norbital_period = bh.orbital_period(bh.R_EARTH + 500e3)\nprint(f\"\\nLEO orbital period: {bh.format_time_string(orbital_period)}\")\nprint(\n</code></pre> <pre><code>    // Practical use case: format orbital period\n    let orbital_period = bh::orbits::orbital_period(bh::constants::R_EARTH + 500e3);\n    println!(\"\\nLEO orbital period: {}\", bh::utils::format_time_string(orbital_period, false));\n    println!(\"LEO orbital period (short): {}\", bh::utils::format_time_string(orbital_period, true));\n</code></pre> <p>This produces:</p> <pre><code>LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\nLEO orbital period (short): 1h 34m 38s\n</code></pre>"},{"location":"learn/utilities/string_formatting.html#supported-time-units","title":"Supported Time Units","text":"<p>The function automatically selects the appropriate units based on the duration:</p> Duration Range Units Used &lt; 60 seconds seconds only 60s - 1 hour minutes and seconds 1 hour - 1 day hours, minutes, and seconds &gt; 1 day days, hours, minutes (short format) or days, hours, minutes, and seconds (long format) <p>Precision</p> <ul> <li>Long format: Displays seconds with 2 decimal places</li> <li>Short format: Displays only whole seconds (fractional part truncated)</li> </ul>"},{"location":"learn/utilities/string_formatting.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating both formats with various durations:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Format various time durations in long format (default)\nprint(\"Long format (default):\")\nprint(f\"  30 seconds: {bh.format_time_string(30)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000)}\")\n\n# Format the same durations in short format\nprint(\"\\nShort format:\")\nprint(f\"  30 seconds: {bh.format_time_string(30, short=True)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90, short=True)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362, short=True)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665, short=True)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000, short=True)}\")\n\n# Practical use case: format orbital period\norbital_period = bh.orbital_period(bh.R_EARTH + 500e3)\nprint(f\"\\nLEO orbital period: {bh.format_time_string(orbital_period)}\")\nprint(\n    f\"LEO orbital period (short): {bh.format_time_string(orbital_period, short=True)}\"\n)\n\n# Expected output:\n# Long format (default):\n#   30 seconds: 30.00 seconds\n#   90 seconds: 1 minute and 30.00 seconds\n#   362 seconds: 6 minutes and 2.00 seconds\n#   3665 seconds: 1 hour, 1 minute and 5.00 seconds\n#   90000 seconds: 1 day, 1 hour and 0.00 seconds\n#\n# Short format:\n#   30 seconds: 30s\n#   90 seconds: 1m 30s\n#   362 seconds: 6m 2s\n#   3665 seconds: 1h 1m 5s\n#   90000 seconds: 1d 1h 0m\n#\n# LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\n# LEO orbital period (short): 1h 34m 38s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Format various time durations in long format (default)\n    println!(\"Long format (default):\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, false));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, false));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, false));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, false));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, false));\n\n    // Format the same durations in short format\n    println!(\"\\nShort format:\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, true));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, true));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, true));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, true));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, true));\n\n    // Practical use case: format orbital period\n    let orbital_period = bh::orbits::orbital_period(bh::constants::R_EARTH + 500e3);\n    println!(\"\\nLEO orbital period: {}\", bh::utils::format_time_string(orbital_period, false));\n    println!(\"LEO orbital period (short): {}\", bh::utils::format_time_string(orbital_period, true));\n\n    // Expected output:\n    // Long format (default):\n    //   30 seconds: 30.00 seconds\n    //   90 seconds: 1 minute and 30.00 seconds\n    //   362 seconds: 6 minutes and 2.00 seconds\n    //   3665 seconds: 1 hour, 1 minute and 5.00 seconds\n    //   90000 seconds: 1 day, 1 hour and 0.00 seconds\n    //\n    // Short format:\n    //   30 seconds: 30s\n    //   90 seconds: 1m 30s\n    //   362 seconds: 6m 2s\n    //   3665 seconds: 1h 1m 5s\n    //   90000 seconds: 1d 1h 0m\n    //\n    // LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\n    // LEO orbital period (short): 1h 34m 38s\n}\n</code></pre>"},{"location":"learn/utilities/string_formatting.html#common-use-cases","title":"Common Use Cases","text":"<p>Time formatting is useful for:</p> <ul> <li>Access window durations: Display how long a satellite is visible from a ground station</li> <li>Orbital periods: Show the time for one complete orbit in readable form</li> <li>Propagation times: Display simulation duration or time steps</li> <li>Reports and output: Present timing information to users</li> </ul> <p>Choosing a Format</p> <ul> <li>Use long format for reports, documentation, and user-facing output where clarity is important</li> <li>Use short format for tables, logs, and situations where space is limited</li> </ul>"},{"location":"learn/utilities/string_formatting.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>String Formatting API Reference - Complete formatting function documentation</li> </ul>"},{"location":"learn/utilities/threading.html","title":"Multithreading","text":"<p>Brahe uses a global thread pool to parallelize computationally intensive operations, such as computing access windows between satellites and ground locations. The threading utilities allow you to configure the number of threads used by the thread pool.</p> <p>For complete API details, see the Threading API Reference.</p>"},{"location":"learn/utilities/threading.html#default-behavior","title":"Default Behavior","text":"<p>By default, Brahe automatically configures the thread pool to use 90% of available CPU cores on first use. This greatly accelerates computations while leaving some resources for other processes to avoid resource-starving other processes on the machine.</p> <p>For example, on a system with 8 CPU cores, Brahe will use 7 threads by default.</p> <p>Lazy Initialization</p> <p>The thread pool is initialized on first use, not when you import Brahe. This means the default thread count is determined when you first call a function that uses the thread pool.</p> <p>You can configure the thread pool before first use to override the default behavior by calling <code>set_num_threads()</code> or <code>set_max_threads()</code> as shown below.</p> <p>Thread Safety</p> <p>All Brahe functions are thread-safe. You can safely call Brahe functions from multiple threads simultaneously.</p>"},{"location":"learn/utilities/threading.html#setting-thread-count","title":"Setting Thread Count","text":""},{"location":"learn/utilities/threading.html#set-specific-number","title":"Set Specific Number","text":"<p>You can set the thread pool to use a specific number of threads:</p> PythonRust <pre><code># Set a specific number of threads\nbh.set_num_threads(4)\nthreads_after_set = bh.get_max_threads()\nprint(f\"Thread count after setting to 4: {threads_after_set}\")\n</code></pre> <pre><code>    // Set a specific number of threads\n    bh::utils::set_num_threads(4);\n    let threads_after_set = bh::utils::get_max_threads();\n    println!(\"Thread count after setting to 4: {}\", threads_after_set);\n</code></pre>"},{"location":"learn/utilities/threading.html#set-maximum-threads","title":"Set Maximum Threads","text":"<p>To use all available CPU cores (100%), use <code>set_max_threads()</code>:</p> PythonRust <pre><code># Set to maximum available (100% of CPU cores)\nbh.set_max_threads()\nmax_threads = bh.get_max_threads()\nprint(f\"Maximum thread count: {max_threads}\")\n</code></pre> <pre><code>    // Set to maximum available (100% of CPU cores)\n    bh::utils::set_max_threads();\n    let max_threads = bh::utils::get_max_threads();\n    println!(\"Maximum thread count: {}\", max_threads);\n</code></pre> <p>When to Use Maximum Threads</p> <p>Use <code>set_max_threads()</code> when Brahe is the sole computational task running on a server and you want to maximize throughput.</p>"},{"location":"learn/utilities/threading.html#ludicrous-speed","title":"Ludicrous Speed!","text":"<p>For a bit of fun, there's an alias for <code>set_max_threads()</code>:</p> PythonRust <pre><code># Alternative: use the fun alias!\nbh.set_ludicrous_speed()\nludicrous_threads = bh.get_max_threads()\nprint(f\"Ludicrous speed thread count: {ludicrous_threads}\")\n</code></pre> <pre><code>    // Alternative: use the fun alias!\n    bh::utils::set_ludicrous_speed();\n    let ludicrous_threads = bh::utils::get_max_threads();\n    println!(\"Ludicrous speed thread count: {}\", ludicrous_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#querying-thread-count","title":"Querying Thread Count","text":"<p>You can check the current thread pool configuration at any time:</p> PythonRust <pre><code># Query the default number of threads\n# By default, Brahe uses 90% of available CPU cores\ndefault_threads = bh.get_max_threads()\nprint(f\"Default thread count: {default_threads}\")\n</code></pre> <pre><code>    // Query the default number of threads\n    // By default, Brahe uses 90% of available CPU cores\n    let default_threads = bh::utils::get_max_threads();\n    println!(\"Default thread count: {}\", default_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#reconfiguring-the-thread-pool","title":"Reconfiguring the Thread Pool","text":"<p>The thread pool can be reconfigured at any time during program execution. Simply call <code>set_num_threads()</code> or <code>set_max_threads()</code> again with the new desired configuration:</p> PythonRust <pre><code># The thread pool can be reconfigured at any time\nbh.set_num_threads(2)\nfinal_threads = bh.get_max_threads()\nprint(f\"Final thread count: {final_threads}\")\n</code></pre> <pre><code>    // The thread pool can be reconfigured at any time\n    bh::utils::set_num_threads(2);\n    let final_threads = bh::utils::get_max_threads();\n    println!(\"Final thread count: {}\", final_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating all threading configuration functions:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Query the default number of threads\n# By default, Brahe uses 90% of available CPU cores\ndefault_threads = bh.get_max_threads()\nprint(f\"Default thread count: {default_threads}\")\n\n# Set a specific number of threads\nbh.set_num_threads(4)\nthreads_after_set = bh.get_max_threads()\nprint(f\"Thread count after setting to 4: {threads_after_set}\")\n\n# Set to maximum available (100% of CPU cores)\nbh.set_max_threads()\nmax_threads = bh.get_max_threads()\nprint(f\"Maximum thread count: {max_threads}\")\n\n# Alternative: use the fun alias!\nbh.set_ludicrous_speed()\nludicrous_threads = bh.get_max_threads()\nprint(f\"Ludicrous speed thread count: {ludicrous_threads}\")\n\n# The thread pool can be reconfigured at any time\nbh.set_num_threads(2)\nfinal_threads = bh.get_max_threads()\nprint(f\"Final thread count: {final_threads}\")\n\n# Note: Thread pool is used for parallelizable operations like:\n# - Computing access windows between satellites and ground locations\n# - Processing large batches of orbital calculations\n\n# Expected output (actual numbers vary by system):\n# Default thread count: 7\n# Thread count after setting to 4: 4\n# Maximum thread count: 8\n# Ludicrous speed thread count: 8\n# Final thread count: 2\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Query the default number of threads\n    // By default, Brahe uses 90% of available CPU cores\n    let default_threads = bh::utils::get_max_threads();\n    println!(\"Default thread count: {}\", default_threads);\n\n    // Set a specific number of threads\n    bh::utils::set_num_threads(4);\n    let threads_after_set = bh::utils::get_max_threads();\n    println!(\"Thread count after setting to 4: {}\", threads_after_set);\n\n    // Set to maximum available (100% of CPU cores)\n    bh::utils::set_max_threads();\n    let max_threads = bh::utils::get_max_threads();\n    println!(\"Maximum thread count: {}\", max_threads);\n\n    // Alternative: use the fun alias!\n    bh::utils::set_ludicrous_speed();\n    let ludicrous_threads = bh::utils::get_max_threads();\n    println!(\"Ludicrous speed thread count: {}\", ludicrous_threads);\n\n    // The thread pool can be reconfigured at any time\n    bh::utils::set_num_threads(2);\n    let final_threads = bh::utils::get_max_threads();\n    println!(\"Final thread count: {}\", final_threads);\n\n    // Note: Thread pool is used for parallelizable operations like:\n    // - Computing access windows between satellites and ground locations\n    // - Processing large batches of orbital calculations\n\n    // Expected output (actual numbers vary by system):\n    // Default thread count: 7\n    // Thread count after setting to 4: 4\n    // Maximum thread count: 8\n    // Ludicrous speed thread count: 8\n    // Final thread count: 2\n}\n</code></pre>"},{"location":"learn/utilities/threading.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>Threading API Reference - Complete threading function documentation</li> </ul>"},{"location":"library_api/index.html","title":"Python API Reference","text":"<p>This section provides comprehensive documentation for the Brahe Python API. All classes, functions, and modules are documented with detailed descriptions, parameters, return values, and usage examples.</p>"},{"location":"library_api/index.html#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the detailed API documentation for each module. Each page includes:</p> <ul> <li>Complete class and function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value specifications</li> <li>Usage examples</li> </ul> <p>All documentation is automatically generated from the source code docstrings to ensure accuracy and consistency.</p>"},{"location":"library_api/frames.html","title":"Reference Frames Module","text":"<p>Reference frame transformations between ECI and ECEF coordinate systems.</p>"},{"location":"library_api/frames.html#brahe.frames","title":"frames","text":"<p>Reference Frames Module</p> <p>Reference frame transformations between ECI and ECEF coordinate systems.</p> <p>This module provides transformations between: - ECI (Earth-Centered Inertial): J2000/GCRF frame - ECEF (Earth-Centered Earth-Fixed): ITRF frame</p> <p>The transformations implement the IAU 2006/2000A precession-nutation model and use Earth Orientation Parameters (EOP) for high-precision conversions.</p> <p>Functions are provided for: - Rotation matrices (bias-precession-nutation, Earth rotation, polar motion) - Position vector transformations - State vector (position + velocity) transformations</p> Naming Conventions <p>Brahe provides two equivalent sets of function names for frame transformations:</p> <ul> <li>ECI/ECEF naming: Traditional coordinate system names (e.g., rotation_eci_to_ecef)</li> <li>GCRF/ITRF naming: Explicit reference frame names (e.g., rotation_gcrf_to_itrf)</li> </ul> <p>Both naming conventions provide identical results. Users can choose whichever convention they prefer. The ECI/ECEF names are more intuitive and widely used, while the GCRF/ITRF names explicitly identify the specific reference frame implementations used. The ECI/ECEF names are provided as the default to get the \"best\" reference frame transformations out-of-the-box, while the GCRF/ITRF names are for users who want to be explicit about the reference frames they are using.</p>"},{"location":"library_api/frames.html#brahe.frames.bias_precession_nutation","title":"bias_precession_nutation  <code>builtin</code>","text":"<pre><code>bias_precession_nutation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Bias-Precession-Nutation matrix transforming the <code>GCRS</code> to the <code>CIRS</code> intermediate reference frame. This transformation corrects for the bias, precession, and nutation of Celestial Intermediate Origin (<code>CIO</code>) with respect to inertial space.</p> <p>This formulation computes the Bias-Precession-Nutation correction matrix according using a <code>CIO</code> based model using using the <code>IAU 2006</code> precession and <code>IAU 2000A</code> nutation models.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to the Celestial Intermediate Pole (<code>CIP</code>) derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRS</code> -&gt; <code>CIRS</code></p> References <p>IAU SOFA Tools For Earth Attitude, Example 5.5 http://www.iausofa.org/2021_0512_C/sofa/sofa_pn_c.pdf Software Version 18, 2021-04-18</p>"},{"location":"library_api/frames.html#brahe.frames.earth_rotation","title":"earth_rotation  <code>builtin</code>","text":"<pre><code>earth_rotation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>CIRS</code> to the <code>TIRS</code> intermediate reference frame. This transformation corrects for the Earth rotation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>CIRS</code> -&gt; <code>TIRS</code></p>"},{"location":"library_api/frames.html#brahe.frames.polar_motion","title":"polar_motion  <code>builtin</code>","text":"<pre><code>polar_motion(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>TIRS</code> to the <code>ITRF</code> reference frame.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to compute the polar motion correction based on empirical observations of polar motion drift.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>TIRS</code> -&gt; <code>ITRF</code></p>"},{"location":"library_api/frames.html#brahe.frames.rotation_gcrf_to_itrf","title":"rotation_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>rotation_gcrf_to_itrf(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame). Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermediate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>ITRF</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from GCRF to ITRF\nR = bh.rotation_gcrf_to_itrf(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_itrf_to_gcrf","title":"rotation_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>rotation_itrf_to_gcrf(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame). Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermediate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ITRF</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ITRF to GCRF\nR = bh.rotation_itrf_to_gcrf(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_eci_to_ecef","title":"rotation_eci_to_ecef  <code>builtin</code>","text":"<pre><code>rotation_eci_to_ecef(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>This function is an alias for rotation_gcrf_to_itrf. <code>ECI</code> refers to the <code>GCRF</code> (Geocentric Celestial Reference Frame) implementation, and <code>ECEF</code> refers to the <code>ITRF</code> (International Terrestrial Reference Frame) implementation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ECI</code> (<code>GCRF</code>) -&gt; <code>ECEF</code> (<code>ITRF</code>)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix\nR = bh.rotation_eci_to_ecef(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_ecef_to_eci","title":"rotation_ecef_to_eci  <code>builtin</code>","text":"<pre><code>rotation_ecef_to_eci(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>This function is an alias for rotation_itrf_to_gcrf. <code>ECEF</code> refers to the <code>ITRF</code> (International Terrestrial Reference Frame) implementation, and <code>ECI</code> refers to the <code>GCRF</code> (Geocentric Celestial Reference Frame) implementation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ECEF</code> (<code>ITRF</code>) -&gt; <code>ECI</code> (<code>GCRF</code>)</p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR = bh.rotation_ecef_to_eci(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_gcrf_to_itrf","title":"position_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>position_gcrf_to_itrf(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ITRF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in GCRF (meters)\nr_gcrf = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ITRF\nr_itrf = bh.position_gcrf_to_itrf(epc, r_gcrf)\nprint(f\"ITRF position: {r_itrf}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_itrf_to_gcrf","title":"position_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>position_itrf_to_gcrf(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ITRF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ITRF (ground station)\nr_itrf = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to GCRF\nr_gcrf = bh.position_itrf_to_gcrf(epc, r_itrf)\nprint(f\"GCRF position: {r_gcrf}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_eci_to_ecef","title":"position_eci_to_ecef  <code>builtin</code>","text":"<pre><code>position_eci_to_ecef(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>This function is an alias for position_gcrf_to_itrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in ECI (meters)\nr_eci = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ECEF\nr_ecef = bh.position_eci_to_ecef(epc, r_eci)\nprint(f\"ECEF position: {r_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_ecef_to_eci","title":"position_ecef_to_eci  <code>builtin</code>","text":"<pre><code>position_ecef_to_eci(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>This function is an alias for position_itrf_to_gcrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ECEF (ground station)\nr_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to ECI\nr_eci = bh.position_ecef_to_eci(epc, r_ecef)\nprint(f\"ECI position: {r_eci}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_gcrf_to_itrf","title":"state_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>state_gcrf_to_itrf(epc: Epoch, x_gcrf: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_gcrf</code> <code>ndarray or list</code> <p>State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ITRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in GCRF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_gcrf = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ITRF\nstate_itrf = bh.state_gcrf_to_itrf(epc, state_gcrf)\nprint(f\"ITRF state: {state_itrf}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_itrf_to_gcrf","title":"state_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>state_itrf_to_gcrf(epc: Epoch, x_itrf: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_itrf</code> <code>ndarray or list</code> <p>State vector in <code>ITRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ITRF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_itrf = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to GCRF\nstate_gcrf = bh.state_itrf_to_gcrf(epc, state_itrf)\nprint(f\"GCRF state: {state_gcrf}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_eci_to_ecef","title":"state_eci_to_ecef  <code>builtin</code>","text":"<pre><code>state_eci_to_ecef(epc: Epoch, x_eci: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>This function is an alias for state_gcrf_to_itrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_eci</code> <code>ndarray or list</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECI [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eci = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\nprint(f\"ECEF state: {state_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_ecef_to_eci","title":"state_ecef_to_eci  <code>builtin</code>","text":"<pre><code>state_ecef_to_eci(epc: Epoch, x_ecef: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>This function is an alias for state_itrf_to_gcrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_ecef</code> <code>ndarray or list</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_ecef = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to ECI\nstate_eci = bh.state_ecef_to_eci(epc, state_ecef)\nprint(f\"ECI state: {state_eci}\")\n</code></pre>"},{"location":"library_api/access/index.html","title":"Access Computation API","text":"<p>The access computation module provides comprehensive tools for determining when satellites can observe or communicate with ground locations.</p>"},{"location":"library_api/access/index.html#core-functions","title":"Core Functions","text":""},{"location":"library_api/access/index.html#brahe.location_accesses","title":"location_accesses  <code>builtin</code>","text":"<pre><code>location_accesses(locations: PointLocation | PolygonLocation | List[PointLocation | PolygonLocation], propagators: SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator], search_start: Epoch, search_end: Epoch, constraint: Union[ElevationConstraint, OffNadirConstraint, LocalTimeConstraint, LookDirectionConstraint, AscDscConstraint, ElevationMaskConstraint, ConstraintAll, ConstraintAny, ConstraintNot], property_computers: [List[AccessPropertyComputer]] = None, config: [AccessSearchConfig] = None, time_tolerance: [float] = None) -&gt; List[AccessWindow]\n</code></pre> <p>Compute access windows for locations and satellites.</p> <p>This function accepts either single items or lists for both locations and propagators, automatically handling all combinations. All location-satellite pairs are computed and results are returned sorted by window start time.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>PointLocation | PolygonLocation | List[PointLocation | PolygonLocation]</code> <p>Single location or list of locations</p> required <code>propagators</code> <code>SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator]</code> <p>Single propagator or list of propagators</p> required <code>search_start</code> <code>Epoch</code> <p>Start of search window</p> required <code>search_end</code> <code>Epoch</code> <p>End of search window</p> required <code>constraint</code> <code>AccessConstraint</code> <p>Access constraints to evaluate</p> required <code>property_computers</code> <code>Optional[List[AccessPropertyComputer]]</code> <p>Optional property computers</p> <code>None</code> <code>config</code> <code>Optional[AccessSearchConfig]</code> <p>Search configuration (default: 60s fixed grid, no adaptation)</p> <code>None</code> <code>time_tolerance</code> <code>Optional[float]</code> <p>Bisection search tolerance in seconds (default: 0.01)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AccessWindow]</code> <p>List[AccessWindow]: List of access windows sorted by start time</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a ground station\nstation = bh.PointLocation(-75.0, 40.0, 0.0)  # Philadelphia\n\n# Create satellite propagators\nepoch = bh.Epoch(2024, 1, 1, 0, 0, 0.0)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator(epoch, state)\n\n# Define access constraints\nconstraint = bh.ElevationConstraint(10.0)  # 10 degree minimum elevation\n\n# Single location, single propagator\nsearch_end = epoch + 86400.0  # 1 day\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint)\n\n# Single location, multiple propagators\nprop2 = bh.KeplerianPropagator(epoch, state)  # Different satellite\nwindows = bh.location_accesses(station, [prop1, prop2], epoch, search_end, constraint)\n\n# Multiple locations, single propagator\nstation2 = bh.PointLocation(-122.0, 37.0, 0.0)  # San Francisco\nwindows = bh.location_accesses([station, station2], prop1, epoch, search_end, constraint)\n\n# Multiple locations, multiple propagators\nwindows = bh.location_accesses([station, station2], [prop1, prop2], epoch, search_end, constraint)\n\n# Custom search configuration\nconfig = bh.AccessSearchConfig(initial_time_step=30.0, adaptive_step=True)\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint, config=config)\n</code></pre>"},{"location":"library_api/access/index.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/index.html#brahe.AccessSearchConfig","title":"AccessSearchConfig","text":"<pre><code>AccessSearchConfig(initial_time_step: float, adaptive_step: bool, adaptive_fraction: float)\n</code></pre> <p>Configuration for access search grid parameters.</p> <p>Controls the time step and adaptive stepping behavior for access window finding.</p> <p>Parameters:</p> Name Type Description Default <code>initial_time_step</code> <code>float</code> <p>Initial time step in seconds for grid search (default: 60.0)</p> required <code>adaptive_step</code> <code>bool</code> <p>Enable adaptive stepping after first access (default: False)</p> required <code>adaptive_fraction</code> <code>float</code> <p>Fraction of orbital period to use for adaptive step (default: 0.75)</p> required Example <pre><code>import brahe as bh\n\n# Create a config with custom parameters\nconfig = bh.AccessSearchConfig(\n    initial_time_step=30.0,\n    adaptive_step=True,\n    adaptive_fraction=0.5\n)\n\n# Use config with location_accesses\nwindows = bh.location_accesses(\n    station, prop, search_start, search_end,\n    constraint, config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_fraction","title":"adaptive_fraction  <code>property</code>","text":"<pre><code>adaptive_fraction: float\n</code></pre> <p>Get the adaptive fraction (fraction of orbital period).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adaptive fraction</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_step","title":"adaptive_step  <code>property</code>","text":"<pre><code>adaptive_step: bool\n</code></pre> <p>Get whether adaptive stepping is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Adaptive stepping flag</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.initial_time_step","title":"initial_time_step  <code>property</code>","text":"<pre><code>initial_time_step: float\n</code></pre> <p>Get the initial time step in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Initial time step</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.num_threads","title":"num_threads  <code>property</code>","text":"<pre><code>num_threads: Optional[int]\n</code></pre> <p>Get the number of threads for parallel computation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Number of threads, or None to use global setting</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.parallel","title":"parallel  <code>property</code>","text":"<pre><code>parallel: bool\n</code></pre> <p>Get whether parallel computation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Parallel computation flag (default: True)</p>"},{"location":"library_api/access/index.html#threading-control","title":"Threading Control","text":""},{"location":"library_api/access/index.html#brahe.set_num_threads","title":"set_num_threads  <code>builtin</code>","text":"<pre><code>set_num_threads(n: int) -&gt; Any\n</code></pre> <p>Set the number of threads for parallel computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations such as access computations. This function can be called multiple times to dynamically change the thread pool configuration - each call will reinitialize the pool with the new thread count.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If n &lt; 1.</p> <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Set to 4 threads initially\nbh.set_num_threads(4)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 4\n\n# Reinitialize with 8 threads - no error!\nbh.set_num_threads(8)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 8\n\n# All parallel operations (e.g., location_accesses) will now use\n# 8 threads unless overridden with AccessSearchConfig.num_threads\n</code></pre> Note <p>Unlike earlier versions, this function no longer raises an error if the thread pool has already been initialized. You can safely call it at any time to reconfigure the thread pool.</p>"},{"location":"library_api/access/index.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads() -&gt; Any\n</code></pre> <p>Set the thread pool to use all available CPU cores.</p> <p>This is a convenience function that sets the number of threads to 100% of available CPU cores. Can be called multiple times to reinitialize the thread pool dynamically.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Use all available CPU cores\nbh.set_max_threads()\nprint(f\"Using all {bh.get_max_threads()} cores\")\n\n# Switch to 2 threads\nbh.set_num_threads(2)\n\n# Switch back to max - no error!\nbh.set_max_threads()\nprint(f\"Back to {bh.get_max_threads()} cores\")\n</code></pre> Note <p>This function can be called at any time, even after the thread pool has been initialized with a different configuration.</p>"},{"location":"library_api/access/index.html#brahe.set_ludicrous_speed","title":"set_ludicrous_speed  <code>builtin</code>","text":"<pre><code>set_ludicrous_speed() -&gt; Any\n</code></pre> <p>LUDICROUS SPEED! GO!</p> <p>Set the thread pool to use all available CPU cores (alias for <code>set_max_threads</code>).</p> <p>This is a fun alias for <code>set_max_threads()</code> that sets the number of threads to 100% of available CPU cores for maximum performance. Can be called multiple times to dynamically reinitialize the thread pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# MAXIMUM POWER! Use all available CPU cores\nbh.set_ludicrous_speed()\nprint(f\"Going ludicrous with {bh.get_max_threads()} threads!\")\n\n# Throttle down for testing\nbh.set_num_threads(1)\n\n# ENGAGE LUDICROUS SPEED again - no error!\nbh.set_ludicrous_speed()\n</code></pre> Note <p>This function can be called at any time to reconfigure the thread pool to use maximum available cores, regardless of previous configuration.</p>"},{"location":"library_api/access/index.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores, initialized on first call)\nthreads = bh.get_max_threads()\nprint(f\"Default: {threads} threads\")\n\n# Set to specific value and verify\nbh.set_num_threads(4)\nassert bh.get_max_threads() == 4\n\n# Reconfigure and verify again\nbh.set_num_threads(8)\nassert bh.get_max_threads() == 8\n\n# Switch to max cores\nbh.set_max_threads()\nprint(f\"Max cores: {bh.get_max_threads()}\")\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings (90% of cores) if it hasn't been configured yet. After initialization, you can still reconfigure it using set_num_threads() or set_max_threads().</p>"},{"location":"library_api/access/constraint_computer.html","title":"Custom Constraint Computer","text":"<p>The <code>AccessConstraintComputer</code> base class allows you to create custom constraint logic for access computation. Subclass this class and implement the <code>evaluate</code> and <code>name</code> methods to define custom constraints that can be combined with built-in constraints using logical operators.</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer","title":"AccessConstraintComputer","text":"<pre><code>AccessConstraintComputer(epoch: Epoch, satellite_state_ecef: ndarray, location_ecef: Union[ndarray, List])\n</code></pre> <p>Base class for custom access constraint computers.</p> <p>Subclass this class and implement the <code>evaluate</code> and <code>name</code> methods to create custom constraint logic that can be applied to access computation.</p> <p>The evaluate method is called at each time step during access search to determine if the constraint is satisfied. Return True if the constraint is satisfied (access is allowed), False otherwise.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass NorthernHemisphereConstraint(bh.AccessConstraintComputer):\n    '''Only allows access when satellite is in northern hemisphere.'''\n\n    def evaluate(self, epoch: bh.Epoch, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; bool:\n        '''\n        Args:\n            epoch (Epoch): Current evaluation time\n            satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef (ndarray or list): Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            bool: True if constraint is satisfied, False otherwise\n        '''\n        # Check if satellite Z-coordinate (ECEF) is positive (northern hemisphere)\n        return satellite_state_ecef[2] &gt;= 0.0\n\n    def name(self) -&gt; str:\n        '''Return name of this constraint.'''\n        return \"NorthernHemisphereConstraint\"\n\n# Use with access computation\ncustom_constraint = NorthernHemisphereConstraint()\n# Then combine with other constraints using ConstraintAll or ConstraintAny\n</code></pre> Notes <ul> <li>The <code>evaluate</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Return True to allow access, False to reject</li> <li>The constraint is checked at each time step during access search</li> <li>Custom constraints can be combined with built-in constraints using ConstraintAll/ConstraintAny</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, satellite_state_ecef: ndarray, location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Override this method in your subclass to implement custom constraint logic.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Current evaluation time</p> required <code>satellite_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied (access allowed), False otherwise</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Return name of this constraint computer.</p> <p>Override this method to return a descriptive name for your constraint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Constraint name</p>"},{"location":"library_api/access/constraints.html","title":"Constraints","text":"<p>Constraints define criteria that must be satisfied for satellite access.</p>"},{"location":"library_api/access/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"library_api/access/constraints.html#elevationconstraint","title":"ElevationConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint","title":"ElevationConstraint","text":"<pre><code>ElevationConstraint(min_elevation_deg: float | None, max_elevation_deg: float | None)\n</code></pre> <p>Elevation angle constraint for satellite visibility.</p> <p>Constrains access based on the elevation angle of the satellite above the local horizon at the ground location.</p> <p>Parameters:</p> Name Type Description Default <code>min_elevation_deg</code> <code>float | None</code> <p>Minimum elevation angle in degrees, or None for no minimum</p> required <code>max_elevation_deg</code> <code>float | None</code> <p>Maximum elevation angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None (unbounded constraint is meaningless)</p> Example <pre><code>import brahe as bh\n\n# Typical ground station constraint: 5\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\n\n# Both bounds specified\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\n\n# Only maximum (e.g., avoid zenith)\nconstraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint","title":"ElevationMaskConstraint","text":"<pre><code>ElevationMaskConstraint(mask: list[tuple[float, float]])\n</code></pre> <p>Azimuth-dependent elevation mask constraint.</p> <p>Constrains access based on azimuth-dependent elevation masks. Useful for ground stations with terrain obstructions or antenna limitations.</p> <p>The mask is defined as a list of (azimuth, elevation) pairs in degrees. Linear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>list[tuple[float, float]]</code> <p>List of (azimuth_deg, min_elevation_deg) pairs</p> required Example <pre><code>import brahe as bh\n\n# Ground station with terrain obstruction to the north\nmask = [\n    (0.0, 15.0),     # North: 15\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 5.0),    # South: 5\u00b0 minimum\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n]\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint","title":"OffNadirConstraint","text":"<pre><code>OffNadirConstraint(min_off_nadir_deg: float | None, max_off_nadir_deg: float | None)\n</code></pre> <p>Off-nadir angle constraint for satellite imaging.</p> <p>Constrains access based on the off-nadir angle (angle between the satellite's nadir vector and the line-of-sight to the location).</p> <p>Parameters:</p> Name Type Description Default <code>min_off_nadir_deg</code> <code>float | None</code> <p>Minimum off-nadir angle in degrees, or None for no minimum</p> required <code>max_off_nadir_deg</code> <code>float | None</code> <p>Maximum off-nadir angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None, or if any angle is negative</p> Example <pre><code>import brahe as bh\n\n# Imaging satellite with 45\u00b0 maximum slew angle\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\n\n# Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint","title":"LookDirectionConstraint","text":"<pre><code>LookDirectionConstraint(allowed: LookDirection)\n</code></pre> <p>Look direction constraint (left/right relative to velocity).</p> <p>Constrains access based on the look direction of the satellite relative to its velocity vector.</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>LookDirection</code> <p>Required look direction (LEFT, RIGHT, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Satellite can only look right\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Either direction is acceptable\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint","title":"LocalTimeConstraint","text":"<pre><code>LocalTimeConstraint(time_windows: list[tuple[int, int]])\n</code></pre> <p>Local solar time constraint.</p> <p>Constrains access based on the local solar time at the ground location. Useful for sun-synchronous orbits or daytime-only imaging.</p> <p>Time windows are specified in military time format (HHMM). Wrap-around windows (e.g., 2200-0200) are supported.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[int, int]]</code> <p>List of (start_military, end_military) tuples (0-2400)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any military time is invalid (&gt;2400 or minutes &gt;=60)</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\n\n# Two windows: morning (6-9 AM) and evening (4-7 PM)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\n\n# Overnight window (10 PM to 2 AM) - handles wrap-around\nconstraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.from_hours","title":"from_hours  <code>builtin</code>","text":"<pre><code>from_hours(time_windows: list[tuple[float, float]]) -&gt; LocalTimeConstraint\n</code></pre> <p>Create from decimal hour windows instead of military time.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[float, float]]</code> <p>List of (start_hour, end_hour) tuples [0, 24)</p> required <p>Returns:</p> Name Type Description <code>LocalTimeConstraint</code> <code>LocalTimeConstraint</code> <p>The constraint instance</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint.from_hours([(6.0, 18.0)])\n\n# Overnight window (10 PM to 2 AM)\nconstraint = bh.LocalTimeConstraint.from_hours([(22.0, 2.0)])\n</code></pre>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#ascdscconstraint","title":"AscDscConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint","title":"AscDscConstraint","text":"<pre><code>AscDscConstraint(allowed: AscDsc)\n</code></pre> <p>Ascending/descending pass constraint.</p> <p>Constrains access based on whether the satellite is on an ascending or descending pass (moving north or south).</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>AscDsc</code> <p>Required pass type (ASCENDING, DESCENDING, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Either type is acceptable\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#logical-composition","title":"Logical Composition","text":""},{"location":"library_api/access/constraints.html#constraintall","title":"ConstraintAll","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAll","title":"ConstraintAll","text":"<pre><code>ConstraintAll(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with AND logic.</p> <p>All constraints must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with AND logic</p> required Example <pre><code>import brahe as bh\n\n# Ground station with multiple requirements\nelev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\ncombined = bh.ConstraintAll(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ALL constraints are satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintany","title":"ConstraintAny","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAny","title":"ConstraintAny","text":"<pre><code>ConstraintAny(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with OR logic.</p> <p>At least one constraint must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with OR logic</p> required Example <pre><code>import brahe as bh\n\n# Accept either high elevation or specific time window\nelev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\ncombined = bh.ConstraintAny(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if AT LEAST ONE constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintnot","title":"ConstraintNot","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintNot","title":"ConstraintNot","text":"<pre><code>ConstraintNot(constraint: object)\n</code></pre> <p>Composite constraint negating another constraint with NOT logic.</p> <p>The negated constraint must NOT be satisfied for this to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>object</code> <p>Constraint object to negate</p> required Example <pre><code>import brahe as bh\n\n# Avoid low elevation angles (i.e., require high elevation)\nlow_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\nhigh_elev = bh.ConstraintNot(constraint=low_elev)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the negated constraint is NOT satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/enums.html","title":"Access Enumerations","text":"<p>Enumeration types used in access computation.</p>"},{"location":"library_api/access/enums.html#lookdirection","title":"LookDirection","text":""},{"location":"library_api/access/enums.html#brahe.LookDirection","title":"LookDirection","text":"<pre><code>LookDirection()\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <code>Any</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <code>Any</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <code>Any</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = LookDirection.Either\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.LEFT","title":"LEFT  <code>class-attribute</code>","text":"<pre><code>LEFT: Any = LookDirection.Left\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.RIGHT","title":"RIGHT  <code>class-attribute</code>","text":"<pre><code>RIGHT: Any = LookDirection.Right\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#ascdsc","title":"AscDsc","text":""},{"location":"library_api/access/enums.html#brahe.AscDsc","title":"AscDsc","text":"<pre><code>AscDsc()\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>Any</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <code>Any</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <code>Any</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.ASCENDING","title":"ASCENDING  <code>class-attribute</code>","text":"<pre><code>ASCENDING: Any = AscDsc.Ascending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.DESCENDING","title":"DESCENDING  <code>class-attribute</code>","text":"<pre><code>DESCENDING: Any = AscDsc.Descending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = AscDsc.Either\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/locations.html","title":"Locations","text":"<p>Location types represent ground positions or areas that satellites can access.</p>"},{"location":"library_api/access/locations.html#pointlocation","title":"PointLocation","text":""},{"location":"library_api/access/locations.html#brahe.PointLocation","title":"PointLocation","text":"<pre><code>PointLocation(lon: float, lat: float, alt: float)\n</code></pre> <p>A single point location on Earth's surface.</p> <p>Represents a discrete point with geodetic coordinates (longitude, latitude, altitude). Commonly used for ground stations, imaging targets, or tessellated polygon tiles.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude in degrees (-180 to 180)</p> required <code>lat</code> <code>float</code> <p>Latitude in degrees (-90 to 90)</p> required <code>alt</code> <code>float</code> <p>Altitude above ellipsoid in meters (default: 0.0)</p> required Example <pre><code>import brahe as bh\n\n# Create a ground station in Svalbard\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\n\n# With identity\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard Ground Station\") \\\\\n    .with_id(1)\n\n# With custom properties\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"min_elevation_deg\", 5.0)\n\n# Access coordinates as properties\nlon = svalbard.lon  # Property (always degrees)\nlat = svalbard.lat  # Property (always degrees)\nlat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nprint(loc.properties[\"climate\"])  # \"Arctic\"\n\n# Dict methods\nif \"country\" in loc.properties:\n    del loc.properties[\"country\"]\n\n# Iteration\nfor key in loc.properties.keys():\n    print(key, loc.properties[key])\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation._get_properties_dict","title":"_get_properties_dict  <code>method descriptor</code>","text":"<pre><code>_get_properties_dict()\n</code></pre> <p>Internal method: Get properties as a plain Python dict.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation._remove_property","title":"_remove_property  <code>method descriptor</code>","text":"<pre><code>_remove_property(key)\n</code></pre> <p>Internal method: Remove a property.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation._set_property","title":"_set_property  <code>method descriptor</code>","text":"<pre><code>_set_property(key, json_str)\n</code></pre> <p>Internal method: Set a property value.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value: Any) -&gt; PointLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <code>Any</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"elevation_mask_deg\", 5.0)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PointLocation\n</code></pre> <p>Create from GeoJSON Point Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Point geometry</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>New location instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Point Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 0.0]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\"\n    }\n}\n\nlocation = bh.PointLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard\")\n\ngeojson = location.to_geojson()\n# Returns:\n# {\n#     \"type\": \"Feature\",\n#     \"geometry\": {\n#         \"type\": \"Point\",\n#         \"coordinates\": [15.4, 78.2, 0.0]\n#     },\n#     \"properties\": {\n#         \"name\": \"Svalbard\"\n#     }\n# }\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PointLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PointLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PointLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PointLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/locations.html#polygonlocation","title":"PolygonLocation","text":""},{"location":"library_api/access/locations.html#brahe.PolygonLocation","title":"PolygonLocation","text":"<pre><code>PolygonLocation(vertices: list[list[float]])\n</code></pre> <p>A polygonal area on Earth's surface.</p> <p>Represents a closed polygon with multiple vertices. Commonly used for areas of interest, no-fly zones, or imaging footprints.</p> <p>The polygon is automatically closed if the first and last vertices don't match.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[list[float]]</code> <p>List of [lon, lat, alt] vertices in degrees and meters</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If polygon has fewer than 4 vertices or has validation errors</p> Example <pre><code>import brahe as bh\n\n# Define a rectangular area\nvertices = [\n    [10.0, 50.0, 0.0],  # lon, lat, alt\n    [11.0, 50.0, 0.0],\n    [11.0, 51.0, 0.0],\n    [10.0, 51.0, 0.0],\n    [10.0, 50.0, 0.0],  # Closed (first == last)\n]\npolygon = bh.PolygonLocation(vertices)\n\n# With identity\npolygon = bh.PolygonLocation(vertices) \\\\\n    .with_name(\"AOI-1\") \\\\\n    .add_property(\"region\", \"Europe\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get center latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get center longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.num_vertices","title":"num_vertices  <code>property</code>","text":"<pre><code>num_vertices: int\n</code></pre> <p>Get number of unique vertices (excluding closure).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of unique vertices</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nverts = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]\npoly = bh.PolygonLocation(verts)\n\n# Dict-style assignment\npoly.properties[\"region\"] = \"Test Area\"\npoly.properties[\"area_km2\"] = 123.45\n\n# Dict-style access\nprint(poly.properties[\"region\"])  # \"Test Area\"\n\n# Dict methods\nif \"area_km2\" in poly.properties:\n    del poly.properties[\"area_km2\"]\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.vertices","title":"vertices  <code>property</code>","text":"<pre><code>vertices: ndarray\n</code></pre> <p>Get polygon vertices.</p> <p>Returns all vertices including the closure vertex (first == last).</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Vertices as Nx3 array [[lon, lat, alt], ...]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._get_properties_dict","title":"_get_properties_dict  <code>method descriptor</code>","text":"<pre><code>_get_properties_dict()\n</code></pre> <p>Internal method: Get properties as a plain Python dict.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._remove_property","title":"_remove_property  <code>method descriptor</code>","text":"<pre><code>_remove_property(key)\n</code></pre> <p>Internal method: Remove a property.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._set_property","title":"_set_property  <code>method descriptor</code>","text":"<pre><code>_set_property(key, json_str)\n</code></pre> <p>Internal method: Set a property value.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value: Any) -&gt; PolygonLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <code>Any</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PolygonLocation\n</code></pre> <p>Create from GeoJSON Polygon Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Polygon geometry</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>New polygon instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Polygon Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\"\n    }\n}\n\npolygon = bh.PolygonLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PolygonLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PolygonLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PolygonLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PolygonLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/properties.html","title":"Property Computers","text":"<p>Property computers calculate additional measurements for access windows beyond basic visibility timing.</p>"},{"location":"library_api/access/properties.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/properties.html#samplingconfig","title":"SamplingConfig","text":""},{"location":"library_api/access/properties.html#brahe.SamplingConfig","title":"SamplingConfig","text":"<pre><code>SamplingConfig()\n</code></pre> <p>Sampling configuration for access property computation.</p> <p>Determines how many times and when to sample satellite states during an access window for property calculations.</p> Example <pre><code>import brahe as bh\n\n# Sample at start, middle, and end\nconfig = bh.SamplingConfig.relative_points([0.0, 0.5, 1.0])\n\n# Sample every 0.1 seconds\nconfig = bh.SamplingConfig.fixed_interval(0.1, 0.0)\n\n# Sample at 10 evenly-spaced points\nconfig = bh.SamplingConfig.fixed_count(10)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.fixed_count","title":"fixed_count  <code>staticmethod</code>","text":"<pre><code>fixed_count(count: int) -&gt; SamplingConfig\n</code></pre> <p>Create a fixed count sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of evenly-spaced sample points (including endpoints)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Fixed count sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample at 10 evenly-spaced points\nconfig = bh.SamplingConfig.fixed_count(10)\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.fixed_interval","title":"fixed_interval  <code>staticmethod</code>","text":"<pre><code>fixed_interval(interval: float, offset: float) -&gt; SamplingConfig\n</code></pre> <p>Create a fixed interval sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Time between samples (seconds)</p> required <code>offset</code> <code>float</code> <p>Time offset from window start (seconds)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Fixed interval sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample every 0.1 seconds, starting at window open\nconfig = bh.SamplingConfig.fixed_interval(0.1, 0.0)\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.midpoint","title":"midpoint  <code>staticmethod</code>","text":"<pre><code>midpoint() -&gt; SamplingConfig\n</code></pre> <p>Create a midpoint sampling configuration (single sample at window center).</p> <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Midpoint sampling configuration</p> Example <pre><code>import brahe as bh\nconfig = bh.SamplingConfig.midpoint()\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.relative_points","title":"relative_points  <code>staticmethod</code>","text":"<pre><code>relative_points(relative_times: list[float]) -&gt; SamplingConfig\n</code></pre> <p>Create a relative points sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>relative_times</code> <code>list[float]</code> <p>Relative times from 0.0 (window start) to 1.0 (window end)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Relative points sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample at start, quarter, middle, three-quarters, and end\nconfig = bh.SamplingConfig.relative_points([0.0, 0.25, 0.5, 0.75, 1.0])\n</code></pre>"},{"location":"library_api/access/properties.html#built-in-computers","title":"Built-in Computers","text":""},{"location":"library_api/access/properties.html#dopplercomputer","title":"DopplerComputer","text":""},{"location":"library_api/access/properties.html#brahe.DopplerComputer","title":"DopplerComputer","text":"<pre><code>DopplerComputer()\n</code></pre> <p>Computes Doppler shift during access windows.</p> <p>Calculates uplink and/or downlink Doppler shifts based on satellite velocity and line-of-sight geometry.</p> Example <pre><code>import brahe as bh\n\n# Doppler for GPS L1 downlink\nconfig = bh.SamplingConfig.midpoint()\ncomputer = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=1.57542e9,  # Hz\n    sampling_config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#rangecomputer","title":"RangeComputer","text":""},{"location":"library_api/access/properties.html#brahe.RangeComputer","title":"RangeComputer","text":"<pre><code>RangeComputer()\n</code></pre> <p>Computes range (distance) during access windows.</p> <p>Calculates the distance between satellite and ground location.</p> Example <pre><code>import brahe as bh\n\nconfig = bh.SamplingConfig.fixed_interval(0.1 / 86400.0, 0.0)\ncomputer = bh.RangeComputer(config)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#rangeratecomputer","title":"RangeRateComputer","text":""},{"location":"library_api/access/properties.html#brahe.RangeRateComputer","title":"RangeRateComputer","text":"<pre><code>RangeRateComputer()\n</code></pre> <p>Computes range rate (radial velocity) during access windows.</p> <p>Calculates the rate of change of distance between satellite and ground location.</p> Example <pre><code>import brahe as bh\n\nconfig = bh.SamplingConfig.fixed_interval(0.1 / 86400.0, 0.0)\ncomputer = bh.RangeRateComputer(config)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#custom-property-computers","title":"Custom Property Computers","text":""},{"location":"library_api/access/properties.html#accesspropertycomputer","title":"AccessPropertyComputer","text":""},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer","title":"AccessPropertyComputer","text":"<pre><code>AccessPropertyComputer(window: AccessWindow, sample_epochs: ndarray, sample_states_ecef: ndarray, location_ecef: Union[ndarray, List], location_geodetic: Union[ndarray, List])\n</code></pre> <p>Base class for custom access property computers.</p> <p>Subclass this class and implement the <code>compute</code> and <code>property_names</code> methods to create custom property calculations that can be applied to access windows.</p> <p>The compute method is called for each access window and should return a dictionary of property names to values. Properties can be scalars, vectors, time series, booleans, strings, or any JSON-serializable value.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    '''Computes Doppler shift time series during access windows.'''\n\n    def sampling_config(self) -&gt; bh.SamplingConfig:\n        '''Configure sampling at 1 Hz during access windows.'''\n        return bh.SamplingConfig.fixed_interval(1.0, 0.0)\n\n    def compute(\n        self,\n        window: bh.AccessWindow,\n        sample_epochs: np.ndarray,\n        sample_states_ecef: np.ndarray,\n        location_ecef: np.ndarray,\n        location_geodetic: np.ndarray\n    ) -&gt; dict:\n        '''\n        Args:\n            window (AccessWindow): AccessWindow with timing information\n            sample_epochs (ndarray): Sample epochs in MJD [N]\n            sample_states_ecef (ndarray): Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef (ndarray or list): Location position [x,y,z] in ECEF (m)\n            location_geodetic (ndarray or list): Location geodetic [lon,lat,alt] (deg, deg, m)\n\n        Returns:\n            dict: Property name -&gt; value (scalar, list, or dict for time series)\n        '''\n        # Compute Doppler shift at each sample\n        doppler_values = []\n        for state in sample_states_ecef:\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Line-of-sight vector\n            los = sat_pos - location_ecef\n            los_unit = los / np.linalg.norm(los)\n\n            # Radial velocity\n            radial_velocity = np.dot(sat_vel, los_unit)\n\n            # Doppler shift (L-band)\n            freq_hz = 1.57542e9  # GPS L1\n            doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\n            doppler_values.append(doppler_hz)\n\n        # Return time series\n        return {\n            \"doppler_shift\": {\n                \"times\": sample_epochs.tolist(),\n                \"values\": doppler_values\n            }\n        }\n\n    def property_names(self) -&gt; list:\n        '''Return list of property names this computer produces.'''\n        return [\"doppler_shift\"]\n\n# Use with access computation (future)\ncomputer = DopplerComputer()\n# accesses = bh.compute_accesses(..., property_computers=[computer])\n</code></pre> Notes <ul> <li>The <code>compute</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Property values are automatically converted to appropriate Rust types</li> <li>The window parameter provides access to timing via:</li> <li><code>window.window_open</code>: Start epoch</li> <li><code>window.window_close</code>: End epoch</li> <li><code>window.midtime()</code>: Midpoint epoch</li> <li><code>window.duration()</code>: Duration in seconds</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(window: AccessWindow, sample_epochs: ndarray, sample_states_ecef: ndarray, location_ecef: Union[ndarray, List], location_geodetic: Union[ndarray, List]) -&gt; dict\n</code></pre> <p>Compute custom properties for an access window.</p> <p>Override this method in your subclass to implement custom property calculations.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>AccessWindow</code> <p>Access window with timing information</p> required <code>sample_epochs</code> <code>ndarray</code> <p>Sample epochs in MJD (Modified Julian Date)</p> required <code>sample_states_ecef</code> <code>ndarray</code> <p>Satellite states in ECEF (N x 6) [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <code>location_geodetic</code> <code>ndarray or list</code> <p>Location geodetic coordinates [lon,lat,alt] (radians, meters)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping property names (str) to values (scalar, list, dict, etc.)</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.property_names","title":"property_names  <code>method descriptor</code>","text":"<pre><code>property_names() -&gt; list[str]\n</code></pre> <p>Return list of property names this computer will produce.</p> <p>Override this method to return the list of property names that your compute() method will include in its returned dictionary.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of property names</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.sampling_config","title":"sampling_config  <code>method descriptor</code>","text":"<pre><code>sampling_config() -&gt; SamplingConfig\n</code></pre> <p>Return sampling configuration for this property computer.</p> <p>Override this method to specify how you want the satellite states to be sampled during the access window.</p> <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>The sampling configuration</p> Example <pre><code>import brahe as bh\n\nclass MyComputer(bh.AccessPropertyComputer):\n    def sampling_config(self) -&gt; bh.SamplingConfig:\n        return bh.SamplingConfig.midpoint()\n</code></pre>"},{"location":"library_api/access/properties.html#property-storage","title":"Property Storage","text":""},{"location":"library_api/access/properties.html#propertiesdict","title":"PropertiesDict","text":""},{"location":"library_api/access/properties.html#brahe.PropertiesDict","title":"PropertiesDict","text":"<pre><code>PropertiesDict()\n</code></pre> <p>A dictionary-like wrapper for Location properties that supports dict-style assignment.</p> <p>This class provides a Pythonic dict interface for accessing and modifying location properties. Changes are automatically synchronized with the underlying Location object.</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nclimate = loc.properties[\"climate\"]\n\n# Dict methods work\nif \"country\" in loc.properties:\n    print(loc.properties[\"country\"])\n\n# Iteration\nfor key in loc.properties:\n    print(key, loc.properties[key])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all properties.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get property value with optional default.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>default</code> <code>optional</code> <p>Value to return if key not found</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Property value if key exists, otherwise default value</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.items","title":"items  <code>method descriptor</code>","text":"<pre><code>items() -&gt; List\n</code></pre> <p>Return a list of (key, value) tuples.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of (key, value) tuples</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.keys","title":"keys  <code>method descriptor</code>","text":"<pre><code>keys() -&gt; List\n</code></pre> <p>Return a list of property keys.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of property key strings</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.update","title":"update  <code>method descriptor</code>","text":"<pre><code>update(other: dict) -&gt; None\n</code></pre> <p>Update properties from another dict.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict</code> <p>Dictionary to merge into properties</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.values","title":"values  <code>method descriptor</code>","text":"<pre><code>values() -&gt; List\n</code></pre> <p>Return a list of property values.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of property values</p>"},{"location":"library_api/access/windows.html","title":"Access Windows","text":"<p>Access windows represent time periods when satellites can access ground locations.</p>"},{"location":"library_api/access/windows.html#accesswindow","title":"AccessWindow","text":""},{"location":"library_api/access/windows.html#brahe.AccessWindow","title":"AccessWindow","text":"<pre><code>AccessWindow(window_open: Epoch, window_close: Epoch)\n</code></pre> <p>An access window representing a period of time when access constraints are satisfied.</p> <p>AccessWindow stores the opening and closing times of an access period, along with computed properties for that window.</p> <p>Parameters:</p> Name Type Description Default <code>window_open</code> <code>Epoch</code> <p>Opening time of the access window</p> required <code>window_close</code> <code>Epoch</code> <p>Closing time of the access window</p> required Example <pre><code>import brahe as bh\n\n# Create an access window\nt_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\nt_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\nwindow = bh.AccessWindow(t_open, t_close)\n\n# Access window properties\nprint(f\"Duration: {window.duration()} seconds\")\nprint(f\"Midpoint: {window.midtime()}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: AscDsc\n</code></pre> <p>Get ascending/descending pass type.</p> <p>Returns:</p> Name Type Description <code>AscDsc</code> <code>AscDsc</code> <p>Pass type enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: float\n</code></pre> <p>Get azimuth angle at window closing (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: float\n</code></pre> <p>Get azimuth angle at window opening (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_alt","title":"center_alt  <code>property</code>","text":"<pre><code>center_alt: float\n</code></pre> <p>Get location center altitude (meters).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_ecef","title":"center_ecef  <code>property</code>","text":"<pre><code>center_ecef: list[float]\n</code></pre> <p>Get location center ECEF coordinates (meters).</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: ECEF coordinates [x, y, z] in meters</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_lat","title":"center_lat  <code>property</code>","text":"<pre><code>center_lat: float\n</code></pre> <p>Get location center latitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_lon","title":"center_lon  <code>property</code>","text":"<pre><code>center_lon: float\n</code></pre> <p>Get location center longitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Get the duration of the access window in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Duration in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_close","title":"elevation_close  <code>property</code>","text":"<pre><code>elevation_close: float\n</code></pre> <p>Get elevation angle at window closing (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Elevation at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: float\n</code></pre> <p>Get maximum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: float\n</code></pre> <p>Get minimum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_open","title":"elevation_open  <code>property</code>","text":"<pre><code>elevation_open: float\n</code></pre> <p>Get elevation angle at window opening (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Elevation at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.end","title":"end  <code>property</code>","text":"<pre><code>end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[int]\n</code></pre> <p>Get the access window numeric ID.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Window ID, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: float\n</code></pre> <p>Get local solar time at window midpoint (seconds since midnight, 0-86400).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Local time in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_id","title":"location_id  <code>property</code>","text":"<pre><code>location_id: Optional[int]\n</code></pre> <p>Get the location ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_name","title":"location_name  <code>property</code>","text":"<pre><code>location_name: Optional[str]\n</code></pre> <p>Get the location name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_uuid","title":"location_uuid  <code>property</code>","text":"<pre><code>location_uuid: Optional[str]\n</code></pre> <p>Get the location UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the location as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: LookDirection\n</code></pre> <p>Get look direction (Left or Right).</p> <p>Returns:</p> Name Type Description <code>LookDirection</code> <code>LookDirection</code> <p>Look direction enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.midtime","title":"midtime  <code>property</code>","text":"<pre><code>midtime: Epoch\n</code></pre> <p>Get the midpoint time of the access window.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Midpoint time (average of start and end)</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>Get the access window name (auto-generated or user-set).</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Window name, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: float\n</code></pre> <p>Get maximum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: float\n</code></pre> <p>Get minimum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: AccessProperties\n</code></pre> <p>Get the access properties object.</p> <p>Returns:</p> Name Type Description <code>AccessProperties</code> <code>AccessProperties</code> <p>Computed properties for this access window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_id","title":"satellite_id  <code>property</code>","text":"<pre><code>satellite_id: Optional[int]\n</code></pre> <p>Get the satellite/object ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: Optional[str]\n</code></pre> <p>Get the satellite/object name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_uuid","title":"satellite_uuid  <code>property</code>","text":"<pre><code>satellite_uuid: Optional[str]\n</code></pre> <p>Get the satellite UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the satellite as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.start","title":"start  <code>property</code>","text":"<pre><code>start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.t_end","title":"t_end  <code>property</code>","text":"<pre><code>t_end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close/end).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.t_start","title":"t_start  <code>property</code>","text":"<pre><code>t_start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open/start).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: Optional[str]\n</code></pre> <p>Get the access window UUID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_close","title":"window_close  <code>property</code>","text":"<pre><code>window_close: Epoch\n</code></pre> <p>Get the window closing time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window closing time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_open","title":"window_open  <code>property</code>","text":"<pre><code>window_open: Epoch\n</code></pre> <p>Get the window opening time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window opening time</p>"},{"location":"library_api/access/windows.html#accessproperties","title":"AccessProperties","text":""},{"location":"library_api/access/windows.html#brahe.AccessProperties","title":"AccessProperties","text":"<pre><code>AccessProperties()\n</code></pre> <p>Properties computed for an access window.</p> <p>AccessProperties contains geometric properties (azimuth, elevation, off-nadir angles, local time, look direction, ascending/descending) computed over an access window, plus location coordinates, plus a dictionary of additional custom properties.</p> <p>Attributes:</p> Name Type Description <code>azimuth_open</code> <code>float</code> <p>Azimuth angle at window opening (degrees, 0-360)</p> <code>azimuth_close</code> <code>float</code> <p>Azimuth angle at window closing (degrees, 0-360)</p> <code>elevation_min</code> <code>float</code> <p>Minimum elevation angle (degrees)</p> <code>elevation_max</code> <code>float</code> <p>Maximum elevation angle (degrees)</p> <code>elevation_open</code> <code>float</code> <p>Elevation angle at window opening (degrees)</p> <code>elevation_close</code> <code>float</code> <p>Elevation angle at window closing (degrees)</p> <code>off_nadir_min</code> <code>float</code> <p>Minimum off-nadir angle (degrees)</p> <code>off_nadir_max</code> <code>float</code> <p>Maximum off-nadir angle (degrees)</p> <code>local_time</code> <code>float</code> <p>Local solar time (seconds since midnight, 0-86400)</p> <code>look_direction</code> <code>LookDirection</code> <p>Required look direction (Left or Right)</p> <code>asc_dsc</code> <code>AscDsc</code> <p>Pass type (Ascending or Descending)</p> <code>center_lon</code> <code>float</code> <p>Location center longitude (degrees)</p> <code>center_lat</code> <code>float</code> <p>Location center latitude (degrees)</p> <code>center_alt</code> <code>float</code> <p>Location center altitude (meters)</p> <code>center_ecef</code> <code>list[float]</code> <p>Location center ECEF coordinates [x, y, z] (meters)</p> Example <pre><code>import brahe as bh\n\n# Access properties are typically computed by the access computation system\n# This example shows accessing the properties\nprops = ...  # From access computation\n\nprint(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\nprint(f\"Max elevation: {props.elevation_max}\u00b0\")\nprint(f\"Look direction: {props.look_direction}\")\n\n# Access additional custom properties\nif \"signal_strength\" in props.additional:\n    print(f\"Signal: {props.additional['signal_strength']}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.additional","title":"additional  <code>property</code>","text":"<pre><code>additional: AdditionalPropertiesDict\n</code></pre> <p>Get additional properties as a dict-like wrapper.</p> <p>Returns a dictionary-like object that automatically converts between Python types and internal PropertyValue representation.</p> <p>Supported Python types: - float -&gt; Scalar - list[float] -&gt; Vector - bool -&gt; Boolean - str -&gt; String - dict -&gt; Json</p> <p>Returns:</p> Name Type Description <code>AdditionalPropertiesDict</code> <code>AdditionalPropertiesDict</code> <p>Dict-like wrapper for additional properties</p> Example <pre><code># Dict-style assignment\nprops.additional[\"doppler_shift\"] = 2500.0\nprops.additional[\"snr_values\"] = [10.5, 12.3, 15.1]\nprops.additional[\"has_eclipse\"] = False\n\n# Dict-style access\nprint(props.additional[\"doppler_shift\"])  # 2500.0\n\n# Dict methods\nif \"doppler_shift\" in props.additional:\n    del props.additional[\"doppler_shift\"]\n\n# Iteration\nfor key in props.additional.keys():\n    print(key, props.additional[key])\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_alt","title":"center_alt  <code>property</code>","text":"<pre><code>center_alt: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_ecef","title":"center_ecef  <code>property</code>","text":"<pre><code>center_ecef: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_lat","title":"center_lat  <code>property</code>","text":"<pre><code>center_lat: float\n</code></pre> <p>Get location center latitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_lon","title":"center_lon  <code>property</code>","text":"<pre><code>center_lon: float\n</code></pre> <p>Get location center longitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_close","title":"elevation_close  <code>property</code>","text":"<pre><code>elevation_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_open","title":"elevation_open  <code>property</code>","text":"<pre><code>elevation_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: Any\n</code></pre>"},{"location":"library_api/attitude/index.html","title":"Attitude","text":"<p>Module: <code>brahe.attitude</code></p> <p>Classes for representing and converting between different attitude representations.</p>"},{"location":"library_api/attitude/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Quaternion - Quaternion representation</li> <li>Rotation Matrix - Direction Cosine Matrix (DCM) representation</li> <li>Euler Angles - Euler angle sequences</li> <li>Euler Axis - Euler axis-angle representation</li> </ul>"},{"location":"library_api/attitude/euler_angle_order.html","title":"EulerAngleOrder Enum","text":"<p>The <code>EulerAngleOrder</code> enumeration specifies the rotation sequence for Euler angle representations. There are 12 possible sequences: 6 symmetric sequences where the first and third rotations are about the same axis, and 6 asymmetric sequences where all rotations are about different axes.</p>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder","title":"EulerAngleOrder","text":"<pre><code>EulerAngleOrder()\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <code>Any</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <code>Any</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <code>Any</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <code>Any</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <code>Any</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <code>Any</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <code>Any</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <code>Any</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <code>Any</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <code>Any</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <code>Any</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <code>Any</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XYX","title":"XYX  <code>class-attribute</code>","text":"<pre><code>XYX: Any = EulerAngleOrder.XYX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XYZ","title":"XYZ  <code>class-attribute</code>","text":"<pre><code>XYZ: Any = EulerAngleOrder.XYZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XZX","title":"XZX  <code>class-attribute</code>","text":"<pre><code>XZX: Any = EulerAngleOrder.XZX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XZY","title":"XZY  <code>class-attribute</code>","text":"<pre><code>XZY: Any = EulerAngleOrder.XZY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YXY","title":"YXY  <code>class-attribute</code>","text":"<pre><code>YXY: Any = EulerAngleOrder.YXY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YXZ","title":"YXZ  <code>class-attribute</code>","text":"<pre><code>YXZ: Any = EulerAngleOrder.YXZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YZX","title":"YZX  <code>class-attribute</code>","text":"<pre><code>YZX: Any = EulerAngleOrder.YZX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YZY","title":"YZY  <code>class-attribute</code>","text":"<pre><code>YZY: Any = EulerAngleOrder.YZY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZXY","title":"ZXY  <code>class-attribute</code>","text":"<pre><code>ZXY: Any = EulerAngleOrder.ZXY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZXZ","title":"ZXZ  <code>class-attribute</code>","text":"<pre><code>ZXZ: Any = EulerAngleOrder.ZXZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZYX","title":"ZYX  <code>class-attribute</code>","text":"<pre><code>ZYX: Any = EulerAngleOrder.ZYX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZYZ","title":"ZYZ  <code>class-attribute</code>","text":"<pre><code>ZYZ: Any = EulerAngleOrder.ZYZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html","title":"EulerAngle Class","text":"<p>The <code>EulerAngle</code> class represents attitude using Euler angle sequences for intuitive spacecraft orientation specification.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle","title":"EulerAngle","text":"<pre><code>EulerAngle(order: str, phi: float, theta: float, psi: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler angles.</p> <p>Euler angles describe rotations as a sequence of three rotations about specified axes. The rotation sequence is specified by the order parameter (e.g., \"XYZ\", \"ZYX\").</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")</p> required <code>phi</code> <code>float</code> <p>First rotation angle in radians or degrees</p> required <code>theta</code> <code>float</code> <p>Second rotation angle in radians or degrees</p> required <code>psi</code> <code>float</code> <p>Third rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\n\n# Create Euler angle rotation (roll, pitch, yaw in ZYX order)\ne = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n\n# Convert to rotation matrix\ndcm = e.to_rotation_matrix()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.order","title":"order  <code>property</code>","text":"<pre><code>order: EulerAngleOrder\n</code></pre> <p>Get the rotation sequence order.</p> <p>Returns:</p> Name Type Description <code>EulerAngleOrder</code> <code>EulerAngleOrder</code> <p>Rotation sequence enum value</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Order: {e.order}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.phi","title":"phi  <code>property</code>","text":"<pre><code>phi: float\n</code></pre> <p>Get the first rotation angle (phi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Phi: {e.phi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.psi","title":"psi  <code>property</code>","text":"<pre><code>psi: float\n</code></pre> <p>Get the third rotation angle (psi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Third rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Psi: {e.psi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.theta","title":"theta  <code>property</code>","text":"<pre><code>theta: float\n</code></pre> <p>Get the second rotation angle (theta) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Theta: {e.theta}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from another Euler angle with different order.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Source Euler angles</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAngle.from_euler_angle(e1, \"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = bh.EulerAngle.from_euler_axis(ea, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAngle.from_quaternion(q, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAngle.from_rotation_matrix(r, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, order: str, angle_format: AngleFormat) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>3-element array [phi, theta, psi]</p> required <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>New Euler angle instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.1, 0.2, 0.3])\neuler = bh.EulerAngle.from_vector(v, \"XYZ\", bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angles with different rotation sequence.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_angle(\"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nea = e.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html","title":"EulerAxis Class","text":"<p>The <code>EulerAxis</code> class represents attitude using axis-angle representation (Euler's rotation theorem).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis","title":"EulerAxis","text":"<pre><code>EulerAxis(axis: ndarray, angle: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler axis-angle representation.</p> <p>The Euler axis-angle representation describes a rotation as a single rotation about a specified axis by a given angle. This is also known as the axis-angle or rotation vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>3-element unit vector specifying rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Rotation of 90 degrees about z-axis\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle} rad\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.angle","title":"angle  <code>property</code>","text":"<pre><code>angle: float\n</code></pre> <p>Get the rotation angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rotation angle in radians</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.axis","title":"axis  <code>property</code>","text":"<pre><code>axis: ndarray\n</code></pre> <p>Get the rotation axis as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3-element unit vector specifying rotation axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Axis: {e.axis}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne = bh.EulerAxis.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from another Euler axis (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Source Euler axis</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAxis.from_euler_axis(e1)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAxis.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAxis.from_rotation_matrix(r)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(x: float, y: float, z: float, angle: float, angle_format: AngleFormat) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from individual axis components and angle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X component of rotation axis</p> required <code>y</code> <code>float</code> <p>Y component of rotation axis</p> required <code>z</code> <code>float</code> <p>Z component of rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAxis.from_values(0.0, 0.0, 1.0, 1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, angle_format: AngleFormat, vector_first: bool) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing axis and angle</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, array is [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.0, 0.0, 1.0, 1.5708])\ne = bh.EulerAxis.from_vector(v, bh.AngleFormat.RADIANS, True)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = ea.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation (returns self).</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>This Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(angle_format: AngleFormat, vector_first: bool) -&gt; ndarray\n</code></pre> <p>Convert Euler axis to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Units for output angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, returns [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing axis and angle</p>"},{"location":"library_api/attitude/quaternion.html","title":"Quaternion Class","text":"<p>The <code>Quaternion</code> class provides a compact, singularity-free representation of 3D rotations for spacecraft attitude determination and control.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(w: float, x: float, y: float, z: float)\n</code></pre> <p>Represents a quaternion for 3D rotations.</p> <p>Quaternions provide a compact, singularity-free representation of rotations. The quaternion is stored as [w, x, y, z] where w is the scalar part and [x, y, z] is the vector part.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Scalar component</p> required <code>x</code> <code>float</code> <p>X component of vector part</p> required <code>y</code> <code>float</code> <p>Y component of vector part</p> required <code>z</code> <code>float</code> <p>Z component of vector part</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity quaternion\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nprint(f\"Norm: {q.norm()}\")\n\n# Create from array\nq_vec = np.array([1.0, 0.0, 0.0, 0.0])\nq2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\n\n# Convert to rotation matrix\ndcm = q.to_rotation_matrix()\n\n# Quaternion multiplication\nq3 = q * q2\n\n# Normalize\nq3.normalize()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the quaternion components as a numpy array [w, x, y, z].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.w","title":"w  <code>property</code>","text":"<pre><code>w: float\n</code></pre> <p>Get the scalar (w) component of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Scalar component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.x","title":"x  <code>property</code>","text":"<pre><code>x: float\n</code></pre> <p>Get the x component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>X component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.y","title":"y  <code>property</code>","text":"<pre><code>y: float\n</code></pre> <p>Get the y component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Y component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.z","title":"z  <code>property</code>","text":"<pre><code>z: float\n</code></pre> <p>Get the z component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Z component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.conjugate","title":"conjugate  <code>method descriptor</code>","text":"<pre><code>conjugate() -&gt; Quaternion\n</code></pre> <p>Compute the conjugate of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Conjugate quaternion with negated vector part</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_conj = q.conjugate()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from another quaternion (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion.from_quaternion(q1)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nrm = bh.RotationMatrix.from_matrix(mat)\nq = bh.Quaternion.from_rotation_matrix(rm)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, scalar_first: bool) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing quaternion components</p> required <code>scalar_first</code> <code>bool</code> <p>If True, array is [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([1.0, 0.0, 0.0, 0.0])\nq = bh.Quaternion.from_vector(v, scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.inverse","title":"inverse  <code>method descriptor</code>","text":"<pre><code>inverse() -&gt; Quaternion\n</code></pre> <p>Compute the inverse of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Inverse quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_inv = q.inverse()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.norm","title":"norm  <code>method descriptor</code>","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Calculate the norm (magnitude) of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean norm of the quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nnorm = q.norm()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.normalize","title":"normalize  <code>method descriptor</code>","text":"<pre><code>normalize() -&gt; Any\n</code></pre> <p>Normalize the quaternion in-place to unit length.</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(2.0, 0.0, 0.0, 0.0)\nq.normalize()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.slerp","title":"slerp  <code>method descriptor</code>","text":"<pre><code>slerp(other: Quaternion, t: float) -&gt; Quaternion\n</code></pre> <p>Perform spherical linear interpolation (SLERP) between two quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Quaternion</code> <p>Target quaternion</p> required <code>t</code> <code>float</code> <p>Interpolation parameter in [0, 1]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Interpolated quaternion</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion(0.707, 0.707, 0.0, 0.0)\nq_mid = q1.slerp(q2, 0.5)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = q.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation (returns self).</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>This quaternion</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(scalar_first: bool) -&gt; ndarray\n</code></pre> <p>Convert quaternion to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_first</code> <code>bool</code> <p>If True, returns [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nv = q.to_vector(scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html","title":"RotationMatrix Class","text":"<p>The <code>RotationMatrix</code> class represents attitude using Direction Cosine Matrices (DCM) for spacecraft orientation and coordinate transformations.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix","title":"RotationMatrix","text":"<pre><code>RotationMatrix(r11: float, r12: float, r13: float, r21: float, r22: float, r23: float, r31: float, r32: float, r33: float)\n</code></pre> <p>Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).</p> <p>A rotation matrix is an orthogonal 3x3 matrix with determinant +1 that represents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>r11</code> <code>float</code> <p>Element at row 1, column 1</p> required <code>r12</code> <code>float</code> <p>Element at row 1, column 2</p> required <code>r13</code> <code>float</code> <p>Element at row 1, column 3</p> required <code>r21</code> <code>float</code> <p>Element at row 2, column 1</p> required <code>r22</code> <code>float</code> <p>Element at row 2, column 2</p> required <code>r23</code> <code>float</code> <p>Element at row 2, column 3</p> required <code>r31</code> <code>float</code> <p>Element at row 3, column 1</p> required <code>r32</code> <code>float</code> <p>Element at row 3, column 2</p> required <code>r33</code> <code>float</code> <p>Element at row 3, column 3</p> required <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity rotation\ndcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n\n# Create from numpy array\nR = np.eye(3)\ndcm2 = bh.RotationMatrix.from_matrix(R)\n\n# Convert to quaternion\nq = dcm.to_quaternion()\n\n# Rotate a vector\nv = np.array([1.0, 0.0, 0.0])\nv_rot = dcm.rotate_vector(v)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r11","title":"r11  <code>property</code>","text":"<pre><code>r11: float\n</code></pre> <p>Get element (1,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r12","title":"r12  <code>property</code>","text":"<pre><code>r12: float\n</code></pre> <p>Get element (1,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r13","title":"r13  <code>property</code>","text":"<pre><code>r13: float\n</code></pre> <p>Get element (1,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r21","title":"r21  <code>property</code>","text":"<pre><code>r21: float\n</code></pre> <p>Get element (2,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r22","title":"r22  <code>property</code>","text":"<pre><code>r22: float\n</code></pre> <p>Get element (2,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r23","title":"r23  <code>property</code>","text":"<pre><code>r23: float\n</code></pre> <p>Get element (2,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r31","title":"r31  <code>property</code>","text":"<pre><code>r31: float\n</code></pre> <p>Get element (3,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r32","title":"r32  <code>property</code>","text":"<pre><code>r32: float\n</code></pre> <p>Get element (3,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r33","title":"r33  <code>property</code>","text":"<pre><code>r33: float\n</code></pre> <p>Get element (3,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rx","title":"Rx  <code>builtin</code>","text":"<pre><code>Rx(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for X-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Ry","title":"Ry  <code>builtin</code>","text":"<pre><code>Ry(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Y-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rz","title":"Rz  <code>builtin</code>","text":"<pre><code>Rz(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Z-axis rotation</p> Example <pre><code>import brahe as bh\n\nr = bh.RotationMatrix.Rz(1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from an Euler axis.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_matrix","title":"from_matrix  <code>builtin</code>","text":"<pre><code>from_matrix(m: ndarray) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a 3x3 numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nr = bh.RotationMatrix.from_matrix(mat)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nr = bh.RotationMatrix.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from another rotation matrix (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Source rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = bh.RotationMatrix.from_rotation_matrix(r1)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\neuler = r.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = r.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert rotation matrix to a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\nq = r.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation (returns self).</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>This rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = r1.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/constants/index.html","title":"Constants","text":"<p>Mathematical, physical, and astronomical constants used throughout the brahe library.</p>"},{"location":"library_api/constants/index.html#categories","title":"Categories","text":""},{"location":"library_api/constants/index.html#units","title":"Units","text":"<p>Angle format enumerations and time system constants for specifying units and reference frames.</p>"},{"location":"library_api/constants/index.html#mathematical-constants","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/index.html#time-constants","title":"Time Constants","text":"<p>Julian date references and time system offset values.</p>"},{"location":"library_api/constants/index.html#physical-constants","title":"Physical Constants","text":"<p>Physical properties of Earth, celestial bodies, and universal constants.</p>"},{"location":"library_api/constants/index.html#quick-reference","title":"Quick Reference","text":"<p>All constants use SI base units unless otherwise noted:</p> <ul> <li>Distance: meters (m)</li> <li>Time: seconds (s)</li> <li>Angles: radians (rad)</li> <li>Gravitational Parameter: m\u00b3/s\u00b2</li> </ul> <p>Constants are accessible directly from the <code>brahe</code> module:</p> <pre><code>import brahe as bh\n\n# Mathematical constants\nangle_rad = 45.0 * bh.DEG2RAD  # Convert degrees to radians\n\n# Physical constants\nmu_earth = bh.GM_EARTH  # Earth's gravitational parameter\nc = bh.C_LIGHT          # Speed of light\n\n# Time system\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n</code></pre>"},{"location":"library_api/constants/math.html","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/math.html#angle-conversions","title":"Angle Conversions","text":""},{"location":"library_api/constants/math.html#deg2rad","title":"DEG2RAD","text":"<p>Value: <code>0.017453292519943295</code> rad/deg</p> <p>Converts degrees to radians. Equivalent to \u03c0/180.</p>"},{"location":"library_api/constants/math.html#brahe.DEG2RAD","title":"DEG2RAD  <code>module-attribute</code>","text":"<pre><code>DEG2RAD: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2deg","title":"RAD2DEG","text":"<p>Value: <code>57.29577951308232</code> deg/rad</p> <p>Converts radians to degrees. Equivalent to 180/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2DEG","title":"RAD2DEG  <code>module-attribute</code>","text":"<pre><code>RAD2DEG: float = 57.29577951308232\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#as2rad","title":"AS2RAD","text":"<p>Value: <code>4.84813681109536e-06</code> rad/arcsec</p> <p>Converts arc seconds to radians. Equivalent to \u03c0/(180 \u00d7 3600).</p>"},{"location":"library_api/constants/math.html#brahe.AS2RAD","title":"AS2RAD  <code>module-attribute</code>","text":"<pre><code>AS2RAD: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2as","title":"RAD2AS","text":"<p>Value: <code>206264.80624709636</code> arcsec/rad</p> <p>Converts radians to arc seconds. Equivalent to (180 \u00d7 3600)/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2AS","title":"RAD2AS  <code>module-attribute</code>","text":"<pre><code>RAD2AS: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html","title":"Physical Constants","text":"<p>Physical properties of celestial bodies and universal constants. All values use SI base units.</p>"},{"location":"library_api/constants/physical.html#universal-constants","title":"Universal Constants","text":""},{"location":"library_api/constants/physical.html#c_light","title":"C_LIGHT","text":"<p>Value: <code>299792458.0</code> m/s</p> <p>Speed of light in vacuum.</p>"},{"location":"library_api/constants/physical.html#brahe.C_LIGHT","title":"C_LIGHT  <code>module-attribute</code>","text":"<pre><code>C_LIGHT: float = 299792458.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#au","title":"AU","text":"<p>Value: <code>1.495978707e11</code> m</p> <p>Astronomical Unit - mean distance of Earth from the Sun. TDB-compatible value.</p>"},{"location":"library_api/constants/physical.html#brahe.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870700.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#p_sun","title":"P_SUN","text":"<p>Value: <code>4.56e-6</code> N/m\u00b2</p> <p>Solar radiation pressure at 1 AU.</p>"},{"location":"library_api/constants/physical.html#brahe.P_SUN","title":"P_SUN  <code>module-attribute</code>","text":"<pre><code>P_SUN: float = 4.56e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#earth-constants","title":"Earth Constants","text":""},{"location":"library_api/constants/physical.html#geometry","title":"Geometry","text":""},{"location":"library_api/constants/physical.html#r_earth","title":"R_EARTH","text":"<p>Value: <code>6378136.3</code> m</p> <p>Earth's equatorial radius (GGM05 gravity model).</p>"},{"location":"library_api/constants/physical.html#brahe.R_EARTH","title":"R_EARTH  <code>module-attribute</code>","text":"<pre><code>R_EARTH: float = 6378136.3\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_a","title":"WGS84_A","text":"<p>Value: <code>6378137.0</code> m</p> <p>Earth's semi-major axis as defined by WGS84 geodetic system.</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_A","title":"WGS84_A  <code>module-attribute</code>","text":"<pre><code>WGS84_A: float = 6378137.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_f","title":"WGS84_F","text":"<p>Value: <code>0.0033528106647474805</code> (dimensionless)</p> <p>Earth's ellipsoidal flattening. WGS84 value: 1/298.257223563</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_F","title":"WGS84_F  <code>module-attribute</code>","text":"<pre><code>WGS84_F: float = 0.0033528106647474805\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#ecc_earth","title":"ECC_EARTH","text":"<p>Value: <code>0.081819190842622</code> (dimensionless)</p> <p>Earth's first eccentricity (WGS84 value).</p>"},{"location":"library_api/constants/physical.html#brahe.ECC_EARTH","title":"ECC_EARTH  <code>module-attribute</code>","text":"<pre><code>ECC_EARTH: float = 0.081819190842622\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gravitational-properties","title":"Gravitational Properties","text":""},{"location":"library_api/constants/physical.html#gm_earth","title":"GM_EARTH","text":"<p>Value: <code>3.986004415e14</code> m\u00b3/s\u00b2</p> <p>Earth's gravitational parameter (\u03bc = G \u00d7 M).</p>"},{"location":"library_api/constants/physical.html#brahe.GM_EARTH","title":"GM_EARTH  <code>module-attribute</code>","text":"<pre><code>GM_EARTH: float = 398600441500000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#j2_earth","title":"J2_EARTH","text":"<p>Value: <code>0.0010826358191967</code> (dimensionless)</p> <p>Earth's J2 zonal harmonic coefficient (GGM05s gravity model). Represents Earth's oblateness.</p>"},{"location":"library_api/constants/physical.html#brahe.J2_EARTH","title":"J2_EARTH  <code>module-attribute</code>","text":"<pre><code>J2_EARTH: float = 0.0010826358191967\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#omega_earth","title":"OMEGA_EARTH","text":"<p>Value: <code>7.292115146706979e-05</code> rad/s</p> <p>Earth's axial rotation rate.</p>"},{"location":"library_api/constants/physical.html#brahe.OMEGA_EARTH","title":"OMEGA_EARTH  <code>module-attribute</code>","text":"<pre><code>OMEGA_EARTH: float = 7.292115146706979e-05\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#celestial-body-gravitational-parameters","title":"Celestial Body Gravitational Parameters","text":"<p>Gravitational parameters (\u03bc = G \u00d7 M) for major solar system bodies in m\u00b3/s\u00b2.</p>"},{"location":"library_api/constants/physical.html#sun","title":"Sun","text":""},{"location":"library_api/constants/physical.html#gm_sun","title":"GM_SUN","text":"<p>Value: <code>1.32712440041939e20</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SUN","title":"GM_SUN  <code>module-attribute</code>","text":"<pre><code>GM_SUN: float = 1.327124400419394e+20\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_sun","title":"R_SUN","text":"<p>Value: <code>6.9634e8</code> m</p> <p>Solar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_SUN","title":"R_SUN  <code>module-attribute</code>","text":"<pre><code>R_SUN: float = 695700000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#moon","title":"Moon","text":""},{"location":"library_api/constants/physical.html#gm_moon","title":"GM_MOON","text":"<p>Value: <code>4.9028e12</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MOON","title":"GM_MOON  <code>module-attribute</code>","text":"<pre><code>GM_MOON: float = 4902800066000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_moon","title":"R_MOON","text":"<p>Value: <code>1.738e6</code> m</p> <p>Lunar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_MOON","title":"R_MOON  <code>module-attribute</code>","text":"<pre><code>R_MOON: float = 1738000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#inner-planets","title":"Inner Planets","text":""},{"location":"library_api/constants/physical.html#gm_mercury","title":"GM_MERCURY","text":"<p>Value: <code>2.2031868551e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MERCURY","title":"GM_MERCURY  <code>module-attribute</code>","text":"<pre><code>GM_MERCURY: float = 22031780000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_venus","title":"GM_VENUS","text":"<p>Value: <code>3.257e14</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_VENUS","title":"GM_VENUS  <code>module-attribute</code>","text":"<pre><code>GM_VENUS: float = 324858592000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_mars","title":"GM_MARS","text":"<p>Value: <code>4.305e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MARS","title":"GM_MARS  <code>module-attribute</code>","text":"<pre><code>GM_MARS: float = 42828375210000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#outer-planets","title":"Outer Planets","text":""},{"location":"library_api/constants/physical.html#gm_jupiter","title":"GM_JUPITER","text":"<p>Value: <code>1.268e17</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_JUPITER","title":"GM_JUPITER  <code>module-attribute</code>","text":"<pre><code>GM_JUPITER: float = 1.267127648e+17\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_saturn","title":"GM_SATURN","text":"<p>Value: <code>3.794e16</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SATURN","title":"GM_SATURN  <code>module-attribute</code>","text":"<pre><code>GM_SATURN: float = 3.79405852e+16\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_uranus","title":"GM_URANUS","text":"<p>Value: <code>5.794e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_URANUS","title":"GM_URANUS  <code>module-attribute</code>","text":"<pre><code>GM_URANUS: float = 5794548600000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_neptune","title":"GM_NEPTUNE","text":"<p>Value: <code>6.837e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_NEPTUNE","title":"GM_NEPTUNE  <code>module-attribute</code>","text":"<pre><code>GM_NEPTUNE: float = 6836527100580000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#dwarf-planets","title":"Dwarf Planets","text":""},{"location":"library_api/constants/physical.html#gm_pluto","title":"GM_PLUTO","text":"<p>Value: <code>9.77e11</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_PLUTO","title":"GM_PLUTO  <code>module-attribute</code>","text":"<pre><code>GM_PLUTO: float = 977000000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html","title":"Time Constants","text":"<p>Constants related to time systems, epochs, and time conversions.</p>"},{"location":"library_api/constants/time.html#julian-date-references","title":"Julian Date References","text":""},{"location":"library_api/constants/time.html#mjd_zero","title":"MJD_ZERO","text":"<p>Value: <code>2400000.5</code> days</p> <p>Offset of Modified Julian Date (MJD) with respect to Julian Date (JD). For any time t: <pre><code>MJD_ZERO = JD - MJD\n</code></pre></p>"},{"location":"library_api/constants/time.html#brahe.MJD_ZERO","title":"MJD_ZERO  <code>module-attribute</code>","text":"<pre><code>MJD_ZERO: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#mjd2000","title":"MJD2000","text":"<p>Value: <code>51544.5</code> days</p> <p>Modified Julian Date of January 1, 2000 12:00:00 (J2000.0 epoch). Value is independent of time system.</p>"},{"location":"library_api/constants/time.html#brahe.MJD2000","title":"MJD2000  <code>module-attribute</code>","text":"<pre><code>MJD2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps_zero","title":"GPS_ZERO","text":"<p>Value: <code>44244.0</code> days</p> <p>Modified Julian Date of the start of GPS time (January 6, 1980 00:00:00 UTC).</p>"},{"location":"library_api/constants/time.html#brahe.GPS_ZERO","title":"GPS_ZERO  <code>module-attribute</code>","text":"<pre><code>GPS_ZERO: float = 44244.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#time-system-offsets","title":"Time System Offsets","text":"<p>All offset values are in seconds.</p>"},{"location":"library_api/constants/time.html#gps-tai","title":"GPS \u2194 TAI","text":""},{"location":"library_api/constants/time.html#gps_tai","title":"GPS_TAI","text":"<p>Value: <code>-19.0</code> seconds</p> <p>Offset of GPS time with respect to TAI: <code>GPS = TAI + GPS_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TAI","title":"GPS_TAI  <code>module-attribute</code>","text":"<pre><code>GPS_TAI: float = -19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_gps","title":"TAI_GPS","text":"<p>Value: <code>19.0</code> seconds</p> <p>Offset of TAI time with respect to GPS: <code>TAI = GPS + TAI_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_GPS","title":"TAI_GPS  <code>module-attribute</code>","text":"<pre><code>TAI_GPS: float = 19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt-tai","title":"TT \u2194 TAI","text":""},{"location":"library_api/constants/time.html#tt_tai","title":"TT_TAI","text":"<p>Value: <code>32.184</code> seconds</p> <p>Offset of Terrestrial Time with respect to TAI: <code>TT = TAI + TT_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_TAI","title":"TT_TAI  <code>module-attribute</code>","text":"<pre><code>TT_TAI: float = 32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_tt","title":"TAI_TT","text":"<p>Value: <code>-32.184</code> seconds</p> <p>Offset of TAI with respect to Terrestrial Time: <code>TAI = TT + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_TT","title":"TAI_TT  <code>module-attribute</code>","text":"<pre><code>TAI_TT: float = -32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps-tt","title":"GPS \u2194 TT","text":""},{"location":"library_api/constants/time.html#gps_tt","title":"GPS_TT","text":"<p>Value: <code>13.184</code> seconds</p> <p>Offset of GPS time with respect to TT: <code>GPS = TT + GPS_TT</code></p> <p>Computed as: <code>GPS_TAI + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TT","title":"GPS_TT  <code>module-attribute</code>","text":"<pre><code>GPS_TT: float = -51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt_gps","title":"TT_GPS","text":"<p>Value: <code>-13.184</code> seconds</p> <p>Offset of TT with respect to GPS time: <code>TT = GPS + TT_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_GPS","title":"TT_GPS  <code>module-attribute</code>","text":"<pre><code>TT_GPS: float = 51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/units.html","title":"Units","text":"<p>Enumerations for specifying angle formats and time systems.</p>"},{"location":"library_api/constants/units.html#angle-format","title":"Angle Format","text":"<p>The <code>AngleFormat</code> enumeration specifies whether angles are in radians or degrees.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create rotation with angle in degrees\nq = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=90.0,\n    angle_format=bh.AngleFormat.DEGREES\n)\n\n# Create rotation with angle in radians\nq2 = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=np.pi/2,\n    angle_format=bh.AngleFormat.RADIANS\n)\n</code></pre>"},{"location":"library_api/constants/units.html#time-system","title":"Time System","text":"<p>The <code>TimeSystem</code> enumeration specifies the time reference system for epochs.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem","title":"TimeSystem","text":"<pre><code>TimeSystem()\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UTC","title":"UTC  <code>class-attribute</code>","text":"<pre><code>UTC: Any = TimeSystem.UTC\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TAI","title":"TAI  <code>class-attribute</code>","text":"<pre><code>TAI: Any = TimeSystem.TAI\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TT","title":"TT  <code>class-attribute</code>","text":"<pre><code>TT: Any = TimeSystem.TT\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.GPS","title":"GPS  <code>class-attribute</code>","text":"<pre><code>GPS: Any = TimeSystem.GPS\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UT1","title":"UT1  <code>class-attribute</code>","text":"<pre><code>UT1: Any = TimeSystem.UT1\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#time-system-descriptions","title":"Time System Descriptions","text":"<ul> <li>UTC (Coordinated Universal Time): Civil time standard used worldwide. Includes leap seconds to keep within 0.9 seconds of UT1.</li> <li>TAI (International Atomic Time): Continuous time scale based on atomic clocks. Currently 37 seconds ahead of UTC (as of 2024).</li> <li>TT (Terrestrial Time): Theoretical time scale for solar system calculations. TT = TAI + 32.184 seconds.</li> <li>GPS (Global Positioning System): Continuous time starting from GPS epoch (January 6, 1980). Does not include leap seconds.</li> <li>UT1 (Universal Time 1): Based on Earth's rotation. Computed from UTC using Earth Orientation Parameters (EOP).</li> </ul>"},{"location":"library_api/constants/units.html#usage-example_1","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Create epoch in different time systems\nutc_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ntai_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.TAI)\ngps_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\n\n# Time system is preserved in the epoch\nprint(utc_epoch.time_system)  # Output: UTC\nprint(tai_epoch.time_system)  # Output: TAI\n</code></pre>"},{"location":"library_api/coordinates/index.html","title":"Coordinates","text":"<p>Module: <code>brahe.coordinates</code></p> <p>Comprehensive coordinate system transformations for satellite dynamics.</p>"},{"location":"library_api/coordinates/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Enumerations - Coordinate type enumerations (EllipsoidalConversionType, AngleFormat)</li> <li>Cartesian Coordinates - Cartesian state vectors and orbital element conversions</li> <li>Geodetic &amp; Geocentric - WGS84 geodetic and geocentric coordinate conversions</li> <li>Topocentric Coordinates - Local topocentric frames (ENZ, SEZ, AzElRange)</li> </ul>"},{"location":"library_api/coordinates/cartesian.html","title":"Cartesian Coordinates","text":"<p>Functions for working with Cartesian state vectors and conversions.</p>"},{"location":"library_api/coordinates/cartesian.html#state-conversions","title":"State Conversions","text":""},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_osculating_to_cartesian","title":"state_osculating_to_cartesian  <code>builtin</code>","text":"<pre><code>state_osculating_to_cartesian(x_oe: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert osculating orbital elements to Cartesian state.</p> <p>Transforms a state vector from osculating Keplerian orbital elements to Cartesian position and velocity coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_oe</code> <code>ndarray or list</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Orbital elements for a circular orbit\noe = np.array([7000000.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\nx_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprint(f\"Cartesian state: {x_cart}\")\n</code></pre>"},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_cartesian_to_osculating","title":"state_cartesian_to_osculating  <code>builtin</code>","text":"<pre><code>state_cartesian_to_osculating(x_cart: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert Cartesian state to osculating orbital elements.</p> <p>Transforms a state vector from Cartesian position and velocity coordinates to osculating Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>x_cart</code> <code>ndarray or list</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Cartesian state vector\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])  # [x, y, z, vx, vy, vz]\noe = bh.state_cartesian_to_osculating(x_cart, bh.AngleFormat.RADIANS)\nprint(f\"Orbital elements: a={oe[0]:.0f}m, e={oe[1]:.6f}, i={oe[2]:.6f} rad\")\n</code></pre>"},{"location":"library_api/coordinates/enums.html","title":"Coordinate Enumerations","text":"<p>Enumerations for specifying coordinate transformation types.</p>"},{"location":"library_api/coordinates/enums.html#ellipsoidalconversiontype","title":"EllipsoidalConversionType","text":"<p>Specifies the type of ellipsoidal conversion used in topocentric coordinate transformations.</p> <p>Values: - <code>GEOCENTRIC</code> - Uses geocentric latitude where the angle is measured from the center of the Earth - <code>GEODETIC</code> - Uses geodetic latitude where the angle is measured perpendicular to the WGS84 ellipsoid</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType","title":"EllipsoidalConversionType","text":"<pre><code>EllipsoidalConversionType()\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEOCENTRIC","title":"GEOCENTRIC  <code>class-attribute</code>","text":"<pre><code>GEOCENTRIC: Any = EllipsoidalConversionType.Geocentric\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEODETIC","title":"GEODETIC  <code>class-attribute</code>","text":"<pre><code>GEODETIC: Any = EllipsoidalConversionType.Geodetic\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#angleformat","title":"AngleFormat","text":"<p>Specifies whether angles are in radians or degrees.</p> <p>Values: - <code>RADIANS</code> - Angles are in radians - <code>DEGREES</code> - Angles are in degrees</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates</li> <li>Geodetic &amp; Geocentric</li> </ul>"},{"location":"library_api/coordinates/geodetic.html","title":"Geodetic and Geocentric Coordinates","text":"<p>Functions for converting between geodetic, geocentric, and ECEF coordinates.</p>"},{"location":"library_api/coordinates/geodetic.html#geodetic-conversions","title":"Geodetic Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geodetic_to_ecef","title":"position_geodetic_to_ecef  <code>builtin</code>","text":"<pre><code>position_geodetic_to_ecef(x_geod: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert geodetic position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geodetic coordinates (longitude, latitude, altitude) using the <code>WGS84</code> ellipsoid model to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geod</code> <code>ndarray or list</code> <p>Geodetic position <code>[longitude, latitude, altitude]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: <code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (GPS-like) to ECEF\nlon, lat, alt = -105.0, 40.0, 1655.0  # Boulder, CO (degrees, meters)\nx_geod = np.array([lon, lat, alt])\nx_ecef = bh.position_geodetic_to_ecef(x_geod, bh.AngleFormat.DEGREES)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geodetic","title":"position_ecef_to_geodetic  <code>builtin</code>","text":"<pre><code>position_ecef_to_geodetic(x_ecef: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geodetic coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geodetic coordinates (longitude, latitude, altitude) using the <code>WGS84</code> ellipsoid model.</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray or list</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Geodetic position <code>[longitude, latitude, altitude]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geodetic coordinates (GPS-like)\nx_ecef = np.array([-1275936.0, -4797210.0, 4020109.0])  # Example location\nx_geod = bh.position_ecef_to_geodetic(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geodetic: lon={x_geod[0]:.4f}\u00b0, lat={x_geod[1]:.4f}\u00b0, alt={x_geod[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#geocentric-conversions","title":"Geocentric Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geocentric_to_ecef","title":"position_geocentric_to_ecef  <code>builtin</code>","text":"<pre><code>position_geocentric_to_ecef(x_geoc: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert geocentric position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geocentric spherical coordinates (longitude, latitude, radius) to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geoc</code> <code>ndarray or list</code> <p>Geocentric position <code>[longitude, latitude, radius]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and radius is in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: <code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geocentric coordinates to ECEF\nlon, lat, r = 0.0, 0.0, 6378137.0  # Equator, prime meridian, Earth's radius\nx_geoc = np.array([lon, lat, r])\nx_ecef = bh.position_geocentric_to_ecef(x_geoc, bh.AngleFormat.RADIANS)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geocentric","title":"position_ecef_to_geocentric  <code>builtin</code>","text":"<pre><code>position_ecef_to_geocentric(x_ecef: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geocentric coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geocentric spherical coordinates (longitude, latitude, radius).</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray or list</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Geocentric position <code>[longitude, latitude, radius]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and radius is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geocentric coordinates\nx_ecef = np.array([6378137.0, 0.0, 0.0])  # Point on equator, prime meridian\nx_geoc = bh.position_ecef_to_geocentric(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geocentric: lon={x_geoc[0]:.2f}\u00b0, lat={x_geoc[1]:.2f}\u00b0, r={x_geoc[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html","title":"Topocentric Coordinates","text":"<p>Functions for working with local topocentric coordinate frames including East-North-Up (ENZ), South-East-Zenith (SEZ), and Azimuth-Elevation-Range.</p>"},{"location":"library_api/coordinates/topocentric.html#enz-east-north-up-frame","title":"ENZ (East-North-Up) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_enz","title":"rotation_ellipsoid_to_enz  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_enz(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to East-North-Up (<code>ENZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from ellipsoidal frame to <code>ENZ</code> frame.</p>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_enz_to_ellipsoid","title":"rotation_enz_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_enz_to_ellipsoid(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from East-North-Up (<code>ENZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local East-North-Up (<code>ENZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from <code>ENZ</code> frame to ellipsoidal frame.</p>"},{"location":"library_api/coordinates/topocentric.html#position-conversions","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_enz","title":"relative_position_ecef_to_enz  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_enz(location_ecef: Union[ndarray, List], r_ecef: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from <code>ECEF</code> to East-North-Up (<code>ENZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nenz = bh.relative_position_ecef_to_enz(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"ENZ: East={enz[0]/1000:.1f}km, North={enz[1]/1000:.1f}km, Up={enz[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_enz_to_ecef","title":"relative_position_enz_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_enz_to_ecef(location_ecef: Union[ndarray, List], r_enz: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from East-North-Up (<code>ENZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local East-North-Up (<code>ENZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_enz</code> <code>ndarray or list</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nenz_offset = np.array([50000.0, 30000.0, 100000.0])  # 50km east, 30km north, 100km up\ntarget_ecef = bh.relative_position_enz_to_ecef(station_ecef, enz_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_enz_to_azel","title":"position_enz_to_azel  <code>builtin</code>","text":"<pre><code>position_enz_to_azel(x_enz: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert position from East-North-Up (<code>ENZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local East-North-Up (<code>ENZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_enz</code> <code>ndarray or list</code> <p>Position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ to azimuth-elevation for satellite tracking\nenz = np.array([50000.0, 100000.0, 200000.0])  # East, North, Up (meters)\nazel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#sez-south-east-zenith-frame","title":"SEZ (South-East-Zenith) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices_1","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_sez","title":"rotation_ellipsoid_to_sez  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_sez(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from ellipsoidal frame to <code>SEZ</code> frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix for ground station in SEZ frame\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_sez = bh.rotation_ellipsoid_to_sez(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_sez.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_sez_to_ellipsoid","title":"rotation_sez_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_sez_to_ellipsoid(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from South-East-Zenith (<code>SEZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from <code>SEZ</code> frame to ellipsoidal frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get inverse rotation matrix from SEZ to ellipsoidal\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_ellipsoid = bh.rotation_sez_to_ellipsoid(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_ellipsoid.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#position-conversions_1","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_sez","title":"relative_position_ecef_to_sez  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_sez(location_ecef: Union[ndarray, List], r_ecef: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from <code>ECEF</code> to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nsez = bh.relative_position_ecef_to_sez(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"SEZ: South={sez[0]/1000:.1f}km, East={sez[1]/1000:.1f}km, Zenith={sez[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_sez_to_ecef","title":"relative_position_sez_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_sez_to_ecef(location_ecef: Union[ndarray, List], x_sez: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from South-East-Zenith (<code>SEZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>x_sez</code> <code>ndarray or list</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsez_offset = np.array([30000.0, 50000.0, 100000.0])  # 30km south, 50km east, 100km up\ntarget_ecef = bh.relative_position_sez_to_ecef(station_ecef, sez_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_sez_to_azel","title":"position_sez_to_azel  <code>builtin</code>","text":"<pre><code>position_sez_to_azel(x_sez: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert position from South-East-Zenith (<code>SEZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_sez</code> <code>ndarray or list</code> <p>Position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ to azimuth-elevation for satellite tracking\nsez = np.array([30000.0, 50000.0, 100000.0])  # South, East, Zenith (meters)\nazel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/datasets/index.html","title":"Datasets Module","text":"<p>The datasets module provides convenient access to satellite ephemeris data and groundstation locations from multiple sources. It handles downloading, parsing, and format conversion automatically.</p>"},{"location":"library_api/datasets/index.html#module-overview","title":"Module Overview","text":"<p>The module is organized by data source, with each source providing a consistent API:</p> <ul> <li><code>brahe.datasets.celestrak</code>: CelesTrak satellite ephemeris data</li> <li><code>brahe.datasets.groundstations</code>: Curated groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#submodules","title":"Submodules","text":"<ul> <li>CelesTrak Functions - Satellite ephemeris from CelesTrak</li> <li>Groundstation Functions - Groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets module</li> <li>CelesTrak Details - CelesTrak data source specifics</li> </ul>"},{"location":"library_api/datasets/celestrak.html","title":"CelesTrak Functions","text":"<p>Functions for accessing satellite ephemeris data from CelesTrak.</p> <p>All functions are available via <code>brahe.datasets.celestrak.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/celestrak.html#download_tles","title":"download_tles","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_download_tles","title":"celestrak_download_tles  <code>builtin</code>","text":"<pre><code>celestrak_download_tles(group: str, filepath: str, content_format: str, file_format: str) -&gt; Any\n</code></pre> <p>Download satellite ephemeris from CelesTrak and save to file</p> <p>Downloads 3LE data from CelesTrak and serializes to the specified file format. The file can contain either 2-line elements (TLE, without names) or 3-line elements (3LE, with satellite names), and can be saved as plain text, CSV, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>filepath</code> <code>str</code> <p>Output file path. Parent directories will be created if needed.</p> required <code>content_format</code> <code>str</code> <p>Content format - \"tle\" (2-line without names) or \"3le\" (3-line with names).</p> required <code>file_format</code> <code>str</code> <p>File format - \"txt\" (plain text), \"csv\" (comma-separated), or \"json\" (JSON array).</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, format is invalid, or file cannot be written.</p> Example <pre><code>import brahe as bh\n\n# Download GNSS satellites as 3LE in JSON format\nbh.datasets.celestrak.download_tles(\"gnss\", \"gnss_sats.json\", \"3le\", \"json\")\n\n# Download active satellites as 2LE in plain text\nbh.datasets.celestrak.download_tles(\"active\", \"active.txt\", \"tle\", \"txt\")\n\n# Download stations as 3LE in CSV format\nbh.datasets.celestrak.download_tles(\"stations\", \"stations.csv\", \"3le\", \"csv\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_id","title":"get_tle_by_id","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_id","title":"celestrak_get_tle_by_id  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_id(norad_id: int, group: str = None) -&gt; tuple[str, str, str]\n</code></pre> <p>Get TLE data for a specific satellite by NORAD catalog number</p> <p>Downloads 3LE data from CelesTrak for a single satellite identified by its NORAD catalog number. Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>NORAD catalog number (1-9 digits).</p> required <code>group</code> <code>str</code> <p>Satellite group for fallback search if direct ID lookup fails. Available groups can be found at https://celestrak.org/NORAD/elements/</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple[str, str, str]: Tuple of (name, line1, line2) containing satellite name and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or satellite not found.</p> Example <pre><code>import brahe as bh\n\n# Get ISS TLE by NORAD ID (25544)\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_id(25544)\nprint(f\"Satellite: {name}\")\nprint(f\"Line 1: {line1}\")\nprint(f\"Line 2: {line2}\")\n\n# With group fallback\ntle = bh.datasets.celestrak.get_tle_by_id(25544, group=\"stations\")\n</code></pre> Note <p>You can find which group contains a specific NORAD ID at: https://celestrak.org/NORAD/elements/master-gp-index.php</p> <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_id_as_propagator","title":"get_tle_by_id_as_propagator","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_id_as_propagator","title":"celestrak_get_tle_by_id_as_propagator  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_id_as_propagator(norad_id: int, step_size: float, group: str = None) -&gt; SGPPropagator\n</code></pre> <p>Get TLE data for a specific satellite as an SGP propagator</p> <p>Downloads TLE data from CelesTrak for a single satellite and creates an SGP4/SDP4 propagator. Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>NORAD catalog number (1-9 digits).</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagator in seconds.</p> required <code>group</code> <code>str</code> <p>Satellite group for fallback search if direct ID lookup fails.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Configured SGP propagator (PySGPPropagator) ready to use.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, satellite not found, or TLE is invalid.</p> Example <pre><code>import brahe as bh\n\n# Get ISS as propagator with 60-second step size\npropagator = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n\n# Propagate to current epoch\nepoch = bh.Epoch.now()\nstate = propagator.propagate(epoch)\nprint(f\"ISS position: {state[:3]}\")\n\n# With group fallback\nprop = bh.datasets.celestrak.get_tle_by_id_as_propagator(\n    25544, 60.0, group=\"stations\"\n)\n</code></pre> Note <p>You can find which group contains a specific NORAD ID at: https://celestrak.org/NORAD/elements/master-gp-index.php</p> <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_name","title":"get_tle_by_name","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_name","title":"celestrak_get_tle_by_name  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_name(name: str, group: str = None) -&gt; tuple[str, str, str]\n</code></pre> <p>Get TLE data for a specific satellite by name</p> <p>Searches for a satellite by name using a cascading search strategy: 1. If a group is provided, search within that group first 2. Fall back to searching the \"active\" group 3. Fall back to using CelesTrak's NAME API</p> <p>Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (case-insensitive, partial matches supported).</p> required <code>group</code> <code>str</code> <p>Satellite group to search first. Available groups can be found at https://celestrak.org/NORAD/elements/</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple[str, str, str]: Tuple of (name, line1, line2) containing satellite name and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or satellite not found.</p> Example <pre><code>import brahe as bh\n\n# Search for ISS with group hint\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_name(\"ISS\", group=\"stations\")\nprint(f\"Found: {name}\")\n\n# Search without group (uses cascading search)\ntle = bh.datasets.celestrak.get_tle_by_name(\"STARLINK-1234\")\n</code></pre> Note <ul> <li>Name matching is case-insensitive</li> <li>Partial names are supported (e.g., \"ISS\" will match \"ISS (ZARYA)\")</li> <li>If multiple satellites match, returns the first match</li> <li>Search order: specified group \u2192 \"active\" \u2192 NAME API</li> <li>Data is cached for 6 hours to reduce server load</li> </ul>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_name_as_propagator","title":"get_tle_by_name_as_propagator","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_name_as_propagator","title":"celestrak_get_tle_by_name_as_propagator  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_name_as_propagator(name: str, step_size: float, group: str = None) -&gt; SGPPropagator\n</code></pre> <p>Get TLE data for a specific satellite by name as an SGP propagator</p> <p>Searches for a satellite by name and creates an SGP4/SDP4 propagator. Uses cascading search strategy (specified group \u2192 active \u2192 NAME API). Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (case-insensitive, partial matches supported).</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagator in seconds.</p> required <code>group</code> <code>str</code> <p>Satellite group to search first.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Configured SGP propagator (PySGPPropagator) ready to use.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, satellite not found, or TLE is invalid.</p> Example <pre><code>import brahe as bh\n\n# Get ISS as propagator with 60-second step size\npropagator = bh.datasets.celestrak.get_tle_by_name_as_propagator(\"ISS\", 60.0, group=\"stations\")\n\n# Propagate to current epoch\nepoch = bh.Epoch.now()\nstate = propagator.propagate(epoch)\nprint(f\"Position: {state[:3]}\")\n</code></pre> Note <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tles","title":"get_tles","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tles","title":"celestrak_get_tles  <code>builtin</code>","text":"<pre><code>celestrak_get_tles(group: str) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Get satellite ephemeris data from CelesTrak</p> <p>Downloads and parses 3LE (three-line element) data for the specified satellite group from CelesTrak (https://celestrak.org).</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\"). See https://celestrak.org/NORAD/elements/ for available groups.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>list[tuple[str, str, str]]: List of (name, line1, line2) tuples containing satellite names and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or data cannot be parsed.</p> Example <pre><code>import brahe as bh\n\n# Download ephemeris for ground stations\nephemeris = bh.datasets.celestrak.get_tles(\"stations\")\n\n# Print first 5 satellites\nfor name, line1, line2 in ephemeris[:5]:\n    print(f\"Satellite: {name}\")\n    print(f\"  Line 1: {line1[:20]}...\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_tles_as_propagators","title":"get_tles_as_propagators","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tles_as_propagators","title":"celestrak_get_tles_as_propagators  <code>builtin</code>","text":"<pre><code>celestrak_get_tles_as_propagators(group: str, step_size: float) -&gt; list[SGPPropagator]\n</code></pre> <p>Get satellite ephemeris as SGP propagators from CelesTrak</p> <p>Downloads and parses 3LE data from CelesTrak, then creates SGP4/SDP4 propagators for each satellite. This is a convenient way to get ready-to-use propagators.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagators in seconds.</p> required <p>Returns:</p> Type Description <code>list[SGPPropagator]</code> <p>list[SGPPropagator]: List of configured SGP propagators (PySGPPropagator), one per satellite.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or no valid propagators can be created.</p> Note <p>Satellites with invalid TLE data will be skipped with a warning printed to stderr. The function will only raise an error if NO valid propagators can be created.</p> Example <pre><code>import brahe as bh\n\n# Get propagators for GNSS satellites with 60-second step size\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"gnss\", 60.0)\nprint(f\"Loaded {len(propagators)} GNSS satellites\")\n\n# Propagate first satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0, tsys=\"UTC\")\nstate = propagators[0].propagate(epoch)\n</code></pre>"},{"location":"library_api/datasets/groundstations.html","title":"Groundstation Functions","text":"<p>Functions for accessing curated groundstation location datasets.</p> <p>All functions are available via <code>brahe.datasets.groundstations.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/groundstations.html#load","title":"load","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load","title":"groundstations_load  <code>builtin</code>","text":"<pre><code>groundstations_load(provider: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstation locations for a specific provider</p> <p>Loads groundstation locations from embedded data. The data is compiled into the binary and does not require external files or internet connection.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name (case-insensitive). Available providers: - \"atlas\": Atlas Space Operations - \"aws\": Amazon Web Services Ground Station - \"ksat\": Kongsberg Satellite Services - \"leaf\": Leaf Space - \"ssc\": Swedish Space Corporation - \"viasat\": Viasat</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects with properties: - name: Groundstation name - provider: Provider name - frequency_bands: List of supported frequency bands</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If provider is unknown or data cannot be loaded.</p> Example <pre><code>import brahe as bh\n\n# Load KSAT groundstations\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\n\nfor station in ksat_stations:\n    print(f\"{station.name}: ({station.lon():.2f}, {station.lat():.2f})\")\n\n# Check properties\nprops = ksat_stations[0].properties()\nprint(f\"Frequency bands: {props['frequency_bands']}\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_from_file","title":"load_from_file","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_from_file","title":"groundstations_load_from_file  <code>builtin</code>","text":"<pre><code>groundstations_load_from_file(filepath: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstations from a custom GeoJSON file</p> <p>Loads groundstation locations from a user-provided GeoJSON file. The file must be a FeatureCollection with Point geometries.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to GeoJSON file.</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file cannot be read or parsed.</p> Example <pre><code>import brahe as bh\n\n# Load custom groundstations\nstations = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_all","title":"load_all","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_all","title":"groundstations_load_all  <code>builtin</code>","text":"<pre><code>groundstations_load_all() -&gt; list[PointLocation]\n</code></pre> <p>Load all groundstations from all providers</p> <p>Convenience function to load groundstations from all available providers.</p> <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: Combined list of all groundstations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no groundstations can be loaded.</p> Example <pre><code>import brahe as bh\n\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Loaded {len(all_stations)} total groundstations\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#list_providers","title":"list_providers","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_list_providers","title":"groundstations_list_providers  <code>builtin</code>","text":"<pre><code>groundstations_list_providers() -&gt; list[str]\n</code></pre> <p>Get list of available groundstation providers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of provider names that can be used with load().</p> Example <pre><code>import brahe as bh\n\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"Available: {', '.join(providers)}\")\n</code></pre>"},{"location":"library_api/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Module: <code>brahe.eop</code></p> <p>Earth Orientation Parameters provide corrections for the irregular rotation and orientation of the Earth, essential for accurate coordinate frame transformations between ECI and ECEF systems.</p>"},{"location":"library_api/eop/index.html#overview","title":"Overview","text":"<p>EOP data includes: - UT1-UTC: Difference between UT1 (Earth rotation time) and UTC - Polar Motion (x, y): Movement of Earth's rotation axis relative to the crust - dX, dY: Celestial pole offsets - LOD: Length of day variations</p>"},{"location":"library_api/eop/index.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports three types of EOP providers:</p>"},{"location":"library_api/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manage EOP file freshness with cache management and automatic updates.</p>"},{"location":"library_api/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Load EOP data from files (Standard or C04 format) for production applications with current data.</p>"},{"location":"library_api/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Use user-defined fixed data, ideal for testing, offline use, or applications not requiring the most precise transformations.</p>"},{"location":"library_api/eop/index.html#global-eop-management","title":"Global EOP Management","text":"<p>EOP data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/eop/index.html#functions","title":"Functions","text":"<ul> <li>Setting global EOP providers</li> <li>Querying global EOP data</li> <li>Downloading latest EOP files</li> </ul>"},{"location":"library_api/eop/index.html#quick-start","title":"Quick Start","text":"<pre><code>import brahe as bh\n\n# Option 1: Use file-based EOP (recommended for production)\nbh.set_global_eop_provider(\n    bh.FileEOPProvider.from_default_standard()\n)\n\n# Option 2: Use static EOP (for testing/offline use)\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Now frame transformations will use the global EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]  # meters\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/index.html#see-also","title":"See Also","text":"<ul> <li>Frames - Coordinate frame transformations that use EOP</li> <li>Epoch - Time representation</li> </ul>"},{"location":"library_api/eop/caching_provider.html","title":"CachingEOPProvider","text":""},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider","title":"CachingEOPProvider","text":"<pre><code>CachingEOPProvider(eop_type: str, max_age_seconds: int, auto_refresh: bool, interpolate: bool, extrapolate: str, filepath: str = ...)\n</code></pre> <p>Caching EOP provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileEOPProvider and adds automatic cache management. It checks the age of the EOP file and downloads updated versions when the file exceeds the maximum age threshold. If the file doesn't exist, it will be downloaded on initialization.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>Type of EOP file - \"C04\" for IERS C04 format or \"StandardBulletinA\" for IERS finals2000A.all format</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh. Common values: 86400 (1 day), 604800 (7 days)</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access. If False, only checks on initialization and manual refresh() calls</p> required <code>interpolate</code> <code>bool</code> <p>Enable linear interpolation between tabulated EOP values. Recommended: True for smoother data</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside EOP data range: \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)</p> required <code>filepath</code> <code>str</code> <p>Path to the EOP file (will be created if it doesn't exist). If None, uses default cache location: - StandardBulletinA: ~/.cache/brahe/finals.all.iau2000.txt - C04: ~/.cache/brahe/EOP_20_C04_one_file_1962-now.txt</p> <code>...</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file download fails or file is invalid</p> Example <pre><code>import brahe as bh\n\n# Using default cache location (recommended)\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n\n# Check and refresh as needed\nprovider.refresh()\n\n# With explicit filepath\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\",\n    filepath=\"./eop_data/finals.all.iau2000.txt\"\n)\n\n# Auto-refresh mode (convenience)\nauto_provider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,  # Checks on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP file type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type (\"C04\", \"StandardBulletinA\", etc.)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded EOP file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nage = provider.file_age()\nprint(f\"EOP file age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the EOP file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; Tuple\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(pm_x, pm_y, ut1_utc, dx, dy, lod)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last MJD with valid celestial pole offset data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dX/dY data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last MJD with valid LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with length of day data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached EOP data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Later, manually force a refresh check\nprovider.refresh()\n</code></pre>"},{"location":"library_api/eop/file_provider.html","title":"FileEOPProvider","text":"<p>Load Earth Orientation Parameters from IERS data files.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider","title":"FileEOPProvider","text":"<pre><code>FileEOPProvider()\n</code></pre> <p>File-based Earth Orientation Parameter provider.</p> <p>Loads EOP data from files in standard IERS formats and provides interpolation and extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from C04 file with interpolation\neop = bh.FileEOPProvider.from_c04_file(\n    \"./eop_data/finals2000A.all.csv\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Create from standard file\neop = bh.FileEOPProvider.from_standard_file(\n    \"./eop_data/finals.all\",\n    interpolate=True,\n    extrapolate=\"Zero\"\n)\n\n# Use default file location\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(eop)\n\n# Get EOP data for a specific MJD\nmjd = 60310.0\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Extrapolation: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_c04_file","title":"from_c04_file  <code>builtin</code>","text":"<pre><code>from_c04_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a C04 format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to C04 EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with C04 file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_c04_file(\"./eop_data/finals2000A.all.csv\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_c04","title":"from_default_c04  <code>builtin</code>","text":"<pre><code>from_default_c04(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default C04 EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default C04 file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file(eop_type: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from default EOP file location with specified type.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>EOP file type (\"C04\" or \"StandardBulletinA\")</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default file of specified type</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_file(\"C04\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_standard","title":"from_default_standard  <code>builtin</code>","text":"<pre><code>from_default_standard(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default standard IERS EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default standard file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from an EOP file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_file(\"./eop_data/eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_standard_file","title":"from_standard_file  <code>builtin</code>","text":"<pre><code>from_standard_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a standard IERS format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to standard IERS EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with standard file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_standard_file(\"./eop_data/standard_eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"interpolation: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"is_initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_last_dxdy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_max: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#overview","title":"Overview","text":"<p><code>FileEOPProvider</code> loads EOP data from files in either Standard or C04 format provided by the International Earth Rotation and Reference Systems Service (IERS).</p> <p>Module: <code>brahe.eop</code></p> <p>Data Sources: - Standard Format: finals2000A.all - Combined rapid + predicted data - C04 Format: eopc04_IAU2000.XX - Long-term historical data</p>"},{"location":"library_api/eop/file_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/file_provider.html#from-default-files","title":"From Default Files","text":"<pre><code>import brahe as bh\n\n# Use default standard format file\nprovider = bh.FileEOPProvider.from_default_standard()\n\n# Use default C04 format file\nprovider = bh.FileEOPProvider.from_default_c04()\n</code></pre>"},{"location":"library_api/eop/file_provider.html#from-custom-files","title":"From Custom Files","text":"<pre><code>import brahe as bh\n\n# Load from custom standard file\nprovider = bh.FileEOPProvider.from_standard_file(\n    \"/path/to/finals2000A.all\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Load from custom C04 file\nprovider = bh.FileEOPProvider.from_c04_file(\n    \"/path/to/eopc04.XX\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#configuration-options","title":"Configuration Options","text":""},{"location":"library_api/eop/file_provider.html#interpolation","title":"Interpolation","text":"<p><code>interpolate: bool</code> - Enable/disable interpolation between data points</p> <ul> <li><code>True</code>: Linear interpolation for dates between data points (recommended)</li> <li><code>False</code>: Use nearest data point (step function)</li> </ul>"},{"location":"library_api/eop/file_provider.html#extrapolation","title":"Extrapolation","text":"<p><code>extrapolate: str</code> - Behavior when querying dates outside data range</p> <ul> <li><code>\"Hold\"</code>: Use first/last values for dates before/after data range</li> <li><code>\"Zero\"</code>: Return zero for all EOP values outside range</li> <li><code>\"Error\"</code>: Raise an error if date is outside range</li> </ul>"},{"location":"library_api/eop/file_provider.html#usage-with-global-eop","title":"Usage with Global EOP","text":"<pre><code>import brahe as bh\n\n# Create provider from file\nprovider = bh.FileEOPProvider.from_default_standard(\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n\n# Now all frame transformations use this EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#downloading-eop-files","title":"Downloading EOP Files","text":"<pre><code>import brahe as bh\n\n# Download latest standard EOP file\nfilepath = bh.download_standard_eop_file(\"./data\")\n\n# Download latest C04 EOP file\nfilepath = bh.download_c04_eop_file(\"./data\")\n\n# Use downloaded file\nprovider = bh.FileEOPProvider.from_standard_file(filepath)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider - Built-in historical EOP data</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations using EOP</li> </ul>"},{"location":"library_api/eop/functions.html","title":"EOP Functions","text":"<p>Global EOP management and query functions.</p> <p>Module: <code>brahe.eop</code></p>"},{"location":"library_api/eop/functions.html#setting-global-eop-provider","title":"Setting Global EOP Provider","text":""},{"location":"library_api/eop/functions.html#initialize_eop","title":"initialize_eop","text":"<p>Recommended: Initialize the global EOP provider with sensible defaults. This is the easiest way to get started with EOP data for most applications.</p>"},{"location":"library_api/eop/functions.html#brahe.initialize_eop","title":"initialize_eop  <code>builtin</code>","text":"<pre><code>initialize_eop() -&gt; Any\n</code></pre> <p>Initialize the global EOP provider with recommended default settings.</p> <p>This convenience function creates a CachingEOPProvider with sensible defaults and sets it as the global provider. The provider will:</p> <ul> <li>Use StandardBulletinA EOP data format</li> <li>Automatically download/update EOP files when older than 7 days</li> <li>Use the default cache location (~/.cache/brahe/finals.all.iau2000.txt)</li> <li>Enable interpolation for smooth EOP data transitions</li> <li>Hold the last known EOP value when extrapolating beyond available data</li> <li>NOT auto-refresh on every access (manual refresh required)</li> </ul> <p>This is the recommended way to initialize EOP data for most applications, balancing accuracy, performance, and ease of use.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file download or loading failed</p> Example <pre><code>import brahe as bh\n\n# Initialize with recommended defaults\nbh.initialize_eop()\n\n# Now you can perform frame transformations that require EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [bh.R_EARTH + 500e3, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre> Example <pre><code>import brahe as bh\n\n# This is equivalent to:\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider","title":"set_global_eop_provider","text":"<p>Set the global EOP provider using any supported provider type (StaticEOPProvider, FileEOPProvider, or CachingEOPProvider).</p>"},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider","title":"set_global_eop_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider(provider: StaticEOPProvider | FileEOPProvider | CachingEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using any supported provider type.</p> <p>This function accepts any of the three EOP provider types: StaticEOPProvider, FileEOPProvider, or CachingEOPProvider. This is the recommended way to set the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticEOPProvider | FileEOPProvider | CachingEOPProvider</code> <p>EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\n# Use with StaticEOPProvider\nprovider = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(provider)\n\n# Use with FileEOPProvider\nprovider = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(provider)\n\n# Use with CachingEOPProvider\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#querying-global-eop-data","title":"Querying Global EOP Data","text":""},{"location":"library_api/eop/functions.html#get_global_eop","title":"get_global_eop","text":"<p>Get all EOP values for a specific Modified Julian Date.</p> <p>Returns: Tuple of (ut1_utc, pm_x, pm_y, dx, dy, lod)</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop","title":"get_global_eop  <code>builtin</code>","text":"<pre><code>get_global_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p>"},{"location":"library_api/eop/functions.html#get_global_ut1_utc","title":"get_global_ut1_utc","text":"<p>Get UT1-UTC offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_ut1_utc","title":"get_global_ut1_utc  <code>builtin</code>","text":"<pre><code>get_global_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/functions.html#get_global_pm","title":"get_global_pm","text":"<p>Get polar motion (x, y) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_pm","title":"get_global_pm  <code>builtin</code>","text":"<pre><code>get_global_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/functions.html#get_global_dxdy","title":"get_global_dxdy","text":"<p>Get celestial pole offsets (dx, dy) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_dxdy","title":"get_global_dxdy  <code>builtin</code>","text":"<pre><code>get_global_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/functions.html#get_global_lod","title":"get_global_lod","text":"<p>Get length of day offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_lod","title":"get_global_lod  <code>builtin</code>","text":"<pre><code>get_global_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/functions.html#eop-metadata","title":"EOP Metadata","text":""},{"location":"library_api/eop/functions.html#get_global_eop_type","title":"get_global_eop_type","text":"<p>Get the type of global EOP provider (\"file\" or \"static\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_type","title":"get_global_eop_type  <code>builtin</code>","text":"<pre><code>get_global_eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_initialization","title":"get_global_eop_initialization","text":"<p>Check if global EOP provider has been initialized.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_initialization","title":"get_global_eop_initialization  <code>builtin</code>","text":"<pre><code>get_global_eop_initialization() -&gt; bool\n</code></pre> <p>Check if the global EOP provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if global EOP provider is initialized</p>"},{"location":"library_api/eop/functions.html#get_global_eop_interpolation","title":"get_global_eop_interpolation","text":"<p>Check if interpolation is enabled.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_interpolation","title":"get_global_eop_interpolation  <code>builtin</code>","text":"<pre><code>get_global_eop_interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled in the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/functions.html#get_global_eop_extrapolation","title":"get_global_eop_extrapolation","text":"<p>Get extrapolation method (\"Hold\", \"Zero\", or \"Error\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_extrapolation","title":"get_global_eop_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_eop_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_len","title":"get_global_eop_len","text":"<p>Get number of EOP data points in provider.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_len","title":"get_global_eop_len  <code>builtin</code>","text":"<pre><code>get_global_eop_len() -&gt; int\n</code></pre> <p>Get the number of EOP data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_min","title":"get_global_eop_mjd_min","text":"<p>Get minimum (earliest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_min","title":"get_global_eop_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_max","title":"get_global_eop_mjd_max","text":"<p>Get maximum (latest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_max","title":"get_global_eop_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod","text":"<p>Get MJD of last LOD (Length of Day) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy","text":"<p>Get MJD of last dX/dY (celestial pole offset) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p>"},{"location":"library_api/eop/functions.html#downloading-eop-files","title":"Downloading EOP Files","text":""},{"location":"library_api/eop/functions.html#download_standard_eop_file","title":"download_standard_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_standard_eop_file","title":"download_standard_eop_file  <code>builtin</code>","text":"<pre><code>download_standard_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest standard Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre>"},{"location":"library_api/eop/functions.html#download_c04_eop_file","title":"download_c04_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_c04_eop_file","title":"download_c04_eop_file  <code>builtin</code>","text":"<pre><code>download_c04_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest C04 Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"library_api/eop/functions.html#usage-examples","title":"Usage Examples","text":""},{"location":"library_api/eop/functions.html#quick-start-recommended","title":"Quick Start (Recommended)","text":"<pre><code>import brahe as bh\n\n# Initialize EOP with recommended defaults - easiest way to get started!\nbh.initialize_eop()\n\n# Query EOP for specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\nut1_utc, pm_x, pm_y, dx, dy, lod = bh.get_global_eop(mjd)\nprint(f\"EOP for MJD {mjd}:\")\nprint(f\"  UT1-UTC: {ut1_utc:.6f} s\")\nprint(f\"  Polar Motion: ({pm_x*1e6:.3f}, {pm_y*1e6:.3f}) \u03bcrad\")\nprint(f\"  dX, dY: ({dx*1e6:.3f}, {dy*1e6:.3f}) \u03bcrad\")\nprint(f\"  LOD: {lod*1e3:.6f} ms\")\n</code></pre>"},{"location":"library_api/eop/functions.html#custom-provider-setup","title":"Custom Provider Setup","text":"<pre><code>import brahe as bh\n\n# Download and set up file-based EOP with custom settings\neop_file = bh.download_standard_eop_file(\"./data\")\nprovider = bh.FileEOPProvider.from_standard_file(\n    eop_file,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n\n# Check provider status\nprint(f\"EOP Type: {bh.get_global_eop_type()}\")\nprint(f\"Data points: {bh.get_global_eop_len()}\")\nprint(f\"Date range: MJD {bh.get_global_eop_mjd_min():.1f} to {bh.get_global_eop_mjd_max():.1f}\")\nprint(f\"Interpolation: {bh.get_global_eop_interpolation()}\")\nprint(f\"Extrapolation: {bh.get_global_eop_extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/functions.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider</li> <li>StaticEOPProvider</li> <li>Frames - Frame transformations that use EOP</li> </ul>"},{"location":"library_api/eop/static_provider.html","title":"StaticEOPProvider","text":"<p>Built-in Earth Orientation Parameters for testing and offline use.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider","title":"StaticEOPProvider","text":"<pre><code>StaticEOPProvider()\n</code></pre> <p>Static Earth Orientation Parameter provider with constant values.</p> <p>Provides EOP data using fixed values that don't change with time. Useful for testing or scenarios where time-varying EOP data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static EOP provider with default values\neop = bh.StaticEOPProvider()\n\n# Create static EOP provider with zero values\neop_zero = bh.StaticEOPProvider.from_zero()\n\n# Create with custom values\neop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(eop_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Extrapolation method: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(ut1_utc: float, pm_x: float, pm_y: float, dx: float, dy: float, lod: float) -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ut1_utc</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> required <code>pm_x</code> <code>float</code> <p>Polar motion x-component in radians</p> required <code>pm_y</code> <code>float</code> <p>Polar motion y-component in radians</p> required <code>dx</code> <code>float</code> <p>Celestial pole offset dx in radians</p> required <code>dy</code> <code>float</code> <p>Celestial pole offset dy in radians</p> required <code>lod</code> <code>float</code> <p>Length of day offset in seconds</p> required <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with specified EOP values</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with custom values\neop = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,\n    pm_x=1e-6,\n    pm_y=2e-6,\n    dx=1e-7,\n    dy=1e-7,\n    lod=0.001\n)\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with all EOP values set to zero</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with all zeros (no corrections)\neop = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider()\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Interpolation enabled: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Is initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with dx/dy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Maximum MJD: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#overview","title":"Overview","text":"<p><code>StaticEOPProvider</code> provides built-in historical EOP data that doesn't require external files. Useful for testing, examples, or when internet access is unavailable.</p> <p>Module: <code>brahe.eop</code></p> <p>Use Cases: - Unit testing - Examples and tutorials - Offline applications - Quick prototyping</p> <p>Limitations: - Fixed historical data (not updated) - Less accurate than file-based providers - Not suitable for production applications requiring current data</p>"},{"location":"library_api/eop/static_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/static_provider.html#zero-values","title":"Zero Values","text":"<pre><code>import brahe as bh\n\n# All EOP values set to zero\nprovider = bh.StaticEOPProvider.from_zero()\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#custom-values","title":"Custom Values","text":"<pre><code>import brahe as bh\n\n# Specify custom EOP values\nprovider = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,      # UT1-UTC offset (seconds)\n    pm_x=0.0001,      # Polar motion X (radians)\n    pm_y=0.0001,      # Polar motion Y (radians)\n    dx=0.00001,       # Celestial pole offset dX (radians)\n    dy=0.00001,       # Celestial pole offset dY (radians)\n    lod=0.001         # Length of day offset (seconds)\n)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#default-values","title":"Default Values","text":"<pre><code>import brahe as bh\n\n# Use built-in default values\nprovider = bh.StaticEOPProvider()\n</code></pre>"},{"location":"library_api/eop/static_provider.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Set up static EOP for testing\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Perform frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ECI to ECEF transformation\npos_eci = [7000000.0, 0.0, 0.0]  # meters in ECI\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n\n# ECEF to ECI transformation\nvel_ecef = [0.0, 7500.0, 0.0]  # m/s in ECEF\nvel_eci = bh.position_ecef_to_eci(epoch, vel_ecef)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#when-to-use","title":"When to Use","text":"<p>\u2705 Use StaticEOPProvider for: - Unit tests - Documentation examples - Learning and prototyping - Applications where high accuracy isn't critical</p> <p>\u274c Don't use StaticEOPProvider for: - Production orbit determination - Precise tracking applications - Applications requiring current EOP data - High-accuracy simulations</p>"},{"location":"library_api/eop/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider - File-based EOP for production use</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations</li> </ul>"},{"location":"library_api/orbits/index.html","title":"Orbits","text":"<p>Module: <code>brahe.orbits</code></p> <p>Comprehensive tools for orbital mechanics computations and TLE handling.</p>"},{"location":"library_api/orbits/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Keplerian Elements - Functions for computing orbital properties and converting between anomaly types</li> <li>Two-Line Elements (TLE) - TLE parsing, validation, and conversion utilities</li> <li>Enumerations - Orbit-related enumerations (OrbitRepresentation, OrbitFrame, etc.)</li> </ul> <p>Note: Orbit propagators have been moved to the <code>brahe.propagators</code> module.</p>"},{"location":"library_api/orbits/altitude_functions.html","title":"Altitude and Period Functions","text":"<p>Functions for computing orbital altitudes and periods from orbital elements or state vectors.</p>"},{"location":"library_api/orbits/altitude_functions.html#orbital-period-from-state","title":"Orbital Period from State","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.orbital_period_from_state","title":"orbital_period_from_state  <code>builtin</code>","text":"<pre><code>orbital_period_from_state(state_eci: ndarray, gm: float) -&gt; float\n</code></pre> <p>Computes orbital period from an ECI state vector using the vis-viva equation.</p> <p>This function uses the vis-viva equation to compute the semi-major axis from the position and velocity, then calculates the orbital period.</p> <p>Parameters:</p> Name Type Description Default <code>state_eci</code> <code>ndarray</code> <p>ECI state vector [x, y, z, vx, vy, vz] in meters and meters/second.</p> required <code>gm</code> <code>float</code> <p>Gravitational parameter in m\u00b3/s\u00b2. Use GM_EARTH for Earth orbits.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Orbital period in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a circular orbit state at 500 km altitude\nr = bh.R_EARTH + 500e3\nv = np.sqrt(bh.GM_EARTH / r)\nstate_eci = np.array([r, 0, 0, 0, v, 0])\n\n# Compute orbital period from state\nperiod = bh.orbital_period_from_state(state_eci, bh.GM_EARTH)\nprint(f\"Period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#altitude-functions","title":"Altitude Functions","text":""},{"location":"library_api/orbits/altitude_functions.html#periapsis-and-apoapsis-general","title":"Periapsis and Apoapsis (General)","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.periapsis_altitude","title":"periapsis_altitude  <code>builtin</code>","text":"<pre><code>periapsis_altitude(a_or_oe: Union[float, array], e: float = None, *, r_body: float) -&gt; float\n</code></pre> <p>Calculate the altitude above a body's surface at periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>r_body</code> <code>float</code> <p>(keyword-only) The radius of the central body in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above the body's surface at periapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 500e3  # 500 km mean altitude\ne = 0.01  # slight eccentricity\nalt_peri = bh.periapsis_altitude(a, e, bh.R_EARTH)\nprint(f\"Periapsis altitude: {alt_peri/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 500e3, 0.01, np.radians(45), 0, 0, 0]\nalt_peri = bh.periapsis_altitude(oe, r_body=bh.R_EARTH)\nprint(f\"Periapsis altitude: {alt_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#brahe.apoapsis_altitude","title":"apoapsis_altitude  <code>builtin</code>","text":"<pre><code>apoapsis_altitude(a_or_oe: Union[float, array], e: float = None, *, r_body: float) -&gt; float\n</code></pre> <p>Calculate the altitude above a body's surface at apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>r_body</code> <code>float</code> <p>(keyword-only) The radius of the central body in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above the body's surface at apoapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_MOON + 100e3  # 100 km mean altitude\ne = 0.05  # moderate eccentricity\nalt_apo = bh.apoapsis_altitude(a, e, bh.R_MOON)\nprint(f\"Apoapsis altitude: {alt_apo/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_MOON + 100e3, 0.05, np.radians(30), 0, 0, 0]\nalt_apo = bh.apoapsis_altitude(oe, r_body=bh.R_MOON)\nprint(f\"Apoapsis altitude: {alt_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#perigee-and-apogee-earth-specific","title":"Perigee and Apogee (Earth-Specific)","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.perigee_altitude","title":"perigee_altitude  <code>builtin</code>","text":"<pre><code>perigee_altitude(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the altitude above Earth's surface at perigee.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above Earth's surface at perigee in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 420e3  # 420 km mean altitude\ne = 0.0005  # very nearly circular\nalt = bh.perigee_altitude(a, e)\nprint(f\"Perigee altitude: {alt/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 420e3, 0.0005, np.radians(51.6), 0, 0, 0]\nalt = bh.perigee_altitude(oe)\nprint(f\"Perigee altitude: {alt/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#brahe.apogee_altitude","title":"apogee_altitude  <code>builtin</code>","text":"<pre><code>apogee_altitude(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the altitude above Earth's surface at apogee.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above Earth's surface at apogee in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 26554000.0  # ~26554 km semi-major axis\ne = 0.7  # highly eccentric\nalt = bh.apogee_altitude(a, e)\nprint(f\"Apogee altitude: {alt/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [26554000.0, 0.7, np.radians(63.4), 0, 0, 0]\nalt = bh.apogee_altitude(oe)\nprint(f\"Apogee altitude: {alt/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/enums.html","title":"Orbit Enumerations","text":"<p>Enumerations for specifying orbit representation types and reference frames.</p>"},{"location":"library_api/orbits/enums.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies the type of orbital elements being used.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation","title":"OrbitRepresentation","text":"<pre><code>OrbitRepresentation()\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.CARTESIAN","title":"CARTESIAN  <code>class-attribute</code>","text":"<pre><code>CARTESIAN: Any = OrbitRepresentation(Cartesian)\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.KEPLERIAN","title":"KEPLERIAN  <code>class-attribute</code>","text":"<pre><code>KEPLERIAN: Any = OrbitRepresentation(Keplerian)\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#orbitframe","title":"OrbitFrame","text":""},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame","title":"OrbitFrame","text":"<pre><code>OrbitFrame()\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECEF","title":"ECEF  <code>class-attribute</code>","text":"<pre><code>ECEF: Any = OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECI","title":"ECI  <code>class-attribute</code>","text":"<pre><code>ECI: Any = OrbitFrame(Earth-Centered Inertial)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get the full name of the reference frame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable frame name</p>"},{"location":"library_api/orbits/enums.html#interpolationmethod","title":"InterpolationMethod","text":""},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod","title":"InterpolationMethod","text":"<pre><code>InterpolationMethod()\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.LINEAR","title":"LINEAR  <code>class-attribute</code>","text":"<pre><code>LINEAR: Any = InterpolationMethod.Linear\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator</li> <li>Trajectories</li> </ul>"},{"location":"library_api/orbits/keplerian.html","title":"Keplerian Elements","text":"<p>Functions for working with Keplerian orbital elements and computing orbital properties.</p>"},{"location":"library_api/orbits/keplerian.html#orbital-properties","title":"Orbital Properties","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis","title":"semimajor_axis  <code>builtin</code>","text":"<pre><code>semimajor_axis(n: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from Earth given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis from mean motion (typical LEO satellite)\nn = 0.001027  # radians/second (~15 revolutions/day)\na = bh.semimajor_axis(n, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_general","title":"semimajor_axis_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_general(n: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from a general body given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for Jupiter orbiter\nn = 0.0001  # radians/second\na = bh.semimajor_axis_general(n, bh.GM_JUPITER, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period","title":"semimajor_axis_from_orbital_period  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period(period: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for a 90-minute orbit\nperiod = 90 * 60.0  # 90 minutes in seconds\na = bh.semimajor_axis_from_orbital_period(period)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period_general","title":"semimajor_axis_from_orbital_period_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period_general(period: float, gm: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period for a general body.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for 2-hour Venus orbit\nperiod = 2 * 3600.0  # 2 hours in seconds\na = bh.semimajor_axis_from_orbital_period_general(period, bh.GM_VENUS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion","title":"mean_motion  <code>builtin</code>","text":"<pre><code>mean_motion(a_or_oe: Union[float, array], angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = bh.R_EARTH + 35786e3\nn = bh.mean_motion(a, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 35786e3, 0.001, np.radians(0), 0, 0, 0]\nn = bh.mean_motion(oe, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion_general","title":"mean_motion_general  <code>builtin</code>","text":"<pre><code>mean_motion_general(a_or_oe: Union[float, array], gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around a general body given a semi-major axis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = 4000000.0  # 4000 km semi-major axis\nn = bh.mean_motion_general(a, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n\n# Using Keplerian elements vector\noe = [4000000.0, 0.01, np.radians(30), 0, 0, 0]\nn = bh.mean_motion_general(oe, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period","title":"orbital_period  <code>builtin</code>","text":"<pre><code>orbital_period(a_or_oe: Union[float, array]) -&gt; float\n</code></pre> <p>Computes the orbital period of an object around Earth.</p> <p>Uses rastro.constants.GM_EARTH as the standard gravitational parameter for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = bh.R_EARTH + 400e3\nperiod = bh.orbital_period(a)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 400e3, 0.001, np.radians(51.6), 0, 0, 0]\nperiod = bh.orbital_period(oe)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period_general","title":"orbital_period_general  <code>builtin</code>","text":"<pre><code>orbital_period_general(a_or_oe: Union[float, array], gm: float) -&gt; float\n</code></pre> <p>Computes the orbital period of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = 1900000.0  # 1900 km semi-major axis\nperiod = bh.orbital_period_general(a, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n\n# Using Keplerian elements vector\noe = [1900000.0, 0.01, np.radians(45), 0, 0, 0]\nperiod = bh.orbital_period_general(oe, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_distance","title":"periapsis_distance  <code>builtin</code>","text":"<pre><code>periapsis_distance(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at periapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_peri = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [8000000.0, 0.2, np.radians(45), 0, 0, 0]\nr_peri = bh.periapsis_distance(oe)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_distance","title":"apoapsis_distance  <code>builtin</code>","text":"<pre><code>apoapsis_distance(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at apoapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_apo = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [8000000.0, 0.2, np.radians(45), 0, 0, 0]\nr_apo = bh.apoapsis_distance(oe)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_velocity","title":"periapsis_velocity  <code>builtin</code>","text":"<pre><code>periapsis_velocity(a_or_oe: Union[float, array], e: float = None, *, gm: float) -&gt; float\n</code></pre> <p>Computes the periapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at periapsis in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 5e11  # 5 AU semi-major axis (meters)\ne = 0.95  # highly elliptical\nv_peri = bh.periapsis_velocity(a, e, bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n\n# Using Keplerian elements vector\noe = [5e11, 0.95, np.radians(10), 0, 0, 0]\nv_peri = bh.periapsis_velocity(oe, gm=bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_velocity","title":"apoapsis_velocity  <code>builtin</code>","text":"<pre><code>apoapsis_velocity(a_or_oe: Union[float, array], e: float = None, *, gm: float) -&gt; float\n</code></pre> <p>Computes the apoapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apoapsis in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 10000000.0  # 10000 km semi-major axis\ne = 0.3\nv_apo = bh.apoapsis_velocity(a, e, bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n\n# Using Keplerian elements vector\noe = [10000000.0, 0.3, np.radians(30), 0, 0, 0]\nv_apo = bh.apoapsis_velocity(oe, gm=bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.perigee_velocity","title":"perigee_velocity  <code>builtin</code>","text":"<pre><code>perigee_velocity(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Computes the perigee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at perigee in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 26554000.0  # meters\ne = 0.72  # high eccentricity\nv_peri = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n\n# Using Keplerian elements vector\noe = [26554000.0, 0.72, np.radians(63.4), 0, 0, 0]\nv_peri = bh.perigee_velocity(oe)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apogee_velocity","title":"apogee_velocity  <code>builtin</code>","text":"<pre><code>apogee_velocity(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Computes the apogee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apogee in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 24400000.0  # meters\ne = 0.73  # high eccentricity\nv_apo = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n\n# Using Keplerian elements vector\noe = [24400000.0, 0.73, np.radians(7), 0, 0, 0]\nv_apo = bh.apogee_velocity(oe)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.sun_synchronous_inclination","title":"sun_synchronous_inclination  <code>builtin</code>","text":"<pre><code>sun_synchronous_inclination(a_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the inclination for a Sun-synchronous orbit around Earth based on the J2 gravitational perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination for a Sun synchronous orbit in degrees or radians.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 600e3\ne = 0.001  # nearly circular\ninc = bh.sun_synchronous_inclination(a, e, bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 600e3, 0.001, np.radians(97.8), 0, 0, 0]\ninc = bh.sun_synchronous_inclination(oe, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#anomaly-conversions","title":"Anomaly Conversions","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_mean","title":"anomaly_eccentric_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_mean(anm_ecc_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc_or_oe</code> <code>float or array</code> <p>Either the eccentric anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, E] from which <code>e</code> and <code>E</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_ecc_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nE = np.pi / 4  # 45 degrees eccentric anomaly\ne = 0.1  # eccentricity\nM = bh.anomaly_eccentric_to_mean(E, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n\n# Using Keplerian elements vector (with eccentric anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.1, np.radians(45), 0, 0, np.pi/4]\nM = bh.anomaly_eccentric_to_mean(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_true","title":"anomaly_eccentric_to_true  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_true(anm_ecc_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc_or_oe</code> <code>float or array</code> <p>Either the eccentric anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, E] from which <code>e</code> and <code>E</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_ecc_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nE = np.pi / 4  # 45 degrees eccentric anomaly\ne = 0.4  # eccentricity\nnu = bh.anomaly_eccentric_to_true(E, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n\n# Using Keplerian elements vector (with eccentric anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.4, np.radians(45), 0, 0, np.pi/4]\nnu = bh.anomaly_eccentric_to_true(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_eccentric","title":"anomaly_mean_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_eccentric(anm_mean_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean_or_oe</code> <code>float or array</code> <p>Either the mean anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, M] from which <code>e</code> and <code>M</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_mean_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nM = 1.5  # mean anomaly in radians\ne = 0.3  # eccentricity\nE = bh.anomaly_mean_to_eccentric(M, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n\n# Using Keplerian elements vector (with mean anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.3, np.radians(45), 0, 0, 1.5]\nE = bh.anomaly_mean_to_eccentric(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_true","title":"anomaly_mean_to_true  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_true(anm_mean_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean_or_oe</code> <code>float or array</code> <p>Either the mean anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, M] from which <code>e</code> and <code>M</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_mean_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nM = 2.0  # mean anomaly in radians\ne = 0.25  # eccentricity\nnu = bh.anomaly_mean_to_true(M, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n\n# Using Keplerian elements vector (with mean anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.25, np.radians(45), 0, 0, 2.0]\nnu = bh.anomaly_mean_to_true(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_eccentric","title":"anomaly_true_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_true_to_eccentric(anm_true_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true_or_oe</code> <code>float or array</code> <p>Either the true anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>e</code> and <code>\u03bd</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_true_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nnu = np.pi / 3  # 60 degrees true anomaly\ne = 0.2  # eccentricity\nE = bh.anomaly_true_to_eccentric(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n\n# Using Keplerian elements vector (with true anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.2, np.radians(45), 0, 0, np.pi/3]\nE = bh.anomaly_true_to_eccentric(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_mean","title":"anomaly_true_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_true_to_mean(anm_true_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true_or_oe</code> <code>float or array</code> <p>Either the true anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>e</code> and <code>\u03bd</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_true_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nnu = np.pi / 2  # 90 degrees true anomaly\ne = 0.15  # eccentricity\nM = bh.anomaly_true_to_mean(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n\n# Using Keplerian elements vector (with true anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.15, np.radians(45), 0, 0, np.pi/2]\nM = bh.anomaly_true_to_mean(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/tle.html","title":"Two-Line Element (TLE)","text":"<p>Functions for parsing, validating, and converting Two-Line Element sets.</p> <p>For propagating orbits from TLE data, use the <code>SGPPropagator</code> class.</p>"},{"location":"library_api/orbits/tle.html#tle-utility-functions","title":"TLE Utility Functions","text":""},{"location":"library_api/orbits/tle.html#brahe.orbits.epoch_from_tle","title":"epoch_from_tle  <code>builtin</code>","text":"<pre><code>epoch_from_tle(line1: str) -&gt; Epoch\n</code></pre> <p>Extract Epoch from TLE line 1</p> <p>Extracts and parses the epoch timestamp from the first line of TLE data. The epoch is returned in UTC time system.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Extracted epoch in UTC time system</p> <p>Examples:</p> <pre><code>line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\nepoch = epoch_from_tle(line1)\nepoch.year()\n</code></pre>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_from_tle","title":"keplerian_elements_from_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_from_tle(line1: str, line2: str) -&gt; Tuple\n</code></pre> <p>Extract Keplerian orbital elements from TLE lines.</p> <p>Extracts the standard six Keplerian orbital elements from Two-Line Element (TLE) data. Returns elements in standard order: [a, e, i, raan, argp, M] where angles are in radians.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing: - epoch (Epoch): Epoch of the TLE data. - elements (numpy.ndarray): Six Keplerian elements [a, e, i, raan, argp, M] where   a is semi-major axis in meters, e is eccentricity (dimensionless), and   i, raan, argp, M are in radians.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_to_tle","title":"keplerian_elements_to_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_to_tle(epoch: Epoch, elements: ndarray, norad_id: str) -&gt; Tuple\n</code></pre> <p>Convert Keplerian elements to TLE lines.</p> <p>Converts standard Keplerian orbital elements to Two-Line Element (TLE) format. Input angles should be in degrees for compatibility with TLE format.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>elements</code> <code>ndarray</code> <p>Keplerian elements [a (m), e, i (deg), raan (deg), argp (deg), M (deg)].</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.create_tle_lines","title":"create_tle_lines  <code>builtin</code>","text":"<pre><code>create_tle_lines(epoch: Epoch, inclination: float, raan: float, eccentricity: float, arg_perigee: float, mean_anomaly: float, mean_motion: float, norad_id: str, ephemeris_type: int, element_set_number: int, revolution_number: int, classification: str = None, intl_designator: str = None, first_derivative: float = None, second_derivative: float = None, bstar: float = None) -&gt; Tuple\n</code></pre> <p>Create complete TLE lines from all parameters.</p> <p>Creates Two-Line Element (TLE) lines from complete set of orbital and administrative parameters. Provides full control over all TLE fields including derivatives and drag terms.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless).</p> required <code>arg_perigee</code> <code>float</code> <p>Argument of periapsis in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <code>ephemeris_type</code> <code>int</code> <p>Ephemeris type (0-9).</p> required <code>element_set_number</code> <code>int</code> <p>Element set number.</p> required <code>revolution_number</code> <code>int</code> <p>Revolution number at epoch.</p> required <code>classification</code> <code>str</code> <p>Security classification. Defaults to ' '.</p> <code>None</code> <code>intl_designator</code> <code>str</code> <p>International designator. Defaults to ''.</p> <code>None</code> <code>first_derivative</code> <code>float</code> <p>First derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>second_derivative</code> <code>float</code> <p>Second derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>bstar</code> <code>float</code> <p>BSTAR drag term. Defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_line","title":"validate_tle_line  <code>builtin</code>","text":"<pre><code>validate_tle_line(line: str) -&gt; bool\n</code></pre> <p>Validate single TLE line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the line is valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_lines","title":"validate_tle_lines  <code>builtin</code>","text":"<pre><code>validate_tle_lines(line1: str, line2: str) -&gt; bool\n</code></pre> <p>Validate TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both lines are valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.calculate_tle_line_checksum","title":"calculate_tle_line_checksum  <code>builtin</code>","text":"<pre><code>calculate_tle_line_checksum(line: str) -&gt; int\n</code></pre> <p>Calculate TLE line checksum.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum value.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.parse_norad_id","title":"parse_norad_id  <code>builtin</code>","text":"<pre><code>parse_norad_id(norad_str: str) -&gt; int\n</code></pre> <p>Parse NORAD ID from string, handling both classic and Alpha-5 formats.</p> <p>Parameters:</p> Name Type Description Default <code>norad_str</code> <code>str</code> <p>NORAD ID string from TLE.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Parsed numeric NORAD ID.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_numeric_to_alpha5","title":"norad_id_numeric_to_alpha5  <code>builtin</code>","text":"<pre><code>norad_id_numeric_to_alpha5(norad_id: int) -&gt; str\n</code></pre> <p>Convert numeric NORAD ID to Alpha-5 format or pass through if in legacy range.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>Numeric NORAD ID (0-339999). IDs 0-99999 are passed through as numeric strings. IDs 100000-339999 are converted to Alpha-5 format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>For IDs 0-99999: numeric string (e.g., \"42\"). For IDs 100000-339999: Alpha-5 format ID (e.g., \"A0001\").</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_alpha5_to_numeric","title":"norad_id_alpha5_to_numeric  <code>builtin</code>","text":"<pre><code>norad_id_alpha5_to_numeric(alpha5_id: str) -&gt; int\n</code></pre> <p>Convert Alpha-5 NORAD ID to numeric format.</p> <p>Parameters:</p> Name Type Description Default <code>alpha5_id</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric NORAD ID.</p>"},{"location":"library_api/plots/index.html","title":"Plots","text":"<p>Module: <code>brahe.plots</code></p> <p>Visualization tools for astrodynamics data with support for matplotlib and plotly backends.</p>"},{"location":"library_api/plots/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Ground Track Plotting - Ground track visualization with communication cones and polygon zones</li> <li>Access Geometry Plotting - Polar plots and elevation profiles for access windows</li> <li>Orbital Trajectories - Time-series plots of orbital elements (Cartesian and Keplerian)</li> <li>3D Trajectory - 3D visualization of satellite trajectories in ECI frame</li> <li>Gabbard Diagram - Orbital period vs apogee/perigee altitude scatter plots</li> </ul>"},{"location":"library_api/plots/3d_trajectory.html","title":"3D Trajectory Visualization","text":""},{"location":"library_api/plots/3d_trajectory.html#brahe.plot_trajectory_3d","title":"plot_trajectory_3d","text":"<pre><code>plot_trajectory_3d(trajectories, time_range=None, units='km', normalize=False, view_azimuth=45.0, view_elevation=30.0, view_distance=None, show_earth=True, earth_texture=None, sphere_resolution_lon=1080, sphere_resolution_lat=540, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot 3D trajectory in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d73] or [N\u00d76] (positions in ECI) - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>normalize</code> <code>bool</code> <p>Normalize to Earth radii. Default: False</p> <code>False</code> <code>view_azimuth</code> <code>float</code> <p>Camera azimuth angle (degrees). Default: 45.0</p> <code>45.0</code> <code>view_elevation</code> <code>float</code> <p>Camera elevation angle (degrees). Default: 30.0</p> <code>30.0</code> <code>view_distance</code> <code>float</code> <p>Camera distance multiplier. Default: 2.5 (larger = further out)</p> <code>None</code> <code>show_earth</code> <code>bool</code> <p>Show Earth sphere at origin. Default: True</p> <code>True</code> <code>earth_texture</code> <code>str</code> <p>Texture to use for Earth sphere (plotly only). Options: - 'simple': Solid lightblue sphere (fast rendering) - 'blue_marble': NASA Blue Marble texture (packaged with brahe, default for plotly) - 'natural_earth_50m': Natural Earth 50m shaded relief (auto-downloads ~20MB) - 'natural_earth_10m': Natural Earth 10m shaded relief (auto-downloads ~180MB) Note: matplotlib always uses a simple solid sphere regardless of this setting. Default: 'blue_marble' for plotly</p> <code>None</code> <code>sphere_resolution_lon</code> <code>int</code> <p>Longitude resolution for textured sphere (plotly only). Higher values = better quality but slower rendering. Default: 1080</p> <code>1080</code> <code>sphere_resolution_lat</code> <code>int</code> <p>Latitude resolution for textured sphere (plotly only). Higher values = better quality but slower rendering. Default: 540</p> <code>540</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + bh.orbital_period(oe[0]), 60.0)\n\n# Plot 3D trajectory with matplotlib (simple sphere)\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    backend='matplotlib'\n)\n\n# Plot 3D trajectory with plotly (blue marble texture by default)\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    backend='plotly'\n)\n\n# Plot with explicit texture choice\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    earth_texture='natural_earth_50m',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html","title":"Access Geometry Plotting","text":""},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_polar","title":"plot_access_polar","text":"<pre><code>plot_access_polar(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], min_elevation=0.0, num_samples=None, time_step=5.0, elevation_mask=None, backend='matplotlib', width=None, height=None, radial_tick_values=None, radial_tick_labels=None, radial_range=None, radial_tick_offset=8) -&gt; object\n</code></pre> <p>Plot access window geometry in polar coordinates (azimuth/elevation).</p> <p>Polar coordinates: - Radius: 90\u00b0 - elevation (zenith at center, horizon at edge) - Theta: Azimuth (North at top, clockwise)</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>min_elevation</code> <code>float</code> <p>Minimum elevation for plot edge (degrees). Default: 0.0</p> <code>0.0</code> <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified.</p> <code>5.0</code> <code>elevation_mask</code> <code>float, callable, or array</code> <p>Elevation mask to visualize. Can be: - float: Constant elevation angle (degrees) - callable: Function taking azimuth (degrees) returning elevation (degrees) - array: Elevation values at each azimuth (evaluated at 360 points around horizon)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>radial_tick_values</code> <code>array - like</code> <p>Custom radial tick positions (in radius units: 90-elevation). Default: [15, 30, 45, 60, 75, 90] (corresponding to elevations 75\u00b0, 60\u00b0, 45\u00b0, 30\u00b0, 15\u00b0, 0\u00b0)</p> <code>None</code> <code>radial_tick_labels</code> <code>array - like</code> <p>Custom labels for radial ticks. Default: [\"75\u00b0\", \"60\u00b0\", \"45\u00b0\", \"30\u00b0\", \"15\u00b0\", \"0\u00b0\"]</p> <code>None</code> <code>radial_range</code> <code>tuple</code> <p>(min, max) range for radial axis. Default: (0, 90) for matplotlib, auto-calculated for plotly to accommodate offset ticks</p> <code>None</code> <code>radial_tick_offset</code> <code>float</code> <p>Offset for radial tick positions in plotly (to avoid overlapping with circle lines). Default: 3. Set to 0 for no offset. Only applies to plotly.</p> <code>8</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot first access window\nfig = bh.plot_access_polar(\n    [{\"access_window\": windows[0], \"propagator\": prop, \"label\": \"Pass 1\"}],\n    min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_elevation","title":"plot_access_elevation","text":"<pre><code>plot_access_elevation(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], num_samples=None, time_step=5.0, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot elevation angle vs time for access windows.</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified. - label (str, optional): Legend label</p> <code>5.0</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: 1400</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: 700</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup (same as polar plot example)\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot elevation profile\nfig = bh.plot_access_elevation(\n    [{\"access_window\": w, \"propagator\": prop, \"label\": f\"Pass {i+1}\"} for i, w in enumerate(windows[:3])],\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_elevation_azimuth","title":"plot_access_elevation_azimuth","text":"<pre><code>plot_access_elevation_azimuth(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], num_samples=None, time_step=5.0, elevation_mask=None, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot elevation vs azimuth for access windows (observed horizon plot).</p> <p>Shows the satellite's path across the sky as elevation angle vs azimuth angle, providing a \"view from the ground\" perspective of the satellite's trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified.</p> <code>5.0</code> <code>elevation_mask</code> <code>float, callable, or array</code> <p>Elevation mask to visualize. Can be: - float: Constant elevation angle (degrees) - callable: Function taking azimuth (degrees) returning elevation (degrees) - array: Elevation values at each azimuth (evaluated at 360 points)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: 1400</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: 700</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Sinusoidal elevation mask\nmask_fn = lambda az: 15.0 + 10.0 * np.sin(np.radians(2 * az))\n\n# Plot elevation vs azimuth\nfig = bh.plot_access_elevation_azimuth(\n    [{\"access_window\": w, \"propagator\": prop, \"label\": f\"Pass {i+1}\"} for i, w in enumerate(windows[:3])],\n    elevation_mask=mask_fn,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/gabbard.html","title":"Gabbard Diagram","text":"<p>Gabbard diagrams visualize satellite populations and debris clouds by plotting orbital period versus apogee/perigee altitude. These plots are particularly useful for analyzing satellite breakup events and orbital debris distributions.</p>"},{"location":"library_api/plots/gabbard.html#brahe.plot_gabbard_diagram","title":"plot_gabbard_diagram","text":"<pre><code>plot_gabbard_diagram(objects, epoch=None, altitude_units: str = 'km', period_units: str = 'min', backend: str = 'matplotlib', width=None, height=None) -&gt; Union[Figure, Figure]\n</code></pre> <p>Plot Gabbard diagram showing orbital period vs apogee/perigee altitude.</p> <p>A Gabbard diagram is a scatter plot used to visualize satellite populations and debris clouds, plotting each object's apogee and perigee altitudes against its orbital period. This visualization is particularly useful for analyzing satellite breakup events and orbital debris distributions.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>list</code> <p>List of objects to plot. Can be: - List of Propagator objects (SGPPropagator or KeplerianPropagator) - List of numpy arrays (state vectors or Keplerian elements) with format specified - List of dicts with keys:     - objects: List of propagators or states     - format (str, optional): 'ECI', 'ECEF', or 'Keplerian' (required for state arrays)     - color (str, optional): Marker color     - marker (str, optional): Marker style     - label (str, optional): Legend label</p> required <code>epoch</code> <code>Epoch</code> <p>Epoch to evaluate propagator states. If None, uses current state.</p> <code>None</code> <code>altitude_units</code> <code>str</code> <p>'km' or 'm'. Default: 'km'</p> <code>'km'</code> <code>period_units</code> <code>str</code> <p>'min' or 's'. Default: 'min'</p> <code>'min'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Figure, Figure]</code> <p>Union[matplotlib.figure.Figure, plotly.graph_objects.Figure]: Figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Set up EOP\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\n# Create propagators for debris cloud\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Parent orbit\noe_parent = np.array([bh.R_EARTH + 215e3, 0.1, np.radians(97.8), 0.0, 0.0, 0.0])\n\n# Simulate debris with various delta-v\ndebris = []\nfor dv in np.linspace(-100, 100, 50):  # m/s delta-v\n    oe = oe_parent.copy()\n    # Simplified: adjust semi-major axis based on delta-v\n    oe[0] += dv * 1000  # rough approximation\n    oe[1] = max(0.001, min(0.3, oe[1] + np.random.normal(0, 0.05)))\n    state = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\n    debris.append(prop)\n\n# Plot Gabbard diagram\nfig = bh.plot_gabbard_diagram(\n    debris,\n    epoch=epoch,\n    altitude_units='km',\n    period_units='min',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/ground_tracks.html","title":"Ground Track Plotting","text":""},{"location":"library_api/plots/ground_tracks.html#brahe.plot_groundtrack","title":"plot_groundtrack","text":"<pre><code>plot_groundtrack(trajectories=None, ground_stations=None, zones=None, gs_cone_altitude=500000.0, gs_min_elevation=10.0, basemap='natural_earth', show_borders=True, show_coastlines=True, border_width=0.5, show_grid=False, show_ticks=True, show_legend=False, extent=None, backend='matplotlib') -&gt; object\n</code></pre> <p>Plot ground tracks with optional ground stations and polygon zones.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array - color (str, optional): Line color - line_width (float, optional): Line width - track_length (float, optional): Length of track to display - track_units (str, optional): Units for track_length - \"orbits\" or \"seconds\". Default: \"orbits\"</p> <code>None</code> <code>ground_stations</code> <code>list of dict</code> <p>List of ground station groups, each with: - stations: List of PointLocation or (lat, lon) tuples - color (str, optional): Station and cone color - alpha (float, optional): Cone transparency - point_size (float, optional): Station marker size - show_ring (bool, optional): Show outer ring - ring_color (str, optional): Ring color - ring_width (float, optional): Ring line width</p> <code>None</code> <code>zones</code> <code>list of dict</code> <p>List of polygon zone groups, each with: - zone: PolygonLocation - fill (bool, optional): Fill interior - fill_alpha (float, optional): Fill transparency - fill_color (str, optional): Fill color - edge (bool, optional): Show edge - edge_color (str, optional): Edge color - points (bool, optional): Show vertices</p> <code>None</code> <code>gs_cone_altitude</code> <code>float</code> <p>Assumed satellite altitude for cone calculation (m). Default: 500e3</p> <code>500000.0</code> <code>gs_min_elevation</code> <code>float</code> <p>Minimum elevation angle (degrees). Default: 10.0</p> <code>10.0</code> <code>basemap</code> <code>str</code> <p>Basemap style - \"natural_earth\", \"stock\", or None. Default: \"natural_earth\"</p> <code>'natural_earth'</code> <code>show_borders</code> <code>bool</code> <p>Show country borders. Default: True</p> <code>True</code> <code>show_coastlines</code> <code>bool</code> <p>Show coastlines. Default: True</p> <code>True</code> <code>border_width</code> <code>float</code> <p>Border line width. Default: 0.5</p> <code>0.5</code> <code>show_grid</code> <code>bool</code> <p>Show lat/lon grid. Default: False</p> <code>False</code> <code>show_ticks</code> <code>bool</code> <p>Show lat/lon tick marks. Default: True</p> <code>True</code> <code>show_legend</code> <code>bool</code> <p>Show legend (plotly only). Default: False</p> <code>False</code> <code>extent</code> <code>list</code> <p>[lon_min, lon_max, lat_min, lat_max] to zoom. Default: None (global)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a simple LEO trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Define ground stations\nstations_aws = [\n    bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0),  # NYC\n    bh.PointLocation(np.radians(37.7749), np.radians(-122.4194), 0.0),  # SF\n]\n\nstations_ksat = [\n    bh.PointLocation(np.radians(78.2232), np.radians(15.6267), 0.0),  # Svalbard\n]\n\n# Plot with per-group configuration\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"track_length\": 2, \"track_units\": \"orbits\"}],\n    ground_stations=[\n        {\"stations\": stations_aws, \"color\": \"orange\", \"alpha\": 0.3},\n        {\"stations\": stations_ksat, \"color\": \"blue\", \"alpha\": 0.3},\n    ],\n    gs_cone_altitude=500e3,\n    gs_min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/ground_tracks.html#brahe.split_ground_track_at_antimeridian","title":"split_ground_track_at_antimeridian","text":"<pre><code>split_ground_track_at_antimeridian(lons, lats, threshold: float = 180.0) -&gt; List[Tuple]\n</code></pre> <p>Split a ground track into segments at antimeridian crossings.</p> <p>When a satellite ground track crosses the antimeridian (\u00b1180\u00b0 longitude), plotting libraries may draw an incorrect line across the entire map. This function detects such crossings and splits the track into separate segments that can be plotted individually.</p> <p>Parameters:</p> Name Type Description Default <code>lons</code> <code>list or ndarray</code> <p>Longitude values in degrees</p> required <code>lats</code> <code>list or ndarray</code> <p>Latitude values in degrees (same length as lons)</p> required <code>threshold</code> <code>float</code> <p>Longitude jump threshold in degrees to detect wraparound. Default: 180.0</p> <code>180.0</code> <p>Returns:</p> Type Description <code>List[Tuple]</code> <p>List[Tuple]: List of (lon_segment, lat_segment) tuples, where each tuple contains arrays for one continuous segment</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground track that crosses antimeridian\nlons = [170, 175, 180, -175, -170]\nlats = [10, 15, 20, 25, 30]\n\n# Split into segments\nsegments = bh.split_ground_track_at_antimeridian(lons, lats)\n\n# Plot each segment\nimport matplotlib.pyplot as plt\nfor lon_seg, lat_seg in segments:\n    plt.plot(lon_seg, lat_seg)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html","title":"Orbital Trajectory Plotting","text":""},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_cartesian_trajectory","title":"plot_cartesian_trajectory","text":"<pre><code>plot_cartesian_trajectory(trajectories, time_range=None, position_units='km', velocity_units='km/s', backend='matplotlib', show_title=False, show_grid=False, matplotlib_config=None, plotly_config=None, width=None, height=None) -&gt; object\n</code></pre> <p>Plot Cartesian orbital elements (position and velocity) vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: x, y, z positions - Row 2: vx, vy, vz velocities</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>position_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>velocity_units</code> <code>str</code> <p>'m/s' or 'km/s'. Default: 'km/s'</p> <code>'km/s'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>show_title</code> <code>bool</code> <p>Whether to display plot title. Default: False</p> <code>False</code> <code>show_grid</code> <code>bool</code> <p>Whether to display grid lines. Default: False</p> <code>False</code> <code>matplotlib_config</code> <code>dict</code> <p>Matplotlib-specific configuration: - legend_subplot (tuple): (row, col) of subplot for legend. Default: (0, 0) - legend_loc (str): Legend location. Default: 'best'   Options: 'best', 'upper right', 'upper left', 'lower left', 'lower right',            'right', 'center left', 'center right', 'lower center', 'upper center', 'center' - dark_mode (bool): Apply dark mode styling. Default: False - ylabel_pad (float): Padding for y-axis labels. Default: 10 - figsize (tuple): Figure size (width, height). Default: (15, 10)</p> <code>None</code> <code>plotly_config</code> <code>dict</code> <p>Plotly-specific configuration (reserved for future use)</p> <code>None</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Cartesian elements with legend in upper right of Z position subplot\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    position_units='km',\n    velocity_units='km/s',\n    backend='matplotlib',\n    matplotlib_config={'legend_subplot': (0, 2), 'legend_loc': 'upper right'}\n)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_keplerian_trajectory","title":"plot_keplerian_trajectory","text":"<pre><code>plot_keplerian_trajectory(trajectories, time_range=None, angle_units='deg', sma_units='km', normalize_angles=False, backend='matplotlib', show_title=False, show_grid=False, matplotlib_config=None, plotly_config=None, width=None, height=None) -&gt; object\n</code></pre> <p>Plot Keplerian orbital elements vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: a (semi-major axis), e (eccentricity), i (inclination) - Row 2: \u03a9 (RAAN), \u03c9 (argument of periapsis), M (mean anomaly)</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] as [a, e, i, \u03a9, \u03c9, M] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>angle_units</code> <code>str</code> <p>'rad' or 'deg'. Default: 'deg'</p> <code>'deg'</code> <code>sma_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>normalize_angles</code> <code>bool</code> <p>If True, wrap angles to [0, 2\u03c0) or [0, 360\u00b0). Default: False</p> <code>False</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>show_title</code> <code>bool</code> <p>Whether to display plot title. Default: False</p> <code>False</code> <code>show_grid</code> <code>bool</code> <p>Whether to display grid lines. Default: False</p> <code>False</code> <code>matplotlib_config</code> <code>dict</code> <p>Matplotlib-specific configuration: - legend_subplot (tuple): (row, col) of subplot for legend. Default: (0, 0) - legend_loc (str): Legend location. Default: 'best'   Options: 'best', 'upper right', 'upper left', 'lower left', 'lower right',            'right', 'center left', 'center right', 'lower center', 'upper center', 'center' - dark_mode (bool): Apply dark mode styling. Default: False - ylabel_pad (float): Padding for y-axis labels. Default: 10 - figsize (tuple): Figure size (width, height). Default: (15, 10) - set_angle_ylim (bool): Set y-axis limits to [0, 360\u00b0] or [0, 2\u03c0]. Default: False - set_eccentricity_ylim (bool): Set y-axis limits to [0, 1]. Default: False</p> <code>None</code> <code>plotly_config</code> <code>dict</code> <p>Plotly-specific configuration: - set_angle_ylim (bool): Set y-axis limits to [0, 360\u00b0] or [0, 2\u03c0]. Default: False - set_eccentricity_ylim (bool): Set y-axis limits to [0, 1]. Default: False</p> <code>None</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\n\nprop = bh.KeplerianPropagator.from_eci(epoch, oe, bh.AngleFormat.DEGREES, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Keplerian elements\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    angle_units='deg',\n    sma_units='km',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/propagators/index.html","title":"Propagators","text":"<p>Module: <code>brahe.propagators</code></p> <p>Orbit propagators for predicting satellite positions over time.</p>"},{"location":"library_api/propagators/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>KeplerianPropagator - Analytical two-body orbit propagator</li> <li>SGPPropagator - SGP4/SDP4 orbit propagator for TLE data</li> </ul>"},{"location":"library_api/propagators/keplerian_propagator.html","title":"Keplerian Propagator","text":"<p>Analytical two-body orbit propagator using Keplerian orbital elements.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator","title":"KeplerianPropagator","text":"<pre><code>KeplerianPropagator()\n</code></pre> <p>Python wrapper for KeplerianPropagator (new architecture) Keplerian orbit propagator using two-body dynamics.</p> <p>The Keplerian propagator implements ideal two-body orbital mechanics without perturbations. It's fast and accurate for short time spans but doesn't account for real-world effects like drag, J2, solar radiation pressure, etc.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initial epoch and orbital elements\nepc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\n\n# Create propagator from Keplerian elements\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\n)\n\n# Propagate forward one orbit\nperiod = bh.orbital_period(oe[0])\nepc_future = epc0 + period\nstate = prop.state(epc_future)\nprint(f\"State after one orbit: {state}\")\n\n# Create from Cartesian state\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\nprop2 = bh.KeplerianPropagator(\n    epc0, x_cart, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    bh.AngleFormat.RADIANS, 60.0\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Epoch\n</code></pre> <p>Get initial epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Initial propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\ntraj = prop.trajectory\nprint(f\"Trajectory contains {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_ecef","title":"from_ecef  <code>builtin</code>","text":"<pre><code>from_ecef(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECEF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECEF frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECI frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_keplerian","title":"from_keplerian  <code>builtin</code>","text":"<pre><code>from_keplerian(epoch: Epoch, elements: ndarray, angle_format: AngleFormat, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>elements</code> <code>ndarray</code> <p>6-element Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format (Degrees or Radians).</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_id(12345)\nprint(f\"ID: {prop.get_id()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_name(\"MySat\")\nprint(f\"Name: {prop.get_name()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_new_uuid()\nprint(f\"UUID: {prop.get_uuid()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)  # Take 10 steps (600 seconds total)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 3600.0  # Propagate to 1 hour ahead\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\nprop.reset()  # Return to initial epoch and state\nprint(f\"Reset to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_age(3600.0)  # Keep only states within 1 hour\nprop.propagate_to(epc + 7200.0)  # Propagate 2 hours\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_size(100)  # Keep only 100 most recent states\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_initial_conditions","title":"set_initial_conditions  <code>method descriptor</code>","text":"<pre><code>set_initial_conditions(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Set initial conditions.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame.</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\n\n# Change initial conditions to a different orbit\nnew_oe = np.array([bh.R_EARTH + 800e3, 0.02, 1.2, 0.5, 0.3, 0.0])\nnew_state = bh.state_osculating_to_cartesian(new_oe, bh.AngleFormat.RADIANS)\nnew_epc = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop.set_initial_conditions(new_epc, new_state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, bh.AngleFormat.RADIANS)\nprint(f\"New initial epoch: {prop.initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_step_size","title":"set_step_size  <code>method descriptor</code>","text":"<pre><code>set_step_size(new_step_size: float) -&gt; Any\n</code></pre> <p>Set step size in seconds (explicit method).</p> <p>Parameters:</p> Name Type Description Default <code>new_step_size</code> <code>float</code> <p>New step size in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\npropagator.set_step_size(120.0)  # Can use explicit method\n# or propagator.step_size = 120.0  # Can use property\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_as_osculating_elements","title":"states_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>states_as_osculating_elements(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_ecef","title":"states_ecef  <code>method descriptor</code>","text":"<pre><code>states_ecef(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECEF state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step()  # Advance by default step_size (60 seconds)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step_by(120.0)  # Advance by 120 seconds\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 300.0  # Target 5 minutes ahead\nprop.step_past(target)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; KeplerianPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; KeplerianPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with identity set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000e3, 0.001, 0.9, 0.0, 0.0, 0.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc, oe, bh.AngleFormat.RADIANS, 60.0\n).with_name(\"My Orbit\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; KeplerianPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#overview","title":"Overview","text":"<p>The Keplerian propagator provides fast, analytical orbit propagation for unperturbed two-body motion. It uses closed-form solutions to Kepler's equations for orbital element propagation.</p> <p>Key Features: - Fast analytical propagation (no numerical integration) - Perfect for preliminary analysis and mission design - No perturbations (atmospheric drag, J2, third-body, etc.) - Suitable for high-altitude orbits where perturbations are minimal</p> <p>Module: <code>brahe.orbits</code></p> <p>When to Use: - Preliminary orbit analysis - High-altitude orbits (GEO, cislunar) - Short propagation times where perturbations are negligible - Educational purposes</p> <p>When NOT to Use: - LEO orbits requiring accuracy beyond a few days - When atmospheric drag is significant - When J2 perturbations matter - Precise orbit determination applications</p>"},{"location":"library_api/propagators/keplerian_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Initial orbital elements [a, e, i, \u03a9, \u03c9, M] in SI units (m, rad)\n# Example: Geostationary orbit\na = 42164000.0        # Semi-major axis (m)\ne = 0.0001            # Eccentricity\ni = 0.0 * bh.DEG2RAD  # Inclination (rad)\nraan = 0.0            # Right ascension of ascending node (rad)\nargp = 0.0            # Argument of periapsis (rad)\nM = 0.0               # Mean anomaly (rad)\n\nelements = np.array([a, e, i, raan, argp, M])\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create propagator\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI,\n    gm=bh.GM_EARTH\n)\n\n# Propagate to a future time\nfuture_epoch = epoch + 86400.0  # 1 day later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz]\n\n# Propagate to multiple times\ntimes = np.linspace(0, 7*86400, 100)  # 1 week in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)\n\nprint(f\"Propagated to {len(states)} epochs\")\nprint(f\"Final position: {states[-1][:3]} m\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#orbital-elements","title":"Orbital Elements","text":"<p>The propagator accepts orbital elements in the following order: 1. a - Semi-major axis (meters) 2. e - Eccentricity (dimensionless) 3. i - Inclination (radians) 4. \u03a9 - Right ascension of ascending node (radians) 5. \u03c9 - Argument of periapsis (radians) 6. M or \u03bd - Mean anomaly or true anomaly (radians)</p> <p>Use <code>OrbitRepresentation</code> to specify element type: - <code>MEAN_ELEMENTS</code> - Mean orbital elements with mean anomaly - <code>OSCULATING_ELEMENTS</code> - Osculating elements with true anomaly</p>"},{"location":"library_api/propagators/keplerian_propagator.html#see-also","title":"See Also","text":"<ul> <li>SGPPropagator - SGP4/SDP4 propagator for TLE data</li> <li>Keplerian Elements - Orbital element conversion functions</li> <li>OrbitRepresentation - Element type specification</li> </ul>"},{"location":"library_api/propagators/sgp_propagator.html","title":"SGP Propagator","text":"<p>The SGP4/SDP4 propagator for satellite orbit propagation using Two-Line Element (TLE) data.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator","title":"SGPPropagator","text":"<pre><code>SGPPropagator()\n</code></pre> <p>Python wrapper for SGPPropagator (replaces TLE) SGP4/SDP4 satellite propagator using TLE data.</p> <p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using Two-Line Element (TLE) orbital data. This is the standard model used for tracking objects in Earth orbit.</p> Example <pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_eci = prop.state(epc)\nprint(f\"Position: {state_eci[:3]}\")\nprint(f\"Velocity: {state_eci[3:]}\")\n\n# Propagate multiple epochs\nepochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\nstates = prop.states(epochs)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.arg_perigee","title":"arg_perigee  <code>property</code>","text":"<pre><code>arg_perigee: float\n</code></pre> <p>Get argument of periapsis at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Argument of periapsis in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nargp = prop.arg_perigee\nprint(f\"Argument of periapsis: {argp:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.step()\nprint(f\"Current epoch: {propagator.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.eccentricity","title":"eccentricity  <code>property</code>","text":"<pre><code>eccentricity: float\n</code></pre> <p>Get eccentricity at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentricity (dimensionless).</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\necc = prop.eccentricity\nprint(f\"Eccentricity: {ecc:.6f}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Epoch\n</code></pre> <p>Get TLE epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch of the TLE data.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.inclination","title":"inclination  <code>property</code>","text":"<pre><code>inclination: float\n</code></pre> <p>Get inclination at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\ninc = prop.inclination\nprint(f\"Inclination: {inc:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.mean_anomaly","title":"mean_anomaly  <code>property</code>","text":"<pre><code>mean_anomaly: float\n</code></pre> <p>Get mean anomaly at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nma = prop.mean_anomaly\nprint(f\"Mean anomaly: {ma:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.norad_id","title":"norad_id  <code>property</code>","text":"<pre><code>norad_id: int\n</code></pre> <p>Get NORAD ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>NORAD catalog ID.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.right_ascension","title":"right_ascension  <code>property</code>","text":"<pre><code>right_ascension: float\n</code></pre> <p>Get right ascension of ascending node at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Right ascension of ascending node (RAAN) in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nraan = prop.right_ascension\nprint(f\"RAAN: {raan:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: str\n</code></pre> <p>Get satellite name (if available).</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: Satellite name if provided.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Satellite: {propagator.satellite_name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.semi_major_axis","title":"semi_major_axis  <code>property</code>","text":"<pre><code>semi_major_axis: float\n</code></pre> <p>Get semi-major axis at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nsma = prop.semi_major_axis\nprint(f\"Semi-major axis: {sma:.3f} m\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(f\"Step size: {propagator.step_size} seconds\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.propagate_steps(100)\ntraj = prop.trajectory\nprint(f\"Trajectory has {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_3le","title":"from_3le  <code>builtin</code>","text":"<pre><code>from_3le(name: str, line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from 3-line TLE format (with satellite name).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (line 0).</p> required <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_tle","title":"from_tle  <code>builtin</code>","text":"<pre><code>from_tle(line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_elements","title":"get_elements  <code>method descriptor</code>","text":"<pre><code>get_elements(angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get Keplerian orbital elements from TLE data.</p> <p>Extracts the Keplerian elements directly from the TLE lines used to initialize this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements (DEGREES or RADIANS).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Keplerian elements [a, e, i, \u03a9, \u03c9, M] where: - a: semi-major axis [m] - e: eccentricity [dimensionless] - i: inclination [rad or deg] - \u03a9: right ascension of ascending node [rad or deg] - \u03c9: argument of periapsis [rad or deg] - M: mean anomaly [rad or deg]</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements in degrees\noe_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nprint(f\"Inclination: {oe_deg[2]:.4f} degrees\")\n\n# Get elements in radians\noe_rad = prop.get_elements(bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {oe_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_id(25544)\nprint(f\"ID: {prop.get_id()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Name: {prop.get_name()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_new_uuid()\nprint(f\"UUID: {prop.get_uuid()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\nprop.propagate_steps(10)  # Advance by 10 steps (600 seconds)\nprint(f\"After 10 steps: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ninitial_epoch = prop.epoch\nprop.propagate_steps(100)\nprop.reset()\nprint(f\"Reset to: {prop.current_epoch == initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_age(86400.0)  # Keep 1 day of history\nprint(\"Trajectory limited to 24 hours of states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_size(1000)\nprint(\"Trajectory limited to 1000 states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_output_format","title":"set_output_format  <code>method descriptor</code>","text":"<pre><code>set_output_format(frame: OrbitFrame, representation: OrbitRepresentation, angle_format: Union[AngleFormat, None]) -&gt; Any\n</code></pre> <p>Set output format (frame, representation, and angle format).</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>OrbitFrame</code> <p>Output frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>Output representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian (None for Cartesian).</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_step_size","title":"set_step_size  <code>method descriptor</code>","text":"<pre><code>set_step_size(new_step_size: float) -&gt; Any\n</code></pre> <p>Set step size in seconds (explicit method).</p> <p>Parameters:</p> Name Type Description Default <code>new_step_size</code> <code>float</code> <p>New step size in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.set_step_size(120.0)  # Can use explicit method\n# or propagator.step_size = 120.0  # Can use property\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get osculating elements at initial epoch\nepoch = prop.epoch\nelements_deg = prop.state_as_osculating_elements(epoch, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements_deg[0]/1000:.3f} km\")\nprint(f\"Inclination: {elements_deg[2]:.4f} degrees\")\n\n# Get elements in radians\nelements_rad = prop.state_as_osculating_elements(epoch, bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {elements_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_pef","title":"state_pef  <code>method descriptor</code>","text":"<pre><code>state_pef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in PEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in PEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_as_osculating_elements","title":"states_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>states_as_osculating_elements(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements at multiple epochs\nepoch0 = prop.epoch\nepochs = [epoch0 + i*3600.0 for i in range(10)]  # Every hour for 10 hours\nelements_list = prop.states_as_osculating_elements(epochs, bh.AngleFormat.DEGREES)\n\nfor i, elements in enumerate(elements_list):\n    print(f\"Hour {i}: a={elements[0]/1000:.3f} km, e={elements[1]:.6f}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step()  # Advance by default step_size\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step_by(120.0)  # Advance by 2 minutes\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 3600.0  # 1 hour later\nprop.step_past(target)\nprint(f\"Stepped past target\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; SGPPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; SGPPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with identity set.</p> Example <pre><code>import brahe as bh\nimport uuid\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nmy_uuid = str(uuid.uuid4())\nprop = bh.SGPPropagator.from_tle(line1, line2).with_identity(\"ISS\", my_uuid, 25544)\nprint(f\"Name: {prop.name}, ID: {prop.id}, UUID: {prop.uuid}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; SGPPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_name(\"My Satellite\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; SGPPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; SGPPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#overview","title":"Overview","text":"<p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using TLE orbital data. This is the standard model used for tracking objects in Earth orbit and is maintained by NORAD/Space Force.</p> <p>Key Features: - Industry-standard orbit propagation - Atmospheric drag modeling - Automatic selection between SGP4 (near-Earth) and SDP4 (deep-space) models - Compatible with standard TLE format</p> <p>Module: <code>brahe.orbits</code></p>"},{"location":"library_api/propagators/sgp_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator from TLE\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get current epoch\nepoch = prop.epoch()\n\n# Propagate to a specific time\nfuture_epoch = epoch + 3600.0  # 1 hour later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz] in TEME frame\n\n# Propagate to multiple times\nimport numpy as np\ntimes = np.linspace(0, 86400, 100)  # 1 day in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)  # Returns array of states\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>TLE - Two-Line Element format details</li> <li>Keplerian Elements - Orbital element functions</li> </ul>"},{"location":"library_api/time/index.html","title":"Time","text":"<p>Module: <code>brahe.time</code></p> <p>High-precision time system management and conversions.</p>"},{"location":"library_api/time/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Epoch Class - Core time representation supporting multiple time systems</li> <li>Time Conversions - Functions for converting between time systems and formats</li> </ul>"},{"location":"library_api/time/conversions.html","title":"Time Conversions","text":"<p>Functions for converting between different time systems and formats.</p>"},{"location":"library_api/time/conversions.html#time-system-offset-functions","title":"Time System Offset Functions","text":""},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_mjd","title":"time_system_offset_for_mjd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_mjd(mjd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from UTC to TAI at J2000 epoch\nmjd_j2000 = 51544.0\noffset = bh.time_system_offset_for_mjd(mjd_j2000, bh.TimeSystem.UTC, bh.TimeSystem.TAI)\nprint(f\"UTC to TAI offset: {offset} seconds\")\n# Output: UTC to TAI offset: 32.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_jd","title":"time_system_offset_for_jd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_jd(jd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from GPS to UTC at a specific Julian Date\njd = 2460000.0\noffset = bh.time_system_offset_for_jd(jd, bh.TimeSystem.GPS, bh.TimeSystem.UTC)\nprint(f\"GPS to UTC offset: {offset} seconds\")\n# Output: GPS to UTC offset: -18.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_datetime","title":"time_system_offset_for_datetime  <code>builtin</code>","text":"<pre><code>time_system_offset_for_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Gregorian calendar date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from TT to TAI on January 1, 2024\noffset = bh.time_system_offset_for_datetime(\n    2024, 1, 1, 0, 0, 0.0, 0.0,\n    bh.TimeSystem.TT, bh.TimeSystem.TAI\n)\nprint(f\"TT to TAI offset: {offset} seconds\")\n# Output: TT to TAI offset: -32.184 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#datetime-conversion-functions","title":"DateTime Conversion Functions","text":""},{"location":"library_api/time/conversions.html#brahe.datetime_to_jd","title":"datetime_to_jd  <code>builtin</code>","text":"<pre><code>datetime_to_jd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Julian Date\njd = bh.datetime_to_jd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460311.000000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.datetime_to_mjd","title":"datetime_to_mjd  <code>builtin</code>","text":"<pre><code>datetime_to_mjd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Modified Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Modified Julian Date\nmjd = bh.datetime_to_mjd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.500000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.jd_to_datetime","title":"jd_to_datetime  <code>builtin</code>","text":"<pre><code>jd_to_datetime(jd: float) -&gt; Tuple\n</code></pre> <p>Convert a Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Julian Date to Gregorian calendar\njd = 2460311.0\nyear, month, day, hour, minute, second, nanosecond = bh.jd_to_datetime(jd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.mjd_to_datetime","title":"mjd_to_datetime  <code>builtin</code>","text":"<pre><code>mjd_to_datetime(mjd: float) -&gt; Tuple\n</code></pre> <p>Convert a Modified Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Modified Julian Date to Gregorian calendar\nmjd = 60310.5\nyear, month, day, hour, minute, second, nanosecond = bh.mjd_to_datetime(mjd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html","title":"Epoch Class","text":"<p>The <code>Epoch</code> class is the foundational time representation in Brahe, providing comprehensive support for multiple time systems and high-precision time computations with nanosecond accuracy.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch","title":"Epoch","text":"<pre><code>Epoch()\n</code></pre> <p>Represents a specific instant in time.</p> <p>Epoch is the primary and preferred mechanism for representing time in brahe. It accurately represents, tracks, and compares instants in time with nanosecond precision.</p> <p>Internally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation was chosen to enable accurate time system conversions using the IAU SOFA library (which operates in days and fractional days) while maintaining high precision for small time differences. The structure uses Kahan summation to accurately handle running sums over long periods without losing accuracy to floating-point rounding errors.</p> <p>All arithmetic operations (addition, subtraction) use seconds as the default unit and return time differences in seconds.</p> <p>The Epoch constructor accepts multiple input formats for convenience:</p> <ul> <li>Date components: <code>Epoch(year, month, day)</code> - creates epoch at midnight</li> <li>Full datetime: <code>Epoch(year, month, day, hour, minute, second, nanosecond)</code> - full precision</li> <li>Partial datetime: <code>Epoch(year, month, day, hour)</code> or <code>Epoch(year, month, day, hour, minute)</code> etc.</li> <li>ISO 8601 string: <code>Epoch(\"2024-01-01T12:00:00Z\")</code> - parse from string</li> <li>Python datetime: <code>Epoch(datetime_obj)</code> - convert from Python datetime</li> <li>Copy constructor: <code>Epoch(other_epoch)</code> - create a copy</li> <li>Time system: All constructors accept optional <code>time_system=</code> keyword argument (default: UTC)</li> </ul> Example <pre><code>import brahe as bh\nfrom datetime import datetime\n\n# Multiple ways to create the same epoch\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\nepc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\nprint(epc1)\n# Output: 2024-01-01 12:00:00.000 UTC\n\n# Create epoch at midnight\nmidnight = bh.Epoch(2024, 1, 1)\nprint(midnight)\n# Output: 2024-01-01 00:00:00.000 UTC\n\n# Use different time systems\ngps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\nprint(gps_time)\n# Output: 2024-01-01 12:00:00.000 GPS\n\n# Perform arithmetic operations\nepoch2 = epc1 + 3600.0  # Add one hour (in seconds)\ndiff = epoch2 - epc1     # Difference in seconds\nprint(f\"Time difference: {diff} seconds\")\n# Output: Time difference: 3600.0 seconds\n\n# Legacy constructors still available\nepc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nepc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.time_system","title":"time_system  <code>property</code>","text":"<pre><code>time_system: TimeSystem\n</code></pre> <p>Time system of the epoch.</p> <p>Returns:</p> Name Type Description <code>TimeSystem</code> <code>TimeSystem</code> <p>The time system used by this epoch</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day","title":"day  <code>method descriptor</code>","text":"<pre><code>day() -&gt; int\n</code></pre> <p>Returns the day component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The day of the month as an integer from 1 to 31</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year","title":"day_of_year  <code>method descriptor</code>","text":"<pre><code>day_of_year() -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the epoch's time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <pre><code>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, \"UTC\")\ndoy = epoch.day_of_year()\nprint(f\"Day of year: {doy}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year_as_time_system","title":"day_of_year_as_time_system  <code>method descriptor</code>","text":"<pre><code>day_of_year_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the specified time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>The time system to use for the calculation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <pre><code>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, brahe.TimeSystem.UTC)\ndoy_tai = epoch.day_of_year_as_time_system(brahe.TimeSystem.TAI)\nprint(f\"Day of year in TAI: {doy_tai}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_date","title":"from_date  <code>builtin</code>","text":"<pre><code>from_date(year: int, month: int, day: int, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a calendar date at midnight.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing midnight on the specified date</p> Example <pre><code>import brahe as bh\n\n# Create an epoch at midnight on January 1, 2024 UTC\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T00:00:00.000000000 UTC\n\n# Create epoch in different time system\nepc_tai = bh.Epoch.from_date(2024, 6, 15, bh.TimeSystem.TAI)\nprint(epc_tai)\n# Output: 2024-06-15T00:00:00.000000000 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_datetime","title":"from_datetime  <code>builtin</code>","text":"<pre><code>from_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a complete Gregorian calendar date and time.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified date and time</p> Example <pre><code>import brahe as bh\n\n# Create epoch for January 1, 2024 at 12:30:45.5 UTC\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T12:30:45.500000000 UTC\n\n# With nanosecond precision\nepc_ns = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 0.0, 123456789.0, bh.TimeSystem.TAI)\nprint(epc_ns)\n# Output: 2024-06-15T14:30:00.123456789 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_day_of_year","title":"from_day_of_year  <code>builtin</code>","text":"<pre><code>from_day_of_year(year: int, day_of_year: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a year and floating-point day-of-year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>day_of_year</code> <code>float</code> <p>Day of year as a floating-point number (1.0 = January 1st, 1.5 = January 1st noon, etc.)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified day of year</p> Example <pre><code>import brahe as bh\n\n# Create epoch for day 100 of 2024 at midnight\nepc = bh.Epoch.from_day_of_year(2024, 100.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-04-09T00:00:00.000000000 UTC\n\n# Create epoch for day 100.5 (noon on day 100)\nepc_noon = bh.Epoch.from_day_of_year(2024, 100.5, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc_noon.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-04-09 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_date","title":"from_gps_date  <code>builtin</code>","text":"<pre><code>from_gps_date(week: int, seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS week and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>week</code> <code>int</code> <p>GPS week number since GPS epoch (January 6, 1980)</p> required <code>seconds</code> <code>float</code> <p>Seconds into the GPS week</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS week 2200, day 3, noon\nweek = 2200\nseconds = 3 * 86400 + 12 * 3600  # 3 days + 12 hours\nepc = bh.Epoch.from_gps_date(week, seconds)\nprint(epc)\n\n# Verify GPS week extraction\nweek_out, sec_out = epc.gps_date()\nprint(f\"GPS Week: {week_out}, Seconds: {sec_out}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_nanoseconds","title":"from_gps_nanoseconds  <code>builtin</code>","text":"<pre><code>from_gps_nanoseconds(gps_nanoseconds: int) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS nanoseconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_nanoseconds</code> <code>int</code> <p>Nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS nanoseconds with high precision\ngps_ns = 1234567890123456789\nepc = bh.Epoch.from_gps_nanoseconds(gps_ns)\nprint(f\"Epoch: {epc}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_seconds","title":"from_gps_seconds  <code>builtin</code>","text":"<pre><code>from_gps_seconds(gps_seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS seconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_seconds</code> <code>float</code> <p>Seconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS seconds\ngps_seconds = 1234567890.5\nepc = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"Epoch: {epc}\")\nprint(f\"GPS seconds: {epc.gps_seconds()}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_jd","title":"from_jd  <code>builtin</code>","text":"<pre><code>from_jd(jd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Julian Date\njd = 2460000.0\nepc = bh.Epoch.from_jd(jd, bh.TimeSystem.UTC)\nprint(epc)\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"JD: {jd_out:.10f}\")\n# Output: JD: 2460000.0000000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_mjd","title":"from_mjd  <code>builtin</code>","text":"<pre><code>from_mjd(mjd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Modified Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Modified Julian Date\nmjd = 60000.0\nepc = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\nprint(epc)\n\n# MJD is commonly used in astronomy\nmjd_j2000 = 51544.0  # J2000 epoch\nepc_j2000 = bh.Epoch.from_mjd(mjd_j2000, bh.TimeSystem.TT)\nprint(f\"J2000: {epc_j2000}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_string","title":"from_string  <code>builtin</code>","text":"<pre><code>from_string(datestr: str) -&gt; Epoch\n</code></pre> <p>Create an Epoch from an ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>datestr</code> <code>str</code> <p>ISO 8601 formatted date string (e.g., \"2024-01-01T12:00:00.000000000 UTC\")</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the parsed date and time</p> Example <pre><code>import brahe as bh\n\n# Parse ISO 8601 string with full precision\nepc = bh.Epoch.from_string(\"2024-01-01T12:00:00.000000000 UTC\")\nprint(epc)\n# Output: 2024-01-01T12:00:00.000000000 UTC\n\n# Parse different time systems\nepc_tai = bh.Epoch.from_string(\"2024-06-15T14:30:45.123456789 TAI\")\nprint(epc_tai.time_system)\n# Output: TimeSystem.TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gast","title":"gast  <code>method descriptor</code>","text":"<pre><code>gast(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Apparent Sidereal Time (GAST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GAST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngast_rad = epc.gast(bh.AngleFormat.RADIANS)\ngast_deg = epc.gast(bh.AngleFormat.DEGREES)\nprint(f\"GAST: {gast_rad:.6f} rad = {gast_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gmst","title":"gmst  <code>method descriptor</code>","text":"<pre><code>gmst(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Mean Sidereal Time (GMST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GMST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngmst_rad = epc.gmst(bh.AngleFormat.RADIANS)\ngmst_deg = epc.gmst(bh.AngleFormat.DEGREES)\nprint(f\"GMST: {gmst_rad:.6f} rad = {gmst_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_date","title":"gps_date  <code>method descriptor</code>","text":"<pre><code>gps_date() -&gt; Tuple\n</code></pre> <p>Get the GPS week number and seconds into the week.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (week, seconds_into_week)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.GPS)\nweek, seconds = epc.gps_date()\nprint(f\"GPS Week: {week}, Seconds: {seconds:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_nanoseconds","title":"gps_nanoseconds  <code>method descriptor</code>","text":"<pre><code>gps_nanoseconds() -&gt; float\n</code></pre> <p>Get the nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS nanoseconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 123456789.0, bh.TimeSystem.GPS)\ngps_ns = epc.gps_nanoseconds()\nprint(f\"GPS nanoseconds: {gps_ns:.0f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_seconds","title":"gps_seconds  <code>method descriptor</code>","text":"<pre><code>gps_seconds() -&gt; float\n</code></pre> <p>Get the seconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS seconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\ngps_sec = epc.gps_seconds()\nprint(f\"GPS seconds: {gps_sec:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.hour","title":"hour  <code>method descriptor</code>","text":"<pre><code>hour() -&gt; int\n</code></pre> <p>Returns the hour component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hour as an integer from 0 to 23</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring","title":"isostring  <code>method descriptor</code>","text":"<pre><code>isostring() -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string with full nanosecond precision</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso = epc.isostring()\nprint(iso)\n# Output: 2024-01-01T12:30:45.123456789Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring_with_decimals","title":"isostring_with_decimals  <code>method descriptor</code>","text":"<pre><code>isostring_with_decimals(decimals: int) -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string with specified decimal precision.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimal places for the seconds field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso3 = epc.isostring_with_decimals(3)\niso6 = epc.isostring_with_decimals(6)\nprint(iso3)  # Output: 2024-01-01T12:30:45.123Z\nprint(iso6)  # Output: 2024-01-01T12:30:45.123457Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd","title":"jd  <code>method descriptor</code>","text":"<pre><code>jd() -&gt; float\n</code></pre> <p>Get the Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd = epc.jd()\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460310.500000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd_as_time_system","title":"jd_as_time_system  <code>method descriptor</code>","text":"<pre><code>jd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd_utc = epc.jd()\njd_tai = epc.jd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"JD UTC: {jd_utc:.10f}\")\nprint(f\"JD TAI: {jd_tai:.10f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.minute","title":"minute  <code>method descriptor</code>","text":"<pre><code>minute() -&gt; int\n</code></pre> <p>Returns the minute component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The minute as an integer from 0 to 59</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd","title":"mjd  <code>method descriptor</code>","text":"<pre><code>mjd() -&gt; float\n</code></pre> <p>Get the Modified Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epc.mjd()\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd_as_time_system","title":"mjd_as_time_system  <code>method descriptor</code>","text":"<pre><code>mjd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Modified Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd_utc = epc.mjd()\nmjd_gps = epc.mjd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"MJD UTC: {mjd_utc:.6f}\")\nprint(f\"MJD GPS: {mjd_gps:.6f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.month","title":"month  <code>method descriptor</code>","text":"<pre><code>month() -&gt; int\n</code></pre> <p>Returns the month component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The month as an integer from 1 to 12</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.nanosecond","title":"nanosecond  <code>method descriptor</code>","text":"<pre><code>nanosecond() -&gt; float\n</code></pre> <p>Returns the nanosecond component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The nanosecond component as a floating-point number</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.now","title":"now  <code>builtin</code>","text":"<pre><code>now() -&gt; Epoch\n</code></pre> <p>Create an Epoch representing the current UTC instant.</p> <p>This method uses the system clock to get the current time and creates an Epoch in the UTC time system.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the current instant in time in UTC</p> Example <pre><code>import brahe as bh\n\n# Get current time as an Epoch\nnow = bh.Epoch.now()\nprint(f\"Current time: {now}\")\nprint(f\"Time system: {now.time_system}\")\n# Output: Time system: TimeSystem.UTC\n\n# Use in orbital calculations\nimport numpy as np\ncurrent_epoch = bh.Epoch.now()\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\npropagator = bh.KeplerianPropagator.from_eci(current_epoch, state, 60.0)\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.second","title":"second  <code>method descriptor</code>","text":"<pre><code>second() -&gt; float\n</code></pre> <p>Returns the second component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The second as a floating-point number from 0.0 to 59.999...</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime","title":"to_datetime  <code>method descriptor</code>","text":"<pre><code>to_datetime() -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-06-15 14:30:45.500\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime_as_time_system","title":"to_datetime_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_datetime_as_time_system(time_system: TimeSystem) -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Create epoch in UTC and convert to TAI\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime_as_time_system(bh.TimeSystem.TAI)\nprint(f\"TAI: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: TAI: 2024-01-01 12:00:37.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_pydatetime","title":"to_pydatetime  <code>method descriptor</code>","text":"<pre><code>to_pydatetime() -&gt; datetime\n</code></pre> <p>Convert the epoch to a Python datetime object in UTC timezone.</p> <p>This method always converts the epoch to UTC before creating the datetime object, regardless of the epoch's original time system.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: Python datetime object with UTC timezone</p> Example <pre><code>import brahe as bh\nfrom datetime import datetime, timezone\n\n# Create epoch in GPS time\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.GPS)\n\n# Convert to Python datetime (always UTC)\ndt = epc.to_pydatetime()\nprint(dt)  # datetime object in UTC\nprint(dt.tzinfo)  # timezone.utc\n\n# Verify it's always UTC\nassert dt.tzinfo == timezone.utc\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_string_as_time_system","title":"to_string_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_string_as_time_system(time_system: TimeSystem) -&gt; str\n</code></pre> <p>Convert the epoch to a string representation in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the epoch</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprint(epc.to_string_as_time_system(bh.TimeSystem.UTC))\nprint(epc.to_string_as_time_system(bh.TimeSystem.TAI))\n# Shows same instant in different time systems\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.year","title":"year  <code>method descriptor</code>","text":"<pre><code>year() -&gt; int\n</code></pre> <p>Returns the year component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year as a 4-digit integer</p>"},{"location":"library_api/time/time_range.html","title":"TimeRange Class","text":"<p>The <code>TimeRange</code> class provides an iterator for generating sequences of epochs over a time range with a specified step size. It is particularly useful for orbit propagation, trajectory sampling, and time-series analysis.</p>"},{"location":"library_api/time/time_range.html#brahe._brahe.TimeRange","title":"TimeRange","text":"<pre><code>TimeRange(epoch_start: Epoch, epoch_end: Epoch, step: float)\n</code></pre> <p>Iterator that generates a sequence of epochs over a time range.</p> <p>TimeRange creates an iterator that yields epochs from a start time to an end time with a specified step size in seconds. This is useful for propagating orbits, sampling trajectories, or generating time grids for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>epoch_start</code> <code>Epoch</code> <p>Starting epoch for the range</p> required <code>epoch_end</code> <code>Epoch</code> <p>Ending epoch for the range</p> required <code>step</code> <code>float</code> <p>Time step in seconds between consecutive epochs</p> required <p>Examples:</p> <pre><code>from brahe import Epoch, TimeRange, TimeSystem\nstart = Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, TimeSystem.UTC)\nend = start + 3600.0  # One hour later\ntime_range = TimeRange(start, end, 60.0)  # 60-second steps\nfor epoch in time_range:\n    print(epoch)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/index.html","title":"Trajectories","text":"<p>Module: <code>brahe.trajectories</code></p> <p>Trajectory containers for storing, managing, and interpolating time-series state data.</p>"},{"location":"library_api/trajectories/index.html#overview","title":"Overview","text":"<p>Brahe provides several trajectory container types for storing sequences of states (positions, velocities, or other data) over time with automatic interpolation capabilities.</p>"},{"location":"library_api/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":""},{"location":"library_api/trajectories/index.html#dtrajectory","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container where dimension is set at runtime. Flexible for storing any N-dimensional state data.</p>"},{"location":"library_api/trajectories/index.html#strajectory6","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state vectors [x, y, z, vx, vy, vz]. Faster than DTrajectory for fixed-size data.</p>"},{"location":"library_api/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized orbital trajectory with frame-aware storage and automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/index.html#key-features","title":"Key Features","text":"<ul> <li>Time-ordered storage: States automatically sorted by epoch</li> <li>Interpolation: Linear or Lagrange interpolation between states</li> <li>Eviction policies: Automatic state removal based on age or count</li> <li>Query methods: Get states before/after/at specific times</li> <li>Batch operations: Add and query multiple states efficiently</li> </ul>"},{"location":"library_api/trajectories/index.html#quick-comparison","title":"Quick Comparison","text":"Feature DTrajectory STrajectory6 OrbitTrajectory Dimension Runtime (any N) Compile-time (6) Compile-time (6) Performance Good Better Better Use Case General data Orbital states Frame-aware orbits Frames Not frame-aware Not frame-aware ECI/ECEF support"},{"location":"library_api/trajectories/index.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Option 1: Dynamic trajectory (any dimension)\ntraj_dyn = bh.DTrajectory(dimension=6)\n\n# Option 2: Static 6D trajectory (faster for orbital states)\ntraj_static = bh.STrajectory6()\n\n# Option 3: Orbit trajectory (frame-aware)\ntraj_orbit = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Add states\nstate = np.array([7000000.0, 0.0, 0.0, 0.0, 7500.0, 0.0])  # [x,y,z,vx,vy,vz]\ntraj_static.add(epoch, state)\n\n# Propagate orbit and store trajectory\nprop = bh.KeplerianPropagator(...)\ntimes = np.linspace(0, 86400, 100)\nfor dt in times:\n    future_epoch = epoch + dt\n    state = prop.propagate(future_epoch)\n    traj_static.add(future_epoch, state)\n\n# Query with interpolation\nquery_epoch = epoch + 43200.0  # 12 hours later\ninterpolated_state = traj_static.interpolate(query_epoch)\n</code></pre>"},{"location":"library_api/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>InterpolationMethod - Interpolation options</li> <li>OrbitFrame - Frame specifications</li> <li>KeplerianPropagator - Analytical orbit propagation</li> <li>SGPPropagator - SGP4/SDP4 orbit propagation</li> </ul>"},{"location":"library_api/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container for N-dimensional state data.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory","title":"DTrajectory","text":"<pre><code>DTrajectory()\n</code></pre> <p>Dynamic-dimension trajectory container.</p> <p>Stores a sequence of N-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is determined at runtime.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>N-element state vector where N is the trajectory dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get the trajectory dimension (method form).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Any\n</code></pre> <p>Get end epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; DTrajectory\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of states with shape (num_epochs, dimension) where each row is a state vector</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = bh.InterpolationMethod.LINEAR\ntraj.set_interpolation_method(method)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Any\n</code></pre> <p>Get start epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; Any\n</code></pre> <p>Get time span of trajectory in seconds</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#overview","title":"Overview","text":"<p><code>DTrajectory</code> is a flexible trajectory container where the state dimension is determined at runtime. Use this when you need to store state vectors of varying sizes or when the dimension isn't known at compile time.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Runtime dimension specification - Automatic time-ordering of states - Configurable interpolation (Linear or Lagrange) - Eviction policies for memory management - Efficient state queries and interpolation</p>"},{"location":"library_api/trajectories/dtrajectory.html#creating-a-trajectory","title":"Creating a Trajectory","text":"<pre><code>import brahe as bh\n\n# Create with specified dimension\ntraj = bh.DTrajectory(dimension=6)  # For orbital states\n\n# Create with specific interpolation method\ntraj = bh.DTrajectory(\n    dimension=3,\n    interpolation_method=bh.InterpolationMethod.LAGRANGE\n)\n\n# Create from existing data\nimport numpy as np\nepochs = [epoch1, epoch2, epoch3]\nstates = np.array([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])\ntraj = bh.DTrajectory.from_data(\n    epochs,\n    states,\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(dimension=6)\n\n# Add single state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([7e6, 0, 0, 0, 7.5e3, 0])\ntraj.add(epoch, state)\n\n# Add multiple states from propagation\nprop = bh.KeplerianPropagator(...)\nfor i in range(100):\n    future_epoch = epoch + i * 60.0  # Every minute\n    state = prop.propagate(future_epoch)\n    traj.add(future_epoch, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#querying-states","title":"Querying States","text":"<pre><code># Interpolate at specific epoch\nquery_epoch = epoch + 1800.0  # 30 minutes later\ninterp_state = traj.interpolate(query_epoch)\n\n# Get state at specific index\nstate_10 = traj.state(10)\nepoch_10 = traj.epoch(10)\n\n# Get first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\n\n# Get state before/after epoch\nbefore_epoch, before_state = traj.state_before_epoch(query_epoch)\nafter_epoch, after_state = traj.state_after_epoch(query_epoch)\n\n# Get all data\nall_states = traj.to_matrix()  # Returns numpy array (n_states, dimension)\nall_epochs = traj.to_epochs()  # Returns list of Epochs\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#eviction-policies","title":"Eviction Policies","text":"<p>Control memory usage by automatically removing old states:</p> <pre><code># Maximum age: keep only states within 1 hour of newest\ntraj.set_eviction_policy_max_age(3600.0)\n\n# Maximum size: keep only last 1000 states\ntraj.set_eviction_policy_max_size(1000)\n\n# No eviction (default)\ntraj.set_eviction_policy_no_eviction()\n\n# Builder pattern (method chaining)\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_eviction_policy_max_age(3600.0) \\\n    .with_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#interpolation-methods","title":"Interpolation Methods","text":"<pre><code># Linear interpolation (faster, less accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n\n# Lagrange interpolation (slower, more accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#trajectory-information","title":"Trajectory Information","text":"<pre><code># Get dimension\ndim = traj.dimension()  # Returns dimension of state vectors\n\n# Get size\nn_states = traj.len()  # Number of states stored\n\n# Check if empty\nis_empty = traj.is_empty()\n\n# Get time span\nspan = traj.timespan()  # Duration in seconds from first to last\n\n# Get start/end epochs\nstart = traj.start_epoch()\nend = traj.end_epoch()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#clearing-and-removing-states","title":"Clearing and Removing States","text":"<pre><code># Clear all states\ntraj.clear()\n\n# Remove state at specific epoch\nremoved_state = traj.remove_epoch(epoch)\n\n# Remove state at index\nremoved_epoch, removed_state = traj.remove_at(index)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#complete-example","title":"Complete Example","text":"<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set up propagator\nepoch_start = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch_start,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Create trajectory with eviction policy\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_interpolation_method(bh.InterpolationMethod.LINEAR) \\\n    .with_eviction_policy_max_size(1000)\n\n# Propagate and store states\ntimes = np.linspace(0, 86400, 1440)  # 1 day, 1-minute steps\nfor dt in times:\n    epoch = epoch_start + dt\n    state = prop.propagate(epoch)\n    traj.add(epoch, state)\n\nprint(f\"Stored {traj.len()} states\")\nprint(f\"Time span: {traj.timespan()/3600:.1f} hours\")\n\n# Interpolate at arbitrary times\nquery_times = np.linspace(0, 86400, 100)\naltitudes = []\nfor dt in query_times:\n    query_epoch = epoch_start + dt\n    state = traj.interpolate(query_epoch)\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1000  # km\n    altitudes.append(altitude)\n\n# Plot altitude profile\nplt.plot(query_times/3600, altitudes)\nplt.xlabel('Time (hours)')\nplt.ylabel('Altitude (km)')\nplt.title('Orbit Altitude Over 1 Day')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Fixed 6D trajectory (faster)</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> <li>InterpolationMethod</li> </ul>"},{"location":"library_api/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p>Frame-aware orbital trajectory with automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory","title":"OrbitTrajectory","text":"<pre><code>OrbitTrajectory()\n</code></pre> <p>Orbital trajectory with frame and representation awareness.</p> <p>Stores a sequence of orbital states at specific epochs with support for interpolation, frame conversions, and representation transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.angle_format","title":"angle_format  <code>property</code>","text":"<pre><code>angle_format: AngleFormat\n</code></pre> <p>Get trajectory angle format for Keplerian states.</p> <p>Returns:</p> Type Description <code>AngleFormat</code> <p>AngleFormat or None: Angle format for Keplerian representation, None for Cartesian</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Angle format: {traj.angle_format}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: OrbitFrame\n</code></pre> <p>Get trajectory reference frame.</p> <p>Returns:</p> Name Type Description <code>OrbitFrame</code> <code>OrbitFrame</code> <p>Reference frame of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Frame: {traj.frame}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.representation","title":"representation  <code>property</code>","text":"<pre><code>representation: OrbitRepresentation\n</code></pre> <p>Get trajectory state representation.</p> <p>Returns:</p> Name Type Description <code>OrbitRepresentation</code> <code>OrbitRepresentation</code> <p>State representation format of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Representation: {traj.representation}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.clear()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; OrbitTrajectory\n</code></pre> <p>Create a default empty orbital trajectory (ECI Cartesian).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory with ECI frame and Cartesian representation</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6 for orbital trajectories).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"End epoch: {traj.end_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get the epoch at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch to retrieve</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get epoch at index\nepoch_0 = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epochs","title":"epochs  <code>method descriptor</code>","text":"<pre><code>epochs() -&gt; list[Epoch]\n</code></pre> <p>Get all epochs as a list of Epoch objects.</p> <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: List of Epoch objects for all trajectory points</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nepochs_list = traj.epochs()\nprint(f\"First epoch: {epochs_list[0]}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.from_orbital_data","title":"from_orbital_data  <code>builtin</code>","text":"<pre><code>from_orbital_data(epochs: list[Epoch], states: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: Union[AngleFormat, None] = None) -&gt; OrbitTrajectory\n</code></pre> <p>Create orbital trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs for each state</p> required <code>states</code> <code>ndarray</code> <p>2D array of 6-element state vectors with shape (N, 6) where N is the number of epochs. Each row is one state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the states</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the trajectory numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: The trajectory ID, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_id(12345)\nprint(traj.get_id())  # 12345\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the trajectory name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: The trajectory name, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_name(\"My Trajectory\")\nprint(traj.get_name())  # \"My Trajectory\"\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the trajectory UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: The trajectory UUID as a string, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_new_uuid()\nprint(traj.get_uuid())  # e.g., \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Start epoch: {traj.start_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state at specified epoch (in native frame/representation).</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in trajectory's native frame and representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate1 = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc1, state1)\n\n# Query state at epoch\nstate = traj.state(epc1)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get state as osculating Keplerian elements at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements [a, e, i, raan, argp, M]</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_cart = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_cart)\n\n# Get osculating elements in degrees\nelements = traj.state_as_osculating_elements(epc, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements[0]/1000:.2f} km\")\nprint(f\"Inclination: {elements[2]:.2f} degrees\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get the state vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to retrieve</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get state at index\nstate_0 = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECEF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECEF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_eci = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_eci)\n\n# Get ECEF state (automatically converted from ECI)\nstate_ecef = traj.state_ecef(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECI Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECI Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory in any frame/representation\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 98.0, 15.0, 30.0, 45.0])\ntraj.add(epc, oe)\n\n# Get ECI Cartesian state (automatically converted from Keplerian)\nstate_eci = traj.state_eci(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array of states with shape (N, 6) where N is the number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nstates_array = traj.states()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 3600.0, state)\nprint(f\"Timespan: {traj.timespan()} seconds\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_ecef","title":"to_ecef  <code>method descriptor</code>","text":"<pre><code>to_ecef() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECEF (Earth-Centered Earth-Fixed) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECEF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_ecef = traj.to_ecef()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eci","title":"to_eci  <code>method descriptor</code>","text":"<pre><code>to_eci() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECI (Earth-Centered Inertial) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\ntraj.add(epc, state)\ntraj_eci = traj.to_eci()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_keplerian","title":"to_keplerian  <code>method descriptor</code>","text":"<pre><code>to_keplerian(angle_format: AngleFormat) -&gt; OrbitTrajectory\n</code></pre> <p>Convert to Keplerian representation in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for the result (Radians or Degrees)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Keplerian representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_kep = traj.to_keplerian(bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert trajectory to matrix representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array with shape (6, N) where N is number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nmatrix = traj.to_matrix()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set the trajectory numeric ID and return self (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to the trajectory</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with ID set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_id(12345)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; OrbitTrajectory\n</code></pre> <p>Set the trajectory name and return self (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to the trajectory</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with name set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_name(\"My Trajectory\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; OrbitTrajectory\n</code></pre> <p>Generate a new UUID and set it on the trajectory (builder pattern).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with new UUID set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_new_uuid()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#overview","title":"Overview","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that stores states in a specific reference frame (ECI or ECEF) and can automatically transform between frames when querying.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Frame-aware storage (ECI or ECEF) - Automatic frame transformations on query - Built on STrajectory6 (6D states only) - Same performance as STrajectory6</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#creating-with-frame","title":"Creating with Frame","text":"<pre><code>import brahe as bh\n\n# ECI frame trajectory\ntraj_eci = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# ECEF frame trajectory\ntraj_ecef = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECEF)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Propagate and store states in ECI\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Add states\nfor i in range(100):\n    t = epoch + i * 60.0\n    state_eci = prop.propagate(t)\n    traj.add(t, state_eci)\n\n# States are stored and retrieved in ECI\nquery_epoch = epoch + 1800.0\nstate = traj.interpolate(query_epoch)  # ECI frame\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#frame-information","title":"Frame Information","text":"<pre><code># Get trajectory frame\nframe = traj.frame()  # Returns OrbitFrame.ECI or OrbitFrame.ECEF\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#api","title":"API","text":"<p>OrbitTrajectory has the same API as STrajectory6 and DTrajectory, plus frame awareness.</p> <p>See STrajectory6 or DTrajectory for full API documentation.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Non-frame-aware 6D trajectory</li> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitFrame - Frame specifications</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state storage.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6","title":"STrajectory6","text":"<pre><code>STrajectory6()\n</code></pre> <p>Static-dimension 6D trajectory container.</p> <p>Stores a sequence of 6-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is fixed at compile time for performance.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.end_epoch","title":"end_epoch  <code>property</code>","text":"<pre><code>end_epoch: Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolation_method","title":"interpolation_method  <code>property</code>","text":"<pre><code>interpolation_method: InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.start_epoch","title":"start_epoch  <code>property</code>","text":"<pre><code>start_epoch: Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.time_span","title":"time_span  <code>property</code>","text":"<pre><code>time_span: float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; STrajectory6\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of 6D state vectors with shape (N, 6) where N is the number of epochs. Each row is one state vector.</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>New 6D trajectory instance populated with data</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstates = np.array([[bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0],\n                   [bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0]])\ntraj = bh.STrajectory6.from_data([epc1, epc2], states)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; STrajectory6\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#overview","title":"Overview","text":"<p><code>STrajectory6</code> provides compile-time optimized storage for 6-dimensional Cartesian states <code>[x, y, z, vx, vy, vz]</code>. It offers the best performance for standard orbital mechanics applications.</p>"},{"location":"library_api/trajectories/strajectory6.html#features","title":"Features","text":"<ul> <li>Fixed dimension: Always 6D (compile-time optimization)</li> <li>Lower memory overhead: More efficient than DTrajectory</li> <li>Fastest performance: Optimized for Cartesian orbital states</li> <li>Full interpolation: Supports linear, cubic, and Lagrange interpolation</li> <li>Eviction policies: Memory management via automatic state removal</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html#when-to-use","title":"When to Use","text":"<p>Use <code>STrajectory6</code> when:</p> <ul> <li>Storing standard Cartesian orbital states</li> <li>Performance is critical</li> <li>State dimension is always 6</li> <li>Not using orbit-specific features (use OrbitTrajectory for that)</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory - Variable dimension trajectory</li> <li>OrbitTrajectory - Orbit-aware trajectory</li> <li>Trajectories Overview</li> </ul>"},{"location":"library_api/utils/index.html","title":"Utilities API Reference","text":"<p>This section provides detailed API documentation for all utility functions in Brahe.</p>"},{"location":"library_api/utils/index.html#overview","title":"Overview","text":"<p>The utilities module provides support functions for:</p> <ul> <li>Caching: Cache directory management for downloaded data</li> <li>Multithreading: Thread pool configuration for parallel computation</li> <li>String Formatting: Human-readable output formatting</li> </ul>"},{"location":"library_api/utils/index.html#quick-links","title":"Quick Links","text":"Module Description Caching Functions for managing cache directories Threading Functions for configuring the thread pool Formatting Functions for formatting values as strings"},{"location":"library_api/utils/index.html#see-also","title":"See Also","text":"<ul> <li>Utilities Learn Section - Conceptual guides and examples</li> </ul>"},{"location":"library_api/utils/caching.html","title":"Caching Functions","text":"<p>Functions for managing cache directories where Brahe stores downloaded data.</p>"},{"location":"library_api/utils/caching.html#main-cache-directory","title":"Main Cache Directory","text":""},{"location":"library_api/utils/caching.html#brahe.get_brahe_cache_dir","title":"get_brahe_cache_dir  <code>builtin</code>","text":"<pre><code>get_brahe_cache_dir() -&gt; str\n</code></pre> <p>Get the brahe cache directory path.</p> <p>The cache directory is determined by the <code>BRAHE_CACHE</code> environment variable. If not set, defaults to <code>~/.cache/brahe</code>.</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Cache directory: {cache_dir}\")\n\n# You can also override with environment variable\nimport os\nos.environ['BRAHE_CACHE'] = '/custom/cache/path'\ncache_dir = bh.get_brahe_cache_dir()\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#brahe.get_brahe_cache_dir_with_subdir","title":"get_brahe_cache_dir_with_subdir  <code>builtin</code>","text":"<pre><code>get_brahe_cache_dir_with_subdir(subdirectory: Union[str, None]) -&gt; str\n</code></pre> <p>Get the brahe cache directory path with an optional subdirectory.</p> <p>The cache directory is determined by the <code>BRAHE_CACHE</code> environment variable. If not set, defaults to <code>~/.cache/brahe</code>. If a subdirectory is provided, it is appended to the cache path.</p> <p>The directory is created if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>subdirectory</code> <code>str or None</code> <p>Optional subdirectory name to append to cache path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the cache directory (with subdirectory if provided).</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\n# Get main cache directory\ncache_dir = bh.get_brahe_cache_dir_with_subdir(None)\nprint(f\"Cache: {cache_dir}\")\n\n# Get custom subdirectory\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"my_data\")\nprint(f\"Custom cache: {custom_cache}\")\n</code></pre> Note <p>The directory (and subdirectory) will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#specialized-cache-directories","title":"Specialized Cache Directories","text":""},{"location":"library_api/utils/caching.html#brahe.get_eop_cache_dir","title":"get_eop_cache_dir  <code>builtin</code>","text":"<pre><code>get_eop_cache_dir() -&gt; str\n</code></pre> <p>Get the EOP cache directory path.</p> <p>Returns the path to the EOP (Earth Orientation Parameters) cache subdirectory. Defaults to <code>~/.cache/brahe/eop</code> (or <code>$BRAHE_CACHE/eop</code> if environment variable is set).</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the EOP cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache: {eop_cache}\")\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#brahe.get_celestrak_cache_dir","title":"get_celestrak_cache_dir  <code>builtin</code>","text":"<pre><code>get_celestrak_cache_dir() -&gt; str\n</code></pre> <p>Get the CelesTrak cache directory path.</p> <p>Returns the path to the CelesTrak cache subdirectory used for storing downloaded TLE data. Defaults to <code>~/.cache/brahe/celestrak</code> (or <code>$BRAHE_CACHE/celestrak</code> if environment variable is set).</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the CelesTrak cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache: {celestrak_cache}\")\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/formatting.html","title":"String Formatting Functions","text":"<p>Functions for formatting numerical values into human-readable strings.</p>"},{"location":"library_api/utils/formatting.html#time-formatting","title":"Time Formatting","text":""},{"location":"library_api/utils/formatting.html#brahe.format_time_string","title":"format_time_string  <code>builtin</code>","text":"<pre><code>format_time_string(seconds: float, short: bool = False) -&gt; str\n</code></pre> <p>Format a time duration in seconds to a human-readable string.</p> <p>Converts a duration in seconds to either a long format (e.g., \"6 minutes and 2.00 seconds\") or a short format (e.g., \"6m 2s\").</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Time duration in seconds</p> required <code>short</code> <code>bool</code> <p>If True, use short format; otherwise use long format (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable string representation of the time duration</p> Example <pre><code>import brahe as bh\n\n# Long format (default)\nprint(bh.format_time_string(90.0))\n# Output: \"1 minutes and 30.00 seconds\"\n\nprint(bh.format_time_string(3665.0))\n# Output: \"1 hours, 1 minutes, and 5.00 seconds\"\n\n# Short format\nprint(bh.format_time_string(90.0, short=True))\n# Output: \"1m 30s\"\n\nprint(bh.format_time_string(3665.0, short=True))\n# Output: \"1h 1m 5s\"\n</code></pre>"},{"location":"library_api/utils/threading.html","title":"Threading Functions","text":"<p>Functions for configuring the global thread pool used for parallel computation.</p>"},{"location":"library_api/utils/threading.html#thread-pool-configuration","title":"Thread Pool Configuration","text":""},{"location":"library_api/utils/threading.html#brahe.set_num_threads","title":"set_num_threads  <code>builtin</code>","text":"<pre><code>set_num_threads(n: int) -&gt; Any\n</code></pre> <p>Set the number of threads for parallel computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations such as access computations. This function can be called multiple times to dynamically change the thread pool configuration - each call will reinitialize the pool with the new thread count.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If n &lt; 1.</p> <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Set to 4 threads initially\nbh.set_num_threads(4)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 4\n\n# Reinitialize with 8 threads - no error!\nbh.set_num_threads(8)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 8\n\n# All parallel operations (e.g., location_accesses) will now use\n# 8 threads unless overridden with AccessSearchConfig.num_threads\n</code></pre> Note <p>Unlike earlier versions, this function no longer raises an error if the thread pool has already been initialized. You can safely call it at any time to reconfigure the thread pool.</p>"},{"location":"library_api/utils/threading.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads() -&gt; Any\n</code></pre> <p>Set the thread pool to use all available CPU cores.</p> <p>This is a convenience function that sets the number of threads to 100% of available CPU cores. Can be called multiple times to reinitialize the thread pool dynamically.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Use all available CPU cores\nbh.set_max_threads()\nprint(f\"Using all {bh.get_max_threads()} cores\")\n\n# Switch to 2 threads\nbh.set_num_threads(2)\n\n# Switch back to max - no error!\nbh.set_max_threads()\nprint(f\"Back to {bh.get_max_threads()} cores\")\n</code></pre> Note <p>This function can be called at any time, even after the thread pool has been initialized with a different configuration.</p>"},{"location":"library_api/utils/threading.html#brahe.set_ludicrous_speed","title":"set_ludicrous_speed  <code>builtin</code>","text":"<pre><code>set_ludicrous_speed() -&gt; Any\n</code></pre> <p>LUDICROUS SPEED! GO!</p> <p>Set the thread pool to use all available CPU cores (alias for <code>set_max_threads</code>).</p> <p>This is a fun alias for <code>set_max_threads()</code> that sets the number of threads to 100% of available CPU cores for maximum performance. Can be called multiple times to dynamically reinitialize the thread pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# MAXIMUM POWER! Use all available CPU cores\nbh.set_ludicrous_speed()\nprint(f\"Going ludicrous with {bh.get_max_threads()} threads!\")\n\n# Throttle down for testing\nbh.set_num_threads(1)\n\n# ENGAGE LUDICROUS SPEED again - no error!\nbh.set_ludicrous_speed()\n</code></pre> Note <p>This function can be called at any time to reconfigure the thread pool to use maximum available cores, regardless of previous configuration.</p>"},{"location":"library_api/utils/threading.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores, initialized on first call)\nthreads = bh.get_max_threads()\nprint(f\"Default: {threads} threads\")\n\n# Set to specific value and verify\nbh.set_num_threads(4)\nassert bh.get_max_threads() == 4\n\n# Reconfigure and verify again\nbh.set_num_threads(8)\nassert bh.get_max_threads() == 8\n\n# Switch to max cores\nbh.set_max_threads()\nprint(f\"Max cores: {bh.get_max_threads()}\")\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings (90% of cores) if it hasn't been configured yet. After initialization, you can still reconfigure it using set_num_threads() or set_max_threads().</p>"}]}