{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Brahe","text":"<p> Brahe - Practical Astrodynamics </p> <p> </p> <p>Pure-Python Brahe Deprecation Notice</p> <p>The older pure-Python implementaiton of brahe is currently being deprecated in favor of an improved Rust-based implementation. There will be breaking changes during this period that include breaking changes. You can read more about this change in the deprecation notice.</p>"},{"location":"index.html#brahe","title":"Brahe","text":"<p>!!! quote \"\"'s </p> <pre><code>All software is wrong, but some is useful.\n</code></pre> <p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, quick-to-deploy, and easy to build on. The north-star of the development is enabling users to solve meaningful problems and answer questions quickly and correctly.</p> <p>The Brahe permissively licensed and distributed under an MIT License to encourage adoption and enable the broader community to build on the work.</p> <p>If you do find it useful, please consider starring the repository on GitHub to help increase its visibility. If you're using Brahe for school, research, a commercial endeavour, or flying a mission. I'd love to know about it! You can find my contact information on my personal website,  or open an issue on the GitHub repository.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#python","title":"Python","text":"<p>To install the latest release of brahe for Python, simply run:</p> <pre><code>pip install brahe\n</code></pre> <p>You can then import the package in your Python code with:</p> <pre><code>import brahe as bh\n</code></pre> <p>And do something fun like calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>import brahe as bh\n\n# Define the semi-major axis of a low Earth orbit (in meters)\na = bh.constants.EARTH_RADIUS + 400e3  # 400 km altitude\n\n# Calculate the orbital period using Kepler's third law\nT = bh.orbital_period(a)\n\nprint(f\"Orbital Period: {T / 60:.2f} minutes\")\n</code></pre> <p>Here are some common operations to get you started:</p> <p>Working with Time: <pre><code>import brahe as bh\n\n# Create an epoch from a specific date and time\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0, bh.TimeSystem.UTC)\n\n# Convert between time systems\nmjd_utc = epc.mjd_as_time_system(bh.TimeSystem.UTC)\nmjd_tai = epc.mjd_as_time_system(bh.TimeSystem.TAI)\n\n# Time arithmetic\nfuture_epc = epc + 3600  # Add 3600 seconds (1 hour)\ntime_diff = future_epc - epc  # Difference in seconds\n</code></pre></p> <p>Propagating an Orbit: <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a Two-Line Element (TLE) for a satellite\ntle = bh.TLE(\n    \"ISS (ZARYA)\",\n    \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\",\n    \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n)\n\n# Create an SGP4 propagator\nprop = bh.SGPPropagator.from_tle(tle)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 6, 1, 0, 0, 0.0, 0, \"UTC\")\nstate = prop.propagate(epc)  # Returns [x, y, z, vx, vy, vz] in meters and m/s\n\nprint(f\"Position: {state[:3] / 1000} km\")\nprint(f\"Velocity: {state[3:] / 1000} km/s\")\n</code></pre></p> <p>Coordinate Transformations: <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (lat, lon, alt) to ECEF\nlat = 40.0  # degrees\nlon = -105.0  # degrees\nalt = 1000.0  # meters\necef = bh.sGEODtoECEF(np.array([lat, lon, alt]), use_degrees=True)\n\n# Convert ECEF to ECI at a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0, bh.TimeSystem.UTC)\neci = bh.rECEFtoECI(epc, ecef)\n</code></pre></p>"},{"location":"index.html#rust","title":"Rust","text":"<p>To use brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre> <p>Here are some common operations to get you started:</p> <p>Working with Time: <pre><code>use brahe::time::Epoch;\nuse brahe::time::TimeSystem;\n\n// Create an epoch from a specific date and time\nlet epc = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0, TimeSystem::UTC);\n\n// Convert between time systems\nlet mjd_utc = epc.to_mjd(TimeSystem::UTC);\nlet mjd_tai = epc.to_mjd(TimeSystem::TAI);\n\n// Time arithmetic\nlet future_epc = epc + 3600.0;  // Add 3600 seconds (1 hour)\nlet time_diff = future_epc - epc;  // Difference in seconds\n</code></pre></p> <p>Propagating an Orbit: <pre><code>use brahe::orbits::{TLE, SGPPropagator};\nuse brahe::time::Epoch;\n\n// Create a Two-Line Element (TLE) for a satellite\nlet tle = TLE::from_lines(\n    \"ISS (ZARYA)\",\n    \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\",\n    \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n).unwrap();\n\n// Create an SGP4 propagator\nlet prop = SGPPropagator::from_tle(&amp;tle);\n\n// Propagate to a specific epoch\nlet epc = Epoch::from_datetime(2024, 6, 1, 0, 0, 0.0, 0, TimeSystem::UTC);\nlet state = prop.propagate(&amp;epc);  // Returns [x, y, z, vx, vy, vz] in meters and m/s\n\nprintln!(\"Position: {:?} km\", [state[0]/1000.0, state[1]/1000.0, state[2]/1000.0]);\nprintln!(\"Velocity: {:?} km/s\", [state[3]/1000.0, state[4]/1000.0, state[5]/1000.0]);\n</code></pre></p> <p>Coordinate Transformations: <pre><code>use brahe::coordinates::{sGEODtoECEF, rECEFtoECI};\nuse brahe::time::Epoch;\n\n// Convert geodetic coordinates (lat, lon, alt) to ECEF\nlet lat = 40.0_f64.to_radians();  // Radians\nlet lon = -105.0_f64.to_radians();  // Radians\nlet alt = 1000.0;  // meters\nlet ecef = sGEODtoECEF([lat, lon, alt]);\n\n// Convert ECEF to ECI at a specific epoch\nlet epc = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0, TimeSystem::UTC);\nlet eci = rECEFtoECI(&amp;epc, ecef);\n</code></pre></p>"},{"location":"index.html#going-further","title":"Going Further","text":"<p>If you want to learn more about how to use the package the documentation is structured in the following way:</p> <ul> <li>Learn: Provides short-form documentation of major concepts of the package.</li> <li>Examples: Provides longer-form examples of how-to examples of accomplish common tasks.</li> <li>Library API: Provides detailed reference documentation of the Python API.</li> <li>Rust API: Provides detailed reference documentation of the Rust API.</li> </ul>"},{"location":"index.html#support-and-acknowledgement","title":"Support and Acknowledgement","text":"<p>Brahe is currently being developed primarily for my own enjoyment and because I find having these tools helpful in professional and hobby work. I plan to continue developing it for the time being regardless of greater adoption as time permitting.</p> <p>That being said, it's incredibly encouraging and useful to know if the software is being adopted or found useful in wider practice.</p>"},{"location":"contributing.html","title":"Contributing","text":""},{"location":"contributing.html#development-workflow","title":"Development Workflow","text":"<p>For all development we recommend using uv to manage your environment. The guidelines for contributing, developing, and extending brahe assume you are using uv.</p>"},{"location":"contributing.html#setting-up-your-environment","title":"Setting up your environment","text":"<p>If you need to setup the development environment, including installing the necessary development dependencies.</p> <p>First, you need to install Rust from rustup.rs.</p> <p>Then you can install the nightly toolchain with:</p> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <p>After this you can now setup your python environment with:</p> <pre><code>uv sync --dev\n</code></pre> <p>Finally, you can install the pre-commit hooks with:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"contributing.html#testing","title":"Testing","text":"<p>The package includes both Rust and Python tests.</p> <p>To execute the Rust test suite run the following command:</p> <pre><code>cargo test\n</code></pre> <p>To execute the python test suite first install the package in editable mode with development dependencies:</p> <pre><code>uv pip install -e .\n</code></pre> <p>Then run the test suite with:</p> <pre><code>uv run pytest\n</code></pre>"},{"location":"contributing.html#rust-standards-and-guidelines","title":"Rust Standards and Guidelines","text":""},{"location":"contributing.html#rust-testing-conventions","title":"Rust Testing Conventions","text":"<p>New functions implemented in rust are expected to have unit tests and documentation tests. Unit tests should cover all edge cases and typical use cases for the function. Documentation tests should provide examples of how to use the function.</p> <p>Unit tests should be placed in the same file as the function they are testing, in a module named <code>tests</code>. The names of tests should follow the general convention of <code>test_&lt;struct&gt;_&lt;trait&gt;_&lt;method&gt;_&lt;case&gt;</code> or <code>test_&lt;function&gt;_&lt;case&gt;</code>.</p>"},{"location":"contributing.html#rust-docstring-template","title":"Rust Docstring Template","text":"<p>New functions implemented in rust are expected to use the following docstring to standardize information on functions to enable users to more easily navigate and learn the library.</p> <pre><code>{{ Function Description }}\n\n## Arguments\n\n* `argument_name`: {{ Arugment description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Returns\n\n* `value_name`: {{ Value description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Examples\n\\`\\`\\`\n{{ Implement shor function in language }}\n\\`\\`\\`\n\n## References:\n1. {{ author, *title/journal*, pp. page_number, eq. equation_number, year}}\n2. O. Montenbruck, and E. Gill, *Satellite Orbits: Models, Methods and Applications*, pp. 24, eq. 2.43 &amp; 2.44, 2012.\n</code></pre>"},{"location":"contributing.html#python-standards-and-guidelines","title":"Python Standards and Guidelines","text":""},{"location":"contributing.html#python-testing-conventions","title":"Python Testing Conventions","text":"<p>Python tests should be placed in the <code>tests</code> directory. The test structure and names should mirror the structure of the <code>brahe</code> package. For example, tests for <code>brahe.orbits.keplerian</code> should be placed in <code>tests/orbits/test_keplerian.py</code>.</p> <p>All Python tests should be exact mirrors of the Rust tests, ensuring that both implementations are equivalent and consistent. There are a few exceptions to this rule, such as tests that check for Python-specific functionality or behavior, or capabilities that are not possible to reproduce in Python due to language limitations.</p>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#rust","title":"Rust","text":""},{"location":"installation.html#python","title":"Python","text":""},{"location":"about/index.html","title":"About","text":"<p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, high-performance, and quick-to-deploy. The north-star of the development is enabling users to solve meaningful problems and answer questions quickly, easily, and correctly.</p> <p>The key features of the library are:</p> <ul> <li>Intuitive API: API designed to be easily composable, making it easy to   solve complex problems correctly by building on core functionality.</li> <li>Easy-to-Learn: Designed to be easy to use and learn. The objective is   to provide clear documentation and visibility into what the software is doing   so that users don't need to spend time reverse engineering internal routines   and more time solving their own problems.</li> <li>High-Performance: Brahe provides a Python 3.6+ wrapper that is   auto-generated from a core Rust library. This provides fast core implementation,   while allowing users to take advantage of Python's rich scientific ecosystem   if they so choose.</li> <li>Answer Questions Quickly: Brahe is designed to make it easy to code up   solutions to meaningful problems. High-fieldity, high-performance APIs are not   the end-objective, but helping users solve their problems.</li> </ul> <p>Brahe gets its name from the combination of Rust and astrodynamics (Rust + astrodynamics = Brahe). The library specifically focuses on satellite astrodynamics and space mission analysis. While the underlying concepts have been studied and known since Kepler wrote down his three laws, there are few modern software libraries that make these concepts easily accessible. While extremely well tested, other astrodynamics and mission analysis software can have an extremely steep learning curve, making it difficult to quickly run simple analysis that is known to be correct.</p> <p>Because of this, students, researchers, and engineers frequently end up reimplementing common astrodynamics and mission analysis tools with unfortunately frequent regularity. While  reimplementation of common code can be a good learning mechanisms, in most cases it is both error-prone and costs time better spent on other endeavours. This project seeks to providing an easy-to-use, well-tested library, to enable everyone to more easily, and quickly perform astrodynamics and space mission analysis without sacrificing performance or correctness. The software built in Rust for performance with bindings to Python for ease of use.</p> <p>The implementation approach is opinionated, the objective is to provide an easy-to-use and accurate astrodynamics library to enable users to quickly and correctly solve most common problem types. it is not practical to try to implement every aerodynamics model and function utilized in practice or historically. Since Brahe is open source, if a specific function is not present, or a different implementation is required, users can modify the code to address their specific use case. This means that Brahe, while we want to continue expanding the capabilities of the module over time, the immediate goal is to provide a well-tested, flexible, composable API to quickly address modern problems in astrodynamics.</p> <p>One example of this in practice is that the built-in Earth reference frame transformation utilizes the IAU 2006/2000A precession-nutation model, CIO-based transformation. Even through there are multiple ways to construct this transformation, Brahe only implements one. Another example, is that the geodetic and geocentric transformations use the latest NIMA technical report definitions for Earth's radius and flatness. If a desired model isn't implemented users are free to extend the software to address and functionality or modeling gaps that exist to address their specific application.</p>"},{"location":"about/design_decisions.html","title":"Design Decisions","text":"<p>This page documents significant design decisions of the library.</p>"},{"location":"about/design_decisions.html#default-64-bit-floating-point-functions","title":"Default 64-bit Floating Point Functions","text":"<p>There is a decision to be made as to whether to support both 32-bit and 64-bit operations for all standard functions that could be used with either type. However, this results in duplicating a large amount of code as Rust does not support overloading primitive types. While some space missions may use lower-precision processors that do not support 64-bit floating point operations, the majority of modern computers and processors do support 64-bit floating point operations. Furthermore, the primary focus of this library is for us in terrestrial applications, and analysis, or space-processors that do support 64-bit floating point operations.</p> <p>Therefore, the decision is to only support 64-bit floating point operations for the time being.</p>"},{"location":"about/design_decisions.html#inline-pyo3-annotations-vs-written-wrappers","title":"Inline PyO3 Annotations vs Written Wrappers","text":"<p>There is a decision to use PyO3 macros to generate Python bindings or  to write them manually. Currently, the decision is to write them manually to have more control over the generated code and be able to more easily navigate issues related to type conversions that can arise. As a secondary benefit separate python-formatted docstrings can be written for the new functions.</p> <p>PyO3 macros would ultimately be preferable to reduce duplication of code, the  amount of boilerplate, and to make the code more maintainable. However, at the current time the complexity and difficulty to get them working is not worth the effort. This decision may be revisited in the future, and any change  proposals and pull requests to use PyO3 macros are welcome.</p>"},{"location":"about/license.html","title":"License","text":"<p>Brahe is released under a commercially-permissive MIT License that can be found here.</p> <p>The reason is so that individuals, studens, and companies can stop reinventing the wheel to get access to useful software that solves common problems without paying prohibitive amounts of money.</p>"},{"location":"about/python_deprecation.html","title":"Pure-Python Brahe Deprecation Notice","text":"<p>The older pure-Python version of brahe is currently being deprecated in favor of a mixed Rust-Python implementation, along with improved documentation. That means that the development on the <code>master</code> branch has been frozen and will no longer be developed against. Moving forward the <code>main</code> branch will be the primary branch for the project.</p> <p>There will be point commits (less than <code>1.0.0</code>) during this period that include breaking changes.</p> <p>Furthermore, initially the features of the new implementation will not be at partity with the old python implementation, so users should pin their requirements file to use the latest commit of the master branch:</p> <pre><code>brahe @ git+https://github.com/duncaneddy/brahe@master\n</code></pre> <p>To install and use the latest master branch via pip</p> <pre><code>pip install git+https://github.com/duncaneddy/brahe.git@master\n</code></pre> <p>The old master branch can be found here.</p>"},{"location":"learn/earth_orientation_data.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth Orientation Parameters are essential data for high-precision transformations between Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) reference frames. These parameters account for irregularities in Earth's rotation that cannot be modeled purely mathematically.</p> <p>Since many transformations depend on accurate EOP data, Brahe abstracts thsi complexity through a flexible global provider system. This allows users to initialize EOP data once and have it automatically applied in all relevant calculations without needing to pass EOP data explicitly with each function call.</p>"},{"location":"learn/earth_orientation_data.html#overview","title":"Overview","text":"<p>EOP data provides corrections for:</p> <ul> <li>UT1-UTC: Difference between Universal Time (based on Earth rotation) and Coordinated Universal Time</li> <li>Polar Motion (x, y): Variation in Earth's rotation axis position relative to its crust</li> <li>Celestial Pole Offsets (dX, dY): Corrections to precession-nutation models</li> <li>Length of Day (LOD): Variations in Earth's rotation rate</li> </ul>"},{"location":"learn/earth_orientation_data.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports multiple ways to access EOP data, each suited for different use cases.</p>"},{"location":"learn/earth_orientation_data.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Uses fixed EOP data, best for applications that don't require the most current data or when internet access is unavailable.</p> <pre><code>import brahe as bh\n\n# Use built-in static data\nprovider = bh.StaticEOPProvider.from_zero() # Sets all EOP values to zero\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>Testing and development</li> <li>Offline environments</li> <li>Applications where high precision is not critical</li> </ul>"},{"location":"learn/earth_orientation_data.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Loads EOP data from IERS (International Earth Rotation and Reference Systems Service) data files. Provides the most flexibility and control over EOP data sources.</p> <pre><code>import brahe as bh\n\n# Download latest EOP file\nbh.download_standard_eop_file(\"./eop_data/finals.all.iau2000.txt\")\n\n# Load from file\nprovider = bh.FileEOPProvider.from_file(\n    \"./eop_data/finals.all.iau2000.txt\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_file_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>You manage EOP file updates externally</li> <li>You need specific historical EOP data versions</li> <li>You want full control over data sources</li> <li>Minimal runtime overhead is critical</li> </ul>"},{"location":"learn/earth_orientation_data.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manages EOP file freshness by monitoring file age and downloading updates when data becomes stale. Combines the precision of file-based data with automatic updates.</p> <pre><code>import brahe as bh\n\n# Create provider that refreshes files older than 7 days\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,          # Manual refresh only\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>Long-running services that need current EOP data for accuracy</li> <li>Applications where automatic updates are preferred over manual management</li> <li>Production systems requiring data freshness guarantees</li> </ul>"},{"location":"learn/earth_orientation_data.html#automatic-cache-management","title":"Automatic Cache Management","text":"<p>The <code>CachingEOPProvider</code> offers two refresh strategies:</p>"},{"location":"learn/earth_orientation_data.html#manual-refresh-recommended","title":"Manual Refresh (Recommended)","text":"<p>Check and update EOP data at controlled intervals:</p> <pre><code>import brahe as bh\nimport time\n\n# Create provider with manual refresh\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Use in application\nwhile True:\n    # Refresh at start of processing cycle\n    provider.refresh()\n\n    # Process data with current EOP\n    perform_calculations()\n\n    # Wait before next cycle\n    time.sleep(3600)  # 1 hour\n</code></pre> <p>Advantages:</p> <ul> <li>No performance overhead during data access</li> <li>Predictable refresh timing</li> <li>Better for batch processing and scheduled tasks</li> </ul>"},{"location":"learn/earth_orientation_data.html#auto-refresh","title":"Auto-Refresh","text":"<p>Automatically check and update on every data access:</p> <pre><code>import brahe as bh\n\n# Provider checks file age on every access\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,           # Check on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# EOP data automatically stays current\nut1_utc = provider.get_ut1_utc(mjd)\npm_x, pm_y = provider.get_pm(mjd)\n</code></pre> <p>Advantages:</p> <ul> <li>Guaranteed data freshness</li> <li>Simpler application code</li> <li>Suitable for long-running services</li> </ul> <p>Considerations:</p> <ul> <li>Small performance overhead on each access (microseconds)</li> <li>May trigger downloads during time-critical operations, potentially causing delays</li> <li>Better suited for applications where data access is not in tight loops</li> </ul>"},{"location":"learn/earth_orientation_data.html#monitoring-file-freshness","title":"Monitoring File Freshness","text":"<p>Track when EOP data was loaded and how old it is:</p> <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Check when file was loaded\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n\n# Check file age in seconds\nage_seconds = provider.file_age()\nage_hours = age_seconds / 3600\nage_days = age_seconds / 86400\n\nprint(f\"File age: {age_hours:.1f} hours ({age_days:.1f} days)\")\n\n# Refresh if needed\nif age_days &gt; 7:\n    print(\"EOP data is stale, refreshing...\")\n    provider.refresh()\n</code></pre>"},{"location":"learn/earth_orientation_data.html#eop-file-types","title":"EOP File Types","text":""},{"location":"learn/earth_orientation_data.html#standard-format-finals2000aall","title":"Standard Format (finals2000A.all)","text":"<p>Combined rapid + predicted data updated daily by IERS. Contains: - Historical data (final values) - Recent rapid service data - Predicted values for near future</p> <p>Use case: Most applications requiring current EOP data</p> <pre><code>provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#c04-format","title":"C04 Format","text":"<p>Long-term consistent EOP series from IERS C04 product. Updated less frequently but provides consistent historical record.</p> <p>Use case: Historical analysis, research, long-term consistency</p> <pre><code>provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/eopc04.txt\",\n    eop_type=\"C04\",\n    max_age_seconds=30 * 86400,  # 30 days (less frequent updates)\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#configuration-options","title":"Configuration Options","text":""},{"location":"learn/earth_orientation_data.html#interpolation","title":"Interpolation","text":"<p>Enable interpolation for smoother data between tabulated points:</p> <pre><code># With interpolation (recommended for most applications)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,  # Smooth interpolation\n    extrapolate=\"Hold\"\n)\n\n# Without interpolation (step function between points)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=False,  # No interpolation\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#extrapolation","title":"Extrapolation","text":"<p>Control behavior for dates outside the EOP data range:</p> <pre><code># Hold last value (recommended for most applications)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"  # Use last known value\n)\n\n# Return zero for out-of-range dates\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Zero\"  # Return 0.0\n)\n\n# Raise error for out-of-range dates\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Error\"  # Raise exception\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#recommended-refresh-intervals","title":"Recommended Refresh Intervals","text":"<p>Choose refresh intervals based on your accuracy requirements:</p> Application Type Recommended Interval Rationale Real-time operations 1-3 days Balance freshness with download overhead Batch processing 7 days Weekly updates sufficient for most accuracy needs Historical analysis 30+ days Data rarely changes for historical periods Testing/development No auto-refresh Use manual refresh as needed <pre><code>import brahe as bh\n\n# Real-time operations\nrealtime_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/realtime.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=2 * 86400,  # 2 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Batch processing\nbatch_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/batch.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Historical analysis\nhistorical_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/historical.txt\",\n    eop_type=\"C04\",\n    max_age_seconds=30 * 86400,  # 30 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#complete-example-long-running-service","title":"Complete Example: Long-Running Service","text":"<pre><code>import brahe as bh\nimport time\nfrom datetime import datetime\n\n# Initialize caching provider for service\nprovider = bh.CachingEOPProvider(\n    filepath=\"/var/lib/myapp/eop_data/finals.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=3 * 86400,  # 3 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider_from_caching_provider(provider)\n\nprint(\"Service started with EOP caching\")\nprint(f\"Initial EOP age: {provider.file_age() / 86400:.1f} days\")\n\n# Service loop\nwhile True:\n    # Refresh EOP data at start of cycle\n    try:\n        provider.refresh()\n        print(f\"EOP refreshed at {datetime.now()}\")\n    except Exception as e:\n        print(f\"EOP refresh failed: {e}\")\n        # Continue with existing data\n\n    # Perform calculations with current EOP data\n    for mjd in range(59000, 59100):\n        try:\n            # Frame transformations automatically use global EOP provider\n            ut1_utc = bh.get_global_ut1_utc(mjd)\n            pm_x, pm_y = bh.get_global_pm(mjd)\n\n            # Use for ECEF/ECI transformations\n            # ...\n\n        except Exception as e:\n            print(f\"Error processing MJD {mjd}: {e}\")\n\n    # Log current EOP file age\n    age_days = provider.file_age() / 86400\n    print(f\"EOP file age: {age_days:.1f} days\")\n\n    # Wait before next cycle (e.g., hourly processing)\n    time.sleep(3600)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#thread-safety","title":"Thread Safety","text":"<p><code>CachingEOPProvider</code> is thread-safe and can be safely shared across multiple threads:</p> <pre><code>import brahe as bh\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Create shared provider\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\ndef process_epoch(mjd):\n    \"\"\"Process epoch using shared EOP provider\"\"\"\n    ut1_utc = provider.get_ut1_utc(mjd)\n    pm_x, pm_y = provider.get_pm(mjd)\n    # Process...\n    return result\n\n# Process epochs concurrently\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    mjds = range(59000, 60000)\n    results = list(executor.map(process_epoch, mjds))\n</code></pre>"},{"location":"learn/earth_orientation_data.html#see-also","title":"See Also","text":"<ul> <li>Frame Transformations - Using EOP data for coordinate frame conversions</li> <li>Time Systems - Understanding UT1, UTC, and other time systems</li> <li>API Reference: EOP Module - Complete API documentation</li> </ul>"},{"location":"library_api/index.html","title":"Python API Reference","text":"<p>This section provides comprehensive documentation for the Brahe Python API. All classes, functions, and modules are documented with detailed descriptions, parameters, return values, and usage examples.</p>"},{"location":"library_api/index.html#core-modules","title":"Core Modules","text":""},{"location":"library_api/index.html#time","title":"Time","text":"<p>The time module provides precise time representation and conversion between different time systems (UTC, TAI, GPS, TT, UT1). The <code>Epoch</code> class is the foundational time representation used throughout Brahe.</p> <p>Key Components: - <code>Epoch</code>: High-precision time representation with nanosecond accuracy - Time system conversions and utilities</p>"},{"location":"library_api/index.html#coordinates","title":"Coordinates","text":"<p>Coordinate transformation functions for converting between various coordinate systems used in astrodynamics.</p> <p>Key Components: - Cartesian coordinates (position and velocity vectors) - Geodetic coordinates (latitude, longitude, altitude) - Geocentric coordinates - Topocentric coordinates (East-North-Up, South-East-Zenith)</p>"},{"location":"library_api/index.html#frames","title":"Frames","text":"<p>Reference frame transformations between Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) coordinate frames using IAU 2006/2000A models.</p>"},{"location":"library_api/index.html#orbits","title":"Orbits","text":"<p>Orbital mechanics representations and propagators for satellite trajectory computation.</p> <p>Key Components: - Keplerian orbital elements - Two-Line Element (TLE) format parsing - Analytical propagators (Keplerian, SGP4/SDP4)</p>"},{"location":"library_api/index.html#attitude","title":"Attitude","text":"<p>Attitude representation and conversion between different rotation parameterizations.</p> <p>Key Components: - Quaternions - Rotation matrices (Direction Cosine Matrices) - Euler angles (various sequences) - Euler axis-angle representation</p>"},{"location":"library_api/index.html#trajectories","title":"Trajectories","text":"<p>High-level trajectory containers with interpolation support for storing and querying orbital states over time.</p>"},{"location":"library_api/index.html#earth-orientation-parameters-eop","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth orientation parameter data management for high-precision coordinate frame transformations.</p>"},{"location":"library_api/index.html#constants","title":"Constants","text":"<p>Mathematical, physical, and time-related constants used throughout the library.</p>"},{"location":"library_api/index.html#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the detailed API documentation for each module. Each page includes:</p> <ul> <li>Complete class and function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value specifications</li> <li>Usage examples</li> <li>References to related functionality</li> </ul> <p>All documentation is automatically generated from the source code docstrings to ensure accuracy and consistency.</p>"},{"location":"library_api/frames.html","title":"Reference Frames Module","text":"<p>Reference frame transformations between ECI and ECEF coordinate systems.</p>"},{"location":"library_api/frames.html#brahe.frames","title":"frames","text":"<p>Reference Frames Module</p> <p>Reference frame transformations between ECI and ECEF coordinate systems.</p> <p>This module provides transformations between: - ECI (Earth-Centered Inertial): J2000/GCRF frame - ECEF (Earth-Centered Earth-Fixed): ITRF frame</p> <p>The transformations implement the IAU 2006/2000A precession-nutation model and use Earth Orientation Parameters (EOP) for high-precision conversions.</p> <p>Functions are provided for: - Rotation matrices (bias-precession-nutation, Earth rotation, polar motion) - Position vector transformations - State vector (position + velocity) transformations</p>"},{"location":"library_api/frames.html#brahe.frames.bias_precession_nutation","title":"bias_precession_nutation  <code>builtin</code>","text":"<pre><code>bias_precession_nutation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Bias-Precession-Nutation matrix transforming the <code>GCRS</code> to the <code>CIRS</code> intermediate reference frame. This transformation corrects for the bias, precession, and nutation of Celestial Intermediate Origin (<code>CIO</code>) with respect to inertial space.</p> <p>This formulation computes the Bias-Precession-Nutation correction matrix according using a <code>CIO</code> based model using using the <code>IAU 2006</code> precession and <code>IAU 2000A</code> nutation models.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to the Celestial Intermediate Pole (<code>CIP</code>) derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRS</code> -&gt; <code>CIRS</code></p> References <p>IAU SOFA Tools For Earth Attitude, Example 5.5 http://www.iausofa.org/2021_0512_C/sofa/sofa_pn_c.pdf Software Version 18, 2021-04-18</p>"},{"location":"library_api/frames.html#brahe.frames.earth_rotation","title":"earth_rotation  <code>builtin</code>","text":"<pre><code>earth_rotation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>CIRS</code> to the <code>TIRS</code> intermediate reference frame. This transformation corrects for the Earth rotation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>CIRS</code> -&gt; <code>TIRS</code></p>"},{"location":"library_api/frames.html#brahe.frames.polar_motion","title":"polar_motion  <code>builtin</code>","text":"<pre><code>polar_motion(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>TIRS</code> to the <code>ITRF</code> reference frame.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to compute the polar motion correction based on empirical observations of polar motion drift.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>TIRS</code> -&gt; <code>ITRF</code></p>"},{"location":"library_api/frames.html#brahe.frames.rotation_eci_to_ecef","title":"rotation_eci_to_ecef  <code>builtin</code>","text":"<pre><code>rotation_eci_to_ecef(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>ITRF</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix\nR = bh.rotation_eci_to_ecef(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_ecef_to_eci","title":"rotation_ecef_to_eci  <code>builtin</code>","text":"<pre><code>rotation_ecef_to_eci(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>ITRF</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR = bh.rotation_ecef_to_eci(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_eci_to_ecef","title":"position_eci_to_ecef  <code>builtin</code>","text":"<pre><code>position_eci_to_ecef(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in ECI (meters)\nr_eci = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ECEF\nr_ecef = bh.position_eci_to_ecef(epc, r_eci)\nprint(f\"ECEF position: {r_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_ecef_to_eci","title":"position_ecef_to_eci  <code>builtin</code>","text":"<pre><code>position_ecef_to_eci(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ECEF (ground station)\nr_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to ECI\nr_eci = bh.position_ecef_to_eci(epc, r_ecef)\nprint(f\"ECI position: {r_eci}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_eci_to_ecef","title":"state_eci_to_ecef  <code>builtin</code>","text":"<pre><code>state_eci_to_ecef(epc: Epoch, x_eci: ndarray) -&gt; np.ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_eci</code> <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECI [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eci = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\nprint(f\"ECEF state: {state_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_ecef_to_eci","title":"state_ecef_to_eci  <code>builtin</code>","text":"<pre><code>state_ecef_to_eci(epc: Epoch, x_ecef: ndarray) -&gt; np.ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_ecef</code> <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_ecef = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to ECI\nstate_eci = bh.state_ecef_to_eci(epc, state_ecef)\nprint(f\"ECI state: {state_eci}\")\n</code></pre>"},{"location":"library_api/attitude/index.html","title":"Attitude","text":"<p>Module: <code>brahe.attitude</code></p> <p>Classes for representing and converting between different attitude representations.</p>"},{"location":"library_api/attitude/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Quaternion - Quaternion representation</li> <li>Rotation Matrix - Direction Cosine Matrix (DCM) representation</li> <li>Euler Angles - Euler angle sequences</li> <li>Euler Axis - Euler axis-angle representation</li> </ul>"},{"location":"library_api/attitude/euler_angles.html","title":"EulerAngle Class","text":"<p>The <code>EulerAngle</code> class represents attitude using Euler angle sequences for intuitive spacecraft orientation specification.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle","title":"EulerAngle","text":"<pre><code>EulerAngle(order: str, phi: float, theta: float, psi: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler angles.</p> <p>Euler angles describe rotations as a sequence of three rotations about specified axes. The rotation sequence is specified by the order parameter (e.g., \"XYZ\", \"ZYX\").</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")</p> required <code>phi</code> <code>float</code> <p>First rotation angle in radians or degrees</p> required <code>theta</code> <code>float</code> <p>Second rotation angle in radians or degrees</p> required <code>psi</code> <code>float</code> <p>Third rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\n\n# Create Euler angle rotation (roll, pitch, yaw in ZYX order)\ne = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n\n# Convert to rotation matrix\ndcm = e.to_rotation_matrix()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler angles.\\n\\nEuler angles describe rotations as a sequence of three rotations about\\nspecified axes. The rotation sequence is specified by the order parameter\\n(e.g., \"XYZ\", \"ZYX\").\\n\\nArgs:\\n    order (str): Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")\\n    phi (float): First rotation angle in radians or degrees\\n    theta (float): Second rotation angle in radians or degrees\\n    psi (float): Third rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angles (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create Euler angle rotation (roll, pitch, yaw in ZYX order)\\n    e = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\\n    print(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n\\n    # Convert to rotation matrix\\n    dcm = e.to_rotation_matrix()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.order","title":"order  <code>property</code>","text":"<pre><code>order: str\n</code></pre> <p>Get the rotation sequence order.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Order: {e.order}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.phi","title":"phi  <code>property</code>","text":"<pre><code>phi: float\n</code></pre> <p>Get the first rotation angle (phi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Phi: {e.phi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.psi","title":"psi  <code>property</code>","text":"<pre><code>psi: float\n</code></pre> <p>Get the third rotation angle (psi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Third rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Psi: {e.psi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.theta","title":"theta  <code>property</code>","text":"<pre><code>theta: float\n</code></pre> <p>Get the second rotation angle (theta) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Theta: {e.theta}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from another Euler angle with different order.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Source Euler angles</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAngle.from_euler_angle(e1, \"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = bh.EulerAngle.from_euler_axis(ea, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAngle.from_quaternion(q, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAngle.from_rotation_matrix(r, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, order: str, angle_format: AngleFormat) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>3-element array [phi, theta, psi]</p> required <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>New Euler angle instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.1, 0.2, 0.3])\neuler = bh.EulerAngle.from_vector(v, \"XYZ\", bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angles with different rotation sequence.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_angle(\"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nea = e.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html","title":"EulerAxis Class","text":"<p>The <code>EulerAxis</code> class represents attitude using axis-angle representation (Euler's rotation theorem).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis","title":"EulerAxis","text":"<pre><code>EulerAxis(axis: ndarray, angle: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler axis-angle representation.</p> <p>The Euler axis-angle representation describes a rotation as a single rotation about a specified axis by a given angle. This is also known as the axis-angle or rotation vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>3-element unit vector specifying rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Rotation of 90 degrees about z-axis\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle} rad\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler axis-angle representation.\\n\\nThe Euler axis-angle representation describes a rotation as a single rotation\\nabout a specified axis by a given angle. This is also known as the axis-angle\\nor rotation vector representation.\\n\\nArgs:\\n    axis (numpy.ndarray): 3-element unit vector specifying rotation axis\\n    angle (float): Rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angle (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Rotation of 90 degrees about z-axis\\n    axis = np.array([0.0, 0.0, 1.0])\\n    e = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\\n    print(f\"Angle: {e.angle} rad\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.angle","title":"angle  <code>property</code>","text":"<pre><code>angle: float\n</code></pre> <p>Get the rotation angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rotation angle in radians</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.axis","title":"axis  <code>property</code>","text":"<pre><code>axis: ndarray\n</code></pre> <p>Get the rotation axis as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3-element unit vector specifying rotation axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Axis: {e.axis}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne = bh.EulerAxis.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from another Euler axis (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Source Euler axis</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAxis.from_euler_axis(e1)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAxis.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAxis.from_rotation_matrix(r)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(x: float, y: float, z: float, angle: float, angle_format: AngleFormat) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from individual axis components and angle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X component of rotation axis</p> required <code>y</code> <code>float</code> <p>Y component of rotation axis</p> required <code>z</code> <code>float</code> <p>Z component of rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAxis.from_values(0.0, 0.0, 1.0, 1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, angle_format: AngleFormat, vector_first: bool) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing axis and angle</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, array is [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.0, 0.0, 1.0, 1.5708])\ne = bh.EulerAxis.from_vector(v, bh.AngleFormat.RADIANS, True)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = ea.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation (returns self).</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>This Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(angle_format: AngleFormat, vector_first: bool) -&gt; np.ndarray\n</code></pre> <p>Convert Euler axis to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Units for output angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, returns [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing axis and angle</p>"},{"location":"library_api/attitude/quaternion.html","title":"Quaternion Class","text":"<p>The <code>Quaternion</code> class provides a compact, singularity-free representation of 3D rotations for spacecraft attitude determination and control.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(w: float, x: float, y: float, z: float)\n</code></pre> <p>Represents a quaternion for 3D rotations.</p> <p>Quaternions provide a compact, singularity-free representation of rotations. The quaternion is stored as [w, x, y, z] where w is the scalar part and [x, y, z] is the vector part.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Scalar component</p> required <code>x</code> <code>float</code> <p>X component of vector part</p> required <code>y</code> <code>float</code> <p>Y component of vector part</p> required <code>z</code> <code>float</code> <p>Z component of vector part</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity quaternion\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nprint(f\"Norm: {q.norm()}\")\n\n# Create from array\nq_vec = np.array([1.0, 0.0, 0.0, 0.0])\nq2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\n\n# Convert to rotation matrix\ndcm = q.to_rotation_matrix()\n\n# Quaternion multiplication\nq3 = q * q2\n\n# Normalize\nq3.normalize()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a quaternion for 3D rotations.\\n\\nQuaternions provide a compact, singularity-free representation of rotations.\\nThe quaternion is stored as [w, x, y, z] where w is the scalar part and\\n[x, y, z] is the vector part.\\n\\nArgs:\\n    w (float): Scalar component\\n    x (float): X component of vector part\\n    y (float): Y component of vector part\\n    z (float): Z component of vector part\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity quaternion\\n    q = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\\n    print(f\"Norm: {q.norm()}\")\\n\\n    # Create from array\\n    q_vec = np.array([1.0, 0.0, 0.0, 0.0])\\n    q2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\\n\\n    # Convert to rotation matrix\\n    dcm = q.to_rotation_matrix()\\n\\n    # Quaternion multiplication\\n    q3 = q * q2\\n\\n    # Normalize\\n    q3.normalize()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the quaternion components as a numpy array [w, x, y, z].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.conjugate","title":"conjugate  <code>method descriptor</code>","text":"<pre><code>conjugate() -&gt; Quaternion\n</code></pre> <p>Compute the conjugate of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Conjugate quaternion with negated vector part</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_conj = q.conjugate()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from another quaternion (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion.from_quaternion(q1)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nrm = bh.RotationMatrix.from_matrix(mat)\nq = bh.Quaternion.from_rotation_matrix(rm)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, scalar_first: bool) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing quaternion components</p> required <code>scalar_first</code> <code>bool</code> <p>If True, array is [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([1.0, 0.0, 0.0, 0.0])\nq = bh.Quaternion.from_vector(v, scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.inverse","title":"inverse  <code>method descriptor</code>","text":"<pre><code>inverse() -&gt; Quaternion\n</code></pre> <p>Compute the inverse of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Inverse quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_inv = q.inverse()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.norm","title":"norm  <code>method descriptor</code>","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Calculate the norm (magnitude) of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean norm of the quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nnorm = q.norm()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.normalize","title":"normalize  <code>method descriptor</code>","text":"<pre><code>normalize() -&gt; Any\n</code></pre> <p>Normalize the quaternion in-place to unit length.</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(2.0, 0.0, 0.0, 0.0)\nq.normalize()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.slerp","title":"slerp  <code>method descriptor</code>","text":"<pre><code>slerp(other: Quaternion, t: float) -&gt; Quaternion\n</code></pre> <p>Perform spherical linear interpolation (SLERP) between two quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Quaternion</code> <p>Target quaternion</p> required <code>t</code> <code>float</code> <p>Interpolation parameter in [0, 1]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Interpolated quaternion</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion(0.707, 0.707, 0.0, 0.0)\nq_mid = q1.slerp(q2, 0.5)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = q.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation (returns self).</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>This quaternion</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(scalar_first: bool) -&gt; np.ndarray\n</code></pre> <p>Convert quaternion to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_first</code> <code>bool</code> <p>If True, returns [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nv = q.to_vector(scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html","title":"RotationMatrix Class","text":"<p>The <code>RotationMatrix</code> class represents attitude using Direction Cosine Matrices (DCM) for spacecraft orientation and coordinate transformations.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix","title":"RotationMatrix","text":"<pre><code>RotationMatrix(r11: float, r12: float, r13: float, r21: float, r22: float, r23: float, r31: float, r32: float, r33: float)\n</code></pre> <p>Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).</p> <p>A rotation matrix is an orthogonal 3x3 matrix with determinant +1 that represents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>r11</code> <code>float</code> <p>Element at row 1, column 1</p> required <code>r12</code> <code>float</code> <p>Element at row 1, column 2</p> required <code>r13</code> <code>float</code> <p>Element at row 1, column 3</p> required <code>r21</code> <code>float</code> <p>Element at row 2, column 1</p> required <code>r22</code> <code>float</code> <p>Element at row 2, column 2</p> required <code>r23</code> <code>float</code> <p>Element at row 2, column 3</p> required <code>r31</code> <code>float</code> <p>Element at row 3, column 1</p> required <code>r32</code> <code>float</code> <p>Element at row 3, column 2</p> required <code>r33</code> <code>float</code> <p>Element at row 3, column 3</p> required <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity rotation\ndcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n\n# Create from numpy array\nR = np.eye(3)\ndcm2 = bh.RotationMatrix.from_matrix(R)\n\n# Convert to quaternion\nq = dcm.to_quaternion()\n\n# Rotate a vector\nv = np.array([1.0, 0.0, 0.0])\nv_rot = dcm.rotate_vector(v)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).\\n\\nA rotation matrix is an orthogonal 3x3 matrix with determinant +1 that\\nrepresents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).\\n\\nArgs:\\n    r11 (float): Element at row 1, column 1\\n    r12 (float): Element at row 1, column 2\\n    r13 (float): Element at row 1, column 3\\n    r21 (float): Element at row 2, column 1\\n    r22 (float): Element at row 2, column 2\\n    r23 (float): Element at row 2, column 3\\n    r31 (float): Element at row 3, column 1\\n    r32 (float): Element at row 3, column 2\\n    r33 (float): Element at row 3, column 3\\n\\nRaises:\\n    BraheError: If the matrix is not a valid rotation matrix\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity rotation\\n    dcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\\n\\n    # Create from numpy array\\n    R = np.eye(3)\\n    dcm2 = bh.RotationMatrix.from_matrix(R)\\n\\n    # Convert to quaternion\\n    q = dcm.to_quaternion()\\n\\n    # Rotate a vector\\n    v = np.array([1.0, 0.0, 0.0])\\n    v_rot = dcm.rotate_vector(v)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rx","title":"Rx  <code>builtin</code>","text":"<pre><code>Rx(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for X-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Ry","title":"Ry  <code>builtin</code>","text":"<pre><code>Ry(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Y-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rz","title":"Rz  <code>builtin</code>","text":"<pre><code>Rz(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Z-axis rotation</p> Example <pre><code>import brahe as bh\n\nr = bh.RotationMatrix.Rz(1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from an Euler axis.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_matrix","title":"from_matrix  <code>builtin</code>","text":"<pre><code>from_matrix(m: ndarray) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a 3x3 numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nr = bh.RotationMatrix.from_matrix(mat)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nr = bh.RotationMatrix.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from another rotation matrix (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Source rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = bh.RotationMatrix.from_rotation_matrix(r1)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\neuler = r.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = r.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Convert rotation matrix to a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\nq = r.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation (returns self).</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>This rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = r1.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/constants/index.html","title":"Constants","text":"<p>Mathematical, physical, and astronomical constants used throughout the brahe library.</p>"},{"location":"library_api/constants/index.html#categories","title":"Categories","text":""},{"location":"library_api/constants/index.html#units","title":"Units","text":"<p>Angle format enumerations and time system constants for specifying units and reference frames.</p>"},{"location":"library_api/constants/index.html#mathematical-constants","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/index.html#time-constants","title":"Time Constants","text":"<p>Julian date references and time system offset values.</p>"},{"location":"library_api/constants/index.html#physical-constants","title":"Physical Constants","text":"<p>Physical properties of Earth, celestial bodies, and universal constants.</p>"},{"location":"library_api/constants/index.html#quick-reference","title":"Quick Reference","text":"<p>All constants use SI base units unless otherwise noted:</p> <ul> <li>Distance: meters (m)</li> <li>Time: seconds (s)</li> <li>Angles: radians (rad)</li> <li>Gravitational Parameter: m\u00b3/s\u00b2</li> </ul> <p>Constants are accessible directly from the <code>brahe</code> module:</p> <pre><code>import brahe as bh\n\n# Mathematical constants\nangle_rad = 45.0 * bh.DEG2RAD  # Convert degrees to radians\n\n# Physical constants\nmu_earth = bh.GM_EARTH  # Earth's gravitational parameter\nc = bh.C_LIGHT          # Speed of light\n\n# Time system\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n</code></pre>"},{"location":"library_api/constants/math.html","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/math.html#angle-conversions","title":"Angle Conversions","text":""},{"location":"library_api/constants/math.html#deg2rad","title":"DEG2RAD","text":"<p>Value: <code>0.017453292519943295</code> rad/deg</p> <p>Converts degrees to radians. Equivalent to \u03c0/180.</p>"},{"location":"library_api/constants/math.html#brahe.DEG2RAD","title":"DEG2RAD  <code>module-attribute</code>","text":"<pre><code>DEG2RAD: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2deg","title":"RAD2DEG","text":"<p>Value: <code>57.29577951308232</code> deg/rad</p> <p>Converts radians to degrees. Equivalent to 180/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2DEG","title":"RAD2DEG  <code>module-attribute</code>","text":"<pre><code>RAD2DEG: float = 57.29577951308232\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#as2rad","title":"AS2RAD","text":"<p>Value: <code>4.84813681109536e-06</code> rad/arcsec</p> <p>Converts arc seconds to radians. Equivalent to \u03c0/(180 \u00d7 3600).</p>"},{"location":"library_api/constants/math.html#brahe.AS2RAD","title":"AS2RAD  <code>module-attribute</code>","text":"<pre><code>AS2RAD: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2as","title":"RAD2AS","text":"<p>Value: <code>206264.80624709636</code> arcsec/rad</p> <p>Converts radians to arc seconds. Equivalent to (180 \u00d7 3600)/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2AS","title":"RAD2AS  <code>module-attribute</code>","text":"<pre><code>RAD2AS: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html","title":"Physical Constants","text":"<p>Physical properties of celestial bodies and universal constants. All values use SI base units.</p>"},{"location":"library_api/constants/physical.html#universal-constants","title":"Universal Constants","text":""},{"location":"library_api/constants/physical.html#c_light","title":"C_LIGHT","text":"<p>Value: <code>299792458.0</code> m/s</p> <p>Speed of light in vacuum.</p>"},{"location":"library_api/constants/physical.html#brahe.C_LIGHT","title":"C_LIGHT  <code>module-attribute</code>","text":"<pre><code>C_LIGHT: float = 299792458.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#au","title":"AU","text":"<p>Value: <code>1.495978707e11</code> m</p> <p>Astronomical Unit - mean distance of Earth from the Sun. TDB-compatible value.</p>"},{"location":"library_api/constants/physical.html#brahe.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870700.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#p_sun","title":"P_SUN","text":"<p>Value: <code>4.56e-6</code> N/m\u00b2</p> <p>Solar radiation pressure at 1 AU.</p>"},{"location":"library_api/constants/physical.html#brahe.P_SUN","title":"P_SUN  <code>module-attribute</code>","text":"<pre><code>P_SUN: float = 4.56e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#earth-constants","title":"Earth Constants","text":""},{"location":"library_api/constants/physical.html#geometry","title":"Geometry","text":""},{"location":"library_api/constants/physical.html#r_earth","title":"R_EARTH","text":"<p>Value: <code>6378136.3</code> m</p> <p>Earth's equatorial radius (GGM05 gravity model).</p>"},{"location":"library_api/constants/physical.html#brahe.R_EARTH","title":"R_EARTH  <code>module-attribute</code>","text":"<pre><code>R_EARTH: float = 6378136.3\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_a","title":"WGS84_A","text":"<p>Value: <code>6378137.0</code> m</p> <p>Earth's semi-major axis as defined by WGS84 geodetic system.</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_A","title":"WGS84_A  <code>module-attribute</code>","text":"<pre><code>WGS84_A: float = 6378137.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_f","title":"WGS84_F","text":"<p>Value: <code>0.0033528106647474805</code> (dimensionless)</p> <p>Earth's ellipsoidal flattening. WGS84 value: 1/298.257223563</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_F","title":"WGS84_F  <code>module-attribute</code>","text":"<pre><code>WGS84_F: float = 0.0033528106647474805\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#ecc_earth","title":"ECC_EARTH","text":"<p>Value: <code>0.081819190842622</code> (dimensionless)</p> <p>Earth's first eccentricity (WGS84 value).</p>"},{"location":"library_api/constants/physical.html#brahe.ECC_EARTH","title":"ECC_EARTH  <code>module-attribute</code>","text":"<pre><code>ECC_EARTH: float = 0.081819190842622\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gravitational-properties","title":"Gravitational Properties","text":""},{"location":"library_api/constants/physical.html#gm_earth","title":"GM_EARTH","text":"<p>Value: <code>3.986004415e14</code> m\u00b3/s\u00b2</p> <p>Earth's gravitational parameter (\u03bc = G \u00d7 M).</p>"},{"location":"library_api/constants/physical.html#brahe.GM_EARTH","title":"GM_EARTH  <code>module-attribute</code>","text":"<pre><code>GM_EARTH: float = 398600441500000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#j2_earth","title":"J2_EARTH","text":"<p>Value: <code>0.0010826358191967</code> (dimensionless)</p> <p>Earth's J2 zonal harmonic coefficient (GGM05s gravity model). Represents Earth's oblateness.</p>"},{"location":"library_api/constants/physical.html#brahe.J2_EARTH","title":"J2_EARTH  <code>module-attribute</code>","text":"<pre><code>J2_EARTH: float = 0.0010826358191967\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#omega_earth","title":"OMEGA_EARTH","text":"<p>Value: <code>7.292115146706979e-05</code> rad/s</p> <p>Earth's axial rotation rate.</p>"},{"location":"library_api/constants/physical.html#brahe.OMEGA_EARTH","title":"OMEGA_EARTH  <code>module-attribute</code>","text":"<pre><code>OMEGA_EARTH: float = 7.292115146706979e-05\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#celestial-body-gravitational-parameters","title":"Celestial Body Gravitational Parameters","text":"<p>Gravitational parameters (\u03bc = G \u00d7 M) for major solar system bodies in m\u00b3/s\u00b2.</p>"},{"location":"library_api/constants/physical.html#sun","title":"Sun","text":""},{"location":"library_api/constants/physical.html#gm_sun","title":"GM_SUN","text":"<p>Value: <code>1.32712440041939e20</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SUN","title":"GM_SUN  <code>module-attribute</code>","text":"<pre><code>GM_SUN: float = 1.327124400419394e+20\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_sun","title":"R_SUN","text":"<p>Value: <code>6.9634e8</code> m</p> <p>Solar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_SUN","title":"R_SUN  <code>module-attribute</code>","text":"<pre><code>R_SUN: float = 695700000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#moon","title":"Moon","text":""},{"location":"library_api/constants/physical.html#gm_moon","title":"GM_MOON","text":"<p>Value: <code>4.9028e12</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MOON","title":"GM_MOON  <code>module-attribute</code>","text":"<pre><code>GM_MOON: float = 4902800066000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_moon","title":"R_MOON","text":"<p>Value: <code>1.738e6</code> m</p> <p>Lunar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_MOON","title":"R_MOON  <code>module-attribute</code>","text":"<pre><code>R_MOON: float = 1738000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#inner-planets","title":"Inner Planets","text":""},{"location":"library_api/constants/physical.html#gm_mercury","title":"GM_MERCURY","text":"<p>Value: <code>2.2031868551e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MERCURY","title":"GM_MERCURY  <code>module-attribute</code>","text":"<pre><code>GM_MERCURY: float = 22031780000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_venus","title":"GM_VENUS","text":"<p>Value: <code>3.257e14</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_VENUS","title":"GM_VENUS  <code>module-attribute</code>","text":"<pre><code>GM_VENUS: float = 324858592000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_mars","title":"GM_MARS","text":"<p>Value: <code>4.305e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MARS","title":"GM_MARS  <code>module-attribute</code>","text":"<pre><code>GM_MARS: float = 42828375210000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#outer-planets","title":"Outer Planets","text":""},{"location":"library_api/constants/physical.html#gm_jupiter","title":"GM_JUPITER","text":"<p>Value: <code>1.268e17</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_JUPITER","title":"GM_JUPITER  <code>module-attribute</code>","text":"<pre><code>GM_JUPITER: float = 1.267127648e+17\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_saturn","title":"GM_SATURN","text":"<p>Value: <code>3.794e16</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SATURN","title":"GM_SATURN  <code>module-attribute</code>","text":"<pre><code>GM_SATURN: float = 3.79405852e+16\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_uranus","title":"GM_URANUS","text":"<p>Value: <code>5.794e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_URANUS","title":"GM_URANUS  <code>module-attribute</code>","text":"<pre><code>GM_URANUS: float = 5794548600000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_neptune","title":"GM_NEPTUNE","text":"<p>Value: <code>6.837e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_NEPTUNE","title":"GM_NEPTUNE  <code>module-attribute</code>","text":"<pre><code>GM_NEPTUNE: float = 6836527100580000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#dwarf-planets","title":"Dwarf Planets","text":""},{"location":"library_api/constants/physical.html#gm_pluto","title":"GM_PLUTO","text":"<p>Value: <code>9.77e11</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_PLUTO","title":"GM_PLUTO  <code>module-attribute</code>","text":"<pre><code>GM_PLUTO: float = 977000000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html","title":"Time Constants","text":"<p>Constants related to time systems, epochs, and time conversions.</p>"},{"location":"library_api/constants/time.html#julian-date-references","title":"Julian Date References","text":""},{"location":"library_api/constants/time.html#mjd_zero","title":"MJD_ZERO","text":"<p>Value: <code>2400000.5</code> days</p> <p>Offset of Modified Julian Date (MJD) with respect to Julian Date (JD). For any time t: <pre><code>MJD_ZERO = JD - MJD\n</code></pre></p>"},{"location":"library_api/constants/time.html#brahe.MJD_ZERO","title":"MJD_ZERO  <code>module-attribute</code>","text":"<pre><code>MJD_ZERO: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#mjd2000","title":"MJD2000","text":"<p>Value: <code>51544.5</code> days</p> <p>Modified Julian Date of January 1, 2000 12:00:00 (J2000.0 epoch). Value is independent of time system.</p>"},{"location":"library_api/constants/time.html#brahe.MJD2000","title":"MJD2000  <code>module-attribute</code>","text":"<pre><code>MJD2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps_zero","title":"GPS_ZERO","text":"<p>Value: <code>44244.0</code> days</p> <p>Modified Julian Date of the start of GPS time (January 6, 1980 00:00:00 UTC).</p>"},{"location":"library_api/constants/time.html#brahe.GPS_ZERO","title":"GPS_ZERO  <code>module-attribute</code>","text":"<pre><code>GPS_ZERO: float = 44244.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#time-system-offsets","title":"Time System Offsets","text":"<p>All offset values are in seconds.</p>"},{"location":"library_api/constants/time.html#gps-tai","title":"GPS \u2194 TAI","text":""},{"location":"library_api/constants/time.html#gps_tai","title":"GPS_TAI","text":"<p>Value: <code>-19.0</code> seconds</p> <p>Offset of GPS time with respect to TAI: <code>GPS = TAI + GPS_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TAI","title":"GPS_TAI  <code>module-attribute</code>","text":"<pre><code>GPS_TAI: float = -19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_gps","title":"TAI_GPS","text":"<p>Value: <code>19.0</code> seconds</p> <p>Offset of TAI time with respect to GPS: <code>TAI = GPS + TAI_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_GPS","title":"TAI_GPS  <code>module-attribute</code>","text":"<pre><code>TAI_GPS: float = 19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt-tai","title":"TT \u2194 TAI","text":""},{"location":"library_api/constants/time.html#tt_tai","title":"TT_TAI","text":"<p>Value: <code>32.184</code> seconds</p> <p>Offset of Terrestrial Time with respect to TAI: <code>TT = TAI + TT_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_TAI","title":"TT_TAI  <code>module-attribute</code>","text":"<pre><code>TT_TAI: float = 32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_tt","title":"TAI_TT","text":"<p>Value: <code>-32.184</code> seconds</p> <p>Offset of TAI with respect to Terrestrial Time: <code>TAI = TT + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_TT","title":"TAI_TT  <code>module-attribute</code>","text":"<pre><code>TAI_TT: float = -32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps-tt","title":"GPS \u2194 TT","text":""},{"location":"library_api/constants/time.html#gps_tt","title":"GPS_TT","text":"<p>Value: <code>13.184</code> seconds</p> <p>Offset of GPS time with respect to TT: <code>GPS = TT + GPS_TT</code></p> <p>Computed as: <code>GPS_TAI + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TT","title":"GPS_TT  <code>module-attribute</code>","text":"<pre><code>GPS_TT: float = -51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt_gps","title":"TT_GPS","text":"<p>Value: <code>-13.184</code> seconds</p> <p>Offset of TT with respect to GPS time: <code>TT = GPS + TT_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_GPS","title":"TT_GPS  <code>module-attribute</code>","text":"<pre><code>TT_GPS: float = 51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/units.html","title":"Units","text":"<p>Enumerations for specifying angle formats and time systems.</p>"},{"location":"library_api/constants/units.html#angle-format","title":"Angle Format","text":"<p>The <code>AngleFormat</code> enumeration specifies whether angles are in radians or degrees.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create rotation with angle in degrees\nq = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=90.0,\n    angle_format=bh.AngleFormat.DEGREES\n)\n\n# Create rotation with angle in radians\nq2 = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=np.pi/2,\n    angle_format=bh.AngleFormat.RADIANS\n)\n</code></pre>"},{"location":"library_api/constants/units.html#time-system","title":"Time System","text":"<p>The <code>TimeSystem</code> enumeration specifies the time reference system for epochs.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem","title":"TimeSystem","text":"<pre><code>TimeSystem()\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UTC","title":"UTC  <code>class-attribute</code>","text":"<pre><code>UTC: Any = TimeSystem.UTC\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TAI","title":"TAI  <code>class-attribute</code>","text":"<pre><code>TAI: Any = TimeSystem.TAI\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TT","title":"TT  <code>class-attribute</code>","text":"<pre><code>TT: Any = TimeSystem.TT\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.GPS","title":"GPS  <code>class-attribute</code>","text":"<pre><code>GPS: Any = TimeSystem.GPS\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UT1","title":"UT1  <code>class-attribute</code>","text":"<pre><code>UT1: Any = TimeSystem.UT1\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#time-system-descriptions","title":"Time System Descriptions","text":"<ul> <li>UTC (Coordinated Universal Time): Civil time standard used worldwide. Includes leap seconds to keep within 0.9 seconds of UT1.</li> <li>TAI (International Atomic Time): Continuous time scale based on atomic clocks. Currently 37 seconds ahead of UTC (as of 2024).</li> <li>TT (Terrestrial Time): Theoretical time scale for solar system calculations. TT = TAI + 32.184 seconds.</li> <li>GPS (Global Positioning System): Continuous time starting from GPS epoch (January 6, 1980). Does not include leap seconds.</li> <li>UT1 (Universal Time 1): Based on Earth's rotation. Computed from UTC using Earth Orientation Parameters (EOP).</li> </ul>"},{"location":"library_api/constants/units.html#usage-example_1","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Create epoch in different time systems\nutc_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ntai_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.TAI)\ngps_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\n\n# Time system is preserved in the epoch\nprint(utc_epoch.time_system)  # Output: UTC\nprint(tai_epoch.time_system)  # Output: TAI\n</code></pre>"},{"location":"library_api/coordinates/index.html","title":"Coordinates","text":"<p>Module: <code>brahe.coordinates</code></p> <p>Comprehensive coordinate system transformations for satellite dynamics.</p>"},{"location":"library_api/coordinates/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Enumerations - Coordinate type enumerations (EllipsoidalConversionType, AngleFormat)</li> <li>Cartesian Coordinates - Cartesian state vectors and orbital element conversions</li> <li>Geodetic &amp; Geocentric - WGS84 geodetic and geocentric coordinate conversions</li> <li>Topocentric Coordinates - Local topocentric frames (ENZ, SEZ, AzElRange)</li> </ul>"},{"location":"library_api/coordinates/cartesian.html","title":"Cartesian Coordinates","text":"<p>Functions for working with Cartesian state vectors and conversions.</p>"},{"location":"library_api/coordinates/cartesian.html#state-conversions","title":"State Conversions","text":""},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_osculating_to_cartesian","title":"state_osculating_to_cartesian  <code>builtin</code>","text":"<pre><code>state_osculating_to_cartesian(x_oe: ndarray, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Convert osculating orbital elements to Cartesian state.</p> <p>Transforms a state vector from osculating Keplerian orbital elements to Cartesian position and velocity coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_oe</code> <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Orbital elements for a circular orbit\noe = np.array([7000000.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\nx_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprint(f\"Cartesian state: {x_cart}\")\n</code></pre>"},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_cartesian_to_osculating","title":"state_cartesian_to_osculating  <code>builtin</code>","text":"<pre><code>state_cartesian_to_osculating(x_cart: ndarray, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Convert Cartesian state to osculating orbital elements.</p> <p>Transforms a state vector from Cartesian position and velocity coordinates to osculating Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>x_cart</code> <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Cartesian state vector\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])  # [x, y, z, vx, vy, vz]\noe = bh.state_cartesian_to_osculating(x_cart, bh.AngleFormat.RADIANS)\nprint(f\"Orbital elements: a={oe[0]:.0f}m, e={oe[1]:.6f}, i={oe[2]:.6f} rad\")\n</code></pre>"},{"location":"library_api/coordinates/enums.html","title":"Coordinate Enumerations","text":"<p>Enumerations for specifying coordinate transformation types.</p>"},{"location":"library_api/coordinates/enums.html#ellipsoidalconversiontype","title":"EllipsoidalConversionType","text":"<p>Specifies the type of ellipsoidal conversion used in topocentric coordinate transformations.</p> <p>Values: - <code>GEOCENTRIC</code> - Uses geocentric latitude where the angle is measured from the center of the Earth - <code>GEODETIC</code> - Uses geodetic latitude where the angle is measured perpendicular to the WGS84 ellipsoid</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType","title":"EllipsoidalConversionType","text":"<pre><code>EllipsoidalConversionType()\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEOCENTRIC","title":"GEOCENTRIC  <code>class-attribute</code>","text":"<pre><code>GEOCENTRIC: Any = EllipsoidalConversionType.Geocentric\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEODETIC","title":"GEODETIC  <code>class-attribute</code>","text":"<pre><code>GEODETIC: Any = EllipsoidalConversionType.Geodetic\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for EllipsoidalConversionType enum\\n\\nSpecifies the type of ellipsoidal conversion used in coordinate transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#angleformat","title":"AngleFormat","text":"<p>Specifies whether angles are in radians or degrees.</p> <p>Values: - <code>RADIANS</code> - Angles are in radians - <code>DEGREES</code> - Angles are in degrees</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for AngleFormat enum'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates</li> <li>Geodetic &amp; Geocentric</li> </ul>"},{"location":"library_api/coordinates/geodetic.html","title":"Geodetic and Geocentric Coordinates","text":"<p>Functions for converting between geodetic, geocentric, and ECEF coordinates.</p>"},{"location":"library_api/coordinates/geodetic.html#geodetic-conversions","title":"Geodetic Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geodetic_to_ecef","title":"position_geodetic_to_ecef  <code>builtin</code>","text":"<pre><code>position_geodetic_to_ecef(x_geod: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geodetic position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geod</code> <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (GPS-like) to ECEF\nlat, lon, alt = 40.0, -105.0, 1655.0  # Boulder, CO (degrees, meters)\nx_geod = np.array([lat, lon, alt])\nx_ecef = bh.position_geodetic_to_ecef(x_geod, bh.AngleFormat.DEGREES)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geodetic","title":"position_ecef_to_geodetic  <code>builtin</code>","text":"<pre><code>position_ecef_to_geodetic(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geodetic coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model.</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geodetic coordinates (GPS-like)\nx_ecef = np.array([-1275936.0, -4797210.0, 4020109.0])  # Example location\nx_geod = bh.position_ecef_to_geodetic(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geodetic: lat={x_geod[0]:.4f}\u00b0, lon={x_geod[1]:.4f}\u00b0, alt={x_geod[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#geocentric-conversions","title":"Geocentric Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geocentric_to_ecef","title":"position_geocentric_to_ecef  <code>builtin</code>","text":"<pre><code>position_geocentric_to_ecef(x_geoc: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geocentric position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geocentric spherical coordinates (latitude, longitude, radius) to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geoc</code> <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geocentric coordinates to ECEF\nlat, lon, r = 0.0, 0.0, 6378137.0  # Equator, prime meridian, Earth's radius\nx_geoc = np.array([lat, lon, r])\nx_ecef = bh.position_geocentric_to_ecef(x_geoc, bh.AngleFormat.RADIANS)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geocentric","title":"position_ecef_to_geocentric  <code>builtin</code>","text":"<pre><code>position_ecef_to_geocentric(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geocentric coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geocentric spherical coordinates (latitude, longitude, radius).</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geocentric coordinates\nx_ecef = np.array([6378137.0, 0.0, 0.0])  # Point on equator, prime meridian\nx_geoc = bh.position_ecef_to_geocentric(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geocentric: lat={x_geoc[0]:.2f}\u00b0, lon={x_geoc[1]:.2f}\u00b0, r={x_geoc[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html","title":"Topocentric Coordinates","text":"<p>Functions for working with local topocentric coordinate frames including East-North-Up (ENZ), South-East-Zenith (SEZ), and Azimuth-Elevation-Range.</p>"},{"location":"library_api/coordinates/topocentric.html#enz-east-north-up-frame","title":"ENZ (East-North-Up) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_enz","title":"rotation_ellipsoid_to_enz  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_enz(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to East-North-Up (<code>ENZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>ENZ</code> frame.</p>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_enz_to_ellipsoid","title":"rotation_enz_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_enz_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from East-North-Up (<code>ENZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local East-North-Up (<code>ENZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>ENZ</code> frame to ellipsoidal frame.</p>"},{"location":"library_api/coordinates/topocentric.html#position-conversions","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_enz","title":"relative_position_ecef_to_enz  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_enz(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to East-North-Up (<code>ENZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nenz = bh.relative_position_ecef_to_enz(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"ENZ: East={enz[0]/1000:.1f}km, North={enz[1]/1000:.1f}km, Up={enz[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_enz_to_ecef","title":"relative_position_enz_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_enz_to_ecef(location_ecef: ndarray, r_enz: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from East-North-Up (<code>ENZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local East-North-Up (<code>ENZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_enz</code> <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nenz_offset = np.array([50000.0, 30000.0, 100000.0])  # 50km east, 30km north, 100km up\ntarget_ecef = bh.relative_position_enz_to_ecef(station_ecef, enz_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_enz_to_azel","title":"position_enz_to_azel  <code>builtin</code>","text":"<pre><code>position_enz_to_azel(x_enz: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from East-North-Up (<code>ENZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local East-North-Up (<code>ENZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_enz</code> <code>ndarray</code> <p>Position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ to azimuth-elevation for satellite tracking\nenz = np.array([50000.0, 100000.0, 200000.0])  # East, North, Up (meters)\nazel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#sez-south-east-zenith-frame","title":"SEZ (South-East-Zenith) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices_1","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_sez","title":"rotation_ellipsoid_to_sez  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_sez(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>SEZ</code> frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix for ground station in SEZ frame\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_sez = bh.rotation_ellipsoid_to_sez(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_sez.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_sez_to_ellipsoid","title":"rotation_sez_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_sez_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from South-East-Zenith (<code>SEZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>SEZ</code> frame to ellipsoidal frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get inverse rotation matrix from SEZ to ellipsoidal\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_ellipsoid = bh.rotation_sez_to_ellipsoid(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_ellipsoid.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#position-conversions_1","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_sez","title":"relative_position_ecef_to_sez  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_sez(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nsez = bh.relative_position_ecef_to_sez(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"SEZ: South={sez[0]/1000:.1f}km, East={sez[1]/1000:.1f}km, Zenith={sez[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_sez_to_ecef","title":"relative_position_sez_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_sez_to_ecef(location_ecef: ndarray, x_sez: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from South-East-Zenith (<code>SEZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>x_sez</code> <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsez_offset = np.array([30000.0, 50000.0, 100000.0])  # 30km south, 50km east, 100km up\ntarget_ecef = bh.relative_position_sez_to_ecef(station_ecef, sez_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_sez_to_azel","title":"position_sez_to_azel  <code>builtin</code>","text":"<pre><code>position_sez_to_azel(x_sez: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from South-East-Zenith (<code>SEZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_sez</code> <code>ndarray</code> <p>Position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ to azimuth-elevation for satellite tracking\nsez = np.array([30000.0, 50000.0, 100000.0])  # South, East, Zenith (meters)\nazel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Module: <code>brahe.eop</code></p> <p>Earth Orientation Parameters provide corrections for the irregular rotation and orientation of the Earth, essential for accurate coordinate frame transformations between ECI and ECEF systems.</p>"},{"location":"library_api/eop/index.html#overview","title":"Overview","text":"<p>EOP data includes: - UT1-UTC: Difference between UT1 (Earth rotation time) and UTC - Polar Motion (x, y): Movement of Earth's rotation axis relative to the crust - dX, dY: Celestial pole offsets - LOD: Length of day variations</p>"},{"location":"library_api/eop/index.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports three types of EOP providers:</p>"},{"location":"library_api/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manage EOP file freshness with cache management and automatic updates.</p>"},{"location":"library_api/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Load EOP data from files (Standard or C04 format) for production applications with current data.</p>"},{"location":"library_api/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Use user-defined fixed data, ideal for testing, offline use, or applications not requiring the most precise transformations.</p>"},{"location":"library_api/eop/index.html#global-eop-management","title":"Global EOP Management","text":"<p>EOP data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/eop/index.html#functions","title":"Functions","text":"<ul> <li>Setting global EOP providers</li> <li>Querying global EOP data</li> <li>Downloading latest EOP files</li> </ul>"},{"location":"library_api/eop/index.html#quick-start","title":"Quick Start","text":"<pre><code>import brahe as bh\n\n# Option 1: Use file-based EOP (recommended for production)\nbh.set_global_eop_provider_from_file_provider(\n    bh.FileEOPProvider.from_default_standard()\n)\n\n# Option 2: Use static EOP (for testing/offline use)\nbh.set_global_eop_provider_from_static_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Now frame transformations will use the global EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]  # meters\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/index.html#see-also","title":"See Also","text":"<ul> <li>Frames - Coordinate frame transformations that use EOP</li> <li>Epoch - Time representation</li> </ul>"},{"location":"library_api/eop/caching_provider.html","title":"CachingEOPProvider","text":""},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider","title":"CachingEOPProvider","text":"<pre><code>CachingEOPProvider(filepath: str, eop_type: str, max_age_seconds: int, auto_refresh: bool, interpolate: bool, extrapolate: str)\n</code></pre> <p>Caching EOP provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileEOPProvider and adds automatic cache management. It checks the age of the EOP file and downloads updated versions when the file exceeds the maximum age threshold. If the file doesn't exist, it will be downloaded on initialization.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the EOP file (will be created if it doesn't exist)</p> required <code>eop_type</code> <code>str</code> <p>Type of EOP file - \"C04\" for IERS C04 format or \"StandardBulletinA\" for IERS finals2000A.all format</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh. Common values: 86400 (1 day), 604800 (7 days)</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access. If False, only checks on initialization and manual refresh() calls</p> required <code>interpolate</code> <code>bool</code> <p>Enable linear interpolation between tabulated EOP values. Recommended: True for smoother data</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside EOP data range: \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file download fails or file is invalid</p> Example <pre><code>import brahe as bh\n\n# Manual refresh mode (recommended for performance)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n\n# Check and refresh as needed\nprovider.refresh()\n\n# Auto-refresh mode (convenience)\nauto_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,  # Checks on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Caching EOP provider that automatically downloads updated files when stale.\\n\\nThis provider wraps a FileEOPProvider and adds automatic cache management.\\nIt checks the age of the EOP file and downloads updated versions when the file\\nexceeds the maximum age threshold. If the file doesn\\'t exist, it will be\\ndownloaded on initialization.\\n\\nArgs:\\n    filepath (str): Path to the EOP file (will be created if it doesn\\'t exist)\\n    eop_type (str): Type of EOP file - \"C04\" for IERS C04 format or\\n        \"StandardBulletinA\" for IERS finals2000A.all format\\n    max_age_seconds (int): Maximum age of file in seconds before triggering\\n        a refresh. Common values: 86400 (1 day), 604800 (7 days)\\n    auto_refresh (bool): If True, automatically checks file age and refreshes\\n        on every data access. If False, only checks on initialization and\\n        manual refresh() calls\\n    interpolate (bool): Enable linear interpolation between tabulated EOP\\n        values. Recommended: True for smoother data\\n    extrapolate (str): Behavior for dates outside EOP data range:\\n        \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)\\n\\nRaises:\\n    RuntimeError: If file download fails or file is invalid\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Manual refresh mode (recommended for performance)\\n    provider = bh.CachingEOPProvider(\\n        filepath=\"./eop_data/finals.all.iau2000.txt\",\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=7 * 86400,  # 7 days\\n        auto_refresh=False,\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    bh.set_global_eop_provider_from_caching_provider(provider)\\n\\n    # Check and refresh as needed\\n    provider.refresh()\\n\\n    # Auto-refresh mode (convenience)\\n    auto_provider = bh.CachingEOPProvider(\\n        filepath=\"./eop_data/finals.all.iau2000.txt\",\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=24 * 3600,  # 24 hours\\n        auto_refresh=True,  # Checks on every access\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP file type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type (\"C04\", \"StandardBulletinA\", etc.)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded EOP file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\nage = provider.file_age()\nprint(f\"EOP file age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the EOP file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; Tuple\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(pm_x, pm_y, ut1_utc, dx, dy, lod)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last MJD with valid celestial pole offset data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dX/dY data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last MJD with valid LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with length of day data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached EOP data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\n# Later, manually force a refresh check\nprovider.refresh()\n</code></pre>"},{"location":"library_api/eop/file_provider.html","title":"FileEOPProvider","text":"<p>Load Earth Orientation Parameters from IERS data files.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider","title":"FileEOPProvider","text":"<pre><code>FileEOPProvider()\n</code></pre> <p>File-based Earth Orientation Parameter provider.</p> <p>Loads EOP data from files in standard IERS formats and provides interpolation and extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from C04 file with interpolation\neop = bh.FileEOPProvider.from_c04_file(\n    \"./eop_data/finals2000A.all.csv\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Create from standard file\neop = bh.FileEOPProvider.from_standard_file(\n    \"./eop_data/finals.all\",\n    interpolate=True,\n    extrapolate=\"Zero\"\n)\n\n# Use default file location\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(eop)\n\n# Get EOP data for a specific MJD\nmjd = 60310.0\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'File-based Earth Orientation Parameter provider.\\n\\nLoads EOP data from files in standard IERS formats and provides\\ninterpolation and extrapolation capabilities.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create from C04 file with interpolation\\n    eop = bh.FileEOPProvider.from_c04_file(\\n        \"./eop_data/finals2000A.all.csv\",\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n\\n    # Create from standard file\\n    eop = bh.FileEOPProvider.from_standard_file(\\n        \"./eop_data/finals.all\",\\n        interpolate=True,\\n        extrapolate=\"Zero\"\\n    )\\n\\n    # Use default file location\\n    eop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_file_provider(eop)\\n\\n    # Get EOP data for a specific MJD\\n    mjd = 60310.0\\n    ut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Extrapolation: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_c04_file","title":"from_c04_file  <code>builtin</code>","text":"<pre><code>from_c04_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a C04 format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to C04 EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with C04 file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_c04_file(\"./eop_data/finals2000A.all.csv\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_c04","title":"from_default_c04  <code>builtin</code>","text":"<pre><code>from_default_c04(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default C04 EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default C04 file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file(eop_type: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from default EOP file location with specified type.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>EOP file type (\"C04\" or \"StandardBulletinA\")</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default file of specified type</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_file(\"C04\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_standard","title":"from_default_standard  <code>builtin</code>","text":"<pre><code>from_default_standard(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default standard IERS EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default standard file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from an EOP file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_file(\"./eop_data/eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_standard_file","title":"from_standard_file  <code>builtin</code>","text":"<pre><code>from_standard_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a standard IERS format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to standard IERS EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with standard file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_standard_file(\"./eop_data/standard_eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"interpolation: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"is_initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_last_dxdy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_max: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#overview","title":"Overview","text":"<p><code>FileEOPProvider</code> loads EOP data from files in either Standard or C04 format provided by the International Earth Rotation and Reference Systems Service (IERS).</p> <p>Module: <code>brahe.eop</code></p> <p>Data Sources: - Standard Format: finals2000A.all - Combined rapid + predicted data - C04 Format: eopc04_IAU2000.XX - Long-term historical data</p>"},{"location":"library_api/eop/file_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/file_provider.html#from-default-files","title":"From Default Files","text":"<pre><code>import brahe as bh\n\n# Use default standard format file\nprovider = bh.FileEOPProvider.from_default_standard()\n\n# Use default C04 format file\nprovider = bh.FileEOPProvider.from_default_c04()\n</code></pre>"},{"location":"library_api/eop/file_provider.html#from-custom-files","title":"From Custom Files","text":"<pre><code>import brahe as bh\n\n# Load from custom standard file\nprovider = bh.FileEOPProvider.from_standard_file(\n    \"/path/to/finals2000A.all\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Load from custom C04 file\nprovider = bh.FileEOPProvider.from_c04_file(\n    \"/path/to/eopc04.XX\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#configuration-options","title":"Configuration Options","text":""},{"location":"library_api/eop/file_provider.html#interpolation","title":"Interpolation","text":"<p><code>interpolate: bool</code> - Enable/disable interpolation between data points</p> <ul> <li><code>True</code>: Linear interpolation for dates between data points (recommended)</li> <li><code>False</code>: Use nearest data point (step function)</li> </ul>"},{"location":"library_api/eop/file_provider.html#extrapolation","title":"Extrapolation","text":"<p><code>extrapolate: str</code> - Behavior when querying dates outside data range</p> <ul> <li><code>\"Hold\"</code>: Use first/last values for dates before/after data range</li> <li><code>\"Zero\"</code>: Return zero for all EOP values outside range</li> <li><code>\"Error\"</code>: Raise an error if date is outside range</li> </ul>"},{"location":"library_api/eop/file_provider.html#usage-with-global-eop","title":"Usage with Global EOP","text":"<pre><code>import brahe as bh\n\n# Create provider from file\nprovider = bh.FileEOPProvider.from_default_standard(\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(provider)\n\n# Now all frame transformations use this EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#downloading-eop-files","title":"Downloading EOP Files","text":"<pre><code>import brahe as bh\n\n# Download latest standard EOP file\nfilepath = bh.download_standard_eop_file(\"./data\")\n\n# Download latest C04 EOP file\nfilepath = bh.download_c04_eop_file(\"./data\")\n\n# Use downloaded file\nprovider = bh.FileEOPProvider.from_standard_file(filepath)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider - Built-in historical EOP data</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations using EOP</li> </ul>"},{"location":"library_api/eop/functions.html","title":"EOP Functions","text":"<p>Global EOP management and query functions.</p> <p>Module: <code>brahe.eop</code></p>"},{"location":"library_api/eop/functions.html#setting-global-eop-provider","title":"Setting Global EOP Provider","text":""},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_caching_provider","title":"set_global_eop_provider_from_caching_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_caching_provider","title":"set_global_eop_provider_from_caching_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_caching_provider(provider: CachingEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a caching provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>CachingEOPProvider</code> <p>Caching EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_file_provider","title":"set_global_eop_provider_from_file_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_file_provider","title":"set_global_eop_provider_from_file_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_file_provider(provider: FileEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a file-based provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>FileEOPProvider</code> <p>File-based EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_static_provider","title":"set_global_eop_provider_from_static_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_static_provider","title":"set_global_eop_provider_from_static_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_static_provider(provider: StaticEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a static provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticEOPProvider</code> <p>Static EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#querying-global-eop-data","title":"Querying Global EOP Data","text":""},{"location":"library_api/eop/functions.html#get_global_eop","title":"get_global_eop","text":"<p>Get all EOP values for a specific Modified Julian Date.</p> <p>Returns: Tuple of (ut1_utc, pm_x, pm_y, dx, dy, lod)</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop","title":"get_global_eop  <code>builtin</code>","text":"<pre><code>get_global_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p>"},{"location":"library_api/eop/functions.html#get_global_ut1_utc","title":"get_global_ut1_utc","text":"<p>Get UT1-UTC offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_ut1_utc","title":"get_global_ut1_utc  <code>builtin</code>","text":"<pre><code>get_global_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/functions.html#get_global_pm","title":"get_global_pm","text":"<p>Get polar motion (x, y) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_pm","title":"get_global_pm  <code>builtin</code>","text":"<pre><code>get_global_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/functions.html#get_global_dxdy","title":"get_global_dxdy","text":"<p>Get celestial pole offsets (dx, dy) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_dxdy","title":"get_global_dxdy  <code>builtin</code>","text":"<pre><code>get_global_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/functions.html#get_global_lod","title":"get_global_lod","text":"<p>Get length of day offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_lod","title":"get_global_lod  <code>builtin</code>","text":"<pre><code>get_global_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/functions.html#eop-metadata","title":"EOP Metadata","text":""},{"location":"library_api/eop/functions.html#get_global_eop_type","title":"get_global_eop_type","text":"<p>Get the type of global EOP provider (\"file\" or \"static\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_type","title":"get_global_eop_type  <code>builtin</code>","text":"<pre><code>get_global_eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_initialization","title":"get_global_eop_initialization","text":"<p>Check if global EOP provider has been initialized.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_initialization","title":"get_global_eop_initialization  <code>builtin</code>","text":"<pre><code>get_global_eop_initialization() -&gt; bool\n</code></pre> <p>Check if the global EOP provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if global EOP provider is initialized</p>"},{"location":"library_api/eop/functions.html#get_global_eop_interpolation","title":"get_global_eop_interpolation","text":"<p>Check if interpolation is enabled.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_interpolation","title":"get_global_eop_interpolation  <code>builtin</code>","text":"<pre><code>get_global_eop_interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled in the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/functions.html#get_global_eop_extrapolation","title":"get_global_eop_extrapolation","text":"<p>Get extrapolation method (\"Hold\", \"Zero\", or \"Error\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_extrapolation","title":"get_global_eop_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_eop_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_len","title":"get_global_eop_len","text":"<p>Get number of EOP data points in provider.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_len","title":"get_global_eop_len  <code>builtin</code>","text":"<pre><code>get_global_eop_len() -&gt; int\n</code></pre> <p>Get the number of EOP data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_min","title":"get_global_eop_mjd_min","text":"<p>Get minimum (earliest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_min","title":"get_global_eop_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_max","title":"get_global_eop_mjd_max","text":"<p>Get maximum (latest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_max","title":"get_global_eop_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod","text":"<p>Get MJD of last LOD (Length of Day) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy","text":"<p>Get MJD of last dX/dY (celestial pole offset) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p>"},{"location":"library_api/eop/functions.html#downloading-eop-files","title":"Downloading EOP Files","text":""},{"location":"library_api/eop/functions.html#download_standard_eop_file","title":"download_standard_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_standard_eop_file","title":"download_standard_eop_file  <code>builtin</code>","text":"<pre><code>download_standard_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest standard Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre>"},{"location":"library_api/eop/functions.html#download_c04_eop_file","title":"download_c04_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_c04_eop_file","title":"download_c04_eop_file  <code>builtin</code>","text":"<pre><code>download_c04_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest C04 Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"library_api/eop/functions.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Download and set up file-based EOP\neop_file = bh.download_standard_eop_file(\"./data\")\nprovider = bh.FileEOPProvider.from_standard_file(\n    eop_file,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_file_provider(provider)\n\n# Check provider status\nprint(f\"EOP Type: {bh.get_global_eop_type()}\")\nprint(f\"Data points: {bh.get_global_eop_len()}\")\nprint(f\"Date range: MJD {bh.get_global_eop_mjd_min():.1f} to {bh.get_global_eop_mjd_max():.1f}\")\nprint(f\"Interpolation: {bh.get_global_eop_interpolation()}\")\nprint(f\"Extrapolation: {bh.get_global_eop_extrapolation()}\")\n\n# Query EOP for specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\nut1_utc, pm_x, pm_y, dx, dy, lod = bh.get_global_eop(mjd)\nprint(f\"\\nEOP for MJD {mjd}:\")\nprint(f\"  UT1-UTC: {ut1_utc:.6f} s\")\nprint(f\"  Polar Motion: ({pm_x*1e6:.3f}, {pm_y*1e6:.3f}) \u03bcrad\")\nprint(f\"  dX, dY: ({dx*1e6:.3f}, {dy*1e6:.3f}) \u03bcrad\")\nprint(f\"  LOD: {lod*1e3:.6f} ms\")\n</code></pre>"},{"location":"library_api/eop/functions.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider</li> <li>StaticEOPProvider</li> <li>Frames - Frame transformations that use EOP</li> </ul>"},{"location":"library_api/eop/static_provider.html","title":"StaticEOPProvider","text":"<p>Built-in Earth Orientation Parameters for testing and offline use.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider","title":"StaticEOPProvider","text":"<pre><code>StaticEOPProvider()\n</code></pre> <p>Static Earth Orientation Parameter provider with constant values.</p> <p>Provides EOP data using fixed values that don't change with time. Useful for testing or scenarios where time-varying EOP data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static EOP provider with default values\neop = bh.StaticEOPProvider()\n\n# Create static EOP provider with zero values\neop_zero = bh.StaticEOPProvider.from_zero()\n\n# Create with custom values\neop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(eop_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = \"Static Earth Orientation Parameter provider with constant values.\\n\\nProvides EOP data using fixed values that don't change with time.\\nUseful for testing or scenarios where time-varying EOP data is not needed.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create static EOP provider with default values\\n    eop = bh.StaticEOPProvider()\\n\\n    # Create static EOP provider with zero values\\n    eop_zero = bh.StaticEOPProvider.from_zero()\\n\\n    # Create with custom values\\n    eop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_static_provider(eop_custom)\\n    ```\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Extrapolation method: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(ut1_utc: float, pm_x: float, pm_y: float, dx: float, dy: float, lod: float) -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ut1_utc</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> required <code>pm_x</code> <code>float</code> <p>Polar motion x-component in radians</p> required <code>pm_y</code> <code>float</code> <p>Polar motion y-component in radians</p> required <code>dx</code> <code>float</code> <p>Celestial pole offset dx in radians</p> required <code>dy</code> <code>float</code> <p>Celestial pole offset dy in radians</p> required <code>lod</code> <code>float</code> <p>Length of day offset in seconds</p> required <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with specified EOP values</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with custom values\neop = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,\n    pm_x=1e-6,\n    pm_y=2e-6,\n    dx=1e-7,\n    dy=1e-7,\n    lod=0.001\n)\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with all EOP values set to zero</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with all zeros (no corrections)\neop = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider()\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Interpolation enabled: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Is initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with dx/dy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Maximum MJD: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#overview","title":"Overview","text":"<p><code>StaticEOPProvider</code> provides built-in historical EOP data that doesn't require external files. Useful for testing, examples, or when internet access is unavailable.</p> <p>Module: <code>brahe.eop</code></p> <p>Use Cases: - Unit testing - Examples and tutorials - Offline applications - Quick prototyping</p> <p>Limitations: - Fixed historical data (not updated) - Less accurate than file-based providers - Not suitable for production applications requiring current data</p>"},{"location":"library_api/eop/static_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/static_provider.html#zero-values","title":"Zero Values","text":"<pre><code>import brahe as bh\n\n# All EOP values set to zero\nprovider = bh.StaticEOPProvider.from_zero()\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#custom-values","title":"Custom Values","text":"<pre><code>import brahe as bh\n\n# Specify custom EOP values\nprovider = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,      # UT1-UTC offset (seconds)\n    pm_x=0.0001,      # Polar motion X (radians)\n    pm_y=0.0001,      # Polar motion Y (radians)\n    dx=0.00001,       # Celestial pole offset dX (radians)\n    dy=0.00001,       # Celestial pole offset dY (radians)\n    lod=0.001         # Length of day offset (seconds)\n)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#default-values","title":"Default Values","text":"<pre><code>import brahe as bh\n\n# Use built-in default values\nprovider = bh.StaticEOPProvider()\n</code></pre>"},{"location":"library_api/eop/static_provider.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Set up static EOP for testing\nbh.set_global_eop_provider_from_static_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Perform frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ECI to ECEF transformation\npos_eci = [7000000.0, 0.0, 0.0]  # meters in ECI\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n\n# ECEF to ECI transformation\nvel_ecef = [0.0, 7500.0, 0.0]  # m/s in ECEF\nvel_eci = bh.position_ecef_to_eci(epoch, vel_ecef)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#when-to-use","title":"When to Use","text":"<p>\u2705 Use StaticEOPProvider for: - Unit tests - Documentation examples - Learning and prototyping - Applications where high accuracy isn't critical</p> <p>\u274c Don't use StaticEOPProvider for: - Production orbit determination - Precise tracking applications - Applications requiring current EOP data - High-accuracy simulations</p>"},{"location":"library_api/eop/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider - File-based EOP for production use</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations</li> </ul>"},{"location":"library_api/orbits/index.html","title":"Orbits","text":"<p>Module: <code>brahe.orbits</code></p> <p>Comprehensive tools for orbital mechanics computations.</p>"},{"location":"library_api/orbits/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Keplerian Elements - Functions for computing orbital properties and converting between anomaly types</li> <li>Two-Line Elements (TLE) - TLE parsing, validation, and conversion utilities</li> <li>KeplerianPropagator - Analytical two-body orbit propagator</li> <li>SGPPropagator - SGP4/SDP4 orbit propagator for TLE data</li> <li>Enumerations - Orbit-related enumerations (OrbitRepresentation, OrbitFrame, etc.)</li> </ul>"},{"location":"library_api/orbits/enums.html","title":"Orbit Enumerations","text":"<p>Enumerations for specifying orbit representation types and reference frames.</p>"},{"location":"library_api/orbits/enums.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies the type of orbital elements being used.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation","title":"OrbitRepresentation","text":"<pre><code>OrbitRepresentation()\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.CARTESIAN","title":"CARTESIAN  <code>class-attribute</code>","text":"<pre><code>CARTESIAN: Any = OrbitRepresentation.Cartesian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.KEPLERIAN","title":"KEPLERIAN  <code>class-attribute</code>","text":"<pre><code>KEPLERIAN: Any = OrbitRepresentation.Keplerian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital state representation format.\\n\\nSpecifies how orbital states are represented in the trajectory.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#orbitframe","title":"OrbitFrame","text":""},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame","title":"OrbitFrame","text":"<pre><code>OrbitFrame()\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECEF","title":"ECEF  <code>class-attribute</code>","text":"<pre><code>ECEF: Any = OrbitFrame.ECEF\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECI","title":"ECI  <code>class-attribute</code>","text":"<pre><code>ECI: Any = OrbitFrame.ECI\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Reference frame for orbital trajectory representation.\\n\\nSpecifies the coordinate reference frame for position and velocity states.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get the full name of the reference frame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable frame name</p>"},{"location":"library_api/orbits/enums.html#interpolationmethod","title":"InterpolationMethod","text":""},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod","title":"InterpolationMethod","text":"<pre><code>InterpolationMethod()\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.LINEAR","title":"LINEAR  <code>class-attribute</code>","text":"<pre><code>LINEAR: Any = InterpolationMethod.Linear\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python bindings for the new trajectory architecture\\nInterpolation method for trajectory state estimation.\\n\\nSpecifies the algorithm used to estimate states at epochs between\\ndiscrete trajectory points.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator</li> <li>Trajectories</li> </ul>"},{"location":"library_api/orbits/keplerian.html","title":"Keplerian Elements","text":"<p>Functions for working with Keplerian orbital elements and computing orbital properties.</p>"},{"location":"library_api/orbits/keplerian.html#orbital-properties","title":"Orbital Properties","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis","title":"semimajor_axis  <code>builtin</code>","text":"<pre><code>semimajor_axis(n: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from Earth given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis from mean motion (typical LEO satellite)\nn = 0.001027  # radians/second (~15 revolutions/day)\na = bh.semimajor_axis(n, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_general","title":"semimajor_axis_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_general(n: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from a general body given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for Jupiter orbiter\nn = 0.0001  # radians/second\na = bh.semimajor_axis_general(n, bh.GM_JUPITER, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period","title":"semimajor_axis_from_orbital_period  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period(period: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for a 90-minute orbit\nperiod = 90 * 60.0  # 90 minutes in seconds\na = bh.semimajor_axis_from_orbital_period(period)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period_general","title":"semimajor_axis_from_orbital_period_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period_general(period: float, gm: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period for a general body.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for 2-hour Venus orbit\nperiod = 2 * 3600.0  # 2 hours in seconds\na = bh.semimajor_axis_from_orbital_period_general(period, bh.GM_VENUS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion","title":"mean_motion  <code>builtin</code>","text":"<pre><code>mean_motion(a: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for geostationary orbit (35786 km altitude)\na = bh.R_EARTH + 35786e3\nn = bh.mean_motion(a, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion_general","title":"mean_motion_general  <code>builtin</code>","text":"<pre><code>mean_motion_general(a: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around a general body given a semi-major axis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for a Mars orbiter\na = 4000000.0  # 4000 km semi-major axis\nn = bh.mean_motion_general(a, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period","title":"orbital_period  <code>builtin</code>","text":"<pre><code>orbital_period(a: float) -&gt; Any\n</code></pre> <p>Computes the orbital period of an object around Earth.</p> <p>Uses rastro.constants.GM_EARTH as the standard gravitational parameter for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period for ISS-like orbit (400 km altitude)\na = bh.R_EARTH + 400e3\nperiod = bh.orbital_period(a)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period_general","title":"orbital_period_general  <code>builtin</code>","text":"<pre><code>orbital_period_general(a: float, gm: float) -&gt; float\n</code></pre> <p>Computes the orbital period of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period around the Moon\na = 1900000.0  # 1900 km semi-major axis\nperiod = bh.orbital_period_general(a, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_distance","title":"periapsis_distance  <code>builtin</code>","text":"<pre><code>periapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at periapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis distance for an elliptical orbit\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_peri = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_distance","title":"apoapsis_distance  <code>builtin</code>","text":"<pre><code>apoapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at apoapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis distance\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_apo = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_velocity","title":"periapsis_velocity  <code>builtin</code>","text":"<pre><code>periapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the periapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at periapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis velocity for a comet around the Sun\na = 5e11  # 5 AU semi-major axis (meters)\ne = 0.95  # highly elliptical\nv_peri = bh.periapsis_velocity(a, e, bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_velocity","title":"apoapsis_velocity  <code>builtin</code>","text":"<pre><code>apoapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the apoapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apoapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis velocity for a Martian satellite\na = 10000000.0  # 10000 km semi-major axis\ne = 0.3\nv_apo = bh.apoapsis_velocity(a, e, bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.perigee_velocity","title":"perigee_velocity  <code>builtin</code>","text":"<pre><code>perigee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the perigee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at perigee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate perigee velocity for Molniya orbit (highly elliptical)\na = 26554000.0  # meters\ne = 0.72  # high eccentricity\nv_peri = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apogee_velocity","title":"apogee_velocity  <code>builtin</code>","text":"<pre><code>apogee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the apogee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apogee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apogee velocity for GTO (Geostationary Transfer Orbit)\na = 24400000.0  # meters\ne = 0.73  # high eccentricity\nv_apo = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.sun_synchronous_inclination","title":"sun_synchronous_inclination  <code>builtin</code>","text":"<pre><code>sun_synchronous_inclination(a: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the inclination for a Sun-synchronous orbit around Earth based on the J2 gravitational perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination for a Sun synchronous orbit in degrees or radians.</p> Example <pre><code>import brahe as bh\n\n# Calculate sun-synchronous inclination for typical Earth observation satellite (600 km)\na = bh.R_EARTH + 600e3\ne = 0.001  # nearly circular\ninc = bh.sun_synchronous_inclination(a, e, bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#anomaly-conversions","title":"Anomaly Conversions","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_mean","title":"anomaly_eccentric_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_mean(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to mean anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.1  # eccentricity\nM = bh.anomaly_eccentric_to_mean(E, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_true","title":"anomaly_eccentric_to_true  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_true(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to true anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.4  # eccentricity\nnu = bh.anomaly_eccentric_to_true(E, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_eccentric","title":"anomaly_mean_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_eccentric(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to eccentric anomaly (solves Kepler's equation)\nM = 1.5  # mean anomaly in radians\ne = 0.3  # eccentricity\nE = bh.anomaly_mean_to_eccentric(M, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_true","title":"anomaly_mean_to_true  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_true(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to true anomaly (combines Kepler's equation + eccentric anomaly conversion)\nM = 2.0  # mean anomaly in radians\ne = 0.25  # eccentricity\nnu = bh.anomaly_mean_to_true(M, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_eccentric","title":"anomaly_true_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_true_to_eccentric(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to eccentric anomaly\nnu = math.pi / 3  # 60 degrees true anomaly\ne = 0.2  # eccentricity\nE = bh.anomaly_true_to_eccentric(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_mean","title":"anomaly_true_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_true_to_mean(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to mean anomaly\nnu = math.pi / 2  # 90 degrees true anomaly\ne = 0.15  # eccentricity\nM = bh.anomaly_true_to_mean(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html","title":"Keplerian Propagator","text":"<p>Analytical two-body orbit propagator using Keplerian orbital elements.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator","title":"KeplerianPropagator","text":"<pre><code>KeplerianPropagator()\n</code></pre> <p>Python wrapper for KeplerianPropagator (new architecture) Keplerian orbit propagator using two-body dynamics.</p> <p>The Keplerian propagator implements ideal two-body orbital mechanics without perturbations. It's fast and accurate for short time spans but doesn't account for real-world effects like drag, J2, solar radiation pressure, etc.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initial epoch and orbital elements\nepc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\n\n# Create propagator from Keplerian elements\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\n)\n\n# Propagate forward one orbit\nperiod = bh.orbital_period(oe[0])\nepc_future = epc0 + period\nstate = prop.state(epc_future)\nprint(f\"State after one orbit: {state}\")\n\n# Create from Cartesian state\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\nprop2 = bh.KeplerianPropagator(\n    epc0, x_cart, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    bh.AngleFormat.RADIANS, 60.0\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for KeplerianPropagator (new architecture)\\nKeplerian orbit propagator using two-body dynamics.\\n\\nThe Keplerian propagator implements ideal two-body orbital mechanics without\\nperturbations. It\\'s fast and accurate for short time spans but doesn\\'t account\\nfor real-world effects like drag, J2, solar radiation pressure, etc.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Initial epoch and orbital elements\\n    epc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    oe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\\n\\n    # Create propagator from Keplerian elements\\n    prop = bh.KeplerianPropagator.from_keplerian(\\n        epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\\n    )\\n\\n    # Propagate forward one orbit\\n    period = bh.orbital_period(oe[0])\\n    epc_future = epc0 + period\\n    state = prop.state(epc_future)\\n    print(f\"State after one orbit: {state}\")\\n\\n    # Create from Cartesian state\\n    x_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\\n    prop2 = bh.KeplerianPropagator(\\n        epc0, x_cart, bh.OrbitFrame.ECI,\\n        bh.OrbitRepresentation.CARTESIAN,\\n        bh.AngleFormat.RADIANS, 60.0\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Epoch\n</code></pre> <p>Get initial epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Initial propagator epoch.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\ntraj = prop.trajectory\nprint(f\"Trajectory contains {traj.len()} states\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; np.ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_ecef","title":"from_ecef  <code>builtin</code>","text":"<pre><code>from_ecef(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECEF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECEF frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECI frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_keplerian","title":"from_keplerian  <code>builtin</code>","text":"<pre><code>from_keplerian(epoch: Epoch, elements: ndarray, angle_format: AngleFormat, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>elements</code> <code>ndarray</code> <p>6-element Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format (Degrees or Radians).</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; np.ndarray\n</code></pre> <p>Get initial state.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)  # Take 10 steps (600 seconds total)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 3600.0  # Propagate to 1 hour ahead\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\nprop.reset()  # Return to initial epoch and state\nprint(f\"Reset to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_age(3600.0)  # Keep only states within 1 hour\nprop.propagate_to(epc + 7200.0)  # Propagate 2 hours\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_size(100)  # Keep only 100 most recent states\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_initial_conditions","title":"set_initial_conditions  <code>method descriptor</code>","text":"<pre><code>set_initial_conditions(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Set initial conditions.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame.</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\n\n# Change initial conditions to a different orbit\nnew_oe = np.array([bh.R_EARTH + 800e3, 0.02, 1.2, 0.5, 0.3, 0.0])\nnew_state = bh.state_osculating_to_cartesian(new_oe, bh.AngleFormat.RADIANS)\nnew_epc = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop.set_initial_conditions(new_epc, new_state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, bh.AngleFormat.RADIANS)\nprint(f\"New initial epoch: {prop.initial_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's native format.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's native format.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_as_osculating_elements","title":"states_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>states_as_osculating_elements(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_ecef","title":"states_ecef  <code>method descriptor</code>","text":"<pre><code>states_ecef(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECEF state vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step()  # Advance by default step_size (60 seconds)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step_by(120.0)  # Advance by 120 seconds\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 300.0  # Target 5 minutes ahead\nprop.step_past(target)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#overview","title":"Overview","text":"<p>The Keplerian propagator provides fast, analytical orbit propagation for unperturbed two-body motion. It uses closed-form solutions to Kepler's equations for orbital element propagation.</p> <p>Key Features: - Fast analytical propagation (no numerical integration) - Perfect for preliminary analysis and mission design - No perturbations (atmospheric drag, J2, third-body, etc.) - Suitable for high-altitude orbits where perturbations are minimal</p> <p>Module: <code>brahe.orbits</code></p> <p>When to Use: - Preliminary orbit analysis - High-altitude orbits (GEO, cislunar) - Short propagation times where perturbations are negligible - Educational purposes</p> <p>When NOT to Use: - LEO orbits requiring accuracy beyond a few days - When atmospheric drag is significant - When J2 perturbations matter - Precise orbit determination applications</p>"},{"location":"library_api/orbits/keplerian_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Initial orbital elements [a, e, i, \u03a9, \u03c9, M] in SI units (m, rad)\n# Example: Geostationary orbit\na = 42164000.0        # Semi-major axis (m)\ne = 0.0001            # Eccentricity\ni = 0.0 * bh.DEG2RAD  # Inclination (rad)\nraan = 0.0            # Right ascension of ascending node (rad)\nargp = 0.0            # Argument of periapsis (rad)\nM = 0.0               # Mean anomaly (rad)\n\nelements = np.array([a, e, i, raan, argp, M])\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create propagator\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI,\n    gm=bh.GM_EARTH\n)\n\n# Propagate to a future time\nfuture_epoch = epoch + 86400.0  # 1 day later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz]\n\n# Propagate to multiple times\ntimes = np.linspace(0, 7*86400, 100)  # 1 week in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)\n\nprint(f\"Propagated to {len(states)} epochs\")\nprint(f\"Final position: {states[-1][:3]} m\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#orbital-elements","title":"Orbital Elements","text":"<p>The propagator accepts orbital elements in the following order: 1. a - Semi-major axis (meters) 2. e - Eccentricity (dimensionless) 3. i - Inclination (radians) 4. \u03a9 - Right ascension of ascending node (radians) 5. \u03c9 - Argument of periapsis (radians) 6. M or \u03bd - Mean anomaly or true anomaly (radians)</p> <p>Use <code>OrbitRepresentation</code> to specify element type: - <code>MEAN_ELEMENTS</code> - Mean orbital elements with mean anomaly - <code>OSCULATING_ELEMENTS</code> - Osculating elements with true anomaly</p>"},{"location":"library_api/orbits/keplerian_propagator.html#see-also","title":"See Also","text":"<ul> <li>SGPPropagator - SGP4/SDP4 propagator for TLE data</li> <li>Keplerian Elements - Orbital element conversion functions</li> <li>OrbitRepresentation - Element type specification</li> </ul>"},{"location":"library_api/orbits/sgp_propagator.html","title":"SGP Propagator","text":"<p>The SGP4/SDP4 propagator for satellite orbit propagation using Two-Line Element (TLE) data.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator","title":"SGPPropagator","text":"<pre><code>SGPPropagator()\n</code></pre> <p>Python wrapper for SGPPropagator (replaces TLE) SGP4/SDP4 satellite propagator using TLE data.</p> <p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using Two-Line Element (TLE) orbital data. This is the standard model used for tracking objects in Earth orbit.</p> Example <pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_eci = prop.state(epc)\nprint(f\"Position: {state_eci[:3]}\")\nprint(f\"Velocity: {state_eci[3:]}\")\n\n# Propagate multiple epochs\nepochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\nstates = prop.states(epochs)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for SGPPropagator (replaces TLE)\\nSGP4/SDP4 satellite propagator using TLE data.\\n\\nThe SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models\\nfor propagating satellites using Two-Line Element (TLE) orbital data. This is the standard\\nmodel used for tracking objects in Earth orbit.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # ISS TLE data (example)\\n    line1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\\n    line2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\\n\\n    # Create propagator\\n    prop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\\n\\n    # Propagate to a specific epoch\\n    epc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    state_eci = prop.state(epc)\\n    print(f\"Position: {state_eci[:3]}\")\\n    print(f\"Velocity: {state_eci[3:]}\")\\n\\n    # Propagate multiple epochs\\n    epochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\\n    states = prop.states(epochs)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.step()\nprint(f\"Current epoch: {propagator.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Epoch\n</code></pre> <p>Get TLE epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch of the TLE data.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.norad_id","title":"norad_id  <code>property</code>","text":"<pre><code>norad_id: int\n</code></pre> <p>Get NORAD ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>NORAD catalog ID.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: str\n</code></pre> <p>Get satellite name (if available).</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: Satellite name if provided.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Satellite: {propagator.satellite_name}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(f\"Step size: {propagator.step_size} seconds\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.propagate_steps(100)\ntraj = prop.trajectory\nprint(f\"Trajectory has {traj.len()} states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; np.ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector in the propagator's output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.from_3le","title":"from_3le  <code>builtin</code>","text":"<pre><code>from_3le(name: str, line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from 3-line TLE format (with satellite name).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (line 0).</p> required <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.from_tle","title":"from_tle  <code>builtin</code>","text":"<pre><code>from_tle(line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; np.ndarray\n</code></pre> <p>Get initial state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector in the propagator's output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\nprop.propagate_steps(10)  # Advance by 10 steps (600 seconds)\nprint(f\"After 10 steps: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ninitial_epoch = prop.epoch\nprop.propagate_steps(100)\nprop.reset()\nprint(f\"Reset to: {prop.current_epoch == initial_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_age(86400.0)  # Keep 1 day of history\nprint(\"Trajectory limited to 24 hours of states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_size(1000)\nprint(\"Trajectory limited to 1000 states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_output_format","title":"set_output_format  <code>method descriptor</code>","text":"<pre><code>set_output_format(frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None) -&gt; Any\n</code></pre> <p>Set output format (frame, representation, and angle format).</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>OrbitFrame</code> <p>Output frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>Output representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian (None for Cartesian).</p> required"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's current output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_pef","title":"state_pef  <code>method descriptor</code>","text":"<pre><code>state_pef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in PEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in PEF frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's current output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step()  # Advance by default step_size\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step_by(120.0)  # Advance by 2 minutes\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 3600.0  # 1 hour later\nprop.step_past(target)\nprint(f\"Stepped past target\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#overview","title":"Overview","text":"<p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using TLE orbital data. This is the standard model used for tracking objects in Earth orbit and is maintained by NORAD/Space Force.</p> <p>Key Features: - Industry-standard orbit propagation - Atmospheric drag modeling - Automatic selection between SGP4 (near-Earth) and SDP4 (deep-space) models - Compatible with standard TLE format</p> <p>Module: <code>brahe.orbits</code></p>"},{"location":"library_api/orbits/sgp_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator from TLE\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get current epoch\nepoch = prop.epoch()\n\n# Propagate to a specific time\nfuture_epoch = epoch + 3600.0  # 1 hour later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz] in TEME frame\n\n# Propagate to multiple times\nimport numpy as np\ntimes = np.linspace(0, 86400, 100)  # 1 day in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)  # Returns array of states\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>TLE - Two-Line Element format details</li> <li>Keplerian Elements - Orbital element functions</li> </ul>"},{"location":"library_api/orbits/tle.html","title":"Two-Line Element (TLE)","text":"<p>Classes and functions for working with Two-Line Element sets.</p>"},{"location":"library_api/orbits/tle.html#tle-class","title":"TLE Class","text":"<p>The <code>TLE</code> class represents a Two-Line Element set for satellite orbit description.</p> <pre><code>from brahe import TLE\n\n# Create TLE from strings\ntle = TLE(\n    \"ISS (ZARYA)\",\n    \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\",\n    \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n)\n\n# Access TLE properties\nprint(f\"Satellite: {tle.name}\")\nprint(f\"NORAD ID: {tle.norad_id}\")\nprint(f\"Inclination: {tle.inclination} deg\")\n</code></pre> <p>For complete API documentation, see the Rust API documentation.</p>"},{"location":"library_api/orbits/tle.html#tle-utility-functions","title":"TLE Utility Functions","text":""},{"location":"library_api/orbits/tle.html#brahe.orbits.epoch_from_tle","title":"epoch_from_tle  <code>builtin</code>","text":"<pre><code>epoch_from_tle(line1: str) -&gt; Epoch\n</code></pre> <p>Extract Epoch from TLE line 1</p> <p>Extracts and parses the epoch timestamp from the first line of TLE data. The epoch is returned in UTC time system.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Extracted epoch in UTC time system</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\n&gt;&gt;&gt; epoch = epoch_from_tle(line1)\n&gt;&gt;&gt; epoch.year()\n2021\n</code></pre>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_from_tle","title":"keplerian_elements_from_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_from_tle(line1: str, line2: str) -&gt; Tuple\n</code></pre> <p>Extract Keplerian orbital elements from TLE lines.</p> <p>Extracts the standard six Keplerian orbital elements from Two-Line Element (TLE) data. Returns elements in standard order: [a, e, i, raan, argp, M] where angles are in radians.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing: - epoch (Epoch): Epoch of the TLE data. - elements (numpy.ndarray): Six Keplerian elements [a, e, i, raan, argp, M] where   a is semi-major axis in meters, e is eccentricity (dimensionless), and   i, raan, argp, M are in radians.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_to_tle","title":"keplerian_elements_to_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_to_tle(epoch: Epoch, elements: ndarray, norad_id: str) -&gt; Tuple\n</code></pre> <p>Convert Keplerian elements to TLE lines.</p> <p>Converts standard Keplerian orbital elements to Two-Line Element (TLE) format. Input angles should be in degrees for compatibility with TLE format.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>elements</code> <code>ndarray</code> <p>Keplerian elements [a (m), e, i (deg), raan (deg), argp (deg), M (deg)].</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.create_tle_lines","title":"create_tle_lines  <code>builtin</code>","text":"<pre><code>create_tle_lines(epoch: Epoch, inclination: float, raan: float, eccentricity: float, arg_perigee: float, mean_anomaly: float, mean_motion: float, norad_id: str, ephemeris_type: int, element_set_number: int, revolution_number: int, classification: str = None, intl_designator: str = None, first_derivative: float = None, second_derivative: float = None, bstar: float = None) -&gt; Tuple\n</code></pre> <p>Create complete TLE lines from all parameters.</p> <p>Creates Two-Line Element (TLE) lines from complete set of orbital and administrative parameters. Provides full control over all TLE fields including derivatives and drag terms.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless).</p> required <code>arg_perigee</code> <code>float</code> <p>Argument of periapsis in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <code>ephemeris_type</code> <code>int</code> <p>Ephemeris type (0-9).</p> required <code>element_set_number</code> <code>int</code> <p>Element set number.</p> required <code>revolution_number</code> <code>int</code> <p>Revolution number at epoch.</p> required <code>classification</code> <code>str</code> <p>Security classification. Defaults to ' '.</p> <code>None</code> <code>intl_designator</code> <code>str</code> <p>International designator. Defaults to ''.</p> <code>None</code> <code>first_derivative</code> <code>float</code> <p>First derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>second_derivative</code> <code>float</code> <p>Second derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>bstar</code> <code>float</code> <p>BSTAR drag term. Defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_line","title":"validate_tle_line  <code>builtin</code>","text":"<pre><code>validate_tle_line(line: str) -&gt; bool\n</code></pre> <p>Validate single TLE line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the line is valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_lines","title":"validate_tle_lines  <code>builtin</code>","text":"<pre><code>validate_tle_lines(line1: str, line2: str) -&gt; bool\n</code></pre> <p>Validate TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both lines are valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.calculate_tle_line_checksum","title":"calculate_tle_line_checksum  <code>builtin</code>","text":"<pre><code>calculate_tle_line_checksum(line: str) -&gt; int\n</code></pre> <p>Calculate TLE line checksum.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum value.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.parse_norad_id","title":"parse_norad_id  <code>builtin</code>","text":"<pre><code>parse_norad_id(norad_str: str) -&gt; int\n</code></pre> <p>Parse NORAD ID from string, handling both classic and Alpha-5 formats.</p> <p>Parameters:</p> Name Type Description Default <code>norad_str</code> <code>str</code> <p>NORAD ID string from TLE.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Parsed numeric NORAD ID.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_numeric_to_alpha5","title":"norad_id_numeric_to_alpha5  <code>builtin</code>","text":"<pre><code>norad_id_numeric_to_alpha5(norad_id: int) -&gt; str\n</code></pre> <p>Convert numeric NORAD ID to Alpha-5 format.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>Numeric NORAD ID (100000-339999).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_alpha5_to_numeric","title":"norad_id_alpha5_to_numeric  <code>builtin</code>","text":"<pre><code>norad_id_alpha5_to_numeric(alpha5_id: str) -&gt; int\n</code></pre> <p>Convert Alpha-5 NORAD ID to numeric format.</p> <p>Parameters:</p> Name Type Description Default <code>alpha5_id</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric NORAD ID.</p>"},{"location":"library_api/time/index.html","title":"Time","text":"<p>Module: <code>brahe.time</code></p> <p>High-precision time system management and conversions.</p>"},{"location":"library_api/time/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Epoch Class - Core time representation supporting multiple time systems</li> <li>Time Conversions - Functions for converting between time systems and formats</li> </ul>"},{"location":"library_api/time/conversions.html","title":"Time Conversions","text":"<p>Functions for converting between different time systems and formats.</p>"},{"location":"library_api/time/conversions.html#time-system-offset-functions","title":"Time System Offset Functions","text":""},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_mjd","title":"time_system_offset_for_mjd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_mjd(mjd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from UTC to TAI at J2000 epoch\nmjd_j2000 = 51544.0\noffset = bh.time_system_offset_for_mjd(mjd_j2000, bh.TimeSystem.UTC, bh.TimeSystem.TAI)\nprint(f\"UTC to TAI offset: {offset} seconds\")\n# Output: UTC to TAI offset: 32.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_jd","title":"time_system_offset_for_jd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_jd(jd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from GPS to UTC at a specific Julian Date\njd = 2460000.0\noffset = bh.time_system_offset_for_jd(jd, bh.TimeSystem.GPS, bh.TimeSystem.UTC)\nprint(f\"GPS to UTC offset: {offset} seconds\")\n# Output: GPS to UTC offset: -18.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_datetime","title":"time_system_offset_for_datetime  <code>builtin</code>","text":"<pre><code>time_system_offset_for_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Gregorian calendar date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from TT to TAI on January 1, 2024\noffset = bh.time_system_offset_for_datetime(\n    2024, 1, 1, 0, 0, 0.0, 0.0,\n    bh.TimeSystem.TT, bh.TimeSystem.TAI\n)\nprint(f\"TT to TAI offset: {offset} seconds\")\n# Output: TT to TAI offset: -32.184 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#datetime-conversion-functions","title":"DateTime Conversion Functions","text":""},{"location":"library_api/time/conversions.html#brahe.datetime_to_jd","title":"datetime_to_jd  <code>builtin</code>","text":"<pre><code>datetime_to_jd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Julian Date\njd = bh.datetime_to_jd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460311.000000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.datetime_to_mjd","title":"datetime_to_mjd  <code>builtin</code>","text":"<pre><code>datetime_to_mjd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Modified Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Modified Julian Date\nmjd = bh.datetime_to_mjd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.500000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.jd_to_datetime","title":"jd_to_datetime  <code>builtin</code>","text":"<pre><code>jd_to_datetime(jd: float) -&gt; Tuple\n</code></pre> <p>Convert a Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Julian Date to Gregorian calendar\njd = 2460311.0\nyear, month, day, hour, minute, second, nanosecond = bh.jd_to_datetime(jd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.mjd_to_datetime","title":"mjd_to_datetime  <code>builtin</code>","text":"<pre><code>mjd_to_datetime(mjd: float) -&gt; Tuple\n</code></pre> <p>Convert a Modified Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Modified Julian Date to Gregorian calendar\nmjd = 60310.5\nyear, month, day, hour, minute, second, nanosecond = bh.mjd_to_datetime(mjd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html","title":"Epoch Class","text":"<p>The <code>Epoch</code> class is the foundational time representation in Brahe, providing comprehensive support for multiple time systems and high-precision time computations with nanosecond accuracy.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch","title":"Epoch","text":"<pre><code>Epoch()\n</code></pre> <p>Represents a specific instant in time.</p> <p>Epoch is the primary and preferred mechanism for representing time in brahe. It accurately represents, tracks, and compares instants in time with nanosecond precision.</p> <p>Internally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation was chosen to enable accurate time system conversions using the IAU SOFA library (which operates in days and fractional days) while maintaining high precision for small time differences. The structure uses Kahan summation to accurately handle running sums over long periods without losing accuracy to floating-point rounding errors.</p> <p>All arithmetic operations (addition, subtraction) use seconds as the default unit and return time differences in seconds.</p> <p>The Epoch constructor accepts multiple input formats for convenience:</p> <ul> <li>Date components: <code>Epoch(year, month, day)</code> - creates epoch at midnight</li> <li>Full datetime: <code>Epoch(year, month, day, hour, minute, second, nanosecond)</code> - full precision</li> <li>Partial datetime: <code>Epoch(year, month, day, hour)</code> or <code>Epoch(year, month, day, hour, minute)</code> etc.</li> <li>ISO 8601 string: <code>Epoch(\"2024-01-01T12:00:00Z\")</code> - parse from string</li> <li>Python datetime: <code>Epoch(datetime_obj)</code> - convert from Python datetime</li> <li>Copy constructor: <code>Epoch(other_epoch)</code> - create a copy</li> <li>Time system: All constructors accept optional <code>time_system=</code> keyword argument (default: UTC)</li> </ul> Example <pre><code>import brahe as bh\nfrom datetime import datetime\n\n# Multiple ways to create the same epoch\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\nepc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\nprint(epc1)\n# Output: 2024-01-01 12:00:00.000 UTC\n\n# Create epoch at midnight\nmidnight = bh.Epoch(2024, 1, 1)\nprint(midnight)\n# Output: 2024-01-01 00:00:00.000 UTC\n\n# Use different time systems\ngps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\nprint(gps_time)\n# Output: 2024-01-01 12:00:00.000 GPS\n\n# Perform arithmetic operations\nepoch2 = epc1 + 3600.0  # Add one hour (in seconds)\ndiff = epoch2 - epc1     # Difference in seconds\nprint(f\"Time difference: {diff} seconds\")\n# Output: Time difference: 3600.0 seconds\n\n# Legacy constructors still available\nepc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nepc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a specific instant in time.\\n\\nEpoch is the primary and preferred mechanism for representing time in brahe.\\nIt accurately represents, tracks, and compares instants in time with nanosecond precision.\\n\\nInternally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation\\nwas chosen to enable accurate time system conversions using the IAU SOFA library (which operates\\nin days and fractional days) while maintaining high precision for small time differences.\\nThe structure uses Kahan summation to accurately handle running sums over long periods without\\nlosing accuracy to floating-point rounding errors.\\n\\nAll arithmetic operations (addition, subtraction) use seconds as the default unit and return\\ntime differences in seconds.\\n\\nThe Epoch constructor accepts multiple input formats for convenience:\\n\\n- **Date components**: `Epoch(year, month, day)` - creates epoch at midnight\\n- **Full datetime**: `Epoch(year, month, day, hour, minute, second, nanosecond)` - full precision\\n- **Partial datetime**: `Epoch(year, month, day, hour)` or `Epoch(year, month, day, hour, minute)` etc.\\n- **ISO 8601 string**: `Epoch(\"2024-01-01T12:00:00Z\")` - parse from string\\n- **Python datetime**: `Epoch(datetime_obj)` - convert from Python datetime\\n- **Copy constructor**: `Epoch(other_epoch)` - create a copy\\n- **Time system**: All constructors accept optional `time_system=` keyword argument (default: UTC)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    from datetime import datetime\\n\\n    # Multiple ways to create the same epoch\\n    epc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\\n    epc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\\n    epc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\\n    print(epc1)\\n    # Output: 2024-01-01 12:00:00.000 UTC\\n\\n    # Create epoch at midnight\\n    midnight = bh.Epoch(2024, 1, 1)\\n    print(midnight)\\n    # Output: 2024-01-01 00:00:00.000 UTC\\n\\n    # Use different time systems\\n    gps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\\n    print(gps_time)\\n    # Output: 2024-01-01 12:00:00.000 GPS\\n\\n    # Perform arithmetic operations\\n    epoch2 = epc1 + 3600.0  # Add one hour (in seconds)\\n    diff = epoch2 - epc1     # Difference in seconds\\n    print(f\"Time difference: {diff} seconds\")\\n    # Output: Time difference: 3600.0 seconds\\n\\n    # Legacy constructors still available\\n    epc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\\n    epc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.time_system","title":"time_system  <code>property</code>","text":"<pre><code>time_system: TimeSystem\n</code></pre> <p>Time system of the epoch.</p> <p>Returns:</p> Name Type Description <code>TimeSystem</code> <code>TimeSystem</code> <p>The time system used by this epoch</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day","title":"day  <code>method descriptor</code>","text":"<pre><code>day() -&gt; int\n</code></pre> <p>Returns the day component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The day of the month as an integer from 1 to 31</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year","title":"day_of_year  <code>method descriptor</code>","text":"<pre><code>day_of_year() -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the epoch's time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, \"UTC\") doy = epoch.day_of_year() print(f\"Day of year: {doy}\") Day of year: 100.5</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year_as_time_system","title":"day_of_year_as_time_system  <code>method descriptor</code>","text":"<pre><code>day_of_year_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the specified time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>The time system to use for the calculation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, brahe.TimeSystem.UTC) doy_tai = epoch.day_of_year_as_time_system(brahe.TimeSystem.TAI) print(f\"Day of year in TAI: {doy_tai}\") Day of year in TAI: 100.50042824074075</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_date","title":"from_date  <code>builtin</code>","text":"<pre><code>from_date(year: int, month: int, day: int, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a calendar date at midnight.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing midnight on the specified date</p> Example <pre><code>import brahe as bh\n\n# Create an epoch at midnight on January 1, 2024 UTC\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T00:00:00.000000000 UTC\n\n# Create epoch in different time system\nepc_tai = bh.Epoch.from_date(2024, 6, 15, bh.TimeSystem.TAI)\nprint(epc_tai)\n# Output: 2024-06-15T00:00:00.000000000 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_datetime","title":"from_datetime  <code>builtin</code>","text":"<pre><code>from_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a complete Gregorian calendar date and time.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified date and time</p> Example <pre><code>import brahe as bh\n\n# Create epoch for January 1, 2024 at 12:30:45.5 UTC\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T12:30:45.500000000 UTC\n\n# With nanosecond precision\nepc_ns = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 0.0, 123456789.0, bh.TimeSystem.TAI)\nprint(epc_ns)\n# Output: 2024-06-15T14:30:00.123456789 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_day_of_year","title":"from_day_of_year  <code>builtin</code>","text":"<pre><code>from_day_of_year(year: int, day_of_year: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a year and floating-point day-of-year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>day_of_year</code> <code>float</code> <p>Day of year as a floating-point number (1.0 = January 1st, 1.5 = January 1st noon, etc.)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified day of year</p> Example <pre><code>import brahe as bh\n\n# Create epoch for day 100 of 2024 at midnight\nepc = bh.Epoch.from_day_of_year(2024, 100.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-04-09T00:00:00.000000000 UTC\n\n# Create epoch for day 100.5 (noon on day 100)\nepc_noon = bh.Epoch.from_day_of_year(2024, 100.5, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc_noon.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-04-09 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_date","title":"from_gps_date  <code>builtin</code>","text":"<pre><code>from_gps_date(week: int, seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS week and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>week</code> <code>int</code> <p>GPS week number since GPS epoch (January 6, 1980)</p> required <code>seconds</code> <code>float</code> <p>Seconds into the GPS week</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS week 2200, day 3, noon\nweek = 2200\nseconds = 3 * 86400 + 12 * 3600  # 3 days + 12 hours\nepc = bh.Epoch.from_gps_date(week, seconds)\nprint(epc)\n\n# Verify GPS week extraction\nweek_out, sec_out = epc.gps_date()\nprint(f\"GPS Week: {week_out}, Seconds: {sec_out}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_nanoseconds","title":"from_gps_nanoseconds  <code>builtin</code>","text":"<pre><code>from_gps_nanoseconds(gps_nanoseconds: int) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS nanoseconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_nanoseconds</code> <code>int</code> <p>Nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS nanoseconds with high precision\ngps_ns = 1234567890123456789\nepc = bh.Epoch.from_gps_nanoseconds(gps_ns)\nprint(f\"Epoch: {epc}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_seconds","title":"from_gps_seconds  <code>builtin</code>","text":"<pre><code>from_gps_seconds(gps_seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS seconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_seconds</code> <code>float</code> <p>Seconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS seconds\ngps_seconds = 1234567890.5\nepc = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"Epoch: {epc}\")\nprint(f\"GPS seconds: {epc.gps_seconds()}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_jd","title":"from_jd  <code>builtin</code>","text":"<pre><code>from_jd(jd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Julian Date\njd = 2460000.0\nepc = bh.Epoch.from_jd(jd, bh.TimeSystem.UTC)\nprint(epc)\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"JD: {jd_out:.10f}\")\n# Output: JD: 2460000.0000000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_mjd","title":"from_mjd  <code>builtin</code>","text":"<pre><code>from_mjd(mjd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Modified Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Modified Julian Date\nmjd = 60000.0\nepc = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\nprint(epc)\n\n# MJD is commonly used in astronomy\nmjd_j2000 = 51544.0  # J2000 epoch\nepc_j2000 = bh.Epoch.from_mjd(mjd_j2000, bh.TimeSystem.TT)\nprint(f\"J2000: {epc_j2000}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_string","title":"from_string  <code>builtin</code>","text":"<pre><code>from_string(datestr: str) -&gt; Epoch\n</code></pre> <p>Create an Epoch from an ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>datestr</code> <code>str</code> <p>ISO 8601 formatted date string (e.g., \"2024-01-01T12:00:00.000000000 UTC\")</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the parsed date and time</p> Example <pre><code>import brahe as bh\n\n# Parse ISO 8601 string with full precision\nepc = bh.Epoch.from_string(\"2024-01-01T12:00:00.000000000 UTC\")\nprint(epc)\n# Output: 2024-01-01T12:00:00.000000000 UTC\n\n# Parse different time systems\nepc_tai = bh.Epoch.from_string(\"2024-06-15T14:30:45.123456789 TAI\")\nprint(epc_tai.time_system)\n# Output: TimeSystem.TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gast","title":"gast  <code>method descriptor</code>","text":"<pre><code>gast(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Apparent Sidereal Time (GAST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GAST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngast_rad = epc.gast(bh.AngleFormat.RADIANS)\ngast_deg = epc.gast(bh.AngleFormat.DEGREES)\nprint(f\"GAST: {gast_rad:.6f} rad = {gast_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gmst","title":"gmst  <code>method descriptor</code>","text":"<pre><code>gmst(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Mean Sidereal Time (GMST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GMST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngmst_rad = epc.gmst(bh.AngleFormat.RADIANS)\ngmst_deg = epc.gmst(bh.AngleFormat.DEGREES)\nprint(f\"GMST: {gmst_rad:.6f} rad = {gmst_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_date","title":"gps_date  <code>method descriptor</code>","text":"<pre><code>gps_date() -&gt; Tuple\n</code></pre> <p>Get the GPS week number and seconds into the week.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (week, seconds_into_week)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.GPS)\nweek, seconds = epc.gps_date()\nprint(f\"GPS Week: {week}, Seconds: {seconds:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_nanoseconds","title":"gps_nanoseconds  <code>method descriptor</code>","text":"<pre><code>gps_nanoseconds() -&gt; float\n</code></pre> <p>Get the nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS nanoseconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 123456789.0, bh.TimeSystem.GPS)\ngps_ns = epc.gps_nanoseconds()\nprint(f\"GPS nanoseconds: {gps_ns:.0f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_seconds","title":"gps_seconds  <code>method descriptor</code>","text":"<pre><code>gps_seconds() -&gt; float\n</code></pre> <p>Get the seconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS seconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\ngps_sec = epc.gps_seconds()\nprint(f\"GPS seconds: {gps_sec:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.hour","title":"hour  <code>method descriptor</code>","text":"<pre><code>hour() -&gt; int\n</code></pre> <p>Returns the hour component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hour as an integer from 0 to 23</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring","title":"isostring  <code>method descriptor</code>","text":"<pre><code>isostring() -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string with full nanosecond precision</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso = epc.isostring()\nprint(iso)\n# Output: 2024-01-01T12:30:45.123456789Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring_with_decimals","title":"isostring_with_decimals  <code>method descriptor</code>","text":"<pre><code>isostring_with_decimals(decimals: int) -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string with specified decimal precision.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimal places for the seconds field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso3 = epc.isostring_with_decimals(3)\niso6 = epc.isostring_with_decimals(6)\nprint(iso3)  # Output: 2024-01-01T12:30:45.123Z\nprint(iso6)  # Output: 2024-01-01T12:30:45.123457Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd","title":"jd  <code>method descriptor</code>","text":"<pre><code>jd() -&gt; float\n</code></pre> <p>Get the Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd = epc.jd()\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460310.500000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd_as_time_system","title":"jd_as_time_system  <code>method descriptor</code>","text":"<pre><code>jd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd_utc = epc.jd()\njd_tai = epc.jd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"JD UTC: {jd_utc:.10f}\")\nprint(f\"JD TAI: {jd_tai:.10f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.minute","title":"minute  <code>method descriptor</code>","text":"<pre><code>minute() -&gt; int\n</code></pre> <p>Returns the minute component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The minute as an integer from 0 to 59</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd","title":"mjd  <code>method descriptor</code>","text":"<pre><code>mjd() -&gt; float\n</code></pre> <p>Get the Modified Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epc.mjd()\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd_as_time_system","title":"mjd_as_time_system  <code>method descriptor</code>","text":"<pre><code>mjd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Modified Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd_utc = epc.mjd()\nmjd_gps = epc.mjd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"MJD UTC: {mjd_utc:.6f}\")\nprint(f\"MJD GPS: {mjd_gps:.6f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.month","title":"month  <code>method descriptor</code>","text":"<pre><code>month() -&gt; int\n</code></pre> <p>Returns the month component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The month as an integer from 1 to 12</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.nanosecond","title":"nanosecond  <code>method descriptor</code>","text":"<pre><code>nanosecond() -&gt; float\n</code></pre> <p>Returns the nanosecond component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The nanosecond component as a floating-point number</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.second","title":"second  <code>method descriptor</code>","text":"<pre><code>second() -&gt; float\n</code></pre> <p>Returns the second component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The second as a floating-point number from 0.0 to 59.999...</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime","title":"to_datetime  <code>method descriptor</code>","text":"<pre><code>to_datetime() -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-06-15 14:30:45.500\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime_as_time_system","title":"to_datetime_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_datetime_as_time_system(time_system: TimeSystem) -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Create epoch in UTC and convert to TAI\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime_as_time_system(bh.TimeSystem.TAI)\nprint(f\"TAI: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: TAI: 2024-01-01 12:00:37.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_string_as_time_system","title":"to_string_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_string_as_time_system(time_system: TimeSystem) -&gt; str\n</code></pre> <p>Convert the epoch to a string representation in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the epoch</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprint(epc.to_string_as_time_system(bh.TimeSystem.UTC))\nprint(epc.to_string_as_time_system(bh.TimeSystem.TAI))\n# Shows same instant in different time systems\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.year","title":"year  <code>method descriptor</code>","text":"<pre><code>year() -&gt; int\n</code></pre> <p>Returns the year component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year as a 4-digit integer</p>"},{"location":"library_api/trajectories/index.html","title":"Trajectories","text":"<p>Module: <code>brahe.trajectories</code></p> <p>Trajectory containers for storing, managing, and interpolating time-series state data.</p>"},{"location":"library_api/trajectories/index.html#overview","title":"Overview","text":"<p>Brahe provides several trajectory container types for storing sequences of states (positions, velocities, or other data) over time with automatic interpolation capabilities.</p>"},{"location":"library_api/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":""},{"location":"library_api/trajectories/index.html#dtrajectory","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container where dimension is set at runtime. Flexible for storing any N-dimensional state data.</p>"},{"location":"library_api/trajectories/index.html#strajectory6","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state vectors [x, y, z, vx, vy, vz]. Faster than DTrajectory for fixed-size data.</p>"},{"location":"library_api/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized orbital trajectory with frame-aware storage and automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/index.html#key-features","title":"Key Features","text":"<ul> <li>Time-ordered storage: States automatically sorted by epoch</li> <li>Interpolation: Linear or Lagrange interpolation between states</li> <li>Eviction policies: Automatic state removal based on age or count</li> <li>Query methods: Get states before/after/at specific times</li> <li>Batch operations: Add and query multiple states efficiently</li> </ul>"},{"location":"library_api/trajectories/index.html#quick-comparison","title":"Quick Comparison","text":"Feature DTrajectory STrajectory6 OrbitTrajectory Dimension Runtime (any N) Compile-time (6) Compile-time (6) Performance Good Better Better Use Case General data Orbital states Frame-aware orbits Frames Not frame-aware Not frame-aware ECI/ECEF support"},{"location":"library_api/trajectories/index.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Option 1: Dynamic trajectory (any dimension)\ntraj_dyn = bh.DTrajectory(dimension=6)\n\n# Option 2: Static 6D trajectory (faster for orbital states)\ntraj_static = bh.STrajectory6()\n\n# Option 3: Orbit trajectory (frame-aware)\ntraj_orbit = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Add states\nstate = np.array([7000000.0, 0.0, 0.0, 0.0, 7500.0, 0.0])  # [x,y,z,vx,vy,vz]\ntraj_static.add(epoch, state)\n\n# Propagate orbit and store trajectory\nprop = bh.KeplerianPropagator(...)\ntimes = np.linspace(0, 86400, 100)\nfor dt in times:\n    future_epoch = epoch + dt\n    state = prop.propagate(future_epoch)\n    traj_static.add(future_epoch, state)\n\n# Query with interpolation\nquery_epoch = epoch + 43200.0  # 12 hours later\ninterpolated_state = traj_static.interpolate(query_epoch)\n</code></pre>"},{"location":"library_api/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>InterpolationMethod - Interpolation options</li> <li>OrbitFrame - Frame specifications</li> <li>KeplerianPropagator - Analytical orbit propagation</li> <li>SGPPropagator - SGP4/SDP4 orbit propagation</li> </ul>"},{"location":"library_api/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container for N-dimensional state data.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory","title":"DTrajectory","text":"<pre><code>DTrajectory()\n</code></pre> <p>Dynamic-dimension trajectory container.</p> <p>Stores a sequence of N-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is determined at runtime.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Dynamic-dimension trajectory container.\\n\\nStores a sequence of N-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is\\ndetermined at runtime.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__()\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__()\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>N-element state vector where N is the trajectory dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get the trajectory dimension (method form).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Any\n</code></pre> <p>Get end epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.epoch","title":"epoch  <code>method descriptor</code>","text":"<pre><code>epoch(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; DTrajectory\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of states with shape (num_epochs, dimension) where each row is a state vector</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = bh.InterpolationMethod.LINEAR\ntraj.set_interpolation_method(method)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Any\n</code></pre> <p>Get start epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(index: int) -&gt; np.ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; Any\n</code></pre> <p>Get time span of trajectory in seconds</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#overview","title":"Overview","text":"<p><code>DTrajectory</code> is a flexible trajectory container where the state dimension is determined at runtime. Use this when you need to store state vectors of varying sizes or when the dimension isn't known at compile time.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Runtime dimension specification - Automatic time-ordering of states - Configurable interpolation (Linear or Lagrange) - Eviction policies for memory management - Efficient state queries and interpolation</p>"},{"location":"library_api/trajectories/dtrajectory.html#creating-a-trajectory","title":"Creating a Trajectory","text":"<pre><code>import brahe as bh\n\n# Create with specified dimension\ntraj = bh.DTrajectory(dimension=6)  # For orbital states\n\n# Create with specific interpolation method\ntraj = bh.DTrajectory(\n    dimension=3,\n    interpolation_method=bh.InterpolationMethod.LAGRANGE\n)\n\n# Create from existing data\nimport numpy as np\nepochs = [epoch1, epoch2, epoch3]\nstates = np.array([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])\ntraj = bh.DTrajectory.from_data(\n    epochs,\n    states,\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(dimension=6)\n\n# Add single state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([7e6, 0, 0, 0, 7.5e3, 0])\ntraj.add(epoch, state)\n\n# Add multiple states from propagation\nprop = bh.KeplerianPropagator(...)\nfor i in range(100):\n    future_epoch = epoch + i * 60.0  # Every minute\n    state = prop.propagate(future_epoch)\n    traj.add(future_epoch, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#querying-states","title":"Querying States","text":"<pre><code># Interpolate at specific epoch\nquery_epoch = epoch + 1800.0  # 30 minutes later\ninterp_state = traj.interpolate(query_epoch)\n\n# Get state at specific index\nstate_10 = traj.state(10)\nepoch_10 = traj.epoch(10)\n\n# Get first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\n\n# Get state before/after epoch\nbefore_epoch, before_state = traj.state_before_epoch(query_epoch)\nafter_epoch, after_state = traj.state_after_epoch(query_epoch)\n\n# Get all data\nall_states = traj.to_matrix()  # Returns numpy array (n_states, dimension)\nall_epochs = traj.to_epochs()  # Returns list of Epochs\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#eviction-policies","title":"Eviction Policies","text":"<p>Control memory usage by automatically removing old states:</p> <pre><code># Maximum age: keep only states within 1 hour of newest\ntraj.set_eviction_policy_max_age(3600.0)\n\n# Maximum size: keep only last 1000 states\ntraj.set_eviction_policy_max_size(1000)\n\n# No eviction (default)\ntraj.set_eviction_policy_no_eviction()\n\n# Builder pattern (method chaining)\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_eviction_policy_max_age(3600.0) \\\n    .with_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#interpolation-methods","title":"Interpolation Methods","text":"<pre><code># Linear interpolation (faster, less accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n\n# Lagrange interpolation (slower, more accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#trajectory-information","title":"Trajectory Information","text":"<pre><code># Get dimension\ndim = traj.dimension()  # Returns dimension of state vectors\n\n# Get size\nn_states = traj.len()  # Number of states stored\n\n# Check if empty\nis_empty = traj.is_empty()\n\n# Get time span\nspan = traj.timespan()  # Duration in seconds from first to last\n\n# Get start/end epochs\nstart = traj.start_epoch()\nend = traj.end_epoch()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#clearing-and-removing-states","title":"Clearing and Removing States","text":"<pre><code># Clear all states\ntraj.clear()\n\n# Remove state at specific epoch\nremoved_state = traj.remove_epoch(epoch)\n\n# Remove state at index\nremoved_epoch, removed_state = traj.remove_at(index)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#complete-example","title":"Complete Example","text":"<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set up propagator\nepoch_start = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch_start,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Create trajectory with eviction policy\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_interpolation_method(bh.InterpolationMethod.LINEAR) \\\n    .with_eviction_policy_max_size(1000)\n\n# Propagate and store states\ntimes = np.linspace(0, 86400, 1440)  # 1 day, 1-minute steps\nfor dt in times:\n    epoch = epoch_start + dt\n    state = prop.propagate(epoch)\n    traj.add(epoch, state)\n\nprint(f\"Stored {traj.len()} states\")\nprint(f\"Time span: {traj.timespan()/3600:.1f} hours\")\n\n# Interpolate at arbitrary times\nquery_times = np.linspace(0, 86400, 100)\naltitudes = []\nfor dt in query_times:\n    query_epoch = epoch_start + dt\n    state = traj.interpolate(query_epoch)\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1000  # km\n    altitudes.append(altitude)\n\n# Plot altitude profile\nplt.plot(query_times/3600, altitudes)\nplt.xlabel('Time (hours)')\nplt.ylabel('Altitude (km)')\nplt.title('Orbit Altitude Over 1 Day')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Fixed 6D trajectory (faster)</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> <li>InterpolationMethod</li> </ul>"},{"location":"library_api/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p>Frame-aware orbital trajectory with automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory","title":"OrbitTrajectory","text":"<pre><code>OrbitTrajectory()\n</code></pre> <p>Orbital trajectory with frame and representation awareness.</p> <p>Stores a sequence of orbital states at specific epochs with support for interpolation, frame conversions, and representation transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital trajectory with frame and representation awareness.\\n\\nStores a sequence of orbital states at specific epochs with support for\\ninterpolation, frame conversions, and representation transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.angle_format","title":"angle_format  <code>property</code>","text":"<pre><code>angle_format: AngleFormat\n</code></pre> <p>Get trajectory angle format for Keplerian states.</p> <p>Returns:</p> Type Description <code>AngleFormat</code> <p>AngleFormat or None: Angle format for Keplerian representation, None for Cartesian</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Angle format: {traj.angle_format}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: OrbitFrame\n</code></pre> <p>Get trajectory reference frame.</p> <p>Returns:</p> Name Type Description <code>OrbitFrame</code> <code>OrbitFrame</code> <p>Reference frame of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Frame: {traj.frame}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.representation","title":"representation  <code>property</code>","text":"<pre><code>representation: OrbitRepresentation\n</code></pre> <p>Get trajectory state representation.</p> <p>Returns:</p> Name Type Description <code>OrbitRepresentation</code> <code>OrbitRepresentation</code> <p>State representation format of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Representation: {traj.representation}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__()\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__()\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.clear()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; OrbitTrajectory\n</code></pre> <p>Create a default empty orbital trajectory (ECI Cartesian).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory with ECI frame and Cartesian representation</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6 for orbital trajectories).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"End epoch: {traj.end_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epoch","title":"epoch  <code>method descriptor</code>","text":"<pre><code>epoch(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at given index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epoch = traj.epoch(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epochs","title":"epochs  <code>method descriptor</code>","text":"<pre><code>epochs() -&gt; np.ndarray\n</code></pre> <p>Get all epochs as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 1D array of Julian dates for all epochs</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nepochs_array = traj.epochs()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.from_orbital_data","title":"from_orbital_data  <code>builtin</code>","text":"<pre><code>from_orbital_data(epochs: list[Epoch], states: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None = None) -&gt; OrbitTrajectory\n</code></pre> <p>Create orbital trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs for each state</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6-element state vectors with total length N*6 where N is the number of epochs</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the states</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Start epoch: {traj.start_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(index: int) -&gt; np.ndarray\n</code></pre> <p>Get state at specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at given index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_state = traj.state(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array of states with shape (6, N) where N is the number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nstates_array = traj.states()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 3600.0, state)\nprint(f\"Timespan: {traj.timespan()} seconds\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_ecef","title":"to_ecef  <code>method descriptor</code>","text":"<pre><code>to_ecef() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECEF (Earth-Centered Earth-Fixed) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECEF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_ecef = traj.to_ecef()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eci","title":"to_eci  <code>method descriptor</code>","text":"<pre><code>to_eci() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECI (Earth-Centered Inertial) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\ntraj.add(epc, state)\ntraj_eci = traj.to_eci()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_keplerian","title":"to_keplerian  <code>method descriptor</code>","text":"<pre><code>to_keplerian(angle_format: AngleFormat) -&gt; OrbitTrajectory\n</code></pre> <p>Convert to Keplerian representation in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for the result (Radians or Degrees)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Keplerian representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_kep = traj.to_keplerian(bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Convert trajectory to matrix representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array with shape (6, N) where N is number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nmatrix = traj.to_matrix()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#overview","title":"Overview","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that stores states in a specific reference frame (ECI or ECEF) and can automatically transform between frames when querying.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Frame-aware storage (ECI or ECEF) - Automatic frame transformations on query - Built on STrajectory6 (6D states only) - Same performance as STrajectory6</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#creating-with-frame","title":"Creating with Frame","text":"<pre><code>import brahe as bh\n\n# ECI frame trajectory\ntraj_eci = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# ECEF frame trajectory\ntraj_ecef = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECEF)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Propagate and store states in ECI\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Add states\nfor i in range(100):\n    t = epoch + i * 60.0\n    state_eci = prop.propagate(t)\n    traj.add(t, state_eci)\n\n# States are stored and retrieved in ECI\nquery_epoch = epoch + 1800.0\nstate = traj.interpolate(query_epoch)  # ECI frame\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#frame-information","title":"Frame Information","text":"<pre><code># Get trajectory frame\nframe = traj.frame()  # Returns OrbitFrame.ECI or OrbitFrame.ECEF\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#api","title":"API","text":"<p>OrbitTrajectory has the same API as STrajectory6 and DTrajectory, plus frame awareness.</p> <p>See STrajectory6 or DTrajectory for full API documentation.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Non-frame-aware 6D trajectory</li> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitFrame - Frame specifications</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory container optimized for orbital state vectors.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6","title":"STrajectory6","text":"<pre><code>STrajectory6()\n</code></pre> <p>Static-dimension 6D trajectory container.</p> <p>Stores a sequence of 6-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is fixed at compile time for performance.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Static-dimension 6D trajectory container.\\n\\nStores a sequence of 6-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is fixed\\nat compile time for performance.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.end_epoch","title":"end_epoch  <code>property</code>","text":"<pre><code>end_epoch: Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolation_method","title":"interpolation_method  <code>property</code>","text":"<pre><code>interpolation_method: InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.start_epoch","title":"start_epoch  <code>property</code>","text":"<pre><code>start_epoch: Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.time_span","title":"time_span  <code>property</code>","text":"<pre><code>time_span: float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__()\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__()\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__()\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__()\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.epoch","title":"epoch  <code>method descriptor</code>","text":"<pre><code>epoch(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; STrajectory6\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6D state vectors with total length N*6 where N is the number of epochs</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>New 6D trajectory instance populated with data</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstates = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0,\n                   bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj = bh.STrajectory6.from_data([epc1, epc2], states)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(index: int) -&gt; np.ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; STrajectory6\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#overview","title":"Overview","text":"<p><code>STrajectory6</code> is a trajectory container optimized for 6-dimensional state vectors [x, y, z, vx, vy, vz]. The dimension is fixed at compile time, providing better performance than DTrajectory for orbital mechanics applications.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Use When: - Storing orbital state vectors (position + velocity) - Performance is critical - Dimension is always 6</p> <p>Advantages over DTrajectory: - Faster operations (no runtime dimension checks) - More memory efficient - Same API for state management</p>"},{"location":"library_api/trajectories/strajectory6.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\ntraj = bh.STrajectory6(\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n\n# Add states from propagation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop = bh.KeplerianPropagator(...)\n\nfor i in range(1000):\n    t = epoch + i * 60.0  # Every minute\n    state = prop.propagate(t)  # Returns [x,y,z,vx,vy,vz]\n    traj.add(t, state)\n\n# Query with interpolation\nquery_time = epoch + 1800.0\ninterp_state = traj.interpolate(query_time)\n\nprint(f\"Position: {interp_state[:3]} m\")\nprint(f\"Velocity: {interp_state[3:]} m/s\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#api","title":"API","text":"<p>STrajectory6 has the same methods as DTrajectory: - <code>add()</code>, <code>interpolate()</code>, <code>state()</code>, <code>epoch()</code> - <code>first()</code>, <code>last()</code>, <code>len()</code>, <code>is_empty()</code> - <code>set_eviction_policy_*()</code>, <code>set_interpolation_method()</code> - <code>to_matrix()</code>, <code>to_epochs()</code>, <code>clear()</code></p> <p>See DTrajectory for detailed API documentation.</p>"},{"location":"library_api/trajectories/strajectory6.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> </ul>"}]}