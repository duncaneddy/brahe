{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Brahe","text":"<p> Brahe - Practical Astrodynamics </p> <p> </p> <p>Documentation: https://duncaneddy.github.io/brahe/latest</p> <p>Rust Library Reference: https://docs.rs/crate/brahe/latest</p> <p>Source Code: https://github.com/duncaneddy/brahe</p>"},{"location":"index.html#brahe","title":"Brahe","text":"<p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be quick-to-deploy, composable, extensible, and easy-to-learn. The north-star of the development is enabling users to solve meaningful problems quickly and correctly.</p> <p>Brahe is permissively licensed under an MIT License to enable people to use and build on the work without worrying about licensing restrictions. We want people to be able to stop reinventing the astrodynamics \"wheel\" because commercial licenses are expensive and open-source options are hard to use.</p> <p>We try to prioritize making the software library easy to understand and extend. Many astrodynamics libraries are written in a way that makes them hard to read, understand, or modify. Brahe is written in a modern style with an emphasis on code clarity and modularity to make it easier to understand how algorithms are implemented and to make it easier to extend the library to support new use-cases. This approach has the added benefit of making it easier to verify and validate the correctness of the implementation.</p> <p>If you do find this useful, please consider starring the repository on GitHub to help increase its visibility. If you're using Brahe for school, research, a commercial endeavour, or flying a mission. I'd love to know about it.</p> <p>We hope you find Brahe useful for your work!</p>"},{"location":"index.html#going-further","title":"Going Further","text":"<p>If you want to learn more about how to use the package the documentation is structured in the following way:</p> <ul> <li>Learn: Provides short-form documentation of major concepts of the package.</li> <li>Examples: Provides longer-form examples of how-to examples of accomplish common tasks.</li> <li>Python API Reference: Provides detailed reference documentation of the Python API.</li> <li>Rust API Reference: Provides detailed reference documentation of the Rust API.</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>The project is licensed under the MIT License - see the LICENSE for details.</p> <p>We want to make it easy for people to use and build on the work without worrying about licensing restrictions.</p>"},{"location":"index.html#contributing","title":"Contributing","text":"<p>If you find a bug, have a feature request, want to contribute, please open an issue or a pull request on the GitHub repository. Contributions are welcome and encouraged! If you see something missing, but don't know how to start contributing, please open an issue and we can discuss it. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<p>To install the latest release of brahe for Python, simply run:</p> <pre><code>pip install brahe\n</code></pre> <p>You can then import the package in your Python code with:</p> <pre><code>import brahe as bh\n</code></pre> <p>And do something fun like calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>import brahe as bh\n\n# Define the semi-major axis of a low Earth orbit (in meters)\na = bh.constants.R_EARTH + 400e3  # 400 km altitude\n\n# Calculate the orbital period\nT = bh.orbital_period(a)\n\nprint(f\"Orbital Period: {T / 60:.2f} minutes\")\n# Outputs:\n# Orbital Period: 92.56 minutes\n</code></pre> <p>or find the when the ISS will next pass overhead:</p> <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute upcoming passes of the ISS over San Francisco\npasses = bh.location_accesses(\n    bh.PointLocation(-122.4194, 37.7749, 0.0),  # San Francisco\n    bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\"),  # ISS\n    bh.Epoch.now(),\n    bh.Epoch.now() + 24 * 3600.0,  # Next 24 hours\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n)\nprint(f\"Number of passes in next 24 hours: {len(passes)}\")\n# Example Output: Number of passes in next 24 hours: 5\n</code></pre>"},{"location":"index.html#additional-examples","title":"Additional Examples","text":"<p>If you want to see more examples of how to use brahe, here are some additional quick examples. You can find even more with full source code in the Examples section of the documentation.</p>"},{"location":"index.html#python","title":"Python","text":"<p>Working with Time: <pre><code>import brahe as bh\n\n# Create an epoch from a specific date and time\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Print as ISO 8601 string\nprint(f\"Epoch in UTC: {epc.isostring()}\")\n# Output:\n# Epoch in UTC: 2024-01-01T12:00:00Z\n\n# Get the Modified Julian Date (MJD) in different time systems\nmjd_tai = epc.mjd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"MJD in TAI: {mjd_tai}\")\n# Output:\n# MJD in TAI: 60310.50042824074\n\n# Get the time as a Julian Date (JD) in GPS time system\njd_gps = epc.jd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"JD in GPS: {jd_gps}\")\n# Output:\n# JD in GPS: 2460311.000208333\n\n# Take the difference between two epochs in different time systems\nepc2 = bh.Epoch(2024, 1, 2, 13, 30, 0.0, time_system=bh.TimeSystem.GPS)\ndelta_seconds = epc2 - epc\nprint(f\"Difference between epochs in seconds: {delta_seconds}\")\n# Output:\n# Difference between epochs in seconds: 91782.0\n\n# Get the epoch as a string in different time systems\nepc_utc = epc2.to_string_as_time_system(bh.TimeSystem.UTC)\nprint(f\"Epoch in GPS: {epc2}\")\nprint(f\"Epoch in UTC: {epc_utc}\")\n# Outputs:\n# Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n# Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n</code></pre></p> <p>Coordinate Transformations: <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize Earth Orientation Parameter data\nbh.initialize_eop()\n\n# Define orbital elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis in meters (700 km altitude)\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in radians\nraan = 15.0  # Right Ascension of Ascending Node in radians\narg_periapsis = 30.0  # Argument of Periapsis in radians\nmean_anomaly = 45.0  # Mean Anomaly\n\n# Create a state vector from orbital elements\nstate_kep = np.array([a, e, i, raan, arg_periapsis, mean_anomaly])\n\n# Convert Keplerian state to ECI coordinates\nstate_eci = bh.state_koe_to_eci(state_kep, bh.AngleFormat.DEGREES)\nprint(f\"ECI Coordinates: {state_eci}\")\n# Outputs:\n# ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Define a time epoch\nepoch = bh.Epoch(2024, 6, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Convert ECI coordinates to ECEF coordinates at the given epoch\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\nprint(f\"ECEF Coordinates: {state_ecef}\")\n# Outputs:\n# ECEF Coordinates: [ 1.86480173e+05 -2.07022599e+06  6.76081548e+06 -4.53886373e+03 5.77702345e+03  1.89973203e+03]\n\n# Convert back from ECEF to ECI coordinates\nstate_eci_2 = bh.state_ecef_to_eci(epoch, state_ecef)\nprint(f\"Recovered ECI Coordinates: {state_eci_2}\")\n# Outputs:\n# Recovered ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Convert back from ECI to Keplerian elements\nstate_kep_2 = bh.state_eci_to_koe(state_eci_2, bh.AngleFormat.DEGREES)\nprint(f\"Recovered Keplerian Elements: {state_kep_2}\")\n# Outputs:\n# Recovered Keplerian Elements: [7.0781363e+06 1.0000000e-03 9.8700000e+01 1.5000000e+01 3.0000000e+01 4.5000000e+01]\n</code></pre> Propagating an Orbit: <pre><code>import numpy as np\nimport brahe as bh\n\n# Define the initial Keplerian elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis: 700 km altitude\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in degrees\nraan = 15.0  # Right Ascension of Ascending Node in degrees\nargp = 30.0  # Argument of Perigee in degrees\nmean_anomaly = 75.0  # Mean Anomaly at epoch in degrees\n\ninitial_state = np.array([a, e, i, raan, argp, mean_anomaly])\n\n# Define the epoch time\nepoch = bh.Epoch.now()\n\n# Create the Keplerian Orbit Propagator\ndt = 60.0  # Time step in seconds\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, initial_state, bh.AngleFormat.DEGREES, dt\n)\n\n# Propagate the orbit for 3 time steps\npropagator.propagate_steps(3)\n\n# States are stored as a Trajectory object\nassert len(propagator.trajectory) == 4  # Initial state + 3 propagated states\n\n# Convert trajectory to ECI coordinates\neci_trajectory = propagator.trajectory.to_eci()\n\n# Iterate over all stored states\nfor epoch, state in eci_trajectory:\n    print(\n        f\"Epoch: {epoch}, Position (ECI): {state[0] / 1e3:.2f} km, {state[1] / 1e3:.2f} km, {state[2] / 1e3:.2f} km\"\n    )\n\n# Output:\n# Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n# Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n# Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n# Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n# Propagate for 7 days\nend_epoch = epoch + 86400 * 7  # 7 days later\npropagator.propagate_to(end_epoch)\n\n# Confirm the final epoch is as expected\nassert abs(propagator.current_epoch - end_epoch) &lt; 1e-6\nprint(\"Propagation complete. Final epoch:\", propagator.current_epoch)\n# Output:\n# Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>import brahe as bh\n\n# Initialize EOP\nbh.initialize_eop()\n\n# Set the location\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\n\n# Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\npropagator = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n\n# Configure Search Window\nepoch_start = bh.Epoch.now()\nepoch_end = epoch_start + 7 * 86400.0  # 7 days later\n\n# Set access constraints -&gt; Must be above 10 degrees elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(location, propagator, epoch_start, epoch_end, constraint)\n\nassert len(windows) &gt; 0, \"Should find at least one access window\"\n\n# Print first 3 access windows\nfor window in windows[:3]:\n    print(\n        f\"Access Window: {window.window_open} to {window.window_close}, Duration: {window.duration / 60:.2f} minutes\"\n    )\n# Outputs:\n# Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n# Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n# Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n</code></pre></p>"},{"location":"index.html#rust","title":"Rust","text":"<p>To use brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre> <p>You can then use the crate in your rust code with:</p> <pre><code>use brahe as bh;\n</code></pre> <p>And still calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>use brahe::{R_EARTH, orbital_period};\n\nfn main() {\n    // Define the semi-major axis of a low Earth orbit (in meters)\n    let semi_major_axis = R_EARTH + 400e3; // 400 km altitude\n\n    // Calculate the orbital period\n    let period = orbital_period(semi_major_axis); \n\n    println!(\"Orbital Period: {:.2} minutes\", period / 60.0);\n    // Outputs:\n    // Orbital Period: 92.56 minutes\n}\n</code></pre> <p>You can do everything that you can do in Python in Rust as well:</p> <p>Working with Time: <pre><code>use brahe::{Epoch, TimeSystem};\n\nfn main() {\n    // Create an epoch from a specific date and time\n    let epc = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Print as ISO 8601 string\n    println!(\"Epoch in UTC: {}\", epc.isostring());\n    // Output:\n    // Epoch in UTC: 2024-01-01T12:00:00Z\n\n    // Get the Modified Julian Date (MJD) in different time systems\n    let mjd_tai = epc.mjd_as_time_system(TimeSystem::TAI);\n    println!(\"MJD in TAI: {}\", mjd_tai);\n    // Output:\n    // MJD in TAI: 60310.50042824074\n\n    // Get the time as a Julian Date (JD) in GPS time system\n    let jd_gps = epc.jd_as_time_system(TimeSystem::GPS);\n    println!(\"JD in GPS: {}\", jd_gps);\n    // Output:\n    // JD in GPS: 2460311.000208333\n\n    // Take the difference between two epochs in different time systems\n    let epc2 = Epoch::from_datetime(2024, 1, 2, 13, 30, 0.0, 0.0, TimeSystem::GPS);\n    let delta_seconds = epc2 - epc;\n    println!(\"Difference between epochs in seconds: {}\", delta_seconds);\n    // Output:\n    // Difference between epochs in seconds: 91782.0\n\n    // Get the epoch as a string in different time systems\n    let epc_utc = epc2.to_string_as_time_system(TimeSystem::UTC);\n    println!(\"Epoch in GPS: {}\", epc2);\n    println!(\"Epoch in UTC: {}\", epc_utc);\n    // Outputs:\n    // Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n    // Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n}\n</code></pre></p> <p>Coordinate Transformations: <pre><code>use brahe as bh;\nuse brahe::{Epoch, TimeSystem, R_EARTH, state_koe_to_eci,\n            state_eci_to_ecef, state_ecef_to_eci, state_eci_to_koe, AngleFormat};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements\n    let a = R_EARTH + 700e3;    // Semi-major axis in meters (700 km altitude)\n    let e = 0.001;              // Eccentricity\n    let i = 98.7;               // Inclination in degrees\n    let raan = 15.0;            // Right Ascension of Ascending Node in degrees\n    let arg_periapsis = 30.0;   // Argument of Periapsis in degrees\n    let mean_anomaly = 45.0;    // Mean Anomaly in degrees\n\n    // Create a state vector from orbital elements\n    let state_kep = Vector6::new(a, e, i, raan, arg_periapsis, mean_anomaly);\n\n    // Convert Keplerian state to ECI coordinates\n    let state_eci = state_koe_to_eci(state_kep, AngleFormat::Degrees);\n    println!(\"ECI Coordinates: {:?}\", state_eci);\n    // Outputs:\n    // ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Define a time epoch\n    let epoch = Epoch::from_datetime(2024, 6, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Convert ECI coordinates to ECEF coordinates at the given epoch\n    let state_ecef = state_eci_to_ecef(epoch, state_eci);\n    println!(\"ECEF Coordinates: {:?}\", state_ecef);\n    // Outputs:\n    // ECEF Coordinates: [186480.17260881448, -2070225.9929370368, 6760815.482882127, -4538.863726757974, 5777.023453395301, 1899.7320274086795]\n\n    // Convert back from ECEF to ECI coordinates\n    let state_eci_2 = state_ecef_to_eci(epoch, state_ecef);\n    println!(\"Recovered ECI Coordinates: {:?}\", state_eci_2);\n    // Outputs:\n    // Recovered ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Convert back from ECI to Keplerian elements\n    let state_kep_2 = state_eci_to_koe(state_eci_2, AngleFormat::Degrees);\n    println!(\"Recovered Keplerian Elements: {:?}\", state_kep_2);\n    // Outputs:\n    // Recovered Keplerian Elements: [7078136.3, 0.001, 98.7, 15.0, 30.0, 45.0]\n}\n</code></pre></p> <p>Propagating an Orbit: <pre><code>use brahe as bh;\nuse brahe::{Epoch, R_EARTH, KeplerianPropagator, AngleFormat};\nuse brahe::traits::{SStatePropagator, Trajectory};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Define the initial Keplerian elements\n    let a = R_EARTH + 700e3;  // Semi-major axis: 700 km altitude\n    let e = 0.001;            // Eccentricity\n    let i = 98.7;             // Inclination in degrees\n    let raan = 15.0;          // Right Ascension of Ascending Node in degrees\n    let argp = 30.0;          // Argument of Perigee in degrees\n    let mean_anomaly = 75.0;  // Mean Anomaly at epoch in degrees\n\n    let initial_state = Vector6::new(a, e, i, raan, argp, mean_anomaly);\n\n    // Define the epoch time\n    let epoch = Epoch::now();\n\n    // Create the Keplerian Orbit Propagator\n    let dt = 60.0;  // Time step in seconds\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch,\n        initial_state,\n        AngleFormat::Degrees,\n        dt\n    );\n\n    // Propagate the orbit for 3 time steps\n    propagator.propagate_steps(3);\n\n    // States are stored as a Trajectory object\n    assert_eq!(propagator.trajectory.len(), 4);  // Initial state + 3 propagated states\n\n    // Convert trajectory to ECI coordinates\n    let eci_trajectory = propagator.trajectory.to_eci();\n\n    // Iterate over all stored states\n    for i in 0..eci_trajectory.len() {\n        let epoch = eci_trajectory.epochs[i];\n        let state = eci_trajectory.states[i].clone();\n        println!(\n            \"Epoch: {}, Position (ECI): {:.2} km, {:.2} km, {:.2} km\",\n            epoch,\n            state[0] / 1e3,\n            state[1] / 1e3,\n            state[2] / 1e3\n        );\n    }\n    // Output (will vary based on current time):\n    // Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n    // Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n    // Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n    // Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n    // Propagate for 7 days\n    let end_epoch = epoch + 86400.0 * 7.0;  // 7 days later\n    propagator.propagate_to(end_epoch);\n\n    // Confirm the final epoch is close to expected time\n    let time_diff = (propagator.current_epoch() - end_epoch).abs();\n    assert!(time_diff &lt; 1.0e-6, \"Final epoch should be within 1 second of target\");\n    println!(\"Propagation complete. Final epoch: {}\", propagator.current_epoch());\n    // Output (will vary based on current time):\n    // Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n}\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>use brahe as bh;\nuse brahe::{Epoch, PointLocation, ElevationConstraint, location_accesses};\nuse brahe::datasets::celestrak::get_tle_by_id_as_propagator;\nuse brahe::utils::Identifiable;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Set the location\n    let location = PointLocation::new(-122.4194, 37.7749, 0.0)\n        .with_name(\"San Francisco\");\n\n    // Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\n    let propagator = get_tle_by_id_as_propagator(25544, None, 60.0).unwrap();\n\n    // Configure Search Window\n    let epoch_start = Epoch::now();\n    let epoch_end = epoch_start + 7.0 * 86400.0;  // 7 days later\n\n    // Set access constraints -&gt; Must be above 10 degrees elevation\n    let constraint = ElevationConstraint::new(Some(10.0), None).unwrap();\n\n    // Compute access windows\n    let windows = location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None\n    ).unwrap();\n\n    assert!(!windows.is_empty(), \"Should find at least one access window\");\n\n    // Print first 3 access windows\n    for window in windows.iter().take(3) {\n        println!(\n            \"Access Window: {} to {}, Duration: {:.2} minutes\",\n            window.window_open,\n            window.window_close,\n            window.duration() / 60.0\n        );\n    }\n    // Outputs (will vary based on current time and ISS orbit):\n    // Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n    // Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n    // Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n}\n</code></pre></p>"},{"location":"changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog.html#030-2025-11-18","title":"[0.3.0] - 2025-11-18","text":""},{"location":"changelog.html#added","title":"Added","text":"<ul> <li> <ul> <li>Added <code>Integrators</code> submodule with complete rust implementation, python bindings, documentation, and examples</li> </ul> </li> <li>Support for <code>RK4</code>, <code>RKF45</code>, <code>DP54</code>, and <code>RKN1210</code> numerical integration methods</li> <li>License validation and compliance checks. Package is now automatically checked to ensure all dependencies have permissive, commercially-adoptable licenses #63</li> <li> <ul> <li>NAIF Development Ephemeride dataset download and caching</li> </ul> </li> <li>High-accuracy DE440s-based ephemeris prediction</li> <li>High-accuracy DE440s-based third-body acceleration prediction</li> <li>Python bindings for orbit dynamics functions #68</li> <li> <ul> <li>Added <code>geo_sma</code> function to directly return the semi-major axis needed for a geostationary orbit. #69</li> </ul> </li> </ul>"},{"location":"changelog.html#changed","title":"Changed","text":"<ul> <li> <ul> <li>Moved mathematics capabilities from <code>utils</code> submodule to dedicated <code>math</code> submodule.</li> </ul> </li> <li>Bumped version to <code>0.2.0</code> for release</li> <li>Removed Rust test sections from coverage reporting #63</li> <li> <ul> <li>Orbit dynamics functions which previously required a position-only vector can now accept either a position-only or a state vector. Conversion will be handled by the <code>IntoPosition</code> trait. #68</li> </ul> </li> </ul>"},{"location":"changelog.html#fixed","title":"Fixed","text":"<ul> <li> <ul> <li>Fix inconsistencies in Python API reference header levels</li> </ul> </li> <li>Missing Ground station</li> <li>Miscellaneous documentation improvements and fixes #63</li> </ul>"},{"location":"changelog.html#020-2025-11-17","title":"[0.2.0] - 2025-11-17","text":""},{"location":"changelog.html#added_1","title":"Added","text":"<ul> <li> <ul> <li>Added <code>relative_motion</code> submodule to contain functionality related to relative motion</li> </ul> </li> <li>Implemented RTN rotation and state transformations: <code>rotation_eci_to_rtn</code>, <code>rotation_rtn_to_eci</code>, <code>state_eci_to_rtn</code>, and <code>state_rtn_to_eci</code></li> <li>Implemented Relative Orbital Element (ROE) state transformations <code>state_oe_to_roe</code> and <code>state_roe_to_oe</code></li> <li>Added <code>util::math</code> functions <code>sqrtm</code> and <code>spd_sqrtm</code> to calculate matrix square root</li> <li>Added <code>util::math</code> functions <code>oe_to_radians</code> and <code>oe_to_degrees</code> to reduce duplication in converting angle values in orbital element calcualtions #57</li> <li> <ul> <li>Implement <code>CovarianceProvider</code> trait for <code>OrbitTrajectory</code>. Provides <code>covariance</code>, <code>covariance_eci</code>, <code>covariance_gcrf</code>, and <code>covariance_rtn</code></li> </ul> </li> <li>Add <code>interpolation</code> submodule to store consistent covariance interpolation methods</li> <li>Implement covariance rotation from ECI to RTN frame</li> <li>Extends <code>OrbitTrajectory</code> to optionally store covariance information. #59</li> </ul>"},{"location":"changelog.html#changed_1","title":"Changed","text":"<ul> <li> <ul> <li>Don't run PR tests on release CHANGELOG update. #49</li> </ul> </li> <li> <ul> <li>Unit test and PR test workflows now cancel in-progress runs if a new commit lands</li> </ul> </li> <li>Added concurrency guards to auto-merge workflows. #53</li> <li> <ul> <li>Moved where internal vector/matrix (e.g. <code>SMatrix3</code>, <code>SVector6</code>) type aliases are defined from <code>coordinates</code> submodule to <code>utils</code> #57</li> </ul> </li> </ul>"},{"location":"changelog.html#fixed_1","title":"Fixed","text":"<ul> <li> <ul> <li>Don't trigger multiple changelog merges on changelog a PR. #49</li> </ul> </li> <li> <ul> <li>Only trigger auto-merge on <code>opened</code> due to changelog PRs not issuing <code>labeled</code> events #51</li> </ul> </li> <li> <ul> <li>Added additional triggers to auto-merge workflows to ensure they are properly triggered. #53</li> </ul> </li> <li> <ul> <li>Fixed assorted typos and errors in docstrings related to covariance interpolation features. #61</li> </ul> </li> <li> <ul> <li>Fixes package-data update CI workflow by moving to auto-PR, auto-merge approach #64</li> </ul> </li> </ul>"},{"location":"changelog.html#013-2025-11-12","title":"[0.1.3] - 2025-11-12","text":""},{"location":"changelog.html#added_2","title":"Added","text":"<ul> <li> <ul> <li>Added python missing bindings for <code>states_icrf</code> and <code>states_gcrf</code> for <code>KeplerianPropagator</code> and <code>SGPPropagator</code></li> </ul> </li> <li>Added additional tests across various module to improve test coverage. #36</li> </ul>"},{"location":"changelog.html#changed_2","title":"Changed","text":"<ul> <li> <ul> <li>Refactor <code>frames.rs</code> file into submodule with subfiles for long-term maintainability. #14</li> </ul> </li> <li> <ul> <li>Automatically create and merge PRs for changelog updates #16</li> </ul> </li> <li> <ul> <li>Auto-merge changelog PRs</li> </ul> </li> <li>Auto-merge dependabot PRs</li> <li>Expand dependabot to cover python and rust packages #26</li> <li> <ul> <li>Bump package version to <code>v0.1.3</code> #34</li> </ul> </li> <li> <ul> <li>Skip unit test suite on auto-generated changelog PRs. #44</li> </ul> </li> </ul>"},{"location":"changelog.html#fixed_2","title":"Fixed","text":"<ul> <li> <ul> <li>PR changelogs were not being incorporated into the package changelog due to main-branch protection #16</li> </ul> </li> <li> <ul> <li>Stop generation changelog PRs for auto-generated changelog PRs #26</li> </ul> </li> <li> <ul> <li>Fixed issue with release pipeline release note generation #38</li> </ul> </li> <li> <ul> <li>Fix auto-merge for changelog PRs by using PAT #40</li> </ul> </li> <li> <ul> <li>Fix auto-merge workflow to accept PAT owner as actor. #42</li> </ul> </li> <li> <ul> <li>Fix workflow release step to use workflow PAT and declare base branch #46</li> </ul> </li> </ul>"},{"location":"code_of_conduct.html","title":"Code of Conduct","text":"<p>Note</p> <p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0.</p>"},{"location":"code_of_conduct.html#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>Space has inspired us and continues to inspire the whole world. We are building software to help everyone on this planet explore the universe - regardless of race, creed, or any other distinction. We encourage you to bring your unique perspective to help make us stronger, including those who are traditionally underrepresented in tech. We seek to build a highly collaborative, respectful, inclusive, and curious community. We appreciate contributions from everyone, no prior space experience is needed to participate. We joyously welcome everyone who is excited about tackling seemingly impossible challenges, learning new skills and concepts, and helping each other achieve success.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"code_of_conduct.html#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"code_of_conduct.html#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, directly contact the repository owner, maintainers, or community moderators at: <code>duncan [send-email-symbol] argoinnovations.com</code>.</p> <p>We take reports of violations seriously and will make every effort to respond in a timely manner. We will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. We prioritize safety and confidentiality, while also trying to keep enforcement actions as transparent as possible. In order to honor these values, enforcement actions are carried out in private with the involved parties, but reserve the right to publicly share the outcome of enforcement actions when appropriate for the safety and well-being of the community as a whole.</p>"},{"location":"code_of_conduct.html#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"code_of_conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p>"},{"location":"contributing.html","title":"Contributing to Brahe","text":"<p>Thank you for your interest in contributing to Brahe! We welcome contributions from everyone\u2014whether you're improving documentation, fixing bugs, or adding new features. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p> <p>Checkout the main documentation for the Contributing Guidelines and Code of Conduct.</p>"},{"location":"contributing.html#how-you-can-contribute","title":"How you can contribute","text":"<p>You can contribute in many ways, including: - Reporting bugs or issues. - Suggesting enhancements or new features. - Writing or improving documentation or tutorials. - Adding or improving tests. - Reviewing other contributors\u2019 pull requests.</p>"},{"location":"contributing.html#getting-started","title":"Getting Started","text":"<p>First, check out the development guidelines in the developer guidelines for setting up your development environment, running tests, and the development workflow for implementing new features or fixing bugs.</p>"},{"location":"contributing.html#workflow","title":"Workflow","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally: <code>git clone https://github.com/YOUR_USERNAME/brahe.git</code></li> <li>Create a new branch for your changes: <code>git checkout -b feature/your-feature-name</code></li> <li>Make your changes and commit them with clear, descriptive messages.</li> <li>Push your changes to your fork: <code>git push origin feature/your-feature-name</code></li> <li>Open a pull request against the main branch of the upstream repository.</li> <li>A maintainer will review your contribution; you may be asked to make changes.</li> <li>After approval and CI passing, your pull request will be merged.</li> </ol>"},{"location":"contributing.html#code-style-testing","title":"Code Style &amp; Testing","text":"<ul> <li>Follow the project\u2019s style guidelines (e.g., linting, formatting).</li> <li>Include tests for new functionality, and ensure existing tests pass.</li> <li>Ensure that your changes do not break existing behaviour unless they are intentional, documented, well-motivated, complete, and reviewed. We don't break things without a solution.</li> </ul>"},{"location":"contributing.html#communication-etiquette","title":"Communication &amp; Etiquette","text":"<ul> <li>Please review the Code of Conduct to understand the expected behaviour in our community.</li> <li>If you\u2019re planning a large or complex change, consider opening an issue first to discuss design and get early feedback.</li> <li>Be responsive to review comments. If you need time, it\u2019s okay to say so.</li> <li>Respect the maintainers\u2019 decision. If they decline your change, you\u2019re free to discuss politely or move on.</li> </ul>"},{"location":"contributing.html#license-rights","title":"License &amp; Rights","text":"<p>By submitting a pull request, you agree that your contribution will be available under the project's MIT License and you grant the maintainers the right to apply any necessary changes (e.g., rebase, squash) before merging.</p>"},{"location":"contributing.html#thank-you","title":"Thank You","text":"<p>We appreciate your interest and contribution. Together we build something better!</p>"},{"location":"development_guide.html","title":"Development Guide","text":""},{"location":"development_guide.html#development-workflow","title":"Development Workflow","text":"<p>For all development we recommend using uv to manage your environment. The guidelines for contributing, developing, and extending brahe assume you are using uv.</p>"},{"location":"development_guide.html#setting-up-your-environment","title":"Setting up your environment","text":"<p>If you need to setup the development environment, including installing the necessary development dependencies.</p> <p>First, you need to install Rust from rustup.rs.</p> <p>Then you can install the nightly toolchain with:</p> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <p>After this you can now setup your python environment with:</p> <pre><code>uv sync --dev\n</code></pre> <p>Finally, you can install the pre-commit hooks with:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"development_guide.html#testing","title":"Testing","text":"<p>The package includes Rust tests, Python tests, and documentation example tests.</p> <pre><code># Run Rust tests\ncargo test\n# Run Python tests\nuv pip install -e \".[all]\" &amp;&amp; uv run pytest\n# Run documentation examples\nuv run make.py test-examples\n# Test specific example\nuv run make.py test-example &lt;example_name&gt; # Can just be the file name without extension, e.g. impulsive_maneuver or impulsive_maneuver.py\n</code></pre>"},{"location":"development_guide.html#development-workflow-implementing-a-new-feature","title":"Development Workflow: Implementing a New Feature","text":"<p>When adding new functionality to Brahe, follow this sequence:</p> <p>1. Rust Implementation - Implement functionality in the appropriate module under <code>src/</code> - Use SI base units (meters, seconds) in all public APIs - Follow existing patterns and naming conventions</p> <p>2. Rust Tests - Write comprehensive unit tests in the same file (in a <code>#[cfg(test)] mod tests {}</code> module) - Test edge cases and typical use cases - Run: <code>cargo test</code> - Ensure all tests pass before proceeding</p> <p>3. Python Bindings - Create 1:1 Python bindings in <code>src/pymodule/</code> - Use identical function names and parameter names as Rust - Add complete Google-style docstrings with Args, Returns, Examples - Export new classes in <code>src/pymodule/mod.rs</code> - Export in Python package (<code>brahe/*.py</code> files) - Reinstall: <code>uv pip install -e .</code></p> <p>4. Python Tests - Write Python tests that mirror Rust tests in <code>tests/</code> - Follow the same test structure and assertions - Run: <code>uv run pytest tests/ -v</code></p> <p>5. Documentation Examples - Create standalone example files in <code>examples/&lt;module&gt;/</code> - Create both Python and Rust versions (see templates below) - Test: <code>uv run make.py test-examples</code></p> <p>6. Documentation - Update or create documentation in <code>docs/</code> - Reference examples using snippet includes (see template below) - Build Locally: <code>uv run mkdocs serve</code></p> <p>7. Final Checks <pre><code># Formatting\ncargo fmt\nruff check --fix\nruff format\n# Tests\ncargo test\nuv pip install -e \".[all]\" &amp;&amp; ./scripts/generate_stubs.sh &amp;&amp; uv run pytest\n# Documentation\nuv run test-examples\nuv run make-plots\nuv run mkdocs build --strict\nuv run mkdocs serve\n</code></pre></p>"},{"location":"development_guide.html#rust-standards-and-guidelines","title":"Rust Standards and Guidelines","text":""},{"location":"development_guide.html#rust-testing-conventions","title":"Rust Testing Conventions","text":"<p>New functions implemented in rust are expected to have unit tests and documentation tests. Unit tests should cover all edge cases and typical use cases for the function. Documentation tests should provide examples of how to use the function.</p> <p>Unit tests should be placed in the same file as the function they are testing, in a module named <code>tests</code>. The names of tests should follow the general convention of <code>test_&lt;struct&gt;_&lt;trait&gt;_&lt;method&gt;_&lt;case&gt;</code> or <code>test_&lt;function&gt;_&lt;case&gt;</code>.</p>"},{"location":"development_guide.html#rust-docstring-template","title":"Rust Docstring Template","text":"<p>New functions implemented in rust are expected to use the following docstring to standardize information on functions to enable users to more easily navigate and learn the library.</p> <pre><code>{{ Function Description }}\n\n## Arguments\n\n* `argument_name`: {{ Arugment description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Returns\n\n* `value_name`: {{ Value description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Examples\n\\`\\`\\`\n{{ Implement shor function in language }}\n\\`\\`\\`\n\n## References:\n1. {{ author, *title/journal*, pp. page_number, eq. equation_number, year}}\n2. O. Montenbruck, and E. Gill, *Satellite Orbits: Models, Methods and Applications*, pp. 24, eq. 2.43 &amp; 2.44, 2012.\n</code></pre>"},{"location":"development_guide.html#python-standards-and-guidelines","title":"Python Standards and Guidelines","text":""},{"location":"development_guide.html#python-testing-conventions","title":"Python Testing Conventions","text":"<p>Python tests should be placed in the <code>tests</code> directory. The test structure and names should mirror the structure of the <code>brahe</code> package. For example, tests for <code>brahe.orbits.keplerian</code> should be placed in <code>tests/orbits/test_keplerian.py</code>.</p> <p>All Python tests should be exact mirrors of the Rust tests, ensuring that both implementations are equivalent and consistent. There are a few exceptions to this rule, such as tests that check for Python-specific functionality or behavior, or capabilities that are not possible to reproduce in Python due to language limitations.</p>"},{"location":"development_guide.html#documentation-examples","title":"Documentation Examples","text":"<p>Documentation examples are standalone executable files that demonstrate library functionality. Every example must exist in both Python and Rust versions to ensure API parity.</p>"},{"location":"development_guide.html#example-file-structure","title":"Example File Structure","text":"<p>Examples are organized by module in <code>examples/</code>: <pre><code>examples/\n\u251c\u2500\u2500 time/           # Time system examples\n\u251c\u2500\u2500 orbits/         # Orbital mechanics examples\n\u251c\u2500\u2500 coordinates/    # Coordinate transformation examples\n\u251c\u2500\u2500 frames/         # Reference frame examples\n\u251c\u2500\u2500 attitude/       # Attitude representation examples\n\u251c\u2500\u2500 eop/            # Earth orientation parameter examples\n\u251c\u2500\u2500 trajectories/   # Trajectory examples\n\u2514\u2500\u2500 workflows/      # Complete workflow examples\n</code></pre></p>"},{"location":"development_guide.html#naming-convention","title":"Naming Convention","text":"<p>Example files should follow this pattern: <pre><code>&lt;module&gt;_&lt;functionality&gt;_&lt;description&gt;.{py,rs}\n</code></pre></p> <p>Examples: - <code>time_epoch_creation.py</code> / <code>time_epoch_creation.rs</code> - <code>orbits_keplerian_conversion.py</code> / <code>orbits_keplerian_conversion.rs</code> - <code>coordinates_geodetic_transform.py</code> / <code>coordinates_geodetic_transform.rs</code></p>"},{"location":"development_guide.html#python-example-template","title":"Python Example Template","text":"<p>See <code>examples/TEMPLATE.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"pytest\"]\n# ///\n\"\"\"\nBrief description of what this example demonstrates.\n\"\"\"\nimport brahe as bh\nimport pytest\n\nif __name__ == '__main__':\n    # Setup: Define any input parameters\n    value = 1.0\n\n    # Action: Demonstrate the functionality\n    result = value * 2.0  # Replace with actual brahe function call\n\n    # Validation: Assert the result is correct\n    expected = 2.0\n    assert result == pytest.approx(expected, abs=1e-10)\n\n    print(\"\u2713 Example validated successfully!\")\n</code></pre> <p>Note: The <code># /// script</code> header makes this a uv script, allowing it to be run standalone with <code>uv run example.py</code>.</p>"},{"location":"development_guide.html#rust-example-template","title":"Rust Example Template","text":"<p>See <code>examples/TEMPLATE.rs</code>:</p> <pre><code>//! Brief description of what this example demonstrates.\n\nuse approx::assert_abs_diff_eq;\nuse brahe::time::{Epoch, TimeSystem};\n\nfn main() {\n    // Setup: Define any input parameters\n    let value = 1.0;\n\n    // Action: Demonstrate the functionality\n    let result = value * 2.0; // Replace with actual brahe function call\n\n    // Validation: Assert the result is correct\n    let expected = 2.0;\n    assert_abs_diff_eq!(result, expected, epsilon = 1e-10);\n\n    println!(\"\u2713 Example validated successfully!\");\n}\n</code></pre>"},{"location":"development_guide.html#testing-examples","title":"Testing Examples","text":"<p>Test examples locally: <pre><code>uv run make.py test-examples\n</code></pre></p> <p>The build system will: 1. Execute all <code>.rs</code> files via <code>rust-script</code> 2. Execute all <code>.py</code> files via <code>uv run python</code> 3. Verify every <code>.rs</code> has a matching <code>.py</code> (and vice versa) 4. Report pass/fail for each example</p>"},{"location":"development_guide.html#including-examples-in-documentation","title":"Including Examples in Documentation","text":"<p>Use the <code>pymdownx.snippets</code> directive to include examples in markdown files. See the snippets plugin documentation for additional details on usage.</p> <pre><code>## Example: Creating Epochs\n\n=== \"Python\"\n\n    ``` python\n    ```\n\n=== \"Rust\"\n\n    ``` rust\n    ```\n</code></pre> <p>This will: - Create tabbed interface with Python shown first - Include the actual file contents (always in sync) - Automatically update when examples change</p>"},{"location":"development_guide.html#documentation-plots","title":"Documentation Plots","text":"<p>Interactive plots are generated from Python scripts in <code>plots/</code> and embedded in documentation.</p>"},{"location":"development_guide.html#plot-naming-convention","title":"Plot Naming Convention","text":"<p>Plot files should follow this pattern: <pre><code>fig_&lt;description&gt;.py\n</code></pre></p> <p>Examples: - <code>fig_time_system_offsets.py</code> - <code>fig_orbital_period.py</code> - <code>fig_anomaly_conversions.py</code></p>"},{"location":"development_guide.html#plot-template","title":"Plot Template","text":"<p>See <code>plots/TEMPLATE_plot.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# ///\n\"\"\"\nBrief description of what this plot visualizes.\n\"\"\"\nimport os\nimport pathlib\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport brahe as bh\nimport numpy as np\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\")\nOUTFILE = f\"{OUTDIR}/{SCRIPT_NAME}.html\"\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Replace with actual data\n\n# Create figure\nfig = go.Figure()\nfig.update_layout(\n    title=\"Plot Title\",\n    xaxis_title=\"X Axis Label\",\n    yaxis_title=\"Y Axis Label\",\n    paper_bgcolor='rgba(0,0,0,0)',  # Transparent for dark mode\n    plot_bgcolor='rgba(0,0,0,0)'\n)\n\n# Add traces\nfig.add_trace(go.Scatter(x=x, y=y, name=\"Data\", mode='lines'))\n\n# Write HTML (partial, not full page)\npio.write_html(\n    fig,\n    file=OUTFILE,\n    include_plotlyjs='cdn',\n    full_html=False,\n    auto_play=False\n)\n\nprint(f\"\u2713 Generated {OUTFILE}\")\n</code></pre> <p>Note: The <code># /// script</code> header allows standalone execution with <code>uv run fig_plot.py</code>.</p>"},{"location":"development_guide.html#generating-plots","title":"Generating Plots","text":"<p>Generate all plots: <pre><code>uv run make.py make-plots\n</code></pre></p> <p>Plots are written to <code>docs/figures/</code> as partial HTML files for embedding.</p>"},{"location":"development_guide.html#including-plots-in-documentation","title":"Including Plots in Documentation","text":"<pre><code>## Time System Offsets\n\nThe following plot shows time system offsets from UTC:\n\n\n??? \"Plot Source\"\n\n    ``` python title=\"fig_time_system_offsets.py\"\n    ```\n</code></pre> <p>This will: - Embed the interactive Plotly plot - Add a collapsible section showing the source code</p>"},{"location":"development_guide.html#pull-request-changelog","title":"Pull Request Changelog","text":""},{"location":"development_guide.html#automatic-changelog-generation","title":"Automatic Changelog Generation","text":"<p>When you create a pull request, you must fill in the changelog section in the PR description. The changelog uses Keep a Changelog format with four categories:</p> <ul> <li>Added - New features</li> <li>Changed - Changes to existing functionality</li> <li>Fixed - Bug fixes</li> <li>Removed - Removed features or functionality</li> </ul>"},{"location":"development_guide.html#how-it-works","title":"How It Works","text":"<ol> <li> <p>Fill in PR description: When opening a PR, add entries under the appropriate changelog section(s)    <pre><code>### Fixed\n- Fixed memory leak in trajectory interpolation\n- Corrected EOP data loading for edge cases\n</code></pre></p> </li> <li> <p>Validation: A GitHub Action checks that at least one changelog section has entries</p> </li> <li>PR will fail validation if all sections are empty</li> <li> <p>You'll receive a comment with instructions if validation fails</p> </li> <li> <p>Automatic fragment creation: When the PR is merged:</p> </li> <li>A GitHub Action parses your changelog entries</li> <li>Creates fragment files in <code>news/</code> directory (e.g., <code>123.added.md</code>, <code>123.fixed.md</code>)</li> <li> <p>Commits the fragments to the main branch</p> </li> <li> <p>Release compilation: During release:</p> </li> <li>Towncrier collects all fragments from <code>news/</code></li> <li>Generates formatted release notes</li> <li>Updates <code>CHANGELOG.md</code> with the new version section</li> <li>Deletes fragment files</li> </ol>"},{"location":"development_guide.html#example-pr-changelog","title":"Example PR Changelog","text":"<pre><code>## Changelog\n\n### Added\n- Support for new SGP4 propagation mode\n- EOP data caching to improve performance\n\n### Fixed\n- Memory leak in trajectory interpolation\n- Edge case in geodetic coordinate conversion\n</code></pre> <p>This will automatically create: - <code>news/123.added.md</code> with both Added items - <code>news/123.fixed.md</code> with both Fixed items</p>"},{"location":"development_guide.html#manual-fragment-creation-rare","title":"Manual Fragment Creation (Rare)","text":"<p>In rare cases where you need to create fragments manually, see <code>news/README.md</code> for instructions. Fragment files use the format <code>&lt;PR#&gt;.&lt;type&gt;.md</code> where type is one of: <code>added</code>, <code>changed</code>, <code>fixed</code>, <code>removed</code>.</p>"},{"location":"development_guide.html#previewing-the-changelog","title":"Previewing the Changelog","text":"<p>To see what changelog fragments are currently queued:</p> <pre><code># List all fragment files\nls -la news/*.md\n\n# Or see just the fragment names\nfind news/ -name '*.md' ! -name '.template.md' ! -name 'README.md'\n</code></pre> <p>To see what the next release changelog would look like without making changes:</p> <pre><code># Preview the changelog for the next release\nuv run towncrier build --version 1.2.3 --draft\n</code></pre> <p>This shows the formatted output without modifying <code>CHANGELOG.md</code> or deleting fragments.</p>"},{"location":"development_guide.html#releases-without-changelog-fragments","title":"Releases Without Changelog Fragments","text":"<p>If you create a release when there are no changelog fragments in <code>news/</code>:</p> <ul> <li>The release workflow will succeed</li> <li>A minimal release will be created with \"No significant changes\"</li> <li>This is useful for releases that only contain dependency updates or internal changes</li> </ul>"},{"location":"development_guide.html#release-process","title":"Release Process","text":""},{"location":"development_guide.html#initiating-a-release","title":"Initiating a Release","text":"<p>Before creating a release:</p> <ol> <li> <p>Update version in <code>Cargo.toml</code>:    <pre><code># Edit version in Cargo.toml\nvim Cargo.toml  # Update version = \"1.2.3\"\n</code></pre></p> </li> <li> <p>Run quality checks:    <pre><code>ruff check &amp;&amp; cargo fmt -- --check &amp;&amp; cargo test &amp;&amp; uv pip install -e \".[all]\" &amp;&amp; uv run pytest &amp;&amp; uv run make.py test-examples &amp;&amp; uv run make.py make-plots &amp;&amp; uv run mkdocs build --strict\n</code></pre></p> </li> <li> <p>Push version tag:    <pre><code>git add Cargo.toml\ngit commit -m \"Prepare release v1.2.3\"\ngit push origin main\ngit tag v1.2.3\ngit push origin v1.2.3\n</code></pre></p> </li> </ol>"},{"location":"development_guide.html#automated-workflow","title":"Automated Workflow","text":"<p>Note: Changelog fragments are automatically created from PR descriptions. You don't need to manually create fragment files.</p> <p>Once the tag is pushed, GitHub Actions automatically:</p> <ol> <li>Validates version matches between tag and <code>Cargo.toml</code></li> <li>Runs all tests (Rust, Python, examples)</li> <li>Generates release notes with towncrier (commits CHANGELOG.md)</li> <li>Builds documentation and deploys to GitHub Pages</li> <li>Builds Python wheels and source distribution</li> <li>Publishes to PyPI and crates.io</li> <li>Creates draft GitHub Release with artifacts and release notes</li> <li>Updates \"latest\" tag and release</li> </ol>"},{"location":"development_guide.html#completing-the-release","title":"Completing the Release","text":"<p>After automation completes:</p> <ol> <li>Review draft release at <code>https://github.com/duncaneddy/brahe/releases</code></li> <li>Edit release notes (optional):</li> <li>Add highlights or breaking changes</li> <li>Include migration notes if needed</li> <li>Publish release by clicking \"Publish release\"</li> </ol>"},{"location":"development_guide.html#verification","title":"Verification","text":"<p>After publishing, verify:</p> <ul> <li>PyPI: https://pypi.org/project/brahe/</li> <li>Crates.io: https://crates.io/crates/brahe</li> <li>Docs: https://duncaneddy.github.io/brahe/latest/</li> <li>GitHub: https://github.com/duncaneddy/brahe/releases</li> </ul>"},{"location":"installation.html","title":"Installation","text":"<p>Brahe is available for both Python and Rust. Choose the installation method that best fits your workflow.</p>"},{"location":"installation.html#python-installation","title":"Python Installation","text":""},{"location":"installation.html#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>The simplest way to install Brahe is using pip from PyPI:</p> <pre><code>pip install brahe\n</code></pre> <p>This will install the latest stable release of Brahe and all required dependencies.</p>"},{"location":"installation.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Brahe includes optional dependencies for enhanced plotting capabilities:</p> <pre><code># Install with scienceplots for publication-quality plots\npip install brahe[plots]\n</code></pre>"},{"location":"installation.html#using-uv-fast-alternative","title":"Using uv (Fast Alternative)","text":"<p>uv is a fast Python package installer. To install Brahe with uv:</p> <pre><code># Install brahe\nuv pip install brahe\n\n# Or with optional plot dependencies\nuv pip install \"brahe[plots]\"\n</code></pre>"},{"location":"installation.html#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that Brahe is working correctly:</p> <pre><code>import brahe as bh\nprint(bh.__version__)\n\n# Test basic functionality\na = bh.R_EARTH + 500e3  # Semi-major axis for 500 km altitude\nT = bh.orbital_period(a)\nprint(f\"Orbital period: {T/60:.2f} minutes\")\n</code></pre>"},{"location":"installation.html#building-from-source-python","title":"Building from Source (Python)","text":"<p>If you want to build Brahe from source (e.g., for development or to use unreleased features), follow these steps:</p>"},{"location":"installation.html#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Rust toolchain (required for building the native extensions):    <pre><code># Install Rust using rustup\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Follow the prompts, then restart your shell\n# Verify installation\nrustc --version\ncargo --version\n</code></pre></p> </li> <li> <p>Configure Rust to Use Nightly:    <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre></p> </li> <li> <p>Python 3.10+ with development headers:    <pre><code># On Ubuntu/Debian\nsudo apt-get install python3-dev\n\n# On macOS (usually included with Python)\n# On Windows, ensure you have Python from python.org\n</code></pre></p> </li> </ol>"},{"location":"installation.html#building-with-uv-recommended","title":"Building with uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Install uv if you haven't already\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Sync dependencies and create virtual environment\nuv sync\n\n# Build and install in editable mode\nuv pip install -e .\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre>"},{"location":"installation.html#building-with-pip-and-maturin","title":"Building with pip and maturin","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Create and activate a virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n\n# Install maturin (the build tool for PyO3)\npip install maturin\n\n# Build and install in development mode\nmaturin develop --release\n\n# Or install normally\npip install -e .\n</code></pre>"},{"location":"installation.html#development-installation","title":"Development Installation","text":"<p>For development work, install with development dependencies:</p> <pre><code># With uv\nuv sync --dev\n\n# With pip\npip install -e \".[dev]\"\n</code></pre> <p>This includes tools for: - Testing (pytest, pytest-cov) - Documentation (mkdocs, mkdocstrings) - Code quality (ruff, pre-commit) - Type stubs generation (pyo3-stubgen)</p>"},{"location":"installation.html#running-tests","title":"Running Tests","text":"<p>After building from source, verify everything works:</p> <pre><code># Run Python tests\npytest tests/ -v\n\n# Run Rust tests\ncargo test\n\n# Run with code coverage\npytest tests/ --cov=brahe --cov-report=html\n</code></pre>"},{"location":"installation.html#updating-type-stubs","title":"Updating Type Stubs","text":"<p>If you modify the Rust Python bindings, regenerate Python type stubs:</p> <pre><code>./scripts/generate_stubs.sh\n</code></pre>"},{"location":"installation.html#rust-installation","title":"Rust Installation","text":"<p>To use Brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre>"},{"location":"installation.html#building-the-rust-library","title":"Building the Rust Library","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Build the library\ncargo build\n\n# Run tests\ncargo test\n\n# Build documentation\ncargo doc --open\n</code></pre>"},{"location":"installation.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation.html#common-issues","title":"Common Issues","text":"<p>\"Failed to build wheel\" (Python) - Ensure Rust is installed: <code>rustc --version</code> - Update Rust: <code>rustup update</code> - Install Python development headers (see prerequisites above)</p> <p>Import errors after installation - Verify installation: <code>pip show brahe</code> - Check Python version: <code>python --version</code> (must be 3.10+) - Try reinstalling: <code>pip install --force-reinstall brahe</code></p> <p>Cartopy installation fails - On Ubuntu/Debian: <code>sudo apt-get install libgeos-dev</code> - On macOS: <code>brew install geos</code> - See Cartopy installation docs</p> <p>Type hints not working in IDE - Ensure type stubs are installed: <code>ls $(python -c \"import brahe; print(brahe.__path__[0])\")/_brahe.pyi</code> - If missing, regenerate: <code>./scripts/generate_stubs.sh</code> (from source installation)</p>"},{"location":"installation.html#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Review the documentation</li> <li>Open a new issue with:</li> <li>Your operating system and version</li> <li>Python/Rust version</li> <li>Complete error message</li> <li>Steps to reproduce</li> </ol>"},{"location":"installation.html#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation.html#macos","title":"macOS","text":"<p>On Apple Silicon (M1/M2/M3): - Brahe builds natively for ARM64 - Ensure you have the ARM64 version of Python</p>"},{"location":"installation.html#windows","title":"Windows","text":"<ul> <li>Install Microsoft C++ Build Tools</li> <li>Consider using WSL2 for a smoother development experience</li> </ul>"},{"location":"installation.html#linux","title":"Linux","text":"<p>Most distributions work out-of-the-box. If you encounter issues: - Install build essentials: <code>sudo apt-get install build-essential</code> - Ensure GEOS library is installed for Cartopy</p>"},{"location":"about/index.html","title":"About","text":"<p>About brahe --- its design, inspiration and where it's going.</p>"},{"location":"about/alternatives.html","title":"History and Inspiration","text":""},{"location":"about/alternatives.html#intro","title":"Intro","text":"<p>There have been many astrodynamics libraries developed over the years, each with its own strengths and weaknesses. Brahe draws inspiration from several of these projects while aiming to provide a unique combination of features, performance, and usability.</p>"},{"location":"about/alternatives.html#history","title":"History","text":"<p>The origins of Brahe started in 2014 when I first started graduate school at Stanford. At the time, I was working on a project that required high-fidelity orbit propagation and I found that high-fidelity tools were either inaccessible (proprietary, expensive, or both) or difficult to use (poor documentation, complex APIs). I wanted to create a tool that was both powerful and easy to use to make it easy for researchers and engineers to ask and answer questions they really cared about without needing to become experts in astrodynamics or software engineering themselves.</p> <p>As I changed organizations and projects over the years, I kept running into the same problem of a lack of open, permissively license, astrodynamics software. So when I joined a new organization I'd write a new astrodynamics library using the core algorithms and data structures in new languages to make astrodynamics accessible to those organizations. Through this process, I kept refinding my approach to the software design --- learning and improving with each iteration. </p> <p>When I returned to finish my PhD in 2019, I decided to take the best parts of these previous implementations and create a new library from scratch that would be open and accessible to all so that others wouldn't have to go through the same process of reinventing the wheel. In 2023 I began rewriting the library in Rust to take advantage of its performance, safety, and modern language features. The result is Brahe as it exists today.</p>"},{"location":"about/alternatives.html#inspirations-and-alternatives","title":"Inspirations and Alternatives","text":""},{"location":"about/alternatives.html#fastapi","title":"FastAPI","text":"<p>FastAPI isn't an astrodynamics library at all, but it is one of the primary inspirations for Brahe's design. FastAPI is a modern web framework for building APIs with Python. It is designed to be easy-to-use, high-performance, and scalable. I find it's design to be an elegant mix of minimalism and extensibility which makes it easy to get started with while still being powerful enough for complex applications.</p> <p>It's incredibly well documented and distributed through common package managers which makes it easy to install and integrate into new projects. It also has a strong focus on type hints and data validation which helps catch errors early and improves code readability. All of these design principles influenced Brahe's design.</p>"},{"location":"about/alternatives.html#pydantic","title":"Pydantic","text":"<p>Pydantic is another non-astrodynamics library that influenced Brahe's design. Pydantic is a data validation and settings management library for Python. It uses Python type hints to define data models and provides automatic validation and serialization of data.</p> <p>Pydantic uses a Rust core for performance with Python bindings which influenced my decision to use Rust for Brahe's core implementation. As with FastAPI, Pydantic is well-documented and distributed through common package managers which makes it easy to install and integrate into new projects.</p>"},{"location":"about/alternatives.html#stk-systems-tool-kit","title":"STK (Systems Tool Kit)","text":"<p>Systems Tool Kit (STK) is likely the most well-known commercial astrodynamics software package. It is extremely well validated and provides built-in visualization capabilities. It also supports a wide variety of use-cases and has workflows for built-in analysis. However, it is expensive and closed-source which limits its accessibility and extensibility.</p>"},{"location":"about/alternatives.html#freeflyer","title":"FreeFlyer","text":"<p>FreeFlyer is another commercial astrodynamics software package. It has been used for trajectory design and mission analysis for many high-profile space missions. It is also known for its scripting capabilities. a.i. Solutions generously provides free licenses for academic users. However it is closed-source which can limit its accessibility and extensibility.</p>"},{"location":"about/alternatives.html#orekit","title":"Orekit","text":"<p>Orekit is a popular open-source astrodynamics library written in Java. It provides a wide range of features, is well-validated, and well-documented. There are also Python bindings available through different wrappers, though all require a Java runtime.</p> <p>While Orekit is powerful, its Java foundation makes it difficult to integrate into modern Python scientific computing ecosystem. I also found that due to it's Java roots it uses many design patterns such as factory methods that can make it hard to figure out where in the codebase to look for certain functionality to understand how things work.</p> <p>I appreciate Orekit's permissive open-source licensing (Apache 2.0) which allows for both academic and commercial use, modification, and distribution, which influenced my decision to license Brahe under the MIT License.</p> <p>Inspiration</p> <p>Brahe's open-source permissive licensing was inspired in part by Orekit's approach to open-source software.</p>"},{"location":"about/alternatives.html#gmat-general-mission-analysis-tool","title":"GMAT (General Mission Analysis Tool)","text":"<p>GMAT is an open-source astrodynamics software package developed by NASA. It provides a wide range of features and is well-validated. It also provides a custom scripting language for mission design and analysis.</p> <p>GMAT documentation can be hard to find and navigate which made it hard for me to learn. It is also distributed as it's own standalone application, as opposed to a common library, which makes it difficult to integrate into new software.</p> <p>Inspiration</p> <p>GMAT is a wonderful example of open-source astrodynamics software that provides transparency into its algorithms and implementations.</p>"},{"location":"about/alternatives.html#poliastro","title":"poliastro","text":"<p>poliastro is an open-source astrodynamics library written in Python. It is designed to be easy-to-use and integrates well with the scientific Python ecosystem. It provides a wide range of features for orbit propagation, maneuver planning, and mission design. It is well-documented with many examples and tutorials, though is no longer actively maintained.</p> <p>Inspiration</p> <p>Brahe's Python plotting routines draw inspiration from poliastro's built-in plotting capabilities.</p>"},{"location":"about/alternatives.html#skyfield","title":"Skyfield","text":"<p>Skyfield is an excellent open-source library for high-precision astronomy and satellite tracking written in Python. It is designed to be easy-to-use and provides accurate calculations for positions of planets, stars, and satellites. It is well documented, with lots of examples and well-maintained.</p> <p>It primarily focuses on ephemeris calculations and star tracking for astronomy, but also supports satellite orbit propagation using two-line element (TLE) data.</p> <p>Inspiration</p> <p>Skyfield adopts a zen-of-python approach to its API design which influenced Brahe's Python API design. It prioritizes code readability and simplicity to make it easy for users to understand and use the library effectively.</p>"},{"location":"about/alternatives.html#nyx-space","title":"Nyx Space","text":"<p>Nyx Space is a modern astrodynamics library written in Rust with python bindings. It focuses on validation and verification of its algorithms and provides high-performance implementations of common astrodynamics tasks. It's general focus in on trajectory design and orbit determination for interplanetary missions, though it also supports Earth-orbiting missions as well.</p> <p>Nyx Space is licensed under an AGPLv3 license which requires derivative works to also be open-sourced under the same license, which can limit its use in commercial applications. Commercial licenses are available from Nyx Space for those who want to use it in closed-source applications.</p> <p>Inspiration</p> <p>Brahe's Rust implementation was inspired in part by Nyx Space's approach to using Rust for astrodynamics.</p> <p>Additionally Brahe uses the anise crate from the nyx ecosystem for working with NAIF SPICE kernels and ephemerides.</p>"},{"location":"about/alternatives.html#basilisk","title":"Basilisk","text":"<p>Basilisk is an open-source astrodynamics and spacecraft simulation framework developed by the Autonomous Vehicle Systems (AVS) Lab at the University of Colorado Boulder. It provides a modular architecture for simulating spacecraft dynamics, control systems, and mission scenarios though a component-based approach.</p> <p>Basilisk is primarily focused on spacecraft simulation and control system design, making it well-suited for simulating complex spacecraft missions with multiple interacting subsystems. However it is not distributed through common package managers which can make it difficult to integrate into new software projects.</p>"},{"location":"about/benchmarks.html","title":"Benchmarks","text":""},{"location":"about/benchmarks.html#benchmarks","title":"Benchmarks","text":"<p>While Brahe prioritizes usability and flexibility, it also aims to provide competitive performance for orbit propagation tasks and analysis.</p>"},{"location":"about/benchmarks.html#access-computation-benchmark","title":"Access Computation Benchmark","text":"<p>We benchmarked Brahe's orbit propagation and access computation performance against Skyfield, a popular Python library for satellite tracking and orbit propagation and access computation. The benchmark involved randomly sampling 100 different locations and computing all accesses between a satellite in low Earth orbit and ground stations over a 48-hour period.</p> <p>The access start and end times all agreed to within one second between Brahe and Skyfield, indicating consistent results to within the level of error of differing Earth orientation models used by each library.</p> <p>We tested five implementations:</p> <ol> <li>Skyfield - Popular Python astronomy library (baseline)</li> <li>Brahe-Python (serial) - Python bindings, one location per call</li> <li>Brahe-Python (parallel) - Python bindings, all locations in single call to leverage internal parallelization</li> <li>Brahe-Rust (serial) - Native Rust, one location per call</li> <li>Brahe-Rust (parallel) - Native Rust, all locations in single call to leverage internal parallelization</li> </ol> Implementation Avg Time vs Skyfield vs Brahe-Py-Serial Brahe-Rust (parallel) 1.37ms 3.2x faster 23.0x faster Brahe-Python (parallel) 2.40ms 1.8x faster 13.1x faster Brahe-Rust (serial) 2.79ms 1.6x faster 11.2x faster Skyfield 4.44ms baseline 7.1x faster Brahe-Python (serial) 31.41ms 7.1x slower baseline <p>Unsurprisingly, the parallel implementations significantly outperform their serial counterparts by leveraging multiple CPU cores to handle multiple ground station locations simultaneously. The Rust serial implementation still outperforms both the Skyfield and Brahe-Python serial implementations. Skyfield's performance is still impressive being only marginally slower than Brahe's serial Rust implementation despite being written in pure Python. These tests were run on a 2021 MacBook Pro with an Apple M1 Max chip and 64GB of RAM.</p> <p>You can reproduce these tests by running:</p> <pre><code>uv run scripts/benchmark_access_three_way.py --n-locations 100 --seed 42 --output chart.html --plot-style scatter --csv accesses.csv\n</code></pre>"},{"location":"about/design.html","title":"Design Philosophy &amp; Decisions","text":"<p>This page documents significant design decisions of the library. Right now this is mostly just what I think is \"good design\" for an astrodynamics library, which is highly subjective and somewhat hard to write down concretely. Over time I hope to expand this page to include more specific design decisions made in the library, along with the reasoning behind them.</p>"},{"location":"about/design.html#on-development-philosophy","title":"On Development Philosophy","text":"<p>I think the rv contributing guidelines express my philosophy well, so I am copying them here with minor modifications.</p> <p>Brahe originated out of a frustration with existing astrodynamics software. I wanted something that was easy to use, easy to install, and easy to extend. I wanted something that could help me solve the problems I cared about quickly. I wanted it to be succinct yet expressive, easy-to-use, yet performant. I wanted it to be fun. This is something I've been working on for over a decade of my life in one for or another, with all the learnings and opinions that come with that experience.</p> <p>All of this is to say, the ultimate goal of Brahe is to solve the problems I care about. If that means that others find it useful\u2014that's great! I'd love that it can also be useful to others and help them avoid the frustrations and problems I've had. I will gladly accept contributions that align with my vision and help improve Brahe in ways that I find valuable, but for now I reserve the right to steer the project in the direction that I find most compelling. Depending on how things go, am open to opening-up more decision-making to the community in the future.</p> <p>If you want to take things in a different direction, that's great! I encourage you to fork the project and build your own version that suits your needs. Part of my vision for Brahe is that it should be easy to extend and modify so that I'm not a single point of failure for the project.</p>"},{"location":"about/design.html#rust-core-with-python-bindings","title":"Rust Core with Python Bindings","text":"<p>The core of the library is implemented in Rust for performance and safety, with Python bindings provided for ease of use and accessibility to the Python community. This design choice allows us to leverage Rust's strengths while still providing a user-friendly interface in Python. Providing Python bindings also opens the library to a wider audience, as Python is a popular language in the scientific and engineering communities.</p>"},{"location":"about/design.html#tightly-coupled-documentation","title":"Tightly Coupled Documentation","text":"<p>The documentation is designed to be tightly coupled with the codebase, ensuring that users have access to up-to-date and relevant information. This is achieved by organizing the documentation in a way that mirrors the structure of the code, and automatically testing code examples within the documentation to ensure sure that documentation cannot be released without it working. This approach helps maintain consistency between the library's functionality and its documentation, making it easier for users to understand and utilize the library effectively.</p>"},{"location":"about/design.html#earth-centered-focus","title":"Earth-Centered Focus","text":"<p>Currently the library is focused on Earth-centered applications, while extending to other celestial bodies is not ruled out in the future, they are not a design priority. This choice has enabled us to optimize the design of the library API by dropping support for multiple central bodies, simplifying the user experience for the primary use case.</p>"},{"location":"about/design.html#do-the-rightest-thing","title":"Do the Rightest Thing","text":"<p>When faced with design decisions, I try to choose the option that feels like the \"rightest\" thing to do. This is generally what is the most common, most user-fiendly, or most extensible option. The goal is to make the library as easy to use and understand as possible, while still providing the necessary functionality and flexibility for advanced users.</p> <p>For example, when designing the API for propagators, we've taken an Earth-centered approach, simplifying the interface for the most common use case. It doesn't preclude future support for other central bodies, but it does make the main library easier to get up an running with for the majority of users.</p> <p>Another example is \"ECI\" and \"ECEF\" frame naming. While these are not strictly correct terms (they should be \"TEME\" and \"ITRF\"), they are much commonly used in the astrodynamics community, and so we've chosen to use them in the library to make it easier for users to understand and work with. They're currently backed by the GCRF and ITRF frames currently, but having the main functions use the common terminology makes it easier for users to get started with the library.</p>"},{"location":"about/design.html#s-type-and-d-type-structs","title":"S-Type and D-Type Structs","text":"<p>In Brahe, we distinguish between \"S-Type\" (Static) and \"D-Type\" (Dynamic) structs to clarify their intended usage and mutability. This is partially a knock-on effect from nalgebra's design and naming, but also reflects the reality of stack and heap allocation in programming. Brahe exposes both S-Type and D-Type structs, traits, and functions in Rust. In python however, only D-Type structs and functions are exposed, as Python's dynamic nature makes the distinction less relevant. By only having D-Type structs in Python, we simplify the API and make it easier for users to compose and manipulate objects without worrying about the underlying S-Type and D-Type distinctions.</p>"},{"location":"about/license.html","title":"License","text":"<p>Commercial Use and License Compatibility</p> <p>Brahe is permissively licensed under the MIT License to enable broad use and adoption in both open source and commercial projects. Additionally, we use cargo-deny to check all dependency licenses to ensure that they are compatible with Brahe's licensing and general commercial use.</p>"},{"location":"about/license.html#brahe-license","title":"Brahe License","text":"<pre><code>MIT License\n\nCopyright (c) 2019-2025 Duncan Eddy\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"about/license.html#additional-licenses","title":"Additional Licenses","text":""},{"location":"about/license.html#blue-marble-image","title":"Blue Marble Image","text":"<p>The Blue Marble images used in Brahe's plotting functions are provided by NASA and are in the public domain. For more information, visit the NASA Blue Marble website.</p>"},{"location":"about/license.html#natural-earth-data","title":"Natural Earth Data","text":"<p>Some map data used in Brahe's plotting functions is sourced from Natural Earth, which is available under the Public Domain. For more information, visit the Natural Earth website.</p>"},{"location":"about/license.html#fex-rkn1210","title":"FEX-RKN1210","text":"<p>The brahe implementation of the RKN1210 integrator is based on the code by Rody Oldenhuis, which is provided under the following BSD 2-Clause License:</p> <pre><code>Copyright (c) 2018, Rody Oldenhuis\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those\nof the authors and should not be interpreted as representing official policies,\neither expressed or implied, of this project.\n</code></pre> <p>The original FEX-RKN1210 code can be found here</p>"},{"location":"about/roadmap.html","title":"Roadmap","text":"<p>Here you can find an overview of planned features and improvements for Brahe aligned to releases. This roadmap is subject to change based on user feedback, development priorities, and other factors.</p>"},{"location":"about/roadmap.html#v010-overhaul-rust-migration","title":"v0.1.0 - Overhaul &amp; Rust Migration","text":"<p>This release completes the migration of the Brahe core library from Python to Rust, and matches capabilities with the previous pure-Python version. It also contains many new features, improvements to core functionality, and better documentation.</p> <ul> <li> Complete conversion to Rust core library</li> <li> Datasets Module<ul> <li> Celestrak</li> <li> Ground Stations</li> </ul> </li> <li> Trajectories Module<ul> <li> Core Traits</li> <li> Static Trajectory</li> <li> Dynamic Trajectory</li> </ul> </li> <li> Two Line Element Validation &amp; Parsing</li> <li> Propagators Module<ul> <li> StateProvider</li> <li> OrbitPropagator</li> <li> Keplerian Propagator</li> <li> SGP4 Propagator</li> </ul> </li> <li> Implement Access Computation<ul> <li> Access Constraints</li> <li> Access Properties</li> <li> Parallel Access Computation</li> </ul> </li> <li> Plotting Module<ul> <li> Ground Track Plots</li> <li> State Trajectory Plots</li> <li> 3D Orbit Plots</li> <li> Gabbard Plots</li> </ul> </li> <li> Documentation<ul> <li> Automatically compiled and checked code samples</li> <li> User Guide</li> <li> API Reference</li> <li> Examples</li> </ul> </li> <li> CI/CD Pipeline<ul> <li> Documentation-only fast releases</li> <li> MacOS testing and builds</li> <li> Windows testing and builds</li> <li> Automated latest release deployment</li> <li> Automated wheel builds</li> </ul> </li> <li> Package Quality<ul> <li> Add Code of Conduct</li> <li> Add Contributing Guide</li> </ul> </li> <li> Implement <code>Epoch.now()</code> initialization</li> <li> Caching Earth Orientation Parameters (EOP) data providers</li> <li> Add consistent package caching strategy for data files</li> </ul>"},{"location":"about/roadmap.html#v020-numerical-integration","title":"v0.2.0 - Numerical Integration","text":"<ul> <li> Additional Integrators<ul> <li> Fixed-step Runge-Kutta 4 (RK4)</li> <li> Adaptive-step Runge-Kutta-Fehlberg 4(5) (RKF45)</li> <li> Dormand-Prince 5(4) (DP54)</li> <li> Runge-Kutta-Nystr\u00f6m 12(10) (RKN1210)</li> </ul> </li> <li> State Transition Matrix (STM) propagation support</li> <li> Package Maintenance<ul> <li> Add <code>towncrier</code> for automated PR-request changelogs</li> </ul> </li> <li> Documentation for Numerical Integration Module</li> </ul>"},{"location":"about/roadmap.html#v030-orbital-perturbations","title":"v0.3.0 - Orbital Perturbations","text":"<ul> <li> Orbital Perturbations<ul> <li> Spherical Harmonic Gravity</li> <li> Third Body Gravity</li> <li> Atmospheric Drag</li> <li> Solar Radiation Pressure</li> <li> Relativity</li> <li> Eclipse Models</li> <li> Low-fidelity planetary ephemerides</li> <li> High-fidelity planetary ephemerides (JPL DE430)</li> </ul> </li> </ul>"},{"location":"about/roadmap.html#v040-numerical-orbit-propagation","title":"v0.4.0 - Numerical Orbit Propagation","text":"<ul> <li> Numerical Orbit Propagation Module<ul> <li> Control Input Support<ul> <li> Impulsive Maneuvers</li> <li> Continuous Thrust</li> </ul> </li> <li> Event Detection during Propagation</li> <li> Premade event detectors</li> </ul> </li> <li> General Numerical Propagation</li> <li> Documentation for Orbital Perturbations and Numerical Propagation</li> <li> Space Weather Data Management<ul> <li> Data provider classes<ul> <li> Static provider</li> <li> File provider</li> <li> Caching provider</li> </ul> </li> </ul> </li> <li> NRLMSISE-00 Atmospheric Model Integration</li> </ul>"},{"location":"about/roadmap.html#v100-stable-release-with-foundational-features","title":"v1.0.0 - Stable Release with Foundational Features","text":"<ul> <li> Numerical Propagators<ul> <li> User-defined Force Models</li> <li> Configurable Numerical propagator with default force models</li> </ul> </li> <li> Align with JOSS paper required release</li> <li> Improved Interpolation Methods for Trajectories<ul> <li> Lagrange Interpolation</li> <li> Hermite Interpolation</li> </ul> </li> <li> Mean Orbital Elements Support<ul> <li> Conversion between Mean and Osculating elements</li> </ul> </li> <li> Relative Orbits<ul> <li> Relative Orbit Representations<ul> <li> RTN Cartesian States</li> <li> Relative Orbital Elements</li> </ul> </li> <li> Cartesian to ROE Conversions</li> </ul> </li> <li> Walker Constellation Generator</li> </ul>"},{"location":"about/roadmap.html#planned-features","title":"Planned Features","text":"<p>The following features are planned for future releases beyond v1.0.0. These features are prioritized based on user feedback and development resources. We welcome contributions and suggestions from the community to help shape the roadmap, as well as help with implementation.</p> <ul> <li> Spacetrack Datasets Module</li> <li> Initialize SGPPropagator from GP Elements</li> <li> Propagation of relative motion<ul> <li> Hill-Clohessy-Wiltshire (HCW) Equations</li> <li> Numerical Relative Orbit Propagation</li> </ul> </li> <li> Plotting Relative Orbits<ul> <li> RTN 3-panel plot</li> <li> RTN 3D plot</li> </ul> </li> <li> Estimation<ul> <li> Batch Least Squares Estimator</li> <li> Extended Kalman Filter</li> <li> Unscented Kalman Filter</li> <li> Particle Filter</li> </ul> </li> <li> TLE Estimation <ul> <li> From GPS Observations</li> <li> From Initial OPM State</li> </ul> </li> </ul>"},{"location":"about/roadmap.html#considered-unplanned-features","title":"Considered, Unplanned Features","text":"<p>The following features have been considered for future releases but are not currently planned. They may be revisited based on user demand and development priorities.</p> <ul> <li> OEM File Support<ul> <li> Initialize Trajectory from OEM File</li> <li> Export Trajectory to OEM File</li> </ul> </li> <li> OMM File Support<ul> <li> Initialize Trajectory from OMM File</li> <li> Export Trajectory to OMM File</li> </ul> </li> <li> OPM File Support<ul> <li> Initialize Trajectory from OPM File</li> <li> Export Trajectory to OPM File</li> </ul> </li> <li> Additional Force Models<ul> <li> Tidal Force Models<ul> <li> Solid Earth Tides</li> <li> Ocean Tides</li> </ul> </li> <li> Albedeo Force Models</li> </ul> </li> <li> Probability of Collision Estimation</li> <li> Monte Carlo Simulation Framework</li> <li> Plotting Improvements<ul> <li> Access timeline plots</li> </ul> </li> <li> Attitude dynamics module<ul> <li> Rigid Body Dynamics</li> <li> Attitude Perturbations</li> <li> Attitude Actuator Modeling</li> </ul> </li> <li> Additional Examples and Tutorials</li> <li> Improved Atmospheric Models (EDU-only license)<ul> <li> NRLMSISE 2.0 Atmospheric Model Integration</li> <li> NRLMSISE 2.1 Atmospheric Model Integration</li> <li> DTM 2020 Atmospheric Model Integration</li> </ul> </li> <li> Quality of Life Improvements<ul> <li> Improved error messages and handling</li> <li> Enhanced logging capabilities</li> <li> Automatically append script outputs to documentation examples &amp; remove fixed outputs</li> </ul> </li> </ul>"},{"location":"about/versioning.html","title":"Versioning","text":"<p>While Brahe generally tries to adhere to Semantic Versioning to manage its version numbers. In pratice the versioning strategy is closer to that of Python and Pythongs's SciPy library, where breaking changes may occasionally be introduced in minor releases to facilitate rapid development and improvement. This is for two reasons. First, we want to avoid the forever \"0.x\" versioning trap that many Rust and scientific software projects fall into, which can deter users from adopting the software for use. Our \"1.x\" are intended to signal that Brahe is stable and ready for general use. Second, as we again adoption we are actively seeking user feedback and may need to make breaking changes to improve usability, performance, or correctness based on that feedback.</p> <p>Breaking Changes in Minor Releases</p> <p>If you need guaranteed stability you should pin your project to a specific major.minor version (e.g., <code>1.2.x</code>) rather than using a floating version specifier (e.g., <code>^1.2.0</code> or <code>&gt;=1.2.0</code>).</p> <p>Experimental Features</p> <p>Some features in Brahe are currently marked as experimental. These features are functional but more likely to undergo changes in minor releases as we refine their design and implementation. Experimental features are indicated in the documentation with a warning box.</p>"},{"location":"about/versioning.html#current-experimental-features","title":"Current Experimental Features","text":"<p>Some features in Brahe are currently marked as experimental. These features are functional but more likely to undergo changes in minor releases as we refine their design and implementation. Experimental features are indicated in the documentation with a warning box.</p> <p>Current experimental features include:</p> <ol> <li>Numerical Integration Module</li> <li>Space Weather Module</li> <li>Atmospheric Density Models (NRLMSISE-00)</li> <li>Numerical Propagation</li> </ol>"},{"location":"examples/index.html","title":"Examples","text":"<p>Here you will find complete worked examples that showcase some of the problems Brahe can help you solve. Each example includes the full source code so that you can run it yourself and modify it to suit your needs.</p>"},{"location":"examples/doppler_compensation.html","title":"Calculating Doppler Compensation","text":"<p>In this example we'll compute the Doppler compensation required for a ground station to maintain communications with a satellite in low Earth orbit (LEO). We'll simulate the International Space Station (ISS) passing over the Cape Canaveral ground station from the NASA Near Earth Network (NEN) and calculate the frequency shift due to the relative motion between the satellite and ground station during the access window.</p> <p>To accomplish this we'll define a custom access property computer that calculates the Doppler shift in Hz for S-band uplink communications (2.2 GHz) and X-Band downlink communications (8.4 GHz) based on the relative velocity between the satellite and ground station along the line of sight. We'll assume that the satellite uses a fixed carrier frequency for both uplink and downlink, and the ground station must adjust its local oscillator frequency to compensate for the Doppler shift in order to maintain a stable communication link.</p>"},{"location":"examples/doppler_compensation.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the TLE for the ISS (25544) from CelesTrak, and load the NASA Near Earth Network ground station network, and select the Cape Canaveral ground station.</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nbh.initialize_eop()\n</code></pre> <p>We download the ISS TLE directly by NORAD ID and load all NASA NEN ground stations:</p> <pre><code>iss = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n</code></pre> <p>Then select Cape Canaveral from the loaded stations:</p> <pre><code>nen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n\n# Select Cape Canaveral ground station\ncape_canaveral = None\nfor station in nen_stations:\n    if \"Merrit Island\" in station.get_name():\n        cape_canaveral = station\n        break\n</code></pre>"},{"location":"examples/doppler_compensation.html#custom-doppler-shift-property-computer","title":"Custom Doppler Shift Property Computer","text":"<p>Next, we'll define a custom access property computer that calculates the Doppler shift compensation required for maintaining stable communication links.</p>"},{"location":"examples/doppler_compensation.html#doppler-shift-physics","title":"Doppler Shift Physics","text":"<p>For electromagnetic signals traveling between a moving satellite and a stationary ground station, the observed frequency differs from the transmitted frequency due to relative motion along the line-of-sight from the transmitter to the receiver. Using the non-relativistic Doppler approximation (valid when \\(|v_{los}| \\ll c\\)), the received frequency \\(f_r\\) given a transmitted frequency \\(f_x\\) is:</p> \\[ f_r = f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>where \\(f_x\\) is the transmitted carrier frequency, \\(v_{los}\\) is the velocity along the line of sight from the station to the spacecraft (negative when approaching, positive when receding), and \\(c\\) is the speed of light.</p> <p>Sign Convention:</p> <ul> <li>\\(v_{los} &lt; 0\\): satellite approaching \u2192 frequency increases and wavelength decreases (blueshift)</li> <li>\\(v_{los} &gt; 0\\): satellite receeding \u2192 frequency decreases and wavelength increases (redshift)</li> </ul>"},{"location":"examples/doppler_compensation.html#compensation-strategy","title":"Compensation Strategy","text":"<p>To maintain a stable communication link, the ground station must compensate for the Doppler shift that arises from the relative line-of-sight velocity \\(v_{los}\\) between the satellite and the station. Both the satellite and ground station have design frequencies that they expect to operate at for uplink. The challenge is determining how much the ground station must adjust its transmit and receive frequencies to account for the Doppler effect.</p>"},{"location":"examples/doppler_compensation.html#downlink-compensation-satellite-ground","title":"Downlink Compensation (Satellite \u2192 Ground)","text":"<p>The spacecraft transmits at a fixed design frequency \\(f_x^d\\) (e.g., 8.4 GHz for X-band). The ground station's initial receiver frequency \\(f_r^0\\) is initially tuned to \\(f_r^0 = f_x^d\\), expecting to receive at the design frequency. The challenge then is to determine the required frequency adjustment \\(\\Delta f_r = f_r - f_r^0\\) that is added to base the receiver frequency to correctly receive the Doppler-shifted signal.</p> <p>Starting from the Doppler relation:</p> \\[ f_r = f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>where \\(f_r\\) is the actual received frequency, \\(f_x\\) is the transmitted frequency, and \\(v_{los}\\) is the line-of-sight velocity (negative when approaching, positive when receding).</p> <p>Since the spacecraft transmits at the fixed design frequency \\(f_x = f_x^d\\):</p> \\[ f_r = f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) \\] <p>The receiver compensation term is the difference between the actual received frequency and the initial tuning:</p> \\[ \\Delta f_r = f_r - f_r^0 = f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_r^0 \\] <p>Since \\(f_r^0 = f_x^d\\):</p> \\[ \\begin{align} \\Delta f_r &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_r^0 \\\\ &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c} \\right) - f_x^d \\\\ &amp;= f_x^d \\left( 1 - \\frac{v_{los}}{c}  - 1 \\right) \\\\ &amp;= -f_x^d \\frac{v_{los}}{c} \\end{align} \\] <p>Therefore, the downlink compensation is:</p> \\[ \\boxed{\\Delta f_r = -f_x^d \\frac{v_{los}}{c}} \\] <p>Sign interpretation: - When approaching (\\(v_{los} &lt; 0\\)): \\(\\Delta f_r &gt; 0\\) \u2192 tune receiver higher (blueshift) - When receding (\\(v_{los} &gt; 0\\)): \\(\\Delta f_r &lt; 0\\) \u2192 tune receiver lower (redshift)</p>"},{"location":"examples/doppler_compensation.html#uplink-compensation-ground-satellite","title":"Uplink Compensation (Ground \u2192 Satellite)","text":"<p>For uplink, the spacecraft expects to receive at its design frequency \\(f_r^d\\) (e.g., 2.2 GHz for S-band). The ground station initially transmits at \\(f_x^0 = f_r^d\\), but must pre-compensate so that after Doppler shift, the spacecraft receives exactly \\(f_r^d\\). We must determine the required frequency adjustment \\(\\Delta f_x = f_x - f_x^0\\) that the ground station must apply to its transmit frequency.</p> <p>We again start from the Doppler relation:</p> \\[ \\begin{align} f_r^d &amp;= (f_x + \\Delta f_x) \\left( 1 - \\frac{v_{los}}{c} \\right) &amp;= f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right) + \\Delta f_x \\left( 1 - \\frac{v_{los}}{c} \\right) \\end{align} \\] <p>Solving for \\(\\Delta f_x\\):</p> \\[ \\Delta f_x \\left( 1 - \\frac{v_{los}}{c} \\right) = f_r^d - f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right) \\] \\[ \\Delta f_x = \\frac{f_r^d - f_x^0 \\left( 1 - \\frac{v_{los}}{c} \\right)}{1 - \\frac{v_{los}}{c}} \\] <p>Since we know that \\(f_x^0 = f_r^d\\), we can substitute and simplify:</p> \\[ \\begin{align} \\Delta f_x &amp;= \\frac{f_r^d - f_r^d \\left( 1 - \\frac{v_{los}}{c} \\right)}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= \\frac{f_r^d \\left( 1 - \\left( 1 - \\frac{v_{los}}{c} \\right) \\right)}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= f_r^d \\frac{\\frac{v_{los}}{c}}{1 - \\frac{v_{los}}{c}} \\\\ &amp;= f_x^0 \\frac{\\frac{v_{los}}{c}}{\\frac{c - v_{los}}{c}} \\\\ &amp;= f_x^0 \\frac{v_{los}}{c - v_{los}} \\end{align} \\] <p>And so we find the uplink compensation is:</p> \\[ \\boxed{\\Delta f_x = f_x^0 \\frac{v_{los}}{c - v_{los}}} \\] <p>Frequency Scaling</p> <p>The magnitude of Doppler compensation scales with carrier frequency. X-band (8.4 GHz) experiences about \\(8.4/2.2 \\approx 3.8\\times\\) the frequency shift of S-band (2.2 GHz) for the same line-of-sight velocity.</p>"},{"location":"examples/doppler_compensation.html#implementation","title":"Implementation","text":"<p>We create a custom property computer that calculates the line-of-sight velocity from the satellite state and computes Doppler compensation for both S-band uplink (2.2 GHz) and X-band downlink (8.4 GHz):</p> <pre><code># Communication frequency bands\nS_BAND_FREQ = 2.2e9  # Hz (uplink)\nX_BAND_FREQ = 8.4e9  # Hz (downlink)\n\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"Compute Doppler shift time series for S-band and X-band communications.\"\"\"\n\n    def sampling_config(self):\n        \"\"\"Configure sampling at 10 Hz during access windows.\"\"\"\n        interval_hz = 10.0  # 10 samples per second\n        interval_s = 1.0 / interval_hz\n        return bh.SamplingConfig.fixed_interval(interval_s, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        \"\"\"Calculate Doppler compensation frequencies at each sample point.\n\n        Args:\n            window: AccessWindow with timing information\n            sample_times: Sample epochs in MJD [N]\n            sample_states_ecef: Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef: Location position [3] in ECEF (m)\n            location_geodetic: Location geodetic coords [lon, lat, alt] in (degrees, degrees, m)\n\n        Returns:\n            dict: Time series of Doppler compensation frequencies in Hz\n        \"\"\"\n        loc_pos = np.array(location_ecef)\n\n        # Compute Doppler at each sample point\n        doppler_s_band_list = []\n        doppler_x_band_list = []\n        v_los_list = []\n\n        for state in sample_states_ecef:\n            # Extract satellite position and velocity\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Compute line-of-sight vector (from ground station to satellite)\n            los_vec = sat_pos - loc_pos\n            los_unit = los_vec / np.linalg.norm(los_vec)\n\n            # Compute line-of-sight velocity (negative when approaching, positive when receding)\n            v_los = np.dot(sat_vel, los_unit)\n\n            # Compute Doppler compensation from first principles\n            # Uplink (S-band): \u0394f_x = f_x^0 \u00d7 v_los / (c - v_los)\n            #   Ground pre-compensates transmit frequency so spacecraft receives design frequency\n            # Downlink (X-band): \u0394f_r = -f_x^d \u00d7 v_los / c\n            #   Ground adjusts receive frequency to match Doppler-shifted spacecraft transmission\n            doppler_s = S_BAND_FREQ * v_los / (bh.C_LIGHT - v_los)  # Uplink\n            doppler_x = -X_BAND_FREQ * v_los / bh.C_LIGHT  # Downlink\n\n            doppler_s_band_list.append(doppler_s)\n            doppler_x_band_list.append(doppler_x)\n            v_los_list.append(v_los)\n\n        # Convert sample times to relative times (seconds from window open)\n        relative_times = (sample_times - window.window_open.mjd()) * 86400.0\n\n        # Return as time series\n        return {\n            \"doppler_s_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_s_band_list,\n            },\n            \"doppler_x_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_x_band_list,\n            },\n            \"v_los\": {\n                \"times\": relative_times.tolist(),\n                \"values\": v_los_list,\n            },\n        }\n\n    def property_names(self):\n        \"\"\"List properties this computer provides.\"\"\"\n        return [\"doppler_s_band\", \"doppler_x_band\", \"v_los\"]\n</code></pre> <p>The property computer extracts the satellite velocity from the provided ECEF state, projects it onto the line-of-sight unit vector to get the line-of-sight velocity, and applies the Doppler formula for both frequency bands.</p>"},{"location":"examples/doppler_compensation.html#access-computation","title":"Access Computation","text":"<p>Next, we'll compute the access windows between the ISS and the Cape Canaveral ground station over a 72-hour period with our custom Doppler shift property computer to calculate the Doppler compensation required to establish S-band and X-band communications during each access.</p> <pre><code>epoch_start = iss.epoch\nepoch_end = epoch_start + 72 * 3600.0  # 72 hours in seconds\n\n# Propagate for full 72-hour period\niss.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation and Doppler properties\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\ndoppler_computer = DopplerComputer()\n\nwindows = bh.location_accesses(\n    [cape_canaveral],\n    [iss],\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler_computer],\n)\n</code></pre> <p>This computes all access windows where the ISS rises above 5\u00b0 elevation as viewed from Cape Canaveral, and automatically calculates the Doppler compensation frequencies at the midpoint of each window using our custom property computer.</p>"},{"location":"examples/doppler_compensation.html#ground-track-visualization","title":"Ground Track Visualization","text":"<p>We first visualize the ISS ground track over one orbital period, showing Cape Canaveral's location and its communication cone based on the 5\u00b0 minimum elevation constraint:</p> <pre><code>orbital_period = bh.orbital_period(iss.semi_major_axis)\niss.propagate_to(iss.epoch + orbital_period)\n\n\n# Create ground track visualization\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": iss.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": [cape_canaveral],\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 8.0,\n        }\n    ],\n    gs_cone_altitude=iss.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\n</code></pre> <p>The resulting plot shows the ISS ground track in red and Cape Canaveral with its communication cone in blue:</p>"},{"location":"examples/doppler_compensation.html#doppler-compensation-analysis","title":"Doppler Compensation Analysis","text":"<p>For detailed analysis, we select one access window extract the computed doppler compensation value. This provides a high-resolution profile showing how the Doppler compensation varies as the satellite approaches, reaches closest approach, and recedes:</p> <p>The top panel shows \\(v_{los}\\) (line-of-sight velocity from ground station to satellite), confirming our sign convention: negative when approaching (start of pass), crossing through zero at closest approach, then positive when receding (end of pass).</p> <p>The middle and bottom panels show the Doppler compensation frequencies with opposite signs as required:</p> <ul> <li>S-band uplink (middle): Uses \\(\\Delta f_x = f_x^0 v_{los}/(c - v_{los})\\), so it's negative when approaching (transmit lower) and positive when receding (transmit higher)</li> <li>X-band downlink (bottom): Uses \\(\\Delta f_r = -f_x^d v_{los}/c\\), so it's positive when approaching (receive higher) and negative when receding (receive lower)</li> </ul> <p>Note that X-band requires approximately 3.8\u00d7 more compensation than S-band due to its higher carrier frequency (8.4 GHz vs 2.2 GHz). The uplink compensation includes the \\((c - v_{los})\\) denominator term for proper pre-compensation.</p> <pre><code># Convert times to minutes relative to window start for better readability\ntimes_rel_min = [t / 60.0 for t in doppler_s_ts[\"times\"]]\ndoppler_s_band_khz = [d / 1000.0 for d in doppler_s_ts[\"values\"]]\ndoppler_x_band_khz = [d / 1000.0 for d in doppler_x_ts[\"values\"]]\nv_los_km_s = [v / 1000.0 for v in v_los_ts[\"values\"]]  # Convert m/s to km/s\n\n# Create figure with three subplots\nfig_doppler = make_subplots(\n    rows=3,\n    cols=1,\n    subplot_titles=(\n        \"Line-of-Sight Velocity (negative = approaching, positive = receding)\",\n        \"S-band Uplink Doppler Compensation (2.2 GHz)\",\n        \"X-band Downlink Doppler Compensation (8.4 GHz)\",\n    ),\n    vertical_spacing=0.12,\n)\n\n# v_los plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=v_los_km_s,\n        mode=\"lines\",\n        name=\"v_los\",\n        line=dict(color=\"green\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;v_los: %{y:.2f} km/s&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=1,\n    col=1,\n)\n\n# S-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_s_band_khz,\n        mode=\"lines\",\n        name=\"S-band (2.2 GHz)\",\n        line=dict(color=\"steelblue\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=2,\n    col=1,\n)\n\n# X-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_x_band_khz,\n        mode=\"lines\",\n        name=\"X-band (8.4 GHz)\",\n        line=dict(color=\"coral\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=3,\n    col=1,\n)\n\n# Add zero reference lines\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=1, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=2, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=3, col=1\n)\n\n# Update axes labels with smaller fonts (matching plot_cartesian_trajectory pattern)\naxis_config = {\n    \"title_font\": {\"size\": 11},\n    \"tickfont\": {\"size\": 10},\n}\nfig_doppler.update_xaxes(\n    title_text=\"Time from AOS (minutes)\", row=3, col=1, **axis_config\n)\nfig_doppler.update_yaxes(title_text=\"v_los (km/s)\", row=1, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=2, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=3, col=1, **axis_config)\n\n# Make subplot titles smaller\nfor annotation in fig_doppler.layout.annotations:\n    annotation.font.size = 11\n\n# Update layout - NO explicit width/height for responsive sizing\nfig_doppler.update_layout(\n    title=\"Doppler Compensation for ISS Pass over Cape Canaveral\",\n    showlegend=False,\n)\n</code></pre>"},{"location":"examples/doppler_compensation.html#doppler-compensation-data","title":"Doppler Compensation Data","text":"<p>Below is a table of sampled Doppler compensation values during the access window. The compensation frequency indicates the adjustment needed for the ground station equipment:</p> Time (UTC) S-band Doppler (kHz) X-band Doppler (kHz) 2025-12-17 09:09:24 -50.47 192.72 2025-12-17 09:10:15 -49.92 190.6 2025-12-17 09:11:06 -48.57 185.45 2025-12-17 09:11:57 -45.03 171.95 2025-12-17 09:12:48 -33.71 128.72 2025-12-17 09:13:39 0.81 -3.1 2025-12-17 09:14:30 34.38 -131.26 2025-12-17 09:15:21 45.22 -172.64 2025-12-17 09:16:12 48.62 -185.64 2025-12-17 09:17:03 49.92 -190.61 2025-12-17 09:17:54 50.45 -192.64"},{"location":"examples/doppler_compensation.html#full-code-example","title":"Full Code Example","text":"doppler_compensation.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n\n# Communication frequency bands\nS_BAND_FREQ = 2.2e9  # Hz (uplink)\nX_BAND_FREQ = 8.4e9  # Hz (downlink)\n\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"Compute Doppler shift time series for S-band and X-band communications.\"\"\"\n\n    def sampling_config(self):\n        \"\"\"Configure sampling at 10 Hz during access windows.\"\"\"\n        interval_hz = 10.0  # 10 samples per second\n        interval_s = 1.0 / interval_hz\n        return bh.SamplingConfig.fixed_interval(interval_s, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        \"\"\"Calculate Doppler compensation frequencies at each sample point.\n\n        Args:\n            window: AccessWindow with timing information\n            sample_times: Sample epochs in MJD [N]\n            sample_states_ecef: Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef: Location position [3] in ECEF (m)\n            location_geodetic: Location geodetic coords [lon, lat, alt] in (degrees, degrees, m)\n\n        Returns:\n            dict: Time series of Doppler compensation frequencies in Hz\n        \"\"\"\n        loc_pos = np.array(location_ecef)\n\n        # Compute Doppler at each sample point\n        doppler_s_band_list = []\n        doppler_x_band_list = []\n        v_los_list = []\n\n        for state in sample_states_ecef:\n            # Extract satellite position and velocity\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Compute line-of-sight vector (from ground station to satellite)\n            los_vec = sat_pos - loc_pos\n            los_unit = los_vec / np.linalg.norm(los_vec)\n\n            # Compute line-of-sight velocity (negative when approaching, positive when receding)\n            v_los = np.dot(sat_vel, los_unit)\n\n            # Compute Doppler compensation from first principles\n            # Uplink (S-band): \u0394f_x = f_x^0 \u00d7 v_los / (c - v_los)\n            #   Ground pre-compensates transmit frequency so spacecraft receives design frequency\n            # Downlink (X-band): \u0394f_r = -f_x^d \u00d7 v_los / c\n            #   Ground adjusts receive frequency to match Doppler-shifted spacecraft transmission\n            doppler_s = S_BAND_FREQ * v_los / (bh.C_LIGHT - v_los)  # Uplink\n            doppler_x = -X_BAND_FREQ * v_los / bh.C_LIGHT  # Downlink\n\n            doppler_s_band_list.append(doppler_s)\n            doppler_x_band_list.append(doppler_x)\n            v_los_list.append(v_los)\n\n        # Convert sample times to relative times (seconds from window open)\n        relative_times = (sample_times - window.window_open.mjd()) * 86400.0\n\n        # Return as time series\n        return {\n            \"doppler_s_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_s_band_list,\n            },\n            \"doppler_x_band\": {\n                \"times\": relative_times.tolist(),\n                \"values\": doppler_x_band_list,\n            },\n            \"v_los\": {\n                \"times\": relative_times.tolist(),\n                \"values\": v_los_list,\n            },\n        }\n\n    def property_names(self):\n        \"\"\"List properties this computer provides.\"\"\"\n        return [\"doppler_s_band\", \"doppler_x_band\", \"v_los\"]\n\n\n\n\n# Download TLE data for ISS from CelesTrak\n# ISS (International Space Station)\n# NORAD ID: 25544\nprint(\"Downloading ISS TLE from CelesTrak...\")\nstart_time = time.time()\niss = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\nelapsed = time.time() - start_time\nprint(f\"Downloaded ISS TLE in {elapsed:.2f} seconds.\")\nprint(f\"Epoch: {iss.epoch}\")\nprint(f\"Semi-major axis: {iss.semi_major_axis / 1000:.1f} km\")\n\n# Load NASA Near Earth Network ground stations\nprint(\"\\nLoading NASA Near Earth Network ground stations...\")\nstart_time = time.time()\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n\n# Select Cape Canaveral ground station\ncape_canaveral = None\nfor station in nen_stations:\n    if \"Merrit Island\" in station.get_name():\n        cape_canaveral = station\n        break\n\nif cape_canaveral is None:\n    print(\"Error: Cape Canaveral ground station not found.\")\n    sys.exit(1)\n\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(nen_stations)} NASA NEN ground stations in {elapsed:.2f} seconds.\")\n\n\n# Propagate ISS for one orbit to create ground track visualization\nstart_time = time.time()\nprint(\"\\nCreating ground track visualization...\")\norbital_period = bh.orbital_period(iss.semi_major_axis)\niss.propagate_to(iss.epoch + orbital_period)\n\n\n# Create ground track visualization\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": iss.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": [cape_canaveral],\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 8.0,\n        }\n    ],\n    gs_cone_altitude=iss.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagator and compute 72-hour access windows with Doppler properties\nstart_time = time.time()\nprint(\"\\nComputing 72-hour access windows with Doppler compensation...\")\niss.reset()\n\n\nepoch_start = iss.epoch\nepoch_end = epoch_start + 72 * 3600.0  # 72 hours in seconds\n\n# Propagate for full 72-hour period\niss.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation and Doppler properties\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\ndoppler_computer = DopplerComputer()\n\nwindows = bh.location_accesses(\n    [cape_canaveral],\n    [iss],\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler_computer],\n)\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} access windows in {elapsed:.2f} seconds.\")\n\nif len(windows) == 0:\n    print(\"No access windows found. Exiting.\")\n    sys.exit(0)\n\n# Print sample of access windows with Doppler properties\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Sample Access Windows with Doppler Time Series (first 5)\")\nprint(\"=\" * 100)\nprint(\n    f\"{'Start Time':&lt;25} {'Duration':&gt;10} {'Max Elev':&gt;10} {'# Samples':&gt;10} {'Peak S-band':&gt;13} {'Peak X-band':&gt;13}\"\n)\nprint(\"-\" * 100)\nfor i, window in enumerate(windows[:5]):\n    duration_min = window.duration / 60.0\n    max_elev = window.properties.elevation_max\n\n    # Extract time series data\n    doppler_s_ts = window.properties.additional[\"doppler_s_band\"]\n    doppler_x_ts = window.properties.additional[\"doppler_x_band\"]\n\n    n_samples = len(doppler_s_ts[\"values\"])\n    peak_s = max(abs(v) for v in doppler_s_ts[\"values\"]) / 1000.0\n    peak_x = max(abs(v) for v in doppler_x_ts[\"values\"]) / 1000.0\n\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    print(\n        f\"{start_str:&lt;25} {duration_min:&gt;8.1f} m {max_elev:&gt;8.1f}\u00b0 {n_samples:&gt;10} {peak_s:&gt;10.2f} kHz {peak_x:&gt;10.2f} kHz\"\n    )\nprint(\"=\" * 100)\n\n# Select a window with good duration for detailed analysis\nselected_window = None\nfor window in windows:\n    if window.duration &gt; 300:  # At least 5 minutes\n        selected_window = window\n        break\n\nif selected_window is None:\n    # Fallback to first window if none are long enough\n    selected_window = windows[0]\n\nprint(\n    f\"\\nAnalyzing detailed Doppler profile for window starting at {selected_window.start}\"\n)\nprint(f\"Window duration: {selected_window.duration / 60:.1f} minutes\")\n\n# Extract precomputed time series from window properties\nprint(\"Extracting precomputed Doppler time series...\")\nstart_time = time.time()\n\ndoppler_s_ts = selected_window.properties.additional[\"doppler_s_band\"]\ndoppler_x_ts = selected_window.properties.additional[\"doppler_x_band\"]\nv_los_ts = selected_window.properties.additional[\"v_los\"]\n\n# Convert relative times to UTC epochs\ntimes_utc = [selected_window.start + t for t in doppler_s_ts[\"times\"]]\n\nnum_samples = len(doppler_s_ts[\"times\"])\n\nelapsed = time.time() - start_time\nprint(f\"Extracted {num_samples} samples (0.1s interval) in {elapsed:.2f} seconds.\")\n\n# Export ~10 evenly-spaced samples to CSV\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_data.csv\"\nnum_csv_samples = 11\ncsv_indices = np.linspace(0, len(times_utc) - 1, num_csv_samples, dtype=int)\n\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow([\"Time (UTC)\", \"S-band Doppler (kHz)\", \"X-band Doppler (kHz)\"])\n    for idx in csv_indices:\n        time_str = str(times_utc[idx]).split(\".\")[0]  # Remove fractional seconds\n        writer.writerow(\n            [\n                time_str,\n                f\"{doppler_s_ts['values'][idx] / 1000.0:.2f}\",\n                f\"{doppler_x_ts['values'][idx] / 1000.0:.2f}\",\n            ]\n        )\n\nprint(f\"\u2713 Exported {num_csv_samples} samples to {csv_path}\")\n\n# Create Doppler vs time visualization\nprint(\"\\nCreating Doppler compensation visualization...\")\nstart_time = time.time()\n\n\n# Convert times to minutes relative to window start for better readability\ntimes_rel_min = [t / 60.0 for t in doppler_s_ts[\"times\"]]\ndoppler_s_band_khz = [d / 1000.0 for d in doppler_s_ts[\"values\"]]\ndoppler_x_band_khz = [d / 1000.0 for d in doppler_x_ts[\"values\"]]\nv_los_km_s = [v / 1000.0 for v in v_los_ts[\"values\"]]  # Convert m/s to km/s\n\n# Create figure with three subplots\nfig_doppler = make_subplots(\n    rows=3,\n    cols=1,\n    subplot_titles=(\n        \"Line-of-Sight Velocity (negative = approaching, positive = receding)\",\n        \"S-band Uplink Doppler Compensation (2.2 GHz)\",\n        \"X-band Downlink Doppler Compensation (8.4 GHz)\",\n    ),\n    vertical_spacing=0.12,\n)\n\n# v_los plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=v_los_km_s,\n        mode=\"lines\",\n        name=\"v_los\",\n        line=dict(color=\"green\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;v_los: %{y:.2f} km/s&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=1,\n    col=1,\n)\n\n# S-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_s_band_khz,\n        mode=\"lines\",\n        name=\"S-band (2.2 GHz)\",\n        line=dict(color=\"steelblue\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=2,\n    col=1,\n)\n\n# X-band plot\nfig_doppler.add_trace(\n    go.Scatter(\n        x=times_rel_min,\n        y=doppler_x_band_khz,\n        mode=\"lines\",\n        name=\"X-band (8.4 GHz)\",\n        line=dict(color=\"coral\", width=2),\n        hovertemplate=\"Time: %{x:.2f} min&lt;br&gt;Doppler: %{y:.2f} kHz&lt;extra&gt;&lt;/extra&gt;\",\n    ),\n    row=3,\n    col=1,\n)\n\n# Add zero reference lines\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=1, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=2, col=1\n)\nfig_doppler.add_hline(\n    y=0, line_dash=\"dash\", line_color=\"gray\", opacity=0.5, row=3, col=1\n)\n\n# Update axes labels with smaller fonts (matching plot_cartesian_trajectory pattern)\naxis_config = {\n    \"title_font\": {\"size\": 11},\n    \"tickfont\": {\"size\": 10},\n}\nfig_doppler.update_xaxes(\n    title_text=\"Time from AOS (minutes)\", row=3, col=1, **axis_config\n)\nfig_doppler.update_yaxes(title_text=\"v_los (km/s)\", row=1, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=2, col=1, **axis_config)\nfig_doppler.update_yaxes(title_text=\"Doppler (kHz)\", row=3, col=1, **axis_config)\n\n# Make subplot titles smaller\nfor annotation in fig_doppler.layout.annotations:\n    annotation.font.size = 11\n\n# Update layout - NO explicit width/height for responsive sizing\nfig_doppler.update_layout(\n    title=\"Doppler Compensation for ISS Pass over Cape Canaveral\",\n    showlegend=False,\n)\n\nelapsed = time.time() - start_time\nprint(f\"Created Doppler visualization in {elapsed:.2f} seconds.\")\n\n# ============================================================================\n# Plot Output Section (for documentation generation)\n# ============================================================================\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent / \"plots\"))\nfrom brahe_theme import save_themed_html  # noqa: E402\n\n# Save the ground track figure as themed HTML\nlight_path, dark_path = save_themed_html(\n    fig_groundtrack, OUTDIR / f\"{SCRIPT_NAME}_groundtrack\"\n)\nprint(f\"\\n\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n\n# Save Doppler figure as themed HTML\nlight_path, dark_path = save_themed_html(fig_doppler, OUTDIR / f\"{SCRIPT_NAME}_doppler\")\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n\nprint(\"\\nDoppler Compensation Analysis Complete!\")\nprint(f\"Peak S-band Doppler: {max(abs(d) for d in doppler_s_band_khz):.2f} kHz\")\nprint(f\"Peak X-band Doppler: {max(abs(d) for d in doppler_x_band_khz):.2f} kHz\")\n</code></pre>"},{"location":"examples/doppler_compensation.html#see-also","title":"See Also","text":"<ul> <li>Access Properties - Custom property computers and property types</li> <li>Access Computation - Access search algorithms and configuration</li> <li>Predicting Ground Contacts - Similar example with statistical analysis</li> <li>CelesTrak Dataset - Downloading TLE data</li> <li>Ground Station Datasets - Loading ground station networks</li> </ul>"},{"location":"examples/geo_hohmann_transfer.html","title":"LEO to GEO Hohmann Transfer","text":"<p>In this example we'll compute and visualize a Hohmann transfer from a low Earth orbit (LEO) at 400 km altitude to geostationary orbit (GEO) at 35,786 km altitude. The Hohmann transfer is the most fuel-efficient two-impulse maneuver for transferring between coplanar circular orbits, making it fundamental to spacecraft mission design.</p> <p>We'll use the <code>NumericalOrbitPropagator</code> with event callbacks to apply impulsive velocity changes at perigee (departure) and apogee (arrival). The example demonstrates the complete workflow from calculating the required delta-v values to visualizing the orbit geometry and trajectory profiles.</p>"},{"location":"examples/geo_hohmann_transfer.html#problem-setup","title":"Problem Setup","text":"<p>Our mission is to transfer a spacecraft from a circular LEO parking orbit at 400 km altitude to geostationary orbit at 35,786 km altitude. At GEO altitude, a satellite with zero inclination orbits the Earth once per sidereal day, appearing stationary relative to the ground - ideal for communications and weather satellites.</p> <pre><code>import os\nimport pathlib\nimport sys\n\nimport numpy as np\nimport plotly.graph_objects as go\n\nimport brahe as bh\n\nbh.initialize_eop()\n</code></pre> <pre><code># LEO starting orbit: 400 km circular altitude\nr_leo = bh.R_EARTH + 400e3  # meters\n\n# GEO target orbit: 35,786 km altitude (geostationary)\nr_geo = bh.R_EARTH + 35786e3  # meters\n\nprint(\n    f\"LEO radius: {r_leo / 1e3:.1f} km (altitude: {(r_leo - bh.R_EARTH) / 1e3:.0f} km)\"\n)\nprint(\n    f\"GEO radius: {r_geo / 1e3:.1f} km (altitude: {(r_geo - bh.R_EARTH) / 1e3:.0f} km)\"\n)\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#hohmann-transfer-theory","title":"Hohmann Transfer Theory","text":""},{"location":"examples/geo_hohmann_transfer.html#mathematical-background","title":"Mathematical Background","text":"<p>The Hohmann transfer uses an elliptical transfer orbit that is tangent to both the initial and final circular orbits. The spacecraft performs two impulsive burns:</p> <ol> <li>First burn at perigee (LEO altitude): Increases velocity to enter the transfer ellipse</li> <li>Second burn at apogee (GEO altitude): Circularizes the orbit at the target altitude</li> </ol> <p>The transfer orbit has its perigee at the initial orbit radius \\(r_1\\) and apogee at the final orbit radius \\(r_2\\).</p> <p>Transfer orbit semi-major axis:</p> \\[a_{transfer} = \\frac{r_1 + r_2}{2}\\] <p>Circular orbit velocity (from the vis-viva equation for \\(e = 0\\)):</p> \\[v_{circ} = \\sqrt{\\frac{\\mu}{r}}\\] <p>Velocity at perigee and apogee of transfer ellipse (vis-viva equation):</p> \\[v = \\sqrt{\\mu \\left(\\frac{2}{r} - \\frac{1}{a}\\right)}\\] <p>Delta-v for each burn:</p> \\[\\Delta v_1 = v_{perigee,transfer} - v_{LEO} = \\sqrt{\\mu \\left(\\frac{2}{r_1} - \\frac{1}{a_{transfer}}\\right)} - \\sqrt{\\frac{\\mu}{r_1}}\\] \\[\\Delta v_2 = v_{GEO} - v_{apogee,transfer} = \\sqrt{\\frac{\\mu}{r_2}} - \\sqrt{\\mu \\left(\\frac{2}{r_2} - \\frac{1}{a_{transfer}}\\right)}\\] <p>Transfer time (half the orbital period of the transfer ellipse):</p> \\[T_{transfer} = \\pi \\sqrt{\\frac{a_{transfer}^3}{\\mu}}\\]"},{"location":"examples/geo_hohmann_transfer.html#delta-v-calculations","title":"Delta-V Calculations","text":"<pre><code># Circular orbit velocities (vis-viva equation for circular orbit: v = sqrt(mu/r))\nv_leo = np.sqrt(bh.GM_EARTH / r_leo)\nv_geo = np.sqrt(bh.GM_EARTH / r_geo)\n\n# Transfer orbit parameters\n# Semi-major axis is the average of the two radii\na_transfer = (r_leo + r_geo) / 2\n\n# Eccentricity of transfer ellipse\ne_transfer = (r_geo - r_leo) / (r_geo + r_leo)\n\n# Velocities on transfer orbit using vis-viva equation: v^2 = mu(2/r - 1/a)\nv_perigee_transfer = np.sqrt(bh.GM_EARTH * (2 / r_leo - 1 / a_transfer))\nv_apogee_transfer = np.sqrt(bh.GM_EARTH * (2 / r_geo - 1 / a_transfer))\n\n# Delta-v magnitudes\ndv1 = v_perigee_transfer - v_leo  # First burn: prograde at perigee (LEO)\ndv2 = v_geo - v_apogee_transfer  # Second burn: prograde at apogee (GEO)\n\n# Transfer time: half the period of the transfer ellipse\ntransfer_time = np.pi * np.sqrt(a_transfer**3 / bh.GM_EARTH)\n\nprint(\"\\nHohmann Transfer Parameters:\")\nprint(f\"  Transfer semi-major axis: {a_transfer / 1e3:.1f} km\")\nprint(f\"  Transfer eccentricity:    {e_transfer:.4f}\")\nprint(f\"  LEO circular velocity:    {v_leo / 1e3:.3f} km/s\")\nprint(f\"  GEO circular velocity:    {v_geo / 1e3:.3f} km/s\")\nprint(f\"  First burn (perigee):     {dv1 / 1e3:.3f} km/s\")\nprint(f\"  Second burn (apogee):     {dv2 / 1e3:.3f} km/s\")\nprint(f\"  Total delta-v:            {(dv1 + dv2) / 1e3:.3f} km/s\")\nprint(f\"  Transfer time:            {transfer_time / 3600:.2f} hours\")\n</code></pre> <p>The total delta-v of approximately 3.85 km/s is substantial - this is why geostationary satellites require large launch vehicles or are launched into geostationary transfer orbits (GTO) where the rocket provides the first burn and the satellite provides the circularization burn.</p>"},{"location":"examples/geo_hohmann_transfer.html#implementation","title":"Implementation","text":""},{"location":"examples/geo_hohmann_transfer.html#initial-state","title":"Initial State","text":"<p>We create an initial circular orbit at LEO altitude. The spacecraft starts at the point that will become the perigee of the transfer orbit:</p> <pre><code># Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial state: circular LEO orbit (at perigee of transfer)\n# Keplerian elements: [a, e, i, raan, argp, M]\noe_initial = np.array([r_leo, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate_initial = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\nprint(\"\\nInitial State (ECI):\")\nprint(\n    f\"  Position: [{state_initial[0] / 1e3:.1f}, {state_initial[1] / 1e3:.1f}, {state_initial[2] / 1e3:.1f}] km\"\n)\nprint(\n    f\"  Velocity: [{state_initial[3] / 1e3:.3f}, {state_initial[4] / 1e3:.3f}, {state_initial[5] / 1e3:.3f}] km/s\"\n)\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#event-callbacks-for-impulsive-maneuvers","title":"Event Callbacks for Impulsive Maneuvers","text":"<p>One way to implement the impulsive burns is by propagating to the burn times, extracting the state, applying the delta-v, and restarting propagation with a new state and propagator. However, brahe provides a cleaner approach using event callbacks. An event callback is a function that is invoked when a specified event occurs during propagation. In this case, we use <code>TimeEvent</code> detectors to trigger the burns at the calculated transfer times. Each callback receives the event epoch and current state, and returns the modified state along with an <code>EventAction</code> indicating whether to continue propagation:</p> <pre><code># Define event callbacks for impulsive maneuvers\n# Each callback receives the event epoch and current state,\n# and returns (new_state, EventAction)\n\n\ndef first_burn_callback(event_epoch, event_state):\n    \"\"\"Apply first delta-v at departure (prograde burn at perigee).\"\"\"\n    new_state = event_state.copy()\n    # Add delta-v in velocity direction (prograde)\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv1 * v_hat\n    print(f\"First burn applied: dv = {dv1 / 1e3:.3f} km/s (prograde)\")\n    return (new_state, bh.EventAction.CONTINUE)\n\n\ndef second_burn_callback(event_epoch, event_state):\n    \"\"\"Apply second delta-v at arrival (prograde burn at apogee).\"\"\"\n    new_state = event_state.copy()\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv2 * v_hat\n    print(f\"Second burn applied: dv = {dv2 / 1e3:.3f} km/s (prograde)\")\n    return (new_state, bh.EventAction.CONTINUE)\n</code></pre> <p>The callbacks apply delta-v in the prograde direction (along the velocity vector) to raise the orbit. Returning <code>EventAction.CONTINUE</code> tells the propagator to proceed with the modified state.</p>"},{"location":"examples/geo_hohmann_transfer.html#single-propagator-with-events","title":"Single Propagator with Events","text":"<p>We use a single propagator with <code>TimeEvent</code> detectors to trigger the burns at the appropriate times. This is cleaner than multi-stage propagation for simple maneuver sequences:</p> <pre><code># Create a single propagator with event-based maneuvers\n# This is cleaner than multi-stage propagation for simple burns\n\n# Timing\nburn1_time_s = 1.0  # First burn shortly after start\nburn2_time_s = burn1_time_s + transfer_time  # Second burn at apogee\ngeo_period = bh.orbital_period(r_geo)\ntotal_time = burn2_time_s + geo_period  # Continue for one GEO orbit\n\nprint(\"\\nPropagation Timeline:\")\nprint(f\"  Burn 1 at t = {burn1_time_s:.1f} s\")\nprint(f\"  Burn 2 at t = {burn2_time_s / 3600:.2f} hours\")\nprint(f\"  Total simulation: {total_time / 3600:.2f} hours\")\n\n# Create the propagator with two-body dynamics\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state_initial,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Add time-based events for the burns\nevent1 = bh.TimeEvent(epoch + burn1_time_s, \"First Burn\").with_callback(\n    first_burn_callback\n)\nevent2 = bh.TimeEvent(epoch + burn2_time_s, \"Second Burn\").with_callback(\n    second_burn_callback\n)\n\nprop.add_event_detector(event1)\nprop.add_event_detector(event2)\n\n# Propagate through both burns plus one GEO orbit\nprint(\"\\nPropagating...\")\nprop.propagate_to(epoch + total_time)\nprint(\"  Complete!\")\n\n# Verify final orbit\nfinal_koe = prop.state_koe_osc(prop.current_epoch, bh.AngleFormat.DEGREES)\nfinal_altitude = final_koe[0] - bh.R_EARTH\nprint(\"\\nFinal GEO Orbit:\")\nprint(f\"  Semi-major axis: {final_koe[0] / 1e3:.1f} km\")\nprint(f\"  Altitude:        {final_altitude / 1e3:.1f} km (target: 35786 km)\")\nprint(f\"  Eccentricity:    {final_koe[1]:.6f}\")\n</code></pre> <p>Why Two-Body Dynamics?</p> <p>We use the two-body force model (<code>ForceModelConfig.two_body()</code>) for this example because it provides the idealized Keplerian motion that matches the analytical Hohmann transfer theory. In practice, perturbations from Earth's oblateness, atmospheric drag (at LEO), and third-body effects would cause deviations that require trajectory correction maneuvers.</p>"},{"location":"examples/geo_hohmann_transfer.html#sampling-the-trajectory","title":"Sampling the Trajectory","text":"<p>We sample the trajectory at regular intervals to create the visualization data. The single propagator stores the complete trajectory including the state discontinuities from the burns:</p> <pre><code># Sample trajectory data for plotting\n# The single propagator stores the complete trajectory with maneuvers\ntimes_hours = []\naltitudes_km = []\nvelocities_km_s = []\n\ndt = 60.0  # 1-minute sampling\nt = 0.0\n\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    state = prop.state_eci(current_epoch)\n\n    r_mag = np.linalg.norm(state[:3])\n    v_mag = np.linalg.norm(state[3:6])\n\n    times_hours.append(t / 3600.0)\n    altitudes_km.append((r_mag - bh.R_EARTH) / 1e3)\n    velocities_km_s.append(v_mag / 1e3)\n\n    t += dt\n\nprint(f\"\\nSampled {len(times_hours)} trajectory points\")\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#visualizations","title":"Visualizations","text":""},{"location":"examples/geo_hohmann_transfer.html#orbit-geometry","title":"Orbit Geometry","text":"<p>The following plot shows a top-down view of the transfer geometry. The spacecraft departs from the LEO parking orbit (dashed blue), follows the transfer ellipse (solid red) for half an orbit, and arrives at GEO (dashed green):</p> <pre><code># Create 2D top-down view of orbit geometry\ntheta = np.linspace(0, 2 * np.pi, 200)\n\n# Earth circle\nearth_x = bh.R_EARTH * np.cos(theta) / 1e3\nearth_y = bh.R_EARTH * np.sin(theta) / 1e3\n\n# LEO orbit circle\nleo_x = r_leo * np.cos(theta) / 1e3\nleo_y = r_leo * np.sin(theta) / 1e3\n\n# GEO orbit circle\ngeo_x = r_geo * np.cos(theta) / 1e3\ngeo_y = r_geo * np.sin(theta) / 1e3\n\n# Transfer ellipse (only upper half: theta from 0 to pi)\ntheta_transfer = np.linspace(0, np.pi, 100)\np_transfer = a_transfer * (1 - e_transfer**2)\nr_transfer = p_transfer / (1 + e_transfer * np.cos(theta_transfer))\ntransfer_x = r_transfer * np.cos(theta_transfer) / 1e3\ntransfer_y = r_transfer * np.sin(theta_transfer) / 1e3\n\nfig_geometry = go.Figure()\n\n# Earth (filled)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=earth_x.tolist(),\n        y=earth_y.tolist(),\n        fill=\"toself\",\n        fillcolor=\"lightblue\",\n        line=dict(color=\"steelblue\", width=1),\n        name=\"Earth\",\n        hoverinfo=\"name\",\n    )\n)\n\n# LEO orbit\nfig_geometry.add_trace(\n    go.Scatter(\n        x=leo_x.tolist(),\n        y=leo_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2, dash=\"dash\"),\n        name=f\"LEO ({(r_leo - bh.R_EARTH) / 1e3:.0f} km)\",\n    )\n)\n\n# GEO orbit\nfig_geometry.add_trace(\n    go.Scatter(\n        x=geo_x.tolist(),\n        y=geo_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"green\", width=2, dash=\"dash\"),\n        name=f\"GEO ({(r_geo - bh.R_EARTH) / 1e3:.0f} km)\",\n    )\n)\n\n# Transfer ellipse\nfig_geometry.add_trace(\n    go.Scatter(\n        x=transfer_x.tolist(),\n        y=transfer_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"red\", width=3),\n        name=\"Transfer Orbit\",\n    )\n)\n\n# Burn 1 marker (at LEO, right side)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=[r_leo / 1e3],\n        y=[0],\n        mode=\"markers+text\",\n        marker=dict(size=15, color=\"red\", symbol=\"star\"),\n        text=[f\"Burn 1&lt;br&gt;{dv1 / 1e3:.2f} km/s\"],\n        textposition=\"bottom right\",\n        textfont=dict(size=10),\n        name=\"Burn 1\",\n        showlegend=False,\n    )\n)\n\n# Burn 2 marker (at GEO, left side - apogee)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=[-r_geo / 1e3],\n        y=[0],\n        mode=\"markers+text\",\n        marker=dict(size=15, color=\"red\", symbol=\"star\"),\n        text=[f\"Burn 2&lt;br&gt;{dv2 / 1e3:.2f} km/s\"],\n        textposition=\"top left\",\n        textfont=dict(size=10),\n        name=\"Burn 2\",\n        showlegend=False,\n    )\n)\n\nfig_geometry.update_layout(\n    title=\"LEO to GEO Hohmann Transfer Geometry\",\n    xaxis_title=\"X (km)\",\n    yaxis_title=\"Y (km)\",\n    yaxis_scaleanchor=\"x\",\n    showlegend=True,\n    legend=dict(x=0.02, y=0.98),\n    height=600,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#altitude-profile","title":"Altitude Profile","text":"<p>The altitude profile shows the spacecraft climbing from 400 km to nearly 36,000 km over the ~5.3 hour transfer:</p> <pre><code># Create altitude vs time plot\nfig_altitude = go.Figure()\n\nfig_altitude.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=altitudes_km,\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2),\n        name=\"Altitude\",\n    )\n)\n\n# Reference lines for initial and target altitudes\nfig_altitude.add_hline(\n    y=400,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=\"LEO: 400 km\",\n    annotation_position=\"top right\",\n)\n\nfig_altitude.add_hline(\n    y=35786,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=\"GEO: 35,786 km\",\n    annotation_position=\"top right\",\n)\n\n# Burn markers\nburn1_time_hr = burn1_time_s / 3600.0\nburn2_time_hr = burn2_time_s / 3600.0\n\nfig_altitude.add_vline(\n    x=burn1_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 1: {dv1 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_altitude.add_vline(\n    x=burn2_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 2: {dv2 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_altitude.update_layout(\n    title=\"Altitude During Hohmann Transfer\",\n    xaxis_title=\"Time (hours)\",\n    yaxis_title=\"Altitude (km)\",\n    showlegend=False,\n    height=500,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#velocity-profile","title":"Velocity Profile","text":"<p>The velocity profile reveals the characteristic behavior of elliptical orbits - the spacecraft is fastest at perigee and slowest at apogee. The impulsive burns appear as discontinuities:</p> <pre><code># Create velocity vs time plot\nfig_velocity = go.Figure()\n\nfig_velocity.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=velocities_km_s,\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2),\n        name=\"Velocity\",\n    )\n)\n\n# Reference lines for circular orbit velocities\nfig_velocity.add_hline(\n    y=v_leo / 1e3,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=f\"LEO: {v_leo / 1e3:.2f} km/s\",\n    annotation_position=\"top right\",\n)\n\nfig_velocity.add_hline(\n    y=v_geo / 1e3,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=f\"GEO: {v_geo / 1e3:.2f} km/s\",\n    annotation_position=\"bottom right\",\n)\n\n# Burn markers\nfig_velocity.add_vline(\n    x=burn1_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 1: +{dv1 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_velocity.add_vline(\n    x=burn2_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 2: +{dv2 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_velocity.update_layout(\n    title=\"Velocity During Hohmann Transfer\",\n    xaxis_title=\"Time (hours)\",\n    yaxis_title=\"Velocity (km/s)\",\n    showlegend=False,\n    height=500,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#transfer-summary","title":"Transfer Summary","text":"Parameter Value Initial altitude 400 km (LEO) Final altitude 35,786 km (GEO) First burn \\(\\Delta v_1\\) 2.40 km/s Second burn \\(\\Delta v_2\\) 1.46 km/s Total \\(\\Delta v\\) 3.85 km/s Transfer time 5.29 hours"},{"location":"examples/geo_hohmann_transfer.html#full-code-example","title":"Full Code Example","text":"geo_hohmann_transfer.py<pre><code>import os\nimport pathlib\nimport sys\n\nimport numpy as np\nimport plotly.graph_objects as go\n\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# LEO starting orbit: 400 km circular altitude\nr_leo = bh.R_EARTH + 400e3  # meters\n\n# GEO target orbit: 35,786 km altitude (geostationary)\nr_geo = bh.R_EARTH + 35786e3  # meters\n\nprint(\n    f\"LEO radius: {r_leo / 1e3:.1f} km (altitude: {(r_leo - bh.R_EARTH) / 1e3:.0f} km)\"\n)\nprint(\n    f\"GEO radius: {r_geo / 1e3:.1f} km (altitude: {(r_geo - bh.R_EARTH) / 1e3:.0f} km)\"\n)\n\n# Circular orbit velocities (vis-viva equation for circular orbit: v = sqrt(mu/r))\nv_leo = np.sqrt(bh.GM_EARTH / r_leo)\nv_geo = np.sqrt(bh.GM_EARTH / r_geo)\n\n# Transfer orbit parameters\n# Semi-major axis is the average of the two radii\na_transfer = (r_leo + r_geo) / 2\n\n# Eccentricity of transfer ellipse\ne_transfer = (r_geo - r_leo) / (r_geo + r_leo)\n\n# Velocities on transfer orbit using vis-viva equation: v^2 = mu(2/r - 1/a)\nv_perigee_transfer = np.sqrt(bh.GM_EARTH * (2 / r_leo - 1 / a_transfer))\nv_apogee_transfer = np.sqrt(bh.GM_EARTH * (2 / r_geo - 1 / a_transfer))\n\n# Delta-v magnitudes\ndv1 = v_perigee_transfer - v_leo  # First burn: prograde at perigee (LEO)\ndv2 = v_geo - v_apogee_transfer  # Second burn: prograde at apogee (GEO)\n\n# Transfer time: half the period of the transfer ellipse\ntransfer_time = np.pi * np.sqrt(a_transfer**3 / bh.GM_EARTH)\n\nprint(\"\\nHohmann Transfer Parameters:\")\nprint(f\"  Transfer semi-major axis: {a_transfer / 1e3:.1f} km\")\nprint(f\"  Transfer eccentricity:    {e_transfer:.4f}\")\nprint(f\"  LEO circular velocity:    {v_leo / 1e3:.3f} km/s\")\nprint(f\"  GEO circular velocity:    {v_geo / 1e3:.3f} km/s\")\nprint(f\"  First burn (perigee):     {dv1 / 1e3:.3f} km/s\")\nprint(f\"  Second burn (apogee):     {dv2 / 1e3:.3f} km/s\")\nprint(f\"  Total delta-v:            {(dv1 + dv2) / 1e3:.3f} km/s\")\nprint(f\"  Transfer time:            {transfer_time / 3600:.2f} hours\")\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial state: circular LEO orbit (at perigee of transfer)\n# Keplerian elements: [a, e, i, raan, argp, M]\noe_initial = np.array([r_leo, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate_initial = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\nprint(\"\\nInitial State (ECI):\")\nprint(\n    f\"  Position: [{state_initial[0] / 1e3:.1f}, {state_initial[1] / 1e3:.1f}, {state_initial[2] / 1e3:.1f}] km\"\n)\nprint(\n    f\"  Velocity: [{state_initial[3] / 1e3:.3f}, {state_initial[4] / 1e3:.3f}, {state_initial[5] / 1e3:.3f}] km/s\"\n)\n\n# Define event callbacks for impulsive maneuvers\n# Each callback receives the event epoch and current state,\n# and returns (new_state, EventAction)\n\n\ndef first_burn_callback(event_epoch, event_state):\n    \"\"\"Apply first delta-v at departure (prograde burn at perigee).\"\"\"\n    new_state = event_state.copy()\n    # Add delta-v in velocity direction (prograde)\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv1 * v_hat\n    print(f\"First burn applied: dv = {dv1 / 1e3:.3f} km/s (prograde)\")\n    return (new_state, bh.EventAction.CONTINUE)\n\n\ndef second_burn_callback(event_epoch, event_state):\n    \"\"\"Apply second delta-v at arrival (prograde burn at apogee).\"\"\"\n    new_state = event_state.copy()\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv2 * v_hat\n    print(f\"Second burn applied: dv = {dv2 / 1e3:.3f} km/s (prograde)\")\n    return (new_state, bh.EventAction.CONTINUE)\n\n\n\n# Create a single propagator with event-based maneuvers\n# This is cleaner than multi-stage propagation for simple burns\n\n# Timing\nburn1_time_s = 1.0  # First burn shortly after start\nburn2_time_s = burn1_time_s + transfer_time  # Second burn at apogee\ngeo_period = bh.orbital_period(r_geo)\ntotal_time = burn2_time_s + geo_period  # Continue for one GEO orbit\n\nprint(\"\\nPropagation Timeline:\")\nprint(f\"  Burn 1 at t = {burn1_time_s:.1f} s\")\nprint(f\"  Burn 2 at t = {burn2_time_s / 3600:.2f} hours\")\nprint(f\"  Total simulation: {total_time / 3600:.2f} hours\")\n\n# Create the propagator with two-body dynamics\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state_initial,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Add time-based events for the burns\nevent1 = bh.TimeEvent(epoch + burn1_time_s, \"First Burn\").with_callback(\n    first_burn_callback\n)\nevent2 = bh.TimeEvent(epoch + burn2_time_s, \"Second Burn\").with_callback(\n    second_burn_callback\n)\n\nprop.add_event_detector(event1)\nprop.add_event_detector(event2)\n\n# Propagate through both burns plus one GEO orbit\nprint(\"\\nPropagating...\")\nprop.propagate_to(epoch + total_time)\nprint(\"  Complete!\")\n\n# Verify final orbit\nfinal_koe = prop.state_koe_osc(prop.current_epoch, bh.AngleFormat.DEGREES)\nfinal_altitude = final_koe[0] - bh.R_EARTH\nprint(\"\\nFinal GEO Orbit:\")\nprint(f\"  Semi-major axis: {final_koe[0] / 1e3:.1f} km\")\nprint(f\"  Altitude:        {final_altitude / 1e3:.1f} km (target: 35786 km)\")\nprint(f\"  Eccentricity:    {final_koe[1]:.6f}\")\n\n# Sample trajectory data for plotting\n# The single propagator stores the complete trajectory with maneuvers\ntimes_hours = []\naltitudes_km = []\nvelocities_km_s = []\n\ndt = 60.0  # 1-minute sampling\nt = 0.0\n\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    state = prop.state_eci(current_epoch)\n\n    r_mag = np.linalg.norm(state[:3])\n    v_mag = np.linalg.norm(state[3:6])\n\n    times_hours.append(t / 3600.0)\n    altitudes_km.append((r_mag - bh.R_EARTH) / 1e3)\n    velocities_km_s.append(v_mag / 1e3)\n\n    t += dt\n\nprint(f\"\\nSampled {len(times_hours)} trajectory points\")\n\n# Create 2D top-down view of orbit geometry\ntheta = np.linspace(0, 2 * np.pi, 200)\n\n# Earth circle\nearth_x = bh.R_EARTH * np.cos(theta) / 1e3\nearth_y = bh.R_EARTH * np.sin(theta) / 1e3\n\n# LEO orbit circle\nleo_x = r_leo * np.cos(theta) / 1e3\nleo_y = r_leo * np.sin(theta) / 1e3\n\n# GEO orbit circle\ngeo_x = r_geo * np.cos(theta) / 1e3\ngeo_y = r_geo * np.sin(theta) / 1e3\n\n# Transfer ellipse (only upper half: theta from 0 to pi)\ntheta_transfer = np.linspace(0, np.pi, 100)\np_transfer = a_transfer * (1 - e_transfer**2)\nr_transfer = p_transfer / (1 + e_transfer * np.cos(theta_transfer))\ntransfer_x = r_transfer * np.cos(theta_transfer) / 1e3\ntransfer_y = r_transfer * np.sin(theta_transfer) / 1e3\n\nfig_geometry = go.Figure()\n\n# Earth (filled)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=earth_x.tolist(),\n        y=earth_y.tolist(),\n        fill=\"toself\",\n        fillcolor=\"lightblue\",\n        line=dict(color=\"steelblue\", width=1),\n        name=\"Earth\",\n        hoverinfo=\"name\",\n    )\n)\n\n# LEO orbit\nfig_geometry.add_trace(\n    go.Scatter(\n        x=leo_x.tolist(),\n        y=leo_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2, dash=\"dash\"),\n        name=f\"LEO ({(r_leo - bh.R_EARTH) / 1e3:.0f} km)\",\n    )\n)\n\n# GEO orbit\nfig_geometry.add_trace(\n    go.Scatter(\n        x=geo_x.tolist(),\n        y=geo_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"green\", width=2, dash=\"dash\"),\n        name=f\"GEO ({(r_geo - bh.R_EARTH) / 1e3:.0f} km)\",\n    )\n)\n\n# Transfer ellipse\nfig_geometry.add_trace(\n    go.Scatter(\n        x=transfer_x.tolist(),\n        y=transfer_y.tolist(),\n        mode=\"lines\",\n        line=dict(color=\"red\", width=3),\n        name=\"Transfer Orbit\",\n    )\n)\n\n# Burn 1 marker (at LEO, right side)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=[r_leo / 1e3],\n        y=[0],\n        mode=\"markers+text\",\n        marker=dict(size=15, color=\"red\", symbol=\"star\"),\n        text=[f\"Burn 1&lt;br&gt;{dv1 / 1e3:.2f} km/s\"],\n        textposition=\"bottom right\",\n        textfont=dict(size=10),\n        name=\"Burn 1\",\n        showlegend=False,\n    )\n)\n\n# Burn 2 marker (at GEO, left side - apogee)\nfig_geometry.add_trace(\n    go.Scatter(\n        x=[-r_geo / 1e3],\n        y=[0],\n        mode=\"markers+text\",\n        marker=dict(size=15, color=\"red\", symbol=\"star\"),\n        text=[f\"Burn 2&lt;br&gt;{dv2 / 1e3:.2f} km/s\"],\n        textposition=\"top left\",\n        textfont=dict(size=10),\n        name=\"Burn 2\",\n        showlegend=False,\n    )\n)\n\nfig_geometry.update_layout(\n    title=\"LEO to GEO Hohmann Transfer Geometry\",\n    xaxis_title=\"X (km)\",\n    yaxis_title=\"Y (km)\",\n    yaxis_scaleanchor=\"x\",\n    showlegend=True,\n    legend=dict(x=0.02, y=0.98),\n    height=600,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n\n# Create altitude vs time plot\nfig_altitude = go.Figure()\n\nfig_altitude.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=altitudes_km,\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2),\n        name=\"Altitude\",\n    )\n)\n\n# Reference lines for initial and target altitudes\nfig_altitude.add_hline(\n    y=400,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=\"LEO: 400 km\",\n    annotation_position=\"top right\",\n)\n\nfig_altitude.add_hline(\n    y=35786,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=\"GEO: 35,786 km\",\n    annotation_position=\"top right\",\n)\n\n# Burn markers\nburn1_time_hr = burn1_time_s / 3600.0\nburn2_time_hr = burn2_time_s / 3600.0\n\nfig_altitude.add_vline(\n    x=burn1_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 1: {dv1 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_altitude.add_vline(\n    x=burn2_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 2: {dv2 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_altitude.update_layout(\n    title=\"Altitude During Hohmann Transfer\",\n    xaxis_title=\"Time (hours)\",\n    yaxis_title=\"Altitude (km)\",\n    showlegend=False,\n    height=500,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n\n# Create velocity vs time plot\nfig_velocity = go.Figure()\n\nfig_velocity.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=velocities_km_s,\n        mode=\"lines\",\n        line=dict(color=\"blue\", width=2),\n        name=\"Velocity\",\n    )\n)\n\n# Reference lines for circular orbit velocities\nfig_velocity.add_hline(\n    y=v_leo / 1e3,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=f\"LEO: {v_leo / 1e3:.2f} km/s\",\n    annotation_position=\"top right\",\n)\n\nfig_velocity.add_hline(\n    y=v_geo / 1e3,\n    line_dash=\"dash\",\n    line_color=\"gray\",\n    annotation_text=f\"GEO: {v_geo / 1e3:.2f} km/s\",\n    annotation_position=\"bottom right\",\n)\n\n# Burn markers\nfig_velocity.add_vline(\n    x=burn1_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 1: +{dv1 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_velocity.add_vline(\n    x=burn2_time_hr,\n    line_dash=\"dot\",\n    line_color=\"red\",\n    annotation_text=f\"Burn 2: +{dv2 / 1e3:.2f} km/s\",\n    annotation_position=\"top left\",\n)\n\nfig_velocity.update_layout(\n    title=\"Velocity During Hohmann Transfer\",\n    xaxis_title=\"Time (hours)\",\n    yaxis_title=\"Velocity (km/s)\",\n    showlegend=False,\n    height=500,\n    margin=dict(l=60, r=40, t=60, b=60),\n)\n\n# Validation\naltitude_gain = final_altitude - (r_leo - bh.R_EARTH)\nassert altitude_gain &gt; 30000e3, f\"Altitude gain too small: {altitude_gain / 1e3:.0f} km\"\nassert final_koe[1] &lt; 0.01, f\"Final orbit not circular enough: e = {final_koe[1]:.6f}\"\n\nprint(\"\\nExample validated successfully!\")\nprint(f\"  Altitude gain: {altitude_gain / 1e3:.0f} km\")\nprint(f\"  Final eccentricity: {final_koe[1]:.6f}\")\n</code></pre>"},{"location":"examples/geo_hohmann_transfer.html#see-also","title":"See Also","text":"<ul> <li>Numerical Orbit Propagation - Propagator fundamentals</li> <li>Impulsive and Continuous Control - Maneuver implementation details</li> <li>Event Detection - Event-based propagation control</li> <li>Force Models - Configuring force models</li> </ul>"},{"location":"examples/ground_contacts.html","title":"Predicting Ground Contacts","text":"<p>In this example we'll predict ground contacts between the NISAR radar satellite and the NASA Near Earth Network ground stations using Brahe. We'll download the latest TLE data for the satellite from CelesTrak, load the NASA Near Earth Network ground station data, and compute the ground contacts between the satellite and ground stations over a 7-day period. We'll then analyze the statistics of the contact duration and number of contacts per ground station.</p>"},{"location":"examples/ground_contacts.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the TLE for NISAR (NORAD ID 65053) from CelesTrak, and load the NASA Near Earth Network ground station network.</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\nbh.initialize_eop()\n</code></pre> <p>We download the NISAR TLE directly by NORAD ID and load all NASA NEN ground stations:</p> <pre><code>nisar = bh.datasets.celestrak.get_tle_by_id_as_propagator(65053, 60.0)\nnisar = nisar.with_name(\"NISAR\")\n</code></pre> <pre><code>nen_stations = bh.datasets.groundstations.load(\"nasa nen\")\n</code></pre> <p>We then propagate NISAR for 3 orbital periods to prepare for ground track visualization:</p> <pre><code>orbital_period = bh.orbital_period(nisar.semi_major_axis)\nnisar.propagate_to(nisar.epoch + 3 * orbital_period)\n</code></pre>"},{"location":"examples/ground_contacts.html#ground-track-visualization","title":"Ground Track Visualization","text":"<p>Next we'll visualize the ground track and communication cones for NISAR over a 3-orbit period. The communication cones show the coverage area of each ground station based on a 5\u00b0 minimum elevation angle:</p> <pre><code>fig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": nisar.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": nen_stations,\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 5.0,\n        }\n    ],\n    gs_cone_altitude=nisar.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    basemap=\"natural_earth\",\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\n</code></pre> <p>The resulting plot shows NISAR's ground track in red and the NASA Near Earth Network stations with their communication cones in blue:</p>"},{"location":"examples/ground_contacts.html#compute-ground-contacts","title":"Compute Ground Contacts","text":"<p>We'll compute the ground contacts between NISAR and the NASA Near Earth Network ground stations over a 7-day period using Brahe's access computation tools. We use an elevation constraint of 5\u00b0 minimum elevation:</p> <pre><code>nisar.reset()\n\nepoch_start = nisar.epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate for full 7-day period\nnisar.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    nen_stations, [nisar], epoch_start, epoch_end, constraint\n)\n</code></pre> <p>Below is the table of the first 20 contact windows. Click on any column header to sort:</p> Station Start Time (UTC) End Time (UTC) Duration (min) Max Elevation (deg) Singapore 2025-12-16 22:41:20 2025-12-16 22:47:51 6.5 41.2 Svalbard 2025-12-16 23:00:11 2025-12-16 23:12:10 12 60.5 Kiruna 2025-12-16 23:00:45 2025-12-16 23:10:17 9.5 18.5 Wallops 2025-12-16 23:14:39 2025-12-16 23:26:42 12.1 73.7 Ponce de Leon 2025-12-16 23:17:24 2025-12-16 23:29:15 11.8 52.7 Merrit Island 2025-12-16 23:17:30 2025-12-16 23:29:23 11.9 54.9 Santiago 2025-12-16 23:35:37 2025-12-16 23:44:07 8.5 13.5 McMurdo 2025-12-16 23:50:57 2025-12-17 00:03:07 12.2 60.9 Dongara 2025-12-17 00:08:19 2025-12-17 00:14:03 5.7 8.3 Singapore 2025-12-17 00:17:06 2025-12-17 00:23:48 6.7 9.7 Kiruna 2025-12-17 00:37:41 2025-12-17 00:48:18 10.6 26.1 Svalbard 2025-12-17 00:38:40 2025-12-17 00:50:45 12.1 69.9 Wallops 2025-12-17 00:54:46 2025-12-17 01:02:40 7.9 12.5 White Sands 2025-12-17 00:56:26 2025-12-17 01:08:09 11.7 45.5 Ponce de Leon 2025-12-17 00:57:28 2025-12-17 01:05:32 8.1 13 Merrit Island 2025-12-17 00:57:42 2025-12-17 01:05:31 7.8 12.3 McMurdo 2025-12-17 01:29:25 2025-12-17 01:41:34 12.2 59.5 Kiruna 2025-12-17 02:15:03 2025-12-17 02:26:57 11.9 54.5 Svalbard 2025-12-17 02:17:25 2025-12-17 02:29:35 12.2 81.9 Gilmore Creek 2025-12-17 02:28:35 2025-12-17 02:37:19 8.7 14.1"},{"location":"examples/ground_contacts.html#analyze-contact-statistics","title":"Analyze Contact Statistics","text":"<p>Finally, we'll analyze the contact statistics, including the average daily contacts per station and distribution of contact durations.</p> <p>We group the contact windows by station and compute the average daily contacts:</p> <pre><code># Group contacts by station\nstation_contacts = {}\nfor window in windows:\n    station_name = window.location_name\n    if station_name not in station_contacts:\n        station_contacts[station_name] = []\n    station_contacts[station_name].append(window)\n\n# Calculate average daily contacts per station\ndays = 7.0\nstation_daily_avg = {}\nfor station, contacts in station_contacts.items():\n    avg_per_day = len(contacts) / days\n    station_daily_avg[station] = avg_per_day\n\n# Sort by average daily contacts\nsorted_stations = sorted(station_daily_avg.items(), key=lambda x: x[1], reverse=True)\n</code></pre> <p>Then we create two visualizations: a bar chart of average daily contacts per station, and a histogram of contact duration distribution:</p> <pre><code># Figure 1: Daily contacts per station (bar chart)\nstations_list = [s[0] for s in sorted_stations]\ndaily_avgs = [s[1] for s in sorted_stations]\n\nfig_daily = go.Figure(\n    data=[\n        go.Bar(\n            x=stations_list,\n            y=daily_avgs,\n            marker_color=\"steelblue\",\n            hovertemplate=\"&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;%{y:.1f} contacts/day&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_daily.update_layout(\n    title=\"NISAR Average Daily Contacts by Station (7-day period)\",\n    xaxis_title=\"Ground Station\",\n    yaxis_title=\"Average Daily Contacts\",\n    xaxis_tickangle=-45,\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=120),\n)\n\n# Figure 2: Contact duration distribution (histogram)\ndurations = [w.duration / 60.0 for w in windows]  # Convert to minutes\n\nmean_duration = np.mean(durations)\nmedian_duration = np.median(durations)\nmax_duration = np.max(durations)\n\nfig_duration = go.Figure(\n    data=[\n        go.Histogram(\n            x=durations,\n            nbinsx=30,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Duration: %{x:.1f} min&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_duration.update_layout(\n    title=\"NISAR Contact Duration Distribution\",\n    xaxis_title=\"Contact Duration (minutes)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {mean_duration:.1f} min&lt;br&gt;Median: {median_duration:.1f} min&lt;br&gt;Max: {max_duration:.1f} min\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.05,\n            y=0.97,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n</code></pre> <p>The daily contacts bar chart shows which stations have the most frequent visibility to NISAR:</p> <p>The duration histogram shows the distribution of contact lengths, with statistics overlay:</p>"},{"location":"examples/ground_contacts.html#full-code-example","title":"Full Code Example","text":"ground_contacts.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for NISAR from CelesTrak\n# NISAR (NASA-ISRO SAR) is a joint Earth observation satellite\n# NORAD ID: 65053\nprint(\"Downloading NISAR TLE from CelesTrak...\")\nstart_time = time.time()\nnisar = bh.datasets.celestrak.get_tle_by_id_as_propagator(65053, 60.0)\nnisar = nisar.with_name(\"NISAR\")\nelapsed = time.time() - start_time\nprint(f\"Downloaded NISAR TLE in {elapsed:.2f} seconds.\")\nprint(f\"Epoch: {nisar.epoch}\")\nprint(f\"Semi-major axis: {nisar.semi_major_axis / 1000:.1f} km\")\n\n# Load NASA Near Earth Network ground stations\nprint(\"\\nLoading NASA Near Earth Network ground stations...\")\nstart_time = time.time()\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(nen_stations)} NASA NEN ground stations in {elapsed:.2f} seconds.\")\n\n# Propagate NISAR for 3 orbits to create ground track visualization\nprint(\"\\nPropagating NISAR for 3 orbits...\")\nstart_time = time.time()\norbital_period = bh.orbital_period(nisar.semi_major_axis)\nnisar.propagate_to(nisar.epoch + 3 * orbital_period)\nelapsed = time.time() - start_time\nprint(f\"Orbital period: {orbital_period / 60:.1f} minutes\")\nprint(f\"Propagated NISAR for 3 orbits in {elapsed:.2f} seconds.\")\n\n# Create ground track visualization with communication cones\nprint(\"\\nCreating ground track visualization with communication cones...\")\nstart_time = time.time()\nfig_groundtrack = bh.plot_groundtrack(\n    trajectories=[\n        {\n            \"trajectory\": nisar.trajectory,\n            \"color\": \"red\",\n            \"line_width\": 2.0,\n            \"track_length\": 3,\n            \"track_units\": \"orbits\",\n        }\n    ],\n    ground_stations=[\n        {\n            \"stations\": nen_stations,\n            \"color\": \"blue\",\n            \"alpha\": 0.15,\n            \"point_size\": 5.0,\n        }\n    ],\n    gs_cone_altitude=nisar.semi_major_axis - bh.R_EARTH,\n    gs_min_elevation=5.0,\n    basemap=\"natural_earth\",\n    show_borders=True,\n    show_coastlines=True,\n    show_legend=False,\n    backend=\"plotly\",\n)\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n\nstart_time = time.time()\n# Reset propagator and compute 7-day access windows\nprint(\"\\nComputing 7-day ground contacts...\")\nnisar.reset()\n\nepoch_start = nisar.epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate for full 7-day period\nnisar.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    nen_stations, [nisar], epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} contact windows in {elapsed:.2f} seconds.\")\n\n# Print sample of contact windows\nprint(\"\\n\" + \"=\" * 80)\nprint(\"Sample Contact Windows (first 10)\")\nprint(\"=\" * 80)\nprint(\n    f\"{'Station':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;10} {'Max Elev':&gt;10}\"\n)\nprint(\"-\" * 80)\nfor i, window in enumerate(windows[:10]):\n    duration_min = window.duration / 60.0\n    max_elev = window.properties.elevation_max\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(window.end).split(\".\")[0]\n    print(\n        f\"{window.location_name:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_min:&gt;8.1f} m {max_elev:&gt;8.1f}\u00b0\"\n    )\nprint(\"=\" * 80)\n\n# Export first 20 contact windows to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_windows.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Station\",\n            \"Start Time (UTC)\",\n            \"End Time (UTC)\",\n            \"Duration (min)\",\n            \"Max Elevation (deg)\",\n        ]\n    )\n    for window in windows[:20]:  # Only export first 20 for documentation\n        duration_min = window.duration / 60.0\n        max_elev = window.properties.elevation_max\n        start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n        end_str = str(window.end).split(\".\")[0]\n        writer.writerow(\n            [\n                window.location_name,\n                start_str,\n                end_str,\n                f\"{duration_min:.1f}\",\n                f\"{max_elev:.1f}\",\n            ]\n        )\nprint(f\"\u2713 Exported first 20 contact windows to {csv_path}\")\n\n# Analyze contact statistics\nprint(\"\\nAnalyzing contact statistics...\")\n\n# Group contacts by station\nstation_contacts = {}\nfor window in windows:\n    station_name = window.location_name\n    if station_name not in station_contacts:\n        station_contacts[station_name] = []\n    station_contacts[station_name].append(window)\n\n# Calculate average daily contacts per station\ndays = 7.0\nstation_daily_avg = {}\nfor station, contacts in station_contacts.items():\n    avg_per_day = len(contacts) / days\n    station_daily_avg[station] = avg_per_day\n\n# Sort by average daily contacts\nsorted_stations = sorted(station_daily_avg.items(), key=lambda x: x[1], reverse=True)\n\nprint(\"\\nAverage Daily Contacts per Station:\")\nprint(\"-\" * 40)\nfor station, avg in sorted_stations:\n    total = len(station_contacts[station])\n    print(f\"{station:&lt;20}: {avg:&gt;5.1f} contacts/day ({total} total)\")\n\n\n# Figure 1: Daily contacts per station (bar chart)\nstations_list = [s[0] for s in sorted_stations]\ndaily_avgs = [s[1] for s in sorted_stations]\n\nfig_daily = go.Figure(\n    data=[\n        go.Bar(\n            x=stations_list,\n            y=daily_avgs,\n            marker_color=\"steelblue\",\n            hovertemplate=\"&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;%{y:.1f} contacts/day&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_daily.update_layout(\n    title=\"NISAR Average Daily Contacts by Station (7-day period)\",\n    xaxis_title=\"Ground Station\",\n    yaxis_title=\"Average Daily Contacts\",\n    xaxis_tickangle=-45,\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=120),\n)\n\n# Figure 2: Contact duration distribution (histogram)\ndurations = [w.duration / 60.0 for w in windows]  # Convert to minutes\n\nmean_duration = np.mean(durations)\nmedian_duration = np.median(durations)\nmax_duration = np.max(durations)\n\nfig_duration = go.Figure(\n    data=[\n        go.Histogram(\n            x=durations,\n            nbinsx=30,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Duration: %{x:.1f} min&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\nfig_duration.update_layout(\n    title=\"NISAR Contact Duration Distribution\",\n    xaxis_title=\"Contact Duration (minutes)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {mean_duration:.1f} min&lt;br&gt;Median: {median_duration:.1f} min&lt;br&gt;Max: {max_duration:.1f} min\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.05,\n            y=0.97,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n\nprint(\"\\nContact Duration Statistics:\")\nprint(f\"  Mean: {mean_duration:.1f} minutes\")\nprint(f\"  Median: {median_duration:.1f} minutes\")\nprint(f\"  Min: {np.min(durations):.1f} minutes\")\nprint(f\"  Max: {max_duration:.1f} minutes\")\n</code></pre>"},{"location":"examples/ground_contacts.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Locations</li> <li>Constraints</li> </ul>"},{"location":"examples/imaging_data_latency.html","title":"Calculating Imaging Data Latency","text":"<p>In this example we'll analyze the imaging data latency for a satellite constellation. Data latency is defined as the time between a satellite exiting an imaging region (Area of Interest) and the start of its next ground station contact for data downlink.</p> <p>For this analysis we'll use the Capella constellation (a commercial SAR imaging constellation) and the KSAT ground station network. The Area of Interest is the continental United States.</p> <p>This metric is critical for understanding how quickly collected imagery can be delivered to end users, which is a key performance indicator for Earth observation missions.</p>"},{"location":"examples/imaging_data_latency.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries and initialize Earth orientation parameters:</p> <pre><code>import csv\nimport os\nimport pathlib\nimport time\n\nimport brahe as bh\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shapely.geometry import Point, Polygon\n\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n</code></pre> <p>We download all active satellite TLEs from CelesTrak and filter for Capella satellites:</p> <pre><code># Download TLE data for all active satellites and filter for Capella\nprint(\"Downloading active satellite TLEs from CelesTrak...\")\nstart_time = time.time()\nall_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Capella satellites (name contains \"CAPELLA\")\ncapella_props = [\n    prop for prop in all_active_props if \"CAPELLA\" in prop.get_name().upper()\n]\nelapsed = time.time() - start_time\nprint(f\"Found {len(capella_props)} Capella satellites in {elapsed:.2f} seconds\")\nfor prop in capella_props:\n    print(f\"  - {prop.get_name()}\")\n</code></pre> <p>Next, we load the KSAT ground station network:</p> <pre><code># Load all KSAT ground stations\nprint(\"\\nLoading KSAT ground stations...\")\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"Loaded {len(ksat_stations)} KSAT ground stations\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#define-the-area-of-interest","title":"Define the Area of Interest","text":"<p>We define the AOI as a polygon covering the continental United States using a detailed GeoJSON outline:</p> <pre><code># Define AOI polygon for continental United States (CONUS)\n# Using a simplified polygon that captures the main landmass\nprint(\"\\nDefining continental US AOI polygon...\")\naoi_vertices = [\n    (-117.1, 32.5),\n    (-114.6, 32.7),\n    (-111.0, 31.3),\n    (-108.2, 31.3),\n    (-106.5, 31.8),\n    (-103.0, 29.0),\n    (-97.1, 25.9),\n    (-90.1, 30.9),\n    (-80.0, 24.5),\n    (-80.1, 31.0),\n    (-75.5, 35.2),\n    (-73.9, 40.5),\n    (-70.0, 41.5),\n    (-66.9, 44.8),\n    (-67.0, 47.5),\n    (-82.5, 41.7),\n    (-83.5, 46.0),\n    (-92.0, 48.6),\n    (-104.0, 49.0),\n    (-117.0, 49.0),\n    (-124.7, 48.4),\n    (-125.0, 42.0),\n    (-124.0, 39.0),\n    (-117.1, 32.5),  # Close polygon\n]\n\nprint(f\"Defined US AOI with {len(aoi_vertices)} vertices\")\n\n# Create PolygonLocation for visualization\naoi_polygon = bh.PolygonLocation(\n    [[lon, lat, 0.0] for lon, lat in aoi_vertices]\n).with_name(\"Continental US\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#filter-ground-stations","title":"Filter Ground Stations","text":"<p>We filter out ground stations that are inside the AOI. The reasoning is that a satellite cannot begin a downlink pass while it is still over the imaging region - it must first exit the AOI:</p> <pre><code># Filter out ground stations that are inside the AOI\n# (We assume you can't start a downlink while still over the imaging region)\naoi_shapely = Polygon(aoi_vertices)\n\n\ndef station_in_aoi(station):\n    \"\"\"Check if station is inside AOI using point-in-polygon test.\"\"\"\n    point = Point(station.lon, station.lat)\n    return aoi_shapely.contains(point)\n\n\n# Keep only stations outside the AOI\nexternal_stations = [s for s in ksat_stations if not station_in_aoi(s)]\nfiltered_count = len(ksat_stations) - len(external_stations)\nprint(f\"\\nFiltered out {filtered_count} stations inside AOI\")\nprint(f\"Using {len(external_stations)} external stations for downlink:\")\nfor station in external_stations:\n    print(f\"  - {station.get_name()} ({station.lon:.2f}, {station.lat:.2f})\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#compute-aoi-exit-events","title":"Compute AOI Exit Events","text":"<p>Using the <code>AOIExitEvent</code> detector with <code>SGPPropagator</code>, we detect every time a Capella satellite exits the US imaging region:</p> <pre><code># Compute AOI exit events for each Capella satellite\nprint(\"\\nComputing AOI exit events...\")\nstart_time = time.time()\n\n# Define analysis period using the EARLIEST satellite epoch\n# (different satellites have different TLE epochs)\nepoch_start = min(prop.epoch for prop in capella_props)\nepoch_end = epoch_start + 7 * 86400.0  # 7 days\n\n# Add AOI exit event detector to each propagator\nfor prop in capella_props:\n    sat_name = prop.get_name()\n\n    # Create AOI exit event detector\n    exit_event = bh.AOIExitEvent.from_coordinates(\n        aoi_vertices, f\"{sat_name}_AOI_Exit\", bh.AngleFormat.DEGREES\n    )\n\n    # Add event detector to propagator\n    prop.add_event_detector(exit_event)\n\n# Propagate all satellites in parallel\nbh.par_propagate_to(capella_props, epoch_end)\n\n# Collect all AOI exit events from all propagators\naoi_exits = []\nfor prop in capella_props:\n    sat_name = prop.get_name()\n    for event in prop.event_log():\n        if \"AOI_Exit\" in event.name:\n            aoi_exits.append(\n                {\"satellite\": sat_name, \"exit_time\": event.window_open, \"event\": event}\n            )\n\nelapsed = time.time() - start_time\nprint(f\"Found {len(aoi_exits)} AOI exit events in {elapsed:.2f} seconds\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#compute-ground-contacts","title":"Compute Ground Contacts","text":"<p>We reset the propagators and use the access computation pipeline to find all ground station contacts over the 7-day period:</p> <pre><code># Reset propagators and compute ground contacts\nprint(\"\\nComputing ground station contacts...\")\nstart_time = time.time()\n\n# Reset all propagators\nfor prop in capella_props:\n    prop.reset()\n\n# Propagate all satellites in parallel for 7 days\nbh.par_propagate_to(capella_props, epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    external_stations, capella_props, epoch_start, epoch_end, constraint\n)\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} ground contact windows in {elapsed:.2f} seconds\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#calculate-latencies","title":"Calculate Latencies","text":"<p>For each AOI exit event, we find the next ground contact for that satellite and compute the latency (time difference):</p> <pre><code># For each AOI exit, find the next ground contact and compute latency\nprint(\"\\nComputing imaging data latencies...\")\nstart_time = time.time()\n\n# Group contacts by satellite\nsatellite_contacts = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in satellite_contacts:\n        satellite_contacts[sat_name] = []\n    satellite_contacts[sat_name].append(window)\n\n# Sort each satellite's contacts by start time\nfor sat_name in satellite_contacts:\n    satellite_contacts[sat_name].sort(key=lambda w: w.start.jd())\n\n# Calculate latency for each AOI exit\nlatencies = []\nfor exit_info in aoi_exits:\n    sat_name = exit_info[\"satellite\"]\n    exit_time = exit_info[\"exit_time\"]\n\n    # Get contacts for this satellite\n    contacts = satellite_contacts.get(sat_name, [])\n\n    # Find the first contact that starts AFTER the exit time\n    for contact in contacts:\n        if contact.start &gt; exit_time:\n            latency = contact.start - exit_time  # Duration in seconds\n            latencies.append(\n                {\n                    \"satellite\": sat_name,\n                    \"exit_time\": exit_time,\n                    \"contact_start\": contact.start,\n                    \"contact_end\": contact.end,\n                    \"station\": contact.location_name,\n                    \"latency\": latency,\n                }\n            )\n            break\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(latencies)} latency values in {elapsed:.2f} seconds\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#results","title":"Results","text":""},{"location":"examples/imaging_data_latency.html#top-5-worst-latencies","title":"Top 5 Worst Latencies","text":"<p>The table below shows the 5 longest imaging data latencies - these represent the worst-case scenarios for data delivery:</p> Satellite AOI Exit (UTC) Contact Start (UTC) Station Latency CAPELLA-16 (ACADIA-6) 2025-12-18 16:37:26 2025-12-18 17:31:52 Bangalore 54m 25s CAPELLA-16 (ACADIA-6) 2025-12-17 16:29:12 2025-12-17 17:23:18 Bangalore 54m 5s CAPELLA-15 (ACADIA-5) 2025-12-22 16:25:22 2025-12-22 17:19:24 Bangalore 54m 2s CAPELLA-17 (ACADIA-7) 2025-12-22 18:59:35 2025-12-22 19:53:32 Bangalore 53m 57s CAPELLA-16 (ACADIA-6) 2025-12-19 16:45:40 2025-12-19 17:35:15 Mauritius 49m 35s"},{"location":"examples/imaging_data_latency.html#latency-statistics","title":"Latency Statistics","text":"<p>Summary statistics for all imaging data latencies over the 7-day period:</p> Metric Value Worst (Maximum) 54m 25s Average 11m 45s Median 5m 17s Best (Minimum) 8s Total AOI Exits 232 Matched Latencies 232 <pre><code># Sort latencies by duration (longest first)\nlatencies.sort(key=lambda x: x[\"latency\"], reverse=True)\n\n# Compute statistics\nlatency_values = [x[\"latency\"] for x in latencies]\nif latency_values:\n    worst_latency = max(latency_values)\n    best_latency = min(latency_values)\n    avg_latency = np.mean(latency_values)\n    median_latency = np.median(latency_values)\nelse:\n    worst_latency = best_latency = avg_latency = median_latency = 0.0\n\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Imaging Data Latency Statistics\")\nprint(\"=\" * 100)\nprint(f\"  Worst (Max):  {bh.format_time_string(worst_latency)}\")\nprint(f\"  Best (Min):   {bh.format_time_string(best_latency)}\")\nprint(f\"  Average:      {bh.format_time_string(avg_latency)}\")\nprint(f\"  Median:       {bh.format_time_string(median_latency)}\")\nprint(\"=\" * 100)\n\n# Print top 5 worst latencies\nprint(\"\\n\" + \"=\" * 120)\nprint(\"Top 5 Worst Imaging Data Latencies\")\nprint(\"=\" * 120)\nprint(\n    f\"{'Satellite':&lt;25} {'AOI Exit Time':&lt;28} {'Contact Start':&lt;28} {'Station':&lt;20} {'Latency':&gt;15}\"\n)\nprint(\"-\" * 120)\nfor entry in latencies[:5]:\n    exit_str = str(entry[\"exit_time\"]).split(\".\")[0]\n    contact_str = str(entry[\"contact_start\"]).split(\".\")[0]\n    latency_str = bh.format_time_string(entry[\"latency\"], short=False)\n    print(\n        f\"{entry['satellite']:&lt;25} {exit_str:&lt;28} {contact_str:&lt;28} {entry['station']:&lt;20} {latency_str:&gt;15}\"\n    )\nprint(\"=\" * 120)\n\n# Export top 5 latencies to CSV\ncsv_top5_path = OUTDIR / f\"{SCRIPT_NAME}_top5.csv\"\nwith open(csv_top5_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\"Satellite\", \"AOI Exit (UTC)\", \"Contact Start (UTC)\", \"Station\", \"Latency\"]\n    )\n    for entry in latencies[:5]:\n        exit_str = str(entry[\"exit_time\"]).split(\".\")[0]\n        contact_str = str(entry[\"contact_start\"]).split(\".\")[0]\n        latency_str = bh.format_time_string(entry[\"latency\"], short=True)\n        writer.writerow(\n            [entry[\"satellite\"], exit_str, contact_str, entry[\"station\"], latency_str]\n        )\nprint(f\"\\n\u2713 Exported top 5 latencies to {csv_top5_path}\")\n\n# Export statistics to CSV\ncsv_stats_path = OUTDIR / f\"{SCRIPT_NAME}_stats.csv\"\nwith open(csv_stats_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow([\"Metric\", \"Value\"])\n    writer.writerow(\n        [\"Worst (Maximum)\", bh.format_time_string(worst_latency, short=True)]\n    )\n    writer.writerow([\"Average\", bh.format_time_string(avg_latency, short=True)])\n    writer.writerow([\"Median\", bh.format_time_string(median_latency, short=True)])\n    writer.writerow([\"Best (Minimum)\", bh.format_time_string(best_latency, short=True)])\n    writer.writerow([\"Total AOI Exits\", str(len(aoi_exits))])\n    writer.writerow([\"Matched Latencies\", str(len(latencies))])\nprint(f\"\u2713 Exported statistics to {csv_stats_path}\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#visualization","title":"Visualization","text":"<p>The ground track plot below shows the satellite paths during the top 3 worst-case latency periods. The green dashed line indicates the US AOI boundary, and the blue circles show the ground station communication cones:</p> <p>The colored tracks show the satellite ground paths from the moment of AOI exit until the start of the next ground contact:</p> <ul> <li>Red: Longest latency (worst case)</li> <li>Orange: Second longest latency</li> <li>Yellow: Third longest latency</li> </ul> <p>This visualization helps identify geographic regions where additional ground stations might reduce data latency.</p> <pre><code># Create ground track visualization for top 3 worst latencies\nprint(\"\\nCreating ground track visualization for top 3 worst latencies...\")\nstart_time = time.time()\n\n# Get the top 3 worst latencies\ntop_3_latencies = latencies[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\ngap_segments_all = []\n\nfor lat_idx, lat_entry in enumerate(top_3_latencies):\n    sat_name = lat_entry[\"satellite\"]\n    exit_time = lat_entry[\"exit_time\"]\n    contact_start = lat_entry[\"contact_start\"]\n    station_name = lat_entry[\"station\"]\n    total_latency = lat_entry[\"latency\"]\n\n    latency_str = bh.format_time_string(total_latency, short=True)\n    gap_label = f\"{sat_name} \u2192 {station_name}\"\n\n    # Find the propagator for this satellite\n    sat_prop = None\n    for prop in capella_props:\n        if prop.get_name() == sat_name:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {sat_name}\")\n        continue\n\n    # Get trajectory data from the stored trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ALL ground track points from AOI exit to ground contact\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if exit_time &lt;= ep &lt;= contact_start:\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    if len(gap_lons) &lt; 2:\n        print(f\"Warning: Insufficient points for gap {lat_idx + 1}\")\n        continue\n\n    # Split ground track at antimeridian crossings to avoid wrap-around lines\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    gap_segments_all.append(\n        {\n            \"segments\": segments,\n            \"color\": gap_colors[lat_idx],\n            \"label\": gap_label,\n            \"satellite\": sat_name,\n            \"latency\": total_latency,\n        }\n    )\n\n    print(\n        f\"  Gap {lat_idx + 1}: {len(gap_lons)} points, {len(segments)} segments, latency={latency_str}\"\n    )\n\n# Create ground track plot with stations and AOI\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": external_stations, \"color\": \"red\", \"alpha\": 0.2}],\n    gs_cone_altitude=np.min(\n        [prop.semi_major_axis - bh.R_EARTH for prop in capella_props]\n    ),\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\nax = fig_groundtrack.get_axes()[0]\n\n# Plot AOI boundary\naoi_lons = [v[0] for v in aoi_vertices]\naoi_lats = [v[1] for v in aoi_vertices]\nax.plot(\n    aoi_lons,\n    aoi_lats,\n    color=\"green\",\n    linewidth=2,\n    linestyle=\"--\",\n    transform=ccrs.Geodetic(),\n    zorder=8,\n    label=\"US AOI Boundary\",\n)\nax.fill(\n    aoi_lons, aoi_lats, color=\"green\", alpha=0.1, transform=ccrs.Geodetic(), zorder=7\n)\n\n# Plot each latency gap segment\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        if ccrs is not None:\n            ax.plot(\n                lon_seg,\n                lat_seg,\n                color=gap_data[\"color\"],\n                linewidth=2.5,\n                transform=ccrs.Geodetic(),\n                zorder=10,\n                label=gap_data[\"label\"] if i == 0 else \"\",\n            )\n\n# Add legend\nlegend = ax.legend(loc=\"lower left\", fontsize=9)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Capella Constellation: Top 3 Worst Imaging Data Latencies\\n\"\n    f\"KSAT Network ({len(external_stations)} stations outside US, 5\u00b0 elevation)\",\n    fontsize=11,\n)\n</code></pre>"},{"location":"examples/imaging_data_latency.html#full-code-example","title":"Full Code Example","text":"imaging_data_latency.py<pre><code>import csv\nimport os\nimport pathlib\nimport time\n\nimport brahe as bh\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom shapely.geometry import Point, Polygon\n\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for all active satellites and filter for Capella\nprint(\"Downloading active satellite TLEs from CelesTrak...\")\nstart_time = time.time()\nall_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Capella satellites (name contains \"CAPELLA\")\ncapella_props = [\n    prop for prop in all_active_props if \"CAPELLA\" in prop.get_name().upper()\n]\nelapsed = time.time() - start_time\nprint(f\"Found {len(capella_props)} Capella satellites in {elapsed:.2f} seconds\")\nfor prop in capella_props:\n    print(f\"  - {prop.get_name()}\")\n\n# Load all KSAT ground stations\nprint(\"\\nLoading KSAT ground stations...\")\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"Loaded {len(ksat_stations)} KSAT ground stations\")\n\n# Define AOI polygon for continental United States (CONUS)\n# Using a simplified polygon that captures the main landmass\nprint(\"\\nDefining continental US AOI polygon...\")\naoi_vertices = [\n    (-117.1, 32.5),\n    (-114.6, 32.7),\n    (-111.0, 31.3),\n    (-108.2, 31.3),\n    (-106.5, 31.8),\n    (-103.0, 29.0),\n    (-97.1, 25.9),\n    (-90.1, 30.9),\n    (-80.0, 24.5),\n    (-80.1, 31.0),\n    (-75.5, 35.2),\n    (-73.9, 40.5),\n    (-70.0, 41.5),\n    (-66.9, 44.8),\n    (-67.0, 47.5),\n    (-82.5, 41.7),\n    (-83.5, 46.0),\n    (-92.0, 48.6),\n    (-104.0, 49.0),\n    (-117.0, 49.0),\n    (-124.7, 48.4),\n    (-125.0, 42.0),\n    (-124.0, 39.0),\n    (-117.1, 32.5),  # Close polygon\n]\n\nprint(f\"Defined US AOI with {len(aoi_vertices)} vertices\")\n\n# Create PolygonLocation for visualization\naoi_polygon = bh.PolygonLocation(\n    [[lon, lat, 0.0] for lon, lat in aoi_vertices]\n).with_name(\"Continental US\")\n\n# Filter out ground stations that are inside the AOI\n# (We assume you can't start a downlink while still over the imaging region)\naoi_shapely = Polygon(aoi_vertices)\n\n\ndef station_in_aoi(station):\n    \"\"\"Check if station is inside AOI using point-in-polygon test.\"\"\"\n    point = Point(station.lon, station.lat)\n    return aoi_shapely.contains(point)\n\n\n# Keep only stations outside the AOI\nexternal_stations = [s for s in ksat_stations if not station_in_aoi(s)]\nfiltered_count = len(ksat_stations) - len(external_stations)\nprint(f\"\\nFiltered out {filtered_count} stations inside AOI\")\nprint(f\"Using {len(external_stations)} external stations for downlink:\")\nfor station in external_stations:\n    print(f\"  - {station.get_name()} ({station.lon:.2f}, {station.lat:.2f})\")\n\n# Compute AOI exit events for each Capella satellite\nprint(\"\\nComputing AOI exit events...\")\nstart_time = time.time()\n\n# Define analysis period using the EARLIEST satellite epoch\n# (different satellites have different TLE epochs)\nepoch_start = min(prop.epoch for prop in capella_props)\nepoch_end = epoch_start + 7 * 86400.0  # 7 days\n\n# Add AOI exit event detector to each propagator\nfor prop in capella_props:\n    sat_name = prop.get_name()\n\n    # Create AOI exit event detector\n    exit_event = bh.AOIExitEvent.from_coordinates(\n        aoi_vertices, f\"{sat_name}_AOI_Exit\", bh.AngleFormat.DEGREES\n    )\n\n    # Add event detector to propagator\n    prop.add_event_detector(exit_event)\n\n# Propagate all satellites in parallel\nbh.par_propagate_to(capella_props, epoch_end)\n\n# Collect all AOI exit events from all propagators\naoi_exits = []\nfor prop in capella_props:\n    sat_name = prop.get_name()\n    for event in prop.event_log():\n        if \"AOI_Exit\" in event.name:\n            aoi_exits.append(\n                {\"satellite\": sat_name, \"exit_time\": event.window_open, \"event\": event}\n            )\n\nelapsed = time.time() - start_time\nprint(f\"Found {len(aoi_exits)} AOI exit events in {elapsed:.2f} seconds\")\n\n# Reset propagators and compute ground contacts\nprint(\"\\nComputing ground station contacts...\")\nstart_time = time.time()\n\n# Reset all propagators\nfor prop in capella_props:\n    prop.reset()\n\n# Propagate all satellites in parallel for 7 days\nbh.par_propagate_to(capella_props, epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    external_stations, capella_props, epoch_start, epoch_end, constraint\n)\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} ground contact windows in {elapsed:.2f} seconds\")\n\n# For each AOI exit, find the next ground contact and compute latency\nprint(\"\\nComputing imaging data latencies...\")\nstart_time = time.time()\n\n# Group contacts by satellite\nsatellite_contacts = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in satellite_contacts:\n        satellite_contacts[sat_name] = []\n    satellite_contacts[sat_name].append(window)\n\n# Sort each satellite's contacts by start time\nfor sat_name in satellite_contacts:\n    satellite_contacts[sat_name].sort(key=lambda w: w.start.jd())\n\n# Calculate latency for each AOI exit\nlatencies = []\nfor exit_info in aoi_exits:\n    sat_name = exit_info[\"satellite\"]\n    exit_time = exit_info[\"exit_time\"]\n\n    # Get contacts for this satellite\n    contacts = satellite_contacts.get(sat_name, [])\n\n    # Find the first contact that starts AFTER the exit time\n    for contact in contacts:\n        if contact.start &gt; exit_time:\n            latency = contact.start - exit_time  # Duration in seconds\n            latencies.append(\n                {\n                    \"satellite\": sat_name,\n                    \"exit_time\": exit_time,\n                    \"contact_start\": contact.start,\n                    \"contact_end\": contact.end,\n                    \"station\": contact.location_name,\n                    \"latency\": latency,\n                }\n            )\n            break\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(latencies)} latency values in {elapsed:.2f} seconds\")\n\n# Sort latencies by duration (longest first)\nlatencies.sort(key=lambda x: x[\"latency\"], reverse=True)\n\n# Compute statistics\nlatency_values = [x[\"latency\"] for x in latencies]\nif latency_values:\n    worst_latency = max(latency_values)\n    best_latency = min(latency_values)\n    avg_latency = np.mean(latency_values)\n    median_latency = np.median(latency_values)\nelse:\n    worst_latency = best_latency = avg_latency = median_latency = 0.0\n\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Imaging Data Latency Statistics\")\nprint(\"=\" * 100)\nprint(f\"  Worst (Max):  {bh.format_time_string(worst_latency)}\")\nprint(f\"  Best (Min):   {bh.format_time_string(best_latency)}\")\nprint(f\"  Average:      {bh.format_time_string(avg_latency)}\")\nprint(f\"  Median:       {bh.format_time_string(median_latency)}\")\nprint(\"=\" * 100)\n\n# Print top 5 worst latencies\nprint(\"\\n\" + \"=\" * 120)\nprint(\"Top 5 Worst Imaging Data Latencies\")\nprint(\"=\" * 120)\nprint(\n    f\"{'Satellite':&lt;25} {'AOI Exit Time':&lt;28} {'Contact Start':&lt;28} {'Station':&lt;20} {'Latency':&gt;15}\"\n)\nprint(\"-\" * 120)\nfor entry in latencies[:5]:\n    exit_str = str(entry[\"exit_time\"]).split(\".\")[0]\n    contact_str = str(entry[\"contact_start\"]).split(\".\")[0]\n    latency_str = bh.format_time_string(entry[\"latency\"], short=False)\n    print(\n        f\"{entry['satellite']:&lt;25} {exit_str:&lt;28} {contact_str:&lt;28} {entry['station']:&lt;20} {latency_str:&gt;15}\"\n    )\nprint(\"=\" * 120)\n\n# Export top 5 latencies to CSV\ncsv_top5_path = OUTDIR / f\"{SCRIPT_NAME}_top5.csv\"\nwith open(csv_top5_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\"Satellite\", \"AOI Exit (UTC)\", \"Contact Start (UTC)\", \"Station\", \"Latency\"]\n    )\n    for entry in latencies[:5]:\n        exit_str = str(entry[\"exit_time\"]).split(\".\")[0]\n        contact_str = str(entry[\"contact_start\"]).split(\".\")[0]\n        latency_str = bh.format_time_string(entry[\"latency\"], short=True)\n        writer.writerow(\n            [entry[\"satellite\"], exit_str, contact_str, entry[\"station\"], latency_str]\n        )\nprint(f\"\\n\u2713 Exported top 5 latencies to {csv_top5_path}\")\n\n# Export statistics to CSV\ncsv_stats_path = OUTDIR / f\"{SCRIPT_NAME}_stats.csv\"\nwith open(csv_stats_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow([\"Metric\", \"Value\"])\n    writer.writerow(\n        [\"Worst (Maximum)\", bh.format_time_string(worst_latency, short=True)]\n    )\n    writer.writerow([\"Average\", bh.format_time_string(avg_latency, short=True)])\n    writer.writerow([\"Median\", bh.format_time_string(median_latency, short=True)])\n    writer.writerow([\"Best (Minimum)\", bh.format_time_string(best_latency, short=True)])\n    writer.writerow([\"Total AOI Exits\", str(len(aoi_exits))])\n    writer.writerow([\"Matched Latencies\", str(len(latencies))])\nprint(f\"\u2713 Exported statistics to {csv_stats_path}\")\n\n# Create ground track visualization for top 3 worst latencies\nprint(\"\\nCreating ground track visualization for top 3 worst latencies...\")\nstart_time = time.time()\n\n# Get the top 3 worst latencies\ntop_3_latencies = latencies[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\ngap_segments_all = []\n\nfor lat_idx, lat_entry in enumerate(top_3_latencies):\n    sat_name = lat_entry[\"satellite\"]\n    exit_time = lat_entry[\"exit_time\"]\n    contact_start = lat_entry[\"contact_start\"]\n    station_name = lat_entry[\"station\"]\n    total_latency = lat_entry[\"latency\"]\n\n    latency_str = bh.format_time_string(total_latency, short=True)\n    gap_label = f\"{sat_name} \u2192 {station_name}\"\n\n    # Find the propagator for this satellite\n    sat_prop = None\n    for prop in capella_props:\n        if prop.get_name() == sat_name:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {sat_name}\")\n        continue\n\n    # Get trajectory data from the stored trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ALL ground track points from AOI exit to ground contact\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if exit_time &lt;= ep &lt;= contact_start:\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    if len(gap_lons) &lt; 2:\n        print(f\"Warning: Insufficient points for gap {lat_idx + 1}\")\n        continue\n\n    # Split ground track at antimeridian crossings to avoid wrap-around lines\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    gap_segments_all.append(\n        {\n            \"segments\": segments,\n            \"color\": gap_colors[lat_idx],\n            \"label\": gap_label,\n            \"satellite\": sat_name,\n            \"latency\": total_latency,\n        }\n    )\n\n    print(\n        f\"  Gap {lat_idx + 1}: {len(gap_lons)} points, {len(segments)} segments, latency={latency_str}\"\n    )\n\n# Create ground track plot with stations and AOI\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": external_stations, \"color\": \"red\", \"alpha\": 0.2}],\n    gs_cone_altitude=np.min(\n        [prop.semi_major_axis - bh.R_EARTH for prop in capella_props]\n    ),\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\nax = fig_groundtrack.get_axes()[0]\n\n# Plot AOI boundary\naoi_lons = [v[0] for v in aoi_vertices]\naoi_lats = [v[1] for v in aoi_vertices]\nax.plot(\n    aoi_lons,\n    aoi_lats,\n    color=\"green\",\n    linewidth=2,\n    linestyle=\"--\",\n    transform=ccrs.Geodetic(),\n    zorder=8,\n    label=\"US AOI Boundary\",\n)\nax.fill(\n    aoi_lons, aoi_lats, color=\"green\", alpha=0.1, transform=ccrs.Geodetic(), zorder=7\n)\n\n# Plot each latency gap segment\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        if ccrs is not None:\n            ax.plot(\n                lon_seg,\n                lat_seg,\n                color=gap_data[\"color\"],\n                linewidth=2.5,\n                transform=ccrs.Geodetic(),\n                zorder=10,\n                label=gap_data[\"label\"] if i == 0 else \"\",\n            )\n\n# Add legend\nlegend = ax.legend(loc=\"lower left\", fontsize=9)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Capella Constellation: Top 3 Worst Imaging Data Latencies\\n\"\n    f\"KSAT Network ({len(external_stations)} stations outside US, 5\u00b0 elevation)\",\n    fontsize=11,\n)\n\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n</code></pre>"},{"location":"examples/imaging_data_latency.html#see-also","title":"See Also","text":"<ul> <li>Maximum Communications Gap - Related analysis of communication gaps</li> <li>Predicting Ground Contacts - Ground contact analysis example</li> <li>Access Computation - Understanding access windows and constraints</li> <li>AOI Events - AOIEntryEvent and AOIExitEvent API reference</li> <li>KSAT Ground Stations - Ground station dataset documentation</li> </ul>"},{"location":"examples/imaging_opportunities.html","title":"Earth Observation Imaging Opportunities","text":"<p>In this example we'll find upcoming imaging opportunities for the ICEYE constellation over San Francisco (lon: -122.4194, lat: 37.7749), subject to specific imaging constraints.</p>"},{"location":"examples/imaging_opportunities.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the latest TLE data for all active spacecraft and filter it to select just the ICEYE spacecraft:</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n</code></pre> <p>We download all active satellites from CelesTrak and filter for ICEYE spacecraft:</p> <pre><code># Get all active satellites and filter for ICEYE\nall_sats = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\niceye_sats = [sat for sat in all_sats if \"ICEYE\" in sat.get_name().upper()]\n</code></pre>"},{"location":"examples/imaging_opportunities.html#constellation-visualization","title":"Constellation Visualization","text":"<p>Before getting further into the analysis, it's useful to visualize the 3D geometry of the constellation. We propagate each satellite for one orbital period and create a 3D visualization:</p> <pre><code>for sat in iceye_sats:\n    orbital_period = bh.orbital_period(sat.semi_major_axis)\n    sat.propagate_to(sat.epoch + orbital_period)\n\n# Create 3D constellation visualization\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": sat.trajectory,\n            \"mode\": \"lines\",\n            \"line_width\": 1.5,\n            \"label\": sat.get_name(),\n        }\n        for sat in iceye_sats\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the ICEYE constellation orbits in 3D space:</p>"},{"location":"examples/imaging_opportunities.html#target-location-definition","title":"Target Location Definition","text":"<p>We define San Francisco as our imaging target:</p> <pre><code># Define San Francisco target location\nsan_francisco = bh.PointLocation(\n    lon=-122.4194,  # longitude in degrees\n    lat=37.7749,  # latitude in degrees\n    alt=0.0,  # altitude in meters\n).with_name(\"San Francisco\")\n</code></pre>"},{"location":"examples/imaging_opportunities.html#constraint-specification","title":"Constraint Specification","text":"<p>In this case, we want to collect a descending-pass, right-looking image collected from between 35 and 45 degrees off-nadir angle. We compose these requirements using Brahe's constraint system:</p> <pre><code>constraint = bh.ConstraintAll(\n    constraints=[\n        bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING),\n        bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT),\n        bh.OffNadirConstraint(min_off_nadir_deg=35.0, max_off_nadir_deg=45.0),\n    ]\n)\n</code></pre> <p>This creates a composite constraint that requires all three conditions to be satisfied simultaneously:</p> <ul> <li><code>AscDscConstraint</code>: Filters for descending passes only</li> <li><code>LookDirectionConstraint</code>: Requires right-looking geometry</li> <li><code>OffNadirConstraint</code>: Limits imaging angle to 35-45\u00b0 off-nadir</li> </ul>"},{"location":"examples/imaging_opportunities.html#compute-collection-opportunities","title":"Compute Collection Opportunities","text":"<p>Now we'll compute all imaging opportunities between the constellation and San Francisco over a 7-day period:</p> <pre><code>epoch_start = iceye_sats[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for full 7-day period\nfor sat in iceye_sats:\n    sat.propagate_to(epoch_end)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [san_francisco], iceye_sats, epoch_start, epoch_end, constraint\n)\n</code></pre> <p>Below is a table of the first 10 imaging opportunities. Click on any column header to sort:</p> Spacecraft Start Time (UTC) End Time (UTC) Duration (sec) Off-Nadir Angle (deg) ICEYE-X48 2025-12-17 00:38:57 2025-12-17 00:50:05 667.9 39.1 ICEYE-X6 2025-12-17 01:00:29 2025-12-17 01:06:21 352.7 40 ICEYE-X49 2025-12-17 01:15:54 2025-12-17 01:21:59 365.4 40 ICEYE-X47 2025-12-17 01:17:25 2025-12-17 01:23:31 365.4 40 ICEYE-X7 2025-12-17 01:26:07 2025-12-17 01:33:21 434 40 ICEYE-X50 2025-12-17 01:30:17 2025-12-17 01:42:05 708.4 40 ICEYE-X11 2025-12-17 01:38:45 2025-12-17 01:39:26 41.4 44 ICEYE-X11 2025-12-17 02:01:01 2025-12-17 02:04:48 226.4 41.5 ICEYE-X46 2025-12-17 02:10:01 2025-12-17 02:20:13 611.8 40 ICEYE-X51 2025-12-17 02:10:18 2025-12-17 02:20:32 613.6 40"},{"location":"examples/imaging_opportunities.html#full-code-example","title":"Full Code Example","text":"imaging_opportunities.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for ICEYE constellation from CelesTrak\n# ICEYE operates a constellation of SAR (Synthetic Aperture Radar) satellites\nprint(\"Downloading ICEYE constellation TLEs from CelesTrak...\")\nstart_time = time.time()\n\n# Get all active satellites and filter for ICEYE\nall_sats = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\niceye_sats = [sat for sat in all_sats if \"ICEYE\" in sat.get_name().upper()]\n\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(iceye_sats)} ICEYE satellites in {elapsed:.2f} seconds.\")\n\nif len(iceye_sats) == 0:\n    print(\"ERROR: No ICEYE satellites found in active constellation data.\")\n    print(\n        \"This may indicate the satellites are not currently in the CelesTrak database.\"\n    )\n    sys.exit(1)\n\n# Print satellite information\nprint(\"\\nICEYE Constellation:\")\nfor i, sat in enumerate(iceye_sats[:5]):  # Show first 5\n    print(f\"  {i + 1}. {sat.get_name()}\")\n    print(f\"     Epoch: {sat.epoch}\")\n    print(f\"     Semi-major axis: {sat.semi_major_axis / 1000:.1f} km\")\nif len(iceye_sats) &gt; 5:\n    print(f\"  ... and {len(iceye_sats) - 5} more\")\n\n# Propagate all satellites for one orbital period for visualization\nprint(\"\\nPropagating constellation for visualization...\")\nstart_time = time.time()\n\nfor sat in iceye_sats:\n    orbital_period = bh.orbital_period(sat.semi_major_axis)\n    sat.propagate_to(sat.epoch + orbital_period)\n\n# Create 3D constellation visualization\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": sat.trajectory,\n            \"mode\": \"lines\",\n            \"line_width\": 1.5,\n            \"label\": sat.get_name(),\n        }\n        for sat in iceye_sats\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nelapsed = time.time() - start_time\nprint(f\"Created 3D visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagators for access computation\nprint(\"\\nResetting propagators for access computation...\")\nfor sat in iceye_sats:\n    sat.reset()\n\n# Define San Francisco target location\nsan_francisco = bh.PointLocation(\n    lon=-122.4194,  # longitude in degrees\n    lat=37.7749,  # latitude in degrees\n    alt=0.0,  # altitude in meters\n).with_name(\"San Francisco\")\n\nprint(f\"\\nTarget Location: {san_francisco.get_name()}\")\nprint(f\"  Longitude: {san_francisco.lon:.4f}\u00b0\")\nprint(f\"  Latitude: {san_francisco.lat:.4f}\u00b0\")\n\n# Define composite imaging constraint\n# Requirements:\n# - Descending pass only\n# - Right-looking geometry\n# - Off-nadir angle between 35-45 degrees\nprint(\"\\nDefining imaging constraints:\")\nprint(\"  - Descending pass only\")\nprint(\"  - Right-looking geometry\")\nprint(\"  - Off-nadir angle: 35-45 degrees\")\n\nconstraint = bh.ConstraintAll(\n    constraints=[\n        bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING),\n        bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT),\n        bh.OffNadirConstraint(min_off_nadir_deg=35.0, max_off_nadir_deg=45.0),\n    ]\n)\n\n# Compute imaging opportunities over 7-day period\nprint(\"\\nComputing 7-day imaging opportunities...\")\nstart_time = time.time()\n\nepoch_start = iceye_sats[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for full 7-day period\nfor sat in iceye_sats:\n    sat.propagate_to(epoch_end)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [san_francisco], iceye_sats, epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} imaging opportunities in {elapsed:.2f} seconds.\")\n\n# Print sample of imaging opportunities\nprint(\"\\n\" + \"=\" * 90)\nprint(\"Sample Imaging Opportunities (first 10)\")\nprint(\"=\" * 90)\nprint(\n    f\"{'Spacecraft':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;10} {'Off-Nadir':&gt;10}\"\n)\nprint(\"-\" * 90)\nfor i, window in enumerate(windows[:10]):\n    duration_sec = window.duration\n    off_nadir = (\n        window.properties.off_nadir_max - window.properties.off_nadir_min\n    ) / 2 + window.properties.off_nadir_min\n    start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(window.end).split(\".\")[0]\n    print(\n        f\"{window.satellite_name:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_sec:&gt;8.1f} s {off_nadir:&gt;8.1f}\u00b0\"\n    )\nprint(\"=\" * 90)\n\n# Export ~10 imaging opportunities to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_windows.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Spacecraft\",\n            \"Start Time (UTC)\",\n            \"End Time (UTC)\",\n            \"Duration (sec)\",\n            \"Off-Nadir Angle (deg)\",\n        ]\n    )\n    for window in windows[:10]:  # Only export first 10 for documentation\n        duration_sec = window.duration\n        off_nadir = (\n            window.properties.off_nadir_max - window.properties.off_nadir_min\n        ) / 2 + window.properties.off_nadir_min\n        start_str = str(window.start).split(\".\")[0]  # Remove fractional seconds\n        end_str = str(window.end).split(\".\")[0]\n        writer.writerow(\n            [\n                window.satellite_name,\n                start_str,\n                end_str,\n                f\"{duration_sec:.1f}\",\n                f\"{off_nadir:.1f}\",\n            ]\n        )\nprint(f\"\u2713 Exported first 10 imaging opportunities to {csv_path}\")\n\n# Print statistics\nunique_spacecraft = len(set(w.satellite_name for w in windows))\nprint(\"\\nImaging Opportunity Statistics:\")\nprint(f\"  Total opportunities: {len(windows)}\")\nprint(f\"  Spacecraft with opportunities: {unique_spacecraft}\")\nprint(f\"  Average duration: {np.mean([w.duration for w in windows]):.1f} seconds\")\nprint(f\"  Total imaging time: {sum([w.duration for w in windows]):.1f} seconds\")\n</code></pre>"},{"location":"examples/imaging_opportunities.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Locations</li> <li>Constraints</li> </ul>"},{"location":"examples/low_thrust_orbit_raising.html","title":"Low-Thrust Orbit Raising","text":"<p>This example demonstrates modeling a commercial electric propulsion system - the Orbion Aurora Hall-effect thruster - for low-thrust orbit raising. We'll compare performance at the thruster's 100W and 300W power configurations, using extended state dynamics to track propellant mass depletion during the maneuver.</p> <p>Electric propulsion offers significantly higher specific impulse \\(I_{sp}\\) than chemical rockets, translating to dramatic reductions in propellant mass for a given delta-v. However, the trade-off is thrust level: while chemical engines produce newtons to kilonewtons, electric thrusters produce millinewtons. This example shows how to model this realistic scenario using Brahe's <code>NumericalOrbitPropagator</code> with extended state dynamics.</p>"},{"location":"examples/low_thrust_orbit_raising.html#the-orbion-aurora-thruster","title":"The Orbion Aurora Thruster","text":"<p>The Aurora is a Hall-effect thruster designed for small satellites (70+ kg), with different powe configurations of 100W to 300W using xenon propellant.</p> <pre><code>import os\nimport pathlib\nimport sys\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport brahe as bh\n\nbh.initialize_eop()\n</code></pre> <pre><code># Orbion Aurora Hall Thruster Specifications\n# Source 1: https://orbionspace.com/product/\n# Source 2: https://orbionspace.com/wp-content/uploads/2021/08/Orbion_Aurora_Datasheet_2021.pdf\n\n# 100W Configuration\nTHRUST_100W = 5.7e-3  # N (5.7 mN)\nISP_100W = 950.0  # seconds\nMASS_FLOW_100W = 0.53e-6  # kg/s (0.53 mg/s)\n\n# 300W Configuration\nTHRUST_300W = 19.0e-3  # N (19 mN)\nISP_300W = 1370.0  # seconds\nMASS_FLOW_300W = 1.3e-6  # kg/s (1.3 mg/s)\n\n# Standard gravity for Isp calculations\nG0 = 9.80665  # m/s^2\n\n# Verify mass flow rates match thrust equation: mdot = F / (Isp * g0)\nmdot_check_100w = THRUST_100W / (ISP_100W * G0)\nmdot_check_300w = THRUST_300W / (ISP_300W * G0)\n\nprint(\"Orbion Aurora Hall Thruster Specifications:\")\nprint(\"\\n100W Configuration:\")\nprint(f\"  Thrust:     {THRUST_100W * 1e3:.1f} mN\")\nprint(f\"  Isp:        {ISP_100W:.0f} s\")\nprint(f\"  Mass flow:  {MASS_FLOW_100W * 1e6:.2f} mg/s (datasheet)\")\nprint(f\"              {mdot_check_100w * 1e6:.2f} mg/s (computed from F/Isp*g0)\")\n\nprint(\"\\n300W Configuration:\")\nprint(f\"  Thrust:     {THRUST_300W * 1e3:.1f} mN\")\nprint(f\"  Isp:        {ISP_300W:.0f} s\")\nprint(f\"  Mass flow:  {MASS_FLOW_300W * 1e6:.2f} mg/s (datasheet)\")\nprint(f\"              {mdot_check_300w * 1e6:.2f} mg/s (computed from F/Isp*g0)\")\n</code></pre> <p>Key specifications from the Aurora datasheet:</p> Parameter 100W 300W Thrust 5.7 mN 19.0 mN Specific Impulse 950 s 1370 s Mass Flow Rate 0.53 mg/s 1.3 mg/s <p>The mass flow rate follows from the thrust equation:</p> \\[\\dot{m} = \\frac{F}{I_{sp} \\cdot g_0}\\]"},{"location":"examples/low_thrust_orbit_raising.html#spacecraft-configuration","title":"Spacecraft Configuration","text":"<p>We model a 50 kg small satellite bus equipped with the Aurora system:</p> <pre><code># Spacecraft configuration\n# Aurora system specs from datasheet:\n#   Dry mass: 8.3 kg (thruster + PPU + PMA + harness)\n#   Wet mass: 14.3 kg (with max propellant)\n#   Max propellant: 6.0 kg xenon\nSYSTEM_DRY_MASS = 8.3  # kg - Aurora system dry mass\nMAX_PROPELLANT = 6.0  # kg - maximum xenon capacity (14.3 - 8.3)\n\nSPACECRAFT_DRY_MASS = 50.0  # kg - small satellite bus\nTOTAL_DRY_MASS = SPACECRAFT_DRY_MASS + SYSTEM_DRY_MASS  # kg\nPROPELLANT_MASS = 4.0  # kg xenon (partial load for this mission)\n\nINITIAL_WET_MASS = TOTAL_DRY_MASS + PROPELLANT_MASS\n\nprint(\"\\nSpacecraft Configuration:\")\nprint(f\"  Spacecraft bus:      {SPACECRAFT_DRY_MASS:.0f} kg\")\nprint(f\"  Aurora system:       {SYSTEM_DRY_MASS:.1f} kg\")\nprint(f\"  Propellant (Xe):     {PROPELLANT_MASS:.1f} kg (max: {MAX_PROPELLANT:.1f} kg)\")\nprint(f\"  Total dry mass:      {TOTAL_DRY_MASS:.1f} kg\")\nprint(f\"  Total wet mass:      {INITIAL_WET_MASS:.1f} kg\")\n</code></pre> <p>The Aurora system has a dry mass of 8.3 kg and we model a maximum propellant capacity of 6.0 kg xenon.</p>"},{"location":"examples/low_thrust_orbit_raising.html#initial-orbit","title":"Initial Orbit","text":"<p>We start from a circular LEO orbit at 400 km altitude with ISS-like inclination:</p> <pre><code># Create initial epoch and low Earth orbit\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial circular orbit at 400 km altitude\ninitial_altitude = 400e3  # meters\noe_initial = np.array([bh.R_EARTH + initial_altitude, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate_eci = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\n# Orbital period for reference\norbital_period = bh.orbital_period(oe_initial[0])\n\nprint(\"\\nInitial Orbit:\")\nprint(f\"  Altitude:       {initial_altitude / 1e3:.0f} km\")\nprint(f\"  Semi-major axis: {oe_initial[0] / 1e3:.1f} km\")\nprint(f\"  Inclination:    {oe_initial[2]:.1f} deg (ISS-like)\")\nprint(f\"  Orbital period: {orbital_period / 60:.1f} minutes\")\n</code></pre>"},{"location":"examples/low_thrust_orbit_raising.html#extended-state-dynamics","title":"Extended State Dynamics","text":"<p>To track propellant mass during thrusting, we extend the state vector from 6 elements (position + velocity) to 7 elements by adding mass:</p> \\[\\mathbf{x} = [x, y, z, v_x, v_y, v_z, m]^T\\]"},{"location":"examples/low_thrust_orbit_raising.html#dynamics-functions","title":"Dynamics Functions","text":"<p>The <code>NumericalOrbitPropagator</code> accepts two functions for extended state modeling:</p> <ol> <li><code>control_input</code>: Returns thrust acceleration (affects velocity derivatives)</li> <li><code>additional_dynamics</code>: Returns mass flow rate (affects mass derivative)</li> </ol> <pre><code>def create_thrust_dynamics(thrust, mass_flow_rate):\n    \"\"\"Create control and additional dynamics functions for a given thrust configuration.\n\n    The state vector is extended to 7 elements: [x, y, z, vx, vy, vz, mass]\n    - control_input: Returns thrust acceleration in velocity direction\n    - additional_dynamics: Returns mass flow rate\n\n    Args:\n        thrust: Thrust force in Newtons\n        mass_flow_rate: Mass flow rate in kg/s\n\n    Returns:\n        Tuple of (control_input, additional_dynamics) functions\n    \"\"\"\n\n    def control_input(t, state, params):\n        \"\"\"Apply thrust acceleration in the prograde (velocity) direction.\"\"\"\n        dx = np.zeros(len(state))\n\n        # Get current mass from extended state\n        mass = state[6]\n\n        # Compute thrust acceleration\n        velocity = state[3:6]\n        v_mag = np.linalg.norm(velocity)\n        if v_mag &gt; 1e-10:\n            v_hat = velocity / v_mag\n            acceleration = (thrust / mass) * v_hat\n            dx[3:6] = acceleration\n\n        return dx\n\n    def additional_dynamics(t, state, params):\n        \"\"\"Model mass depletion during thrusting.\"\"\"\n        dx = np.zeros(len(state))\n\n        # Mass decreases at the mass flow rate\n        # dm/dt = -mdot (negative because mass is decreasing)\n        dx[6] = -mass_flow_rate\n\n        return dx\n\n    return control_input, additional_dynamics\n</code></pre> <p>The control input computes thrust acceleration using the current mass from the extended state, applying it in the prograde (velocity) direction. The additional dynamics function returns the negative mass flow rate to model propellant consumption.</p>"},{"location":"examples/low_thrust_orbit_raising.html#propagation","title":"Propagation","text":"<p>We create two propagators - one for each power configuration - and propagate for 24 hours of continuous thrusting:</p> <pre><code># Simulation duration: 24 hours of continuous thrusting\nSIMULATION_DURATION = 24 * 3600.0  # seconds\n\nprint(\"\\nSimulation:\")\nprint(f\"  Duration: {SIMULATION_DURATION / 3600:.0f} hours\")\nprint(f\"  Orbits:   ~{SIMULATION_DURATION / orbital_period:.0f}\")\n\n# Extended initial state: [x, y, z, vx, vy, vz, mass]\ninitial_state = np.concatenate([state_eci, [INITIAL_WET_MASS]])\n\n# Two-body force model for clean demonstration\nforce_config = bh.ForceModelConfig.two_body()\n\n# Create dynamics for 100W configuration\ncontrol_100w, dynamics_100w = create_thrust_dynamics(THRUST_100W, MASS_FLOW_100W)\n\n# Create dynamics for 300W configuration\ncontrol_300w, dynamics_300w = create_thrust_dynamics(THRUST_300W, MASS_FLOW_300W)\n\n# Create propagators with extended state\nprint(\"\\nPropagating 100W configuration...\")\nprop_100w = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state.copy(),\n    bh.NumericalPropagationConfig.default(),\n    force_config,\n    additional_dynamics=dynamics_100w,\n    control_input=control_100w,\n)\nprop_100w.propagate_to(epoch + SIMULATION_DURATION)\nprint(\"  Complete!\")\n\nprint(\"Propagating 300W configuration...\")\nprop_300w = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state.copy(),\n    bh.NumericalPropagationConfig.default(),\n    force_config,\n    additional_dynamics=dynamics_300w,\n    control_input=control_300w,\n)\nprop_300w.propagate_to(epoch + SIMULATION_DURATION)\nprint(\"  Complete!\")\n</code></pre>"},{"location":"examples/low_thrust_orbit_raising.html#results-analysis","title":"Results Analysis","text":"<p>After propagation, we extract the full trajectory including the mass state:</p> <pre><code>print(\"\\nAnalyzing results...\")\n\n# Get trajectories (stores full extended state)\ntraj_100w = prop_100w.trajectory\ntraj_300w = prop_300w.trajectory\n\n# Sample trajectories at regular intervals\ndt_sample = 600.0  # 10-minute sampling\ntimes_hours = []\nalt_100w = []\nalt_300w = []\nmass_100w = []\nmass_300w = []\ndv_100w = []\ndv_300w = []\n\n# Track cumulative delta-v\ncumulative_dv_100w = 0.0\ncumulative_dv_300w = 0.0\nlast_t = 0.0\nlast_m_100 = INITIAL_WET_MASS\nlast_m_300 = INITIAL_WET_MASS\n\nt = 0.0\nwhile t &lt;= SIMULATION_DURATION:\n    current_epoch = epoch + t\n\n    # Get full state from trajectory (includes mass as 7th element)\n    state_100 = traj_100w.state(current_epoch)\n    state_300 = traj_300w.state(current_epoch)\n\n    # Extract position and mass\n    r_100 = np.linalg.norm(state_100[:3])\n    r_300 = np.linalg.norm(state_300[:3])\n    m_100 = state_100[6]\n    m_300 = state_300[6]\n\n    # Compute instantaneous delta-v rate and accumulate\n    if t &gt; 0:\n        dt = t - last_t\n        # Use average mass for better accuracy\n        avg_m_100 = (last_m_100 + m_100) / 2\n        avg_m_300 = (last_m_300 + m_300) / 2\n        cumulative_dv_100w += (THRUST_100W / avg_m_100) * dt\n        cumulative_dv_300w += (THRUST_300W / avg_m_300) * dt\n\n    times_hours.append(t / 3600.0)\n    alt_100w.append((r_100 - bh.R_EARTH) / 1e3)\n    alt_300w.append((r_300 - bh.R_EARTH) / 1e3)\n    mass_100w.append(m_100)\n    mass_300w.append(m_300)\n    dv_100w.append(cumulative_dv_100w)\n    dv_300w.append(cumulative_dv_300w)\n\n    last_t = t\n    last_m_100 = m_100\n    last_m_300 = m_300\n    t += dt_sample\n\n# Final results\nfinal_alt_100w = alt_100w[-1]\nfinal_alt_300w = alt_300w[-1]\nfinal_mass_100w = mass_100w[-1]\nfinal_mass_300w = mass_300w[-1]\npropellant_used_100w = INITIAL_WET_MASS - final_mass_100w\npropellant_used_300w = INITIAL_WET_MASS - final_mass_300w\n\n# Theoretical delta-v from Tsiolkovsky\ntheoretical_dv_100w = ISP_100W * G0 * np.log(INITIAL_WET_MASS / final_mass_100w)\ntheoretical_dv_300w = ISP_300W * G0 * np.log(INITIAL_WET_MASS / final_mass_300w)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Results Summary (24 hours continuous thrust)\")\nprint(\"=\" * 60)\nprint(f\"\\n{'Parameter':&lt;30} {'100W':&gt;12} {'300W':&gt;12}\")\nprint(\"-\" * 60)\nprint(\n    f\"{'Initial altitude (km)':&lt;30} {initial_altitude / 1e3:&gt;12.1f} {initial_altitude / 1e3:&gt;12.1f}\"\n)\nprint(f\"{'Final altitude (km)':&lt;30} {final_alt_100w:&gt;12.1f} {final_alt_300w:&gt;12.1f}\")\nprint(\n    f\"{'Altitude gain (km)':&lt;30} {final_alt_100w - initial_altitude / 1e3:&gt;12.1f} {final_alt_300w - initial_altitude / 1e3:&gt;12.1f}\"\n)\nprint(\n    f\"{'Propellant used (g)':&lt;30} {propellant_used_100w * 1e3:&gt;12.1f} {propellant_used_300w * 1e3:&gt;12.1f}\"\n)\nprint(f\"{'Final mass (kg)':&lt;30} {final_mass_100w:&gt;12.2f} {final_mass_300w:&gt;12.2f}\")\nprint(f\"{'Delta-v applied (m/s)':&lt;30} {dv_100w[-1]:&gt;12.1f} {dv_300w[-1]:&gt;12.1f}\")\nprint(\n    f\"{'Theoretical delta-v (m/s)':&lt;30} {theoretical_dv_100w:&gt;12.1f} {theoretical_dv_300w:&gt;12.1f}\"\n)\nprint(\n    f\"{'Thrust-to-weight (mN/kg)':&lt;30} {THRUST_100W * 1e3 / INITIAL_WET_MASS:&gt;12.3f} {THRUST_300W * 1e3 / INITIAL_WET_MASS:&gt;12.3f}\"\n)\n</code></pre> <p>The Tsiolkovsky rocket equation provides a theoretical check on our mass tracking:</p> \\[\\Delta v = I_{sp} \\cdot g_0 \\cdot \\ln\\left(\\frac{m_0}{m_f}\\right)\\]"},{"location":"examples/low_thrust_orbit_raising.html#performance-comparison","title":"Performance Comparison","text":"<p>The following plots compare the 100W and 300W configurations over 24 hours of continuous thrust:</p> <pre><code># Create comparison plots\nfig = make_subplots(\n    rows=2,\n    cols=2,\n    subplot_titles=(\n        \"Altitude Over Time\",\n        \"Fuel Mass Remaining\",\n        \"Cumulative Delta-V\",\n        \"Altitude vs Propellant Used\",\n    ),\n    vertical_spacing=0.15,\n    horizontal_spacing=0.12,\n)\n\n# Color scheme\ncolor_100w = \"blue\"\ncolor_300w = \"red\"\n\n# Altitude over time\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=alt_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W (5.7 mN)\",\n    ),\n    row=1,\n    col=1,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=alt_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W (19 mN)\",\n    ),\n    row=1,\n    col=1,\n)\n\n# Fuel mass (propellant remaining)\nfuel_100w = [m - TOTAL_DRY_MASS for m in mass_100w]\nfuel_300w = [m - TOTAL_DRY_MASS for m in mass_300w]\n\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=fuel_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=1,\n    col=2,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=fuel_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=1,\n    col=2,\n)\n\n# Cumulative delta-v\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=dv_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=1,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=dv_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=1,\n)\n\n# Altitude vs propellant used (efficiency comparison)\nprop_used_100w = [INITIAL_WET_MASS - m for m in mass_100w]\nprop_used_300w = [INITIAL_WET_MASS - m for m in mass_300w]\n\nfig.add_trace(\n    go.Scatter(\n        x=[p * 1e3 for p in prop_used_100w],  # Convert to grams\n        y=alt_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=2,\n)\nfig.add_trace(\n    go.Scatter(\n        x=[p * 1e3 for p in prop_used_300w],  # Convert to grams\n        y=alt_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=2,\n)\n\n# Update axes labels\nfig.update_xaxes(title_text=\"Time (hours)\", row=1, col=1)\nfig.update_yaxes(title_text=\"Altitude (km)\", row=1, col=1)\n\nfig.update_xaxes(title_text=\"Time (hours)\", row=1, col=2)\nfig.update_yaxes(title_text=\"Fuel Mass (kg)\", row=1, col=2)\n\nfig.update_xaxes(title_text=\"Time (hours)\", row=2, col=1)\nfig.update_yaxes(title_text=\"Delta-V (m/s)\", row=2, col=1)\n\nfig.update_xaxes(title_text=\"Propellant Used (g)\", row=2, col=2)\nfig.update_yaxes(title_text=\"Altitude (km)\", row=2, col=2)\n\nfig.update_layout(\n    title=\"Orbion Aurora Performance Comparison: 100W vs 300W\",\n    showlegend=True,\n    legend=dict(x=0.02, y=0.98),\n    height=800,\n    margin=dict(l=60, r=40, t=80, b=100),\n)\n</code></pre>"},{"location":"examples/low_thrust_orbit_raising.html#full-code-example","title":"Full Code Example","text":"low_thrust_orbit_raising.py<pre><code>import os\nimport pathlib\nimport sys\n\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Orbion Aurora Hall Thruster Specifications\n# Source 1: https://orbionspace.com/product/\n# Source 2: https://orbionspace.com/wp-content/uploads/2021/08/Orbion_Aurora_Datasheet_2021.pdf\n\n# 100W Configuration\nTHRUST_100W = 5.7e-3  # N (5.7 mN)\nISP_100W = 950.0  # seconds\nMASS_FLOW_100W = 0.53e-6  # kg/s (0.53 mg/s)\n\n# 300W Configuration\nTHRUST_300W = 19.0e-3  # N (19 mN)\nISP_300W = 1370.0  # seconds\nMASS_FLOW_300W = 1.3e-6  # kg/s (1.3 mg/s)\n\n# Standard gravity for Isp calculations\nG0 = 9.80665  # m/s^2\n\n# Verify mass flow rates match thrust equation: mdot = F / (Isp * g0)\nmdot_check_100w = THRUST_100W / (ISP_100W * G0)\nmdot_check_300w = THRUST_300W / (ISP_300W * G0)\n\nprint(\"Orbion Aurora Hall Thruster Specifications:\")\nprint(\"\\n100W Configuration:\")\nprint(f\"  Thrust:     {THRUST_100W * 1e3:.1f} mN\")\nprint(f\"  Isp:        {ISP_100W:.0f} s\")\nprint(f\"  Mass flow:  {MASS_FLOW_100W * 1e6:.2f} mg/s (datasheet)\")\nprint(f\"              {mdot_check_100w * 1e6:.2f} mg/s (computed from F/Isp*g0)\")\n\nprint(\"\\n300W Configuration:\")\nprint(f\"  Thrust:     {THRUST_300W * 1e3:.1f} mN\")\nprint(f\"  Isp:        {ISP_300W:.0f} s\")\nprint(f\"  Mass flow:  {MASS_FLOW_300W * 1e6:.2f} mg/s (datasheet)\")\nprint(f\"              {mdot_check_300w * 1e6:.2f} mg/s (computed from F/Isp*g0)\")\n\n# Spacecraft configuration\n# Aurora system specs from datasheet:\n#   Dry mass: 8.3 kg (thruster + PPU + PMA + harness)\n#   Wet mass: 14.3 kg (with max propellant)\n#   Max propellant: 6.0 kg xenon\nSYSTEM_DRY_MASS = 8.3  # kg - Aurora system dry mass\nMAX_PROPELLANT = 6.0  # kg - maximum xenon capacity (14.3 - 8.3)\n\nSPACECRAFT_DRY_MASS = 50.0  # kg - small satellite bus\nTOTAL_DRY_MASS = SPACECRAFT_DRY_MASS + SYSTEM_DRY_MASS  # kg\nPROPELLANT_MASS = 4.0  # kg xenon (partial load for this mission)\n\nINITIAL_WET_MASS = TOTAL_DRY_MASS + PROPELLANT_MASS\n\nprint(\"\\nSpacecraft Configuration:\")\nprint(f\"  Spacecraft bus:      {SPACECRAFT_DRY_MASS:.0f} kg\")\nprint(f\"  Aurora system:       {SYSTEM_DRY_MASS:.1f} kg\")\nprint(f\"  Propellant (Xe):     {PROPELLANT_MASS:.1f} kg (max: {MAX_PROPELLANT:.1f} kg)\")\nprint(f\"  Total dry mass:      {TOTAL_DRY_MASS:.1f} kg\")\nprint(f\"  Total wet mass:      {INITIAL_WET_MASS:.1f} kg\")\n\n# Create initial epoch and low Earth orbit\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial circular orbit at 400 km altitude\ninitial_altitude = 400e3  # meters\noe_initial = np.array([bh.R_EARTH + initial_altitude, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate_eci = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\n# Orbital period for reference\norbital_period = bh.orbital_period(oe_initial[0])\n\nprint(\"\\nInitial Orbit:\")\nprint(f\"  Altitude:       {initial_altitude / 1e3:.0f} km\")\nprint(f\"  Semi-major axis: {oe_initial[0] / 1e3:.1f} km\")\nprint(f\"  Inclination:    {oe_initial[2]:.1f} deg (ISS-like)\")\nprint(f\"  Orbital period: {orbital_period / 60:.1f} minutes\")\n\n\ndef create_thrust_dynamics(thrust, mass_flow_rate):\n    \"\"\"Create control and additional dynamics functions for a given thrust configuration.\n\n    The state vector is extended to 7 elements: [x, y, z, vx, vy, vz, mass]\n    - control_input: Returns thrust acceleration in velocity direction\n    - additional_dynamics: Returns mass flow rate\n\n    Args:\n        thrust: Thrust force in Newtons\n        mass_flow_rate: Mass flow rate in kg/s\n\n    Returns:\n        Tuple of (control_input, additional_dynamics) functions\n    \"\"\"\n\n    def control_input(t, state, params):\n        \"\"\"Apply thrust acceleration in the prograde (velocity) direction.\"\"\"\n        dx = np.zeros(len(state))\n\n        # Get current mass from extended state\n        mass = state[6]\n\n        # Compute thrust acceleration\n        velocity = state[3:6]\n        v_mag = np.linalg.norm(velocity)\n        if v_mag &gt; 1e-10:\n            v_hat = velocity / v_mag\n            acceleration = (thrust / mass) * v_hat\n            dx[3:6] = acceleration\n\n        return dx\n\n    def additional_dynamics(t, state, params):\n        \"\"\"Model mass depletion during thrusting.\"\"\"\n        dx = np.zeros(len(state))\n\n        # Mass decreases at the mass flow rate\n        # dm/dt = -mdot (negative because mass is decreasing)\n        dx[6] = -mass_flow_rate\n\n        return dx\n\n    return control_input, additional_dynamics\n\n\n\n# Simulation duration: 24 hours of continuous thrusting\nSIMULATION_DURATION = 24 * 3600.0  # seconds\n\nprint(\"\\nSimulation:\")\nprint(f\"  Duration: {SIMULATION_DURATION / 3600:.0f} hours\")\nprint(f\"  Orbits:   ~{SIMULATION_DURATION / orbital_period:.0f}\")\n\n# Extended initial state: [x, y, z, vx, vy, vz, mass]\ninitial_state = np.concatenate([state_eci, [INITIAL_WET_MASS]])\n\n# Two-body force model for clean demonstration\nforce_config = bh.ForceModelConfig.two_body()\n\n# Create dynamics for 100W configuration\ncontrol_100w, dynamics_100w = create_thrust_dynamics(THRUST_100W, MASS_FLOW_100W)\n\n# Create dynamics for 300W configuration\ncontrol_300w, dynamics_300w = create_thrust_dynamics(THRUST_300W, MASS_FLOW_300W)\n\n# Create propagators with extended state\nprint(\"\\nPropagating 100W configuration...\")\nprop_100w = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state.copy(),\n    bh.NumericalPropagationConfig.default(),\n    force_config,\n    additional_dynamics=dynamics_100w,\n    control_input=control_100w,\n)\nprop_100w.propagate_to(epoch + SIMULATION_DURATION)\nprint(\"  Complete!\")\n\nprint(\"Propagating 300W configuration...\")\nprop_300w = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state.copy(),\n    bh.NumericalPropagationConfig.default(),\n    force_config,\n    additional_dynamics=dynamics_300w,\n    control_input=control_300w,\n)\nprop_300w.propagate_to(epoch + SIMULATION_DURATION)\nprint(\"  Complete!\")\n\nprint(\"\\nAnalyzing results...\")\n\n# Get trajectories (stores full extended state)\ntraj_100w = prop_100w.trajectory\ntraj_300w = prop_300w.trajectory\n\n# Sample trajectories at regular intervals\ndt_sample = 600.0  # 10-minute sampling\ntimes_hours = []\nalt_100w = []\nalt_300w = []\nmass_100w = []\nmass_300w = []\ndv_100w = []\ndv_300w = []\n\n# Track cumulative delta-v\ncumulative_dv_100w = 0.0\ncumulative_dv_300w = 0.0\nlast_t = 0.0\nlast_m_100 = INITIAL_WET_MASS\nlast_m_300 = INITIAL_WET_MASS\n\nt = 0.0\nwhile t &lt;= SIMULATION_DURATION:\n    current_epoch = epoch + t\n\n    # Get full state from trajectory (includes mass as 7th element)\n    state_100 = traj_100w.state(current_epoch)\n    state_300 = traj_300w.state(current_epoch)\n\n    # Extract position and mass\n    r_100 = np.linalg.norm(state_100[:3])\n    r_300 = np.linalg.norm(state_300[:3])\n    m_100 = state_100[6]\n    m_300 = state_300[6]\n\n    # Compute instantaneous delta-v rate and accumulate\n    if t &gt; 0:\n        dt = t - last_t\n        # Use average mass for better accuracy\n        avg_m_100 = (last_m_100 + m_100) / 2\n        avg_m_300 = (last_m_300 + m_300) / 2\n        cumulative_dv_100w += (THRUST_100W / avg_m_100) * dt\n        cumulative_dv_300w += (THRUST_300W / avg_m_300) * dt\n\n    times_hours.append(t / 3600.0)\n    alt_100w.append((r_100 - bh.R_EARTH) / 1e3)\n    alt_300w.append((r_300 - bh.R_EARTH) / 1e3)\n    mass_100w.append(m_100)\n    mass_300w.append(m_300)\n    dv_100w.append(cumulative_dv_100w)\n    dv_300w.append(cumulative_dv_300w)\n\n    last_t = t\n    last_m_100 = m_100\n    last_m_300 = m_300\n    t += dt_sample\n\n# Final results\nfinal_alt_100w = alt_100w[-1]\nfinal_alt_300w = alt_300w[-1]\nfinal_mass_100w = mass_100w[-1]\nfinal_mass_300w = mass_300w[-1]\npropellant_used_100w = INITIAL_WET_MASS - final_mass_100w\npropellant_used_300w = INITIAL_WET_MASS - final_mass_300w\n\n# Theoretical delta-v from Tsiolkovsky\ntheoretical_dv_100w = ISP_100W * G0 * np.log(INITIAL_WET_MASS / final_mass_100w)\ntheoretical_dv_300w = ISP_300W * G0 * np.log(INITIAL_WET_MASS / final_mass_300w)\n\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Results Summary (24 hours continuous thrust)\")\nprint(\"=\" * 60)\nprint(f\"\\n{'Parameter':&lt;30} {'100W':&gt;12} {'300W':&gt;12}\")\nprint(\"-\" * 60)\nprint(\n    f\"{'Initial altitude (km)':&lt;30} {initial_altitude / 1e3:&gt;12.1f} {initial_altitude / 1e3:&gt;12.1f}\"\n)\nprint(f\"{'Final altitude (km)':&lt;30} {final_alt_100w:&gt;12.1f} {final_alt_300w:&gt;12.1f}\")\nprint(\n    f\"{'Altitude gain (km)':&lt;30} {final_alt_100w - initial_altitude / 1e3:&gt;12.1f} {final_alt_300w - initial_altitude / 1e3:&gt;12.1f}\"\n)\nprint(\n    f\"{'Propellant used (g)':&lt;30} {propellant_used_100w * 1e3:&gt;12.1f} {propellant_used_300w * 1e3:&gt;12.1f}\"\n)\nprint(f\"{'Final mass (kg)':&lt;30} {final_mass_100w:&gt;12.2f} {final_mass_300w:&gt;12.2f}\")\nprint(f\"{'Delta-v applied (m/s)':&lt;30} {dv_100w[-1]:&gt;12.1f} {dv_300w[-1]:&gt;12.1f}\")\nprint(\n    f\"{'Theoretical delta-v (m/s)':&lt;30} {theoretical_dv_100w:&gt;12.1f} {theoretical_dv_300w:&gt;12.1f}\"\n)\nprint(\n    f\"{'Thrust-to-weight (mN/kg)':&lt;30} {THRUST_100W * 1e3 / INITIAL_WET_MASS:&gt;12.3f} {THRUST_300W * 1e3 / INITIAL_WET_MASS:&gt;12.3f}\"\n)\n\n# Create comparison plots\nfig = make_subplots(\n    rows=2,\n    cols=2,\n    subplot_titles=(\n        \"Altitude Over Time\",\n        \"Fuel Mass Remaining\",\n        \"Cumulative Delta-V\",\n        \"Altitude vs Propellant Used\",\n    ),\n    vertical_spacing=0.15,\n    horizontal_spacing=0.12,\n)\n\n# Color scheme\ncolor_100w = \"blue\"\ncolor_300w = \"red\"\n\n# Altitude over time\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=alt_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W (5.7 mN)\",\n    ),\n    row=1,\n    col=1,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=alt_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W (19 mN)\",\n    ),\n    row=1,\n    col=1,\n)\n\n# Fuel mass (propellant remaining)\nfuel_100w = [m - TOTAL_DRY_MASS for m in mass_100w]\nfuel_300w = [m - TOTAL_DRY_MASS for m in mass_300w]\n\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=fuel_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=1,\n    col=2,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=fuel_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=1,\n    col=2,\n)\n\n# Cumulative delta-v\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=dv_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=1,\n)\nfig.add_trace(\n    go.Scatter(\n        x=times_hours,\n        y=dv_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=1,\n)\n\n# Altitude vs propellant used (efficiency comparison)\nprop_used_100w = [INITIAL_WET_MASS - m for m in mass_100w]\nprop_used_300w = [INITIAL_WET_MASS - m for m in mass_300w]\n\nfig.add_trace(\n    go.Scatter(\n        x=[p * 1e3 for p in prop_used_100w],  # Convert to grams\n        y=alt_100w,\n        mode=\"lines\",\n        line=dict(color=color_100w, width=2),\n        name=\"100W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=2,\n)\nfig.add_trace(\n    go.Scatter(\n        x=[p * 1e3 for p in prop_used_300w],  # Convert to grams\n        y=alt_300w,\n        mode=\"lines\",\n        line=dict(color=color_300w, width=2),\n        name=\"300W\",\n        showlegend=False,\n    ),\n    row=2,\n    col=2,\n)\n\n# Update axes labels\nfig.update_xaxes(title_text=\"Time (hours)\", row=1, col=1)\nfig.update_yaxes(title_text=\"Altitude (km)\", row=1, col=1)\n\nfig.update_xaxes(title_text=\"Time (hours)\", row=1, col=2)\nfig.update_yaxes(title_text=\"Fuel Mass (kg)\", row=1, col=2)\n\nfig.update_xaxes(title_text=\"Time (hours)\", row=2, col=1)\nfig.update_yaxes(title_text=\"Delta-V (m/s)\", row=2, col=1)\n\nfig.update_xaxes(title_text=\"Propellant Used (g)\", row=2, col=2)\nfig.update_yaxes(title_text=\"Altitude (km)\", row=2, col=2)\n\nfig.update_layout(\n    title=\"Orbion Aurora Performance Comparison: 100W vs 300W\",\n    showlegend=True,\n    legend=dict(x=0.02, y=0.98),\n    height=800,\n    margin=dict(l=60, r=40, t=80, b=100),\n)\n\n# Validation\nassert final_alt_300w &gt; final_alt_100w, \"300W should raise orbit faster than 100W\"\nassert propellant_used_300w &gt; propellant_used_100w, \"300W should use more propellant\"\nassert final_mass_100w &gt; TOTAL_DRY_MASS, \"Should not exhaust propellant at 100W\"\nassert final_mass_300w &gt; TOTAL_DRY_MASS, \"Should not exhaust propellant at 300W\"\n\nprint(\"\\nExample validated successfully!\")\n</code></pre>"},{"location":"examples/low_thrust_orbit_raising.html#see-also","title":"See Also","text":"<ul> <li>Extending Spacecraft State - Mass and battery tracking fundamentals</li> <li>LEO to GEO Hohmann Transfer - Impulsive maneuver comparison</li> <li>Impulsive and Continuous Control - Control implementation details</li> <li>Numerical Orbit Propagation - Propagator fundamentals</li> </ul>"},{"location":"examples/max_communications_gap.html","title":"Maximum Communications Gap","text":"<p>In this example we'll analyze the communication gaps between a satellite constellation and supporting ground station network. For this work we'll use the Umbra constellation and 5 KSAT ground stations (Svalbard, Punta Arenas, Hartebeesthoek, Awarua, and Athens).</p> <p>The maximum contact gap is a significant factor in the reactivity (speed from request to uplink) and latency (time from collection to delivery) for satellite imaging constellations.</p>"},{"location":"examples/max_communications_gap.html#setup","title":"Setup","text":"<p>First, we'll import the necessary libraries, initialize Earth orientation parameters, download the latest TLE data for all active spacecraft, and filter to select just the Umbra satellites:</p> <pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n</code></pre> <p>We download all active satellite TLEs from CelesTrak as propagators and filter for satellites with \"UMBRA\" in their name:</p> <pre><code>all_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Umbra satellites (name contains \"UMBRA\")\numbra_props = [prop for prop in all_active_props if \"UMBRA\" in prop.get_name().upper()]\n</code></pre> <p>Next, we load the 5 specific KSAT ground stations that will support communications:</p> <pre><code>all_ksat = bh.datasets.groundstations.load(\"ksat\")\n\n# Filter for the 5 specific stations mentioned in the problem\nstation_names = [\"Svalbard\", \"Punta Arenas\", \"Hartebeesthoek\", \"Awarua\", \"Athens\"]\nksat_stations = [s for s in all_ksat if s.get_name() in station_names]\n</code></pre>"},{"location":"examples/max_communications_gap.html#constellation-visualization","title":"Constellation Visualization","text":"<p>Before getting further into the analysis, it's useful to visualize the 3D geometry of the constellation. We propagate each satellite for one orbit and plot their trajectories:</p> <pre><code>for prop in umbra_props:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\n\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in umbra_props\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the complete Umbra constellation orbiting Earth:</p>"},{"location":"examples/max_communications_gap.html#access-computation","title":"Access Computation","text":"<p>To figure out the contact gaps, we first need to compute all ground contacts over the 7-day propagation window. We reset the propagators and compute access windows with a 5\u00b0 minimum elevation constraint:</p> <pre><code># Reset all propagators\nfor prop in umbra_props:\n    prop.reset()\n\n# Define analysis period (7 days from first satellite's epoch)\nepoch_start = umbra_props[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for 7 days\nfor prop in umbra_props:\n    prop.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    ksat_stations, umbra_props, epoch_start, epoch_end, constraint\n)\n</code></pre>"},{"location":"examples/max_communications_gap.html#max-gap-computation","title":"Max Gap Computation","text":"<p>Next we'll compute the contact gaps over the course of the simulation. The contact gap is defined as the time between the last contact for a spacecraft and the next contact for that spacecraft. The gap is always computed on a per-spacecraft basis:</p> <pre><code># Group windows by spacecraft\nspacecraft_windows = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in spacecraft_windows:\n        spacecraft_windows[sat_name] = []\n    spacecraft_windows[sat_name].append(window)\n\n# Sort each spacecraft's windows by start time\nfor sat_name in spacecraft_windows:\n    spacecraft_windows[sat_name].sort(key=lambda w: w.start.jd())\n\n# Compute gaps between consecutive contacts\ngaps = []\nfor sat_name, sat_windows in spacecraft_windows.items():\n    for i in range(len(sat_windows) - 1):\n        gap_start = sat_windows[i].end\n        gap_end = sat_windows[i + 1].start\n        gap_duration = gap_end - gap_start  # Duration in seconds\n\n        gaps.append(\n            {\n                \"spacecraft\": sat_name,\n                \"gap_start\": gap_start,\n                \"gap_end\": gap_end,\n                \"duration\": gap_duration,\n                \"last_station\": sat_windows[i].location_name,\n                \"next_station\": sat_windows[i + 1].location_name,\n            }\n        )\n\n# Sort gaps by duration (longest first)\ngaps.sort(key=lambda g: g[\"duration\"], reverse=True)\n</code></pre> <p>The 10 longest contact gaps are shown below:</p> Spacecraft Gap Start (UTC) Gap End (UTC) Duration Last Station Next Station UMBRA-08 2025-12-18 23:42:56 2025-12-19 04:26:26 4h 43m 30s Awarua Punta Arenas UMBRA-08 2025-12-19 23:38:06 2025-12-20 04:20:51 4h 42m 45s Awarua Punta Arenas UMBRA-08 2025-12-20 23:28:18 2025-12-21 04:10:08 4h 41m 50s Awarua Punta Arenas UMBRA-08 2025-12-21 23:12:04 2025-12-22 03:52:56 4h 40m 52s Awarua Punta Arenas UMBRA-08 2025-12-18 04:34:09 2025-12-18 08:33:20 3h 59m 11s Punta Arenas Hartebeesthoek UMBRA-08 2025-12-19 04:32:28 2025-12-19 08:31:16 3h 58m 48s Punta Arenas Hartebeesthoek UMBRA-08 2025-12-20 04:26:41 2025-12-20 08:25:09 3h 58m 28s Punta Arenas Hartebeesthoek UMBRA-08 2025-12-23 04:58:25 2025-12-23 08:53:49 3h 55m 24s Punta Arenas Hartebeesthoek UMBRA-08 2025-12-17 04:32:34 2025-12-17 08:07:46 3h 35m 12s Punta Arenas Svalbard UMBRA-08 2025-12-22 05:24:32 2025-12-22 08:58:23 3h 33m 50s Punta Arenas Svalbard <p>The distribution of gaps for the constellation is shown in this histogram:</p> <pre><code>\n</code></pre> <p>To better understand what percentage of gaps fall below a certain duration, we create a cumulative distribution plot. This shows the percentage of gaps that are less than or equal to each duration value:</p> <pre><code># Sort gap durations and compute cumulative percentages\nsorted_gap_durations_hours = sorted(gap_durations_hours)\ncumulative_percentages = [\n    (i + 1) / len(sorted_gap_durations_hours) * 100\n    for i in range(len(sorted_gap_durations_hours))\n]\n\n# Create cumulative distribution figure\nfig_cumulative = go.Figure(\n    data=[\n        go.Scatter(\n            x=sorted_gap_durations_hours,\n            y=cumulative_percentages,\n            mode=\"lines\",\n            line=dict(color=\"steelblue\", width=2.5),\n            hovertemplate=\"Gap Duration: %{x:.2f} hours&lt;br&gt;Cumulative: %{y:.1f}%&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\n# Add reference lines for key percentiles\npercentile_values = {\n    25: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.25)],\n    50: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.50)],\n    75: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.75)],\n    90: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.90)],\n}\n\nshapes = []\nannotations = []\nfor percentile, value in percentile_values.items():\n    # Add horizontal line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=0,\n            x1=value,\n            y0=percentile,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add vertical line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=value,\n            x1=value,\n            y0=0,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add annotation\n    annotations.append(\n        dict(\n            x=value,\n            y=percentile,\n            text=f\"P{percentile}: {value:.2f}h\",\n            showarrow=False,\n            xanchor=\"left\",\n            yanchor=\"bottom\",\n            xshift=5,\n            yshift=5,\n            font=dict(size=9, color=\"gray\"),\n        )\n    )\n\nfig_cumulative.update_layout(\n    title=\"Umbra Constellation Cumulative Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Cumulative Percentage (%)\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    shapes=shapes,\n    annotations=annotations,\n    yaxis=dict(range=[0, 105]),\n)\n</code></pre> <p>The cumulative distribution plot includes reference lines at the 25th, 50th, 75th, and 90th percentiles, making it easy to determine what fraction of gaps are below a specific value.</p>"},{"location":"examples/max_communications_gap.html#contact-gap-visualization","title":"Contact Gap Visualization","text":"<p>Finally, we'll visualize the 3 longest gaps on a ground track plot to see where they occur. For each gap, we extract the satellite's ground track during that time period and plot it as a colored segment. We also interpolate to the \u00b1180\u00b0 edges to avoid visual gaps at the antimeridian. This type of visualization can be helpful in understanding ground network design and where additional ground stations might help:</p> <pre><code># Get the top 3 gaps\ntop_3_gaps = gaps[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\n# For each gap, we need to extract the ground track segment during that period\n# We'll need to get the propagator for each gap's spacecraft\ngap_segments_all = []\n\nfor gap_idx, gap in enumerate(top_3_gaps):\n    # Create label with spacecraft name and station transition\n    gap_label = f\"{gap['spacecraft']}, {gap['last_station']} \u2192 {gap['next_station']}\"\n\n    # Find the propagator for this gap's spacecraft\n    sat_prop = None\n    for prop in umbra_props:\n        if prop.get_name() == gap[\"spacecraft\"]:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {gap['spacecraft']}\")\n        continue\n\n    # Get states and epochs from the propagator's trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ground track points during this gap period\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if gap[\"gap_start\"] &lt;= ep &lt;= gap[\"gap_end\"]:\n            # Convert to geodetic coordinates\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    # Split ground track at antimeridian crossings for proper plotting\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    # Interpolate segments to the edge at \u00b1180\u00b0 to avoid visual gaps\n    # When a track crosses the antimeridian, add interpolated edge points\n    interpolated_segments = []\n    for seg_idx, (lon_seg, lat_seg) in enumerate(segments):\n        lon_list = list(lon_seg)\n        lat_list = list(lat_seg)\n\n        # Check if this segment needs edge interpolation\n        # If first point is not at edge but previous segment exists, interpolate start\n        if seg_idx &gt; 0 and len(lon_list) &gt; 0:\n            prev_lon, prev_lat = (\n                segments[seg_idx - 1][0][-1],\n                segments[seg_idx - 1][1][-1],\n            )\n            curr_lon, curr_lat = lon_list[0], lat_list[0]\n\n            # Check if there was an antimeridian crossing\n            if abs(curr_lon - prev_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if prev_lon &gt; 0:  # Previous segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon + 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n                else:  # Previous segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon - 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n\n        # Check if segment should be extended to the edge at the end\n        if seg_idx &lt; len(segments) - 1 and len(lon_list) &gt; 0:\n            curr_lon, curr_lat = lon_list[-1], lat_list[-1]\n            next_lon, next_lat = (\n                segments[seg_idx + 1][0][0],\n                segments[seg_idx + 1][1][0],\n            )\n\n            # Check if there will be an antimeridian crossing\n            if abs(next_lon - curr_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if curr_lon &gt; 0:  # Current segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon + 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n                else:  # Current segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon - 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n\n        interpolated_segments.append((lon_list, lat_list))\n\n    gap_segments_all.append(\n        {\n            \"segments\": interpolated_segments,\n            \"color\": gap_colors[gap_idx],\n            \"label\": gap_label,\n            \"spacecraft\": gap[\"spacecraft\"],\n            \"duration\": gap[\"duration\"],\n        }\n    )\n\n    print(\n        f\"  Gap {gap_idx + 1}: {len(gap_lons)} points, {len(interpolated_segments)} segments\"\n    )\n\n# Create base plot with KSAT stations only (matplotlib backend for SVG output)\n\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": ksat_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=500e3,  # Approximate Umbra altitude\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot each gap segment\nax = fig_groundtrack.get_axes()[0]\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        ax.plot(\n            lon_seg,\n            lat_seg,\n            color=gap_data[\"color\"],\n            linewidth=1.5,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=gap_data[\"label\"] if i == 0 else \"\",\n        )\n\n# Add legend with high zorder to render on top\nlegend = ax.legend(loc=\"lower left\", fontsize=10)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Umbra Constellation: Top 3 Longest Communication Gaps\\n\"\n    \"KSAT Network (5 stations, 5\u00b0 elevation)\",\n    fontsize=12,\n)\n</code></pre>"},{"location":"examples/max_communications_gap.html#full-code-example","title":"Full Code Example","text":"max_communications_gap.py<pre><code>import time\nimport csv\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Download TLE data for all active satellites as propagators and filter for Umbra\nprint(\"Downloading active satellite TLEs from CelesTrak...\")\nstart_time = time.time()\nall_active_props = bh.datasets.celestrak.get_tles_as_propagators(\"active\", 60.0)\n\n# Filter for Umbra satellites (name contains \"UMBRA\")\numbra_props = [prop for prop in all_active_props if \"UMBRA\" in prop.get_name().upper()]\nprint(f\"Found {len(umbra_props)} Umbra satellites\")\nelapsed = time.time() - start_time\n\n# Load specific KSAT ground stations\nprint(\"\\nLoading KSAT ground stations...\")\nstart_time = time.time()\nall_ksat = bh.datasets.groundstations.load(\"ksat\")\n\n# Filter for the 5 specific stations mentioned in the problem\nstation_names = [\"Svalbard\", \"Punta Arenas\", \"Hartebeesthoek\", \"Awarua\", \"Athens\"]\nksat_stations = [s for s in all_ksat if s.get_name() in station_names]\nelapsed = time.time() - start_time\nprint(f\"Loaded {len(ksat_stations)} KSAT ground stations in {elapsed:.2f} seconds:\")\nfor station in ksat_stations:\n    print(f\"  - {station.get_name()}\")\n\n# Create 3D constellation visualization\nprint(\"\\nPropagating Umbra satellites for one orbit each...\")\nstart_time = time.time()\nfor prop in umbra_props:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\n\nfig_3d = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in umbra_props\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nelapsed = time.time() - start_time\nprint(f\"Created 3D visualization in {elapsed:.2f} seconds.\")\n\n# Reset propagators and compute 7-day access windows\nprint(\"\\nComputing 7-day ground contacts...\")\nstart_time = time.time()\n\n# Reset all propagators\nfor prop in umbra_props:\n    prop.reset()\n\n# Define analysis period (7 days from first satellite's epoch)\nepoch_start = umbra_props[0].epoch\nepoch_end = epoch_start + 7 * 86400.0  # 7 days in seconds\n\n# Propagate all satellites for 7 days\nfor prop in umbra_props:\n    prop.propagate_to(epoch_end)\n\n# Compute access windows with 5 degree minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\nwindows = bh.location_accesses(\n    ksat_stations, umbra_props, epoch_start, epoch_end, constraint\n)\nelapsed = time.time() - start_time\nprint(f\"Computed {len(windows)} contact windows in {elapsed:.2f} seconds.\")\n\n# Compute communication gaps per spacecraft\nprint(\"\\nComputing communication gaps...\")\nstart_time = time.time()\n\n# Group windows by spacecraft\nspacecraft_windows = {}\nfor window in windows:\n    sat_name = window.satellite_name\n    if sat_name not in spacecraft_windows:\n        spacecraft_windows[sat_name] = []\n    spacecraft_windows[sat_name].append(window)\n\n# Sort each spacecraft's windows by start time\nfor sat_name in spacecraft_windows:\n    spacecraft_windows[sat_name].sort(key=lambda w: w.start.jd())\n\n# Compute gaps between consecutive contacts\ngaps = []\nfor sat_name, sat_windows in spacecraft_windows.items():\n    for i in range(len(sat_windows) - 1):\n        gap_start = sat_windows[i].end\n        gap_end = sat_windows[i + 1].start\n        gap_duration = gap_end - gap_start  # Duration in seconds\n\n        gaps.append(\n            {\n                \"spacecraft\": sat_name,\n                \"gap_start\": gap_start,\n                \"gap_end\": gap_end,\n                \"duration\": gap_duration,\n                \"last_station\": sat_windows[i].location_name,\n                \"next_station\": sat_windows[i + 1].location_name,\n            }\n        )\n\n# Sort gaps by duration (longest first)\ngaps.sort(key=lambda g: g[\"duration\"], reverse=True)\n\nelapsed = time.time() - start_time\nprint(f\"Computed {len(gaps)} communication gaps in {elapsed:.2f} seconds.\")\n\n# Print top 10 gaps\nprint(\"\\n\" + \"=\" * 100)\nprint(\"Top 10 Longest Communication Gaps\")\nprint(\"=\" * 100)\nprint(\n    f\"{'Spacecraft':&lt;20} {'Start Time':&lt;25} {'End Time':&lt;25} {'Duration':&gt;25} {'Last\u2192Next Station':&lt;30}\"\n)\nprint(\"-\" * 100)\nfor i, gap in enumerate(gaps[:10]):\n    start_str = str(gap[\"gap_start\"]).split(\".\")[0]  # Remove fractional seconds\n    end_str = str(gap[\"gap_end\"]).split(\".\")[0]\n    duration_str = bh.format_time_string(gap[\"duration\"], short=False)\n    station_str = f\"{gap['last_station']} \u2192 {gap['next_station']}\"\n    print(\n        f\"{gap['spacecraft']:&lt;20} {start_str:&lt;25} {end_str:&lt;25} {duration_str:&gt;25} {station_str:&lt;30}\"\n    )\nprint(\"=\" * 100)\n\n# Export top 10 gaps to CSV for documentation\ncsv_path = OUTDIR / f\"{SCRIPT_NAME}_gaps.csv\"\nwith open(csv_path, \"w\", newline=\"\") as csvfile:\n    writer = csv.writer(csvfile)\n    writer.writerow(\n        [\n            \"Spacecraft\",\n            \"Gap Start (UTC)\",\n            \"Gap End (UTC)\",\n            \"Duration\",\n            \"Last Station\",\n            \"Next Station\",\n        ]\n    )\n    for gap in gaps[:10]:  # Only export top 10\n        start_str = str(gap[\"gap_start\"]).split(\".\")[0]\n        end_str = str(gap[\"gap_end\"]).split(\".\")[0]\n        duration_str = bh.format_time_string(gap[\"duration\"], short=True)\n        writer.writerow(\n            [\n                gap[\"spacecraft\"],\n                start_str,\n                end_str,\n                duration_str,\n                gap[\"last_station\"],\n                gap[\"next_station\"],\n            ]\n        )\nprint(f\"\\n\u2713 Exported top 10 gaps to {csv_path}\")\n\n# Analyze gap distribution statistics\nprint(\"\\nGap Distribution Statistics:\")\n# --8&lt;-- [gap_statistics]\ngap_durations = [g[\"duration\"] for g in gaps]\nmean_gap = np.mean(gap_durations)\nmedian_gap = np.median(gap_durations)\nmin_gap = np.min(gap_durations)\nmax_gap = np.max(gap_durations)\n\nprint(f\"  Mean: {bh.format_time_string(mean_gap)}\")\nprint(f\"  Median: {bh.format_time_string(median_gap)}\")\nprint(f\"  Min: {bh.format_time_string(min_gap)}\")\nprint(f\"  Max: {bh.format_time_string(max_gap)}\")\n\n# Create gap distribution histogram\nprint(\"\\nCreating gap distribution histogram...\")\ngap_durations_hours = [d / 3600.0 for d in gap_durations]  # Convert to hours\n\nfig_histogram = go.Figure(\n    data=[\n        go.Histogram(\n            x=gap_durations_hours,\n            nbinsx=40,\n            marker_color=\"coral\",\n            marker_line_color=\"black\",\n            marker_line_width=1,\n            hovertemplate=\"Gap Duration: %{x:.1f} hours&lt;br&gt;Count: %{y}&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\nfig_histogram.update_layout(\n    title=\"Umbra Constellation Communication Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Frequency\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    annotations=[\n        dict(\n            text=f\"Mean: {bh.format_time_string(mean_gap)}&lt;br&gt;\"\n            f\"Median: {bh.format_time_string(median_gap)}&lt;br&gt;\"\n            f\"Max: {bh.format_time_string(max_gap)}\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0.95,\n            y=0.97,\n            xanchor=\"right\",\n            yanchor=\"top\",\n            showarrow=False,\n            bordercolor=\"grey\",\n            borderwidth=1,\n            borderpad=8,\n        )\n    ],\n)\n\n# Create cumulative distribution plot\nprint(\"\\nCreating cumulative distribution plot...\")\n\n# Sort gap durations and compute cumulative percentages\nsorted_gap_durations_hours = sorted(gap_durations_hours)\ncumulative_percentages = [\n    (i + 1) / len(sorted_gap_durations_hours) * 100\n    for i in range(len(sorted_gap_durations_hours))\n]\n\n# Create cumulative distribution figure\nfig_cumulative = go.Figure(\n    data=[\n        go.Scatter(\n            x=sorted_gap_durations_hours,\n            y=cumulative_percentages,\n            mode=\"lines\",\n            line=dict(color=\"steelblue\", width=2.5),\n            hovertemplate=\"Gap Duration: %{x:.2f} hours&lt;br&gt;Cumulative: %{y:.1f}%&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    ]\n)\n\n# Add reference lines for key percentiles\npercentile_values = {\n    25: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.25)],\n    50: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.50)],\n    75: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.75)],\n    90: sorted_gap_durations_hours[int(len(sorted_gap_durations_hours) * 0.90)],\n}\n\nshapes = []\nannotations = []\nfor percentile, value in percentile_values.items():\n    # Add horizontal line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=0,\n            x1=value,\n            y0=percentile,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add vertical line\n    shapes.append(\n        dict(\n            type=\"line\",\n            x0=value,\n            x1=value,\n            y0=0,\n            y1=percentile,\n            line=dict(color=\"rgba(128, 128, 128, 0.3)\", width=1, dash=\"dash\"),\n        )\n    )\n    # Add annotation\n    annotations.append(\n        dict(\n            x=value,\n            y=percentile,\n            text=f\"P{percentile}: {value:.2f}h\",\n            showarrow=False,\n            xanchor=\"left\",\n            yanchor=\"bottom\",\n            xshift=5,\n            yshift=5,\n            font=dict(size=9, color=\"gray\"),\n        )\n    )\n\nfig_cumulative.update_layout(\n    title=\"Umbra Constellation Cumulative Gap Distribution (7-day period)\",\n    xaxis_title=\"Gap Duration (hours)\",\n    yaxis_title=\"Cumulative Percentage (%)\",\n    height=700,\n    margin=dict(l=60, r=40, t=80, b=60),\n    shapes=shapes,\n    annotations=annotations,\n    yaxis=dict(range=[0, 105]),\n)\n\n# Create ground track visualization for top 3 longest gaps\nprint(\"\\nCreating ground track visualization for top 3 longest gaps...\")\nstart_time = time.time()\n\n\n# Get the top 3 gaps\ntop_3_gaps = gaps[:3]\ngap_colors = [\"red\", \"orange\", \"yellow\"]\n\n# For each gap, we need to extract the ground track segment during that period\n# We'll need to get the propagator for each gap's spacecraft\ngap_segments_all = []\n\nfor gap_idx, gap in enumerate(top_3_gaps):\n    # Create label with spacecraft name and station transition\n    gap_label = f\"{gap['spacecraft']}, {gap['last_station']} \u2192 {gap['next_station']}\"\n\n    # Find the propagator for this gap's spacecraft\n    sat_prop = None\n    for prop in umbra_props:\n        if prop.get_name() == gap[\"spacecraft\"]:\n            sat_prop = prop\n            break\n\n    if sat_prop is None:\n        print(f\"Warning: Could not find propagator for {gap['spacecraft']}\")\n        continue\n\n    # Get states and epochs from the propagator's trajectory\n    traj = sat_prop.trajectory\n    states = traj.to_matrix()\n    epochs = traj.epochs()\n\n    # Extract ground track points during this gap period\n    gap_lons = []\n    gap_lats = []\n\n    for i, ep in enumerate(epochs):\n        if gap[\"gap_start\"] &lt;= ep &lt;= gap[\"gap_end\"]:\n            # Convert to geodetic coordinates\n            ecef_state = bh.state_eci_to_ecef(ep, states[i])\n            lon, lat, alt = bh.position_ecef_to_geodetic(\n                ecef_state[:3], bh.AngleFormat.RADIANS\n            )\n            gap_lons.append(np.degrees(lon))\n            gap_lats.append(np.degrees(lat))\n\n    # Split ground track at antimeridian crossings for proper plotting\n    segments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\n\n    # Interpolate segments to the edge at \u00b1180\u00b0 to avoid visual gaps\n    # When a track crosses the antimeridian, add interpolated edge points\n    interpolated_segments = []\n    for seg_idx, (lon_seg, lat_seg) in enumerate(segments):\n        lon_list = list(lon_seg)\n        lat_list = list(lat_seg)\n\n        # Check if this segment needs edge interpolation\n        # If first point is not at edge but previous segment exists, interpolate start\n        if seg_idx &gt; 0 and len(lon_list) &gt; 0:\n            prev_lon, prev_lat = (\n                segments[seg_idx - 1][0][-1],\n                segments[seg_idx - 1][1][-1],\n            )\n            curr_lon, curr_lat = lon_list[0], lat_list[0]\n\n            # Check if there was an antimeridian crossing\n            if abs(curr_lon - prev_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if prev_lon &gt; 0:  # Previous segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon + 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n                else:  # Previous segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - prev_lon) / ((curr_lon - 360) - prev_lon)\n                    edge_lat = prev_lat + t * (curr_lat - prev_lat)\n                    # Prepend edge point to current segment\n                    lon_list.insert(0, edge_lon)\n                    lat_list.insert(0, edge_lat)\n\n        # Check if segment should be extended to the edge at the end\n        if seg_idx &lt; len(segments) - 1 and len(lon_list) &gt; 0:\n            curr_lon, curr_lat = lon_list[-1], lat_list[-1]\n            next_lon, next_lat = (\n                segments[seg_idx + 1][0][0],\n                segments[seg_idx + 1][1][0],\n            )\n\n            # Check if there will be an antimeridian crossing\n            if abs(next_lon - curr_lon) &gt; 180:\n                # Determine which edge we're interpolating to\n                if curr_lon &gt; 0:  # Current segment ends in positive lon\n                    edge_lon = 180.0\n                    # Linear interpolation to find latitude at 180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon + 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n                else:  # Current segment ends in negative lon\n                    edge_lon = -180.0\n                    # Linear interpolation to find latitude at -180\u00b0\n                    t = (edge_lon - curr_lon) / ((next_lon - 360) - curr_lon)\n                    edge_lat = curr_lat + t * (next_lat - curr_lat)\n                    # Append edge point to current segment\n                    lon_list.append(edge_lon)\n                    lat_list.append(edge_lat)\n\n        interpolated_segments.append((lon_list, lat_list))\n\n    gap_segments_all.append(\n        {\n            \"segments\": interpolated_segments,\n            \"color\": gap_colors[gap_idx],\n            \"label\": gap_label,\n            \"spacecraft\": gap[\"spacecraft\"],\n            \"duration\": gap[\"duration\"],\n        }\n    )\n\n    print(\n        f\"  Gap {gap_idx + 1}: {len(gap_lons)} points, {len(interpolated_segments)} segments\"\n    )\n\n# Create base plot with KSAT stations only (matplotlib backend for SVG output)\n\nfig_groundtrack = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": ksat_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=500e3,  # Approximate Umbra altitude\n    gs_min_elevation=5.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot each gap segment\nax = fig_groundtrack.get_axes()[0]\nfor gap_data in gap_segments_all:\n    for i, (lon_seg, lat_seg) in enumerate(gap_data[\"segments\"]):\n        ax.plot(\n            lon_seg,\n            lat_seg,\n            color=gap_data[\"color\"],\n            linewidth=1.5,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=gap_data[\"label\"] if i == 0 else \"\",\n        )\n\n# Add legend with high zorder to render on top\nlegend = ax.legend(loc=\"lower left\", fontsize=10)\nlegend.set_zorder(100)\n\n# Add title\nax.set_title(\n    \"Umbra Constellation: Top 3 Longest Communication Gaps\\n\"\n    \"KSAT Network (5 stations, 5\u00b0 elevation)\",\n    fontsize=12,\n)\n\nelapsed = time.time() - start_time\nprint(f\"Created ground track visualization in {elapsed:.2f} seconds.\")\n</code></pre>"},{"location":"examples/max_communications_gap.html#see-also","title":"See Also","text":"<ul> <li>Access Computation - Understanding access windows and constraints</li> <li>KSAT Ground Stations - Ground station dataset documentation</li> <li>CelesTrak Dataset - Downloading TLE data</li> <li>String Formatting - Formatting time durations</li> <li>Predicting Ground Contacts - Related ground contact analysis example</li> </ul>"},{"location":"examples/using_different_integrators.html","title":"Comparing Integrator Performance","text":"<p>In this example, we'll compare the performance of different numerical integrators (RK4, RKF45, DP54, and RKN1210) by propagating a satellite orbit over 7 days and analyzing their accuracy and efficiency. We'll measure integration quality by tracking how well each method conserves orbital energy and angular momentum\u2014quantities that should remain constant in two-body orbital dynamics.</p>"},{"location":"examples/using_different_integrators.html#setup","title":"Setup","text":"<p>First, we import the necessary libraries:</p> Python <pre><code>import pathlib\nimport os\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n</code></pre> <p>Then define the two-body gravitational dynamics function:</p> Python <pre><code>def dynamics(t, state):\n    \"\"\"Two-body gravitational dynamics: acceleration = -mu/r^3 * r\"\"\"\n    r = state[0:3]  # Position vector (m)\n    v = state[3:6]  # Velocity vector (m/s)\n\n    r_mag = np.linalg.norm(r)  # Distance from Earth center (m)\n    a = -bh.GM_EARTH / (r_mag**3) * r  # Gravitational acceleration (m/s^2)\n\n    return np.concatenate([v, a])  # Return [velocity, acceleration]\n</code></pre> <p>We also need helper functions to calculate orbital energy and angular momentum:</p> Python <pre><code>def calculate_specific_energy(state):\n    \"\"\"Calculate specific orbital energy: E = v^2/2 - mu/r (J/kg)\"\"\"\n    r_mag = np.linalg.norm(state[0:3])\n    v_mag = np.linalg.norm(state[3:6])\n    return 0.5 * v_mag**2 - bh.GM_EARTH / r_mag\n\n\ndef calculate_angular_momentum(state):\n    \"\"\"Calculate specific angular momentum: h = r \u00d7 v (m^2/s)\"\"\"\n    r = state[0:3]\n    v = state[3:6]\n    return np.cross(r, v)\n</code></pre>"},{"location":"examples/using_different_integrators.html#initial-conditions","title":"Initial Conditions","text":"<p>We set up a sun-synchronous LEO satellite orbit at 500 km altitude and calculate reference values for comparison:</p> Python <pre><code># Define orbital elements\na = bh.R_EARTH + 500e3  # Semi-major axis: 500 km altitude (m)\ne = 0.001  # Eccentricity: nearly circular\ni = 97.8  # Inclination: sun-synchronous (degrees)\nraan = 0.0  # Right ascension of ascending node (degrees)\nargp = 0.0  # Argument of periapsis (degrees)\nM = 0.0  # Mean anomaly (degrees)\n\n# Convert orbital elements to Cartesian state vector\noe = np.array([a, e, i, raan, argp, M])\nstate0 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Calculate reference values\norbital_period = bh.orbital_period(a)\ninitial_energy = calculate_specific_energy(state0)\ninitial_h = calculate_angular_momentum(state0)\nh_magnitude_initial = np.linalg.norm(initial_h)\n\n# Set integration time to 7 days\nt_end = 7 * 24 * 3600.0  # 7 days in seconds\nn_orbits = t_end / orbital_period\n</code></pre> <p>This gives us a baseline: the orbital period (~95 minutes) and the initial conserved quantities (energy and angular momentum magnitude). Over 7 days, the satellite will complete approximately 106.5 orbits.</p>"},{"location":"examples/using_different_integrators.html#running-each-integrator","title":"Running Each Integrator","text":"<p>Now we'll propagate the orbit using each of the four integrators, tracking the angular momentum error at regular intervals.</p>"},{"location":"examples/using_different_integrators.html#rk4-fixed-step-integrator","title":"RK4 - Fixed-Step Integrator","text":"<p>RK4 uses a fixed time step throughout the integration. We'll use 10-second steps:</p> Python <pre><code>dt = 10.0  # 10 second steps\nconfig_rk4 = bh.IntegratorConfig.fixed_step(step_size=dt)\nintegrator_rk4 = bh.RK4Integrator(6, dynamics, config=config_rk4)\n\n# Storage for trajectory analysis\ntimes_rk4 = []\nh_errors_rk4 = []\n\nt = 0.0\nstate = state0.copy()\nsteps = 0\nwhile t &lt; t_end:\n    state = integrator_rk4.step(t, state, dt)\n    t += dt\n    steps += 1\n\n    # Store data every 10 steps for plotting\n    if steps % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rk4.append(t / 86400.0)  # Convert to days\n        h_errors_rk4.append(h_error)\n\n# Final results\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n</code></pre> <p>With a fixed 10-second step size, RK4 takes 60,480 steps over 7 days. While this is reliable and predictable, it doesn't adapt to the problem dynamics.</p>"},{"location":"examples/using_different_integrators.html#rkf45-adaptive-integrator","title":"RKF45 - Adaptive Integrator","text":"<p>RKF45 (Runge-Kutta-Fehlberg) automatically adjusts its step size based on local error estimates:</p> Python <pre><code>abs_tol = 1e-10\nrel_tol = 1e-9\nconfig_adaptive = bh.IntegratorConfig.adaptive(abs_tol=abs_tol, rel_tol=rel_tol)\nintegrator_rkf45 = bh.RKF45Integrator(6, dynamics, config=config_adaptive)\n\ntimes_rkf45 = []\nh_errors_rkf45 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_rkf45.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    # Sample at approximately same rate as RK4\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rkf45.append(t / 86400.0)  # Convert to days\n        h_errors_rkf45.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n</code></pre> <p>RKF45 completes the same 7-day propagation in only 15,687 steps by taking larger steps when the error is small and smaller steps when more accuracy is needed.</p>"},{"location":"examples/using_different_integrators.html#dp54-dormand-prince-integrator","title":"DP54 - Dormand-Prince Integrator","text":"<p>DP54 is another adaptive method, often more efficient than RKF45:</p> Python <pre><code>integrator_dp54 = bh.DP54Integrator(6, dynamics, config=config_adaptive)\n\ntimes_dp54 = []\nh_errors_dp54 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_dp54.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_dp54.append(t / 86400.0)  # Convert to days\n        h_errors_dp54.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n</code></pre> <p>DP54 is slightly more efficient, requiring 14,264 steps with the same tolerance settings.</p>"},{"location":"examples/using_different_integrators.html#rkn1210-high-precision-integrator","title":"RKN1210 - High-Precision Integrator","text":"<p>RKN1210 is a high-order Runge-Kutta-Nystr\u00f6m method designed for second-order differential equations. We configure it with tighter tolerances:</p> Python <pre><code>abs_tol_hp = 1e-12\nrel_tol_hp = 1e-11\nconfig_high_precision = bh.IntegratorConfig.adaptive(\n    abs_tol=abs_tol_hp, rel_tol=rel_tol_hp\n)\nintegrator_rkn1210 = bh.RKN1210Integrator(6, dynamics, config=config_high_precision)\n\ntimes_rkn1210 = []\nh_errors_rkn1210 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_rkn1210.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rkn1210.append(t / 86400.0)  # Convert to days\n        h_errors_rkn1210.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n</code></pre> <p>RKN1210 achieves much higher accuracy with only 945 steps-over 50\u00d7 fewer than RK4!</p>"},{"location":"examples/using_different_integrators.html#comparison-summary","title":"Comparison Summary","text":"<p>Here's the summary table showing each integrator's performance:</p> <p>Output: <pre><code>======================================================================\nCOMPARISON SUMMARY (7 days / 106.5 orbits)\n======================================================================\n\nIntegrator   Type            Steps    Energy Error    |h| Error\n----------------------------------------------------------------------\nRK4          Fixed-step      60480    8.951e-02       8.085e+01      \nRKF45        Adaptive        15687    1.665e+01       1.504e+04      \nDP54         Adaptive        14268    3.319e+00       2.999e+03      \nRKN1210      High-precision  945      4.869e-05       4.404e-02  \n</code></pre></p> <p>Key observations:</p> <ul> <li>RK4 requires many steps (60,480) with moderate accumulated error</li> <li>RKF45 and DP54 reduce steps by ~4\u00d7 but show more energy/momentum drift</li> <li>RKN1210 achieves the best accuracy with far fewer steps (~64\u00d7 fewer than RK4)</li> </ul> <p>The energy and angular momentum errors reveal an important pattern: adaptive low-order methods (RKF45, DP54) can accumulate more error over long integrations despite taking fewer steps, while the high-order RKN1210 maintains excellent conservation properties.</p>"},{"location":"examples/using_different_integrators.html#angular-momentum-conservation","title":"Angular Momentum Conservation","text":"<p>To visualize how each integrator performs over time, we plot the angular momentum magnitude error:</p>"},{"location":"examples/using_different_integrators.html#full-code-example","title":"Full Code Example","text":"comparing_methods.py<pre><code>import pathlib\nimport os\nimport sys\nimport brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\nbh.initialize_eop()\n\n# Configuration for output files\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# ============================================================================\n# SETUP: Define the problem\n# ============================================================================\n\n\n# Define dynamics function for two-body orbital mechanics\n# State vector: [x, y, z, vx, vy, vz] in meters and meters/second\ndef dynamics(t, state):\n    \"\"\"Two-body gravitational dynamics: acceleration = -mu/r^3 * r\"\"\"\n    r = state[0:3]  # Position vector (m)\n    v = state[3:6]  # Velocity vector (m/s)\n\n    r_mag = np.linalg.norm(r)  # Distance from Earth center (m)\n    a = -bh.GM_EARTH / (r_mag**3) * r  # Gravitational acceleration (m/s^2)\n\n    return np.concatenate([v, a])  # Return [velocity, acceleration]\n\n\n\n\ndef calculate_specific_energy(state):\n    \"\"\"Calculate specific orbital energy: E = v^2/2 - mu/r (J/kg)\"\"\"\n    r_mag = np.linalg.norm(state[0:3])\n    v_mag = np.linalg.norm(state[3:6])\n    return 0.5 * v_mag**2 - bh.GM_EARTH / r_mag\n\n\ndef calculate_angular_momentum(state):\n    \"\"\"Calculate specific angular momentum: h = r \u00d7 v (m^2/s)\"\"\"\n    r = state[0:3]\n    v = state[3:6]\n    return np.cross(r, v)\n\n\n\n\n# ============================================================================\n# INITIAL CONDITIONS: LEO satellite orbit\n# ============================================================================\n\n# Define orbital elements\na = bh.R_EARTH + 500e3  # Semi-major axis: 500 km altitude (m)\ne = 0.001  # Eccentricity: nearly circular\ni = 97.8  # Inclination: sun-synchronous (degrees)\nraan = 0.0  # Right ascension of ascending node (degrees)\nargp = 0.0  # Argument of periapsis (degrees)\nM = 0.0  # Mean anomaly (degrees)\n\n# Convert orbital elements to Cartesian state vector\noe = np.array([a, e, i, raan, argp, M])\nstate0 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Calculate reference values\norbital_period = bh.orbital_period(a)\ninitial_energy = calculate_specific_energy(state0)\ninitial_h = calculate_angular_momentum(state0)\nh_magnitude_initial = np.linalg.norm(initial_h)\n\n# Set integration time to 7 days\nt_end = 7 * 24 * 3600.0  # 7 days in seconds\nn_orbits = t_end / orbital_period\n\n# Print problem setup\nprint(\"=\" * 70)\nprint(\"COMPARING INTEGRATORS ON TWO-BODY ORBITAL DYNAMICS\")\nprint(\"=\" * 70)\nprint(f\"Orbit altitude: {(a - bh.R_EARTH) / 1e3:.1f} km\")\nprint(f\"Inclination: {i:.1f}\u00b0\")\nprint(f\"Orbital period: {orbital_period / 60:.2f} minutes\")\nprint(f\"Initial energy: {initial_energy:.6e} J/kg\")\nprint(f\"Initial |h|: {h_magnitude_initial:.6e} m\u00b2/s\")\nprint(f\"Integration duration: 7 days ({n_orbits:.1f} orbits)\")\nprint(\"=\" * 70)\nprint()\n\n# Store results for comparison\nresults = []\n\n\n# ============================================================================\n# INTEGRATOR 1: RK4 (Fixed-step)\n# ============================================================================\n\nprint(\"1. RK4 - Fourth-order Runge-Kutta (Fixed-step)\")\nprint(\"-\" * 70)\n\ndt = 10.0  # 10 second steps\nconfig_rk4 = bh.IntegratorConfig.fixed_step(step_size=dt)\nintegrator_rk4 = bh.RK4Integrator(6, dynamics, config=config_rk4)\n\n# Storage for trajectory analysis\ntimes_rk4 = []\nh_errors_rk4 = []\n\nt = 0.0\nstate = state0.copy()\nsteps = 0\nwhile t &lt; t_end:\n    state = integrator_rk4.step(t, state, dt)\n    t += dt\n    steps += 1\n\n    # Store data every 10 steps for plotting\n    if steps % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rk4.append(t / 86400.0)  # Convert to days\n        h_errors_rk4.append(h_error)\n\n# Final results\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n\nprint(f\"Configuration: Fixed step size = {dt} seconds\")\nprint(f\"Steps taken: {steps}\")\nprint(f\"Final altitude: {(r_mag - bh.R_EARTH) / 1e3:.3f} km\")\nprint(f\"Energy error: {energy_error:.3e} J/kg\")\nprint(f\"Angular momentum error: {h_error_final:.3e} m\u00b2/s\")\nprint()\n\nresults.append(\n    {\n        \"integrator\": \"RK4\",\n        \"type\": \"Fixed-step\",\n        \"steps\": steps,\n        \"energy_error\": energy_error,\n        \"h_error\": h_error_final,\n        \"times\": times_rk4,\n        \"h_errors\": h_errors_rk4,\n    }\n)\n\n\n# ============================================================================\n# INTEGRATOR 2: RKF45 (Adaptive)\n# ============================================================================\n\nprint(\"2. RKF45 - Runge-Kutta-Fehlberg (Adaptive)\")\nprint(\"-\" * 70)\n\nabs_tol = 1e-10\nrel_tol = 1e-9\nconfig_adaptive = bh.IntegratorConfig.adaptive(abs_tol=abs_tol, rel_tol=rel_tol)\nintegrator_rkf45 = bh.RKF45Integrator(6, dynamics, config=config_adaptive)\n\ntimes_rkf45 = []\nh_errors_rkf45 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_rkf45.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    # Sample at approximately same rate as RK4\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rkf45.append(t / 86400.0)  # Convert to days\n        h_errors_rkf45.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n\nprint(f\"Configuration: abs_tol={abs_tol}, rel_tol={rel_tol}\")\nprint(f\"Steps taken: {steps}\")\nprint(f\"Final altitude: {(r_mag - bh.R_EARTH) / 1e3:.3f} km\")\nprint(f\"Energy error: {energy_error:.3e} J/kg\")\nprint(f\"Angular momentum error: {h_error_final:.3e} m\u00b2/s\")\nprint()\n\nresults.append(\n    {\n        \"integrator\": \"RKF45\",\n        \"type\": \"Adaptive\",\n        \"steps\": steps,\n        \"energy_error\": energy_error,\n        \"h_error\": h_error_final,\n        \"times\": times_rkf45,\n        \"h_errors\": h_errors_rkf45,\n    }\n)\n\n\n# ============================================================================\n# INTEGRATOR 3: DP54 (Adaptive)\n# ============================================================================\n\nprint(\"3. DP54 - Dormand-Prince 5(4) (Adaptive)\")\nprint(\"-\" * 70)\n\nintegrator_dp54 = bh.DP54Integrator(6, dynamics, config=config_adaptive)\n\ntimes_dp54 = []\nh_errors_dp54 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_dp54.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_dp54.append(t / 86400.0)  # Convert to days\n        h_errors_dp54.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n\nprint(f\"Configuration: abs_tol={abs_tol}, rel_tol={rel_tol}\")\nprint(f\"Steps taken: {steps}\")\nprint(f\"Final altitude: {(r_mag - bh.R_EARTH) / 1e3:.3f} km\")\nprint(f\"Energy error: {energy_error:.3e} J/kg\")\nprint(f\"Angular momentum error: {h_error_final:.3e} m\u00b2/s\")\nprint()\n\nresults.append(\n    {\n        \"integrator\": \"DP54\",\n        \"type\": \"Adaptive\",\n        \"steps\": steps,\n        \"energy_error\": energy_error,\n        \"h_error\": h_error_final,\n        \"times\": times_dp54,\n        \"h_errors\": h_errors_dp54,\n    }\n)\n\n\n# ============================================================================\n# INTEGRATOR 4: RKN1210 (High-precision adaptive)\n# ============================================================================\n\nprint(\"4. RKN1210 - Runge-Kutta-Nystr\u00f6m 12(10) (High-precision)\")\nprint(\"-\" * 70)\n\nabs_tol_hp = 1e-12\nrel_tol_hp = 1e-11\nconfig_high_precision = bh.IntegratorConfig.adaptive(\n    abs_tol=abs_tol_hp, rel_tol=rel_tol_hp\n)\nintegrator_rkn1210 = bh.RKN1210Integrator(6, dynamics, config=config_high_precision)\n\ntimes_rkn1210 = []\nh_errors_rkn1210 = []\n\nt = 0.0\nstate = state0.copy()\ndt_current = 10.0\nsteps = 0\nsample_count = 0\nwhile t &lt; t_end:\n    result = integrator_rkn1210.step(t, state, min(dt_current, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt_current = result.dt_next\n    steps += 1\n\n    sample_count += 1\n    if sample_count % 10 == 0:\n        h = calculate_angular_momentum(state)\n        h_error = abs(np.linalg.norm(h) - h_magnitude_initial)\n        times_rkn1210.append(t / 86400.0)  # Convert to days\n        h_errors_rkn1210.append(h_error)\n\nr_mag = np.linalg.norm(state[0:3])\nfinal_energy = calculate_specific_energy(state)\nenergy_error = abs(final_energy - initial_energy)\nh_final = calculate_angular_momentum(state)\nh_error_final = abs(np.linalg.norm(h_final) - h_magnitude_initial)\n\nprint(f\"Configuration: abs_tol={abs_tol_hp}, rel_tol={rel_tol_hp}\")\nprint(f\"Steps taken: {steps}\")\nprint(f\"Final altitude: {(r_mag - bh.R_EARTH) / 1e3:.3f} km\")\nprint(f\"Energy error: {energy_error:.3e} J/kg\")\nprint(f\"Angular momentum error: {h_error_final:.3e} m\u00b2/s\")\nprint()\n\nresults.append(\n    {\n        \"integrator\": \"RKN1210\",\n        \"type\": \"High-precision\",\n        \"steps\": steps,\n        \"energy_error\": energy_error,\n        \"h_error\": h_error_final,\n        \"times\": times_rkn1210,\n        \"h_errors\": h_errors_rkn1210,\n    }\n)\n\n\n# ============================================================================\n# COMPARISON SUMMARY\n# ============================================================================\n\nprint(\"=\" * 70)\nprint(\"COMPARISON SUMMARY (7 days / {:.1f} orbits)\".format(n_orbits))\nprint(\"=\" * 70)\nprint()\nprint(\n    f\"{'Integrator':&lt;12} {'Type':&lt;15} {'Steps':&lt;8} {'Energy Error':&lt;15} {'|h| Error':&lt;15}\"\n)\nprint(\"-\" * 70)\nfor r in results:\n    print(\n        f\"{r['integrator']:&lt;12} {r['type']:&lt;15} {r['steps']:&lt;8} \"\n        f\"{r['energy_error']:&lt;15.3e} {r['h_error']:&lt;15.3e}\"\n    )\nprint()\nprint(\"Key Observations:\")\nprint(\"\u2022 RK4 requires many steps with accumulated drift in conserved quantities\")\nprint(\"\u2022 RKF45 and DP54 adapt step size but show energy/momentum drift\")\nprint(\"\u2022 RKN1210 maintains best conservation with far fewer steps\")\nprint(\"\u2022 Angular momentum conservation indicates integration quality\")\nprint(\"=\" * 70)\n\n\n# ============================================================================\n# VISUALIZATION: Angular Momentum Conservation\n# ============================================================================\n\nprint(\"\\nGenerating angular momentum conservation plot...\")\n\n# Create plotly figure\nfig = go.Figure()\n\n# Add traces for each integrator\nfig.add_trace(\n    go.Scatter(\n        x=results[0][\"times\"],\n        y=results[0][\"h_errors\"],\n        mode=\"lines\",\n        name=\"RK4 (Fixed-step)\",\n        line=dict(color=\"steelblue\", width=2),\n        hovertemplate=\"Day: %{x:.2f}&lt;br&gt;|\u0394h|: %{y:.3e} m\u00b2/s&lt;extra&gt;&lt;/extra&gt;\",\n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=results[1][\"times\"],\n        y=results[1][\"h_errors\"],\n        mode=\"lines\",\n        name=\"RKF45 (Adaptive)\",\n        line=dict(color=\"coral\", width=2),\n        hovertemplate=\"Day: %{x:.2f}&lt;br&gt;|\u0394h|: %{y:.3e} m\u00b2/s&lt;extra&gt;&lt;/extra&gt;\",\n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=results[2][\"times\"],\n        y=results[2][\"h_errors\"],\n        mode=\"lines\",\n        name=\"DP54 (Adaptive)\",\n        line=dict(color=\"green\", width=2),\n        hovertemplate=\"Day: %{x:.2f}&lt;br&gt;|\u0394h|: %{y:.3e} m\u00b2/s&lt;extra&gt;&lt;/extra&gt;\",\n    )\n)\n\nfig.add_trace(\n    go.Scatter(\n        x=results[3][\"times\"],\n        y=results[3][\"h_errors\"],\n        mode=\"lines\",\n        name=\"RKN1210 (High-precision)\",\n        line=dict(color=\"grey\", width=2),\n        hovertemplate=\"Day: %{x:.2f}&lt;br&gt;|\u0394h|: %{y:.3e} m\u00b2/s&lt;extra&gt;&lt;/extra&gt;\",\n    )\n)\n\n# Configure axes\naxis_config = {\n    \"title_font\": {\"size\": 11},\n    \"tickfont\": {\"size\": 10},\n}\n\nfig.update_xaxes(title_text=\"Time (days)\", **axis_config)\nfig.update_yaxes(\n    title_text=\"Angular Momentum Error |\u0394h| (m\u00b2/s)\", type=\"log\", **axis_config\n)\n\nfig.update_layout(\n    title=\"Angular Momentum Conservation Over 7 Days\",\n    showlegend=True,\n    legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01, font=dict(size=10)),\n)\n\nprint(\"Comparison complete!\")\n</code></pre>"},{"location":"examples/using_different_integrators.html#see-also","title":"See Also","text":"<ul> <li>Numerical Integration - Understanding how integrators work</li> <li>Integrator API Reference - Complete API documentation</li> <li>Orbit Propagation Examples - More orbital mechanics examples</li> </ul>"},{"location":"examples/visualizing_gps.html","title":"Visualizing GPS Satellite Orbits","text":"<p>In this example we'll show how to visualize the orbits of GPS satellites using Brahe. We'll download the latest TLE data for the GPS constellation from CelesTrak, propagate each satellite for one orbit, and create an interactive 3D plot showing their trajectories around Earth.</p> <p>This example is similar to the Downloading &amp; Visualizing TLE Data For GPS Satellites example, but but adds in propagation for one full orbit before visualization.</p>"},{"location":"examples/visualizing_gps.html#initialize-earth-orientation-parameters","title":"Initialize Earth Orientation Parameters","text":"<p>Before starting, we need to import brahe and ensure that we have Earth orientation parameters initialized. We'll use <code>initialize_eop()</code>, which provides a CachingEOPProvider to deliver up-to-date Earth orientation parameters.</p> <pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n</code></pre>"},{"location":"examples/visualizing_gps.html#download-gps-tles","title":"Download GPS TLEs","text":"<p>We'll use the CelesTrak dataset to fetch the latest TLE data for all GPS satellites. The <code>get_tles_as_propagators</code> function downloads the data and creates SGP4 propagators in one step:</p> <pre><code>propagators = bh.datasets.celestrak.get_tles_as_propagators(\"gps-ops\", 60.0)\n</code></pre>"},{"location":"examples/visualizing_gps.html#propagate-orbits","title":"Propagate orbits","text":"<p>Next, we'll propagate each satellite for one full orbit based on its semi-major axis:</p> <pre><code># Propagate each satellite one orbit\nfor prop in propagators:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\n</code></pre> <p>The line  <pre><code>    orbital_period = bh.orbital_period(prop.semi_major_axis)\n</code></pre> computes the or orbital period of the satellite by converting the semi-major axis associated with the <code>SGP4Propagator</code> into an orbital period using Brahe's <code>orbital_period</code> function.</p> <p>It then propagates the satellite to one full orbit past its epoch using the <code>propagate_to</code> method to ensure that the trajectory contains position data for one complete orbit.</p>"},{"location":"examples/visualizing_gps.html#visualize-in-3d","title":"Visualize in 3D","text":"<p>We'll create an interactive 3D visualization of the entire GPS constellation using Plotly. We'll use the Natural Earth 50m texture for a realistic Earth representation:</p> <pre><code>fig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n</code></pre> <p>The resulting plot shows the complete GPS constellation orbiting Earth. The interactive visualization allows you to rotate, zoom, and pan to explore the satellite positions from different angles.</p>"},{"location":"examples/visualizing_gps.html#full-code-example","title":"Full Code Example","text":"visualizing_gps.py<pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Download TLE data for all GPS satellites from CelesTrak\n# The get_tles_as_propagators function:\n#   - Downloads latest TLE data (cached for 6 hours)\n#   - Parses each TLE into an SGP4 propagator\n#   - Sets default propagation step size (60 seconds)\nprint(\"Downloading GPS TLEs from CelesTrak...\")\nstart_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"gps-ops\", 60.0)\nelapsed = time.time() - start_time\nprint(\n    f\"Initialized propagators for {len(propagators)} GPS satellites in {elapsed:.2f} seconds.\"\n)\n\nts = time.time()\n# Propagate each satellite one orbit\nfor prop in propagators:\n    orbital_period = bh.orbital_period(prop.semi_major_axis)\n    prop.propagate_to(prop.epoch + orbital_period)\nte = time.time() - ts\nprint(f\"Propagated all satellites to one orbit in {te:.2f} seconds.\")\n\n# Create interactive 3D plot with Earth texture\nprint(\"\\nCreating 3D visualization of satellites...\")\nts = time.time()\nfig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\nte = time.time() - ts\nprint(f\"Created base 3D plot in {te:.2f} seconds.\")\n</code></pre>"},{"location":"examples/visualizing_gps.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Dataset - More details on using CelesTrak datasets</li> <li>Two-Line Elements - Understanding TLE format and usage</li> <li>SGP4 Propagator - How SGP4 works for orbit propagation</li> <li>3D Trajectory Plotting - Advanced options for trajectory visualization</li> </ul>"},{"location":"examples/visualizing_starlink.html","title":"Downloading &amp; Visualizing TLE Data For Starlink Satellites","text":"<p>Slow Page</p> <p>This page may load slowly due to the embedded interactive 3D plot. Please be patient while it loads.</p> <p>This example demonstrates how to download Two-Line Element (TLE) data from the CelesTrak dataset using the Brahe library, and then visualize the complete Starlink satellite constellation in an interactive 3D plot.</p>"},{"location":"examples/visualizing_starlink.html#initialize-earth-orientation-parameters","title":"Initialize Earth Orientation Parameters","text":"<p>Before starting, we need to import brahe and ensure that we have Earth orientation parameters initialized. We'll use <code>initialize_eop()</code>, which provides a CachingEOPProvider to deliver up-to-date Earth orientation parameters.</p> <pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n</code></pre>"},{"location":"examples/visualizing_starlink.html#download-starlink-tles","title":"Download Starlink TLEs","text":"<p>We'll use the CelesTrak dataset to fetch the latest TLE data for all Starlink satellites. The <code>get_tles_as_propagators</code> function downloads the data and creates SGP4 propagators in one step:</p> <pre><code>propagators = bh.datasets.celestrak.get_tles_as_propagators(\"starlink\", 60.0)\n\n# Filter out any re-enerting spacecraft with &lt; 350 km semi-major axis\n# This can sometimes cause numerical issues with the propagator for very low orbit\n# when eccentricity becomes negative.\npropagators = [\n    prop for prop in propagators if prop.semi_major_axis &gt;= (bh.R_EARTH + 350.0e3)\n]\n</code></pre>"},{"location":"examples/visualizing_starlink.html#inspect-satellite-data","title":"Inspect Satellite Data","text":"<p>Let's examine the properties of the first satellite to understand the orbital parameters:</p> <pre><code># Inspect the first satellite\nfirst_sat = propagators[0]\nprint(f\"\\nFirst satellite: {first_sat.get_name()}\")\nprint(f\"Epoch: {first_sat.epoch}\")\nprint(f\"Semi-major axis: {first_sat.semi_major_axis / 1000:.1f} km\")\nprint(f\"Inclination: {first_sat.inclination:.1f} degrees\")\nprint(f\"Eccentricity: {first_sat.eccentricity:.6f}\")\n</code></pre>"},{"location":"examples/visualizing_starlink.html#visualize-in-3d","title":"Visualize in 3D","text":"<p>We'll create an interactive 3D visualization of the entire Starlink constellation using Plotly. We'll use the Natural Earth 50m texture for a realistic Earth representation:</p> <pre><code>fig = bh.plot_trajectory_3d(\n    [],  # Empty trajectory list; we'll add markers for each satellite\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=3.0,\n    sphere_resolution_lon=600,  # Reduce sphere texture resolution for performance\n    sphere_resolution_lat=300,\n)\n</code></pre> <p>Finally, we'll add points for all satellites at the current epoch:</p> <pre><code># Get the current time for display\nepc = bh.Epoch.now()\n\n# For each satellite, add a marker at the current position\nfor prop in propagators:\n    state = prop.state_eci(epc)\n    fig.add_scatter3d(\n        x=[state[0] / 1000],\n        y=[state[1] / 1000],\n        z=[state[2] / 1000],\n        mode=\"markers\",\n        marker=dict(size=2, color=\"white\"),\n        name=prop.get_name(),\n        showlegend=False,\n    )\n</code></pre> <p>The resulting plot shows the complete Starlink constellation orbiting Earth. The interactive visualization allows you to rotate, zoom, and pan to explore the satellite positions from different angles.</p>"},{"location":"examples/visualizing_starlink.html#full-code-example","title":"Full Code Example","text":"visualizing_starlink.py<pre><code>import time\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Download TLE data for all Starlink satellites from CelesTrak\n# The get_tles_as_propagators function:\n#   - Downloads latest TLE data (cached for 6 hours)\n#   - Parses each TLE into an SGP4 propagator\n#   - Sets default propagation step size (60 seconds)\nprint(\"Downloading Starlink TLEs from CelesTrak...\")\nstart_time = time.time()\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"starlink\", 60.0)\n\n# Filter out any re-enerting spacecraft with &lt; 350 km semi-major axis\n# This can sometimes cause numerical issues with the propagator for very low orbit\n# when eccentricity becomes negative.\npropagators = [\n    prop for prop in propagators if prop.semi_major_axis &gt;= (bh.R_EARTH + 350.0e3)\n]\n\nelapsed = time.time() - start_time\nprint(\n    f\"Initialized propagators for {len(propagators)} Starlink satellites in {elapsed:.2f} seconds.\"\n)\n\n# Inspect the first satellite\nfirst_sat = propagators[0]\nprint(f\"\\nFirst satellite: {first_sat.get_name()}\")\nprint(f\"Epoch: {first_sat.epoch}\")\nprint(f\"Semi-major axis: {first_sat.semi_major_axis / 1000:.1f} km\")\nprint(f\"Inclination: {first_sat.inclination:.1f} degrees\")\nprint(f\"Eccentricity: {first_sat.eccentricity:.6f}\")\n\n\n# Create interactive 3D plot with Earth texture\nprint(\"\\nCreating 3D visualization of satellites...\")\nts = time.time()\nfig = bh.plot_trajectory_3d(\n    [],  # Empty trajectory list; we'll add markers for each satellite\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=3.0,\n    sphere_resolution_lon=600,  # Reduce sphere texture resolution for performance\n    sphere_resolution_lat=300,\n)\nte = time.time() - ts\nprint(f\"Created base 3D plot in {te:.2f} seconds.\")\n\nts = time.time()\n# Get the current time for display\nepc = bh.Epoch.now()\n\n# For each satellite, add a marker at the current position\nfor prop in propagators:\n    state = prop.state_eci(epc)\n    fig.add_scatter3d(\n        x=[state[0] / 1000],\n        y=[state[1] / 1000],\n        z=[state[2] / 1000],\n        mode=\"markers\",\n        marker=dict(size=2, color=\"white\"),\n        name=prop.get_name(),\n        showlegend=False,\n    )\nte = time.time() - ts\nprint(f\"Added satellite markers in {te:.2f} seconds.\")\n</code></pre>"},{"location":"examples/visualizing_starlink.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Dataset - More details on using CelesTrak datasets</li> <li>Two-Line Elements - Understanding TLE format and usage</li> <li>SGP4 Propagator - How SGP4 works for orbit propagation</li> <li>3D Trajectory Plotting - Advanced options for trajectory visualization</li> </ul>"},{"location":"learn/index.html","title":"User Guide","text":"<p>Here you will find the introductory and conceptual documentation for Brahe. This is the main user guide for the package, and is intended to help you get started with using Brahe for your work.</p> <p>Contributions Welcome</p> <p>If you find something missing or unclear in this documentation, particularly feedback on the conceptual flow, how things are introduced or otherwise, please consider contributing! We welcome contributions of all kinds, including:</p> <ul> <li>Reporting issues or suggesting improvements</li> <li>Writing new documentation pages or improving existing ones</li> <li>Adding examples or tutorials</li> <li>Enhancing the codebase with new features or bug fixes</li> </ul> <p>Check out our contributing guide to get started.</p>"},{"location":"learn/index.html#module-structure","title":"Module Structure","text":"<p>The Brahe package is organized into several key modules, each providing providing some core functionality. We can generally think of these modules as falling into four main categories: Foundational Modules, Orbit &amp; Attitude Representations, State Propagation &amp; Dynamics, and Applications. Below is an overview of the main modules and their purposes:</p>"},{"location":"learn/index.html#foundational-modules","title":"Foundational Modules","text":"<p>These modules provide the basic building blocks for the package, including utilities for time handling, constants, and Earth Orientation Parameters (EOP).</p> <ul> <li>Constants: This module contains physical and mathematical constants used throughout the package.</li> <li>Time: This module provides tools for representing and dealing with time. It provides the ubiquitous Epoch class which is the basis for all time handling in Brahe.</li> <li>EOP: This module handles Earth Orientation Parameters, which are essential for accurate coordinate transformations and orbit propagation. An Earth Orientation Provider is required for many operations in Brahe. There are multiple kinds provided, but <code>initialize_eop()</code> is the easiest way to get started.</li> </ul>"},{"location":"learn/index.html#orbit-attitude-representations","title":"Orbit &amp; Attitude Representations","text":"<p>These modules help transform between different state and coordinate representations for both spacecraft orbits (position and velocity) and attitudes (orientation).</p> <ul> <li>Coordinates: This module provides functions to convert between different coordinate systems, such as Cartesian, Geocentric, Geodetic, and Topocentric coordinates.</li> <li>Frames: This module deals with reference frames, including Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) frames, and provides rotation matrices and state transformations between them.</li> <li>Orbits: This module provides functions for working with orbital elements, including conversions between Keplerian elements and Cartesian states, as well as handling special orbit types like Sun-synchronous orbits and Two-Line Elements (TLEs).</li> <li>Attitude: This module provides tools for representing and manipulating spacecraft attitudes using rotation matrices, quaternions, Euler angles, and Euler axes.</li> </ul>"},{"location":"learn/index.html#state-propagation-dynamics","title":"State Propagation &amp; Dynamics","text":"<p>These modules focus on propagating spacecraft states over time using various dynamics models. It also provides methods for representing these state trajectories.</p> <ul> <li>Trajectories: This module defines traits and structures for representing dynamics trajectories, including orbit trajectories.</li> <li>Keplerian Propagator: This module implements a simple Keplerian propagator for orbit propagation based on Kepler's laws.</li> <li>SGP Propagator: This module implements the SGP (Simplified General Perturbations) propagator, a widely used method for propagating Earth-orbiting satellites, in particular those defined by TLEs.</li> <li>Orbit Dynamics: This module implements various force models used in orbit propagation, such as gravity, drag, solar radiation pressure, and more.</li> </ul>"},{"location":"learn/index.html#applications","title":"Applications","text":"<p>These modules provide higher-level functionalities for specific applications, such as working with datasets, computing access windows, and plotting.</p> <ul> <li>Datasets: This module provides access to common datasets used in space applications, such as ground stations and satellite ephemeris catalogs (e.g., Celestrak).</li> <li>Access Computation: This module provides tools for computing access windows between satellites and terrestrial locations, including defining access constraints and computing access properties.</li> <li>Plotting: This module offers functions for visualizing satellite data, including ground tracks, state vectors, orbital elements, and access geometry.</li> </ul> <p>Each of these modules are defined to have composable, interoperable interfaces so that you can easily combine functionality from different modules to accomplish your tasks. As you explore the documentation further, you'll find detailed explanations and examples for each module to help you understand how to use them effectively.</p> <p>For detailed information on all functions, classes, and methods available in each module, please refer to the Python API Reference and Rust API Reference.</p>"},{"location":"learn/constants.html","title":"Constants","text":"<p>The Constants module provides frequently occuring fundamental mathematical  and astronomical constants.</p>"},{"location":"learn/constants.html#mathematical","title":"Mathematical","text":"<p>Mathematical constants provide quick-reference to common factors.</p> Constant Description <code>DEG2RAD</code> Factor to convert from degrees and radians. <code>RAD2DEG</code> Factor to convert from radians to degrees. <code>AS2RAD</code> Factor to convert from arc-seconds to radians. <code>RAD2AS</code> Factor to convert from radians to arc-seconds."},{"location":"learn/constants.html#time","title":"Time","text":"<p>Time constants are used for conversions between different time systems.</p> Constant Description Value Units Source <code>MJD_ZERO</code> Offset between Modified Julian Date and Julian Date time scales. $t_{mjd} + {mjd}{0} = t{jd $ \\(2400000.5\\) Days Montenbruck and Gill <sup>1</sup> <code>MJD2000</code> Modified Julian date of J2000 Epoch. January 1, 2000 12:00:00. \\(51544.5\\) Days Montenbruck and Gill <sup>1</sup> <code>GPS_TAI</code> Constant offset from TAI to GPS time scale. \\(t_{gps} = t_{tai} + \\Delta_{GPS-TAI}\\) \\(19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_GPS</code> Constant offset from GPS to TAI time scale. \\(t_{tai} = t_{gps}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; + \\Delta_{TAI-GPS}\\) \\(-19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_TAI</code> Constant offset from TT to TAI time scale. \\(t_{tt} = t_{tai} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-TAI}\\) \\(32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_TT</code> Constant offset from TAI to TT time scale. \\(t_{tai} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TAI-TT}\\) \\(-32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_TT</code> Constant offset from GPS to TT time scale. \\(t_{gps} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{GPS-TT}\\) \\(-51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_GPS</code> Constant offset from TT to GPS time scale. \\(t_{tt} = t_{gps} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-GPS}\\) \\(51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_ZERO</code> Modified Julian Date of the start of the GPS time scale in the GPS time scale. This date is January 6, 1980 00:00:00 hours reckoned in the UTC time scale \\(44244.0\\) Days Montenbruck and Gill <sup>1</sup>"},{"location":"learn/constants.html#physical-constants","title":"Physical Constants","text":"<p>Physical constants are fundamental physical constants or properties of  astronomical bodies. While these values are estimated they are considered to  be well known and do not change frequently.</p> Constant Description Value Units Source <code>C_LIGHT</code> Speed of light in vacuum. \\(299792458.0\\) \\(\\frac{m}{s}\\) Vallado <sup>2</sup> <code>AU</code> Astronominal Unit. TDB reference frame compatible value equal to the mean distance of the Earth from the Sun. \\(1.49597870700 \\times 10^{11}\\) \\(m\\) G\u00e9rard and Luzum <sup>3</sup> <code>R_EARTH</code> Earth's semi-major axis as defined by the Grace GGM05S gravity model. \\(.378136.3\\) \\(m\\) Ries et al. <sup>4</sup> <code>WGS84_A</code> Earth geoid model's semi-major axis as defined by the World Geodetic System 1984 edition. \\(6378137.0\\) \\(m\\) NIMA Technical Report <sup>5</sup> <code>WGS84_F</code> Earth geoid model's flattening as defined by the World Geodetic System 1984 edition. \\(\\frac{1.0}{298.257223563}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>GM_EARTH</code> Gravitational Constant of the Earth. \\(3.986004415 \\times 10^{14}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>ECC_EARTH</code> Earth geoid model's eccentricity. \\(8.1819190842622 \\times 10^{-2}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>J2_EARTH</code> Earth's first zonal harmonic. Also known as Earth's oblateness. \\(0.0010826358191967\\) Dimensionless Montenbruck and Gill <sup>1</sup> <code>OMEGA_EARTH</code> Earth's axial rotation rate. \\(7.292115146706979 \\times 10^{-5}\\) \\(\\frac{rad}{s}\\) Vallado <sup>2</sup> <code>GM_SUN</code> Gravitational constant of the Sun. \\(1.32712440041939400 \\times 10^{20}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Nominal photosphere radius of the Sun. \\(6.957 \\times 10^{8}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>P_SUN</code> Nominal solar radiation pressure at 1 AU. \\(4.560 \\times 10^{-6}\\) \\(\\frac{N}{m^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Equatorial radius of the Moon. \\(1.738 \\times 10^{6}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>GM_MOON</code> Gravitational constant of the Moon. \\(4.902800066 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MERCURY</code> Gravitational constant of the Mercury. \\(2.2031780 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_VENUS</code> Gravitational constant of the Venus. \\(3.248585920 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MARS</code> Gravitational constant of the Mars. \\(4.282837521 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_JUPITER</code> Gravitational constant of the Jupiter. \\(1.267127648 \\times 10^{17}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_SATURN</code> Gravitational constant of the Saturn. \\(3.79405852 \\times 10^{16}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_URANUS</code> Gravitational constant of the Uranus. \\(5.7945486 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_NEPTUNE</code> Gravitational constant of the Neptune. \\(6.836527100580 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_PLUTO</code> Gravitational constant of the Pluto. \\(9.770 \\times 10^{11}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <ol> <li> <p>O. Montenbruck, and E. Gill, Satellite Orbits: Models, Methods and Applications, 2012\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010\u00a0\u21a9\u21a9</p> </li> <li> <p>P. G\u00e9rard and B. Luzum, IERS Technical Note 36, 2010\u00a0\u21a9</p> </li> <li> <p>J. Ries, S. Bettadpur, R. Eanes, Z. Kang, U. Ko, C. McCullough, P. Nagel, N. Pie, S. Poole, T. Richter, H. Save, and B. Tapley, Development and Evaluation of the Global Gravity Model GGM05, 2016\u00a0\u21a9</p> </li> <li> <p>Department of Defense World Geodetic System 1984, Its Definition and Relationships With Local Geodetic Systems\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"learn/access_computation/index.html","title":"Access Computation","text":"<p>Access computation determines when and under what conditions satellites can view, observe, or \"access\" ground locations. This is fundamental for mission planning, ground station contact scheduling, imaging opportunity planning, and other mission operations planning tasks.</p> <p>An access occurs when a satellite has a clear geometric line-of-sight to a ground location and meets all constraints (e.g., minimum elevation angle, local time of day, look direction). Brahe's access computation system identifies time windows where all constraints are met and computes relevant properties (e.g., azimuth, elevation, off-nadir angle) for each access window. The system is designed to be flexible, allowing users to define custom locations, constraints, and properties as needed. Access computation is also parallelized by default to efficiently handle large numbers of locations and satellites.</p>"},{"location":"learn/access_computation/index.html#system-architecture","title":"System Architecture","text":"<p>Brahe's access computation system is built around four major components:</p>"},{"location":"learn/access_computation/index.html#1-locations","title":"1. Locations","text":"<p>Locations define where to check for access. Brahe supports two primary location types:</p> <ul> <li><code>PointLocation</code> - Single geodetic point (e.g., ground station, city)</li> <li><code>PolygonLocation</code> - Closed polygon area (e.g., imaging region, coverage zone)</li> </ul> <p>Both implement the <code>AccessibleLocation</code> trait, which provides coordinate access, property management, and GeoJSON import/export capabilities. Locations can be created from coordinates or loaded from GeoJSON files, and the type supports custom properties for metadata storage.</p> <p>Learn more about Locations \u2192</p>"},{"location":"learn/access_computation/index.html#2-constraints","title":"2. Constraints","text":"<p>Constraints define what conditions must be satisfied for an access to occur. Brahe provides several built-in constraint types including:</p> <ul> <li><code>ElevationConstraint</code> - Minimum/maximum elevation above horizon</li> <li><code>ElevationMaskConstraint</code> - Azimuth-dependent elevation masks (terrain profiles)</li> <li><code>OffNadirConstraint</code> - Minimum/maximum off-nadir angle (imaging satellites)</li> <li><code>LocalTimeConstraint</code> - Local solar time windows (e.g., daylight imaging)</li> <li><code>LookDirectionConstraint</code> - Left/right/either relative to velocity vector</li> <li><code>AscDscConstraint</code> - Ascending/descending pass filter</li> </ul> <p>Constraints can be combined using the <code>ConstraintComposite</code> system to express sophisticated requirements like \"elevation &gt; 10\u00b0 AND (daylight OR look-right)\". Python users can create custom constraints by implementing the <code>AccessConstraintComputer</code> interface.</p> <p>Learn more about Constraints \u2192</p>"},{"location":"learn/access_computation/index.html#3-properties","title":"3. Properties","text":"<p>Properties define what information to compute during each access window. Brahe automatically computes six core geometric properties:</p> <ul> <li><code>azimuth_open</code>, <code>azimuth_close</code> - Azimuth angles at window start/end</li> <li><code>elevation_min</code>, <code>elevation_max</code> - Minimum/maximum elevation during access</li> <li><code>off_nadir_min</code>, <code>off_nadir_max</code> - Minimum/maximum off-nadir angle</li> <li><code>local_time</code> - Local solar time at access midpoint</li> <li><code>look_direction</code> - Satellite look direction (Left/Right)</li> <li><code>asc_dsc</code> - Pass type (Ascending/Descending)</li> </ul> <p>Properties are stored as <code>PropertyValue</code> enums supporting scalar, vector, time-series, boolean, string, and JSON data types. Users can add custom properties or implement <code>AccessPropertyComputer</code> for automated property calculation during access searches.</p> <p>Learn more about Properties \u2192</p>"},{"location":"learn/access_computation/index.html#4-computation","title":"4. Computation","text":"<p>Computation is the algorithm that ties everything together. The primary function <code>location_accesses()</code> performs a two-phase search:</p> <ol> <li>Coarse search - Evaluate access at regular time steps to identify candidate windows</li> <li>Refinement - Use binary search to precisely locate window boundaries</li> </ol> <p>The <code>AccessSearchConfig</code> struct controls algorithm behavior (initial time step, adaptive stepping, etc.) for optimal performance across different scenarios. Results are returned as <code>AccessWindow</code> objects containing start/end times, identifiers, and computed properties.</p> <p>Learn more about Computation \u2192</p>"},{"location":"learn/access_computation/index.html#module-catalog","title":"Module Catalog","text":"<p>This section provides a complete reference of all types, traits, and functions in the access computation module.</p>"},{"location":"learn/access_computation/index.html#location-types","title":"Location Types","text":"<p><code>PointLocation</code> - Single geodetic point location</p> <ul> <li>Create from coordinates: <code>new(lat, lon, alt)</code></li> <li>Load from GeoJSON: <code>from_geojson(geojson_str)</code></li> <li>Access coordinates: <code>lat()</code>, <code>lon()</code>, <code>alt()</code>, <code>longitude()</code>, <code>latitude()</code>, <code>altitude()</code></li> <li>Manage properties: <code>add_property(name, value)</code></li> <li>Export: <code>to_geojson()</code></li> </ul> <p><code>PolygonLocation</code> - Closed polygon area location</p> <ul> <li>Create from vertices: <code>new(vertices)</code></li> <li>Load from GeoJSON: <code>from_geojson(geojson_str)</code></li> <li>Access geometry: <code>vertices()</code>, <code>num_vertices()</code>, center via <code>lat()</code>, <code>lon()</code>, <code>alt()</code></li> <li>Manage properties: <code>add_property(name, value)</code></li> <li>Export: <code>to_geojson()</code></li> </ul> <p><code>AccessibleLocation</code> trait - Common interface for all location types</p> <ul> <li>Get center coordinates: <code>center_geodetic()</code>, <code>center_ecef()</code></li> <li>Access properties: <code>properties()</code>, <code>properties_mut()</code></li> <li>Export: <code>to_geojson()</code></li> </ul>"},{"location":"learn/access_computation/index.html#constraint-types","title":"Constraint Types","text":"<p>Built-in Constraints:</p> <ul> <li><code>ElevationConstraint</code> - Enforce minimum/maximum elevation angles above horizon</li> <li><code>ElevationMaskConstraint</code> - Apply azimuth-dependent elevation masks for terrain modeling</li> <li><code>OffNadirConstraint</code> - Limit off-nadir viewing angles for imaging payloads</li> <li><code>LocalTimeConstraint</code> - Filter by local solar time windows (e.g., daylight-only imaging)</li> <li><code>LookDirectionConstraint</code> - Require left/right/either look direction relative to velocity</li> <li><code>AscDscConstraint</code> - Filter by ascending/descending pass type</li> <li><code>ConstraintComposite</code> - Combine constraints with Boolean logic (All/Any/Not)</li> </ul> <p>Constraint Traits:</p> <ul> <li><code>AccessConstraint</code> trait - Interface for evaluating constraints at specific times</li> <li><code>evaluate(epoch, location, propagator) -&gt; bool</code> - Check if constraint satisfied</li> <li><code>name()</code> - Get constraint name for debugging</li> <li> <p><code>format_string()</code> - Get human-readable constraint description</p> </li> <li> <p><code>AccessConstraintComputer</code> trait - Python interface for custom user-defined constraints</p> </li> <li><code>evaluate(epoch, location, propagator) -&gt; bool</code> - Custom constraint logic</li> <li><code>name()</code> - Constraint identifier</li> </ul>"},{"location":"learn/access_computation/index.html#property-types","title":"Property Types","text":"<p><code>PropertyValue</code> enum - Strongly-typed property values</p> <ul> <li><code>Scalar(f64)</code> - Single floating-point value</li> <li><code>Vector(Vec&lt;f64&gt;)</code> - Array of values</li> <li><code>TimeSeries(Vec&lt;(Epoch, f64)&gt;)</code> - Time-indexed measurements</li> <li><code>Boolean(bool)</code> - True/false flag</li> <li><code>String(String)</code> - Text data</li> <li><code>Json(String)</code> - Arbitrary JSON data</li> </ul> <p><code>AccessProperties</code> struct - Container for access window properties</p> <ul> <li>Core properties: <code>azimuth_open</code>, <code>azimuth_close</code>, <code>elevation_min</code>, <code>elevation_max</code>, <code>off_nadir_min</code>, <code>off_nadir_max</code>, <code>local_time</code>, <code>look_direction</code>, <code>asc_dsc</code></li> <li>Custom properties stored in HashMap</li> <li>Methods: <code>new()</code>, <code>add_property(name, value)</code>, <code>get_property(name)</code></li> </ul> <p><code>AccessPropertyComputer</code> trait - Python interface for custom property calculation</p> <ul> <li><code>compute(window, location, propagator) -&gt; HashMap&lt;String, PropertyValue&gt;</code> - Calculate properties</li> <li><code>property_names() -&gt; Vec&lt;String&gt;</code> - List computed property names</li> </ul>"},{"location":"learn/access_computation/index.html#window-and-configuration-types","title":"Window and Configuration Types","text":"<p><code>AccessWindow</code> struct - Represents a single access opportunity</p> <ul> <li>Time bounds: <code>window_open</code>, <code>window_close</code></li> <li>Identifiers: <code>location_name/id/uuid</code>, <code>satellite_name/id/uuid</code>, <code>name/id/uuid</code></li> <li>Properties: <code>properties</code> (AccessProperties)</li> <li>Methods: <code>new()</code>, <code>start()</code>, <code>end()</code>, <code>midtime()</code>, <code>duration()</code></li> </ul> <p><code>AccessSearchConfig</code> struct - Controls access computation algorithm</p> <ul> <li><code>initial_time_step</code> - Coarse search step size (seconds)</li> <li><code>adaptive_step</code> - Enable adaptive refinement</li> <li><code>adaptive_fraction</code> - Refinement step fraction (0.0-1.0)</li> <li><code>parallel</code> - Enable parallel location/satellite processing</li> <li><code>num_threads</code> - Thread pool size (0 = auto)</li> </ul>"},{"location":"learn/access_computation/index.html#enumerations","title":"Enumerations","text":"<p><code>LookDirection</code> - Satellite look direction</p> <ul> <li><code>Left</code> - Looking left relative to velocity vector</li> <li><code>Right</code> - Looking right relative to velocity vector</li> <li><code>Either</code> - Either direction acceptable</li> </ul> <p><code>AscDsc</code> - Pass type classification</p> <ul> <li><code>Ascending</code> - Satellite moving from south to north</li> <li><code>Descending</code> - Satellite moving from north to south</li> <li><code>Either</code> - Either direction acceptable</li> </ul>"},{"location":"learn/access_computation/index.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and GeoJSON support</li> <li>Constraints - Built-in and custom constraint types</li> <li>Computation - Access algorithms and property computation</li> <li>Example: Predicting Ground Contacts - Complete ground station example</li> <li>Example: Computing Imaging Opportunities - Imaging scenario</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/computation.html","title":"Access Computation","text":"<p>Access computation finds time windows when satellites can observe or communicate with ground locations, subject to geometric and operational constraints. Brahe provides the <code>location_accesses()</code> function as the primary function for finding accesses, with optional search configuration parameters to tune performance and accuracy.</p>"},{"location":"learn/access_computation/computation.html#basic-workflow","title":"Basic Workflow","text":"<p>The simplest access computation requires: a location, a propagator, time bounds, and a constraint.</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize Earth orientation data\nbh.initialize_eop()\n\n# Define ground location (San Francisco, CA)\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\n\n# Create propagator from TLE (example for ISS)\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\n# Define time window (7 days starting from epoch)\nepoch_start = bh.Epoch(2025, 11, 2, 0, 0, 0.0, 0.0)\nepoch_end = epoch_start + 7 * 86400.0\n\n# Define constraint (minimum 10\u00b0 elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(location, propagator, epoch_start, epoch_end, constraint)\n\n# Process results\nprint(f\"Found {len(windows)} access windows\")\nfor i, window in enumerate(windows[:3], 1):\n    duration_min = window.duration / 60.0\n    print(f\"\\nWindow {i}:\")\n    print(f\"  Start: {window.window_open}\")\n    print(f\"  End:   {window.window_close}\")\n    print(f\"  Duration: {duration_min:.2f} minutes\")\n\n    # Access computed properties\n    elev_max = window.properties.elevation_max\n    print(f\"  Max elevation: {elev_max:.1f}\u00b0\")\n\n# Output:\n# Found 35 access windows\n\n# Window 1:\n#   Start: 2025-11-02 05:39:28.345 UTC\n#   End:   2025-11-02 05:44:00.000 UTC\n#   Duration: 4.53 minutes\n#   Max elevation: 18.7\u00b0\n\n# Window 2:\n#   Start: 2025-11-02 07:15:16.033 UTC\n#   End:   2025-11-02 07:21:00.000 UTC\n#   Duration: 5.73 minutes\n#   Max elevation: 38.9\u00b0\n\n# Window 3:\n#   Start: 2025-11-02 08:54:59.619 UTC\n#   End:   2025-11-02 08:56:00.000 UTC\n#   Duration: 1.01 minutes\n#   Max elevation: 10.9\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize EOP\n    bh::initialize_eop()?;\n\n    // Define ground location\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0,\n    )\n    .with_name(\"San Francisco\");\n\n    // Create propagator from TLE\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    // Define time window\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 7.0 * 86400.0;\n\n    // Define constraint\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    // Compute access windows\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None, // Use default config\n        None, // No custom property computers\n        None, // No progress callback\n    )?;\n\n    // Process results\n    println!(\"Found {} access windows\", windows.len());\n    for (i, window) in windows.iter().take(3).enumerate() {\n        let duration_min = window.duration() / 60.0;\n        println!(\"\\nWindow {}:\", i + 1);\n        println!(\"  Start: {}\", window.window_open);\n        println!(\"  End:   {}\", window.window_close);\n        println!(\"  Duration: {:.2} minutes\", duration_min);\n\n        // Access computed properties\n        let elev_max = window.properties.elevation_max;\n        println!(\"  Max elevation: {:.1}\u00b0\", elev_max);\n    }\n\n    Ok(())\n}\n\n// Output:\n// Found 35 access windows\n\n// Window 1:\n//   Start: 2025-11-02 05:39:28.345 UTC\n//   End:   2025-11-02 05:44:00.000 UTC\n//   Duration: 4.53 minutes\n//   Max elevation: 18.7\u00b0\n\n// Window 2:\n//   Start: 2025-11-02 07:15:16.033 UTC\n//   End:   2025-11-02 07:21:00.000 UTC\n//   Duration: 5.73 minutes\n//   Max elevation: 38.9\u00b0\n\n// Window 3:\n//   Start: 2025-11-02 08:54:59.619 UTC\n//   End:   2025-11-02 08:56:00.000 UTC\n//   Duration: 1.01 minutes\n//   Max elevation: 10.9\u00b0\n</code></pre>"},{"location":"learn/access_computation/computation.html#multiple-locations-and-satellites","title":"Multiple Locations and Satellites","text":"<p>Compute access for multiple locations and satellites simultaneously:</p> PythonRust <pre><code>import brahe as bh\nfrom collections import defaultdict\n\nbh.initialize_eop()\n\n# Define multiple ground stations\nlocations = [\n    bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\"),\n    bh.PointLocation(-71.0589, 42.3601, 0.0).with_name(\"Boston\"),\n    bh.PointLocation(15.4038, 78.2232, 458.0).with_name(\"Svalbard\"),\n]\n\n# Define multiple satellites (from TLEs, epoch: 2024-01-01)\ntle_data = [\n    # ISS - LEO, 51.6\u00b0 inclination\n    (\n        \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\",\n        \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\",\n        \"ISS\",\n    ),\n    # Tiangong - LEO, 41.5\u00b0 inclination\n    (\n        \"1 48274U 21035A   25306.17586037  .00031797  00000-0  38131-3 0  9995\",\n        \"2 48274  41.4666 263.0710 0006682 308.7013  51.3228 15.60215133257694\",\n        \"Tiangong\",\n    ),\n]\n\npropagators = [\n    bh.SGPPropagator.from_tle(line1, line2, 60.0).with_name(name)\n    for line1, line2, name in tle_data\n]\n\n# Compute all location-satellite pairs (24 hours from TLE epoch)\nepoch_start = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepoch_end = epoch_start + 86400.0  # 24 hours\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses(\n    locations, propagators, epoch_start, epoch_end, constraint\n)\n\n# Results include windows for all location-satellite combinations\nprint(f\"Total windows: {len(windows)}\")\n\n# Group by location\nby_location = defaultdict(list)\nfor window in windows:\n    by_location[window.location_name].append(window)\n\nfor loc_name, loc_windows in by_location.items():\n    print(f\"\\n{loc_name}: {len(loc_windows)} windows\")\n\n# Output:\n# Total windows: 20\n\n# Boston: 10 windows\n\n# San Francisco: 10 windows\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse std::collections::HashMap;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Define multiple locations\n    let locations = vec![\n        bh::PointLocation::new(\n            -122.4194,\n            37.7749,\n            0.0,\n        )\n        .with_name(\"San Francisco\"),\n        bh::PointLocation::new(-71.0589, 42.3601, 0.0)\n            .with_name(\"Boston\"),\n        bh::PointLocation::new(15.4038, 78.2232, 458.0)\n            .with_name(\"Svalbard\"),\n    ];\n\n    // Define multiple satellites\n    let propagators = vec![\n        bh::SGPPropagator::from_tle(\n            \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\",\n            \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\",\n            60.0,\n        )?\n        .with_name(\"ISS\"),\n        bh::SGPPropagator::from_tle(\n            \"1 48274U 21035A   25306.17586037  .00031797  00000-0  38131-3 0  9995\",\n            \"2 48274  41.4666 263.0710 0006682 308.7013  51.3228 15.60215133257694\",\n            60.0,\n        )?\n        .with_name(\"Tiangong\"),\n    ];\n\n    // Compute access windows\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 2, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    let windows = bh::location_accesses(\n        &amp;locations,\n        &amp;propagators,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    )?;\n\n    println!(\"Total windows: {}\", windows.len());\n\n    // Group by location\n    let mut by_location: HashMap&lt;String, Vec&lt;&amp;bh::AccessWindow&gt;&gt; = HashMap::new();\n    for window in &amp;windows {\n        let loc_name = window.location_name.clone().unwrap_or_else(|| \"Unknown\".to_string());\n        by_location\n            .entry(loc_name)\n            .or_insert_with(Vec::new)\n            .push(window);\n    }\n\n    for (loc_name, loc_windows) in by_location {\n        println!(\"\\n{}: {} windows\", loc_name, loc_windows.len());\n    }\n\n    Ok(())\n}\n\n// Expected output:\n// Total windows: 20\n\n// Boston: 10 windows\n\n// San Francisco: 10 windows\n</code></pre>"},{"location":"learn/access_computation/computation.html#algorithm-explanation","title":"Algorithm Explanation","text":"<p>Brahe uses a two-step search algorithm to balance accuracy and performance:</p>"},{"location":"learn/access_computation/computation.html#phase-1-coarse-search","title":"Phase 1: Coarse Search","text":"<p>The algorithm evaluates the constraint at regular time intervals (<code>initial_time_step</code>) across the entire search period. When the constraint transitions from <code>false</code> to <code>true</code>, a candidate access window has been found. This phase identifies periods of potential access quickly.</p> <p>Optionally, adaptive stepping can be enabled to speed up the search by increasing by increasing the first step after an access window is found. The step size is based on a fraction of the satellite's orbital period (<code>adaptive_fraction</code>). For LEO satellites, this can significantly reduce the number of evaluations needed, as at most one access window occurs per orbit.</p> <p>Example: With a 60-second time step over 24 hours, the algorithm performs ~1,440 constraint evaluations to identify candidate windows.</p>"},{"location":"learn/access_computation/computation.html#phase-2-refinement","title":"Phase 2: Refinement","text":"<p>For each candidate window, the algorithm uses binary search to precisely locate the boundary times:</p> <ol> <li>Start at the coarse boundary estimate</li> <li>Take steps backward/forward at half the previous step size until the constraint changes</li> <li>Evaluate constraint at each step</li> <li>When constraint changes, reduce step size, change direction, and repeat</li> <li>Continue until boundary is located to desired precision</li> </ol>"},{"location":"learn/access_computation/computation.html#configuration","title":"Configuration","text":"<p>The <code>AccessSearchConfig</code> struct controls algorithm behavior:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create custom configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,  # Coarse search: 60-second steps\n    adaptive_step=True,  # Enable adaptive refinement\n    adaptive_fraction=0.75,  # Each step is 75% of orbital period\n    parallel=True,  # Enable parallel processing\n    num_threads=0,  # Auto-detect thread count\n)\n\n# Use custom config with location and propagator\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = bh.Epoch(2025, 11, 2, 0, 0, 0.0, 0.0)\nepoch_end = epoch_start + 86400.0  # 24 hours\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses(\n    location, propagator, epoch_start, epoch_end, constraint, config=config\n)\n\nprint(f\"Found {len(windows)} access windows with custom configuration\")\nprint(\n    f\"Configuration: {config.initial_time_step}s time step, adaptive={config.adaptive_step}\"\n)\n\n# Expected output:\n# Found 5 access windows with custom configuration\n# Configuration: 60s time step, adaptive=True\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Create custom configuration\n    let config = bh::AccessSearchConfig {\n        initial_time_step: 60.0,\n        adaptive_step: true,\n        adaptive_fraction: 0.75,\n        parallel: true,\n        num_threads: Some(0),\n    };\n\n    // Use custom config with location and propagator\n    let location = bh::PointLocation::new(\n       -122.4194,\n       37.7749,\n        0.0,\n    )\n    .with_name(\"San Francisco\");\n\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        Some(&amp;config),\n        None,\n    )?;\n\n    println!(\n        \"Found {} access windows with custom configuration\",\n        windows.len()\n    );\n    println!(\n        \"Configuration: {}s time step, adaptive={}\",\n        config.initial_time_step, config.adaptive_step\n    );\n\n    Ok(())\n}\n\n// Output:\n// Found 5 access windows with custom configuration\n// Configuration: 60s time step, adaptive=true\n</code></pre>"},{"location":"learn/access_computation/computation.html#parameter-guidance","title":"Parameter Guidance","text":"<p><code>initial_time_step</code> - Coarse search step size (seconds)</p> <ul> <li>Smaller values (10-60s): More accurate, slower, for complex constraints or short windows</li> <li>Larger values (60-180s): Faster, risk missing brief access windows</li> <li>Rule of thumb: Use 1/10th of expected minimum window duration</li> </ul> <p><code>adaptive_step</code> - Enable adaptive stepping to speed up coarse search</p> <ul> <li><code>true</code>: Enabled, faster for LEO satellites with regular orbits</li> <li><code>false</code>: Disabled, standard fixed-step search</li> </ul> <p><code>adaptive_fraction</code> - Fraction of orbital period for adaptive step size</p> <ul> <li>Smaller values (0.3-0.6): Smaller adaptive step, less risk of missing windows</li> <li>Larger values (0.6-0.8): Larger adaptive step, faster but riskier</li> <li>Recommended: 0.5-0.75 for LEO satellites</li> </ul> <p><code>parallel</code> - Enable parallel processing</p> <ul> <li><code>true</code>: Process location-satellite pairs in parallel (recommended)</li> <li><code>false</code>: Sequential processing, lower memory usage</li> </ul> <p><code>num_threads</code> - Thread pool size</p> <ul> <li>0: Auto-detect CPU cores (recommended)</li> <li>N &gt; 0: Use exactly N threads for parallel work</li> </ul>"},{"location":"learn/access_computation/computation.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and properties</li> <li>Constraints - Constraint system and composition</li> <li>Access Computation Index - Overview and usage examples</li> <li>Example: Predicting Ground Contacts - Complete workflow</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/constraints.html","title":"Constraints","text":"<p>Constraints define the criteria that must be satisfied for satellite access to ground locations. Brahe provides a comprehensive constraint system with built-in geometric constraints, logical composition operators, and support for custom user-defined constraints.</p> <p>A constraint evaluates to <code>true</code> when access conditions are met and <code>false</code> otherwise. During access computation, the algorithm searches for continuous time periods where constraints remain <code>true</code>, identifying these as access windows.</p>"},{"location":"learn/access_computation/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevation-constraint","title":"Elevation Constraint","text":"<p>The most common constraint - requires satellites to be above a minimum elevation angle. This accounts for terrain obstructions, atmospheric effects, and antenna pointing limits.</p> <p>Basic elevation constraint:</p> PythonRust <pre><code>import brahe as bh\n\n# Require satellite to be at least 10 degrees above horizon\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nprint(f\"Created: {constraint}\")\n# Created:  ElevationConstraint(&gt;= 10.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Require satellite to be at least 10 degrees above horizon\n    let constraint = bh::ElevationConstraint::new(\n        Some(10.0),  // min elevation (degrees)\n        None  // max elevation (defaults to 90\u00b0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 10.00\u00b0)\n}\n</code></pre> <p>With maximum elevation:</p> PythonRust <pre><code>import brahe as bh\n\n# Side-looking sensor with elevation range\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0, max_elevation_deg=80.0)\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(10.00\u00b0 - 80.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Side-looking sensor with elevation range\n    let constraint = bh::ElevationConstraint::new(\n        Some(10.0),\n        Some(80.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(10.00\u00b0 - 80.00\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#elevation-mask-constraint","title":"Elevation Mask Constraint","text":"<p>Models azimuth-dependent elevation masks for terrain profiles, mountains, or buildings blocking low-elevation views in specific directions.</p> PythonRust <pre><code>import brahe as bh\n\n# Define elevation mask: [(azimuth_deg, elevation_deg), ...]\n# Azimuth clockwise from North (0-360)\nmask_points = [\n    (0.0, 5.0),  # North: 5\u00b0 minimum\n    (90.0, 15.0),  # East: 15\u00b0 minimum (mountains)\n    (180.0, 8.0),  # South: 8\u00b0 minimum\n    (270.0, 10.0),  # West: 10\u00b0 minimum\n    (360.0, 5.0),  # Back to North\n]\n\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationMaskConstraint(Min: 5.00\u00b0 at 0.00\u00b0, Max: 15.00\u00b0 at 90.00\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Define mask points in radians\n    let mask_points = vec![\n        (0.0, 5.0),\n        (90.0, 15.0),\n        (180.0, 8.0),\n        (270.0, 10.0),\n        (360.0, 5.0),\n    ];\n\n    let constraint = bh::ElevationMaskConstraint::new(mask_points);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationMaskConstraint(Min: 5.00\u00b0 at 0.00\u00b0, Max: 15.00\u00b0 at 90.00\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#off-nadir-constraint","title":"Off-Nadir Constraint","text":"<p>Limits the off-nadir viewing angle for imaging satellites. Off-nadir angle is measured from the satellite's nadir (straight down) to the target location.</p> <p>Imaging payload:</p> PythonRust <pre><code>import brahe as bh\n\n# Imaging payload with 30\u00b0 maximum off-nadir\nconstraint = bh.OffNadirConstraint(max_off_nadir_deg=30.0)\n\nprint(f\"Created: {constraint}\")\n# Created: OffNadirConstraint(&lt;= 30.0\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Imaging payload with 30\u00b0 maximum off-nadir\n    let constraint = bh::OffNadirConstraint::new(\n        None,  // min off-nadir (defaults to 0\u00b0)\n        Some(30.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: OffNadirConstraint(&lt;= 30.0\u00b0)\n}\n</code></pre> <p>Side-looking radar:</p> PythonRust <pre><code>import brahe as bh\n\n# Side-looking radar requiring specific geometry\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=20.0, max_off_nadir_deg=45.0)\n\nprint(f\"Created: {constraint}\")\n# Created: OffNadirConstraint(20.0\u00b0 - 45.0\u00b0)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Side-looking radar\n    let constraint = bh::OffNadirConstraint::new(\n        Some(20.0),\n        Some(45.0)\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: OffNadirCOffNadirConstraint(20.0\u00b0 - 45.0\u00b0)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#local-time-constraint","title":"Local Time Constraint","text":"<p>Filters access windows by local solar time at the ground location. Useful for daylight-only imaging or night-time astronomy observations.</p> <p>Single time window:</p> PythonRust <pre><code>import brahe as bh\n\n# Daylight imaging: 8:00 AM to 6:00 PM local solar time\n# Times in military format: HHMM\nconstraint = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(08:00-18:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Daylight imaging: 8:00 AM to 6:00 PM\n    let constraint = bh::LocalTimeConstraint::new(\n        vec![(800, 1800)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(08:00-18:00)\n}\n</code></pre> <p>Multiple time windows:</p> PythonRust <pre><code>import brahe as bh\n\n# Multiple windows: dawn and dusk passes\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 800), (1800, 2000)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(06:00-08:00, 18:00-20:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Multiple windows\n    let constraint = bh::LocalTimeConstraint::new(\n        vec![(600, 800), (1800, 2000)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(06:00-08:00, 18:00-20:00)\n}\n</code></pre> <p>Using decimal hours:</p> PythonRust <pre><code>import brahe as bh\n\n# Alternative: specify in decimal hours\nconstraint = bh.LocalTimeConstraint.from_hours(time_windows=[(8.0, 18.0)])\n\nprint(f\"Created: {constraint}\")\n# Created: LocalTimeConstraint(08:00-18:00)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // From decimal hours\n    let constraint = bh::LocalTimeConstraint::from_hours(\n        vec![(8.0, 18.0)]\n    ).unwrap();\n\n    println!(\"Created: {}\", constraint);\n    // Created: LocalTimeConstraint(08:00-18:00)\n}\n</code></pre> <p>Local Solar Time</p> <p>Local solar time is based on the Sun's position relative to the location, not clock time zones. Noon (1200) is when the Sun is highest in the sky.</p>"},{"location":"learn/access_computation/constraints.html#look-direction-constraint","title":"Look Direction Constraint","text":"<p>Requires the satellite to look in a specific direction relative to its velocity vector - left, right, or either side.</p> <p>Left-looking:</p> PythonRust <pre><code>import brahe as bh\nfrom brahe import LookDirection\n\n# Require left-looking geometry\nconstraint = bh.LookDirectionConstraint(allowed=LookDirection.LEFT)\n\nprint(f\"Created: {constraint}\")\n# Created: LookDirectionConstraint(Left)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Require left-looking geometry\n    let constraint = bh::LookDirectionConstraint::new(\n        bh::LookDirection::Left\n    );\n\n    println!(\"Created: {}\", constraint);\n    // Created: LookDirectionConstraint(Left)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#ascending-descending-constraint","title":"Ascending-Descending Constraint","text":"<p>Filters passes by whether the satellite is ascending (moving south-to-north) or descending (north-to-south) over the location.</p> <p>Ascending passes:</p> PythonRust <pre><code>import brahe as bh\nfrom brahe import AscDsc\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=AscDsc.ASCENDING)\n\nprint(f\"Created: {constraint}\")\n# Created: AscDscConstraint(Ascending)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Only ascending passes\n    let constraint = bh::AscDscConstraint::new(\n        bh::AscDsc::Ascending\n    );\n\n    println!(\"Created: {}\", constraint);\n    // Created: AscDscConstraint(Ascending)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraint-composition","title":"Constraint Composition","text":"<p>Combine constraints using Boolean logic to express complex requirements.</p>"},{"location":"learn/access_computation/constraints.html#constraintall-and-logic","title":"ConstraintAll (AND Logic)","text":"<p>All child constraints must be satisfied simultaneously:</p> PythonRust <pre><code>import brahe as bh\n\n# Elevation &gt; 10\u00b0 AND daylight hours\nelev = bh.ElevationConstraint(min_elevation_deg=10.0)\ndaytime = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\n\nconstraint = bh.ConstraintAll(constraints=[elev, daytime])\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n</code></pre> <pre><code>fn main() {\n    // Elevation &gt; 10\u00b0 AND daylight hours\n    let elev = Box::new(bh::ElevationConstraint::new(Some(10.0), None).unwrap());\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(800, 1800)]).unwrap());\n\n    let constraint = bh::ConstraintComposite::All(vec![elev, daytime]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraintany-or-logic","title":"ConstraintAny (OR Logic)","text":"<p>At least one child constraint must be satisfied:</p> PythonRust <pre><code>import brahe as bh\n\n# High elevation OR right-looking geometry\nhigh_elev = bh.ElevationConstraint(min_elevation_deg=60.0)\nright_look = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\nconstraint = bh.ConstraintAny(constraints=[high_elev, right_look])\n\nprint(f\"Created: {constraint}\")\n# Created: ConstraintAny(constraints: [ElevationConstraint(...), LookDirectionConstraint(...)])\n</code></pre> <pre><code>fn main() {\n    // High elevation OR right-looking geometry\n    let high_elev = Box::new(bh::ElevationConstraint::new(Some(60.0), None).unwrap());\n    let right_look = Box::new(bh::LookDirectionConstraint::new(bh::LookDirection::Right));\n\n    let constraint = bh::ConstraintComposite::Any(vec![high_elev, right_look]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) || LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraintnot-negation","title":"ConstraintNot (Negation)","text":"<p>Inverts a constraint - access occurs when the child constraint is NOT satisfied:</p> PythonRust <pre><code>import brahe as bh\n\n# Avoid daylight (e.g., for night-time astronomy)\ndaytime = bh.LocalTimeConstraint(time_windows=[(600, 2000)])\nnight_only = bh.ConstraintNot(constraint=daytime)\n\nprint(f\"Created: {night_only}\")\n# Created: !LocalTimeConstraint(06:00-20:00)\n</code></pre> <pre><code>fn main() {\n    // Avoid daylight (e.g., for night-time astronomy)\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(600, 2000)]).unwrap());\n    let night_only = bh::ConstraintComposite::Not(daytime);\n\n    println!(\"Created: {}\", night_only);\n    // Created: !LocalTimeConstraint(06:00-20:00)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#complex-composition","title":"Complex Composition","text":"<p>Build complex logic by combining multiple constraints:</p> PythonRust <pre><code>import brahe as bh\n\n# Complex constraint: (High elevation AND daylight)\n# Note: Python API currently supports single-level composition\n# For nested constraints, use Rust API with Box&lt;dyn AccessConstraint&gt;\n\n# High elevation AND daylight\nhigh_elev = bh.ElevationConstraint(min_elevation_deg=60.0)\ndaytime = bh.LocalTimeConstraint(time_windows=[(800, 1800)])\nlook_right = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Combine multiple constraints with AND\nconstraint = bh.ConstraintAll(constraints=[high_elev, daytime, look_right])\n\nprint(f\"Created: {constraint}\")\n# Created: ElevationConstraint(&gt;= 60.00\u00b0) &amp;&amp; LocalTimeConstraint(08:00-18:00) &amp;&amp; LookDirectionConstraint(Right)\n</code></pre> <pre><code>fn main() {\n    // Complex constraint: High elevation AND daylight AND right-looking\n    let high_elev = Box::new(bh::ElevationConstraint::new(Some(60.0), None).unwrap());\n    let daytime = Box::new(bh::LocalTimeConstraint::new(vec![(800, 1800)]).unwrap());\n    let look_right = Box::new(bh::LookDirectionConstraint::new(bh::LookDirection::Right));\n\n    // Combine multiple constraints with AND\n    let constraint = bh::ConstraintComposite::All(vec![high_elev, daytime, look_right]);\n\n    println!(\"Created: {}\", constraint);\n    // Created: ElevationConstraint(&gt;= 60.00\u00b0) &amp;&amp; LocalTimeConstraint(08:00-18:00) &amp;&amp; LookDirectionConstraint(Right)\n}\n</code></pre>"},{"location":"learn/access_computation/constraints.html#custom-constraints-python","title":"Custom Constraints (Python)","text":"<p>Python users can create fully custom constraints by implementing the <code>AccessConstraintComputer</code> interface:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n\nclass MaxRangeConstraint(bh.AccessConstraintComputer):\n    \"\"\"Limit access to satellites within a maximum range.\"\"\"\n\n    def __init__(self):\n        self.max_range_m = 2000.0 * 1000.0  # 2000 km in meters\n\n    def evaluate(self, epoch, satellite_state_ecef, location_ecef):\n        \"\"\"Return True when constraint is satisfied\"\"\"\n        # Compute range vector from location to satellite\n        range_vec = satellite_state_ecef[:3] - location_ecef\n        range_m = np.linalg.norm(range_vec)\n\n        return range_m &lt;= self.max_range_m\n\n    def name(self):\n        return f\"MaxRange({self.max_range_m / 1000:.0f}km)\"\n\n\n# Use custom constraint\nconstraint = MaxRangeConstraint()\n\nprint(f\"Created: {constraint.name()}\")\n# Created: MaxRange(2000km)\n</code></pre> <p>Custom Constraints in Rust</p> <p>Rust users implement the <code>AccessConstraint</code> trait directly. This provides maximum performance but requires recompiling the library.</p>"},{"location":"learn/access_computation/constraints.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types</li> <li>Computation - How constraints are evaluated during access search</li> <li>API Reference: Constraints</li> <li>Example: Predicting Ground Contacts</li> <li>Example: Computing Imaging Opportunities</li> </ul>"},{"location":"learn/access_computation/locations.html","title":"Locations","text":"<p>Locations represent ground positions or areas that satellites can access. Brahe provides two fundamental location types\u2014points and polygons\u2014with full GeoJSON interoperability and extensible metadata support.</p> <p>All location types implement the <code>AccessibleLocation</code> trait, which provides a common interface for coordinate access, property management, and GeoJSON import/export. This design allows you to work with different location geometries through a unified API.</p> <p>Coordinate Units</p> <p>All coordinates are specified in geodetic longitude (\u03bb), latitude (\u03c6), and altitude (h) using the WGS84 reference frame. All units are in degrees (for \u03bb and \u03c6) and meters (for h) for consistency with the GeoJSON standard.</p>"},{"location":"learn/access_computation/locations.html#pointlocation","title":"PointLocation","text":"<p>A <code>PointLocation</code> represents a single geodetic point on Earth's surface. This is the most common location type, used for ground stations, cities, or specific observation points.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-coordinates","title":"Initialization from Coordinates","text":"<p>Create a point location from geodetic coordinates (longitude, latitude, altitude):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create location (longitude, latitude, altitude in meters)\n# San Francisco, CA\nsf = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Add an identifier for clarity\nsf = sf.with_name(\"San Francisco\")\n\nprint(f\"Location: {sf.get_name()}\")\nprint(f\"Longitude: {sf.longitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Latitude: {sf.latitude(bh.AngleFormat.DEGREES):.4f} deg\")\n\n# Expected output:\n# Location: San Francisco\n# Longitude: -122.4194 deg\n# Latitude: 37.7749 deg\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create location (longitude, latitude, altitude in meters)\n    // San Francisco, CA\n    let sf = bh::PointLocation::new(\n        -122.4194,  // longitude in degrees\n        37.7749,    // latitude in degrees\n        0.0         // altitude in meters\n    ).with_name(\"San Francisco\");\n\n    let geodetic = sf.center_geodetic();\n    println!(\"Location: {}\", sf.get_name().unwrap_or_default());\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n\n    // Expected output:\n    // Location: San Francisco\n    // Longitude: -122.4194 deg\n    // Latitude: 37.7749 deg\n}\n</code></pre> <p>Coordinate Units</p> <p>Python uses degrees for input convenience. Rust uses radians (SI standard). Both use meters for altitude.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-geojson","title":"Initialization from GeoJSON","text":"<p>Load locations from GeoJSON strings or files:</p> PythonRust <pre><code>import brahe as bh\nimport json\n\nbh.initialize_eop()\n\n# GeoJSON Point feature\ngeojson_str = \"\"\"\n{\n    \"type\": \"Feature\",\n    \"properties\": {\"name\": \"Svalbard Station\"},\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4038, 78.2232, 458.0]\n    }\n}\n\"\"\"\n\nlocation = bh.PointLocation.from_geojson(json.loads(geojson_str))\nprint(f\"Loaded: {location.get_name()}\")\nprint(f\"Longitude: {location.longitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Latitude: {location.latitude(bh.AngleFormat.DEGREES):.4f} deg\")\nprint(f\"Altitude: {location.altitude():.1f} m\")\n\n# Expected output:\n# Loaded: Svalbard Station\n# Longitude: 15.4038 deg\n# Latitude: 78.2232 deg\n# Altitude: 458.0 m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // GeoJSON Point feature\n    let geojson = r#\"\n    {\n        \"type\": \"Feature\",\n        \"properties\": {\"name\": \"Svalbard Station\"},\n        \"geometry\": {\n            \"type\": \"Point\",\n            \"coordinates\": [15.4038, 78.2232, 458.0]\n        }\n    }\n    \"#;\n\n    // Parse JSON string first\n    let json: serde_json::Value = serde_json::from_str(geojson).unwrap();\n    let location = bh::PointLocation::from_geojson(&amp;json).unwrap();\n    let geodetic = location.center_geodetic();\n    println!(\"Loaded: {}\", location.get_name().unwrap_or_default());\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n    println!(\"Altitude: {:.1} m\", geodetic[2]);\n\n    // Expected output:\n    // Loaded: Svalbard Station\n    // Longitude: 15.4038 deg\n    // Latitude: 78.2232 deg\n    // Altitude: 458.0 m\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#accessing-coordinates","title":"Accessing Coordinates","text":"<p>Retrieve coordinates in different formats:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Access in degrees\nprint(f\"Longitude: {location.longitude(bh.AngleFormat.DEGREES)} deg\")\nprint(f\"Latitude: {location.latitude(bh.AngleFormat.DEGREES)} deg\")\nprint(f\"Altitude: {location.altitude()} m\")\n\n# Shorthand access (in degrees)\nprint(f\"Lon (deg): {location.lon:.6f}\")\nprint(f\"Lat (deg): {location.lat:.6f}\")\n\n# Get geodetic array [lat, lon, alt] in radians and meters\ngeodetic = location.center_geodetic()\nprint(f\"Geodetic: [{geodetic[0]:.6f}, {geodetic[1]:.6f}, {geodetic[2]:.1f}]\")\n\n# Get ECEF Cartesian position [x, y, z] in meters\necef = location.center_ecef()\nprint(f\"ECEF: [{ecef[0]:.1f}, {ecef[1]:.1f}, {ecef[2]:.1f}] m\")\n\n# Expected output:\n# Longitude: -122.4194 deg\n# Latitude: 37.7749 deg\n# Altitude: 0.0 m\n# Lon (deg): -122.419400\n# Lat (deg): 37.774900\n# Geodetic: [-122.419400, 37.774900, 0.0]\n# ECEF: [-2706174.8, -4261059.5, 3885725.5] m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0\n    );\n\n    // Access geodetic coordinates (in degrees)\n    let geodetic = location.center_geodetic();\n    println!(\"Longitude: {:.4} deg\", geodetic[0]);\n    println!(\"Latitude: {:.4} deg\", geodetic[1]);\n    println!(\"Altitude: {:.1} m\", geodetic[2]);\n\n\n    // Get ECEF Cartesian position [x, y, z] in meters\n    let ecef = location.center_ecef();\n    println!(\"ECEF: [{:.1}, {:.1}, {:.1}] m\", ecef[0], ecef[1], ecef[2]);\n\n    // Expected output:\n    // Longitude: -122.4194 deg\n    // Latitude: 37.7749 deg\n    // Altitude: 0.0 m\n    // ECEF: [-2706174.8, -4261059.5, 3885725.5] m\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#polygonlocation","title":"PolygonLocation","text":"<p>A <code>PolygonLocation</code> represents a closed polygon area on Earth's surface. This is useful for imaging regions, coverage zones, or geographic areas of interest.</p>"},{"location":"learn/access_computation/locations.html#initialization-from-vertices","title":"Initialization from Vertices","text":"<p>Create a polygon from a list of vertices:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define polygon vertices (longitude, latitude, altitude)\n# Simple rectangular region\nvertices = [\n    [-122.5, 37.7, 0.0],\n    [-122.35, 37.7, 0.0],\n    [-122.35, 37.8, 0.0],\n    [-122.5, 37.8, 0.0],\n    [-122.5, 37.7, 0.0],  # Close the polygon\n]\n\npolygon = bh.PolygonLocation(vertices).with_name(\"SF Region\")\n\nprint(f\"Name: {polygon.get_name()}\")\nprint(f\"Vertices: {polygon.num_vertices}\")\nprint(\n    f\"Center: ({polygon.longitude(bh.AngleFormat.DEGREES):.4f}, {polygon.latitude(bh.AngleFormat.DEGREES):.4f})\"\n)\n\n# Expected output:\n# Name: SF Region\n# Vertices: 4\n# Center: (-122.4250, 37.7500)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define polygon vertices (lon, lat, alt in degrees and meters)\n    let vertices = vec![\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.7, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.35, 37.7, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.35, 37.8, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.8, 0.0),\n        na::SVector::&lt;f64, 3&gt;::new(-122.5, 37.7, 0.0),\n    ];\n\n    let polygon = bh::PolygonLocation::new(vertices).unwrap()\n        .with_name(\"SF Region\");\n\n    let center = polygon.center_geodetic();\n    println!(\"Name: {}\", polygon.get_name().unwrap_or_default());\n    println!(\"Vertices: {}\", polygon.num_vertices());\n    println!(\"Center: ({:.4}, {:.4})\", center[0], center[1]);\n\n    // Expected output:\n    // Name: SF Region\n    // Vertices: 4\n    // Center: (-122.4250, 37.7500)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#initialization-from-geojson_1","title":"Initialization from GeoJSON","text":"<p>Load polygon areas from GeoJSON:</p> PythonRust <pre><code>import brahe as bh\nimport json\n\nbh.initialize_eop()\n\n# GeoJSON Polygon feature\ngeojson_str = \"\"\"\n{\n    \"type\": \"Feature\",\n    \"properties\": {\"name\": \"Target Area\"},\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [-122.5, 37.7, 0],\n            [-122.35, 37.7, 0],\n            [-122.35, 37.8, 0],\n            [-122.5, 37.8, 0],\n            [-122.5, 37.7, 0]\n        ]]\n    }\n}\n\"\"\"\n\npolygon = bh.PolygonLocation.from_geojson(json.loads(geojson_str))\n\nprint(f\"Name: {polygon.get_name()}\")\nprint(f\"Vertices: {polygon.num_vertices}\")\nprint(\n    f\"Center: ({polygon.longitude(bh.AngleFormat.DEGREES):.4f}, {polygon.latitude(bh.AngleFormat.DEGREES):.4f})\"\n)\n\n# Expected output:\n# Name: Target Area\n# Vertices: 5\n# Center: (-122.4250, 37.7500)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let geojson = r#\"\n    {\n        \"type\": \"Feature\",\n        \"properties\": {\"name\": \"Target Area\"},\n        \"geometry\": {\n            \"type\": \"Polygon\",\n            \"coordinates\": [[\n                [-122.5, 37.7, 0],\n                [-122.35, 37.7, 0],\n                [-122.35, 37.8, 0],\n                [-122.5, 37.8, 0],\n                [-122.5, 37.7, 0]\n            ]]\n        }\n    }\n    \"#;\n\n    // Parse JSON string first\n    let json: serde_json::Value = serde_json::from_str(geojson).unwrap();\n    let polygon = bh::PolygonLocation::from_geojson(&amp;json).unwrap();\n\n    let center = polygon.center_geodetic();\n    println!(\"Name: {}\", polygon.get_name().unwrap_or_default());\n    println!(\"Vertices: {}\", polygon.num_vertices());\n    println!(\"Center: ({:.4}, {:.4})\", center[0], center[1]);\n\n    // Expected output:\n    // Name: Target Area\n    // Vertices: 4\n    // Center: (-122.4250, 37.7500)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#working-with-properties","title":"Working with Properties","text":"<p>Both location types support custom properties for storing metadata:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Add scalar properties\nlocation.add_property(\"antenna_gain_db\", 42.5)\nlocation.add_property(\"frequency_mhz\", 8450.0)\n\n# Add string properties\nlocation.add_property(\"operator\", \"NOAA\")\n\n# Add boolean flags\nlocation.add_property(\"uplink_enabled\", True)\n\n# Retrieve properties\nprops = location.properties\ngain = props.get(\"antenna_gain_db\")\noperator = props.get(\"operator\")\nuplink = props.get(\"uplink_enabled\")\n\nprint(f\"Antenna Gain: {gain}\")\nprint(f\"Operator: {operator}\")\nprint(f\"Uplink Enabled: {uplink}\")\n\n# Expected output:\n# Antenna Gain: 42.5\n# Operator: NOAA\n# Uplink Enabled: True\n</code></pre> <pre><code>use brahe as bh;\nuse bh::AccessibleLocation;\nuse serde_json::json;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(-122.4194, 37.7749, 0.0)\n        .add_property(\"antenna_gain_db\", json!(42.5))\n        .add_property(\"frequency_mhz\", json!(8450.0))\n        .add_property(\"operator\", json!(\"NOAA\"))\n        .add_property(\"uplink_enabled\", json!(true));\n\n    // Access properties\n    let props = location.properties();\n    if let Some(gain) = props.get(\"antenna_gain_db\") {\n        println!(\"Antenna Gain: {}\", gain);\n    }\n    if let Some(operator) = props.get(\"operator\") {\n        println!(\"Operator: {}\", operator);\n    }\n    if let Some(uplink) = props.get(\"uplink_enabled\") {\n        println!(\"Uplink Enabled: {}\", uplink);\n    }\n\n    // Expected output:\n    // Antenna Gain: 42.5\n    // Operator: \"NOAA\"\n    // Uplink Enabled: true\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#exporting-to-geojson","title":"Exporting to GeoJSON","text":"<p>Convert locations back to GeoJSON format:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nlocation = (\n    bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\").with_id(1)\n)\n\n# Export to GeoJSON dict\ngeojson = location.to_geojson()\nprint(\"Exported GeoJSON:\")\nprint(geojson)\n\n# The output includes all properties and identifiers\n# Can be loaded back with from_geojson()\nreloaded = bh.PointLocation.from_geojson(geojson)\nprint(f\"\\nReloaded: {reloaded.get_name()} (ID: {reloaded.get_id()})\")\n\n# Expected output:\n# Exported GeoJSON:\n# {'geometry': {'coordinates': [-122.4194, 37.7749, 0.0], 'type': 'Point'}, 'properties': {'id': 1, 'name': 'San Francisco'}, 'type': 'Feature'}\n#\n# Reloaded: San Francisco (ID: 1)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse bh::AccessibleLocation;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let location = bh::PointLocation::new(-122.4194, 37.7749, 0.0)\n        .with_name(\"San Francisco\")\n        .with_id(1);\n\n    // Export to GeoJSON\n    let geojson = location.to_geojson();\n    println!(\"Exported GeoJSON:\");\n    println!(\"{}\", geojson);\n\n    // The output includes all properties and identifiers\n    // Can be loaded back with from_geojson()\n    let reloaded = bh::PointLocation::from_geojson(&amp;geojson).unwrap();\n    println!(\"\\nReloaded: {} (ID: {})\",\n        reloaded.get_name().unwrap_or_default(),\n        reloaded.get_id().unwrap_or(0));\n\n    // Expected output:\n    // Exported GeoJSON:\n    // {\"geometry\":{\"coordinates\":[-122.4194,37.7749,0.0],\"type\":\"Point\"},\"properties\":{\"id\":1,\"name\":\"San Francisco\"},\"type\":\"Feature\"}\n    //\n    // Reloaded: San Francisco (ID: 1)\n}\n</code></pre>"},{"location":"learn/access_computation/locations.html#see-also","title":"See Also","text":"<ul> <li>Constraints - Defining access criteria for locations</li> <li>Computation - Access algorithms and property computation</li> <li>API Reference: Locations</li> <li>Example: Predicting Ground Contacts</li> </ul>"},{"location":"learn/access_computation/properties.html","title":"Access Properties","text":"<p>Access properties are geometric and temporal measurements computed for each access window. Brahe automatically calculates core properties during access searches, and provides both built-in and custom property computers for mission-specific analysis.</p>"},{"location":"learn/access_computation/properties.html#core-properties","title":"Core Properties","text":"<p>Brahe automatically computes these temporal and geometric properties for every access window:</p> Name Type Description <code>window_open</code> <code>Epoch</code> UTC time when access window starts <code>window_close</code> <code>Epoch</code> UTC time when access window ends <code>duration</code> <code>float</code> Total duration of access window in seconds <code>midtime</code> <code>Epoch</code> UTC time at midpoint of access window <code>azimuth_open</code> <code>float</code> Azimuth angle from location to satellite at window start (degrees) <code>azimuth_close</code> <code>float</code> Azimuth angle from location to satellite at window end (degrees) <code>elevation_min</code> <code>float</code> Minimum elevation angle during access window (degrees) <code>elevation_max</code> <code>float</code> Maximum elevation angle during access window (degrees) <code>local_time</code> <code>float</code> Local solar time at window midpoint in seconds \\(\\left[0, 86400\\right)\\) <code>look_direction</code> <code>LookDirection</code> Satellite look direction relative to velocity <code>asc_dsc</code> <code>AscDsc</code> Pass classification based on satellite motion <p>Core properties are attributes of the <code>AccessWindow</code> object returned by access computations and can be accessed directly like <code>window.window_open</code> or <code>window.elevation_max</code>.</p> <p>Below are examples of accessing core properties in Python and Rust.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create location (San Francisco area)\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0)\n\n# Create propagator from TLE (ISS example)\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0)\n\n# Define time period (24 hours from epoch)\nepoch_start = bh.Epoch.from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch_end = epoch_start + 86400.0\n\n# Create elevation constraint\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(\n    [location], [propagator], epoch_start, epoch_end, constraint\n)\n\n# Access core properties from first window\nif windows:\n    window = windows[0]\n    props = window.properties\n\n    print(\"Window \")\n    t_start = window.window_open\n    t_end = window.window_close\n    print(f\"  Start: {t_start}\")\n    print(f\"  End:   {t_end}\")\n    print(f\"  Duration: {window.duration:.1f} seconds\")\n    print(f\"  Midtime: {window.midtime}\")\n\n    print(\"\\nProperties:\")\n\n    # Azimuth values (open and close)\n    az_open = props.azimuth_open\n    az_close = props.azimuth_close\n    print(f\"  Azimuth - Min: {az_open:.1f}\u00b0, Max: {az_close:.1f}\u00b0\")\n\n    # Elevation range (min and max)\n    elev_min = props.elevation_min\n    elev_max = props.elevation_max\n    print(f\"  Elevation - Min: {elev_min:.1f}\u00b0, Max: {elev_max:.1f}\u00b0\")\n\n    # Off-nadir range (min and max)\n    off_nadir_min = props.off_nadir_min\n    off_nadir_max = props.off_nadir_max\n    print(f\"  Off-nadir - Min: {off_nadir_min:.1f}\u00b0, Max: {off_nadir_max:.1f}\u00b0\")\n\n    # Local solar time at midpoint\n    local_time = props.local_time\n    hours = int(local_time // 3600)\n    minutes = (local_time - hours * 3600) / 60\n    print(f\"  Local time: {hours:02d}:{minutes:02.2f}\")\n\n    # Look direction\n    look = props.look_direction\n    print(f\"  Look direction: {look}\")\n\n    # Ascending/Descending\n    asc_dsc = props.asc_dsc\n    print(f\"  Ascending/Descending: {asc_dsc}\")\n\n# Expected output (values will vary based on TLE and time):\n# Window\n#   Start: 2025-11-02 05:39:28.345 UTC\n#   End:   2025-11-02 05:44:00.000 UTC\n#   Duration: 271.7 seconds\n#   Midtime: 2025-11-02 05:41:44.172 UTC\n\n# Properties:\n#   Azimuth - Min: 177.0\u00b0, Max: 87.3\u00b0\n#   Elevation - Min: 10.0\u00b0, Max: 18.7\u00b0\n#   Off-nadir - Min: 62.6\u00b0, Max: 67.4\u00b0\n#   Local time: 05:37.24\n#   Look direction: Left\n#   Ascending/Descending: Ascending\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Create location (San Francisco area)\n    let location = bh::PointLocation::new(\n        -122.4194,\n        37.7749,\n        0.0\n    );\n\n    // Create propagator from TLE (ISS example)\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?;\n\n    // Define time period (24 hours from epoch)\n    let epoch_start = bh::Epoch::from_datetime(2025, 11, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epoch_end = epoch_start + 86400.0;\n\n    // Create elevation constraint\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n\n    // Compute access windows\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    )?;\n\n    // Access core properties from first window\n    if !windows.is_empty() {\n        let window = &amp;windows[0];\n        let props = &amp;window.properties;\n\n        println!(\"Window \");\n        let t_start = window.window_open;\n        let t_end = window.window_close;\n        println!(\"  Start: {}\", t_start);\n        println!(\"  End:   {}\", t_end);\n        println!(\"  Duration: {:.1} seconds\", window.duration());\n        println!(\"  Midtime: {}\", window.midtime());\n\n        println!(\"\\nProperties:\");\n\n        // Azimuth values (open and close)\n        let az_open = props.azimuth_open;\n        let az_close = props.azimuth_close;\n        println!(\"  Azimuth - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", az_open, az_close);\n\n        // Elevation range (min and max)\n        let elev_min = props.elevation_min;\n        let elev_max = props.elevation_max;\n        println!(\"  Elevation - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", elev_min, elev_max);\n\n        // Off-nadir range (min and max)\n        let off_nadir_min = props.off_nadir_min;\n        let off_nadir_max = props.off_nadir_max;\n        println!(\"  Off-nadir - Min: {:.1}\u00b0, Max: {:.1}\u00b0\", off_nadir_min, off_nadir_max);\n\n        // Local solar time at midpoint (local_time is in seconds since midnight)\n        let local_time = props.local_time;\n        let hours = (local_time / 3600.0).floor() as i32;\n        let minutes = (local_time - hours as f64 * 3600.0) / 60.0;\n        println!(\"  Local time: {:02}:{:05.2}\", hours, minutes);\n\n        // Look direction\n        let look = &amp;props.look_direction;\n        println!(\"  Look direction: {}\", look);\n\n        // Ascending/Descending\n        let asc_dsc = &amp;props.asc_dsc;\n        println!(\"  Ascending/Descending: {}\", asc_dsc);\n    }\n\n    Ok(())\n}\n// Expected output (values will vary based on TLE and time):\n// Window \n//   Start: 2025-11-02 05:39:28.345 UTC\n//   End:   2025-11-02 05:44:00.000 UTC\n//   Duration: 271.7 seconds\n//   Midtime: 2025-11-02 05:41:44.172 UTC\n\n// Properties:\n//   Azimuth - Min: 177.0\u00b0, Max: 87.3\u00b0\n//   Elevation - Min: 10.0\u00b0, Max: 18.7\u00b0\n//   Off-nadir - Min: 62.6\u00b0, Max: 67.4\u00b0\n//   Local time: 05:37.24\n//   Look direction: Left\n//   Ascending/Descending: Ascending\n</code></pre>"},{"location":"learn/access_computation/properties.html#property-computers","title":"Property Computers","text":"<p>Property computers allow users to extend the access computation system to define and compute custom properties for each access window beyond the core set. These computations are performed after access windows are identified and refined. </p> <p>Python users can implement property computers by subclassing <code>AccessPropertyComputer</code>, while in Rust you implement the <code>AccessPropertyComputer</code> trait. These traits require the implementation of the <code>sampling_config</code> and <code>compute</code> methods. <code>sampling_config</code> defines how satellite states are sampled during the access window, and <code>compute</code> performs the actual property calculation using those sampled states.</p> <p>Brahe defines a few built-in property computers for common use cases, and users can create custom property computers for application-specific needs.</p>"},{"location":"learn/access_computation/properties.html#sampling-configuration","title":"Sampling Configuration","text":"<p>Property computers use <code>SamplingConfig</code> to determine when satellite states are sampled within the access window. That is, what <code>epoch, state</code> pairs are provided to the computer for its calculations.</p> <p>You can choose from several sampling modes:</p> <ul> <li><code>relative_points([0.0, 0.5, 1.0])</code> - Samples at specified fractions of the window duration with 0.0 being the start and 1.0 being the end</li> <li><code>fixed_count(n)</code> - Samples a fixed number of evenly spaced points within the window</li> <li><code>fixed_interval(interval, offset)</code> - Samples at regular time intervals (defined by seconds between samples) throughout the window with an optional offset</li> <li><code>midpoint</code> - Samples only at the midpoint of the window</li> </ul> <p>This allows you to compute time-series data at specific intervals or points.</p>"},{"location":"learn/access_computation/properties.html#sampling-modes","title":"Sampling Modes","text":"PythonRust <pre><code>import brahe as bh\n\n# Single sample at window midpoint (default)\nconfig = bh.SamplingConfig.midpoint()\nprint(f\"Midpoint: {config}\")\n# Midpoint: SamplingConfig.Midpoint\n\n# Specific relative points [0.0, 1.0] from window start to end\nconfig = bh.SamplingConfig.relative_points([0.0, 0.25, 0.5, 0.75, 1.0])\nprint(f\"Relative points: {config}\")\n# Relative points: SamplingConfig.RelativePoints([0.0, 0.25, 0.5, 0.75, 1.0])\n\n# Fixed time interval in seconds\nconfig = bh.SamplingConfig.fixed_interval(1.0, offset=0.0)  # 1 second\nprint(f\"Fixed interval (1s): {config}\")\n# Fixed interval (1s): SamplingConfig.FixedInterval(interval=1.0, offset=0.0)\n\n# Fixed number of evenly-spaced points\nconfig = bh.SamplingConfig.fixed_count(50)\nprint(f\"Fixed count (50): {config}\")\n# Fixed count (50): SamplingConfig.FixedCount(50)\n</code></pre> <pre><code>//! ```\n\nuse brahe::access::SamplingConfig;\n\nfn main() {\n    // Single sample at window midpoint (default)\n    let config = SamplingConfig::Midpoint;\n    println!(\"Midpoint: {:?}\", config);\n    // Midpoint: Midpoint\n\n    // Specific relative points [0.0, 1.0] from window start to end\n    let config = SamplingConfig::RelativePoints(vec![0.0, 0.25, 0.5, 0.75, 1.0]);\n    println!(\"Relative points: {:?}\", config);\n    // Relative points: RelativePoints([0.0, 0.25, 0.5, 0.75, 1.0])\n\n    // Fixed time interval in seconds\n    let config = SamplingConfig::FixedInterval {\n        interval: 1.0,  // 1 second\n        offset: 0.0\n    };\n    println!(\"Fixed interval (1s): {:?}\", config);\n    // Fixed interval (1s): FixedInterval { interval: 1.0, offset: 0.0 }\n\n    // Fixed number of evenly-spaced points\n    let config = SamplingConfig::FixedCount(50);\n    println!(\"Fixed count (50): {:?}\", config);\n    // Fixed count (50): FixedCount(50)\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#built-in-property-computers","title":"Built-in Property Computers","text":"<p>Brahe provides three commonly-used property computers optimized in Rust:</p>"},{"location":"learn/access_computation/properties.html#dopplercomputer","title":"DopplerComputer","text":"<p>Computes Doppler frequency shifts for uplink and/or downlink communications:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# S-band downlink only (8.4 GHz)\ndoppler = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=8.4e9,\n    sampling_config=bh.SamplingConfig.fixed_interval(0.1, 0.0),  # 0.1 seconds\n)\nprint(f\"Downlink only: {doppler}\")\n# Downlink only: DopplerComputer(uplink=None, downlink=8.4e9 Hz, ...)\n\n# Both uplink (2.0 GHz) and downlink (8.4 GHz)\ndoppler = bh.DopplerComputer(\n    uplink_frequency=2.0e9,\n    downlink_frequency=8.4e9,\n    sampling_config=bh.SamplingConfig.fixed_count(100),\n)\nprint(f\"Both frequencies: {doppler}\")\n# Both frequencies: DopplerComputer(uplink=2.0e9 Hz, downlink=8.4e9 Hz, ...)\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station (lon, lat, alt)\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with Doppler\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler],\n)\n\n# Access computed properties\nwindow = windows[0]\ndoppler_data = window.properties.additional[\"doppler_downlink\"]\ntimes = doppler_data[\"times\"]  # Seconds from window start\nvalues = doppler_data[\"values\"]  # Hz\nprint(\n    f\"\\nFirst pass downlink Doppler shift range: {min(values):.1f} to {max(values):.1f} Hz\"\n)\n# First pass Doppler shift range: -189220.9 to 189239.8 Hz\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{DopplerComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // S-band downlink only (8.4 GHz)\n    let _doppler = DopplerComputer::new(\n        None,  // No uplink\n        Some(8.4e9),  // Downlink frequency\n        SamplingConfig::FixedInterval { interval: 0.1, offset: 0.0 }  // 0.1 seconds\n    );\n    println!(\"Downlink only: uplink=None, downlink=8.4e9 Hz\");\n    // Downlink only: uplink=None, downlink=8.4e9 Hz\n\n    // Both uplink (2.0 GHz) and downlink (8.4 GHz)\n    let doppler = DopplerComputer::new(\n        Some(2.0e9),  // Uplink frequency\n        Some(8.4e9),  // Downlink frequency\n        SamplingConfig::FixedCount(100)\n    );\n    println!(\"Both frequencies: uplink=2.0e9 Hz, downlink=8.4e9 Hz\");\n    // Both frequencies: uplink=2.0e9 Hz, downlink=8.4e9 Hz\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station (lon, lat, alt)\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with Doppler\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;doppler]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let doppler_data = window.properties.additional.get(\"doppler_downlink\").unwrap();\n\n    // Extract values from TimeSeries\n    let values = match doppler_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    let min_val = values.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b));\n    let max_val = values.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b));\n\n    println!(\"\\nFirst pass downlink Doppler shift range: {:.1} to {:.1} Hz\", min_val, max_val);\n    // First pass Doppler shift range: -189220.9 to 189239.8 Hz\n\n    Ok(())\n}\n</code></pre> <p>Doppler Physics:</p> <ul> <li>Uplink: \\(\\Delta f = f_0\\frac{v_{los}}{c - v_{los}}\\) - Ground station pre-compensates transmit frequency</li> <li>Downlink: \\(\\Delta f = -f_0\\frac{v_{los}}{c}\\) - Ground station adjusts receive frequency</li> <li>Where \\(v_{los}\\) is the velocity of the object along the line of sight from the observer. With \\(v_{los} &lt; 0\\) when approaching and \\(v_{los} &gt; 0\\) when receding.</li> </ul>"},{"location":"learn/access_computation/properties.html#rangecomputer","title":"RangeComputer","text":"<p>Computes slant range (distance) from the location to the satellite:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute range at 50 evenly-spaced points\nrange_comp = bh.RangeComputer(sampling_config=bh.SamplingConfig.fixed_count(50))\nprint(f\"Range computer: {range_comp}\")\n# Range computer: RangeComputer(sampling=FixedCount(50))\n\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with range\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[range_comp],\n)\n\n# Access computed properties\nwindow = windows[0]\nrange_data = window.properties.additional[\"range\"]\ndistances_m = range_data[\"values\"]  # meters\ndistances_km = [d / 1000.0 for d in distances_m]\nprint(f\"\\nRange varies from {min(distances_km):.1f} to {max(distances_km):.1f} km\")\n# Range varies from 658.9 to 1501.0 km\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{RangeComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Compute range at 50 evenly-spaced points\n    let range_comp = RangeComputer::new(\n        SamplingConfig::FixedCount(50)\n    );\n    println!(\"Range computer: sampling=FixedCount(50)\");\n    // Range computer: sampling=FixedCount(50)\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with range\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;range_comp]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let range_data = window.properties.additional.get(\"range\").unwrap();\n\n    // Extract values from TimeSeries\n    let distances_m = match range_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    // Convert to km\n    let min_km = distances_m.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b)) / 1000.0;\n    let max_km = distances_m.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b)) / 1000.0;\n\n    println!(\"\\nRange varies from {:.1} to {:.1} km\", min_km, max_km);\n    // Range varies from 658.9 to 1501.0 km\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#rangeratecomputer","title":"RangeRateComputer","text":"<p>Computes line-of-sight velocity (range rate) with the convention that positive values indicate increasing range (satellite receding) and negative values indicate decreasing range (satellite approaching):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Compute range rate every 0.5 seconds\nrange_rate = bh.RangeRateComputer(\n    sampling_config=bh.SamplingConfig.fixed_interval(0.5, 0.0)  # 0.5 seconds\n)\nprint(f\"Range rate computer: {range_rate}\")\n# Range rate computer: RangeRateComputer()\n\n# Create a simple scenario to demonstrate usage\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute accesses with range rate\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[range_rate],\n)\n\n# Access computed properties\nwindow = windows[0]\nrr_data = window.properties.additional[\"range_rate\"]\nvelocities_mps = rr_data[\"values\"]  # m/s (positive=receding)\nprint(\n    f\"\\nRange rate varies from {min(velocities_mps):.1f} to {max(velocities_mps):.1f} m/s\"\n)\nprint(\"Negative = approaching (decreasing distance)\")\nprint(\"Positive = receding (increasing distance)\")\n# Range rate varies from -6382.0 to 6372.9 m/s\n# Negative = approaching (decreasing distance)\n# Positive = receding (increasing distance)\n</code></pre> <pre><code>//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse bh::access::{RangeRateComputer, SamplingConfig, PropertyValue};\nuse bh::utils::Identifiable;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // Compute range rate every 0.5 seconds\n    let range_rate = RangeRateComputer::new(\n        SamplingConfig::FixedInterval { interval: 0.5, offset: 0.0 }  // 0.5 seconds\n    );\n    println!(\"Range rate computer: sampling=FixedInterval(0.5s)\");\n    // Range rate computer: sampling=FixedInterval(0.5s)\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute accesses with range rate\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;range_rate]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    // Access computed properties\n    let window = &amp;windows[0];\n    let rr_data = window.properties.additional.get(\"range_rate\").unwrap();\n\n    // Extract values from TimeSeries\n    let velocities_mps = match rr_data {\n        PropertyValue::TimeSeries { values, .. } =&gt; values,\n        _ =&gt; panic!(\"Expected TimeSeries\"),\n    };\n\n    let min_vel = velocities_mps.iter().fold(f64::INFINITY, |a: f64, &amp;b| a.min(b));\n    let max_vel = velocities_mps.iter().fold(f64::NEG_INFINITY, |a: f64, &amp;b| a.max(b));\n\n    println!(\"\\nRange rate varies from {:.1} to {:.1} m/s\", min_vel, max_vel);\n    println!(\"Negative = approaching (decreasing distance)\");\n    println!(\"Positive = receding (increasing distance)\");\n    // Range rate varies from -6382.0 to 6372.9 m/s\n    // Negative = approaching (decreasing distance)\n    // Positive = receding (increasing distance)\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#custom-property-computers","title":"Custom Property Computers","text":"<p>You can also create your own property computer to compute application-specific properties values. The system will pre-sample the satellite state at the specified times defined by your <code>SamplingConfig</code>, so you don't need to manually propagate the trajectory.</p> <p>This section provides examples of custom property computers in both Python and Rust.</p>"},{"location":"learn/access_computation/properties.html#python-implementation","title":"Python Implementation","text":"<p>In python you subclass <code>AccessPropertyComputer</code> and implement three methods:</p> Python <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n\nclass MaxSpeedComputer(bh.AccessPropertyComputer):\n    \"\"\"Computes maximum ground speed during access.\"\"\"\n\n    def sampling_config(self):\n        # Sample every 0.5 seconds\n        return bh.SamplingConfig.fixed_interval(0.5, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        # Extract velocities from states\n        velocities = sample_states_ecef[:, 3:6]\n        speeds = np.linalg.norm(velocities, axis=1)\n        max_speed = np.max(speeds)\n\n        # Single value -&gt; returns as scalar\n        return {\n            \"max_ground_speed\": max_speed,  # Will be stored as Scalar\n        }\n\n    def property_names(self):\n        return [\"max_ground_speed\"]\n\n\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute with custom property\nmax_speed = MaxSpeedComputer()\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[max_speed],\n)\n\nfor window in windows:\n    speed = window.properties.additional[\"max_ground_speed\"]\n    print(f\"Max speed: {speed:.1f} m/s\")\n\n# Output example:\n# Max speed: 7360.1 m/s\n# Max speed: 7365.5 m/s\n# Max speed: 7361.2 m/s\n# Max speed: 7357.5 m/s\n# Max speed: 7357.8 m/s\n# Max speed: 7360.0 m/s\n</code></pre>"},{"location":"learn/access_computation/properties.html#combining-multiple-computers","title":"Combining Multiple Computers","text":"<p>Pass multiple computers to compute different properties simultaneously:</p> Python <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n\nclass MaxSpeedComputer(bh.AccessPropertyComputer):\n    \"\"\"Computes maximum ground speed during access.\"\"\"\n\n    def sampling_config(self):\n        return bh.SamplingConfig.fixed_interval(0.5, 0.0)\n\n    def compute(\n        self, window, sample_times, sample_states_ecef, location_ecef, location_geodetic\n    ):\n        velocities = sample_states_ecef[:, 3:6]\n        speeds = np.linalg.norm(velocities, axis=1)\n        max_speed = np.max(speeds)\n        return {\"max_ground_speed\": max_speed}\n\n    def property_names(self):\n        return [\"max_ground_speed\"]\n\n\n# Mix built-in and custom computers\ndoppler = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=2.2e9,\n    sampling_config=bh.SamplingConfig.fixed_interval(0.1, 0.0),\n)\n\nrange_comp = bh.RangeComputer(sampling_config=bh.SamplingConfig.midpoint())\n\ncustom_comp = MaxSpeedComputer()\n\n# Setup scenario\n# ISS orbit\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2, 60.0).with_name(\"ISS\")\n\nepoch_start = propagator.epoch\nepoch_end = epoch_start + 24 * 3600.0  # 24 hours\n\n# Ground station\nlocation = bh.PointLocation(-74.0060, 40.7128, 0.0)\n\n# Compute with all property computers\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nwindows = bh.location_accesses(\n    location,\n    propagator,\n    epoch_start,\n    epoch_end,\n    constraint,\n    property_computers=[doppler, range_comp, custom_comp],\n)\n\n# All properties available in results\nwindow = windows[0]\nprops = window.properties.additional\n\ndoppler_data = props[\"doppler_downlink\"]\nrange_data = props[\"range\"]\nmax_speed = props[\"max_ground_speed\"]\n\nprint(f\"Doppler: {len(doppler_data['values'])} samples\")\nprint(f\"Range: {range_data / 1000:.1f} km\")\nprint(f\"Max speed: {max_speed:.1f} m/s\")\n# Doppler: 3777 samples\n# Range: 658.4 km\n# Max speed: 7360.1 m/s\n</code></pre>"},{"location":"learn/access_computation/properties.html#rust-implementation","title":"Rust Implementation","text":"<p>To implement a custom property computer in Rust, create a struct that implements the <code>AccessPropertyComputer</code> trait by defining the <code>sampling_config</code> and <code>compute</code> methods.</p> Rust <pre><code>use brahe as bh;\nuse bh::access::{AccessPropertyComputer, AccessWindow, PropertyValue, SamplingConfig};\nuse bh::utils::{BraheError, Identifiable};\nuse std::collections::HashMap;\n\nstruct MaxSpeedComputer {\n    sampling_config: SamplingConfig,\n}\n\nimpl AccessPropertyComputer for MaxSpeedComputer {\n    fn sampling_config(&amp;self) -&gt; SamplingConfig {\n        self.sampling_config.clone()\n    }\n\n    fn compute(\n        &amp;self,\n        _window: &amp;AccessWindow,\n        _sample_epochs: &amp;[f64],\n        sample_states_ecef: &amp;[nalgebra::SVector&lt;f64, 6&gt;],\n        _location_ecef: &amp;nalgebra::Vector3&lt;f64&gt;,\n        _location_geodetic: &amp;nalgebra::Vector3&lt;f64&gt;,\n    ) -&gt; Result&lt;HashMap&lt;String, PropertyValue&gt;, BraheError&gt; {\n        let mut max_speed = 0.0;\n\n        for state in sample_states_ecef {\n            let velocity = state.fixed_rows::&lt;3&gt;(3);\n            let speed = velocity.norm();\n            if speed &gt; max_speed {\n                max_speed = speed;\n            }\n        }\n\n        let mut props = HashMap::new();\n        props.insert(\"max_ground_speed\".to_string(), PropertyValue::Scalar(max_speed));\n        Ok(props)\n    }\n\n    fn property_names(&amp;self) -&gt; Vec&lt;String&gt; {\n        vec![\"max_ground_speed\".to_string()]\n    }\n}\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    bh::initialize_eop()?;\n\n    // ISS orbit\n    let tle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\";\n    let tle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\";\n    let propagator = bh::SGPPropagator::from_tle(tle_line1, tle_line2, 60.0)?\n        .with_name(\"ISS\");\n\n    let epoch_start = propagator.epoch;\n    let epoch_end = epoch_start + 24.0 * 3600.0;\n\n    // Ground station\n    let location = bh::PointLocation::new(-74.0060, 40.7128, 0.0);\n\n    // Compute with custom property\n    let max_speed = MaxSpeedComputer {\n        sampling_config: SamplingConfig::FixedInterval {\n            interval: 0.5,  // 0.5 seconds\n            offset: 0.0,\n        },\n    };\n\n    let constraint = bh::ElevationConstraint::new(Some(10.0), None)?;\n    let windows = bh::location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        Some(&amp;[&amp;max_speed]),  // Property computers\n        None,  // Use default config\n        None,  // No time tolerance\n    )?;\n\n    for window in &amp;windows {\n        let speed = match window.properties.additional.get(\"max_ground_speed\").unwrap() {\n            PropertyValue::Scalar(s) =&gt; s,\n            _ =&gt; panic!(\"Expected Scalar\"),\n        };\n        println!(\"Max speed: {:.1} m/s\", speed);\n    }\n\n    // Output example:\n    // Max speed: 7360.1 m/s\n    // Max speed: 7365.5 m/s\n    // Max speed: 7361.2 m/s\n    // Max speed: 7357.5 m/s\n    // Max speed: 7357.8 m/s\n    // Max speed: 7360.0 m/s\n\n    Ok(())\n}\n</code></pre>"},{"location":"learn/access_computation/properties.html#see-also","title":"See Also","text":"<ul> <li>Access Computation Overview</li> <li>Constraints</li> <li>Locations</li> <li>Computation Configuration</li> </ul>"},{"location":"learn/attitude_representations/index.html","title":"Attitude Representations","text":"<p>Brahe supports multiple mathematical representations for the attitude, or orientation, of 3D objects such as spacecraft. Each representation has its own advantages and disadvantages depending on the application. These representations are implemented based on the comprehensive treatment found in Representing Attitude: Euler Angles, Unit Quaternions, and Rotation Vectors by James Diebel.</p>"},{"location":"learn/attitude_representations/index.html#overview","title":"Overview","text":"<p>Attitude representation is fundamental to spacecraft dynamics and control. Brahe provides four different representations, each with their own advantages:</p> <ul> <li>Quaternions: Singularity-free, compact representation (4 parameters)</li> <li>Rotation Matrices: Direct transformation matrices (9 parameters)</li> <li>Euler Angles: Intuitive angular representation (3 parameters, but with singularities)</li> <li>Euler Axis: Axis-angle representation (4 parameters)</li> </ul>"},{"location":"learn/attitude_representations/index.html#conversions","title":"Conversions","text":"<p>Brahe provides functions to convert between all attitude representations. You can initialize an attitude in one representation and convert it to any other one as needed.</p>"},{"location":"learn/attitude_representations/index.html#choosing-a-representation","title":"Choosing a Representation","text":"<p>Use Quaternions when:</p> <ul> <li>Numerical stability is critical</li> <li>Interpolating between attitudes</li> <li>Propagating attitude dynamics</li> </ul> <p>Use Rotation Matrices when:</p> <ul> <li>Transforming vectors between frames</li> </ul> <p>Use Euler Angles when:</p> <ul> <li>Human readability is important</li> </ul> <p>Use Euler Axis when:</p> <ul> <li>Representing single rotations about an axis</li> </ul>"},{"location":"learn/attitude_representations/index.html#see-also","title":"See Also","text":"<ul> <li>API Reference - Attitude</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html","title":"Euler Angles","text":"<p>Euler angles represent rotations as three sequential rotations about coordinate axes.</p>"},{"location":"learn/attitude_representations/euler_angles.html#overview","title":"Overview","text":"<p>Euler angles describe orientation using three angles representing sequential rotations about specified axes. Brahe supports all 12 possible Euler angle sequences (e.g., XYZ, ZYX, ZYZ).</p>"},{"location":"learn/attitude_representations/euler_angles.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler angle rotation is specified by:</p> <ul> <li>Three angles: \\((\\phi, \\theta, \\psi)\\)</li> <li>A rotation sequence (e.g., XYZ, ZYX)</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#sequences","title":"Sequences","text":"<p>Brahe supports all valid Euler angle sequences, though some are more commonly used are:</p> <ul> <li>ZYX (3-2-1): Common in aerospace applications. Known as yaw-pitch-roll.</li> <li>XYZ (1-2-3): Common in robotics</li> <li>ZYZ (3-1-3): Common in classical mechanics</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#initialization","title":"Initialization","text":"<p>Euler angles can be created from individual angles with a specified rotation sequence, or converted from other attitude representations. When creating a new <code>EulerAngle</code> object, the rotation sequence of the created object must be specified.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from individual angles with ZYX sequence (yaw-pitch-roll)\n# 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll\nea_zyx = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    45.0,  # Yaw (Z)\n    30.0,  # Pitch (Y)\n    15.0,  # Roll (X)\n    bh.AngleFormat.DEGREES,\n)\nprint(\"ZYX Euler angles (yaw-pitch-roll):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_zyx.order}\")\n\n# Initialize from vector with XYZ sequence\nangles_vec = np.array([15.0, 30.0, 45.0])\nea_xyz = bh.EulerAngle.from_vector(\n    angles_vec, bh.EulerAngleOrder.XYZ, bh.AngleFormat.DEGREES\n)\nprint(\"\\nXYZ Euler angles (from vector):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_xyz.order}\")\n\n# Simple rotation about single axis (45\u00b0 about Z using ZYX)\nea_z_only = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    45.0,  # Z\n    0.0,  # Y\n    0.0,  # X\n    bh.AngleFormat.DEGREES,\n)\nprint(\"\\nSingle-axis rotation (45\u00b0 about Z using ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_z_only.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_z_only.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_z_only.psi):.1f}\u00b0\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(math.cos(math.pi / 8), 0.0, 0.0, math.sin(math.pi / 8))\nea_from_q = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\nprint(\"\\nFrom quaternion (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_q.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_q.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_q.psi):.1f}\u00b0\")\n\n# Initialize from Rotation Matrix\nrm = bh.RotationMatrix.Rz(45.0, bh.AngleFormat.DEGREES)\nea_from_rm = bh.EulerAngle.from_rotation_matrix(rm, bh.EulerAngleOrder.ZYX)\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_rm.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_rm.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_rm.psi):.1f}\u00b0\")\n\n# Initialize from Euler Axis\neuler_axis = bh.EulerAxis(np.array([0.0, 0.0, 1.0]), 45.0, bh.AngleFormat.DEGREES)\nea_from_ea = bh.EulerAngle.from_euler_axis(euler_axis, bh.EulerAngleOrder.ZYX)\n\nprint(\"\\nFrom Euler axis (45\u00b0 about Z):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_from_ea.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_from_ea.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_from_ea.psi):.1f}\u00b0\")\n\n# Initialize from one EulerAngle to another with different order\n# Start with XZY order\nea_xzy = bh.EulerAngle.from_euler_angle(ea_zyx, bh.EulerAngleOrder.XZY)\nprint(\"\\nXZY Euler angles from ZYX:\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xzy.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Z): {math.degrees(ea_xzy.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (Y): {math.degrees(ea_xzy.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_xzy.order}\")\n\n# Convert to ZYX order (same physical rotation, different representation)\n# Go through quaternion as intermediate representation\nq_xzy = ea_xzy.to_quaternion()\nea_zyx_converted = bh.EulerAngle.from_quaternion(q_xzy, bh.EulerAngleOrder.ZYX)\nprint(\"\\nConverted back to ZYX order (same rotation):\")\nprint(f\"  Angle 1 (Z): {math.degrees(ea_zyx_converted.phi):.1f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_zyx_converted.theta):.1f}\u00b0\")\nprint(f\"  Angle 3 (X): {math.degrees(ea_zyx_converted.psi):.1f}\u00b0\")\nprint(f\"  Order: {ea_zyx_converted.order}\")\n\n# Expected output:\n# ZYX Euler angles (yaw-pitch-roll):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 30.0\u00b0\n#   Roll (X):  15.0\u00b0\n#   Order: ZYX\n#\n# XYZ Euler angles (from vector):\n#   Angle 1 (X): 15.0\u00b0\n#   Angle 2 (Y): 30.0\u00b0\n#   Angle 3 (Z): 45.0\u00b0\n#   Order: XYZ\n#\n# Single-axis rotation (45\u00b0 about Z using ZYX):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From quaternion (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From rotation matrix (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  0.0\u00b0\n#\n# From Euler axis (45\u00b0 about Z):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 0.0\u00b0\n#   Roll (X):  -0.0\u00b0\n#\n# XZY Euler angles from ZYX:\n#   Angle 1 (X): 20.8\u00b0\n#   Angle 2 (Z): 50.8\u00b0\n#   Angle 3 (Y): 14.5\u00b0\n#   Order: XZY\n#\n# Converted back to ZYX order (same rotation):\n#   Angle 1 (Z): 45.0\u00b0\n#   Angle 2 (Y): 30.0\u00b0\n#   Angle 3 (X): 15.0\u00b0\n#   Order: ZYX\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::ToAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from individual angles with ZYX sequence (yaw-pitch-roll)\n    // 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll\n    let ea_zyx = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),  // Yaw (Z)\n        (30.0_f64).to_radians(),  // Pitch (Y)\n        (15.0_f64).to_radians(),  // Roll (X)\n        bh::AngleFormat::Radians\n    );\n    println!(\"ZYX Euler angles (yaw-pitch-roll):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_zyx.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_zyx.order);\n\n    // Initialize from vector with XYZ sequence\n    let angles_vec = na::SVector::&lt;f64, 3&gt;::new(\n        (15.0_f64).to_radians(),\n        (30.0_f64).to_radians(),\n        (45.0_f64).to_radians()\n    );\n    let ea_xyz = bh::EulerAngle::from_vector(angles_vec, bh::EulerAngleOrder::XYZ, bh::AngleFormat::Radians);\n    println!(\"\\nXYZ Euler angles (from vector):\");\n    println!(\"  Angle 1 (X): {:.1}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.1}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.1}\u00b0\", ea_xyz.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_xyz.order);\n\n    // Simple rotation about single axis (45\u00b0 about Z using ZYX)\n    let ea_z_only = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),  // Z\n        0.0,                       // Y\n        0.0,                       // X\n        bh::AngleFormat::Radians\n    );\n    println!(\"\\nSingle-axis rotation (45\u00b0 about Z using ZYX):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_z_only.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_z_only.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_z_only.psi.to_degrees());\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n    let ea_from_q = bh::EulerAngle::from_quaternion(q, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom quaternion (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_q.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_q.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_q.psi.to_degrees());\n\n    // Initialize from Rotation Matrix\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let ea_from_rm = bh::EulerAngle::from_rotation_matrix(rm, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_rm.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_rm.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_rm.psi.to_degrees());\n\n    // Initialize from Euler Axis\n    let euler_axis = bh::EulerAxis::new(na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0), 45.0, bh::AngleFormat::Degrees);\n    let ea_from_ea = bh::EulerAngle::from_euler_axis(euler_axis, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nFrom Euler axis (45\u00b0 about Z):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea_from_ea.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea_from_ea.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea_from_ea.psi.to_degrees());\n\n    // Initialize from one EulerAngle to another with different order\n    // Start with XZY order\n    let ea_xzy = bh::EulerAngle::from_euler_angle(ea_zyx, bh::EulerAngleOrder::XZY);\n    println!(\"\\nXZY Euler angles from ZYX:\");\n    println!(\"  Angle 1 (X): {:.1}\u00b0\", ea_xzy.phi.to_degrees());\n    println!(\"  Angle 2 (Z): {:.1}\u00b0\", ea_xzy.theta.to_degrees());\n    println!(\"  Angle 3 (Y): {:.1}\u00b0\", ea_xzy.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_xzy.order);\n\n    // Convert to ZYX order (same physical rotation, different representation)\n    // Go through quaternion as intermediate representation\n    let q_xzy = ea_xzy.to_quaternion();\n    let ea_zyx_converted = bh::EulerAngle::from_quaternion(q_xzy, bh::EulerAngleOrder::ZYX);\n    println!(\"\\nConverted back to ZYX order (same rotation):\");\n    println!(\"  Angle 1 (Z): {:.1}\u00b0\", ea_zyx_converted.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.1}\u00b0\", ea_zyx_converted.theta.to_degrees());\n    println!(\"  Angle 3 (X): {:.1}\u00b0\", ea_zyx_converted.psi.to_degrees());\n    println!(\"  Order: {:?}\", ea_zyx_converted.order);\n}\n\n// Expected output:\n// ZYX Euler angles (yaw-pitch-roll):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 30.0\u00b0\n//   Roll (X):  15.0\u00b0\n//   Order: ZYX\n//\n// XYZ Euler angles (from vector):\n//   Angle 1 (X): 15.0\u00b0\n//   Angle 2 (Y): 30.0\u00b0\n//   Angle 3 (Z): 45.0\u00b0\n//   Order: XYZ\n//\n// Single-axis rotation (45\u00b0 about Z using ZYX):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From quaternion (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From rotation matrix (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  0.0\u00b0\n//\n// From Euler axis (45\u00b0 about Z):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 0.0\u00b0\n//   Roll (X):  -0.0\u00b0\n//\n// XZY Euler angles from ZYX:\n//   Angle 1 (X): 20.8\u00b0\n//   Angle 2 (Z): 50.8\u00b0\n//   Angle 3 (Y): 14.5\u00b0\n//   Order: XZY::132\n//\n// Converted back to ZYX order (same rotation):\n//   Angle 1 (Z): 45.0\u00b0\n//   Angle 2 (Y): 30.0\u00b0\n//   Angle 3 (X): 15.0\u00b0\n//   Order: ZYX::321\n</code></pre>"},{"location":"learn/attitude_representations/euler_angles.html#conversions","title":"Conversions","text":"<p>Convert between Euler angles and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create Euler angles (ZYX: 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll)\nea = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX,\n    math.radians(45.0),\n    math.radians(30.0),\n    math.radians(15.0),\n    bh.AngleFormat.RADIANS,\n)\n\nprint(\"Original Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea.phi):.1f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea.theta):.1f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea.psi):.1f}\u00b0\")\n\n# Convert to quaternion\nq = ea.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = ea.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler axis (axis-angle)\nea_axis = ea.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea_axis.axis[0]:.6f}, {ea_axis.axis[1]:.6f}, {ea_axis.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea_axis.angle):.3f}\u00b0\")\n\n# Expected output:\n# Original Euler angles (ZYX):\n#   Yaw (Z):   45.0\u00b0\n#   Pitch (Y): 30.0\u00b0\n#   Roll (X):  15.0\u00b0\n\n# To quaternion:\n#   q = [0.871836, 0.214680, 0.188824, 0.397693]\n\n# To rotation matrix:\n#   [0.612372, 0.774519, -0.158494]\n#   [-0.612372, 0.591506, 0.524519]\n#   [0.500000, -0.224144, 0.836516]\n\n# To Euler axis:\n#   Axis: [0.438304, 0.385514, 0.811954]\n#   Angle: 58.654\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::ToAttitude;\n\nfn main() {\n    // Create Euler angles (ZYX: 45\u00b0 yaw, 30\u00b0 pitch, 15\u00b0 roll)\n    let ea = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),\n        (30.0_f64).to_radians(),\n        (15.0_f64).to_radians(),\n        bh::AngleFormat::Radians\n    );\n\n    println!(\"Original Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.1}\u00b0\", ea.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.1}\u00b0\", ea.theta.to_degrees());\n    println!(\"  Roll (X):  {:.1}\u00b0\", ea.psi.to_degrees());\n\n    // Convert to quaternion\n    let q = ea.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = ea.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler axis (axis-angle)\n    let ea_axis = ea.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea_axis.axis[0], ea_axis.axis[1], ea_axis.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea_axis.angle.to_degrees());\n}\n\n// Expected output:\n// Original Euler angles (ZYX):\n//   Yaw (Z):   45.0\u00b0\n//   Pitch (Y): 30.0\u00b0\n//   Roll (X):  15.0\u00b0\n\n// To quaternion:\n//   q = [0.871836, 0.214680, 0.188824, 0.397693]\n\n// To rotation matrix:\n//   [0.612372, 0.774519, -0.158494]\n//   [-0.612372, 0.591506, 0.524519]\n//   [0.500000, -0.224144, 0.836516]\n\n// To Euler axis:\n//   Axis: [0.438304, 0.385514, 0.811954]\n//   Angle: 58.654\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_angles.html#see-also","title":"See Also","text":"<ul> <li>Euler Angles API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html","title":"Euler Axis (Axis-Angle)","text":"<p>The Euler axis representation describes rotations using a rotation axis and angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#overview","title":"Overview","text":"<p>Also known as axis-angle representation, this describes any rotation as a single rotation about a unit vector (axis) by a specified angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler axis rotation is specified by:</p> <ul> <li>Unit vector (axis): \\(\\hat{n} = [n_x, n_y, n_z]\\) where \\(|\\hat{n}| = 1\\)</li> <li>Rotation angle: \\(\\theta\\) (in radians)</li> </ul> <p>Together: \\([\\theta, n_x, n_y, n_z]\\) (4 parameters)</p>"},{"location":"learn/attitude_representations/euler_axis.html#initialization","title":"Initialization","text":"<p>Euler axis representations can be created from an axis vector and angle, or converted from other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from axis vector and angle\n# 45\u00b0 rotation about Z-axis\naxis_z = np.array([0.0, 0.0, 1.0])\nangle = math.radians(45.0)\nea_z = bh.EulerAxis(axis_z, angle, bh.AngleFormat.RADIANS)\n\nprint(\"45\u00b0 rotation about Z-axis:\")\nprint(f\"  Axis: [{ea_z.axis[0]:.3f}, {ea_z.axis[1]:.3f}, {ea_z.axis[2]:.3f}]\")\nprint(f\"  Angle: {math.degrees(ea_z.angle):.1f}\u00b0\")\n\n# 90\u00b0 rotation about X-axis\naxis_x = np.array([1.0, 0.0, 0.0])\nea_x = bh.EulerAxis(axis_x, math.radians(90.0), bh.AngleFormat.RADIANS)\n\nprint(\"\\n90\u00b0 rotation about X-axis:\")\nprint(f\"  Axis: [{ea_x.axis[0]:.3f}, {ea_x.axis[1]:.3f}, {ea_x.axis[2]:.3f}]\")\nprint(f\"  Angle: {math.degrees(ea_x.angle):.1f}\u00b0\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(math.cos(math.pi / 8), 0.0, 0.0, math.sin(math.pi / 8))\nea_from_q = bh.EulerAxis.from_quaternion(q)\n\nprint(\"\\nFrom quaternion (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_q.axis[0]:.6f}, {ea_from_q.axis[1]:.6f}, {ea_from_q.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_q.angle):.1f}\u00b0\")\n\n# Initialize from rotation matrix\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\nea_from_rm = bh.EulerAxis.from_rotation_matrix(rm)\n\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_rm.axis[0]:.6f}, {ea_from_rm.axis[1]:.6f}, {ea_from_rm.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_rm.angle):.1f}\u00b0\")\n\n# Initialize from EulerAngle\neuler_angle = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, 45.0, 0.0, 0.0, bh.AngleFormat.DEGREES\n)\nea_from_euler = bh.EulerAxis.from_euler_angle(euler_angle)\n\nprint(\"\\nFrom EulerAngle (45\u00b0 about Z):\")\nprint(\n    f\"  Axis: [{ea_from_euler.axis[0]:.6f}, {ea_from_euler.axis[1]:.6f}, {ea_from_euler.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_from_euler.angle):.1f}\u00b0\")\n\n# Expected output:\n# 45\u00b0 rotation about Z-axis:\n#   Axis: [0.000, 0.000, 1.000]\n#   Angle: 45.0\u00b0\n\n# 90\u00b0 rotation about X-axis:\n#   Axis: [1.000, 0.000, 0.000]\n#   Angle: 90.0\u00b0\n\n# From quaternion (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# From rotation matrix (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# From EulerAngle (45\u00b0 about Z):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from axis vector and angle\n    // 45\u00b0 rotation about Z-axis\n    let axis_z = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0);\n    let angle = (45.0_f64).to_radians();\n    let ea_z = bh::EulerAxis::new(axis_z, angle, bh::AngleFormat::Radians);\n\n    println!(\"45\u00b0 rotation about Z-axis:\");\n    println!(\"  Axis: [{:.3}, {:.3}, {:.3}]\", ea_z.axis[0], ea_z.axis[1], ea_z.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_z.angle.to_degrees());\n\n    // 90\u00b0 rotation about X-axis\n    let axis_x = na::SVector::&lt;f64, 3&gt;::new(1.0, 0.0, 0.0);\n    let ea_x = bh::EulerAxis::new(axis_x, (90.0_f64).to_radians(), bh::AngleFormat::Radians);\n\n    println!(\"\\n90\u00b0 rotation about X-axis:\");\n    println!(\"  Axis: [{:.3}, {:.3}, {:.3}]\", ea_x.axis[0], ea_x.axis[1], ea_x.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_x.angle.to_degrees());\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n    let ea_from_q = bh::EulerAxis::from_quaternion(q);\n\n    println!(\"\\nFrom quaternion (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_q.axis[0], ea_from_q.axis[1], ea_from_q.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_q.angle.to_degrees());\n\n    // Initialize from rotation matrix\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let ea_from_rm = bh::EulerAxis::from_rotation_matrix(rm);\n\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_rm.axis[0], ea_from_rm.axis[1], ea_from_rm.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_rm.angle.to_degrees());\n\n    // Initialize from EulerAngle\n    let euler_angle = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        (45.0_f64).to_radians(),\n        0.0,\n        0.0,\n        bh::AngleFormat::Radians\n    );\n    let ea_from_euler = bh::EulerAxis::from_euler_angle(euler_angle);\n\n    println!(\"\\nFrom EulerAngle (45\u00b0 about Z):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_from_euler.axis[0], ea_from_euler.axis[1], ea_from_euler.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_from_euler.angle.to_degrees());\n}\n\n// Expected output:\n// 45\u00b0 rotation about Z-axis:\n//   Axis: [0.000, 0.000, 1.000]\n//   Angle: 45.0\u00b0\n//\n// 90\u00b0 rotation about X-axis:\n//   Axis: [1.000, 0.000, 0.000]\n//   Angle: 90.0\u00b0\n//\n// From quaternion (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n//\n// From rotation matrix (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n//\n// From EulerAngle (45\u00b0 about Z):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_axis.html#conversions","title":"Conversions","text":"<p>Convert between Euler axis and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Create an Euler axis (45\u00b0 rotation about Z-axis)\nea = bh.EulerAxis(np.array([0.0, 0.0, 1.0]), math.radians(45.0), bh.AngleFormat.RADIANS)\n\nprint(\"Original Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.1f}\u00b0\")\n\n# Convert to quaternion\nq = ea.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = ea.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_angles_zyx = ea.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_angles_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_angles_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_angles_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_angles_xyz = ea.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_angles_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_angles_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_angles_xyz.psi):.3f}\u00b0\")\n\n# Round-trip conversion test\nq_roundtrip = ea.to_quaternion()\nea_roundtrip = bh.EulerAxis.from_quaternion(q_roundtrip)\nprint(\"\\nRound-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\")\nprint(\n    f\"  Axis: [{ea_roundtrip.axis[0]:.6f}, {ea_roundtrip.axis[1]:.6f}, {ea_roundtrip.axis[2]:.6f}]\"\n)\nprint(f\"  Angle: {math.degrees(ea_roundtrip.angle):.1f}\u00b0\")\n\n# Expected output:\n# Original Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n\n# To quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n# To rotation matrix:\n#   [0.707107, 0.707107, 0.000000]\n#   [-0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  -0.000\u00b0\n\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): -0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n\n# Round-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.0\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\nuse nalgebra as na;\n\nfn main() {\n    // Create an Euler axis (45\u00b0 rotation about Z-axis)\n    let ea = bh::EulerAxis::new(\n        na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0),\n        (45.0_f64).to_radians(),\n        bh::AngleFormat::Radians\n    );\n\n    println!(\"Original Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea.angle.to_degrees());\n\n    // Convert to quaternion\n    let q = ea.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = ea.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_angles_zyx = ea.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_angles_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_angles_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_angles_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_angles_xyz = ea.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_angles_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_angles_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_angles_xyz.psi.to_degrees());\n\n    // Round-trip conversion test\n    let q_roundtrip = ea.to_quaternion();\n    let ea_roundtrip = bh::EulerAxis::from_quaternion(q_roundtrip);\n    println!(\"\\nRound-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\",\n             ea_roundtrip.axis[0], ea_roundtrip.axis[1], ea_roundtrip.axis[2]);\n    println!(\"  Angle: {:.1}\u00b0\", ea_roundtrip.angle.to_degrees());\n}\n\n// Expected output:\n// Original Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n\n// To quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n// To rotation matrix:\n//   [0.707107, 0.707107, 0.000000]\n//   [-0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  -0.000\u00b0\n\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): -0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n\n// Round-trip (EulerAxis \u2192 Quaternion \u2192 EulerAxis):\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.0\u00b0\n</code></pre>"},{"location":"learn/attitude_representations/euler_axis.html#see-also","title":"See Also","text":"<ul> <li>Euler Axis API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/quaternions.html","title":"Quaternions","text":"<p>A quaternion is a four-element mathematical object that can represent any 3D rotation without singularities. In Brahe, quaternions use the scalar-first convention: <code>[w, x, y, z]</code>.</p>"},{"location":"learn/attitude_representations/quaternions.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A unit quaternion is defined as:</p> \\[q = [w, x, y, z]\\] <p>where \\(w^2 + x^2 + y^2 + z^2 = 1\\) for unit quaternions. \\(w\\) is the scalar part, and \\((x, y, z)\\) is the vector part. Quaternions can also be formulated with the scalar part as the last element, which brahe also supports for input/output.</p>"},{"location":"learn/attitude_representations/quaternions.html#initialization","title":"Initialization","text":"<p>Quaternions can be initialized in several ways, including directly from all other attitude representations:</p> PythonRust <pre><code>import math\nimport brahe as bh\nimport numpy as np\n\n\n# Initialize from individual components (w, x, y, z)\n# Always scalar-first in constructor\nq1 = bh.Quaternion(0.924, 0.0, 0.0, 0.383)\nprint(\"From components (identity):\")\nprint(f\"  q = [{q1.w:.3f}, {q1.x:.3f}, {q1.y:.3f}, {q1.z:.3f}]\")\n\n# Initialize from vector/array [w, x, y, z]\n# Can specify if scalar is first or last\nq2 = bh.Quaternion.from_vector(np.array([0.924, 0.0, 0.0, 0.383]), scalar_first=True)\nprint(\"\\nFrom vector:\")\nprint(f\"  q = [{q2.w:.3f}, {q2.x:.3f}, {q2.y:.3f}, {q2.z:.3f}]\")\n\n# Initialize from another representation (rotation matrix)\n# 90\u00b0 rotation about Z-axis\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\nq3 = bh.Quaternion.from_rotation_matrix(rm)\nprint(\"\\nFrom rotation matrix (45\u00b0 about Z-axis):\")\nprint(f\"  q = [{q3.w:.3f}, {q3.x:.3f}, {q3.y:.3f}, {q3.z:.3f}]\")\n\n# Initialize from Euler angles (ZYX sequence)\nea = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, math.pi / 4, 0.0, 0.0, bh.AngleFormat.RADIANS\n)\nq4 = bh.Quaternion.from_euler_angle(ea)\nprint(\"\\nFrom Euler angles (45\u00b0 yaw, ZYX):\")\nprint(f\"  q = [{q4.w:.3f}, {q4.x:.3f}, {q4.y:.3f}, {q4.z:.3f}]\")\n\n# Initialize from Euler axis (axis-angle representation)\naxis = np.array([0.0, 0.0, 1.0])  # Z-axis\nangle = math.pi / 4  # 45\u00b0\nea_rep = bh.EulerAxis(axis, angle, bh.AngleFormat.RADIANS)\nq5 = bh.Quaternion.from_euler_axis(ea_rep)\nprint(\"\\nFrom Euler axis (45\u00b0 about Z-axis):\")\nprint(f\"  q = [{q5.w:.3f}, {q5.x:.3f}, {q5.y:.3f}, {q5.z:.3f}]\")\n\n# Expected output:\n# From components (identity):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From vector:\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From rotation matrix (45\u00b0 about Z-axis):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From Euler angles (45\u00b0 yaw, ZYX):\n#   q = [0.924, 0.000, 0.000, 0.383]\n\n# From Euler axis (45\u00b0 about Z-axis):\n#   q = [0.924, 0.000, 0.000, 0.383]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize from individual components (w, x, y, z)\n    // Always scalar-first in constructor\n    let q1 = bh::Quaternion::new(0.924, 0.0, 0.0, 0.383);\n    println!(\"From components (identity):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q1[0], q1[1], q1[2], q1[3]);\n\n    // Initialize from vector/array [w, x, y, z]\n    // Can specify if scalar is first or last\n    let vec = na::SVector::&lt;f64, 4&gt;::new(0.924, 0.0, 0.0, 0.383);\n    let q2 = bh::Quaternion::from_vector(vec, true);  // scalar_first = true\n    println!(\"\\nFrom vector:\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q2[0], q2[1], q2[2], q2[3]);\n\n    // Initialize from another representation (rotation matrix)\n    // 45\u00b0 rotation about Z-axis\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n    let q3 = bh::Quaternion::from_rotation_matrix(rm);\n    println!(\"\\nFrom rotation matrix (45\u00b0 about Z-axis):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q3[0], q3[1], q3[2], q3[3]);\n\n    // Initialize from Euler angles (ZYX sequence)\n    let ea = bh::EulerAngle::new(bh::EulerAngleOrder::ZYX, PI/4.0, 0.0, 0.0, bh::AngleFormat::Radians);\n    let q4 = bh::Quaternion::from_euler_angle(ea);\n    println!(\"\\nFrom Euler angles (45\u00b0 yaw, ZYX):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q4[0], q4[1], q4[2], q4[3]);\n\n    // Initialize from Euler axis (axis-angle representation)\n    let axis = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0);  // Z-axis\n    let angle = PI / 4.0;  // 45\u00b0\n    let ea_rep = bh::EulerAxis::new(axis, angle, bh::AngleFormat::Radians);\n    let q5 = bh::Quaternion::from_euler_axis(ea_rep);\n    println!(\"\\nFrom Euler axis (45\u00b0 about Z-axis):\");\n    println!(\"  q = [{:.3}, {:.3}, {:.3}, {:.3}]\", q5[0], q5[1], q5[2], q5[3]);\n}\n\n// Expected output:\n// From components (identity):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From vector:\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From rotation matrix (45\u00b0 about Z-axis):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From Euler angles (45\u00b0 yaw, ZYX):\n//   q = [0.924, 0.000, 0.000, 0.383]\n//\n// From Euler axis (45\u00b0 about Z-axis):\n//   q = [0.924, 0.000, 0.000, 0.383]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#output-and-access","title":"Output and Access","text":"<p>You can access quaternion components directly or convert them to other data formats:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a quaternion (45\u00b0 rotation about Z-axis)\nq = bh.Quaternion.from_rotation_matrix(bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES))\n\n# Access individual components\nprint(\"Individual components:\")\nprint(f\"  w (scalar): {q.w:.6f}\")\nprint(f\"  x: {q.x:.6f}\")\nprint(f\"  y: {q.y:.6f}\")\nprint(f\"  z: {q.z:.6f}\")\n\n# Directly access as a vector/array\nvec = q.data\nprint(\"\\nAs vector [w, x, y, z]:\")\nprint(f\"  {vec}: {type(vec)}\")\n\n# Or return copy as a NumPy array\nvec_np = q.to_vector(scalar_first=True)\nprint(\"\\nAs vector [w, x, y, z]:\")\nprint(f\"  {vec_np}: {type(vec_np)}\")\n\n# Return in different order (scalar last)\nvec_np_last = q.to_vector(scalar_first=False)\nprint(\"\\nAs scalar-last [x, y, z, w]:\")\nprint(f\"  {vec_np_last}: {type(vec_np_last)}\")\n\n# Display as string\nprint(\"\\nString representation:\")\nprint(f\"  {q}\")\n\nprint(\"\\Repr representation:\")\nprint(f\"  {repr(q)}\")\n\n# Expected output:\n# Individual components:\n#   w (scalar): 0.923880\n#   x: 0.000000\n#   y: 0.000000\n#   z: 0.382683\n\n# As vector :\n#   [0.92387953 0.         0.         0.38268343]: &lt;class 'numpy.ndarray'&gt;\n\n# As vector :\n#   [0.92387953 0.         0.         0.38268343]: &lt;class 'numpy.ndarray'&gt;\n\n# As scalar-last :\n#   [0.         0.         0.38268343 0.92387953]: &lt;class 'numpy.ndarray'&gt;\n\n# String representation:\n#   Quaternion: [s: 0.9238795325112867, v: [0, 0, 0.3826834323650897]]\n# \\Repr representation:\n#   Quaternion&lt;0.9238795325112867, 0, 0, 0.3826834323650897&gt;\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\n\nfn main() {\n    // Create a quaternion (45\u00b0 rotation about Z-axis)\n    let q = bh::Quaternion::from_rotation_matrix(\n        bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees)\n    );\n\n    // Access individual components\n    println!(\"Individual components:\");\n    println!(\"  w (scalar): {:.6}\", q[0]);\n    println!(\"  x: {:.6}\", q[1]);\n    println!(\"  y: {:.6}\", q[2]);\n    println!(\"  z: {:.6}\", q[3]);\n\n    // Directly access as a vector/array\n    let vec = q.to_vector(true);\n    println!(\"\\nAs vector [w, x, y, z]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec[0], vec[1], vec[2], vec[3]);\n\n    // Or return copy as a vector\n    let vec_np = q.to_vector(true);\n    println!(\"\\nAs vector [w, x, y, z]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec_np[0], vec_np[1], vec_np[2], vec_np[3]);\n\n    // Return in different order (scalar last)\n    let vec_np_last = q.to_vector(false);\n    println!(\"\\nAs scalar-last [x, y, z, w]:\");\n    println!(\"  [{}, {}, {}, {}]\", vec_np_last[0], vec_np_last[1], vec_np_last[2], vec_np_last[3]);\n\n    // Display as string (Debug)\n    println!(\"\\nString representation:\");\n    println!(\"  {}\", q);\n\n    println!(\"\\nDebug representation:\");\n    println!(\"  {:?}\", q);\n}\n\n// Expected output:\n// Individual components:\n//   w (scalar): 0.923880\n//   x: 0.000000\n//   y: 0.000000\n//   z: 0.382683\n\n// As vector :\n//   [0.9238795325112867, 0, 0, 0.3826834323650897]\n\n// As vector :\n//   [0.9238795325112867, 0, 0, 0.3826834323650897]\n\n// As scalar-last :\n//   [0, 0, 0.3826834323650897, 0.9238795325112867]\n\n// String representation:\n//   Quaternion: [s: 0.9238795325112867, v: [0, 0, 0.3826834323650897]]\n\n// Debug representation:\n//   Quaternion&lt;0.9238795325112867, 0, 0, 0.3826834323650897&gt;\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#operations","title":"Operations","text":"<p>Quaternions support multiplication, normalization, conjugation, inversion, and interpolation (through Spherical Linear Interpolation (SLERP)):</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a quaternion from rotation matrix (90\u00b0 about X, then 45\u00b0 about Z)\nq = bh.Quaternion.from_rotation_matrix(\n    bh.RotationMatrix.Rx(90, bh.AngleFormat.DEGREES)\n    * bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n)\n\nprint(\"Original quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Compute norm\nnorm = q.norm()\nprint(f\"\\nNorm: {norm:.6f}\")\n\n# Normalize quaternion (in-place)\nq.normalize()  # In-place normalization (This shouldn't really do anything here since q already applies normalization on creation)\nprint(\"After normalization:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\nprint(f\"  Norm: {q.norm():.6f}\")\n\n# Compute conjugate\nq_conj = q.conjugate()\nprint(\"\\nConjugate:\")\nprint(f\"  q* = [{q_conj.w:.6f}, {q_conj.x:.6f}, {q_conj.y:.6f}, {q_conj.z:.6f}]\")\n\n# Compute inverse (same as conjugate for normalized quaternions)\nq_inv = q.inverse()\nprint(\"\\nInverse:\")\nprint(f\"  q^-1 = [{q_inv.w:.6f}, {q_inv.x:.6f}, {q_inv.y:.6f}, {q_inv.z:.6f}]\")\n\n# Quaternion multiplication (compose rotations)\n# 90\u00b0 about X, then 90\u00b0 about Z\nq_x = bh.Quaternion(math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0)\nq_z = bh.Quaternion(math.cos(math.pi / 4), 0.0, 0.0, math.sin(math.pi / 4))\nq_composed = q_z * q_x  # Apply q_x first, then q_z\nprint(\"\\nComposed rotation (90\u00b0 X then 90\u00b0 Z):\")\nprint(f\"  q_x = [{q_x.w:.6f}, {q_x.x:.6f}, {q_x.y:.6f}, {q_x.z:.6f}]\")\nprint(f\"  q_z = [{q_z.w:.6f}, {q_z.x:.6f}, {q_z.y:.6f}, {q_z.z:.6f}]\")\nprint(\n    f\"  q_composed = [{q_composed.w:.6f}, {q_composed.x:.6f}, {q_composed.y:.6f}, {q_composed.z:.6f}]\"\n)\n\n# Multiply q and its inverse to verify identity\nidentity = q * q_inv\nprint(\"\\nq * q^-1 (should be identity):\")\nprint(\n    f\"  q_identity = [{identity.w:.6f}, {identity.x:.6f}, {identity.y:.6f}, {identity.z:.6f}]\"\n)\n\n# SLERP (Spherical Linear Interpolation) between two quaternions\n# Interpolate from q_x (90\u00b0 about X) to q_z (90\u00b0 about Z)\nprint(\"\\nSLERP interpolation from q_x to q_z:\")\nq_slerp_0 = q_x.slerp(q_z, 0.0)  # t=0, should equal q_x\nprint(\n    f\"  t=0.0: [{q_slerp_0.w:.6f}, {q_slerp_0.x:.6f}, {q_slerp_0.y:.6f}, {q_slerp_0.z:.6f}]\"\n)\nq_slerp_25 = q_x.slerp(q_z, 0.25)\nprint(\n    f\"  t=0.25: [{q_slerp_25.w:.6f}, {q_slerp_25.x:.6f}, {q_slerp_25.y:.6f}, {q_slerp_25.z:.6f}]\"\n)\nq_slerp_5 = q_x.slerp(q_z, 0.5)  # t=0.5, halfway\nprint(\n    f\"  t=0.5: [{q_slerp_5.w:.6f}, {q_slerp_5.x:.6f}, {q_slerp_5.y:.6f}, {q_slerp_5.z:.6f}]\"\n)\nq_slerp_75 = q_x.slerp(q_z, 0.75)\nprint(\n    f\"  t=0.75: [{q_slerp_75.w:.6f}, {q_slerp_75.x:.6f}, {q_slerp_75.y:.6f}, {q_slerp_75.z:.6f}]\"\n)\nq_slerp_1 = q_x.slerp(q_z, 1.0)  # t=1, should equal q_z\nprint(\n    f\"  t=1.0: [{q_slerp_1.w:.6f}, {q_slerp_1.x:.6f}, {q_slerp_1.y:.6f}, {q_slerp_1.z:.6f}]\"\n)\n\n# Expected output:\n# Original quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n# To rotation matrix:\n#   [0.707107, 0.707107, 0.000000]\n#   [-0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  -0.000\u00b0\n\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): -0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n\n# Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n#   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Create a quaternion from rotation matrix (90\u00b0 about X, then 45\u00b0 about Z)\n    let mut q = bh::Quaternion::from_rotation_matrix(\n        bh::RotationMatrix::Rx(90.0, bh::AngleFormat::Degrees) * bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees)\n    );\n\n    println!(\"Original quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Compute norm\n    let norm = q.norm();\n    println!(\"\\nNorm: {:.6}\", norm);\n\n    // Normalize quaternion (in-place)\n    q.normalize();  // In-place normalization (This shouldn't really do anything here since q already applies normalization on creation)\n    println!(\"After normalization:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n    println!(\"  Norm: {:.6}\", q.norm());\n\n    // Compute conjugate\n    let q_conj = q.conjugate();\n    println!(\"\\nConjugate:\");\n    println!(\"  q* = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_conj[0], q_conj[1], q_conj[2], q_conj[3]);\n\n    // Compute inverse (same as conjugate for normalized quaternions)\n    let q_inv = q.inverse();\n    println!(\"\\nInverse:\");\n    println!(\"  q^-1 = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_inv[0], q_inv[1], q_inv[2], q_inv[3]);\n\n    // Quaternion multiplication (compose rotations)\n    // 90\u00b0 about X, then 90\u00b0 about Z\n    let q_x = bh::Quaternion::new((PI/4.0).cos(), (PI/4.0).sin(), 0.0, 0.0);\n    let q_z = bh::Quaternion::new((PI/4.0).cos(), 0.0, 0.0, (PI/4.0).sin());\n    let q_composed = q_z * q_x;  // Apply q_x first, then q_z\n    println!(\"\\nComposed rotation (90\u00b0 X then 90\u00b0 Z):\");\n    println!(\"  q_x = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_x[0], q_x[1], q_x[2], q_x[3]);\n    println!(\"  q_z = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_z[0], q_z[1], q_z[2], q_z[3]);\n    println!(\"  q_composed = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_composed[0], q_composed[1], q_composed[2], q_composed[3]);\n\n    // Multiply q and its inverse to verify identity\n    let identity = q * q_inv;\n    println!(\"\\nq * q^-1 (should be identity):\");\n    println!(\"  q_identity = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             identity[0], identity[1], identity[2], identity[3]);\n\n    // SLERP (Spherical Linear Interpolation) between two quaternions\n    // Interpolate from q_x (90\u00b0 about X) to q_z (90\u00b0 about Z)\n    println!(\"\\nSLERP interpolation from q_x to q_z:\");\n    let q_slerp_0 = q_x.slerp(q_z, 0.0);  // t=0, should equal q_x\n    println!(\"  t=0.0: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_0[0], q_slerp_0[1], q_slerp_0[2], q_slerp_0[3]);\n    let q_slerp_25 = q_x.slerp(q_z, 0.25);\n    println!(\"  t=0.25: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_25[0], q_slerp_25[1], q_slerp_25[2], q_slerp_25[3]);\n    let q_slerp_5 = q_x.slerp(q_z, 0.5);  // t=0.5, halfway\n    println!(\"  t=0.5: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_5[0], q_slerp_5[1], q_slerp_5[2], q_slerp_5[3]);\n    let q_slerp_75 = q_x.slerp(q_z, 0.75);\n    println!(\"  t=0.75: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_75[0], q_slerp_75[1], q_slerp_75[2], q_slerp_75[3]);\n    let q_slerp_1 = q_x.slerp(q_z, 1.0);  // t=1, should equal q_z\n    println!(\"  t=1.0: [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_slerp_1[0], q_slerp_1[1], q_slerp_1[2], q_slerp_1[3]);\n}\n\n// Expected output:\n// Original quaternion:\n//   q = [0.653281, 0.653281, 0.270598, 0.270598]\n//\n// Norm: 1.000000\n// After normalization:\n//   q = [0.653281, 0.653281, 0.270598, 0.270598]\n//   Norm: 1.000000\n//\n// Conjugate:\n//   q* = [0.653281, -0.653281, -0.270598, -0.270598]\n//\n// Inverse:\n//   q^-1 = [0.653281, -0.653281, -0.270598, -0.270598]\n//\n// Composed rotation (90\u00b0 X then 90\u00b0 Z):\n//   q_x = [0.707107, 0.707107, 0.000000, 0.000000]\n//   q_z = [0.707107, 0.000000, 0.000000, 0.707107]\n//   q_composed = [0.500000, 0.500000, 0.500000, 0.500000]\n//\n// q * q^-1 (should be identity):\n//   q_identity = [1.000000, 0.000000, 0.000000, 0.000000]\n//\n// SLERP interpolation from q_x to q_z:\n//   t=0.0: [0.707107, 0.707107, 0.000000, 0.000000]\n//   t=0.25: [0.788675, 0.577350, 0.000000, 0.211325]\n//   t=0.5: [0.816497, 0.408248, 0.000000, 0.408248]\n//   t=0.75: [0.788675, 0.211325, 0.000000, 0.577350]\n//   t=1.0: [0.707107, 0.000000, 0.000000, 0.707107]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#conversions","title":"Conversions","text":"<p>You can convert quaternions to all other attitude representations and vice versa:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a quaternion (45\u00b0 rotation about Z-axis)\nq = bh.Quaternion.from_rotation_matrix(bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES))\n\nprint(\"Original quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to rotation matrix\nrm = q.to_rotation_matrix()\nprint(\"\\nTo rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_zyx = q.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_xyz = q.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.3f}\u00b0\")\n\n# Convert to Euler axis (axis-angle)\nea = q.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.3f}\u00b0\")\n\n# Round-trip conversion test\nq_roundtrip = bh.Quaternion.from_rotation_matrix(rm)\nprint(\"\\nRound-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\")\nprint(\n    f\"  q_rt = [{q_roundtrip.w:.6f}, {q_roundtrip.x:.6f}, {q_roundtrip.y:.6f}, {q_roundtrip.z:.6f}]\"\n)\n\n# Expected output:\n# Original quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n#\n# To rotation matrix:\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n#\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  0.000\u00b0\n#\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): 0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n#\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n#\n# Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n#   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Create a quaternion (45\u00b0 rotation about Z-axis)\n    let q = bh::Quaternion::new((PI/8.0).cos(), 0.0, 0.0, (PI/8.0).sin());\n\n    println!(\"Original quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to rotation matrix\n    let rm = q.to_rotation_matrix();\n    println!(\"\\nTo rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_zyx = q.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_xyz = q.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_xyz.psi.to_degrees());\n\n    // Convert to Euler axis (axis-angle)\n    let ea = q.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea.angle.to_degrees());\n\n    // Round-trip conversion test\n    let q_roundtrip = bh::Quaternion::from_rotation_matrix(rm);\n    println!(\"\\nRound-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\");\n    println!(\"  q_rt = [{:.6}, {:.6}, {:.6}, {:.6}]\",\n             q_roundtrip[0], q_roundtrip[1], q_roundtrip[2], q_roundtrip[3]);\n}\n\n// Expected output:\n// Original quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n\n// To rotation matrix:\n//   [0.707107, 0.707107, 0.000000]\n//   [-0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  -0.000\u00b0\n\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): -0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n\n// To Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.000\u00b0\n\n// Round-trip (Quaternion \u2192 RotationMatrix \u2192 Quaternion):\n//   q_rt = [0.923880, 0.000000, 0.000000, 0.382683]\n</code></pre>"},{"location":"learn/attitude_representations/quaternions.html#see-also","title":"See Also","text":"<ul> <li>Quaternion API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html","title":"Rotation Matrices","text":"<p>A rotation matrix is a 3\u00d73 matrix that transforms vectors from one coordinate frame to another. Also known as Direction Cosine Matrices (DCM).</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A rotation matrix is represented as:</p> \\[ R = \\begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} \\\\ r_{21} &amp; r_{22} &amp; r_{23} \\\\ r_{31} &amp; r_{32} &amp; r_{33} \\end{bmatrix} \\] <p>A rotation matrix \\(R\\) satisfies the properties:</p> \\[R^T R = I\\] \\[\\det(R) = 1\\] <p>where \\(I\\) is the identity matrix.</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#initialization","title":"Initialization","text":"<p>Rotation matrices can be created directly from elements, elementary rotations, or converted from other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport math\n\n# Initialize from 9 individual elements (row-major order)\n# Identity rotation\nrm_identity = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\nprint(\"Identity rotation matrix:\")\nprint(f\"  [{rm_identity.r11:.3f}, {rm_identity.r12:.3f}, {rm_identity.r13:.3f}]\")\nprint(f\"  [{rm_identity.r21:.3f}, {rm_identity.r22:.3f}, {rm_identity.r23:.3f}]\")\nprint(f\"  [{rm_identity.r31:.3f}, {rm_identity.r32:.3f}, {rm_identity.r33:.3f}]\")\n\n# Initialize from a matrix of elements\nmatrix_elements = np.array([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]])\nrm_from_matrix = bh.RotationMatrix.from_matrix(matrix_elements)\nprint(\"\\nFrom matrix of elements:\")\nprint(\n    f\"  [{rm_from_matrix.r11:.3f}, {rm_from_matrix.r12:.3f}, {rm_from_matrix.r13:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_matrix.r21:.3f}, {rm_from_matrix.r22:.3f}, {rm_from_matrix.r23:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_matrix.r31:.3f}, {rm_from_matrix.r32:.3f}, {rm_from_matrix.r33:.3f}]\"\n)\n\n# Common rotation: 90\u00b0 about X-axis\nangle_x = 30\nrm_x = bh.RotationMatrix.Rx(angle_x, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_x}\u00b0 rotation about X-axis:\")\nprint(f\"  [{rm_x.r11:.3f}, {rm_x.r12:.3f}, {rm_x.r13:.3f}]\")\nprint(f\"  [{rm_x.r21:.3f}, {rm_x.r22:.3f}, {rm_x.r23:.3f}]\")\nprint(f\"  [{rm_x.r31:.3f}, {rm_x.r32:.3f}, {rm_x.r33:.3f}]\")\n\n# Common rotation: 90\u00b0 about Y-axis\nangle_y = 60\nrm_y = bh.RotationMatrix.Ry(angle_y, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_y}\u00b0 rotation about Y-axis:\")\nprint(f\"  [{rm_y.r11:.3f}, {rm_y.r12:.3f}, {rm_y.r13:.3f}]\")\nprint(f\"  [{rm_y.r21:.3f}, {rm_y.r22:.3f}, {rm_y.r23:.3f}]\")\nprint(f\"  [{rm_y.r31:.3f}, {rm_y.r32:.3f}, {rm_y.r33:.3f}]\")\n\n# Common rotation: 90\u00b0 about Z-axis\nangle_z = 45\nrm_z = bh.RotationMatrix.Rz(angle_z, bh.AngleFormat.DEGREES)\nprint(f\"\\n{angle_z}\u00b0 rotation about Z-axis:\")\nprint(f\"  [{rm_z.r11:.3f}, {rm_z.r12:.3f}, {rm_z.r13:.3f}]\")\nprint(f\"  [{rm_z.r21:.3f}, {rm_z.r22:.3f}, {rm_z.r23:.3f}]\")\nprint(f\"  [{rm_z.r31:.3f}, {rm_z.r32:.3f}, {rm_z.r33:.3f}]\")\n\n# Initialize from another representation (quaternion)\nq = bh.Quaternion(\n    math.cos(math.radians(angle_z) / 2), 0, 0, math.sin(math.radians(angle_z) / 2)\n)  # 90\u00b0 about Z-axis\nrm_from_q = bh.RotationMatrix.from_quaternion(q)\nprint(f\"\\nFrom quaternion ({angle_z}\u00b0 about Z-axis):\")\nprint(f\"  [{rm_from_q.r11:.3f}, {rm_from_q.r12:.3f}, {rm_from_q.r13:.3f}]\")\nprint(f\"  [{rm_from_q.r21:.3f}, {rm_from_q.r22:.3f}, {rm_from_q.r23:.3f}]\")\nprint(f\"  [{rm_from_q.r31:.3f}, {rm_from_q.r32:.3f}, {rm_from_q.r33:.3f}]\")\n\n# Initialize from Euler angles (ZYX sequence)\neuler_angles = bh.EulerAngle(\n    bh.EulerAngleOrder.ZYX, angle_z, 0, 0, bh.AngleFormat.DEGREES\n)\nrm_from_euler = bh.RotationMatrix.from_euler_angle(euler_angles)\nprint(f\"\\nFrom Euler angles ({angle_z}\u00b0 about Z-axis):\")\nprint(f\"  [{rm_from_euler.r11:.3f}, {rm_from_euler.r12:.3f}, {rm_from_euler.r13:.3f}]\")\nprint(f\"  [{rm_from_euler.r21:.3f}, {rm_from_euler.r22:.3f}, {rm_from_euler.r23:.3f}]\")\nprint(f\"  [{rm_from_euler.r31:.3f}, {rm_from_euler.r32:.3f}, {rm_from_euler.r33:.3f}]\")\n\n# Initialize from Euler axis and angle\naxis = np.array([0, 0, 1])  # Z-axis\neuler_axis = bh.EulerAxis(axis, angle_z, bh.AngleFormat.DEGREES)\nrm_from_axis_angle = bh.RotationMatrix.from_euler_axis(euler_axis)\nprint(f\"\\nFrom Euler axis ({angle_z}\u00b0 about Z-axis):\")\nprint(\n    f\"  [{rm_from_axis_angle.r11:.3f}, {rm_from_axis_angle.r12:.3f}, {rm_from_axis_angle.r13:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_axis_angle.r21:.3f}, {rm_from_axis_angle.r22:.3f}, {rm_from_axis_angle.r23:.3f}]\"\n)\nprint(\n    f\"  [{rm_from_axis_angle.r31:.3f}, {rm_from_axis_angle.r32:.3f}, {rm_from_axis_angle.r33:.3f}]\"\n)\n\n# Expected output:\n# Identity rotation matrix:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From matrix of elements:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# 30\u00b0 rotation about X-axis:\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.866, 0.500]\n#   [0.000, -0.500, 0.866]\n\n# 60\u00b0 rotation about Y-axis:\n#   [0.500, 0.000, -0.866]\n#   [0.000, 1.000, 0.000]\n#   [0.866, 0.000, 0.500]\n\n# 45\u00b0 rotation about Z-axis:\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From quaternion (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From Euler angles (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# From Euler axis (45\u00b0 about Z-axis):\n#   [0.707, 0.707, 0.000]\n#   [-0.707, 0.707, 0.000]\n#   [0.000, 0.000, 1.000]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::AngleFormat;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize from 9 individual elements (row-major order)\n    // Identity rotation\n    let rm_identity = bh::RotationMatrix::new(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    ).unwrap();\n    println!(\"Identity rotation matrix:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(0, 0)], rm_identity[(0, 1)], rm_identity[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(1, 0)], rm_identity[(1, 1)], rm_identity[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_identity[(2, 0)], rm_identity[(2, 1)], rm_identity[(2, 2)]);\n\n    // Initialize from a matrix of elements\n    let matrix_elements = na::SMatrix::&lt;f64, 3, 3&gt;::new(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    let rm_from_matrix = bh::RotationMatrix::from_matrix(matrix_elements).unwrap();\n    println!(\"\\nFrom matrix of elements:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(0, 0)], rm_from_matrix[(0, 1)], rm_from_matrix[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(1, 0)], rm_from_matrix[(1, 1)], rm_from_matrix[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_matrix[(2, 0)], rm_from_matrix[(2, 1)], rm_from_matrix[(2, 2)]);\n\n    // Common rotation: 30\u00b0 about X-axis\n    let angle_x = 30.0;\n    let rm_x = bh::RotationMatrix::Rx(angle_x, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about X-axis:\", angle_x as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(0, 0)], rm_x[(0, 1)], rm_x[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(1, 0)], rm_x[(1, 1)], rm_x[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(2, 0)], rm_x[(2, 1)], rm_x[(2, 2)]);\n\n    // Common rotation: 60\u00b0 about Y-axis\n    let angle_y = 60.0;\n    let rm_y = bh::RotationMatrix::Ry(angle_y, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about Y-axis:\", angle_y as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(0, 0)], rm_y[(0, 1)], rm_y[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(1, 0)], rm_y[(1, 1)], rm_y[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_y[(2, 0)], rm_y[(2, 1)], rm_y[(2, 2)]);\n\n    // Common rotation: 45\u00b0 about Z-axis\n    let angle_z = 45.0;\n    let rm_z = bh::RotationMatrix::Rz(angle_z, AngleFormat::Degrees);\n    println!(\"\\n{}\u00b0 rotation about Z-axis:\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(0, 0)], rm_z[(0, 1)], rm_z[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(1, 0)], rm_z[(1, 1)], rm_z[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(2, 0)], rm_z[(2, 1)], rm_z[(2, 2)]);\n\n    // Initialize from another representation (quaternion)\n    let q = bh::Quaternion::new(\n        (angle_z.to_radians() / 2.0).cos(),\n        0.0,\n        0.0,\n        (angle_z.to_radians() / 2.0).sin()\n    );\n    let rm_from_q = bh::RotationMatrix::from_quaternion(q);\n    println!(\"\\nFrom quaternion ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(0, 0)], rm_from_q[(0, 1)], rm_from_q[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(1, 0)], rm_from_q[(1, 1)], rm_from_q[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_q[(2, 0)], rm_from_q[(2, 1)], rm_from_q[(2, 2)]);\n\n    // Initialize from Euler angles (ZYX sequence)\n    let euler_angles = bh::EulerAngle::new(\n        bh::EulerAngleOrder::ZYX,\n        angle_z,\n        0.0,\n        0.0,\n        AngleFormat::Degrees\n    );\n    let rm_from_euler = bh::RotationMatrix::from_euler_angle(euler_angles);\n    println!(\"\\nFrom Euler angles ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(0, 0)], rm_from_euler[(0, 1)], rm_from_euler[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(1, 0)], rm_from_euler[(1, 1)], rm_from_euler[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_euler[(2, 0)], rm_from_euler[(2, 1)], rm_from_euler[(2, 2)]);\n\n    // Initialize from Euler axis and angle\n    let axis = na::SVector::&lt;f64, 3&gt;::new(0.0, 0.0, 1.0); // Z-axis\n    let euler_axis = bh::EulerAxis::new(axis, angle_z, AngleFormat::Degrees);\n    let rm_from_axis_angle = bh::RotationMatrix::from_euler_axis(euler_axis);\n    println!(\"\\nFrom Euler axis ({}\u00b0 about Z-axis):\", angle_z as i32);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(0, 0)], rm_from_axis_angle[(0, 1)], rm_from_axis_angle[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(1, 0)], rm_from_axis_angle[(1, 1)], rm_from_axis_angle[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_from_axis_angle[(2, 0)], rm_from_axis_angle[(2, 1)], rm_from_axis_angle[(2, 2)]);\n}\n\n// Expected output:\n// Identity rotation matrix:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From matrix of elements:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// 30\u00b0 rotation about X-axis:\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.866, 0.500]\n//   [0.000, -0.500, 0.866]\n//\n// 60\u00b0 rotation about Y-axis:\n//   [0.500, 0.000, -0.866]\n//   [0.000, 1.000, 0.000]\n//   [0.866, 0.000, 0.500]\n//\n// 45\u00b0 rotation about Z-axis:\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From quaternion (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From Euler angles (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n//\n// From Euler axis (45\u00b0 about Z-axis):\n//   [0.707, 0.707, 0.000]\n//   [-0.707, 0.707, 0.000]\n//   [0.000, 0.000, 1.000]\n</code></pre> <p>Tip</p> <p>Brahe provides convenient methods to create rotation matrices for elementary rotations about the X, Y, and Z axes:</p> <ul> <li><code>RotationMatrix.Rx(angle, format)</code></li> <li><code>RotationMatrix.Ry(angle, format)</code></li> <li><code>RotationMatrix.Rz(angle, format)</code></li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html#output-and-access","title":"Output and Access","text":"<p>Access rotation matrix elements and convert to other formats:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a rotation matrix (45\u00b0 about Z-axis)\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n\n# Access individual elements\nprint(\"Individual elements (row-by-row):\")\nprint(f\"  r11: {rm.r11:.6f}, r12: {rm.r12:.6f}, r13: {rm.r13:.6f}\")\nprint(f\"  r21: {rm.r21:.6f}, r22: {rm.r22:.6f}, r23: {rm.r23:.6f}\")\nprint(f\"  r31: {rm.r31:.6f}, r32: {rm.r32:.6f}, r33: {rm.r33:.6f}\")\n# String representation\nprint(\"\\nString representation:\")\nprint(f\"  {rm}\")\n\n# Expected output:\n# Individual elements (row-by-row):\n#   r11: 0.707107, r12: 0.707107, r13: 0.000000\n#   r21: -0.707107, r22: 0.707107, r23: 0.000000\n#   r31: 0.000000, r32: 0.000000, r33: 1.000000\n\n# String representation:\n#   RotationMatrix:\n\n#   \u250c                                                             \u2510\n#   \u2502  0.7071067811865476  0.7071067811865475                   0 \u2502\n#   \u2502 -0.7071067811865475  0.7071067811865476                   0 \u2502\n#   \u2502                   0                   0                   1 \u2502\n#   \u2514                                                             \u2518\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Create a rotation matrix (45\u00b0 about Z-axis)\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n\n    // Access individual elements\n    println!(\"Individual elements (row-by-row):\");\n    println!(\"  r11: {:.6}, r12: {:.6}, r13: {:.6}\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  r21: {:.6}, r22: {:.6}, r23: {:.6}\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  r31: {:.6}, r32: {:.6}, r33: {:.6}\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // String representation\n    println!(\"\\nString representation:\");\n    println!(\"  {:?}\", rm);\n}\n\n// Expected output:\n// Individual elements (row-by-row):\n//   r11: 0.707107, r12: 0.707107, r13: 0.000000\n//   r21: -0.707107, r22: 0.707107, r23: 0.000000\n//   r31: 0.000000, r32: 0.000000, r33: 1.000000\n\n// String representation:\n//   RotationMatrix: \n// [[0.7071067811865476, -0.7071067811865475, 0.0], [0.7071067811865475, 0.7071067811865476, 0.0], [0.0, 0.0, 1.0]]\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#operations","title":"Operations","text":"<p>Rotation matrices support composition through matrix multiplication and vector rotation:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Create two rotation matrices\n# 90\u00b0 rotation about X-axis\nrm_x = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0)\n\n# 90\u00b0 rotation about Z-axis\nrm_z = bh.RotationMatrix(0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0)\n\nprint(\"Rotation matrix X (90\u00b0 about X):\")\nprint(f\"  [{rm_x.r11:.3f}, {rm_x.r12:.3f}, {rm_x.r13:.3f}]\")\nprint(f\"  [{rm_x.r21:.3f}, {rm_x.r22:.3f}, {rm_x.r23:.3f}]\")\nprint(f\"  [{rm_x.r31:.3f}, {rm_x.r32:.3f}, {rm_x.r33:.3f}]\")\n\nprint(\"\\nRotation matrix Z (90\u00b0 about Z):\")\nprint(f\"  [{rm_z.r11:.3f}, {rm_z.r12:.3f}, {rm_z.r13:.3f}]\")\nprint(f\"  [{rm_z.r21:.3f}, {rm_z.r22:.3f}, {rm_z.r23:.3f}]\")\nprint(f\"  [{rm_z.r31:.3f}, {rm_z.r32:.3f}, {rm_z.r33:.3f}]\")\n\n# Matrix multiplication (compose rotations)\n# Apply rm_x first, then rm_z\nrm_composed = rm_z * rm_x\nprint(\"\\nComposed rotation (X then Z):\")\nprint(f\"  [{rm_composed.r11:.3f}, {rm_composed.r12:.3f}, {rm_composed.r13:.3f}]\")\nprint(f\"  [{rm_composed.r21:.3f}, {rm_composed.r22:.3f}, {rm_composed.r23:.3f}]\")\nprint(f\"  [{rm_composed.r31:.3f}, {rm_composed.r32:.3f}, {rm_composed.r33:.3f}]\")\n\n# Transform a vector using rotation matrix\n# Rotate vector [1, 0, 0] by 90\u00b0 about Z-axis using matrix multiplication\nR_z = rm_z.to_matrix()  # Get 3x3 numpy array\nvector = np.array([1.0, 0.0, 0.0])\nrotated = R_z @ vector  # Matrix-vector multiplication\nprint(\"\\nVector transformation:\")\nprint(f\"  Original: [{vector[0]:.3f}, {vector[1]:.3f}, {vector[2]:.3f}]\")\nprint(f\"  Rotated:  [{rotated[0]:.3f}, {rotated[1]:.3f}, {rotated[2]:.3f}]\")\n\n# Transform another vector\nvector2 = np.array([0.0, 1.0, 0.0])\nrotated2 = R_z @ vector2\nprint(f\"\\n  Original: [{vector2[0]:.3f}, {vector2[1]:.3f}, {vector2[2]:.3f}]\")\nprint(f\"  Rotated:  [{rotated2[0]:.3f}, {rotated2[1]:.3f}, {rotated2[2]:.3f}]\")\n\n# Equality comparison\neq_result = rm_x == rm_z\nneq_result = rm_x != rm_z\nprint(\"\\nEquality comparison:\")\nprint(f\"  rm_x == rm_z: {eq_result}\")\nprint(f\"  rm_x != rm_z: {neq_result}\")\n\n# Expected output:\n# Rotation matrix X (90\u00b0 about X):\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.000, -1.000]\n#   [0.000, 1.000, 0.000]\n\n# Rotation matrix Z (90\u00b0 about Z):\n#   [0.000, -1.000, 0.000]\n#   [1.000, 0.000, 0.000]\n#   [0.000, 0.000, 1.000]\n\n# Composed rotation (X then Z):\n#   [0.000, 0.000, 1.000]\n#   [1.000, 0.000, 0.000]\n#   [0.000, 1.000, 0.000]\n\n# Vector transformation:\n#   Original: [1.000, 0.000, 0.000]\n#   Rotated:  [0.000, 1.000, 0.000]\n\n#   Original: [0.000, 1.000, 0.000]\n#   Rotated:  [-1.000, 0.000, 0.000]\n\n# Equality comparison:\n#   rm_x == rm_z: False\n#   rm_x != rm_z: True\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    // Create two rotation matrices\n    // 90\u00b0 rotation about X-axis\n    let rm_x = bh::RotationMatrix::new(\n        1.0, 0.0, 0.0,\n        0.0, 0.0, -1.0,\n        0.0, 1.0, 0.0\n    ).unwrap();\n\n    // 90\u00b0 rotation about Z-axis\n    let rm_z = bh::RotationMatrix::new(\n        0.0, -1.0, 0.0,\n        1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    ).unwrap();\n\n    println!(\"Rotation matrix X (90\u00b0 about X):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(0, 0)], rm_x[(0, 1)], rm_x[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(1, 0)], rm_x[(1, 1)], rm_x[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_x[(2, 0)], rm_x[(2, 1)], rm_x[(2, 2)]);\n\n    println!(\"\\nRotation matrix Z (90\u00b0 about Z):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(0, 0)], rm_z[(0, 1)], rm_z[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(1, 0)], rm_z[(1, 1)], rm_z[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_z[(2, 0)], rm_z[(2, 1)], rm_z[(2, 2)]);\n\n    // Matrix multiplication (compose rotations)\n    // Apply rm_x first, then rm_z\n    let rm_composed = rm_z * rm_x;\n    println!(\"\\nComposed rotation (X then Z):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(0, 0)], rm_composed[(0, 1)], rm_composed[(0, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(1, 0)], rm_composed[(1, 1)], rm_composed[(1, 2)]);\n    println!(\"  [{:.3}, {:.3}, {:.3}]\", rm_composed[(2, 0)], rm_composed[(2, 1)], rm_composed[(2, 2)]);\n\n    // Transform a vector using rotation matrix\n    // Rotate vector [1, 0, 0] by 90\u00b0 about Z-axis using matrix multiplication\n    let vector = na::SVector::&lt;f64, 3&gt;::new(1.0, 0.0, 0.0);\n    let rotated = rm_z.to_matrix() * vector;  // Matrix-vector multiplication\n    println!(\"\\nVector transformation:\");\n    println!(\"  Original: [{:.3}, {:.3}, {:.3}]\", vector[0], vector[1], vector[2]);\n    println!(\"  Rotated:  [{:.3}, {:.3}, {:.3}]\", rotated[0], rotated[1], rotated[2]);\n\n    // Transform another vector\n    let vector2 = na::SVector::&lt;f64, 3&gt;::new(0.0, 1.0, 0.0);\n    let rotated2 = rm_z.to_matrix() * vector2;\n    println!(\"\\n  Original: [{:.3}, {:.3}, {:.3}]\", vector2[0], vector2[1], vector2[2]);\n    println!(\"  Rotated:  [{:.3}, {:.3}, {:.3}]\", rotated2[0], rotated2[1], rotated2[2]);\n\n    let eq_result = rm_x == rm_z;\n    let neq_result = rm_x != rm_z;\n    println!(\"\\nEquality comparison:\");\n    println!(\"  rm_x == rm_z: {}\", eq_result);\n    println!(\"  rm_x != rm_z: {}\", neq_result);\n}\n\n// Expected output:\n// Rotation matrix X (90\u00b0 about X):\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.000, -1.000]\n//   [0.000, 1.000, 0.000]\n\n// Rotation matrix Z (90\u00b0 about Z):\n//   [0.000, -1.000, 0.000]\n//   [1.000, 0.000, 0.000]\n//   [0.000, 0.000, 1.000]\n\n// Composed rotation (X then Z):\n//   [0.000, 0.000, 1.000]\n//   [1.000, 0.000, 0.000]\n//   [0.000, 1.000, 0.000]\n\n// Vector transformation:\n//   Original: [1.000, 0.000, 0.000]\n//   Rotated:  [0.000, 1.000, 0.000]\n\n//   Original: [0.000, 1.000, 0.000]\n//   Rotated:  [-1.000, 0.000, 0.000]\n\n// Equality comparison:\n//   rm_x == rm_z: false\n//   rm_x != rm_z: true\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#conversions","title":"Conversions","text":"<p>Convert between rotation matrices and other attitude representations:</p> PythonRust <pre><code>import brahe as bh\nimport math\n\n# Create a rotation matrix (45\u00b0 about Z-axis)\nrm = bh.RotationMatrix.Rz(45, bh.AngleFormat.DEGREES)\n\nprint(\"Original rotation matrix:\")\nprint(f\"  [{rm.r11:.6f}, {rm.r12:.6f}, {rm.r13:.6f}]\")\nprint(f\"  [{rm.r21:.6f}, {rm.r22:.6f}, {rm.r23:.6f}]\")\nprint(f\"  [{rm.r31:.6f}, {rm.r32:.6f}, {rm.r33:.6f}]\")\n\n# Convert to quaternion\nq = rm.to_quaternion()\nprint(\"\\nTo quaternion:\")\nprint(f\"  q = [{q.w:.6f}, {q.x:.6f}, {q.y:.6f}, {q.z:.6f}]\")\n\n# Convert to Euler angles (ZYX sequence)\nea_zyx = rm.to_euler_angle(bh.EulerAngleOrder.ZYX)\nprint(\"\\nTo Euler angles (ZYX):\")\nprint(f\"  Yaw (Z):   {math.degrees(ea_zyx.phi):.3f}\u00b0\")\nprint(f\"  Pitch (Y): {math.degrees(ea_zyx.theta):.3f}\u00b0\")\nprint(f\"  Roll (X):  {math.degrees(ea_zyx.psi):.3f}\u00b0\")\n\n# Convert to Euler angles (XYZ sequence)\nea_xyz = rm.to_euler_angle(bh.EulerAngleOrder.XYZ)\nprint(\"\\nTo Euler angles (XYZ):\")\nprint(f\"  Angle 1 (X): {math.degrees(ea_xyz.phi):.3f}\u00b0\")\nprint(f\"  Angle 2 (Y): {math.degrees(ea_xyz.theta):.3f}\u00b0\")\nprint(f\"  Angle 3 (Z): {math.degrees(ea_xyz.psi):.3f}\u00b0\")\n\n# Convert to Euler axis (axis-angle)\nea = rm.to_euler_axis()\nprint(\"\\nTo Euler axis:\")\nprint(f\"  Axis: [{ea.axis[0]:.6f}, {ea.axis[1]:.6f}, {ea.axis[2]:.6f}]\")\nprint(f\"  Angle: {math.degrees(ea.angle):.3f}\u00b0\")\n\n# Round-trip conversion test\nrm_roundtrip = bh.RotationMatrix.from_quaternion(q)\nprint(\"\\nRound-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\")\nprint(f\"  [{rm_roundtrip.r11:.6f}, {rm_roundtrip.r12:.6f}, {rm_roundtrip.r13:.6f}]\")\nprint(f\"  [{rm_roundtrip.r21:.6f}, {rm_roundtrip.r22:.6f}, {rm_roundtrip.r23:.6f}]\")\nprint(f\"  [{rm_roundtrip.r31:.6f}, {rm_roundtrip.r32:.6f}, {rm_roundtrip.r33:.6f}]\")\n\n# Expected output:\n# Original rotation matrix:\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n#\n# To quaternion:\n#   q = [0.923880, 0.000000, 0.000000, 0.382683]\n#\n# To Euler angles (ZYX):\n#   Yaw (Z):   45.000\u00b0\n#   Pitch (Y): 0.000\u00b0\n#   Roll (X):  0.000\u00b0\n#\n# To Euler angles (XYZ):\n#   Angle 1 (X): 0.000\u00b0\n#   Angle 2 (Y): 0.000\u00b0\n#   Angle 3 (Z): 45.000\u00b0\n#\n# To Euler axis:\n#   Axis: [0.000000, 0.000000, 1.000000]\n#   Angle: 45.000\u00b0\n#\n# Round-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\n#   [0.707107, -0.707107, 0.000000]\n#   [0.707107, 0.707107, 0.000000]\n#   [0.000000, 0.000000, 1.000000]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::attitude::FromAttitude;\nuse brahe::attitude::ToAttitude;\n\nfn main() {\n    // Create a rotation matrix (45\u00b0 about Z-axis)\n    let rm = bh::RotationMatrix::Rz(45.0, bh::AngleFormat::Degrees);\n\n    println!(\"Original rotation matrix:\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(0, 0)], rm[(0, 1)], rm[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(1, 0)], rm[(1, 1)], rm[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm[(2, 0)], rm[(2, 1)], rm[(2, 2)]);\n\n    // Convert to quaternion\n    let q = rm.to_quaternion();\n    println!(\"\\nTo quaternion:\");\n    println!(\"  q = [{:.6}, {:.6}, {:.6}, {:.6}]\", q[0], q[1], q[2], q[3]);\n\n    // Convert to Euler angles (ZYX sequence)\n    let ea_zyx = rm.to_euler_angle(bh::EulerAngleOrder::ZYX);\n    println!(\"\\nTo Euler angles (ZYX):\");\n    println!(\"  Yaw (Z):   {:.3}\u00b0\", ea_zyx.phi.to_degrees());\n    println!(\"  Pitch (Y): {:.3}\u00b0\", ea_zyx.theta.to_degrees());\n    println!(\"  Roll (X):  {:.3}\u00b0\", ea_zyx.psi.to_degrees());\n\n    // Convert to Euler angles (XYZ sequence)\n    let ea_xyz = rm.to_euler_angle(bh::EulerAngleOrder::XYZ);\n    println!(\"\\nTo Euler angles (XYZ):\");\n    println!(\"  Angle 1 (X): {:.3}\u00b0\", ea_xyz.phi.to_degrees());\n    println!(\"  Angle 2 (Y): {:.3}\u00b0\", ea_xyz.theta.to_degrees());\n    println!(\"  Angle 3 (Z): {:.3}\u00b0\", ea_xyz.psi.to_degrees());\n\n    // Convert to Euler axis (axis-angle)\n    let ea = rm.to_euler_axis();\n    println!(\"\\nTo Euler axis:\");\n    println!(\"  Axis: [{:.6}, {:.6}, {:.6}]\", ea.axis[0], ea.axis[1], ea.axis[2]);\n    println!(\"  Angle: {:.3}\u00b0\", ea.angle.to_degrees());\n\n    // Round-trip conversion test\n    let rm_roundtrip = bh::RotationMatrix::from_quaternion(q);\n    println!(\"\\nRound-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\");\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(0, 0)], rm_roundtrip[(0, 1)], rm_roundtrip[(0, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(1, 0)], rm_roundtrip[(1, 1)], rm_roundtrip[(1, 2)]);\n    println!(\"  [{:.6}, {:.6}, {:.6}]\", rm_roundtrip[(2, 0)], rm_roundtrip[(2, 1)], rm_roundtrip[(2, 2)]);\n}\n\n// Expected output:\n// Original rotation matrix:\n//   [0.707107, -0.707107, 0.000000]\n//   [0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n//\n// To quaternion:\n//   q = [0.923880, 0.000000, 0.000000, 0.382683]\n//\n// To Euler angles (ZYX):\n//   Yaw (Z):   45.000\u00b0\n//   Pitch (Y): 0.000\u00b0\n//   Roll (X):  0.000\u00b0\n//\n// To Euler angles (XYZ):\n//   Angle 1 (X): 0.000\u00b0\n//   Angle 2 (Y): 0.000\u00b0\n//   Angle 3 (Z): 45.000\u00b0\n//\n// To Euler axis:\n//   Axis: [0.000000, 0.000000, 1.000000]\n//   Angle: 45.000\u00b0\n//\n// Round-trip (RotationMatrix \u2192 Quaternion \u2192 RotationMatrix):\n//   [0.707107, -0.707107, 0.000000]\n//   [0.707107, 0.707107, 0.000000]\n//   [0.000000, 0.000000, 1.000000]\n</code></pre>"},{"location":"learn/attitude_representations/rotation_matrices.html#see-also","title":"See Also","text":"<ul> <li>Rotation Matrix API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/cli/index.html","title":"Brahe CLI","text":"<p>The Brahe command-line interface provides tools for quick-access time, coordinate, and orbital mechanics calculations directly from the terminal. It also provides functions to download Earth Orientation Parameters (EOP) and satellite datasets.</p>"},{"location":"learn/cli/index.html#installation","title":"Installation","text":"<p>The CLI is included with the Brahe Python package:</p> <pre><code>pip install brahe\n# or\nuv pip install brahe\n</code></pre>"},{"location":"learn/cli/index.html#quick-start","title":"Quick Start","text":"<pre><code># Get help\nbrahe --help\n\n# Convert between time formats\nbrahe time convert \"2024-01-01T00:00:00Z\" string mjd\n# 60310.00042824074\n\n# Calculate orbital period\nbrahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n# 94.616286\n\n# Transform coordinates between representations\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n# [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055\n\n# Compute satellite access windows\nbrahe access compute 25544 --lon -122.4194 --lat 37.7749\n# Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 37.7749\u00b0 lat, -122.4194\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 17 access window(s)\n# ...\n</code></pre>"},{"location":"learn/cli/index.html#command-groups","title":"Command Groups","text":""},{"location":"learn/cli/index.html#eop","title":"eop","text":"<p>Earth Orientation Parameter operations: - <code>download</code> - Download EOP data from IERS - <code>get-utc-ut1</code> - Get UTC-UT1 offset - <code>get-polar-motion</code> - Get polar motion parameters - <code>get-cip-offset</code> - Get CIP offset - <code>get-lod</code> - Get length of day</p>"},{"location":"learn/cli/index.html#datasets","title":"datasets","text":"<p>Download and query satellite data: - <code>celestrak</code> - CelesTrak TLE data operations - <code>groundstations</code> - Ground station database operations</p>"},{"location":"learn/cli/index.html#time","title":"time","text":"<p>Time system operations and conversions:</p> <ul> <li><code>convert</code> - Convert between time formats (MJD, JD, GPS, ISO-8601)</li> <li><code>add</code> - Add time offsets to epochs</li> <li><code>time-system-offset</code> - Calculate offsets between time systems</li> <li><code>range</code> - Generate time ranges</li> </ul>"},{"location":"learn/cli/index.html#orbits","title":"orbits","text":"<p>Orbital mechanics calculations:</p> <ul> <li><code>orbital-period</code> - Calculate orbital period from semi-major axis</li> <li><code>sma-from-period</code> - Calculate semi-major axis from period</li> <li><code>mean-motion</code> - Calculate mean motion</li> <li><code>anomaly-conversion</code> - Convert between anomaly types</li> <li><code>sun-sync-inclination</code> - Calculate sun-synchronous inclination</li> <li><code>perigee-velocity</code> / <code>apogee-velocity</code> - Calculate velocities at apsides</li> </ul>"},{"location":"learn/cli/index.html#transform","title":"transform","text":"<p>Convert between coordinate systems and reference frames:</p> <ul> <li><code>coordinates</code> - Convert between Keplerian, Cartesian, Geodetic, and Geocentric representations</li> </ul>"},{"location":"learn/cli/index.html#access","title":"access","text":"<p>Satellite access window calculations: - <code>compute</code> - Calculate visibility windows for ground stations</p>"},{"location":"learn/cli/index.html#global-options","title":"Global Options","text":"<pre><code>--verbose, -v    Enable verbose output (INFO level)\n--debug, -d      Enable debug output (DEBUG level)\n--help           Show help message\n</code></pre>"},{"location":"learn/cli/index.html#features","title":"Features","text":""},{"location":"learn/cli/index.html#constant-expressions","title":"Constant Expressions","text":"<p>Many numeric arguments support mathematical expressions using Brahe constants:</p> <pre><code># Use R_EARTH constant for semi-major axis (500km altitude LEO)\nbrahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n# 94.616286\n</code></pre> <p>Available constants include: - <code>R_EARTH</code>, <code>R_SUN</code>, <code>R_MOON</code> - Body radii (meters) - <code>GM_EARTH</code>, <code>GM_SUN</code>, <code>GM_MOON</code> - Gravitational parameters (m\u00b3/s\u00b2) - <code>DEG2RAD</code>, <code>RAD2DEG</code> - Angular conversions - <code>MJD_ZERO</code>, <code>MJD2000</code>, <code>GPS_ZERO</code> - Time epoch constants</p> <p>See the Constants documentation for the complete list.</p>"},{"location":"learn/cli/index.html#see-also","title":"See Also","text":"<ul> <li>Python API Documentation</li> <li>Coordinate Systems</li> <li>Time Systems</li> <li>Orbital Mechanics</li> </ul>"},{"location":"learn/cli/access.html","title":"Access Commands","text":"<p>The <code>access</code> command group calculates when satellites are visible from ground locations, considering elevation constraints and other visibility criteria.</p>"},{"location":"learn/cli/access.html#commands","title":"Commands","text":""},{"location":"learn/cli/access.html#compute","title":"<code>compute</code>","text":"<p>Compute satellite access windows for a ground location.</p> <p>Syntax: <pre><code>brahe access compute &lt;NORAD_ID&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID of the satellite (integer)</p> <p>Location Options (choose one):</p> <p>Location coordinates: - <code>--lat &lt;degrees&gt;</code> - Latitude in degrees (-90 to 90) - <code>--lon &lt;degrees&gt;</code> - Longitude in degrees (-180 to 180) - <code>--alt &lt;meters&gt;</code> - Altitude above WGS84 ellipsoid (default: 0.0)</p> <p>Or ground station lookup: - <code>--gs-provider &lt;name&gt;</code> - Ground station provider (e.g., 'ksat', 'atlas', 'aws') - <code>--gs-name &lt;name&gt;</code> - Ground station name to lookup</p> <p>Time Range Options:</p> <ul> <li><code>--start-time &lt;epoch&gt;</code> - Start time (ISO-8601). Default: now</li> <li><code>--end-time &lt;epoch&gt;</code> - End time (ISO-8601)</li> <li><code>--duration &lt;days&gt;</code> - Duration in days (default: 7)</li> </ul> <p>Constraint Options:</p> <ul> <li><code>--min-elevation &lt;degrees&gt;</code> - Minimum elevation angle (default: 10.0)</li> </ul> <p>Output Options:</p> <ul> <li><code>--output-format [table|rich|simple]</code> - Output format (default: <code>table</code>)</li> <li><code>--sort-by [contact_number|start_time|end_time|duration|max_elevation|start_azimuth|end_azimuth]</code> - Sort field (default: <code>start_time</code>)</li> <li><code>--sort-order [ascending|descending]</code> - Sort order (default: <code>ascending</code>)</li> <li><code>--max-results &lt;count&gt;</code> - Maximum number of windows to display</li> <li><code>--output-file &lt;path&gt;</code> - Export results to JSON file</li> </ul> <p>Examples:</p> <p>ISS passes over New York City (next 7 days): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n...\n</code></pre></p> <p>GPS satellite passes (15\u00b0 minimum elevation): <pre><code>brahe access compute 32260 --lat 40.7128 --lon -74.0060 --min-elevation 15\n</code></pre> Output: <pre><code># Access Windows for NAVSTAR 60 (USA 196) (NORAD ID: 32260)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 15.0\u00b0\n# Found 8 access window(s)\n</code></pre></p> <p>Custom time range: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --start-time \"2024-06-01T00:00:00Z\" \\\n  --duration 1\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 2 access window(s)\n</code></pre></p> <p>Use ground station database: <pre><code>brahe access compute 25544 --gs-provider ksat --gs-name \"Svalbard\"\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 78.2300\u00b0 lat, 15.4100\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 19 access window(s)\n</code></pre></p> <p>Simple output format: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-format simple\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n\n# 1. 2025-11-03 18:36:18.197 UTC | 2025-11-03 18:38:16.000 UTC | 1m 57s | Max Elev: 11.9\u00b0 | Az: 150\u00b0-114\u00b0\n# 2. 2025-11-03 20:11:37.226 UTC | 2025-11-03 20:16:16.000 UTC | 4m 38s | Max Elev: 20.6\u00b0 | Az: 255\u00b0-351\u00b0\n</code></pre></p> <p>Export to JSON: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-file passes.json\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n</code></pre></p> <p>Sort by maximum elevation (highest first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by max_elevation --sort-order descending --max-results 5\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 5 access window(s)\n\n# \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503         \u2503 Start   \u2503 End    \u2503         \u2503    Max \u2503   Start \u2503        \u2503\n# \u2503 Contact \u2503 Time    \u2503 Time   \u2503         \u2503   Elev \u2503      Az \u2503 End Az \u2503\n# \u2503       # \u2503 (UTC)   \u2503 (UTC)  \u2503 Durati\u2026 \u2503  (deg) \u2503   (deg) \u2503  (deg) \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502       1 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   77.0 \u2502     321 \u2502    148 \u2502\n# \u2502         \u2502 05:22:\u2026 \u2502 05:28\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 31.74   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       2 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   69.8 \u2502     319 \u2502    151 \u2502\n# \u2502         \u2502 06:58:\u2026 \u2502 07:04\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 30.04   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       3 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   57.9 \u2502     206 \u2502     46 \u2502\n# \u2502         \u2502 18:34:\u2026 \u2502 18:40\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 7.79    \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       4 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   52.9 \u2502     204 \u2502     48 \u2502\n# \u2502         \u2502 16:58:\u2026 \u2502 17:04\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 9.76    \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       5 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 5       \u2502   52.6 \u2502     227 \u2502     22 \u2502\n# \u2502         \u2502 17:46:\u2026 \u2502 17:52\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 59.45   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Sort by duration (longest passes first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by duration --sort-order descending\n</code></pre> Output: <pre><code># Access Windows for ISS (ZARYA) (NORAD ID: 25544)\n# Location: 40.7128\u00b0 lat, -74.0060\u00b0 lon, 0 m alt\n# Minimum elevation: 10.0\u00b0\n# Found 18 access window(s)\n\n# \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503         \u2503 Start   \u2503 End    \u2503         \u2503    Max \u2503   Start \u2503        \u2503\n# \u2503 Contact \u2503 Time    \u2503 Time   \u2503         \u2503   Elev \u2503      Az \u2503 End Az \u2503\n# \u2503       # \u2503 (UTC)   \u2503 (UTC)  \u2503 Durati\u2026 \u2503  (deg) \u2503   (deg) \u2503  (deg) \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502       1 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   53.8 \u2502     204 \u2502     47 \u2502\n# \u2502         \u2502 16:58:\u2026 \u2502 17:05\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 24.76   \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502         \u2502        \u2502 seconds \u2502        \u2502         \u2502        \u2502\n# \u2502       2 \u2502 2025-1\u2026 \u2502 2025-\u2026 \u2502 6       \u2502   59.5 \u2502     206 \u2502     45 \u2502\n# \u2502         \u2502 18:34:\u2026 \u2502 18:41\u2026 \u2502 minutes \u2502        \u2502         \u2502        \u2502\n# \u2502         \u2502 UTC     \u2502 UTC    \u2502 and     \u2502        \u2502         \u2502        \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/access.html#tips","title":"Tips","text":""},{"location":"learn/cli/access.html#norad-catalog-ids","title":"NORAD Catalog IDs","text":"<p>Find NORAD IDs using the datasets command: <pre><code># Search for satellite by name\nbrahe datasets celestrak lookup \"ISS\"\n\n# Show TLE with NORAD ID\nbrahe datasets celestrak show 25544\n</code></pre></p> <p>See Datasets CLI for more details.</p>"},{"location":"learn/cli/access.html#negative-longitudes","title":"Negative Longitudes","text":"<p>For westerly longitudes, use negative values with <code>=</code> or <code>--</code>: <pre><code># Method 1: Negative longitude\nbrahe access compute 25544 --lat 40.7128 --lon=-74.0060\n\n# Method 2: After -- separator\nbrahe access compute 25544 -- --lat 40.7128 --lon -74.0060\n</code></pre></p>"},{"location":"learn/cli/access.html#output-formats","title":"Output Formats","text":"<p>table (default): - ASCII table with columns - Good for terminal viewing - Aligned columns</p> <p>rich: - Enhanced table with colors - Better readability in modern terminals</p> <p>simple: - Plain text, one line per pass - Easy to parse with scripts</p> <p>JSON (via <code>--output-file</code>): - Machine-readable - Complete data structure - For further processing</p>"},{"location":"learn/cli/access.html#performance","title":"Performance","text":"<p>Computing access windows requires: 1. Downloading TLE data from CelesTrak (cached) 2. Downloading EOP data (cached) 3. Propagating orbit over time range</p> <p>Longer durations take more time: - 1 day: ~1-2 seconds - 7 days: ~5-10 seconds - 30 days: ~20-30 seconds</p>"},{"location":"learn/cli/access.html#see-also","title":"See Also","text":"<ul> <li>Ground Contacts Example - Detailed access computation examples</li> <li>Datasets CLI - Find NORAD IDs and download TLEs</li> <li>Groundstations Dataset - Ground station database</li> <li>Access API - Python access computation functions</li> </ul>"},{"location":"learn/cli/datasets.html","title":"Datasets Commands","text":"<p>Download and query satellite ephemeris data and ground station information.</p>"},{"location":"learn/cli/datasets.html#overview","title":"Overview","text":"<p>The <code>datasets</code> command group provides access to: - CelesTrak - Satellite TLE (Two-Line Element) data - Ground Stations - Commercial ground station network databases</p>"},{"location":"learn/cli/datasets.html#celestrak-commands","title":"CelesTrak Commands","text":""},{"location":"learn/cli/datasets.html#celestrak-download","title":"<code>celestrak download</code>","text":"<p>Download satellite ephemeris data from CelesTrak and save to file.</p> <p>Syntax: <pre><code>brahe datasets celestrak download &lt;GROUP&gt; &lt;FILEPATH&gt;\n</code></pre></p> <p>Arguments: - <code>GROUP</code> - Satellite group name (e.g., 'stations', 'starlink', 'gps-ops') - <code>FILEPATH</code> - Output file path for TLE data</p> <p>Examples:</p> <p>Download space station TLEs: <pre><code>brahe datasets celestrak download --group stations ~/satellite_data/stations.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/stations.txt\n</code></pre></p> <p>Download Starlink constellation: <pre><code>brahe datasets celestrak download --group starlink ~/satellite_data/starlink.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/starlink.txt\n</code></pre></p> <p>Download GPS satellites: <pre><code>brahe datasets celestrak download --group gps-ops ~/satellite_data/gps.txt\n</code></pre> Output: <pre><code>\u2713 Downloaded stations satellites to ~/satellite_data/gps.txt\n</code></pre></p> <p>See available groups: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-lookup","title":"<code>celestrak lookup</code>","text":"<p>Look up a satellite by name and display its NORAD ID and TLE.</p> <p>Syntax: <pre><code>brahe datasets celestrak lookup &lt;NAME&gt;\n</code></pre></p> <p>Arguments: - <code>NAME</code> - Satellite name (partial match supported)</p> <p>Examples:</p> <p>Find ISS: <pre><code>brahe datasets celestrak lookup \"ISS\"\n</code></pre> Output: <pre><code># ISS (ZARYA) [NORAD ID: 25544]\n\n# TLE Lines:\n#   1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# \u2713 Found satellite 'ISS (ZARYA)'\n</code></pre></p> <p>Find Hubble Space Telescope: <pre><code>brahe datasets celestrak lookup \"HST\"\n</code></pre> Output: <pre><code># HST [NORAD ID: 20580]\n\n# TLE Lines:\n#   1 20580U 90037B   25306.35384425  .00007204  00000+0  25387-3 0  9994\n#   2 20580  28.4668 187.2184 0001915 134.9270 225.1481 15.27276544753814\n\n# \u2713 Found satellite 'HST'\n</code></pre></p> <p>Find by partial name: <pre><code>brahe datasets celestrak lookup \"CAPELLA\"\n</code></pre> Output: <pre><code># CAPELLA-11 (ACADIA-1) [NORAD ID: 57693]\n\n# TLE Lines:\n#   1 57693U 23126A   25306.12190313 -.00002119  00000+0 -25509-3 0  9998\n#   2 57693  53.0104  84.6427 0002550 126.4571 233.6640 14.78979627118491\n\n# \u2713 Found satellite 'CAPELLA-11 (ACADIA-1)'\n</code></pre> (Shows first match)</p>"},{"location":"learn/cli/datasets.html#celestrak-show","title":"<code>celestrak show</code>","text":"<p>Display TLE information and computed orbital parameters for a satellite.</p> <p>Syntax: <pre><code>brahe datasets celestrak show &lt;NORAD_ID&gt;\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID (integer)</p> <p>Examples:</p> <p>Show ISS TLE and orbit info: <pre><code>brahe datasets celestrak show 25544 -s\n</code></pre> Output: <pre><code># ISS (ZARYA) [NORAD ID: 25544]\n\n# TLE Lines:\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# Orbital Elements:\n#   Epoch:              2025-11-02 10:09:34.283 UTC\n#   Ephemeris Age:      21h 16m 13s\n#   Semi-major axis:    6795.7 km\n#   Eccentricity:       0.0004969\n#   Inclination:        51.6344\u00b0\n#   RAAN:               342.0717\u00b0\n#   Arg of Perigee:     8.9436\u00b0\n#   Mean Anomaly:       351.1640\u00b0\n\n# Orbital Characteristics:\n#   Orbital Period:     92.9 min (1.55 hours)\n#   Mean Motion:        15.497 rev/day\n#   Perigee Altitude:   414.2 km\n#   Apogee Altitude:    421.0 km\n</code></pre></p> <p>Show GPS satellite: <pre><code># brahe datasets celestrak show 32260\n</code></pre> Output: <pre><code># \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502 NAVSTAR 60 (USA 196)                                                                 \u2502\n# \u2502 NORAD ID: 32260                                                                      \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 TLE Lines \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Line 1:  1 32260U 07047A   25305.87057871  .00000045  00000+0  00000+0 0  9996      \u2502\n# \u2502  Line 2:  2 32260  53.9265  89.4464 0164696  84.6485 277.2299  2.00566111132250      \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Orbital Elements \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Epoch            2025-11-01 20:53:38.001 UTC                                        \u2502\n# \u2502  Ephemeris Age                 1d 10h 32m 23s                                        \u2502\n# \u2502  Semi-major axis                   26560.1 km                                        \u2502\n# \u2502  Eccentricity                       0.0164696                                        \u2502\n# \u2502  Inclination                         53.9265\u00b0                                        \u2502\n# \u2502  RAAN                                89.4464\u00b0                                        \u2502\n# \u2502  Arg of Perigee                      84.6485\u00b0                                        \u2502\n# \u2502  Mean Anomaly                       277.2299\u00b0                                        \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n# \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Orbital Characteristics \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n# \u2502  Orbital Period    718.0 min (11.97 hours)                                           \u2502\n# \u2502  Mean Motion                 2.006 rev/day                                           \u2502\n# \u2502  Perigee Altitude               19744.6 km                                           \u2502\n# \u2502  Apogee Altitude                20619.4 km                                           \u2502\n# \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-list-groups","title":"<code>celestrak list-groups</code>","text":"<p>List commonly used CelesTrak satellite groups.</p> <p>Syntax: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p> <p>Examples: <pre><code>brahe datasets celestrak list-groups\n</code></pre> Output: <pre><code>Common CelesTrak Satellite Groups\n\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Group Name           \u2503 Description                                         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 active               \u2502 All active satellites                               \u2502\n\u2502 stations             \u2502 Space stations (ISS, Tiangong, etc.)                \u2502\n\u2502 last-30-days         \u2502 Satellites launched in the last 30 days             \u2502\n\u2502 gnss                 \u2502 All GNSS satellites (GPS, Galileo, GLONASS, Beidou) \u2502\n\u2502 gps-ops              \u2502 Operational GPS satellites                          \u2502\n\u2502 galileo              \u2502 Galileo navigation satellites                       \u2502\n\u2502 beidou               \u2502 Beidou navigation satellites                        \u2502\n\u2502 glo-ops              \u2502 Operational GLONASS satellites                      \u2502\n\u2502 geo                  \u2502 Geostationary satellites                            \u2502\n\u2502 gpz                  \u2502 Geostationary protected zone satellites             \u2502\n\u2502 gpz-plus             \u2502 Geostationary protected zone plus satellites        \u2502\n\u2502 weather              \u2502 Weather satellites                                  \u2502\n\u2502 noaa                 \u2502 NOAA satellites                                     \u2502\n\u2502 goes                 \u2502 GOES weather satellites                             \u2502\n\u2502 starlink             \u2502 SpaceX Starlink constellation                       \u2502\n\u2502 oneweb               \u2502 OneWeb constellation                                \u2502\n\u2502 kuiper               \u2502 Amazon Kuiper constellation                         \u2502\n\u2502 qianfan              \u2502 Qianfan constellation                               \u2502\n\u2502 hulianwang           \u2502 Hulianwang constellation                            \u2502\n\u2502 planet               \u2502 Planet Labs imaging satellites                      \u2502\n\u2502 iridium              \u2502 Iridium constellation                               \u2502\n\u2502 iridium-NEXT         \u2502 Iridium NEXT constellation                          \u2502\n\u2502 intelsat             \u2502 Intelsat satellites                                 \u2502\n\u2502 eutelsat             \u2502 Eutelsat satellites                                 \u2502\n\u2502 ses                  \u2502 SES satellites                                      \u2502\n\u2502 orbcomm              \u2502 Orbcomm satellites                                  \u2502\n\u2502 globalstar           \u2502 Globalstar satellites                               \u2502\n\u2502 sarsat               \u2502 Search and rescue satellites                        \u2502\n\u2502 cubesat              \u2502 CubeSats                                            \u2502\n\u2502 amateur              \u2502 Amateur radio satellites                            \u2502\n\u2502 science              \u2502 Science satellites                                  \u2502\n\u2502 weather              \u2502 Weather satellites                                  \u2502\n\u2502 geodetic             \u2502 Geodetic satellites                                 \u2502\n\u2502 cosmos-2251-debris   \u2502 Debris from Cosmos 2251 collision                   \u2502\n\u2502 iridium-33-debris    \u2502 Debris from Iridium 33 collision                    \u2502\n\u2502 fengyun-1c-debris    \u2502 Debris from Fengyun-1C ASAT test                    \u2502\n\u2502 cosmos-1408-debris   \u2502 Debris from Cosmos 1408 ASAT test                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-search","title":"<code>celestrak search</code>","text":"<p>Search for satellites by name pattern within a group.</p> <p>Syntax: <pre><code>brahe datasets celestrak search &lt;PATTERN&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PATTERN</code> - Name search pattern (case-insensitive)</p> <p>Options: - <code>--group &lt;name&gt;</code> - Satellite group to search (default: \"active\") - <code>--table, -t</code> - Display results as table - <code>--columns &lt;preset&gt;</code> - Columns to display: 'minimal', 'default', 'all', or comma-separated list</p> <p>Examples:</p> <p>Search for Capella satellites: <pre><code>brahe datasets celestrak search \"Capella\"\n</code></pre> Output: <pre><code># CAPELLA-11 (ACADIA-1) (NORAD: 57693)\n# CAPELLA-14 (ACADIA-4) (NORAD: 59444)\n# CAPELLA-13 (ACADIA-3) (NORAD: 60419)\n# CAPELLA-15 (ACADIA-5) (NORAD: 60544)\n# CAPELLA-17 (ACADIA-7) (NORAD: 64583)\n# CAPELLA-16 (ACADIA-6) (NORAD: 65318)\n</code></pre></p> <p>Search for GPS satellites in specific group: <pre><code>brahe datasets celestrak search \"GPS II\" --group gps-ops\n</code></pre> Output: <pre><code># GPS BIIR-2  (PRN 13) (NORAD: 24876)\n# GPS BIIR-4  (PRN 20) (NORAD: 26360)\n# GPS BIIR-5  (PRN 22) (NORAD: 26407)\n# GPS BIIR-8  (PRN 16) (NORAD: 27663)\n# GPS BIIR-11 (PRN 19) (NORAD: 28190)\n# GPS BIIR-13 (PRN 02) (NORAD: 28474)\n# GPS BIIRM-1 (PRN 17) (NORAD: 28874)\n# GPS BIIRM-2 (PRN 31) (NORAD: 29486)\n# GPS BIIRM-3 (PRN 12) (NORAD: 29601)\n# GPS BIIRM-4 (PRN 15) (NORAD: 32260)\n# GPS BIIRM-5 (PRN 29) (NORAD: 32384)\n# GPS BIIRM-6 (PRN 07) (NORAD: 32711)\n# GPS BIIRM-8 (PRN 05) (NORAD: 35752)\n</code></pre></p> <p>Search with table output: <pre><code>brahe datasets celestrak search \"CAPELLA\" --group active --table\n</code></pre> Output: <pre><code># \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n# \u2503 Name               \u2503 ID     \u2503 Epoch                \u2503 Age        \u2503 Period (min) \u2503 SMA (km)  \u2503 Ecc      \u2503 Inc (\u00b0) \u2503 RAAN (\u00b0)  \u2503 ArgP (\u00b0)  \u2503 MA (\u00b0)  \u2503\n# \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n# \u2502 CAPELLA-11         \u2502 57693  \u2502 2025-11-02           \u2502 1d 5h 13m  \u2502 97.4         \u2502 7010.7    \u2502 0.000255 \u2502 53.01   \u2502 84.64     \u2502 126.46    \u2502 233.66  \u2502\n# \u2502 (ACADIA-1)         \u2502        \u2502 02:55:32.430 UTC     \u2502 39s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-14         \u2502 59444  \u2502 2025-11-02           \u2502 20h 33m 2s \u2502 95.7         \u2502 6930.2    \u2502 0.000330 \u2502 45.61   \u2502 6.37      \u2502 226.89    \u2502 133.18  \u2502\n# \u2502 (ACADIA-4)         \u2502        \u2502 11:36:09.001 UTC     \u2502            \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-13         \u2502 60419  \u2502 2025-11-01           \u2502 1d 23h 48m \u2502 96.8         \u2502 6983.4    \u2502 0.000158 \u2502 53.00   \u2502 332.08    \u2502 93.30     \u2502 266.82  \u2502\n# \u2502 (ACADIA-3)         \u2502        \u2502 08:20:23.000 UTC     \u2502 48s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-15         \u2502 60544  \u2502 2025-11-01           \u2502 2d 4h 11m  \u2502 96.5         \u2502 6968.5    \u2502 0.000478 \u2502 97.70   \u2502 18.46     \u2502 121.04    \u2502 239.13  \u2502\n# \u2502 (ACADIA-5)         \u2502        \u2502 03:57:45.954 UTC     \u2502 25s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-17         \u2502 64583  \u2502 2025-11-02           \u2502 1d 31m 29s \u2502 96.4         \u2502 6963.2    \u2502 0.000327 \u2502 97.76   \u2502 58.71     \u2502 21.22     \u2502 338.91  \u2502\n# \u2502 (ACADIA-7)         \u2502        \u2502 07:37:41.806 UTC     \u2502            \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2502 CAPELLA-16         \u2502 65318  \u2502 2025-11-02           \u2502 1d 3h 57m  \u2502 96.6         \u2502 6973.1    \u2502 0.000296 \u2502 97.76   \u2502 19.81     \u2502 275.26    \u2502 84.83   \u2502\n# \u2502 (ACADIA-6)         \u2502        \u2502 04:11:12.548 UTC     \u2502 58s        \u2502              \u2502           \u2502          \u2502         \u2502           \u2502           \u2502         \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"learn/cli/datasets.html#ground-station-commands","title":"Ground Station Commands","text":""},{"location":"learn/cli/datasets.html#groundstations-list-providers","title":"<code>groundstations list-providers</code>","text":"<p>List available ground station providers.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-providers\n</code></pre></p> <p>Examples: <pre><code>brahe datasets groundstations list-providers\n</code></pre> Output: <pre><code># Available groundstation providers:\n#   - atlas\n#   - aws\n#   - ksat\n#   - leaf\n#   - ssc\n#   - viasat\n</code></pre></p>"},{"location":"learn/cli/datasets.html#groundstations-list-stations","title":"<code>groundstations list-stations</code>","text":"<p>List ground stations, optionally filtered by provider.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-stations [OPTIONS]\n</code></pre></p> <p>Options: - <code>--provider &lt;name&gt;</code> - Filter by provider name</p> <p>Examples:</p> <p>List all ground stations: <pre><code>brahe datasets groundstations list-stations\n</code></pre> Output: <pre><code># All Groundstations (96 total):\n#   Absheron: 40.470\u00b0 lat, 49.490\u00b0 lon, 0 m alt [S, X]\n#   Accra: 5.600\u00b0 lat, -0.300\u00b0 lon, 0 m alt [L, S, X, Ka]\n</code></pre></p> <p>List KSAT stations only: <pre><code>brahe datasets groundstations list-stations --provider ksat\n</code></pre> Output: <pre><code># KSAT Groundstations (36 total):\n#   Athens: 37.850\u00b0 lat, 22.620\u00b0 lon, 0 m alt [S, X, Optical]\n#   Awarua: -46.530\u00b0 lat, 168.380\u00b0 lon, 0 m alt [S, X, Ka]\n</code></pre></p>"},{"location":"learn/cli/datasets.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak - Official TLE data source</li> <li>Two-Line Elements - Understanding Two-Line Elements</li> <li>SGP Propagation - TLE-based orbit propagation</li> <li>Access CLI - Compute satellite passes (uses TLE data)</li> <li>Datasets API - Python dataset functions</li> </ul>"},{"location":"learn/cli/eop.html","title":"EOP Commands","text":"<p>The <code>eop</code> command group provides access to Earth Orientation Parameters (EOP) data from IERS (International Earth Rotation and Reference Systems Service). EOP data is required for accurate transformations between ECI and ECEF reference frames.</p>"},{"location":"learn/cli/eop.html#commands","title":"Commands","text":""},{"location":"learn/cli/eop.html#download","title":"<code>download</code>","text":"<p>Download EOP data from IERS and save to file.</p> <p>Syntax: <pre><code>brahe eop download &lt;FILEPATH&gt; --product &lt;PRODUCT&gt;\n</code></pre></p> <p>Arguments: - <code>FILEPATH</code> - Output file path for EOP data</p> <p>Options: - <code>--product [standard|c04]</code> - Data product type (required)   - <code>standard</code> - Standard rapid EOP data (daily updates, ~1 year of predictions)   - <code>c04</code> - EOP 14 C04 long-term series (high accuracy, historical)</p> <p>Examples:</p> <p>Download standard EOP data: <pre><code>brahe eop download ~/.cache/brahe/eop/iau2000_standard.txt --product standard\n</code></pre></p> <p>Download C04 long-term series: <pre><code>brahe eop download ~/.cache/brahe/eop/iau2000_c04_20.txt --product c04\n</code></pre></p> <p>Update local EOP file: <pre><code>brahe eop download /path/to/eop_data.txt --product standard\n</code></pre></p> <p>Tip</p> <p>It's usually not necessary to manually download EOP data. If you are using a caching file provider, the package data will automatically download and cache EOP data as needed.</p>"},{"location":"learn/cli/eop.html#get-utc-ut1","title":"<code>get-utc-ut1</code>","text":"<p>Get the UTC-UT1 offset (\u0394UT1) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-utc-ut1 &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get \u0394UT1 for a specific date: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\"\n# 0.0087837\n</code></pre></p> <p>Use custom EOP file: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --source file --filepath /path/to/eop.txt\n</code></pre></p> <p>Use C04 product: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --product c04\n# 0.0087572\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-polar-motion","title":"<code>get-polar-motion</code>","text":"<p>Get polar motion parameters (x_p, y_p) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-polar-motion &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get polar motion parameters: <pre><code>brahe eop get-polar-motion \"2024-01-01T00:00:00Z\"\n# 6.63768107080688e-07, 9.802447818353709e-07\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-cip-offset","title":"<code>get-cip-offset</code>","text":"<p>Get Celestial Intermediate Pole (CIP) offset (dX, dY) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-cip-offset &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get CIP offset: <pre><code>brahe eop get-cip-offset \"2024-01-01T00:00:00Z\"\n# 1.4302003592731312e-09, -4.6057299705405924e-10\n</code></pre></p>"},{"location":"learn/cli/eop.html#get-lod","title":"<code>get-lod</code>","text":"<p>Get Length of Day (LOD) variation at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-lod &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get LOD variation: <pre><code>brahe eop get-lod \"2024-01-01T00:00:00Z\"\n# 0.00023750000000000003\n</code></pre></p>"},{"location":"learn/cli/eop.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - Conceptual overview</li> <li>Reference Frames - ECI/ECEF transformations</li> <li>Transform CLI - Frame transformations (use EOP)</li> <li>Time CLI - UT1 time system</li> <li>EOP API - Python EOP provider classes</li> </ul>"},{"location":"learn/cli/orbits.html","title":"Orbits Commands","text":"<p>The <code>orbits</code> command group provides calculations for: - Orbital period and semi-major axis - Mean motion - Anomaly conversions (mean, eccentric, true) - Sun-synchronous orbit design - Perigee and apogee velocities</p> <p>All commands support constant expressions (e.g., <code>R_EARTH+500e3</code>).</p>"},{"location":"learn/cli/orbits.html#commands","title":"Commands","text":""},{"location":"learn/cli/orbits.html#orbital-period","title":"<code>orbital-period</code>","text":"<p>Calculate the orbital period from semi-major axis.</p> <p>Syntax: <pre><code>brahe orbits orbital-period &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--units [seconds|minutes|hours|days|years]</code> - Output time units (default: <code>seconds</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>LEO orbit period (500km altitude): <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code># 5676.977164\n</code></pre> (Period: ~94.6 minutes)</p> <p>With different units: <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n</code></pre> Output: <pre><code># 94.616286\n</code></pre></p> <p>GEO orbit period (should be ~24 hours): <pre><code>brahe orbits orbital-period \"R_EARTH+35786e3\" --units hours\n</code></pre> Output: <pre><code># 23.934441\n</code></pre></p> <p>Moon's orbit (using GM_EARTH): <pre><code>brahe orbits orbital-period 384400e3 --units days\n</code></pre> Output: <pre><code># 27.451894\n</code></pre></p> <p>Mars orbit (using GM_SUN): <pre><code>brahe orbits orbital-period 227.9e9 --gm GM_SUN --units days\n</code></pre> Output: <pre><code># 686.794481\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sma-from-period","title":"<code>sma-from-period</code>","text":"<p>Calculate semi-major axis from orbital period.</p> <p>Syntax: <pre><code>brahe orbits sma-from-period &lt;PERIOD&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PERIOD</code> - Orbital period (supports expressions)</p> <p>Options: - <code>--units [seconds|minutes|hours|days|years]</code> - Input time units (default: <code>seconds</code>) - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Find altitude for 90-minute orbit: <pre><code>brahe orbits sma-from-period 90 --units minutes\n</code></pre> Output: <pre><code># 6652555.699659\n</code></pre> (Semi-major axis: ~6653 km \u2192 altitude ~275 km)</p> <p>Find GEO altitude (24-hour period): <pre><code>brahe orbits sma-from-period 24 --units hours\n</code></pre> Output: <pre><code># 42241095.663660\n</code></pre> (Semi-major axis: ~42164 km \u2192 altitude ~35786 km above Earth surface)</p> <p>Calculate altitude: <pre><code># SMA - R_EARTH = altitude\necho \"scale=2; ($(brahe orbits sma-from-period 90 --units minutes) - 6378137) / 1000\" | bc\n</code></pre> Output: <pre><code># 274.41\n</code></pre></p>"},{"location":"learn/cli/orbits.html#mean-motion","title":"<code>mean-motion</code>","text":"<p>Calculate mean motion (radians per second).</p> <p>Syntax: <pre><code>brahe orbits mean-motion &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean motion for LEO (500km): <pre><code>brahe orbits mean-motion \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code># 0.001107\n</code></pre></p>"},{"location":"learn/cli/orbits.html#anomaly-conversion","title":"<code>anomaly-conversion</code>","text":"<p>Convert between mean, eccentric, and true anomaly.</p> <p>Syntax: <pre><code>brahe orbits anomaly-conversion &lt;ANOMALY&gt; &lt;ECCENTRICITY&gt; &lt;INPUT_ANOMALY&gt; &lt;OUTPUT_ANOMALY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>ANOMALY</code> - Anomaly value to convert (supports expressions) - <code>ECCENTRICITY</code> - Orbital eccentricity (supports expressions) - <code>INPUT_ANOMALY</code> - Input type: <code>mean</code>, <code>eccentric</code>, or <code>true</code> - <code>OUTPUT_ANOMALY</code> - Output type: <code>mean</code>, <code>eccentric</code>, or <code>true</code></p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Use degrees (default: <code>--no-as-degrees</code> = radians) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean anomaly to true anomaly (circular orbit): <pre><code>brahe orbits anomaly-conversion 0.785 0.0 mean true\n</code></pre> Output: <pre><code># 0.785000\n</code></pre> (For circular orbit, mean = eccentric = true)</p> <p>Mean to true (eccentric orbit): <pre><code>brahe orbits anomaly-conversion --as-degrees 45.0 0.1 mean true\n</code></pre> Output: <pre><code># 53.849399\n</code></pre></p> <p>True to mean anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 90.0 0.05 true mean\n</code></pre> Output: <pre><code># 84.272810\n</code></pre></p> <p>Eccentric to true anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 60.0 0.2 eccentric true\n</code></pre> Output: <pre><code># 70.528779\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sun-sync-inclination","title":"<code>sun-sync-inclination</code>","text":"<p>Calculate the inclination required for a sun-synchronous orbit.</p> <p>Syntax: <pre><code>brahe orbits sun-sync-inclination &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Output in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Sun-sync inclination for 500km circular orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 97.401744\n</code></pre> (Inclination: ~97.42\u00b0)</p> <p>Sun-sync for 600km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+600e3\" 0.001\n</code></pre> Output: <pre><code># 97.787587\n</code></pre></p> <p>Sun-sync for 800km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+800e3\" 0.0\n</code></pre> Output: <pre><code># 98.603036\n</code></pre></p> <p>Output in radians: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0 --no-as-degrees\n</code></pre> Output: <pre><code># 1.699981\n</code></pre></p>"},{"location":"learn/cli/orbits.html#perigee-velocity","title":"<code>perigee-velocity</code>","text":"<p>Calculate orbital velocity at perigee (closest approach).</p> <p>Syntax: <pre><code>brahe orbits perigee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit velocity (500km): <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 7612.608558\n</code></pre></p> <p>Eccentric orbit perigee velocity: <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code># 8416.055421\n</code></pre></p> <p>GTO perigee velocity (highly eccentric): <pre><code>brahe orbits perigee-velocity \"R_EARTH+24000e3\" 0.73\n</code></pre> Output: <pre><code># 9169.158794\n</code></pre></p>"},{"location":"learn/cli/orbits.html#apogee-velocity","title":"<code>apogee-velocity</code>","text":"<p>Calculate orbital velocity at apogee (farthest point).</p> <p>Syntax: <pre><code>brahe orbits apogee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit (apogee = perigee): <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code># 7612.608558\n</code></pre></p> <p>Eccentric orbit apogee velocity: <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code># 6885.863526\n</code></pre> (Lower velocity at apogee)</p> <p>Compare perigee vs apogee: <pre><code>echo \"Perigee: $(brahe orbits perigee-velocity 'R_EARTH+500e3' 0.1) m/s\"\necho \"Apogee:  $(brahe orbits apogee-velocity 'R_EARTH+500e3' 0.1) m/s\"\n</code></pre> Output: <pre><code># Perigee: 8416.055421 m/s\n# Apogee:  6885.863526 m/s\n</code></pre></p>"},{"location":"learn/cli/orbits.html#see-also","title":"See Also","text":"<ul> <li>Anomaly Conversions - True, eccentric, and mean anomaly conversions</li> <li>Orbital Properties - Orbital period, sun-synchronous inclination, etc.</li> <li>Orbits API - Python orbital mechanics functions</li> <li>Transform CLI - Coordinate conversions</li> <li>Constants - Physical constants for calculations</li> </ul>"},{"location":"learn/cli/time.html","title":"Time Commands","text":"<p>The <code>time</code> command group provides: - Conversion between time formats (MJD, JD, ISO-8601, GPS) - Conversion between time systems (UTC, TAI, GPS, UT1, TT) - Time arithmetic (adding/subtracting durations) - Time range generation</p>"},{"location":"learn/cli/time.html#commands","title":"Commands","text":""},{"location":"learn/cli/time.html#convert","title":"<code>convert</code>","text":"<p>Convert between time formats and time systems.</p> <p>Syntax: <pre><code>brahe time convert &lt;EPOCH&gt; &lt;INPUT_FORMAT&gt; &lt;OUTPUT_FORMAT&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Time value to convert - <code>INPUT_FORMAT</code> - Format of input: <code>mjd</code>, <code>jd</code>, <code>string</code>, <code>gps_date</code>, <code>gps_nanoseconds</code> - <code>OUTPUT_FORMAT</code> - Desired output format (same options as input)</p> <p>Options: - <code>--input-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of input - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of output</p> <p>Examples:</p> <p>Convert ISO-8601 string to Modified Julian Date: <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string mjd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code># 60310.0\n</code></pre></p> <p>Convert MJD to Julian Date: <pre><code>brahe time convert 60310.0 mjd jd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code># 2460310.5\n</code></pre></p> <p>Convert between time systems (UTC to TAI): <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string string --input-time-system UTC --output-time-system TAI\n</code></pre> Output: <pre><code># 2024-01-01 00:00:37.000 TAI\n</code></pre></p> <p>Convert GPS time to UTC: <pre><code>brahe time convert \"1356998418000000000\" gps_nanoseconds string --output-time-system UTC\n</code></pre> Output: <pre><code># 2023-01-06 00:00:00.000 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#add","title":"<code>add</code>","text":"<p>Add a time offset to an epoch.</p> <p>Syntax: <pre><code>brahe time add &lt;EPOCH&gt; &lt;SECONDS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Starting epoch (ISO-8601 string, MJD, or JD) - <code>SECONDS</code> - Number of seconds to add (can be negative)</p> <p>Options: - <code>--output-format [mjd|jd|string|gps_date|gps_nanoseconds]</code> - Output format (default: <code>string</code>) - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Output time system (default: <code>UTC</code>)</p> <p>Examples:</p> <p>Add 1 hour (3600 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 3600\n</code></pre> Output: <pre><code># 2024-01-01 01:00:00.000 UTC\n</code></pre></p> <p>Add 1 day (86400 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400\n</code></pre> Output: <pre><code># 2024-01-02 00:00:00.000 UTC\n</code></pre></p> <p>Subtract 30 minutes (negative seconds): <pre><code>brahe time add \"2024-01-01T12:00:00Z\" -- -1800\n</code></pre> Output: <pre><code># 2024-01-01 11:30:00.000 UTC\n</code></pre></p> <p>Output as MJD: <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400 --output-format mjd\n</code></pre> Output: <pre><code># 60311.0\n</code></pre></p>"},{"location":"learn/cli/time.html#time-system-offset","title":"<code>time-system-offset</code>","text":"<p>Calculate the offset between two time systems at a given epoch.</p> <p>Syntax: <pre><code>brahe time time-system-offset &lt;EPOCH&gt; &lt;SOURCE&gt; &lt;TARGET&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to calculate offset at (ISO-8601 string) - <code>SOURCE</code> - Source time system: <code>UTC</code>, <code>GPS</code>, <code>TAI</code>, <code>UT1</code>, <code>TT</code> - <code>TARGET</code> - Target time system (same options)</p> <p>Examples:</p> <p>UTC to TAI offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" UTC TAI\n</code></pre> Output: <pre><code># 37.0\n</code></pre> (TAI is 37 seconds ahead of UTC in 2024)</p> <p>GPS to UTC offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" GPS UTC\n</code></pre> Output: <pre><code># -18.0\n</code></pre></p> <p>TAI to TT offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" TAI TT\n</code></pre> Output: <pre><code># 32.184\n</code></pre></p>"},{"location":"learn/cli/time.html#range","title":"<code>range</code>","text":"<p>Generate a sequence of epochs over a time range.</p> <p>Syntax: <pre><code>brahe time range &lt;EPOCH_START&gt; &lt;EPOCH_END&gt; &lt;STEP&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH_START</code> - Start of time range (ISO-8601 string) - <code>EPOCH_END</code> - End of time range (ISO-8601 string) - <code>STEP</code> - Step size in seconds</p> <p>Examples:</p> <p>Generate epochs every 30 minutes for 1 hour: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-01T01:00:00Z\" 1800\n</code></pre> Output: <pre><code># 2024-01-01 00:00:00.000 UTC\n# 2024-01-01 00:30:00.000 UTC\n</code></pre></p> <p>Generate epochs every 6 hours for 1 day: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-02T00:00:00Z\" 21600\n</code></pre> Output: <pre><code># 2024-01-01 00:00:00.000 UTC\n# 2024-01-01 06:00:00.000 UTC\n# 2024-01-01 12:00:00.000 UTC\n# 2024-01-01 18:00:00.000 UTC\n</code></pre></p> <p>Generate epochs every minute for 5 minutes: <pre><code>brahe time range \"2024-01-01T12:00:00Z\" \"2024-01-01T12:05:00Z\" 60\n</code></pre> Output: <pre><code># 2024-01-01 12:00:00.000 UTC\n# 2024-01-01 12:01:00.000 UTC\n# 2024-01-01 12:02:00.000 UTC\n# 2024-01-01 12:03:00.000 UTC\n# 2024-01-01 12:04:00.000 UTC\n# 2024-01-01 12:05:00.000 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#time-systems","title":"Time Systems","text":""},{"location":"learn/cli/time.html#utc-coordinated-universal-time","title":"UTC (Coordinated Universal Time)","text":"<ul> <li>Civil time standard</li> <li>Includes leap seconds</li> <li>Most common for human-readable timestamps</li> </ul>"},{"location":"learn/cli/time.html#tai-international-atomic-time","title":"TAI (International Atomic Time)","text":"<ul> <li>Continuous atomic time scale</li> <li>No leap seconds</li> <li>Ahead of UTC by IERS-defined leap seconds (37s as of 2024)</li> </ul>"},{"location":"learn/cli/time.html#gps-global-positioning-system-time","title":"GPS (Global Positioning System Time)","text":"<ul> <li>Used by GPS satellites</li> <li>Started at 1980-01-06 00:00:00 UTC</li> <li>19 seconds behind TAI (fixed offset)</li> </ul>"},{"location":"learn/cli/time.html#ut1-universal-time-1","title":"UT1 (Universal Time 1)","text":"<ul> <li>Based on Earth's rotation</li> <li>Irregular due to Earth rotation variations</li> <li>Requires Earth Orientation Parameters (EOP)</li> </ul>"},{"location":"learn/cli/time.html#tt-terrestrial-time","title":"TT (Terrestrial Time)","text":"<ul> <li>Ideal time for Earth-based observations</li> <li>Always 32.184 seconds ahead of TAI</li> </ul>"},{"location":"learn/cli/time.html#offset-relationships","title":"Offset Relationships","text":"<pre><code>TT  = TAI + 32.184s\nTAI = GPS + 19s\nTAI = UTC + (leap seconds, currently 37s)\nUT1 = UTC + (DUT1, from EOP data)\n</code></pre>"},{"location":"learn/cli/time.html#time-formats","title":"Time Formats","text":""},{"location":"learn/cli/time.html#iso-8601-string-string","title":"ISO-8601 String (<code>string</code>)","text":"<p>Human-readable format with timezone: <pre><code>2024-01-01T00:00:00Z\n2024-12-31T23:59:59.123Z\n</code></pre></p>"},{"location":"learn/cli/time.html#modified-julian-date-mjd","title":"Modified Julian Date (<code>mjd</code>)","text":"<p>Days since 1858-11-17 00:00:00 UTC: <pre><code>60310.0         # 2024-01-01 00:00:00 UTC\n60310.5         # 2024-01-01 12:00:00 UTC\n60310.25        # 2024-01-01 06:00:00 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#julian-date-jd","title":"Julian Date (<code>jd</code>)","text":"<p>Days since -4712-01-01 12:00:00 UTC: <pre><code>2460310.5       # 2024-01-01 00:00:00 UTC\n2460311.0       # 2024-01-01 12:00:00 UTC\n</code></pre></p> <p>Relationship: <code>JD = MJD + 2400000.5</code></p>"},{"location":"learn/cli/time.html#gps-date-gps_date","title":"GPS Date (<code>gps_date</code>)","text":"<p>GPS week number and seconds: <pre><code>2295:0.0        # GPS Week 2295, 0 seconds\n</code></pre></p>"},{"location":"learn/cli/time.html#gps-nanoseconds-gps_nanoseconds","title":"GPS Nanoseconds (<code>gps_nanoseconds</code>)","text":"<p>Nanoseconds since GPS epoch (1980-01-06 00:00:00 UTC): <pre><code>1356998418000000000\n</code></pre></p>"},{"location":"learn/cli/time.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - EOP and UT1</li> <li>Epoch API - Python Epoch class</li> <li>EOP CLI - Earth Orientation Parameters</li> <li>Transform CLI - Coordinate transformations (require epochs)</li> </ul>"},{"location":"learn/cli/transform.html","title":"Transform Commands","text":"<p>Convert between coordinate systems and reference frames.</p>"},{"location":"learn/cli/transform.html#overview","title":"Overview","text":"<p>The <code>transform</code> command group provides conversions between: - Reference frames: ECI (Earth-Centered Inertial) \u2194 ECEF (Earth-Centered Earth-Fixed) - Coordinate systems: Keplerian, Cartesian, Geodetic, Geocentric - Attitude representations: Quaternions, Euler angles, rotation matrices (planned)</p>"},{"location":"learn/cli/transform.html#commands","title":"Commands","text":""},{"location":"learn/cli/transform.html#frame","title":"<code>frame</code>","text":"<p>Transform state vectors between ECI and ECEF reference frames.</p> <p>Syntax: <pre><code>brahe transform frame &lt;FROM_FRAME&gt; &lt;TO_FRAME&gt; &lt;EPOCH&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;vx&gt; &lt;vy&gt; &lt;vz&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>FROM_FRAME</code> - Source reference frame: <code>ECI</code> or <code>ECEF</code> - <code>TO_FRAME</code> - Target reference frame: <code>ECI</code> or <code>ECEF</code> - <code>EPOCH</code> - Epoch for the transformation (ISO-8601 format with timezone) - <code>x y z vx vy vz</code> - State vector [m, m, m, m/s, m/s, m/s]</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Convert ECI state to ECEF at a specific epoch: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code># [-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Convert ECEF back to ECI: <pre><code>brahe transform frame ECEF ECI \"2024-01-01T00:00:00Z\" -- -1176064.179 -6776827.197 15961.825 6895.377 -1196.637 0.241\n</code></pre> Output: <pre><code># [6878137.000016, 0.000312, -0.000213, 0.000018, 7500.000440, 0.000398]\n</code></pre></p> <p>Low-precision output: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T12:00:00Z\" 6878137 0 0 0 7500 0 --format .2f\n</code></pre> Output: <pre><code># [1234308.01, 6766461.20, 15974.24, -6884.83, 1255.90, 0.25]\n</code></pre></p>"},{"location":"learn/cli/transform.html#coordinates","title":"<code>coordinates</code>","text":"<p>Convert between coordinate system representations.</p> <p>Syntax: <pre><code>brahe transform coordinates [OPTIONS] &lt;FROM_SYSTEM&gt; &lt;TO_SYSTEM&gt; &lt;EPOCH&gt; &lt;x1&gt; &lt;x2&gt; &lt;x3&gt; &lt;x4&gt; &lt;x5&gt; &lt;x6&gt;\n</code></pre></p> <p>Arguments: - <code>FROM_SYSTEM</code> - Source coordinate system (see below) - <code>TO_SYSTEM</code> - Target coordinate system (see below) - <code>EPOCH</code> - Epoch (ISO-8601 format). Use <code>\"\"</code> if not needed for the conversion - <code>x1 x2 x3 x4 x5 x6</code> - Coordinate values (interpretation depends on system)</p> <p>Coordinate Systems: - <code>keplerian</code> - Keplerian orbital elements [a, e, i, \u03a9, \u03c9, \u03bd] - <code>cartesian</code> - Cartesian state [x, y, z, vx, vy, vz] - <code>geodetic</code> - Geodetic coordinates [lon, lat, alt, 0, 0, 0] - <code>geocentric</code> - Geocentric spherical [lat, lon, radius, 0, 0, 0]</p> <p>Options: - <code>--from-frame [ECI|ECEF]</code> - Reference frame for cartesian input (default: <code>ECI</code>) - <code>--to-frame [ECI|ECEF]</code> - Reference frame for cartesian output (default: <code>ECI</code>) - <code>--as-degrees / --no-as-degrees</code> - Interpret/output angles in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p>"},{"location":"learn/cli/transform.html#keplerian-to-cartesian-eci","title":"Keplerian to Cartesian (ECI)","text":"<p>Convert orbital elements to ECI state (no epoch required): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre> Output: <pre><code># [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055]\n</code></pre></p> <p>With different true anomaly (45\u00b0): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 45 --as-degrees\n</code></pre> Output: <pre><code># [4853256.459155, -660529.749078, 4821984.763637, -5390.543500, -730.545720, 5333.113819]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-to-keplerian","title":"Cartesian to Keplerian","text":"<p>Convert ECI state back to orbital elements: <pre><code>brahe transform coordinates --as-degrees cartesian keplerian \"\" -- 6871258.863 0.0 0.0 0.0 -1034.183 7549.721\n</code></pre> Output: <pre><code># [6878136.866355, 0.001000, 97.799999, 0.000000, 0.000000, 0.000000]\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-to-cartesian-ecef","title":"Geodetic to Cartesian (ECEF)","text":"<p>Convert geodetic coordinates (New York City) to ECEF: <pre><code>brahe transform coordinates --as-degrees --to-frame ECEF geodetic cartesian \"\" 286.0060 40.7128 10 0 0 0\n</code></pre> Output: <pre><code># [1334224.912305, -4651969.287142, 4140677.827068]\n</code></pre></p> <p>Note: Order is [lon, lat, alt]. Longitude 286\u00b0 = -74\u00b0 (use positive east longitude, or handle negative with <code>--</code>)</p>"},{"location":"learn/cli/transform.html#ecef-cartesian-to-geodetic","title":"ECEF Cartesian to Geodetic","text":"<p><pre><code>brahe transform coordinates --as-degrees --from-frame ECEF cartesian geodetic \"2024-01-01T00:00:00Z\" 1334915.0 4652372.0 4075345.0 0 0 0\n</code></pre> Output: <pre><code># [73.990114, 40.288227, -41917.492259]\n</code></pre></p>"},{"location":"learn/cli/transform.html#keplerian-to-geodetic-via-ecef","title":"Keplerian to Geodetic (via ECEF)","text":"<p>Convert satellite orbital elements to ground track position at epoch: <pre><code># First to cartesian ECI, then specify ECEF and geodetic\nbrahe transform coordinates --as-degrees --to-frame ECEF keplerian geodetic \"2024-01-01T00:00:00Z\" 6878137 0.001 97.8 0 0 0\n</code></pre> Output: <pre><code># [-99.845171, 0.133796, 493121.978692]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eci-to-ecef-frame-change","title":"Cartesian ECI to ECEF (frame change)","text":"<p><pre><code>brahe transform coordinates --from-frame ECI --to-frame ECEF cartesian cartesian \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code># [-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Alternative: Use <code>brahe transform frame</code> for dedicated ECI\u2194ECEF transformations.</p>"},{"location":"learn/cli/transform.html#coordinate-system-details","title":"Coordinate System Details","text":""},{"location":"learn/cli/transform.html#keplerian-elements","title":"Keplerian Elements","text":"<p>Format: <code>[a, e, i, \u03a9, \u03c9, M]</code></p> <ul> <li><code>a</code> - Semi-major axis (meters)</li> <li><code>e</code> - Eccentricity (dimensionless, 0 \u2264 e &lt; 1)</li> <li><code>i</code> - Inclination (degrees or radians)</li> <li><code>\u03a9</code> - Right Ascension of Ascending Node / RAAN (degrees or radians)</li> <li><code>\u03c9</code> - Argument of periapsis (degrees or radians)</li> <li><code>M</code> - Mean anomaly (degrees or radians)</li> </ul> <p>Standard orbits: - LEO (500km): <code>a = R_EARTH + 500e3 = 6878137 m</code> - GEO (35786km): <code>a = R_EARTH + 35786e3 = 42164137 m</code> - SSO inclination: ~97.8\u00b0 (for 500km altitude)</p> <p>Example: <pre><code># Sun-synchronous orbit, 500km altitude, 97.8\u00b0 inclination\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre> Output: <pre><code># [6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eciecef","title":"Cartesian (ECI/ECEF)","text":"<p>Format: <code>[x, y, z, vx, vy, vz]</code></p> <ul> <li><code>x, y, z</code> - Position (meters)</li> <li><code>vx, vy, vz</code> - Velocity (meters/second)</li> </ul> <p>ECI (Earth-Centered Inertial): - Inertial reference frame - Z-axis aligned with Earth's rotation axis - X-axis points to vernal equinox</p> <p>ECEF (Earth-Centered Earth-Fixed): - Rotating with Earth - Z-axis aligned with Earth's rotation axis - X-axis through 0\u00b0 latitude, 0\u00b0 longitude</p> <p>Example: <pre><code># Circular equatorial orbit in ECI\nbrahe transform coordinates cartesian keplerian \"\" 6878137 0 0 0 7668 0 --as-degrees\n</code></pre> Output: <pre><code># [6980085.332943, 0.014606, 0.000000, 180.000000, 0.000000, 0.000000]\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Format: <code>[lon, lat, alt, 0, 0, 0]</code></p> <ul> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>lat</code> - Geodetic latitude (degrees or radians)</li> <li><code>alt</code> - Altitude above WGS84 ellipsoid (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul> <p>Geodetic vs Geocentric: - Geodetic: Perpendicular to WGS84 ellipsoid - Geocentric: Angle from Earth's center</p>"},{"location":"learn/cli/transform.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Format: <code>[lat, lon, radius, 0, 0, 0]</code></p> <ul> <li><code>lat</code> - Geocentric latitude (degrees or radians)</li> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>radius</code> - Distance from Earth center (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul>"},{"location":"learn/cli/transform.html#see-also","title":"See Also","text":"<ul> <li>Coordinate Systems - Conceptual overview</li> <li>Reference Frames - ECI/ECEF details</li> <li>Coordinates API - Python API</li> <li>Frames API - Frame conversion functions</li> <li>Orbits API - Orbital elements</li> <li>Time CLI - Time conversions</li> <li>Orbits CLI - Orbital mechanics calculations</li> </ul>"},{"location":"learn/coordinates/index.html","title":"Coordinate Transformations","text":"<p>Coordinate systems and transformations are fundamental to astrodynamics. Different coordinate systems are used depending on the application - some are better for orbital mechanics, others for ground station tracking, and still others for describing positions on Earth's surface.</p> <p>Brahe provides coordinate transformation functions for converting between different coordinate representations and reference frames.</p>"},{"location":"learn/coordinates/index.html#coordinate-systems-in-brahe","title":"Coordinate Systems in Brahe","text":""},{"location":"learn/coordinates/index.html#cartesian-state-vectors","title":"Cartesian State Vectors","text":"<p>Cartesian coordinates represent positions and velocities as vectors in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code>. In astrodynamics, these are typically used to represent the state in Earth-Centered Inertial (ECI) frames or Earth-Centered Earth-Fixed (ECEF) frames. </p> <p>While Cartesian coordinates are mathematically convenient for numerical integration and propagation, orbital elements are often more intuitive for understanding orbits. Therefore, Brahe provides functions to convert between ECI Cartesian states and Keplerian orbital elements.</p> <p>Learn more: Cartesian Transformations</p>"},{"location":"learn/coordinates/index.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Geocentric coordinates use a spherical Earth model to represent positions using longitude, latitude, and altitude from Earth's center: <code>[lon, lat, alt]</code>. Applications generally convert between ECEF Cartesian coordinates and geocentric spherical coordinates.</p> <p>Learn more: Geocentric Transformations</p>"},{"location":"learn/coordinates/index.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Geodetic coordinates use the WGS84 ellipsoid model to represent positions: <code>[lon, lat, alt]</code>. Unlike geocentric coordinates, geodetic coordinates account for Earth's equatorial bulge (flattening), providing much more accurate resulting ECEF Cartesian positions for points on or near Earth's surface. Similar to geocentric coordinates, applications typically convert between ECEF Cartesian coordinates and geodetic coordinates.</p> <p>Learn more: Geodetic Transformations</p>"},{"location":"learn/coordinates/index.html#topocentric-coordinates","title":"Topocentric Coordinates","text":"<p>Topocentric coordinate systems are local horizon-based systems centered on an observer (like a ground station on the Earth). They represent the position of objects relative to the local horizon, tagent to the body's surface.</p> <p>Two of the most common topocentric coodinate systems are the East-North-Zenith (ENZ) or South-East-Zenith (SEZ) systems. These systems are essential for computing satellite visibility, tracking angles (azimuth and elevation), and determining when satellites are observable from a specific location.</p> <p>Learn more: Topocentric Transformations</p>"},{"location":"learn/coordinates/index.html#common-transformation-patterns","title":"Common Transformation Patterns","text":""},{"location":"learn/coordinates/index.html#orbital-mechanics","title":"Orbital Mechanics","text":"<p>To work with orbital elements:</p> <ol> <li>Define or receive Keplerian elements <code>[a, e, i, \u03a9, \u03c9, M]</code></li> <li>Convert to Cartesian state <code>[x, y, z, vx, vy, vz]</code> in ECI frame</li> </ol>"},{"location":"learn/coordinates/index.html#ground-station-observations","title":"Ground Station Observations","text":"<p>To compute satellite location from a ground station:</p> <ol> <li>Start with station location in geodetic coordinates <code>[lon, lat, alt]</code></li> <li>Convert the Satellite ECI positions from to the ECEF frame at the observation time</li> <li>Convert the station location to ECEF coordinates</li> <li>Transform the satellite and location ECEF coordinates to the local ENZ</li> <li>Convert ENZ to azimuth-elevation-range</li> </ol>"},{"location":"learn/coordinates/index.html#see-also","title":"See Also","text":"<ul> <li>Cartesian Transformations - Orbital elements and Cartesian states</li> <li>Geocentric Transformations - Spherical Earth coordinates</li> <li>Geodetic Transformations - WGS84 ellipsoid coordinates</li> <li>Topocentric Transformations - Local horizon systems</li> <li>Coordinates API Reference - Complete API documentation</li> </ul>"},{"location":"learn/coordinates/cartesian_transformations.html","title":"Cartesian \u2194 Orbital Element Transformations","text":"<p>The functions described here convert between Keplerian orbital elements and Cartesian state vectors. While these transformations are part of the \"coordinates\" module, they specifically deal with orbital mechanics - converting between two different coordinate representations of a satellite's orbit.</p> <p>Understanding both representations is essential: Keplerian elements provide intuitive orbital parameters like size, shape, and orientation, while Cartesian states are necessary for numerical orbit propagation and applying perturbations.</p> <p>For complete API details, see the Cartesian Coordinates API Reference.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#orbital-representations","title":"Orbital Representations","text":""},{"location":"learn/coordinates/cartesian_transformations.html#keplerian-orbital-elements","title":"Keplerian Orbital Elements","text":"<p>Keplerian elements describe an orbit using six classical parameters:</p> <ul> <li>\\(a\\): Semi-major axis (meters) - defines the orbit's size</li> <li>\\(e\\): Eccentricity (dimensionless) - defines the orbit's shape (0 = circular, 0 &lt; e &lt; 1 = elliptical)</li> <li>\\(i\\): Inclination (radians or degrees) - tilt of orbital plane relative to equator</li> <li>\\(\\Omega\\): Right ascension of ascending node (radians or degrees) - where orbit crosses equator going north</li> <li>\\(\\omega\\): Argument of periapsis (radians or degrees) - where orbit is closest to Earth</li> <li>\\(M\\): Mean anomaly (radians or degrees) - position of satellite along orbit</li> </ul> <p>In brahe, the combined vector has ordering <code>[a, e, i, \u03a9, \u03c9, M]</code></p> <p>Info</p> <p>Brahe uses mean anomaly as the default anomaly representation for Keplerian elements. Other anomaly types (eccentric, true) can be converted using the anomaly conversion functions in the Orbits module.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#cartesian-state-vectors","title":"Cartesian State Vectors","text":"<p>Cartesian states represent position and velocity in three-dimensional space:</p> <ul> <li>Position: \\([p_x, p_y, p_z]\\) in meters</li> <li>Velocity: \\([v_x, v_y, v_z]\\) in meters per second</li> </ul> <p>In brahe, the state vector is combined as <code>[p_x, p_y, p_z, v_x, v_y, v_z]</code></p> <p>Cartesian states are typically expressed in an inertial reference frame like Earth-Centered Inertial (ECI), where the axes are fixed with respect to the stars rather than rotating with Earth.</p> <p>Info</p> <p>All position and velocity components in Cartesian states are in SI base units (meters and meters per second).</p> <p>They must be in SI base units for inputs and are always returned in SI base units.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#converting-orbital-elements-to-cartesian","title":"Converting Orbital Elements to Cartesian","text":"<p>The most common workflow is to start with intuitive orbital parameters and convert them to Cartesian states for propagation.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#using-degrees","title":"Using Degrees","text":"<p>When working with human-readable orbital parameters, degrees are more intuitive:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n# LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\noe_deg = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert orbital elements to Cartesian state using degrees\nstate = bh.state_koe_to_eci(oe_deg, bh.AngleFormat.DEGREES)\nprint(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state[0]:.3f}, {state[1]:.3f}, {state[2]:.3f}]\")\nprint(f\"Velocity: [{state[3]:.6f}, {state[4]:.6f}, {state[5]:.6f}]\")\n# Cartesian state  (m, m/s):\n# Position: [1848964.106, -434937.468, 6560410.530]\n# Velocity: [-7098.379734, -2173.344867, 1913.333385]\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n    // LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\n    let oe_deg = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                 // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of periapsis (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Convert orbital elements to Cartesian state using degrees\n    let state = bh::state_koe_to_eci(oe_deg, bh::AngleFormat::Degrees);\n\n    println!(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state[0], state[1], state[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\", state[3], state[4], state[5]);\n    // Cartesian state  (m, m/s):\n    // Position: [1848964.106, -434937.468, 6560410.530]\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385]\n}\n</code></pre>"},{"location":"learn/coordinates/cartesian_transformations.html#using-radians","title":"Using Radians","text":"<p>For mathematical consistency or when working with data already in radians:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nfrom math import pi\n\nbh.initialize_eop()\n\n# Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and degrees\n# LEO satellite: 500 km altitude, 97.8\u00b0 inclination (~sun-synchronous)\noe_deg = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        pi / 4,  # Inclination (rad)\n        pi / 8,  # Right ascension of ascending node (rad)\n        pi / 2,  # Argument of periapsis (rad)\n        3 * pi / 4,  # Mean anomaly (rad)\n    ]\n)\n\n# Convert orbital elements to Cartesian state using degrees\nstate = bh.state_koe_to_eci(oe_deg, bh.AngleFormat.RADIANS)\nprint(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state[0]:.3f}, {state[1]:.3f}, {state[2]:.3f}]\")\nprint(f\"Velocity: [{state[3]:.6f}, {state[4]:.6f}, {state[5]:.6f}]\")\n# Cartesian state  (m, m/s):\n# Position: [-3117582.037, -5092452.343, -3511765.495]\n# Velocity: [6408.435846, -1407.501408, -3752.763969]\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements [a, e, i, \u03a9, \u03c9, M] in meters and radians\n    // LEO satellite: 500 km altitude, 45\u00b0 inclination\n    let oe_rad = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                 // Eccentricity\n        PI/4.0,               // Inclination (rad)\n        PI/8.0,               // Right ascension of ascending node (rad)\n        PI/2.0,               // Argument of periapsis (rad)\n        3.0*PI/4.0            // Mean anomaly (rad)\n    );\n\n    // Convert orbital elements to Cartesian state using radians\n    let state = bh::state_koe_to_eci(oe_rad, bh::AngleFormat::Radians);\n\n    println!(\"Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state[0], state[1], state[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\", state[3], state[4], state[5]);\n    // Cartesian state  (m, m/s):\n    // Position: [-3117582.037, -5092452.343, -3511765.495]\n    // Velocity: [6408.435846, -1407.501408, -3752.763969]\n}\n</code></pre> <p>Info</p> <p>The <code>AngleFormat</code> parameter only affects the three angular elements (i, \u03a9, \u03c9, M). Semi-major axis is always in meters, and eccentricity is always dimensionless.</p>"},{"location":"learn/coordinates/cartesian_transformations.html#converting-cartesian-to-orbital-elements","title":"Converting Cartesian to Orbital Elements","text":"<p>After propagating or receiving Cartesian state data, you often want to convert back to orbital elements for interpretation and analysis.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define Cartesian state vector [px, py, pz, vx, vy, vz] in meters and meters per second\nstate = np.array(\n    [1848964.106, -434937.468, 6560410.530, -7098.379734, -2173.344867, 1913.333385]\n)\n\n# Convert orbital elements to Cartesian state using degrees\noe_deg = bh.state_eci_to_koe(state, bh.AngleFormat.DEGREES)\nprint(\"Osculating state [a, e, i, \u03a9, \u03c9, M] (deg):\")\nprint(f\"Semi-major axis (m): {oe_deg[0]:.3f}\")\nprint(f\"Eccentricity: {oe_deg[1]:.6f}\")\nprint(f\"Inclination (deg): {oe_deg[2]:.6f}\")\nprint(f\"RA of ascending node (deg): {oe_deg[3]:.6f}\")\nprint(f\"Argument of periapsis (deg): {oe_deg[4]:.6f}\")\nprint(f\"Mean anomaly (deg): {oe_deg[5]:.6f}\")\n# Osculating state  (deg):\n# Semi-major axis (m): 6878136.299\n# Eccentricity: 0.010000\n# Inclination (deg): 97.800000\n# RA of ascending node (deg): 15.000000\n# Argument of periapsis (deg): 30.000000\n# Mean anomaly (deg): 45.000000\n\n# You can also convert using radians\noe_rad = bh.state_eci_to_koe(state, bh.AngleFormat.RADIANS)\nprint(\"\\nOsculating state [a, e, i, \u03a9, \u03c9, M] (rad):\")\nprint(f\"Semi-major axis (m): {oe_rad[0]:.3f}\")\nprint(f\"Eccentricity: {oe_rad[1]:.6f}\")\nprint(f\"Inclination (rad): {oe_rad[2]:.6f}\")\nprint(f\"RA of ascending node (rad): {oe_rad[3]:.6f}\")\nprint(f\"Argument of periapsis (rad): {oe_rad[4]:.6f}\")\nprint(f\"Mean anomaly (rad): {oe_rad[5]:.6f}\")\n# Osculating state  (rad):\n# Semi-major axis (m): 6878136.299\n# Eccentricity: 0.010000\n# Inclination (rad): 1.706932\n# RA of ascending node (rad): 0.261799\n# Argument of periapsis (rad): 0.523599\n# Mean anomaly (rad): 0.785398\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define Cartesian state vector [px, py, pz, vx, vy, vz] in meters and meters per second\n    let state = na::SVector::&lt;f64, 6&gt;::new(\n        1848964.106,\n        -434937.468,\n        6560410.530,\n        -7098.379734,\n        -2173.344867,\n        1913.333385\n    );\n\n    // Convert Cartesian state to orbital elements using degrees\n    let oe_deg = bh::state_eci_to_koe(state, bh::AngleFormat::Degrees);\n\n    println!(\"Osculating state [a, e, i, \u03a9, \u03c9, M] (deg):\");\n    println!(\"Semi-major axis (m): {:.3}\", oe_deg[0]);\n    println!(\"Eccentricity: {:.6}\", oe_deg[1]);\n    println!(\"Inclination (deg): {:.6}\", oe_deg[2]);\n    println!(\"RA of ascending node (deg): {:.6}\", oe_deg[3]);\n    println!(\"Argument of periapsis (deg): {:.6}\", oe_deg[4]);\n    println!(\"Mean anomaly (deg): {:.6}\", oe_deg[5]);\n    // Osculating state  (deg):\n    // Semi-major axis (m): 6878136.299\n    // Eccentricity: 0.010000\n    // Inclination (deg): 97.800000\n    // RA of ascending node (deg): 15.000000\n    // Argument of periapsis (deg): 30.000000\n    // Mean anomaly (deg): 45.000000\n\n    // You can also convert using radians\n    let oe_rad = bh::state_eci_to_koe(state, bh::AngleFormat::Radians);\n\n    println!(\"\\nOsculating state [a, e, i, \u03a9, \u03c9, M] (rad):\");\n    println!(\"Semi-major axis (m): {:.3}\", oe_rad[0]);\n    println!(\"Eccentricity: {:.6}\", oe_rad[1]);\n    println!(\"Inclination (rad): {:.6}\", oe_rad[2]);\n    println!(\"RA of ascending node (rad): {:.6}\", oe_rad[3]);\n    println!(\"Argument of periapsis (rad): {:.6}\", oe_rad[4]);\n    println!(\"Mean anomaly (rad): {:.6}\", oe_rad[5]);\n    // Osculating state  (rad):\n    // Semi-major axis (m): 6878136.299\n    // Eccentricity: 0.010000\n    // Inclination (rad): 1.706932\n    // RA of ascending node (rad): 0.261799\n    // Argument of periapsis (rad): 0.523599\n    // Mean anomaly (rad): 0.785398\n}\n</code></pre>"},{"location":"learn/coordinates/cartesian_transformations.html#see-also","title":"See Also","text":"<ul> <li>Cartesian Coordinates API Reference - Complete function documentation</li> <li>Orbital Mechanics - Related orbital mechanics functions</li> <li>Anomaly Conversions - Converting between mean, eccentric, and true anomaly</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html","title":"Geocentric Transformations","text":"<p>Geocentric longitude, latitude, altitude coordinates represent positions relative to a spherical Earth's surface. These coordinates can be converted to and from Earth-Centered Earth-Fixed (ECEF) Cartesian coordinates. This coordinate system is simpler and computationally faster than the geodetic system, but less accurate for near-surface applications because it assumes Earth is a perfect sphere.</p> <p>For complete API details, see the Geocentric Coordinates API Reference.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#geocentric-coordinate-system","title":"Geocentric Coordinate System","text":"<p>Geocentric coordinates represent a position using:</p> <ul> <li>Longitude (\\(\\lambda\\)): East-west angle from the prime meridian, in degrees [-180\u00b0, +180\u00b0] or radians \\([-\\pi, +\\pi]\\)</li> <li>Latitude (\\(\\varphi\\)): North-south angle from the equatorial plane, in degrees [-90\u00b0, +90\u00b0] or radians \\([-\\frac{\\pi}{2}, +\\frac{\\pi}{2}]\\)</li> <li>Altitude (\\(h\\)): Height above the spherical Earth surface, in meters</li> </ul> <p>Combined as: <code>[longitude, latitude, altitude]</code>, often abbreviated as <code>[lon, lat, alt]</code>.</p> <p>Info</p> <p>The spherical Earth model uses an Earth radius of <code>6378137.0</code> meters, which is the WGS84 semi-major axis. This means the geocentric \"surface\" is a sphere with Earth's equatorial radius.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#spherical-vs-ellipsoidal-earth","title":"Spherical vs Ellipsoidal Earth","text":"<p>The key difference between geocentric and geodetic coordinates is the Earth model:</p> <ul> <li>Geocentric: Earth is a perfect sphere of radius <code>WGS84_A</code></li> <li>Geodetic: Earth is an ellipsoid (oblate spheroid) with equatorial bulge</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html#converting-geocentric-to-ecef","title":"Converting Geocentric to ECEF","text":"<p>Earth-Centered Earth-Fixed (ECEF) is a Cartesian coordinate system with:</p> <ul> <li>Origin at Earth's center of mass</li> <li>X-axis through the intersection of the prime meridian and equator</li> <li>Z-axis through the North Pole</li> <li>Y-axis completing a right-handed system</li> </ul> <p>You can convert geocentric spherical coordinates to ECEF Cartesian coordinates using following:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a location in geocentric coordinates (spherical Earth model)\n# Boulder, Colorado (approximately)\nlon = -122.4194  # Longitude (deg)\nlat = 37.7749  # Latitude (deg)\nalt = 13.8  # Altitude above spherical Earth surface (m)\n\nprint(\"Geocentric coordinates (spherical Earth model):\")\nprint(f\"Longitude: {lon:.4f}\u00b0 = {np.radians(lon):.6f} rad\")\nprint(f\"Latitude:  {lat:.4f}\u00b0 = {np.radians(lat):.6f} rad\")\nprint(f\"Altitude:  {alt:.1f} m\\n\")\n# Longitude: -122.4194\u00b0 = -2.136622 rad\n# Latitude:  37.7749\u00b0 = 0.659296 rad\n# Altitude:  13.8 m\n\n# Convert geocentric to ECEF Cartesian\ngeocentric = np.array([lon, lat, alt])\necef = bh.position_geocentric_to_ecef(geocentric, bh.AngleFormat.DEGREES)\n\nprint(\"ECEF Cartesian coordinates:\")\nprint(f\"x = {ecef[0]:.3f} m\")\nprint(f\"y = {ecef[1]:.3f} m\")\nprint(f\"z = {ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(ecef):.3f} m\\n\")\n# x = -2702779.686 m\n# y = -4255713.575 m\n# z = 3907005.447 m\n# Distance from Earth center: 6378150.800 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a location in geocentric coordinates (spherical Earth model)\n    // Boulder, Colorado (approximately)\n    let lon = -122.4194_f64;  // Longitude (deg)\n    let lat = 37.7749_f64;    // Latitude (deg)\n    let alt = 13.8;           // Altitude above spherical Earth surface (m)\n\n    println!(\"Geocentric coordinates (spherical Earth model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", lon, lon.to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", lat, lat.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt);\n    // Expected output:\n    // Longitude: -122.4194\u00b0 = -2.136622 rad\n    // Latitude:  37.7749\u00b0 = 0.659296 rad\n    // Altitude:  13.8 m\n\n    // Convert geocentric to ECEF Cartesian\n    let geocentric = na::Vector3::new(lon, lat, alt);\n    let ecef = bh::position_geocentric_to_ecef(geocentric, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"ECEF Cartesian coordinates:\");\n    println!(\"x = {:.3} m\", ecef[0]);\n    println!(\"y = {:.3} m\", ecef[1]);\n    println!(\"z = {:.3} m\", ecef[2]);\n    let distance = (ecef[0].powi(2) + ecef[1].powi(2) + ecef[2].powi(2)).sqrt();\n    println!(\"Distance from Earth center: {:.3} m\", distance);\n    // Expected output:\n    // x = -2702779.686 m\n    // y = -4255713.575 m\n    // z = 3907005.447 m\n    // Distance from Earth center: 6378150.800 m\n}\n</code></pre>"},{"location":"learn/coordinates/geocentric_transformations.html#converting-ecef-to-geocentric","title":"Converting ECEF to Geocentric","text":"<p>The reverse transformation converts Cartesian ECEF coordinates back to geocentric spherical coordinates:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a satellite state (convert orbital elements to ECEF state)\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC)\nstate_oe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.0,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\nstate_ecef = bh.state_eci_to_ecef(\n    epc, bh.state_koe_to_eci(state_oe, bh.AngleFormat.DEGREES)\n)\nprint(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}]\")\nprint(f\"Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}]\\n\")\n# Position: [-735665.465, -1838913.314, 6586801.432]\n# Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n# Convert ECEF Cartesian to geocentric position\necef_pos = state_ecef[0:3]\ngeocentric = bh.position_ecef_to_geocentric(ecef_pos, bh.AngleFormat.DEGREES)\nprint(\"Geocentric coordinates (spherical Earth model):\")\nprint(f\"Longitude: {geocentric[0]:.4f}\u00b0 = {np.radians(geocentric[0]):.6f} rad\")\nprint(f\"Latitude:  {geocentric[1]:.4f}\u00b0 = {np.radians(geocentric[1]):.6f} rad\")\nprint(f\"Altitude:  {geocentric[2]:.1f} m\")\n# Longitude: -111.8041\u00b0 = -1.951350 rad\n# Latitude:  73.2643\u00b0 = 1.278704 rad\n# Altitude:  499999.3 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a satellite state (convert orbital elements to ECEF state)\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let state_oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.0,                  // Eccentricity\n        97.8_f64,             // Inclination (deg)\n        15.0_f64,             // Right ascension of ascending node (deg)\n        30.0_f64,             // Argument of periapsis (deg)\n        45.0_f64              // Mean anomaly (deg)\n    );\n    let state_eci = bh::state_koe_to_eci(state_oe, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Expected output:\n    // Position: [-735665.465, -1838913.314, 6586801.432]\n    // Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n    // Convert ECEF Cartesian to geocentric position\n    let ecef_pos = na::Vector3::new(state_ecef[0], state_ecef[1], state_ecef[2]);\n    let geocentric = bh::position_ecef_to_geocentric(ecef_pos, bh::AngleFormat::Degrees);\n\n    println!(\"Geocentric coordinates (spherical Earth model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", geocentric[0], geocentric[0].to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", geocentric[1], geocentric[1].to_radians());\n    println!(\"Altitude:  {:.1} m\", geocentric[2]);\n    // Expected output:\n    // Longitude: -111.8041\u00b0 = -1.951350 rad\n    // Latitude:  73.2643\u00b0 = 1.278704 rad\n    // Altitude:  499999.3 m\n}\n</code></pre> <p>Info</p> <p>Latitude values are automatically constrained to the valid range [-90\u00b0, +90\u00b0] or [\\(-\\frac{\\pi}{2}\\), \\(+\\frac{\\pi}{2}\\)] during conversion.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Geocentric Coordinates API Reference - Complete function documentation</li> <li>Geodetic Transformations - More accurate WGS84 ellipsoid model</li> <li>Topocentric Transformations - Local horizon coordinate systems</li> </ul>"},{"location":"learn/coordinates/geodetic_transformations.html","title":"Geodetic Transformations","text":"<p>Geodetic longitude, latitude, altitude coordinates represent positions relative to the WGS84 ellipsoidal Earth model. These coordinates can be converted to and from Earth-Centered Earth-Fixed (ECEF) Cartesian coordinates. This coordinate system is more accurate than the geocentric system for near-surface applications because it accounts for Earth's equatorial bulge.</p> <p>For complete API details, see the Geodetic Coordinates API Reference.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#geodetic-coordinate-system","title":"Geodetic Coordinate System","text":"<p>Geodetic coordinates represent a position using:</p> <ul> <li>Longitude (\\(\\lambda\\)): East-west angle from the prime meridian, in degrees [-180\u00b0, +180\u00b0] or radians \\([-\\pi, +\\pi]\\)</li> <li>Latitude (\\(\\varphi\\)): North-south angle from the equatorial plane, measured perpendicular to the ellipsoid surface, in degrees [-90\u00b0, +90\u00b0] or radians [\\(-\\frac{\\pi}{2}\\), \\(+\\frac{\\pi}{2}\\)]</li> <li>Altitude (\\(h\\)): Height above the WGS84 ellipsoid surface, in meters</li> </ul> <p>Combined as: <code>[longitude, latitude, altitude]</code>, often abbreviated as <code>[lon, lat, alt]</code>.</p> <p>Info</p> <p>Geodetic latitude is measured perpendicular to the ellipsoid surface, not from Earth's center. This differs from geocentric latitude, which is measured from the center. For a point on the surface, these can differ by up to 11 arcminutes (about 0.2\u00b0).</p>"},{"location":"learn/coordinates/geodetic_transformations.html#wgs84-ellipsoid-model","title":"WGS84 Ellipsoid Model","text":"<p>The key difference between geodetic and geocentric coordinates is the Earth model:</p> <ul> <li>Geodetic: Earth is an ellipsoid (oblate spheroid) with parameters:<ul> <li>Semi-major axis: <code>WGS84_A = 6378137.0</code> meters (equatorial radius)</li> <li>Flattening: <code>WGS84_F = 1/298.257223563</code></li> </ul> </li> <li>Geocentric: Earth is a perfect sphere of radius <code>WGS84_A</code></li> </ul> <p>The difference between equatorial and polar radii is approximately 21 km, which significantly affects position calculations near Earth's surface.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#converting-geodetic-to-ecef","title":"Converting Geodetic to ECEF","text":"<p>Earth-Centered Earth-Fixed (ECEF) is a Cartesian coordinate system with:</p> <ul> <li>Origin at Earth's center of mass</li> <li>X-axis through the intersection of the prime meridian and equator</li> <li>Z-axis through the North Pole</li> <li>Y-axis completing a right-handed system</li> </ul> <p>You can convert geodetic coordinates to ECEF Cartesian coordinates using the following:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a location in geodetic coordinates (WGS84 ellipsoid model)\n# Boulder, Colorado (approximately)\nlon = -122.4194  # Longitude (deg)\nlat = 37.7749  # Latitude (deg)\nalt = 16.0  # Altitude above WGS84 ellipsoid (m)\n\nprint(\"Geodetic coordinates (WGS84 ellipsoid model):\")\nprint(f\"Longitude: {lon:.4f}\u00b0 = {np.radians(lon):.6f} rad\")\nprint(f\"Latitude:  {lat:.4f}\u00b0 = {np.radians(lat):.6f} rad\")\nprint(f\"Altitude:  {alt:.1f} m\\n\")\n# Longitude: -122.4194\u00b0 = -2.136622 rad\n# Latitude:  37.7749\u00b0 = 0.659296 rad\n# Altitude:  16.0 m\n\n# Convert geodetic to ECEF Cartesian\ngeodetic = np.array([lon, lat, alt])\necef = bh.position_geodetic_to_ecef(geodetic, bh.AngleFormat.DEGREES)\n\nprint(\"ECEF Cartesian coordinates:\")\nprint(f\"x = {ecef[0]:.3f} m\")\nprint(f\"y = {ecef[1]:.3f} m\")\nprint(f\"z = {ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(ecef):.3f} m\\n\")\n# x = -2706181.627 m\n# y = -4261070.165 m\n# z = 3885735.291 m\n# Distance from Earth center: 6370170.853 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a location in geodetic coordinates (WGS84 ellipsoid model)\n    // Boulder, Colorado (approximately)\n    let lon = -122.4194_f64;  // Longitude (deg)\n    let lat = 37.7749_f64;    // Latitude (deg)\n    let alt = 16.0;           // Altitude above WGS84 ellipsoid (m)\n\n    println!(\"Geodetic coordinates (WGS84 ellipsoid model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", lon, lon.to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", lat, lat.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt);\n    // Expected output:\n    // Longitude: -122.4194\u00b0 = -2.136622 rad\n    // Latitude:  37.7749\u00b0 = 0.659296 rad\n    // Altitude:  16.0 m\n\n    // Convert geodetic to ECEF Cartesian\n    let geodetic = na::Vector3::new(lon, lat, alt);\n    let ecef = bh::position_geodetic_to_ecef(geodetic, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"ECEF Cartesian coordinates:\");\n    println!(\"x = {:.3} m\", ecef[0]);\n    println!(\"y = {:.3} m\", ecef[1]);\n    println!(\"z = {:.3} m\", ecef[2]);\n    let distance = (ecef[0].powi(2) + ecef[1].powi(2) + ecef[2].powi(2)).sqrt();\n    println!(\"Distance from Earth center: {:.3} m\", distance);\n    // Expected output:\n    // x = -2706181.627 m\n    // y = -4261070.165 m\n    // z = 3885735.291 m\n    // Distance from Earth center: 6370170.853 m\n}\n</code></pre> <p>Info</p> <p>The conversion from geodetic to ECEF accounts for the ellipsoidal shape using the radius of curvature in the prime vertical and the first eccentricity of the ellipsoid.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#converting-ecef-to-geodetic","title":"Converting ECEF to Geodetic","text":"<p>The reverse transformation converts Cartesian ECEF coordinates back to geodetic coordinates. This requires an iterative algorithm due to the ellipsoidal geometry:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a satellite state (convert orbital elements to ECEF state)\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC)\nstate_oe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.0,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\nstate_ecef = bh.state_eci_to_ecef(\n    epc, bh.state_koe_to_eci(state_oe, bh.AngleFormat.DEGREES)\n)\nprint(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\")\nprint(f\"Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}]\")\nprint(f\"Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}]\\n\")\n# Position: [-735665.465, -1838913.314, 6586801.432]\n# Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n# Convert ECEF Cartesian to geodetic position\necef_pos = state_ecef[0:3]\ngeodetic = bh.position_ecef_to_geodetic(ecef_pos, bh.AngleFormat.DEGREES)\nprint(\"Geodetic coordinates (WGS84 ellipsoid model):\")\nprint(f\"Longitude: {geodetic[0]:.4f}\u00b0 = {np.radians(geodetic[0]):.6f} rad\")\nprint(f\"Latitude:  {geodetic[1]:.4f}\u00b0 = {np.radians(geodetic[1]):.6f} rad\")\nprint(f\"Altitude:  {geodetic[2]:.1f} m\")\n# Longitude: -111.8041\u00b0 = -1.951350 rad\n# Latitude:  73.3622\u00b0 = 1.280412 rad\n# Altitude:  519618.1 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a satellite state (convert orbital elements to ECEF state)\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let state_oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.0,                  // Eccentricity\n        97.8_f64,             // Inclination (deg)\n        15.0_f64,             // Right ascension of ascending node (deg)\n        30.0_f64,             // Argument of periapsis (deg)\n        45.0_f64              // Mean anomaly (deg)\n    );\n    let state_eci = bh::state_koe_to_eci(state_oe, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF Cartesian state [x, y, z, vx, vy, vz] (m, m/s):\");\n    println!(\"Position: [{:.3}, {:.3}, {:.3}]\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"Velocity: [{:.6}, {:.6}, {:.6}]\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Expected output:\n    // Position: [-735665.465, -1838913.314, 6586801.432]\n    // Velocity: [-1060.370171, 7357.551468, 1935.662061]\n\n    // Convert ECEF Cartesian to geodetic position\n    let ecef_pos = na::Vector3::new(state_ecef[0], state_ecef[1], state_ecef[2]);\n    let geodetic = bh::position_ecef_to_geodetic(ecef_pos, bh::AngleFormat::Degrees);\n\n    println!(\"Geodetic coordinates (WGS84 ellipsoid model):\");\n    println!(\"Longitude: {:.4}\u00b0 = {:.6} rad\", geodetic[0], geodetic[0].to_radians());\n    println!(\"Latitude:  {:.4}\u00b0 = {:.6} rad\", geodetic[1], geodetic[1].to_radians());\n    println!(\"Altitude:  {:.1} m\", geodetic[2]);\n    // Expected output:\n    // Longitude: -111.8041\u00b0 = -1.951350 rad\n    // Latitude:  73.3622\u00b0 = 1.280412 rad\n    // Altitude:  519618.1 m\n}\n</code></pre> <p>Info</p> <p>The ECEF to geodetic conversion uses an iterative algorithm that typically converges in 3-5 iterations to sub-millimeter precision.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#geodetic-vs-geocentric-accuracy","title":"Geodetic vs Geocentric Accuracy","text":"<p>For the same longitude, latitude, and altitude values, geodetic and geocentric coordinates produce different ECEF positions. The difference is smallest near the equator and largest near the poles.</p> <p>For most applications, it's best to use geodetic coordinates since any computational overhead is negligible compared to the improved accuracy near Earth's surface.</p>"},{"location":"learn/coordinates/geodetic_transformations.html#see-also","title":"See Also","text":"<ul> <li>Geodetic Coordinates API Reference - Complete function documentation</li> <li>Geocentric Transformations - Simpler spherical Earth model</li> <li>Topocentric Transformations - Local horizon coordinate systems</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html","title":"Topocentric Coordinate Transformations","text":"<p>Topocentric coordinate systems are local horizon-based reference frames centered on an observer, such as a ground station or radar site. These coordinate systems are essential for satellite tracking, visibility analysis, and determining where to point antennas or telescopes.</p> <p>Unlike global coordinate systems (ECEF, ECI), topocentric systems define positions relative to a specific location on Earth, making it easy to determine whether a satellite is visible and where to look in the sky.</p> <p>For complete API details, see the Topocentric Coordinates API Reference.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#topocentric-coordinate-systems","title":"Topocentric Coordinate Systems","text":"<p>Brahe supports two local horizon coordinate systems:</p>"},{"location":"learn/coordinates/topocentric_transformations.html#enz-east-north-zenith","title":"ENZ (East-North-Zenith)","text":"<ul> <li>East (E): Positive toward geographic east</li> <li>North (N): Positive toward geographic north</li> <li>Zenith (Z): Positive upward (toward the sky)</li> </ul> <p>This is the most common topocentric system for satellite tracking and is aligned with geographic directions.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#sez-south-east-zenith","title":"SEZ (South-East-Zenith)","text":"<ul> <li>South (S): Positive toward geographic south</li> <li>East (E): Positive toward geographic east</li> <li>Zenith (Z): Positive upward (toward the sky)</li> </ul> <p>The SEZ system is sometimes used in radar and missile tracking applications. The main difference from ENZ is that the first two axes are rotated 180\u00b0 around the zenith axis.</p> <p>Info</p> <p>Both ENZ and SEZ use a right-handed coordinate system with the zenith axis pointing up. The choice between them is typically driven by convention in your specific field or application.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#station-location-interpretation","title":"Station Location Interpretation","text":"<p>When specifying the observer (ground station) location, you must choose whether the coordinates represent:</p> <ul> <li>Geodetic (<code>EllipsoidalConversionType.GEODETIC</code>): Station coordinates use WGS84 ellipsoid (recommended for accuracy)</li> <li>Geocentric (<code>EllipsoidalConversionType.GEOCENTRIC</code>): Station coordinates use spherical Earth model</li> </ul> <p>For ground stations, geodetic interpretation is almost always preferred for accuracy.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#enz-transformations","title":"ENZ Transformations","text":""},{"location":"learn/coordinates/topocentric_transformations.html#converting-ecef-to-enz","title":"Converting ECEF to ENZ","text":"<p>To get the position of an object relative to a location, you need to convert the object's ECEF position to the local ENZ frame centered on the location:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define satellite in sun-synchronous orbit at 500 km altitude\n# SSO orbit passes over Stanford at approximately 10:30 AM local time\n# Orbital elements: [a, e, i, RAAN, omega, M]\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 240.0, 0.0, 90.0])\n\n# Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Convert orbital elements to ECI state\nsat_state_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Convert ECI state to ECEF at the given epoch\nsat_state_ecef = bh.state_eci_to_ecef(epoch, sat_state_eci)\nsat_ecef = sat_state_ecef[0:3]  # Extract position only\n\nyear, month, day, hour, minute, second, ns = epoch.to_datetime()\nprint(f\"Epoch: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f} UTC\")\nprint(\"Satellite ECEF:\")\nprint(f\"x = {sat_ecef[0]:.3f} m\")\nprint(f\"y = {sat_ecef[1]:.3f} m\")\nprint(f\"z = {sat_ecef[2]:.3f} m\\n\")\n\n# Convert satellite position to ENZ coordinates relative to ground station\nenz = bh.relative_position_ecef_to_enz(\n    station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Satellite position in ENZ frame (relative to Stanford):\")\nprint(f\"East:   {enz[0] / 1000:.3f} km\")\nprint(f\"North:  {enz[1] / 1000:.3f} km\")\nprint(f\"Zenith: {enz[2] / 1000:.3f} km\")\nprint(f\"Range:  {np.linalg.norm(enz) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define satellite in sun-synchronous orbit at 500 km altitude\n    // SSO orbit passes over Stanford at approximately 10:30 AM local time\n    // Orbital elements: [a, e, i, RAAN, omega, M]\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8_f64,\n        240.0_f64,\n        0.0_f64,\n        90.0_f64,\n    );\n\n    // Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Convert orbital elements to ECI state\n    let sat_state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Convert ECI state to ECEF at the given epoch\n    let sat_state_ecef = bh::state_eci_to_ecef(epoch, sat_state_eci);\n    let sat_ecef = na::Vector3::new(sat_state_ecef[0], sat_state_ecef[1], sat_state_ecef[2]);\n\n    let (year, month, day, hour, minute, second, _ns) = epoch.to_datetime();\n    println!(\"Epoch: {}-{:02}-{:02} {:02}:{:02}:{:06.3} UTC\", year, month, day, hour, minute, second);\n    println!(\"Satellite ECEF:\");\n    println!(\"x = {:.3} m\", sat_ecef[0]);\n    println!(\"y = {:.3} m\", sat_ecef[1]);\n    println!(\"z = {:.3} m\\n\", sat_ecef[2]);\n\n    // Convert satellite position to ENZ coordinates relative to ground station\n    let enz = bh::relative_position_ecef_to_enz(\n        station_ecef,\n        sat_ecef,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Satellite position in ENZ frame (relative to Stanford):\");\n    println!(\"East:   {:.3} km\", enz[0] / 1000.0);\n    println!(\"North:  {:.3} km\", enz[1] / 1000.0);\n    println!(\"Zenith: {:.3} km\", enz[2] / 1000.0);\n    println!(\"Range:  {:.3} km\", enz.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#converting-enz-to-ecef","title":"Converting ENZ to ECEF","text":"<p>The reverse transformation converts a relative ENZ position back to an absolute ECEF position:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define relative position in ENZ coordinates\n# Example: 50 km East, 100 km North, 200 km Up from station\nenz = np.array([50e3, 100e3, 200e3])\n\nprint(\"Relative position in ENZ frame:\")\nprint(f\"East:   {enz[0] / 1000:.1f} km\")\nprint(f\"North:  {enz[1] / 1000:.1f} km\")\nprint(f\"Zenith: {enz[2] / 1000:.1f} km\\n\")\n# East:   50.0 km\n# North:  100.0 km\n# Zenith: 200.0 km\n\n# Convert ENZ relative position to absolute ECEF position\ntarget_ecef = bh.relative_position_enz_to_ecef(\n    station_ecef, enz, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Target position in ECEF:\")\nprint(f\"x = {target_ecef[0]:.3f} m\")\nprint(f\"y = {target_ecef[1]:.3f} m\")\nprint(f\"z = {target_ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(target_ecef) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define relative position in ENZ coordinates\n    // Example: 50 km East, 100 km North, 200 km Up from station\n    let enz = na::Vector3::new(50e3, 100e3, 200e3);\n\n    println!(\"Relative position in ENZ frame:\");\n    println!(\"East:   {:.1} km\", enz[0] / 1000.0);\n    println!(\"North:  {:.1} km\", enz[1] / 1000.0);\n    println!(\"Zenith: {:.1} km\\n\", enz[2] / 1000.0);\n    // Expected output:\n    // East:   50.0 km\n    // North:  100.0 km\n    // Zenith: 200.0 km\n\n    // Convert ENZ relative position to absolute ECEF position\n    let target_ecef = bh::relative_position_enz_to_ecef(\n        station_ecef,\n        enz,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Target position in ECEF:\");\n    println!(\"x = {:.3} m\", target_ecef[0]);\n    println!(\"y = {:.3} m\", target_ecef[1]);\n    println!(\"z = {:.3} m\", target_ecef[2]);\n    println!(\"Distance from Earth center: {:.3} km\", target_ecef.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#sez-transformations","title":"SEZ Transformations","text":""},{"location":"learn/coordinates/topocentric_transformations.html#converting-ecef-to-sez","title":"Converting ECEF to SEZ","text":"<p>Similar to ENZ, you can convert ECEF positions to the SEZ frame:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define satellite in sun-synchronous orbit at 500 km altitude\n# SSO orbit passes over Stanford at approximately 10:30 AM local time\n# Orbital elements: [a, e, i, RAAN, omega, M]\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 240.0, 0.0, 90.0])\n\n# Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Convert orbital elements to ECI state\nsat_state_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Convert ECI state to ECEF at the given epoch\nsat_state_ecef = bh.state_eci_to_ecef(epoch, sat_state_eci)\nsat_ecef = sat_state_ecef[0:3]  # Extract position only\n\nyear, month, day, hour, minute, second, ns = epoch.to_datetime()\nprint(f\"Epoch: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f} UTC\")\nprint(\"Satellite ECEF:\")\nprint(f\"x = {sat_ecef[0]:.3f} m\")\nprint(f\"y = {sat_ecef[1]:.3f} m\")\nprint(f\"z = {sat_ecef[2]:.3f} m\\n\")\n\n# Convert satellite position to SEZ coordinates relative to ground station\nsez = bh.relative_position_ecef_to_sez(\n    station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Satellite position in SEZ frame (relative to Stanford):\")\nprint(f\"South:  {sez[0] / 1000:.3f} km\")\nprint(f\"East:   {sez[1] / 1000:.3f} km\")\nprint(f\"Zenith: {sez[2] / 1000:.3f} km\")\nprint(f\"Range:  {np.linalg.norm(sez) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define satellite in sun-synchronous orbit at 500 km altitude\n    // SSO orbit passes over Stanford at approximately 10:30 AM local time\n    // Orbital elements: [a, e, i, RAAN, omega, M]\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8_f64,\n        240.0_f64,\n        0.0_f64,\n        90.0_f64,\n    );\n\n    // Define epoch when satellite passes near Stanford (Jan 1, 2024, 17:05 UTC)\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 17, 5, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Convert orbital elements to ECI state\n    let sat_state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Convert ECI state to ECEF at the given epoch\n    let sat_state_ecef = bh::state_eci_to_ecef(epoch, sat_state_eci);\n    let sat_ecef = na::Vector3::new(sat_state_ecef[0], sat_state_ecef[1], sat_state_ecef[2]);\n\n    let (year, month, day, hour, minute, second, _ns) = epoch.to_datetime();\n    println!(\"Epoch: {}-{:02}-{:02} {:02}:{:02}:{:06.3} UTC\", year, month, day, hour, minute, second);\n    println!(\"Satellite ECEF:\");\n    println!(\"x = {:.3} m\", sat_ecef[0]);\n    println!(\"y = {:.3} m\", sat_ecef[1]);\n    println!(\"z = {:.3} m\\n\", sat_ecef[2]);\n\n    // Convert satellite position to SEZ coordinates relative to ground station\n    let sez = bh::relative_position_ecef_to_sez(\n        station_ecef,\n        sat_ecef,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Satellite position in SEZ frame (relative to Stanford):\");\n    println!(\"South:  {:.3} km\", sez[0] / 1000.0);\n    println!(\"East:   {:.3} km\", sez[1] / 1000.0);\n    println!(\"Zenith: {:.3} km\", sez[2] / 1000.0);\n    println!(\"Range:  {:.3} km\", sez.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#converting-sez-to-ecef","title":"Converting SEZ to ECEF","text":"<p>The reverse transformation converts a relative SEZ position back to an absolute ECEF position:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define ground station location in geodetic coordinates\n# Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\nlon_deg = -122.17329\nlat_deg = 37.42692\nalt_m = 32.0\n\nprint(\"Ground Station (Stanford):\")\nprint(f\"Longitude: {lon_deg:.5f}\u00b0 = {np.radians(lon_deg):.6f} rad\")\nprint(f\"Latitude:  {lat_deg:.5f}\u00b0 = {np.radians(lat_deg):.6f} rad\")\nprint(f\"Altitude:  {alt_m:.1f} m\\n\")\n# Longitude: -122.17329\u00b0 = -2.132605 rad\n# Latitude:  37.42692\u00b0 = 0.653131 rad\n# Altitude:  32.0 m\n\n# Convert ground station to ECEF\ngeodetic_station = np.array([lon_deg, lat_deg, alt_m])\nstation_ecef = bh.position_geodetic_to_ecef(geodetic_station, bh.AngleFormat.DEGREES)\n\nprint(\"Ground Station ECEF:\")\nprint(f\"x = {station_ecef[0]:.3f} m\")\nprint(f\"y = {station_ecef[1]:.3f} m\")\nprint(f\"z = {station_ecef[2]:.3f} m\\n\")\n# x = -2700691.122 m\n# y = -4292566.016 m\n# z = 3855395.780 m\n\n# Define relative position in SEZ coordinates\n# Example: 30 km South, 50 km East, 100 km Up from station\nsez = np.array([30e3, 50e3, 100e3])\n\nprint(\"Relative position in SEZ frame:\")\nprint(f\"South:  {sez[0] / 1000:.1f} km\")\nprint(f\"East:   {sez[1] / 1000:.1f} km\")\nprint(f\"Zenith: {sez[2] / 1000:.1f} km\\n\")\n# South:  30.0 km\n# East:   50.0 km\n# Zenith: 100.0 km\n\n# Convert SEZ relative position to absolute ECEF position\ntarget_ecef = bh.relative_position_sez_to_ecef(\n    station_ecef, sez, bh.EllipsoidalConversionType.GEODETIC\n)\n\nprint(\"Target position in ECEF:\")\nprint(f\"x = {target_ecef[0]:.3f} m\")\nprint(f\"y = {target_ecef[1]:.3f} m\")\nprint(f\"z = {target_ecef[2]:.3f} m\")\nprint(f\"Distance from Earth center: {np.linalg.norm(target_ecef) / 1000:.3f} km\")\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define ground station location in geodetic coordinates\n    // Stanford University: (lon=-122.17329\u00b0, lat=37.42692\u00b0, alt=32.0m)\n    let lon_deg = -122.17329_f64;\n    let lat_deg = 37.42692_f64;\n    let alt_m = 32.0;\n\n    println!(\"Ground Station (Stanford):\");\n    println!(\"Longitude: {:.5}\u00b0 = {:.6} rad\", lon_deg, lon_deg.to_radians());\n    println!(\"Latitude:  {:.5}\u00b0 = {:.6} rad\", lat_deg, lat_deg.to_radians());\n    println!(\"Altitude:  {:.1} m\\n\", alt_m);\n    // Expected output:\n    // Longitude: -122.17329\u00b0 = -2.132605 rad\n    // Latitude:  37.42692\u00b0 = 0.653131 rad\n    // Altitude:  32.0 m\n\n    // Convert ground station to ECEF\n    let geodetic_station = na::Vector3::new(lon_deg, lat_deg, alt_m);\n    let station_ecef = bh::position_geodetic_to_ecef(geodetic_station, bh::AngleFormat::Degrees).unwrap();\n\n    println!(\"Ground Station ECEF:\");\n    println!(\"x = {:.3} m\", station_ecef[0]);\n    println!(\"y = {:.3} m\", station_ecef[1]);\n    println!(\"z = {:.3} m\\n\", station_ecef[2]);\n    // Expected output:\n    // x = -2700691.122 m\n    // y = -4292566.016 m\n    // z = 3855395.780 m\n\n    // Define relative position in SEZ coordinates\n    // Example: 30 km South, 50 km East, 100 km Up from station\n    let sez = na::Vector3::new(30e3, 50e3, 100e3);\n\n    println!(\"Relative position in SEZ frame:\");\n    println!(\"South:  {:.1} km\", sez[0] / 1000.0);\n    println!(\"East:   {:.1} km\", sez[1] / 1000.0);\n    println!(\"Zenith: {:.1} km\\n\", sez[2] / 1000.0);\n    // Expected output:\n    // South:  30.0 km\n    // East:   50.0 km\n    // Zenith: 100.0 km\n\n    // Convert SEZ relative position to absolute ECEF position\n    let target_ecef = bh::relative_position_sez_to_ecef(\n        station_ecef,\n        sez,\n        bh::EllipsoidalConversionType::Geodetic,\n    );\n\n    println!(\"Target position in ECEF:\");\n    println!(\"x = {:.3} m\", target_ecef[0]);\n    println!(\"y = {:.3} m\", target_ecef[1]);\n    println!(\"z = {:.3} m\", target_ecef[2]);\n    println!(\"Distance from Earth center: {:.3} km\", target_ecef.norm() / 1000.0);\n}\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#azimuth-and-elevation-from-topocentric-coordinates","title":"Azimuth and Elevation from Topocentric Coordinates","text":"<p>For object tracking, it's often more intuitive to work with azimuth (compass direction) and elevation (angle above the horizon) rather than Cartesian ENZ or SEZ coordinates. Both ENZ and SEZ topocentric systems can be converted to azimuth-elevation-range format.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#from-enz-coordinates","title":"From ENZ Coordinates","text":"<p>Convert ENZ positions to azimuth (measured clockwise from North), elevation (angle above horizon), and range:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define several relative positions in ENZ coordinates\ntest_cases = [\n    (\"Directly overhead\", np.array([0.0, 0.0, 100e3])),\n    (\"North horizon\", np.array([0.0, 100e3, 0.0])),\n    (\"East horizon\", np.array([100e3, 0.0, 0.0])),\n    (\"South horizon\", np.array([0.0, -100e3, 0.0])),\n    (\"West horizon\", np.array([-100e3, 0.0, 0.0])),\n    (\"Northeast at 45\u00b0 elevation\", np.array([50e3, 50e3, 70.7e3])),\n]\n\nprint(\"Converting ENZ coordinates to Azimuth-Elevation-Range:\\n\")\n\nfor name, enz in test_cases:\n    # Convert to azimuth-elevation-range\n    azel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\n\n    print(f\"{name}:\")\n    print(\n        f\"  ENZ:   E={enz[0] / 1000:.1f}km, N={enz[1] / 1000:.1f}km, Z={enz[2] / 1000:.1f}km\"\n    )\n    print(\n        f\"  Az/El: Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2] / 1000:.1f}km\\n\"\n    )\n\n# Expected outputs:\n# Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n# North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n# East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n# South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n# West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define several relative positions in ENZ coordinates\n    let test_cases = vec![\n        (\"Directly overhead\", na::Vector3::new(0.0, 0.0, 100e3)),\n        (\"North horizon\", na::Vector3::new(0.0, 100e3, 0.0)),\n        (\"East horizon\", na::Vector3::new(100e3, 0.0, 0.0)),\n        (\"South horizon\", na::Vector3::new(0.0, -100e3, 0.0)),\n        (\"West horizon\", na::Vector3::new(-100e3, 0.0, 0.0)),\n        (\"Northeast at 45\u00b0 elevation\", na::Vector3::new(50e3, 50e3, 70.7e3)),\n    ];\n\n    println!(\"Converting ENZ coordinates to Azimuth-Elevation-Range:\\n\");\n\n    for (name, enz) in test_cases {\n        // Convert to azimuth-elevation-range\n        let azel = bh::position_enz_to_azel(enz, bh::AngleFormat::Degrees);\n\n        println!(\"{}:\", name);\n        println!(\"  ENZ:   E={:.1}km, N={:.1}km, Z={:.1}km\",\n                 enz[0] / 1000.0, enz[1] / 1000.0, enz[2] / 1000.0);\n        println!(\"  Az/El: Az={:.1}\u00b0, El={:.1}\u00b0, Range={:.1}km\\n\",\n                 azel[0], azel[1], azel[2] / 1000.0);\n    }\n\n    // Expected outputs:\n    // Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n    // North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n}\n</code></pre> <p>Info</p> <p>Azimuth is measured clockwise from North (0\u00b0 = North, 90\u00b0 = East, 180\u00b0 = South, 270\u00b0 = West). Elevation is the angle above the horizon (0\u00b0 = horizon, 90\u00b0 = directly overhead).</p>"},{"location":"learn/coordinates/topocentric_transformations.html#from-sez-coordinates","title":"From SEZ Coordinates","text":"<p>The same conversion is available from SEZ coordinates:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define several relative positions in SEZ coordinates\ntest_cases = [\n    (\"Directly overhead\", np.array([0.0, 0.0, 100e3])),\n    (\"North horizon\", np.array([-100e3, 0.0, 0.0])),\n    (\"East horizon\", np.array([0.0, 100e3, 0.0])),\n    (\"South horizon\", np.array([100e3, 0.0, 0.0])),\n    (\"West horizon\", np.array([0.0, -100e3, 0.0])),\n    (\"Northeast at 45\u00b0 elevation\", np.array([-50e3, 50e3, 70.7e3])),\n]\n\nprint(\"Converting SEZ coordinates to Azimuth-Elevation-Range:\\n\")\n\nfor name, sez in test_cases:\n    # Convert to azimuth-elevation-range\n    azel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\n\n    print(f\"{name}:\")\n    print(\n        f\"  SEZ:   S={sez[0] / 1000:.1f}km, E={sez[1] / 1000:.1f}km, Z={sez[2] / 1000:.1f}km\"\n    )\n    print(\n        f\"  Az/El: Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2] / 1000:.1f}km\\n\"\n    )\n\n# Expected outputs:\n# Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n# North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n# East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n# South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n# West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define several relative positions in SEZ coordinates\n    let test_cases = vec![\n        (\"Directly overhead\", na::Vector3::new(0.0, 0.0, 100e3)),\n        (\"North horizon\", na::Vector3::new(-100e3, 0.0, 0.0)),\n        (\"East horizon\", na::Vector3::new(0.0, 100e3, 0.0)),\n        (\"South horizon\", na::Vector3::new(100e3, 0.0, 0.0)),\n        (\"West horizon\", na::Vector3::new(0.0, -100e3, 0.0)),\n        (\"Northeast at 45\u00b0 elevation\", na::Vector3::new(-50e3, 50e3, 70.7e3)),\n    ];\n\n    println!(\"Converting SEZ coordinates to Azimuth-Elevation-Range:\\n\");\n\n    for (name, sez) in test_cases {\n        // Convert to azimuth-elevation-range\n        let azel = bh::position_sez_to_azel(sez, bh::AngleFormat::Degrees);\n\n        println!(\"{}:\", name);\n        println!(\"  SEZ:   S={:.1}km, E={:.1}km, Z={:.1}km\",\n                 sez[0] / 1000.0, sez[1] / 1000.0, sez[2] / 1000.0);\n        println!(\"  Az/El: Az={:.1}\u00b0, El={:.1}\u00b0, Range={:.1}km\\n\",\n                 azel[0], azel[1], azel[2] / 1000.0);\n    }\n\n    // Expected outputs:\n    // Directly overhead: Az=0.0\u00b0, El=90.0\u00b0, Range=100.0km\n    // North horizon: Az=0.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // East horizon: Az=90.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // South horizon: Az=180.0\u00b0, El=0.0\u00b0, Range=100.0km\n    // West horizon: Az=270.0\u00b0, El=0.0\u00b0, Range=100.0km\n}\n</code></pre> <p>Info</p> <p>Both ENZ and SEZ produce identical azimuth-elevation-range results for the same physical position. The choice between them is purely a matter of intermediate representation.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates API Reference - Complete function documentation</li> <li>Geodetic Transformations - Converting station locations to ECEF</li> <li>Frame Transformations - Converting satellite positions from ECI to ECEF</li> <li>Access Analysis - Higher-level tools for computing satellite visibility windows</li> </ul>"},{"location":"learn/datasets/index.html","title":"Datasets","text":"<p>The datasets module in Brahe provides easy access to common data sources used in astrodynamics, space mission analysis, and research. This includes ephemeris data for Earth-orbiting satellites and locations of ground stations.</p>"},{"location":"learn/datasets/index.html#overview","title":"Overview","text":"<p>Working with satellite and planetary data typically requires gathering information from multiple sources:</p> <ul> <li>Orbital elements (TLEs) for satellite tracking and propagation</li> <li>Planetary ephemeris (DE kernels) for high-precision solar system body positions</li> <li>Groundstation locations for computing contact opportunities</li> <li>Satellite metadata for mission planning and analysis</li> </ul> <p>Brahe's datasets module centralizes access to these data sources, handling the details of fetching, parsing, and caching so you can focus on analysis rather than data wrangling.</p>"},{"location":"learn/datasets/index.html#available-data-sources","title":"Available Data Sources","text":""},{"location":"learn/datasets/index.html#celestrak","title":"CelesTrak","text":"<p>CelesTrak provides Two-Line Element (TLE) data for thousands of Earth-orbiting satellites. The brahe interface supports:</p> <ul> <li>Group downloads: Fetch entire satellite constellations (Starlink, OneWeb, GPS, etc.)</li> <li>Individual lookups: Get specific satellites by NORAD ID or name</li> <li>Direct propagation: Convert TLEs to SGP4 propagators in one step</li> </ul> <p>Best for: Satellite analysis, orbit propagation, space situational awareness</p>"},{"location":"learn/datasets/index.html#naif","title":"NAIF","text":"<p>NASA JPL's NAIF archive provides high-precision planetary ephemeris kernels. The brahe interface supports:</p> <ul> <li>DE kernel downloads: Fetch Development Ephemeris binary files (SPK format)</li> <li>Automatic caching: Downloaded kernels are cached permanently</li> <li>Multiple versions: Support for DE430, DE440, DE442 and variants</li> </ul> <p>Best for: High-precision planetary ephemeris, interplanetary mission analysis</p>"},{"location":"learn/datasets/index.html#groundstations","title":"Groundstations","text":"<p>Embedded GeoJSON data for commercial groundstation networks. Includes 6 major providers:</p> <ul> <li>Atlas Space Operations</li> <li>Amazon Web Services Ground Station</li> <li>Kongsberg Satellite Services (KSAT)</li> <li>Leaf Space</li> <li>Swedish Space Corporation (SSC)</li> <li>Viasat</li> </ul> <p>Best for: Contact opportunity analysis, network planning, coverage studies</p>"},{"location":"learn/datasets/index.html#data-philosophy","title":"Data Philosophy","text":"<p>Brahe's datasets module aims to:</p> <ul> <li>Reduce friction: Provide easy access to commonly needed data</li> <li>No surprises: Data sources are clearly documented with known limitations</li> <li>Offline capable: Prefer embedded data when feasible</li> <li>Respect providers: Follow best practices and rate limiting</li> <li>Stay current: Update data sources as the ecosystem evolves</li> </ul>"},{"location":"learn/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Data Source - TLE ephemeris data</li> <li>NAIF Ephemeris Kernels - Planetary ephemeris data</li> <li>Groundstation Datasets - Ground facility locations</li> <li>Datasets API Reference - Complete function documentation</li> </ul>"},{"location":"learn/datasets/celestrak.html","title":"CelesTrak Data Source","text":"<p>CelesTrak is a public source for satellite Two-Line Element (TLE) data, maintained by T.S. Kelso since 1985. It provides free, frequently updated orbital element sets for thousands of satellites, making it a useful resource for satellite tracking, orbit determination, and space situational awareness.</p> <p>Respectful Usage</p> <p>CelesTrak is freely available for public use, but users should be respectful of the service. Avoid excessive automated requests, and design your calls to take advantage of caching to minimize repeated queries. For large-scale or commercial applications, consider setting up a single download and local caching strategy to disribute ephemeris data internally.</p>"},{"location":"learn/datasets/celestrak.html#overview","title":"Overview","text":""},{"location":"learn/datasets/celestrak.html#what-is-celestrak","title":"What is CelesTrak?","text":"<p>CelesTrak is a public data source for satellite orbital elements, maintained by Dr. T.S. Kelso since 1985. It provides free, frequently updated Two-Line Element (TLE) data for thousands of satellites, making it an essential resource for satellite tracking, orbit determination, and space situational awareness.</p>"},{"location":"learn/datasets/celestrak.html#tle-format","title":"TLE Format","text":"<p>Two-Line Elements (TLEs) are a compact text format for encoding satellite orbital parameters compatible with the SGP4/SDP4 propagation models. For more information on TLEs, see the Two-Line Elements documentation.</p>"},{"location":"learn/datasets/celestrak.html#caching","title":"Caching","text":"<p>To minimize load on CelesTrak's servers and improve performance, brahe implements a 6-hour cache for downloaded data:</p> <ul> <li>Cache key: Satellite group name (e.g., \"starlink\", \"stations\")</li> <li>Cache duration: 6 hours (default, configurable)</li> <li>Cache location: System temp directory</li> </ul> <p>When you request a satellite by ID or name with a group hint, brahe checks if that group was recently downloaded and uses cached data if available. This is much faster and more respectful than making individual requests.</p> <p>Customizing Cache</p> <p>See the Caching documentation for details on customizing cache behavior.</p>"},{"location":"learn/datasets/celestrak.html#usage","title":"Usage","text":""},{"location":"learn/datasets/celestrak.html#getting-ephemeris-by-group","title":"Getting Ephemeris by Group","text":"<p>The most efficient way to get TLE data is by downloading entire groups. This minimizes API requests and leverages caching:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Download TLE data for the Starlink group\n# This fetches all Starlink satellites in one request\ntles = bh.datasets.celestrak.get_tles(\"starlink\")\n\nprint(f\"Downloaded {len(tles)} Starlink TLEs\")\n\n# Each TLE is a tuple of (name, line1, line2)\nname, line1, line2 = tles[0]\nprint(\"\\nFirst TLE:\")\nprint(f\"  Name: {name}\")\nprint(f\"  Line 1: {line1}\")\nprint(f\"  Line 2: {line2}\")\n\n# Expected output:\n# Downloaded 8647 Starlink TLEs\n\n# First TLE:\n#   Name: STARLINK-1008\n#   Line 1: 1 44714U 19074B   25306.45157821  .00002551  00000+0  19011-3 0  9997\n#   Line 2: 2 44714  53.0544  37.8105 0001365  79.2826 280.8316 15.06391189329573\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Download TLE data for the Starlink group\n    // This fetches all Starlink satellites in one request\n    let tles = bh::datasets::celestrak::get_tles(\"starlink\").unwrap();\n\n    println!(\"Downloaded {} Starlink TLEs\", tles.len());\n\n    // Each TLE is a tuple of (name, line1, line2)\n    let (name, line1, line2) = &amp;tles[0];\n    println!(\"\\nFirst TLE:\");\n    println!(\"  Name: {}\", name);\n    println!(\"  Line 1: {}\", line1);\n    println!(\"  Line 2: {}\", line2);\n\n    // Expected output:\n    // Downloaded 8647 Starlink TLEs\n\n    // First TLE:\n    //   Name: STARLINK-1008\n    //   Line 1: 1 44714U 19074B   25306.45157821  .00002551  00000+0  19011-3 0  9997\n    //   Line 2: 2 44714  53.0544  37.8105 0001365  79.2826 280.8316 15.06391189329573\n}\n</code></pre>"},{"location":"learn/datasets/celestrak.html#getting-a-satellite-by-id","title":"Getting a Satellite by ID","text":"<p>To get a specific satellite, provide its NORAD ID. Always include a group hint to enable cache-efficient lookups:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get ISS TLE by NORAD ID\n# The group hint (\"stations\") allows brahe to check cached data first\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_id(25544, \"stations\")\n\n# Parse TLE data to get epoch and orbital elements\nepoch, oe = bh.keplerian_elements_from_tle(line1, line2)\n\nprint(\"ISS TLE:\")\nprint(f\"  Name: {name}\")\nprint(f\"  Epoch: {epoch}\")\nprint(f\"  Inclination: {oe[2]:.2f}\u00b0\")\nprint(f\"  RAAN: {oe[3]:.2f}\u00b0\")\nprint(f\"  Eccentricity: {oe[1]:.6f}\")\n\n# Expected output:\n# ISS TLE:\n#   Name: ISS (ZARYA)\n#   Epoch: 2025-11-02 10:09:34.283 UTC\n#   Inclination: 51.63\u00b0\n#   RAAN: 342.07\u00b0\n#   Eccentricity: 0.000497\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get ISS TLE by NORAD ID\n    // The group hint (\"stations\") allows brahe to check cached data first\n    let (name, line1, line2) = bh::datasets::celestrak::get_tle_by_id(25544, Some(\"stations\")).unwrap();\n\n    // Parse TLE data to get epoch and orbital elements\n    let (epoch, oe) = bh::keplerian_elements_from_tle(&amp;line1, &amp;line2).unwrap();\n\n    println!(\"ISS TLE:\");\n    println!(\"  Name: {}\", name);\n    println!(\"  Epoch: {}\", epoch);\n    println!(\"  Inclination: {:.2}\u00b0\", oe[2]);\n    println!(\"  RAAN: {:.2}\u00b0\", oe[3]);\n    println!(\"  Eccentricity: {:.6}\", oe[1]);\n\n    // Expected output:\n    // ISS TLE:\n    //   Name: ISS (ZARYA)\n    //   Epoch: 2025-11-02 10:09:34.283 UTC\n    //   Inclination: 51.63\u00b0\n    //   RAAN: 342.07\u00b0\n    //   Eccentricity: 0.000497\n}\n</code></pre> <p>Cache-Efficient Pattern</p> <p>The most efficient workflow is:</p> <ol> <li>Download the group once: <code>get_tles(\"stations\")</code></li> <li>Query specific satellites with the group hint: <code>get_tle_by_id(25544, \"stations\")</code></li> </ol> <p>This pattern uses cached data and avoids redundant downloads.</p>"},{"location":"learn/datasets/celestrak.html#converting-to-propagators","title":"Converting to Propagators","text":"<p>For most applications, you'll want to convert TLEs directly to SGP propagators. Brahe provides convenience functions that do this in one step:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get ISS as a propagator with 60-second step size\n# The group hint (\"stations\") uses cached data for efficiency\niss_prop = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"stations\")\n\nprint(f\"Created propagator: {iss_prop.get_name()}\")\nprint(f\"Epoch: {iss_prop.epoch}\")\n\n# Propagate forward 1 orbit period (~93 minutes for ISS)\niss_prop.propagate_to(iss_prop.epoch + bh.orbital_period(iss_prop.semi_major_axis))\nstate = iss_prop.current_state()\n\nprint(\"\\nState after 1 orbit:\")\nprint(f\"  Position: [{state[0]:.1f}, {state[1]:.1f}, {state[2]:.1f}] m\")\nprint(f\"  Velocity: [{state[3]:.1f}, {state[4]:.1f}, {state[5]:.1f}] m/s\")\n\n# Expected output:\n# Created propagator: ISS (ZARYA)\n# Epoch: 2025-11-02 10:09:34.283 UTC\n\n# State after 1 orbit:\n#   Position: [6451630.2, -2126316.1, 34427.2] m\n#   Velocity: [2019.6, 5281.4, 6006.2] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::SStatePropagator;\nuse bh::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get ISS as a propagator with 60-second step size\n    // The group hint (\"stations\") uses cached data for efficiency\n    let mut iss_prop = bh::datasets::celestrak::get_tle_by_id_as_propagator(\n        25544,\n        Some(\"stations\"),\n        60.0,\n    )\n    .unwrap();\n\n    println!(\"Created propagator: {}\", iss_prop.get_name().unwrap_or(\"Unknown\"));\n    println!(\"Epoch: {}\", iss_prop.epoch);\n\n    // Propagate forward 1 orbit period (~93 minutes for ISS)\n    iss_prop.propagate_to(iss_prop.epoch + bh::orbital_period(iss_prop.semi_major_axis()));\n    let state = iss_prop.current_state();\n\n    println!(\"\\nState after 1 orbit:\");\n    println!(\n        \"  Position: [{:.1}, {:.1}, {:.1}] m\",\n        state[0], state[1], state[2]\n    );\n    println!(\n        \"  Velocity: [{:.1}, {:.1}, {:.1}] m/s\",\n        state[3], state[4], state[5]\n    );\n\n    // Expected output:\n    // Created propagator: ISS (ZARYA)\n    // Epoch: 2025-11-02 10:09:34.283 UTC\n\n    // State after 1 orbit:\n    //   Position: [6451630.2, -2126316.1, 34427.2] m\n    //   Velocity: [2019.6, 5281.4, 6006.2] m/s\n}\n</code></pre>"},{"location":"learn/datasets/celestrak.html#getting-by-name","title":"Getting by Name","text":"<p>You can also search for satellites by name. This performs a cascading search across groups:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Search by name (checks common groups automatically)\niss_name, iss_line1, iss_line2 = bh.datasets.celestrak.get_tle_by_name(\"ISS\")\n\nprint(\"Search without group hint:\")\nprint(f\"  Found: {iss_name}\")\nprint(f\"  Line 1: {iss_line1}\")\nprint(f\"  Line 2: {iss_line2}\")\n\n# Or provide a group hint for faster lookup\niss_name2, iss_line2_1, iss_line2_2 = bh.datasets.celestrak.get_tle_by_name(\n    \"ISS\", \"stations\"\n)\n\nprint(\"\\nSearch with group hint:\")\nprint(f\"  Found: {iss_name2}\")\nprint(f\"  Line 1: {iss_line2_1}\")\nprint(f\"  Line 2: {iss_line2_2}\")\n\n# Expected output:\n# Search without group hint:\n#   Found: ISS (ZARYA)\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n# Search with group hint:\n#   Found: ISS (ZARYA)\n#   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n#   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Search by name (checks common groups automatically)\n    let (iss_name, iss_line1, iss_line2) =\n        bh::datasets::celestrak::get_tle_by_name(\"ISS\", None).unwrap();\n\n    println!(\"Search without group hint:\");\n    println!(\"  Found: {}\", iss_name);\n    println!(\"  Line 1: {}\", &amp;iss_line1);\n    println!(\"  Line 2: {}\", &amp;iss_line2);\n\n    // Or provide a group hint for faster lookup\n    let (iss_name2, iss_line2_1, iss_line2_2) =\n        bh::datasets::celestrak::get_tle_by_name(\"ISS\", Some(\"stations\")).unwrap();\n\n    println!(\"\\nSearch with group hint:\");\n    println!(\"  Found: {}\", iss_name2);\n    println!(\"  Line 1: {}\", &amp;iss_line2_1);\n    println!(\"  Line 2: {}\", &amp;iss_line2_2);\n\n    // Expected output:\n    // Search without group hint:\n    //   Found: ISS (ZARYA)\n    //   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n    //   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n\n    // Search with group hint:\n    //   Found: ISS (ZARYA)\n    //   Line 1: 1 25544U 98067A   25306.42331346  .00010070  00000+0  18610-3 0  9998\n    //   Line 2: 2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\n}\n</code></pre> <p>Name Matching</p> <p>Name searches are case-insensitive and support partial matches. If multiple satellites match, the function returns the first match. </p>"},{"location":"learn/datasets/celestrak.html#satellite-groups","title":"Satellite Groups","text":"<p>CelesTrak organizes satellites into logical groups accessible via simple names. These groups are updated as active constellations evolve. It is best to download TLEs by group name rather than ID to minimize the number of distinct requests.</p>"},{"location":"learn/datasets/celestrak.html#temporal-groups","title":"Temporal Groups","text":"Group Description <code>active</code> All active satellites <code>last-30-days</code> Recently launched satellites <code>tle-new</code> Newly added TLEs (last 15 days)"},{"location":"learn/datasets/celestrak.html#communications","title":"Communications","text":"Group Description <code>starlink</code> SpaceX Starlink constellation <code>oneweb</code> OneWeb constellation <code>kuiper</code> Amazon Kuiper constellation <code>intelsat</code> Intelsat satellites <code>eutelsat</code> Eutelsat constellation <code>orbcomm</code> ORBCOMM constellation <code>telesat</code> Telesat constellation <code>globalstar</code> Globalstar constellation <code>iridium-NEXT</code> Iridium constellation <code>qianfan</code> Qianfan constellation <code>hulianwang</code> Hulianwang Digui constellation"},{"location":"learn/datasets/celestrak.html#earth-observation","title":"Earth Observation","text":"Group Description <code>weather</code> Weather satellites (NOAA, GOES, Metop, etc.) <code>earth-resources</code> Earth observation (Landsat, Sentinel, etc.) <code>planet</code> Planet Labs imaging satellites <code>spire</code> Spire Global satellites"},{"location":"learn/datasets/celestrak.html#navigation","title":"Navigation","text":"Group Description <code>gnss</code> All navigation satellites (GPS, GLONASS, Galileo, BeiDou, QZSS, IRNSS) <code>gps-ops</code> Operational GPS satellites only <code>glonass-ops</code> Operational GLONASS satellites only <code>galileo</code> European Galileo constellation <code>beidou</code> Chinese BeiDou/COMPASS constellation <code>sbas</code> Satellite-Based Augmentation System (WAAS/EGNOS/MSAS)"},{"location":"learn/datasets/celestrak.html#scientific-and-special-purpose","title":"Scientific and Special Purpose","text":"Group Description <code>science</code> Scientific research satellites <code>noaa</code> NOAA satellites <code>stations</code> Space stations (ISS, Tiangong) <code>analyst</code> Analyst satellites (tracking placeholder IDs) <code>visual</code> 100 (or so) brightest objects <code>gpz</code> Geostationary Protected Zone <code>gpz-plus</code> Geostationary Protected Zone Plus <p>Note: Group names and contents evolve as missions launch, deorbit, or change status. Visit CelesTrak GP Element Sets for the current complete list.</p>"},{"location":"learn/datasets/celestrak.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding satellite ephemeris datasets</li> <li>Two-Line Elements - TLE and 3LE format details</li> <li>Downloading TLE Data - Practical examples</li> <li>CelesTrak API Reference - Function documentation</li> </ul>"},{"location":"learn/datasets/groundstations.html","title":"Groundstation Datasets","text":""},{"location":"learn/datasets/groundstations.html#overview","title":"Overview","text":"<p>Groundstation datasets provide geographic locations and metadata for commercial satellite ground facilities worldwide. This data is essential for:</p> <ul> <li>Computing contact opportunities: Determine when satellites are visible from ground stations</li> <li>Network planning: Analyze coverage and redundancy across multiple providers</li> <li>Mission design: Evaluate downlink opportunities for different orbit configurations</li> </ul> <p>Brahe includes embedded GeoJSON data for 6 major commercial groundstation providers, totaling 50+ facilities globally. All data is:</p> <ul> <li>Offline-capable: No network requests required</li> <li>Comprehensive: Global coverage across multiple providers</li> <li>Standardized: Consistent format with geographic coordinates and metadata</li> <li>Up-to-date: Maintained as provider networks evolve</li> </ul>"},{"location":"learn/datasets/groundstations.html#when-to-use","title":"When to Use","text":"<p>Use groundstation datasets when you need to:</p> <ul> <li>Compute visibility windows for satellite-to-ground contacts</li> <li>Plan downlink schedules for data collection</li> <li>Analyze network coverage and redundancy</li> <li>Compare provider capabilities across different locations</li> </ul>"},{"location":"learn/datasets/groundstations.html#available-providers","title":"Available Providers","text":"<p>Brahe includes groundstation data from six major commercial providers:</p> Provider Description Atlas Atlas Space Operations AWS Amazon Web Services Ground Station KSAT Kongsberg Satellite Services Leaf Leaf Space NASA DSN NASA Deep Space Network NASA NEN NASA Near Earth Network SSC Swedish Space Corporation Viasat Viasat"},{"location":"learn/datasets/groundstations.html#usage","title":"Usage","text":""},{"location":"learn/datasets/groundstations.html#loading-groundstations","title":"Loading Groundstations","text":"<p>Load groundstation data from one or more providers:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load groundstations from a single provider\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"KSAT stations: {len(ksat_stations)}\")\n\n# Load all available providers at once\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Total stations (all providers): {len(all_stations)}\")\n\n# List available providers\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"\\nAvailable providers: {', '.join(providers)}\")\n\n# Load multiple specific providers\naws_stations = bh.datasets.groundstations.load(\"aws\")\nssc_stations = bh.datasets.groundstations.load(\"ssc\")\ncombined = aws_stations + ssc_stations\nprint(f\"\\nCombined AWS + SSC: {len(combined)} stations\")\n\n# Expected output:\n# KSAT stations: 36\n# Total stations (all providers): 96\n\n# Available providers: atlas, aws, ksat, leaf, ssc, viasat\n\n# Combined AWS + SSC: 22 stations\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load groundstations from a single provider\n    let ksat_stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n    println!(\"KSAT stations: {}\", ksat_stations.len());\n\n    // Load all available providers at once\n    let all_stations = bh::datasets::groundstations::load_all_groundstations().unwrap();\n    println!(\"Total stations (all providers): {}\", all_stations.len());\n\n    // List available providers\n    let providers = bh::datasets::groundstations::list_providers();\n    println!(\"\\nAvailable providers: {}\", providers.join(\", \"));\n\n    // Load multiple specific providers\n    let aws_stations = bh::datasets::groundstations::load_groundstations(\"aws\").unwrap();\n    let ssc_stations = bh::datasets::groundstations::load_groundstations(\"ssc\").unwrap();\n    let combined: Vec&lt;_&gt; = aws_stations\n        .iter()\n        .chain(ssc_stations.iter())\n        .cloned()\n        .collect();\n    println!(\"\\nCombined AWS + SSC: {} stations\", combined.len());\n\n    // Expected output:\n    // KSAT stations: 36\n    // Total stations (all providers): 96\n\n    // Available providers: atlas, aws, ksat, leaf, ssc, viasat\n\n    // Combined AWS + SSC: 22 stations\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#accessing-properties","title":"Accessing Properties","text":"<p>Each groundstation includes geographic coordinates and metadata:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load KSAT groundstations\nstations = bh.datasets.groundstations.load(\"ksat\")\n\n# Access the first station\nstation = stations[0]\n\n# Geographic coordinates (degrees and meters)\nname = station.get_name() if station.get_name() else \"Unknown\"\nprint(f\"Station: {name}\")\nprint(f\"Latitude: {station.lat:.4f}\u00b0\")\nprint(f\"Longitude: {station.lon:.4f}\u00b0\")\nprint(f\"Altitude: {station.alt:.1f} m\")\n\n# Access metadata properties\nprops = station.properties\nprint(f\"\\nProvider: {props['provider']}\")\nprint(f\"Frequency bands: {', '.join(props['frequency_bands'])}\")\n\n# Show all stations with their locations\nprint(f\"\\n{len(stations)} KSAT Stations:\")\nfor i, gs in enumerate(stations, 1):\n    gs_name = gs.get_name() if gs.get_name() else \"Unknown\"\n    print(f\"{i:2d}. {gs_name:30s} ({gs.lat:7.3f}\u00b0, {gs.lon:8.3f}\u00b0)\")\n\n# Expected output:\n# Station: Prudhoe Bay\n# Latitude: 70.2000\u00b0\n# Longitude: -148.4700\u00b0\n# Altitude: 0.0 m\n\n# Provider: KSAT\n# Frequency bands: S, X\n\n# 36 KSAT Stations:\n#  1. Prudhoe Bay                    ( 70.200\u00b0, -148.470\u00b0)\n#  2. Athens                         ( 37.850\u00b0,   22.620\u00b0)\n#  3. Awarua                         (-46.530\u00b0,  168.380\u00b0)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load KSAT groundstations\n    let stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n\n    // Access the first station\n    let station = &amp;stations[0];\n\n    // Geographic coordinates (degrees and meters)\n    let name = station.get_name().unwrap_or(\"Unknown\");\n    println!(\"Station: {}\", name);\n    println!(\"Latitude: {:.4}\u00b0\", station.lat());\n    println!(\"Longitude: {:.4}\u00b0\", station.lon());\n    println!(\"Altitude: {:.1} m\", station.alt());\n\n    // Show all stations with their locations\n    println!(\"\\n{} KSAT Stations:\", stations.len());\n    for (i, gs) in stations.iter().enumerate() {\n        let gs_name = gs.get_name().unwrap_or(\"Unknown\");\n        println!(\n            \"{:2}. {:30} ({:7.3}\u00b0, {:8.3}\u00b0)\",\n            i + 1,\n            gs_name,\n            gs.lat(),\n            gs.lon()\n        );\n    }\n\n    // Expected output:\n    // Station: Prudhoe Bay\n    // Latitude: 70.2000\u00b0\n    // Longitude: -148.4700\u00b0\n    // Altitude: 0.0 m\n\n    // 36 KSAT Stations:\n    //  1. Prudhoe Bay                    ( 70.200\u00b0, -148.470\u00b0)\n    //  2. Athens                         ( 37.850\u00b0,   22.620\u00b0)\n    //  3. Awarua                         (-46.530\u00b0,  168.380\u00b0)\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#computing-access-windows","title":"Computing Access Windows","text":"<p>Use groundstation data with brahe's access computation to find contact opportunities:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load groundstations from a provider\nstations = bh.datasets.groundstations.load(\"ksat\")\nprint(f\"Computing access for {len(stations)} KSAT stations\")\n\n# Create a sun-synchronous orbit satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"EO-Sat\")\n\n# Define access constraint (minimum 5\u00b0 elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\n\n# Compute access windows for 24 hours\nduration = 24.0 * 3600.0  # seconds\nwindows = bh.location_accesses(\n    stations, [propagator], epoch, epoch + duration, constraint\n)\n\n# Display results\nprint(f\"\\nTotal access windows: {len(windows)}\")\nprint(\"\\nFirst 5 windows:\")\nfor i, window in enumerate(windows[:5], 1):\n    duration_min = (window.end - window.start) / 60.0\n    print(f\"{i}. {window.location_name:20s} -&gt; {window.satellite_name:10s}\")\n    print(f\"   Start: {window.start}\")\n    print(f\"   Duration: {duration_min:.1f} minutes\")\n\n# Expected output:\n# Computing access for 36 KSAT stations\n\n# Total access windows: 213\n\n# First 5 windows:\n# 1. Long Beach           -&gt; EO-Sat\n#    Start: 2024-01-01 00:05:08.313 UTC\n#    Duration: 8.9 minutes\n# 2. Thomaston            -&gt; EO-Sat\n#    Start: 2024-01-01 00:07:15.029 UTC\n#    Duration: 1.7 minutes\n# 3. Inuvik               -&gt; EO-Sat\n#    Start: 2024-01-01 00:13:53.159 UTC\n#    Duration: 10.1 minutes\n# 4. Fairbanks            -&gt; EO-Sat\n#    Start: 2024-01-01 00:14:39.836 UTC\n#    Duration: 8.3 minutes\n# 5. Prudhoe Bay          -&gt; EO-Sat\n#    Start: 2024-01-01 00:15:18.853 UTC\n#    Duration: 9.7 minutes\n</code></pre> <pre><code>use brahe as bh;\nuse bh::access::location_accesses;\nuse bh::utils::Identifiable;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Load groundstations from a provider\n    let stations = bh::datasets::groundstations::load_groundstations(\"ksat\").unwrap();\n    println!(\"Computing access for {} KSAT stations\", stations.len());\n\n    // Create a sun-synchronous orbit satellite\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 600e3,\n        0.001,\n        97.8_f64.to_radians(),\n        0.0,\n        0.0,\n        0.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Radians);\n    let propagator =\n        bh::KeplerianPropagator::from_eci(epoch, state, 60.0).with_name(\"EO-Sat\");\n\n    // Define access constraint (minimum 5\u00b0 elevation)\n    let constraint = bh::ElevationConstraint::new(Some(5.0), None).unwrap();\n\n    // Compute access windows for 24 hours\n    let duration = 24.0 * 3600.0; // seconds\n    let windows = location_accesses(\n        &amp;stations,\n        &amp;vec![propagator],\n        epoch,\n        epoch + duration,\n        &amp;constraint,\n        None,\n        None,\n        None,\n    ).unwrap();\n\n    // Display results\n    println!(\"\\nTotal access windows: {}\", windows.len());\n    println!(\"\\nFirst 5 windows:\");\n    for (i, window) in windows.iter().take(5).enumerate() {\n        let duration_min = (window.end() - window.start()) / 60.0;\n        let loc_name = window.location_name.as_deref().unwrap_or(\"Unknown\");\n        let sat_name = window.satellite_name.as_deref().unwrap_or(\"Unknown\");\n        println!(\n            \"{}. {:20} -&gt; {:10}\",\n            i + 1,\n            loc_name,\n            sat_name\n        );\n        println!(\"   Start: {}\", window.start());\n        println!(\"   Duration: {:.1} minutes\", duration_min);\n    }\n\n    // Expected output:\n    // Computing access for 36 KSAT stations\n\n    // Total access windows: 213\n\n    // First 5 windows:\n    // 1. Long Beach           -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:05:08.313 UTC\n    //    Duration: 8.9 minutes\n    // 2. Thomaston            -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:07:15.029 UTC\n    //    Duration: 1.7 minutes\n    // 3. Inuvik               -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:13:53.159 UTC\n    //    Duration: 10.1 minutes\n    // 4. Fairbanks            -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:14:39.836 UTC\n    //    Duration: 8.3 minutes\n    // 5. Prudhoe Bay          -&gt; EO-Sat    \n    //    Start: 2024-01-01 00:15:18.853 UTC\n    //    Duration: 9.7 minutes\n}\n</code></pre>"},{"location":"learn/datasets/groundstations.html#data-format","title":"Data Format","text":"<p>Each groundstation is represented as a <code>PointLocation</code> with standardized properties:</p> <pre><code>import brahe as bh\n\nstations = bh.datasets.groundstations.load(\"ksat\")\nstation = stations[0]\n\n# Geographic coordinates (WGS84)\nlon = station.lon()      # Longitude in degrees\nlat = station.lat()      # Latitude in degrees\nalt = station.alt()      # Altitude in meters\n\n# Metadata properties\nprops = station.properties\nname = station.get_name()              # Station name\nprovider = props[\"provider\"]            # Provider name (e.g., \"KSAT\")\nbands = props[\"frequency_bands\"]        # Supported bands (e.g., [\"S\", \"X\"])\n</code></pre> <p>All groundstations include these standard properties:</p> <ul> <li><code>provider</code>: Provider name (string, e.g., \"KSAT\", \"Atlas\")</li> <li><code>frequency_bands</code>: List of supported frequency bands (e.g., <code>[\"S\", \"X\", \"Ka\"]</code>)</li> </ul> <p>Additional properties may be included in future releases as data becomes available.</p>"},{"location":"learn/datasets/groundstations.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets in Brahe</li> <li>Groundstation API Reference - Complete function documentation</li> </ul>"},{"location":"learn/datasets/naif.html","title":"NAIF Ephemeris Kernels","text":"<p>NAIF (Navigation and Ancillary Information Facility) is NASA JPL's archive for planetary ephemeris data. Brahe provides functions to download DE (Development Ephemeris) kernels, which contain high-precision position and velocity data for solar system bodies.</p> <p>What are DE Kernels?</p> <p>DE kernels are binary SPK (SPICE Kernel) files containing numerical integration results for planetary positions and velocities. Each version represents a different JPL Development Ephemeris model, with newer versions incorporating improved observations and models.</p>"},{"location":"learn/datasets/naif.html#supported-kernels","title":"Supported Kernels","text":"<p>Brahe supports downloading the following DE kernel files:</p> Kernel File Size Description <code>de430</code> ~114 MB Standard precision, extended time span <code>de432s</code> ~32 MB Designed for New Horizons Targeting Pluto <code>de435</code> ~114 MB Higher accuracy for inner planets <code>de440</code> ~114 MB Latest standard precision <code>de440s</code> ~33 MB Latest small variant of DE440 <code>de442</code> ~114 MB Intendended for MESSENGER mission to Mercury <code>de442s</code> ~33 MB Small variant of DE442 <p>Choosing a Kernel</p> <p>For most applications, <code>de440s</code> provides a good balance between file size and accuracy. The \"s\" (small) variants cover a shorter time span but are significantly smaller files.</p>"},{"location":"learn/datasets/naif.html#caching-behavior","title":"Caching Behavior","text":"<p>DE kernels are large files that do not change over time. Brahe implements permanent caching:</p> <ul> <li>Cache location: <code>~/.cache/brahe/naif/</code> (or <code>$BRAHE_CACHE/naif/</code> if set)</li> <li>Cache duration: Permanent (kernels are stable long-term products)</li> <li>Cache check: Simple file existence check - no age validation</li> </ul> <p>Once a kernel is downloaded, it remains cached indefinitely and subsequent calls return the cached file path without re-downloading.</p>"},{"location":"learn/datasets/naif.html#usage","title":"Usage","text":""},{"location":"learn/datasets/naif.html#basic-download","title":"Basic Download","text":"<p>Download a kernel and use the cached location:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Download de440s kernel (smaller variant, ~33MB)\n# This will download once and cache for future use\nkernel_path = bh.datasets.naif.download_de_kernel(\"de440s\")\n\nprint(f\"Kernel cached at: {kernel_path}\")\n\n# Subsequent calls use the cached file - no re-download\nkernel_path_again = bh.datasets.naif.download_de_kernel(\"de440s\")\nprint(f\"Retrieved from cache: {kernel_path_again}\")\n\n# Optionally copy to a specific location\noutput_path = \"/tmp/my_kernel.bsp\"\ncopied_path = bh.datasets.naif.download_de_kernel(\"de440s\", output_path)\nprint(f\"Copied to: {copied_path}\")\n\n# Expected output:\n# Kernel cached at: /Users/username/.cache/brahe/naif/de440s.bsp\n# Retrieved from cache: /Users/username/.cache/brahe/naif/de440s.bsp\n# Copied to: /tmp/my_kernel.bsp\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Download de440s kernel (smaller variant, ~33MB)\n    // This will download once and cache for future use\n    let kernel_path = bh::datasets::naif::download_de_kernel(\"de440s\", None).unwrap();\n\n    println!(\"Kernel cached at: {}\", kernel_path.display());\n\n    // Subsequent calls use the cached file - no re-download\n    let kernel_path_again = bh::datasets::naif::download_de_kernel(\"de440s\", None).unwrap();\n    println!(\"Retrieved from cache: {}\", kernel_path_again.display());\n\n    // Optionally copy to a specific location\n    let output_path = std::path::PathBuf::from(\"/tmp/my_kernel.bsp\");\n    let copied_path = bh::datasets::naif::download_de_kernel(\"de440s\", Some(output_path)).unwrap();\n    println!(\"Copied to: {}\", copied_path.display());\n\n    // Expected output:\n    // Kernel cached at: /Users/username/.cache/brahe/naif/de440s.bsp\n    // Retrieved from cache: /Users/username/.cache/brahe/naif/de440s.bsp\n    // Copied to: /tmp/my_kernel.bsp\n}\n</code></pre> <p>The first call downloads and caches the kernel. Subsequent calls immediately return the cached file path.</p>"},{"location":"learn/datasets/naif.html#error-handling","title":"Error Handling","text":"<p>The function validates kernel names before attempting downloads. Invalid kernel names raise an error immediately:</p> PythonRust <pre><code>try:\n    bh.datasets.naif.download_de_kernel(\"de999\")\nexcept RuntimeError as e:\n    print(e)\n    # \"Unsupported kernel name 'de999'. Supported kernels: de430, de432s, ...\"\n</code></pre> <pre><code>match bh::datasets::naif::download_de_kernel(\"de999\", None) {\n    Ok(_) =&gt; println!(\"Success\"),\n    Err(e) =&gt; println!(\"Error: {}\", e),\n    // Error: Unsupported kernel name 'de999'. Supported kernels: de430, de432s, ...\n}\n</code></pre>"},{"location":"learn/datasets/naif.html#see-also","title":"See Also","text":"<ul> <li>NAIF SPICE System - Full SPICE toolkit documentation</li> <li>DE Kernel Details - Detailed descriptions of each DE version</li> <li>Library API Reference - Complete function documentation</li> </ul>"},{"location":"learn/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth Orientation Parameters (EOP) are essential corrections that account for irregularities in Earth's rotation. They are required for high-precision transformations between inertial (ECI) and Earth-fixed (ECEF) reference frames.</p>"},{"location":"learn/eop/index.html#overview","title":"Overview","text":"<p>Earth's rotation is not perfectly uniform or predictable due to:</p> <ul> <li>Polar motion: Wobble of Earth's rotation axis relative to its crust</li> <li>UT1-UTC offset: Variations in Earth's rotation rate</li> <li>Nutation: Short-period oscillations in Earth's axis orientation</li> </ul> <p>EOP data provides the corrections needed to accurately transform between coordinate systems, which is critical for:</p> <ul> <li>Satellite orbit determination</li> <li>Ground station tracking</li> <li>Precision timing</li> <li>Navigation and geodesy</li> </ul>"},{"location":"learn/eop/index.html#why-eop-matters","title":"Why EOP Matters","text":""},{"location":"learn/eop/index.html#without-eop","title":"Without EOP","text":"<p>Coordinate transformations using only theoretical models (precession, nutation) can have errors of:</p> <ul> <li>Position errors: 10-30 meters</li> <li>Velocity errors: mm/s level</li> <li>Timing errors: Milliseconds to seconds</li> </ul>"},{"location":"learn/eop/index.html#with-eop","title":"With EOP","text":"<p>Including measured EOP values reduces errors to:</p> <ul> <li>Position errors: &lt; 1 meter</li> <li>Velocity errors: Sub-mm/s</li> <li>Timing accuracy: Sub-millisecond</li> </ul> <p>For most satellite applications, EOP is required for accurate results.</p>"},{"location":"learn/eop/index.html#eop-parameters","title":"EOP Parameters","text":"<p>Brahe uses five primary EOP parameters:</p> Parameter Description Typical Range Units <code>x_p</code> Polar motion X component \u00b10.7 arcsec arcseconds <code>y_p</code> Polar motion Y component \u00b10.7 arcsec arcseconds <code>UT1_UTC</code> UT1 minus UTC time offset \u00b10.9 seconds seconds <code>dX</code> Celestial pole X offset \u00b10.0003 arcsec arcseconds <code>dY</code> Celestial pole Y offset \u00b10.0003 arcsec arcseconds <p>Additionally, derivatives are used for interpolation: - <code>LOD</code>: Length of day variations - Rates of change for <code>x_p</code> and <code>y_p</code></p>"},{"location":"learn/eop/index.html#eop-data-sources","title":"EOP Data Sources","text":"<p>EOP values are measured by the International Earth Rotation and Reference Systems Service (IERS) using:</p> <ul> <li>Very Long Baseline Interferometry (VLBI)</li> <li>Satellite Laser Ranging (SLR)</li> <li>Global Navigation Satellite Systems (GNSS)</li> <li>Doppler Orbitography and Radiopositioning Integrated by Satellite (DORIS)</li> </ul> <p>IERS publishes several data products:</p> <ul> <li>Finals2000A.all: Combined observed + predicted values (recommended)</li> <li>EOP C04: Long-term series with consistent processing</li> <li>Rapid: Near real-time values updated daily</li> <li>Predictions: Future values (lower accuracy)</li> </ul>"},{"location":"learn/eop/index.html#managing-eop-in-brahe","title":"Managing EOP in Brahe","text":"<p>Brahe provides three EOP provider types:</p>"},{"location":"learn/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Loads EOP data from IERS files for production use:</p> <pre><code>import brahe as bh\n\n# Download latest EOP data\nbh.download_iers_eop_data()\n\n# Load from standard location\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# Set as global provider\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: Production applications requiring maximum accuracy.</p>"},{"location":"learn/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Uses built-in historical EOP data or constant values:</p> <pre><code># Use built-in data (covers ~1990-2024)\neop = bh.StaticEOPProvider.from_static_data()\n\n# Or use constant values (for testing)\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: - Testing and development - Historical analysis within built-in data range - Applications where 10-30m accuracy is acceptable</p>"},{"location":"learn/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Wraps another provider with caching for performance:</p> <pre><code># Wrap file provider with cache\nfile_provider = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\ncached_provider = bh.CachingEOPProvider(file_provider, cache_size=1000)\n\nbh.set_global_eop_provider(cached_provider)\n</code></pre> <p>When to use: High-frequency EOP queries at similar epochs (e.g., batch processing).</p> <p>See: Managing EOP Data</p>"},{"location":"learn/eop/index.html#global-eop-provider","title":"Global EOP Provider","text":"<p>Brahe uses a global EOP provider that is accessed automatically during frame transformations:</p> <pre><code># Set global provider (do this once at program start)\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# Frame transformations automatically use global EOP\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)  # Uses global EOP\n</code></pre> <p>Important: The global provider must be set before any frame transformations, or an error will occur.</p>"},{"location":"learn/eop/index.html#workflow","title":"Workflow","text":""},{"location":"learn/eop/index.html#production-application","title":"Production Application","text":"<pre><code>import brahe as bh\n\n# 1. Download latest EOP data (run periodically, e.g., weekly)\nbh.download_iers_eop_data()\n\n# 2. Load EOP provider at program startup\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# 3. Perform frame transformations (EOP used automatically)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n</code></pre>"},{"location":"learn/eop/index.html#testingdevelopment","title":"Testing/Development","text":"<pre><code>import brahe as bh\n\n# Use static EOP for reproducible tests\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider(eop)\n\n# All transformations use zero EOP values\n# Results are deterministic but less accurate\n</code></pre>"},{"location":"learn/eop/index.html#eop-data-management","title":"EOP Data Management","text":""},{"location":"learn/eop/index.html#downloading-updates","title":"Downloading Updates","text":"<p>EOP data should be updated periodically:</p> <pre><code># Download latest data\nbh.download_iers_eop_data()\n\n# Reload provider with new data\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n</code></pre> <p>Update frequency: - Real-time applications: Daily - Planning applications: Weekly - Historical analysis: Not needed (use archived data)</p>"},{"location":"learn/eop/index.html#data-file-location","title":"Data File Location","text":"<p>By default, EOP files are stored in: - Unix/Linux/macOS: <code>~/.brahe/</code> - Windows: <code>C:\\Users\\&lt;username&gt;\\.brahe\\</code></p> <p>Files are cached locally and reused until updated.</p>"},{"location":"learn/eop/index.html#eop-data-coverage","title":"EOP Data Coverage","text":"<p>IERS publishes: - Historical: Observed values from 1973 to ~7 days ago - Recent: Rapid service values (updated daily) - Future: Predictions up to 1 year ahead (less accurate)</p> <p>For dates beyond prediction range, extrapolation is used (accuracy degrades).</p>"},{"location":"learn/eop/index.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/eop/index.html#eop-query-cost","title":"EOP Query Cost","text":"<p>Querying EOP data requires: 1. Date conversion (epoch \u2192 MJD) 2. Table lookup or interpolation 3. Parameter extraction</p> <p>Typical cost: 1-10 microseconds per query</p>"},{"location":"learn/eop/index.html#caching-strategy","title":"Caching Strategy","text":"<p>For repeated transformations at similar epochs:</p> <pre><code># Without caching: ~10 \u03bcs per EOP query\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# With caching: ~0.1 \u03bcs per cached query\ncached_eop = bh.CachingEOPProvider(eop, cache_size=1000)\n</code></pre> <p>Caching provides 100\u00d7 speedup for repeated queries.</p>"},{"location":"learn/eop/index.html#batch-operations","title":"Batch Operations","text":"<p>When transforming many states at the same epoch:</p> <pre><code># Query EOP once, reuse for all transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# EOP queried once internally\nfor state in states:\n    state_ecef = bh.state_eci_to_ecef(state, epoch)  # Reuses cached EOP\n</code></pre>"},{"location":"learn/eop/index.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/eop/index.html#startup-initialization","title":"Startup Initialization","text":"<pre><code>def initialize_eop():\n    \"\"\"Initialize EOP provider at application startup\"\"\"\n    try:\n        # Try to use file-based EOP\n        eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    except Exception:\n        # Fall back to static EOP if file not found\n        print(\"Warning: Using static EOP data (reduced accuracy)\")\n        eop = bh.StaticEOPProvider.from_static_data()\n\n    bh.set_global_eop_provider(eop)\n\n# Call at program start\ninitialize_eop()\n</code></pre>"},{"location":"learn/eop/index.html#periodic-updates","title":"Periodic Updates","text":"<pre><code>import schedule\nimport brahe as bh\n\ndef update_eop_data():\n    \"\"\"Download and reload EOP data\"\"\"\n    bh.download_iers_eop_data()\n    eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    bh.set_global_eop_provider(eop)\n    print(\"EOP data updated\")\n\n# Schedule weekly updates\nschedule.every().monday.at(\"02:00\").do(update_eop_data)\n</code></pre>"},{"location":"learn/eop/index.html#testing-with-controlled-eop","title":"Testing with Controlled EOP","text":"<pre><code>import pytest\nimport brahe as bh\n\n@pytest.fixture(autouse=True)\ndef setup_eop():\n    \"\"\"Setup zero EOP for deterministic tests\"\"\"\n    eop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    bh.set_global_eop_provider(eop)\n    yield\n    # Cleanup if needed\n\ndef test_frame_transformation():\n    # Test uses zero EOP values (deterministic)\n    epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n    state_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n    # Assert expected values...\n</code></pre>"},{"location":"learn/eop/index.html#see-also","title":"See Also","text":"<ul> <li>What is EOP Data? - Detailed explanation of EOP parameters and why they matter</li> <li>Managing EOP Data - Practical guide to EOP providers and data management</li> <li>Frame Transformations - How EOP is used in coordinate transformations</li> <li>EOP API Reference - Complete EOP provider documentation</li> <li>IERS Website - Official source for EOP data</li> </ul>"},{"location":"learn/eop/managing_eop_data.html","title":"Managing EOP Data","text":"<p>Generally, users of brahe will not need to directly manage Earth orientation data. The package provides default data files and the <code>CachingEOPProvider</code> to automatically update data as needed. However, for advanced users or those with specific data requirements, brahe provides functionality to load and manage Earth orientation data manually.</p> <p>To make the package interface ergonommic, brahe functions do not explicitly accept Earth orientation data as input parameters. Instead, there is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions.</p> <p>If you want to skip understanding Earth orientation data for now, you can initialize the global provider with zeroed values using the <code>initialize_eop()</code> function:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n}\n</code></pre> <p>Warning</p> <p>Earth orientation data MUST be initialized before using any functionality in brahe that requires Earth orientation data. If no data is initialized, brahe will panic and terminate the program when Earth orientation data is requested.</p>"},{"location":"learn/eop/managing_eop_data.html#earth-orientation-providers","title":"Earth Orientation Providers","text":"<p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>For the most accurate Earth orientation data modeling in scripts, you should download the latest available Earth orientation data for the desired model and the using the file-based loading methods. Alternatively you can the <code>CachingEOPProvider</code> to initialize the Earth orientation data which will automatically download and update the latest data files as needed.</p>"},{"location":"learn/eop/managing_eop_data.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>A static provider is one that just uses fixed values for Earth orientation parameters. This provider is useful for testing and development or if your application only requires low accuracy.</p> PythonRust <pre><code>import brahe as bh\n\n\n# Method 1: Static EOP Provider - All Zeros\neop_static_zeros = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(eop_static_zeros)\n\n# Method 2: Static EOP Provider - Constant Values\neop_static_values = bh.StaticEOPProvider.from_values(\n    0.001, 0.002, 0.003, 0.004, 0.005, 0.006\n)\nbh.set_global_eop_provider(eop_static_values)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Static EOP Provider - All Zeros\n    let eop_static_zeros = bh::eop::StaticEOPProvider::from_zero();\n    bh::eop::set_global_eop_provider(eop_static_zeros);\n\n    // Method 2: Static EOP Provider - Constant Values\n    let eop_static_values = bh::eop::StaticEOPProvider::from_values((0.001, 0.002, 0.003, 0.004, 0.005, 0.006));\n    bh::eop::set_global_eop_provider(eop_static_values);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#fileeopprovider","title":"FileEOPProvider","text":"<p>If you want to use high-accuracy Earth orientation data, you can load data from IERS files using the <code>FileEOPProvider</code>. Brahe provides functions to load default IERS data files provided with the package, or you can specify your own file paths.</p> <p>When creating any new file-based data provider there are two parameters that are set at loading time which will determine how the EOP instances handles data returns for times not in the loaded data.</p> <p>The first parameter is the <code>interpolate</code> setting. When <code>interpolate</code> is set to <code>True</code> and data set will be linearly interpolated to the desired time. When set to <code>False</code>, the function call will return the last value prior to the requested data. Given that IERS data is typically provided at daily intervals, it is generally recommended to enable interpolation for most applications.</p> <p>The second parameter is the <code>extrapolate</code> parameter, which can have a value of <code>Zero</code>, <code>Hold</code>, or <code>Error</code>. This value will determine how requests for data points beyond the end of the loaded data are handled. The possible behaviors are</p> <ul> <li><code>Zero</code>: Returned values will be <code>0.0</code> where data is not available</li> <li><code>Hold</code>: Will return the last available returned value when data is not available</li> <li><code>Error</code>: Data access attempts where data is not present will panic and terminate the program</li> </ul> <p>You can create a file-based Earth orientation provider by specifying the file paths to the desired data files as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n# File-based EOP Provider - Default IERS Standard with Hold Extrapolation\neop_file_default = bh.FileEOPProvider.from_default_standard(\n    True,  # Interpolation -&gt; if True times between data points are interpolated\n    \"Hold\",  # Extrapolation method -&gt; How accesses outside data range are handled\n)\nbh.set_global_eop_provider(eop_file_default)\n\n# File-based EOP Provider - Default C04 Standard with Zero Extrapolation\neop_file_c04 = bh.FileEOPProvider.from_default_c04(False, \"Zero\")\nbh.set_global_eop_provider(eop_file_c04)\n\n# Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\nif False:  # Change to True to enable custom file examples\n    # File-based EOP Provider - Custom Standard File\n    eop_file_custom = bh.FileEOPProvider.from_standard_file(\n        \"path_to_standard_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom)\n\n    # File-based EOP Provider - Custom C04 File\n    eop_file_custom_c04 = bh.FileEOPProvider.from_c04_file(\n        \"path_to_c04_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom_c04)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n    // File-based EOP Provider - Default IERS Standard with Hold Extrapolation\n    let eop_file_default = bh::eop::FileEOPProvider::from_default_standard(\n        true,                                   // Interpolation -&gt; if True times between data points are interpolated\n        bh::eop::EOPExtrapolation::Hold        // Extrapolation method -&gt; How accesses outside data range are handled\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_default);\n\n    // File-based EOP Provider - Default C04 Standard with Zero Extrapolation\n    let eop_file_c04 = bh::eop::FileEOPProvider::from_default_c04(\n        false,\n        bh::eop::EOPExtrapolation::Zero\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_c04);\n\n    // Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\n    if false {  // Change to true to enable custom file examples\n        // File-based EOP Provider - Custom Standard File\n        let eop_file_custom = bh::eop::FileEOPProvider::from_standard_file(\n            std::path::Path::new(\"path_to_standard_file.txt\"),  // Replace with actual file path\n            true,                                                 // Interpolation\n            bh::eop::EOPExtrapolation::Hold                      // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom);\n\n        // File-based EOP Provider - Custom C04 File\n        let eop_file_custom_c04 = bh::eop::FileEOPProvider::from_c04_file(\n            std::path::Path::new(\"path_to_c04_file.txt\"),  // Replace with actual file path\n            true,                                           // Interpolation\n            bh::eop::EOPExtrapolation::Hold                // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom_c04);\n    }\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>The <code>CachingEOPProvider</code> is a <code>FileEOPProvider</code> that automatically downloads and caches the latest Earth orientation data files from the IERS website as needed. It checks the age of the cached data and if the data is older than a specified value, it downloads the latest files, then loads them for use. This provider can also be configured to check for a stale cache on use and update the data if needed, which is useful for long-running applications.</p> <p>The <code>CachingEOPProvider</code> is the recommended provider for most applications as it provides high-accuracy Earth orientation data without requiring manual management of data files. <code>initialize_eop()</code> uses this provider by default.</p> <p>The interpolation and extrapolation parameters are also available when creating a <code>CachingEOPProvider</code>, with the same behavior as described for the <code>FileEOPProvider</code>.</p> PythonRust <pre><code>from pathlib import Path\nimport brahe as bh\n\n# Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider)\n\n# Method 2: Initialize from Caching EOP Provider with custom location\nprovider_custom = bh.CachingEOPProvider(\n    filepath=str(\n        Path(bh.get_brahe_cache_dir()) / \"my_eop.txt\"\n    ),  # Replace with desired file path to load / save from\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider_custom)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\n    let provider = bh::eop::CachingEOPProvider::new(\n        None,                                   // filepath (None for default cache location)\n        bh::eop::EOPType::StandardBulletinA,   // eop_type\n        7 * 86400,                             // max_age_seconds - Maximum age of file before refreshing\n        false,                                 // auto_refresh - Check staleness of every access\n        true,                                  // interpolate\n        bh::eop::EOPExtrapolation::Hold       // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider);\n\n    // Method 2: Initialize from Caching EOP Provider with custom location\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    let custom_filepath = std::path::Path::new(&amp;cache_dir).join(\"my_eop.txt\");\n    let provider_custom = bh::eop::CachingEOPProvider::new(\n        Some(&amp;custom_filepath),                        // Replace with desired file path to load / save from\n        bh::eop::EOPType::StandardBulletinA,           // eop_type\n        7 * 86400,                                     // max_age_seconds - Maximum age of file before refreshing\n        false,                                         // auto_refresh - Check staleness of every access\n        true,                                          // interpolate\n        bh::eop::EOPExtrapolation::Hold               // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider_custom);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#downloading-eop-data-files","title":"Downloading EOP Data Files","text":"<p>If you want to manually download Earth orientation data files to store or save them, brahe provides two means of doing so. The first is through the command-line interface (CLI) tool included with brahe. The second is through direct function calls in either the Rust or Python APIs.</p>"},{"location":"learn/eop/managing_eop_data.html#cli","title":"CLI","text":"<p>The brahe CLI command includes an <code>eop download</code> subcommand which can be used to download the latest Earth orientation data files from IERS servers.</p> <p>To download the latest standard product file, use the following command:</p> <pre><code>brahe eop download --product standard &lt;output_filepath&gt;\n</code></pre> <p>To download the latest C04 final product file, use the following command:</p> <pre><code>brahe eop download --product c04 &lt;output_filepath&gt;\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#functions","title":"Functions","text":"<p>You can also download Earth orientation data files directly using the <code>download_standard_eop_file</code> and <code>download_c04_eop_file</code> functions in the <code>brahe.eop</code> module.</p> <p>You can download the latest standard EOP data file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre> <pre><code>use brahe::eop::download_standard_eop_file;\n\n// Download latest C04 EOP data\ndownload_standard_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <p>Or download the latest C04 final product file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <pre><code>use brahe::eop::download_c04_eop_file;\n\n// Download latest C04 EOP data\ndownload_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#accessing-eop-parameters","title":"Accessing EOP Parameters","text":"<p>While not common it is possible to directly access Earth orientation parameters from the currently loaded global Earth orientation provider. This can be useful for debugging or analysis purposes.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Get current time\nepc = bh.Epoch.now()\n\nxp, yp, dut1, lod, dX, dY = bh.get_global_eop(epc.mjd())\n\nprint(f\"At epoch {epc}:\")\nprint(f\"  x_pole: {xp} arcseconds\")\nprint(f\"  y_pole: {yp} arcseconds\")\nprint(f\"  dut1: {dut1} seconds\")\nprint(f\"  length of day: {lod} seconds\")\nprint(f\"  dX: {dX} arcseconds\")\nprint(f\"  dY: {dY} arcseconds\")\n</code></pre> <pre><code>#[allow(unused_imports)]\nuse brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epc = bh::Epoch::now();\n    let (xp, yp, dut1, lod, dx, dy) = bh::get_global_eop(epc.mjd()).unwrap();\n\n    println!(\"At epoch {}:\", epc.to_string());\n    println!(\"xp:  {}\", xp);\n    println!(\"yp:  {}\", yp);\n    println!(\"dut1: {}\", dut1);\n    println!(\"lod:  {}\", lod);\n    println!(\"dX:   {}\", dx);\n    println!(\"dY:   {}\", dy);\n}\n</code></pre> <p>You can find more functions to access specific subsets of Earth orientation data in the API Reference.</p>"},{"location":"learn/eop/managing_eop_data.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider API Reference</li> <li>FileEOPProvider API Reference</li> <li>CachingEOPProvider API Reference</li> </ul>"},{"location":"learn/eop/what_is_eop_data.html","title":"What is EOP Data?","text":"<p>Earth Orientation Parameters are empirically observed, estimated parameters that describe the irregularities in Earth's rotation in space. When combined with their specific related models they provide the mechanism to transform between an Earth-Centered Earth-Fixed (ECEF) reference frame and an Earth-Centered Inertial (ECI) reference frame. These transformations are essential for accurate orbit propagation, coordinate transformations, and other space-related applications.</p> <p>Earth Orientation Parameters are stochastic meaning that they are random and cannot be predicted with perfect accuracy into the future. Therefore, Earth orientation data is continually observed, estimated, and updated by various international organizations. The International Earth Rotation and Reference Systems Service (IERS) is the primary organization responsible for providing Earth orientation data products and maintaining the associated reference frames and systems.</p> <p>For example the predicted evolution of the offset between solar time (UT1) and Coordinated Universal Time (UTC) is show below. The difference between UT1 and UTC is primarily driven by variations in Earth's rotation rate, which are influenced by factors such as tidal forces, atmospheric dynamics, and core-mantle interactions. As a result, the UT1-UTC offset exhibits irregular fluctuations that cannot be precisely predicted far into the future.</p> Plot Source fig_ut1_utc_offset.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# ------------------------------\n# Configuration\n# ------------------------------\n\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# ------------------------------\n\n# Initialize IERS EOP Data\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(eop)\n\n## Generate plot data\n\n# Get range of dates stored in EOP data\nmjd_min = bh.get_global_eop_mjd_min()\nmjd_max = bh.get_global_eop_mjd_max()\nmjd_now = bh.Epoch.now().mjd()\n\nprint(\"EOP MJD Range:\", mjd_min, \"to\", mjd_max)\nprint(\"Current MJD (now):\", mjd_now)\n\n# Split data into past (solid) and predicted (dashed)\ndays_past = np.arange(mjd_min, min(mjd_now, mjd_max), 1)\ndays_predicted = np.arange(max(mjd_now, mjd_min), mjd_max, 1)\n\n# Get UT1-UTC offsets\nut1_utc_past = [bh.get_global_ut1_utc(mjd) for mjd in days_past]\nut1_utc_predicted = [bh.get_global_ut1_utc(mjd) for mjd in days_predicted]\n\n# Get year range for x-axis tick labels\nepoch_min = bh.Epoch.from_mjd(mjd_min, bh.TimeSystem.UTC)\nepoch_max = bh.Epoch.from_mjd(mjd_max, bh.TimeSystem.UTC)\nyear_min = epoch_min.to_datetime()[0]\nyear_max = epoch_max.to_datetime()[0]\n\n\n## Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Plot past data (solid line) - use primary color\n    fig.add_trace(\n        go.Scatter(\n            x=days_past,\n            y=ut1_utc_past,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n            name=\"Past (Measured)\",\n            showlegend=True,\n        )\n    )\n\n    # Plot predicted data (dashed line) - use error color\n    fig.add_trace(\n        go.Scatter(\n            x=days_predicted,\n            y=ut1_utc_predicted,\n            mode=\"lines\",\n            line=dict(color=colors[\"error\"], width=2, dash=\"dash\"),\n            name=\"Future (Predicted)\",\n            showlegend=True,\n        )\n    )\n\n    # Create custom tick values and labels for x-axis (years)\n    # Generate tick positions every 5 years\n    tick_mjds = []\n    tick_labels = []\n    for year in range(year_min, year_max + 1, 5):\n        epoch = bh.Epoch.from_datetime(year, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n        tick_mjds.append(epoch.mjd())\n        tick_labels.append(str(year))\n\n    # Configure axes (theme-agnostic settings)\n    fig.update_xaxes(\n        tickmode=\"array\",\n        tickvals=tick_mjds,\n        ticktext=tick_labels,\n        title_text=\"Year\",\n        range=[mjd_min, mjd_max],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"array\",\n        tickvals=[-1.0, -0.5, 0.0, 0.5, 1.0],\n        title_text=\"UT1-UTC Offset Magnitude [s]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/eop/what_is_eop_data.html#iers","title":"IERS","text":"<p>The International Earth Rotation Service (IERS) was established in 1987 by the International Astronomical Union and the International Union of Geodesy and Geophysics. The IERS provides data on Earth orientation, on the International Celestial Reference System/Frame, and on the International Terrestrial Reference System/Frame. The IERS also maintains conventions containing models, constants, and standards used for modeling Earth orientation.</p> <p>The IERS deals with reference systems and reference frames. A reference system is an idealized mathematical concept for defining a reference used to represent the state of objects in that system. The two primary reference systems developed by the IERS are the International Celestial Reference System (ICRS) and International Terrestrial Reference System (ITRS). The ICRS is an inertial reference system and the one we used to define Earth-centered inertial (ECI) reference frames in brahe. The ITRS is a rotating reference system fixed to the Earth and is used to define Earth-centered, Earth-fixed (ECEF*) reference frames in the packge.</p> <p>A reference system is a concept and cannot be used directly. For example you can say that you'll represent all coordinates in the world with respect to the the North Star, but to actually use that reference you need to define how to measure positions with respect to it. Therefore the IERS develops reference frames, which are specific realizations of a given reference system. A reference frame realization defines the models, standards, and associated data products for users to actually interact and usethat reference system. The primary reference frames of the IERS are the International Celestial Reference Frame (ICRF) and International Terrestrial Reference Frame (ITRF).</p> <p>The ICRS and ITRS models are defined with respect to the solar system barycenter<sup>1</sup>. However, for many satellite-specific engineering applications we are primarily concerned with geocentric references, centered at Earth. Therefore, brahe primarily deals with the Geocentric Celestial Reference Frame (GCRF) and Geocentric Terrestrial Reference Frame (GTRF). For most intents and purposes the international and geocentric references are identical as there is no rotation component between ICRS and GCRS (or ITRF and GCRF)<sup>2</sup>. The transformation between the two reference systems and frames is simply a pure translation.</p> <p>For a more detailed discussion of reference frames and systems please read IERS Technical Note 36 provides an in-depth discussion of the concepts presented and discussed here.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-products","title":"Earth Orientation Products","text":"<p>The IERS provides various Earth orientation products which are derived from Very Long Baseline Interferometry (VLBI) or a network of terrestrial GPS<sup>3</sup>  reference stations. The continual observations made by these stations are  combined with specific reference frame realizations (e.g. the IAU 2010  conventions) to model Earth orientation and enable the transformation between  inertial and Earth-fixed reference frames.</p> <p>The Earth orientation parameter products come in multiple variations, all of which can be found at the IERS data products site. These variations arise from the selection of precession-nutation model, ITRF realization, the data sources, and data processing time span. There are two precession-nutation models widely in use today: IAU 1980 nutation theory andthe IAU2006/2000A precession-nutation model. The ITRF 2014 realization is the most recent realization and preferred in most cases.</p> <p>For data products there are two primary distinctions: standard products and long term products. Standard products, which are produced daily, to provide a daily estimate of the past Earth orientation along with forward-looking predictions available for use in planning. Long term data products are only available for past days, and are produced less frequently, but provider higher accurate estimates of Earth orientation. </p> <p>For most purposes the standard products provide sufficient accuracy along with the benefit of having fairly accurate forward-looking predictions. Therefore, brahe defaults to using standard Earth Orientation data products wherever possible. Unless otherwise stated or specified, brahe uses IERS standard product generated with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-parameters","title":"Earth Orientation Parameters","text":"<p>The primary Earth orientation parameters provided by the IERS are polar motion coefficients (\\(x_p\\), \\(y_p\\)), UTC-UT1 time system offset (\\(\\Delta_{UTC}\\)), celestial pole offsets (\\(dX\\), \\(dY\\)), and length of day (\\(LOD\\)) corrections. These parameters are used in combination with specific models to compute the transformation between ECEF and ECI reference frames.</p> <p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>There is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions. See the Managing EOP Data page for more information on loading and managing Earth orientation data in brahe.</p> <ol> <li> <p>A barycenter is the center of mass of two or more bodies. The solar  system barycenter is the center of mass of the entire solar system. Due to  significant mass contributions and distances of Jupiter and Saturn, the  solar system barycenter evolves in time and is sometimes outside of the  Sun's outer radius.\u00a0\u21a9</p> </li> <li> <p>For applications requiring the highest levels of fidelity, the  equations of motion of an Earth satellite, with respect to the  GCRS will contain a relativistic Coriolis force due to geodesic precession  not present in the ICRS.\u00a0\u21a9</p> </li> <li> <p>Now frequently GNSS receivers\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/frames/index.html","title":"Reference Frames","text":"<p>Reference frame transformations are a fundamental aspect of astrodynamics. Different tasks require working in different reference frames, and accurate transformations between these frames are essential for precise calculations.</p> <p>Brahe uses the IAU SOFA (Standards of Fundamental Astronomy) C library for reference frame transformations to provide speed, accuracy, and reliability. To learn more about these models, refer to the IERS Conventions (2010).</p>"},{"location":"learn/frames/index.html#reference-frame-types","title":"Reference Frame Types","text":""},{"location":"learn/frames/index.html#inertial-frames-non-rotating","title":"Inertial Frames (Non-Rotating)","text":"<p>Inertial reference frames are fixed with respect to distant stars and do not rotate. They are ideal for integrating equations of motion as they do not require the addition of fictitious forces.</p> <p>Inertial reference frames currently supported in Brahe are:</p> <ul> <li>GCRF (Geocentric Celestial Reference Frame): The standard modern inertial reference frame for Earth-orbiting satellites, aligned with the International Celestial Reference Frame (ICRF)</li> <li>EME2000 (Earth Mean Equator and Equinox of J2000.0): Classical J2000.0 mean equator and mean equinox inertial frame. Derived from the FK5 catalog and widely used in older systems</li> </ul>"},{"location":"learn/frames/index.html#earth-fixed-frames-rotating","title":"Earth-Fixed Frames (Rotating)","text":"<p>Earth-fixed reference frames rotate with the Earth and are ideal for computing positions and motions relative to terrestrial locations and observers.</p> <p>Earth-fixed reference frames currently supported in Brahe are:</p> <ul> <li>ITRF (International Terrestrial Reference Frame): The standard Earth-fixed reference frame maintained by IERS, rotating with the Earth and aligned with geographic coordinates</li> </ul>"},{"location":"learn/frames/index.html#available-transformations","title":"Available Transformations","text":"<p>We can visualize the relations between the relevants reference frames and their transformations as follows</p> <p>The CIRS and TIRS frames are intermediate steps in the transformation process and are not directly exposed in Brahe's API. If you need to work with these frames, you can construct them manually using the provided functions for bias-precession-nutation, Earth rotation, and polar motion. Refer directly to the source code for details.</p> <p>Which Methods Should I Use?</p> <p>If you always want to use the most accurate and up-to-date reference frame transformations, use the ECI \u2194 ECEF functions. These functions will always map to the best available transformations in Brahe.</p> <p>If you want to make sure your results are reproducible and consistent over time, use the explicit GCRF \u2194 ITRF functions. This ensures that your code will always use the same transformation models, even if Brahe introduces improved models in the future.</p>"},{"location":"learn/frames/index.html#eci-ecef-common-naming","title":"ECI \u2194 ECEF (Common Naming)","text":"<p>Generic \"Earth-Centered Inertial\" and \"Earth-Centered Earth-Fixed\" naming convention that currently maps to GCRF and ITRF using conventions. This naming is widely used in the astrodynamics community.</p> <p>The ECI/ECEF naming is provided as a convenient alias for the commonly used terminology, and seeks to always provide the \"best\" available transformation between inertial and Earth-fixed frames. The transformation that underpins ECI \u2194 ECEF conversions is currently the IAU 2010 GCRF \u2194 ITRF transformations, but may differ in the future if improved reference frame models are introduced and adopted.</p> <p>Learn more in ECI \u2194 ECEF Naming Convention</p>"},{"location":"learn/frames/index.html#gcrf-itrf","title":"GCRF \u2194 ITRF","text":"<p>The primary transformation for modern applications, converting between the inertial GCRF and Earth-fixed ITRF frames. The transformation is accomplished using the IAU 2006/2000A, CIO-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook. This transformation accounts for:</p> <ul> <li>Earth's rotation</li> <li>Polar motion</li> <li>Precession and nutation effects</li> </ul> <p>Learn more in GCRF \u2194 ITRF Transformations</p>"},{"location":"learn/frames/index.html#eme2000-gcrf","title":"EME2000 \u2194 GCRF","text":"<p>A constant frame bias transformation between the classical J2000.0 frame (Earth Equator and Mean Equinox) and the modern ICRS-aligned GCRF. The transformation is accomplished using the second-order frame bias rotation matrix as described in Astrodynamics Convention and Modeling Reference for Lunar, Cislunar, and Libration Point Orbits by Folta et al., section 4.3.5.</p> <p>Learn more in EME2000 \u2194 GCRF Transformations</p>"},{"location":"learn/frames/eci_ecef.html","title":"ECI \u2194 ECEF Transformations","text":"<p>The ECI (Earth-Centered Inertial) and ECEF (Earth-Centered Earth-Fixed) naming convention is a traditional and widely-used terminology in the astrodynamics community.</p> <p>Naming Convention</p> <p>Brahe provides two sets of function names for frame transformations, both currently mapping to the same underlying implementations:</p> <ul> <li>ECI/ECEF naming: Common coordinate system names (e.g., <code>rotation_eci_to_ecef</code>, <code>state_eci_to_ecef</code>)</li> <li>GCRF/ITRF naming: Explicit reference frame names (e.g., <code>rotation_gcrf_to_itrf</code>, <code>state_gcrf_to_itrf</code>)</li> </ul> <p>The ECI/ECEF naming will always use the \"best\" available transformations in Brahe, while the GCRF/ITRF naming ensures consistent use of specific reference frame implementations.</p>"},{"location":"learn/frames/eci_ecef.html#reference-frames","title":"Reference Frames","text":""},{"location":"learn/frames/eci_ecef.html#eci-earth-centered-inertial","title":"ECI (Earth-Centered Inertial)","text":"<ul> <li>A non-rotating frame fixed with respect to distant stars</li> <li>Inertial frame suitable for integration of equations of motion</li> <li>Current Realization: GCRF (Geocentric Celestial Reference Frame)</li> </ul>"},{"location":"learn/frames/eci_ecef.html#ecef-earth-centered-earth-fixed","title":"ECEF (Earth-Centered Earth-Fixed)","text":"<ul> <li>A rotating frame fixed to the Earth's surface</li> <li>Ideal for computing positions and motions relative to terrestrial locations and observers</li> <li>Current Realization: ITRF (International Terrestrial Reference Frame)</li> </ul>"},{"location":"learn/frames/eci_ecef.html#eci-to-ecef","title":"ECI to ECEF","text":"<p>Converting from ECI to ECEF accounts for the Earth's rotation, polar motion, and precession-nutation effects. These transformations are time-dependent and require Earth Orientation Parameters (EOP) for high accuracy. The transformations will use the currently loaded Earth orientation data provider to obtain the necessary parameters automatically. See Earth Orientation Data for more details.</p>"},{"location":"learn/frames/eci_ecef.html#state-vector","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from ECI to ECEF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-01-01 12:00:00.000 UTC\n\n# Convert to ECI Cartesian state\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\nprint(\"ECI state vector:\")\nprint(f\"  Position: [{state_eci[0]:.3f}, {state_eci[1]:.3f}, {state_eci[2]:.3f}] m\")\nprint(f\"  Velocity: [{state_eci[3]:.6f}, {state_eci[4]:.6f}, {state_eci[5]:.6f}] m/s\\n\")\n\n# ECI state vector:\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ECEF at specific epoch\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\n\nprint(\"\\nECEF state vector:\")\nprint(f\"  Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}] m/s\"\n)\n# ECEF state vector:\n#   Position: [757164.267, 1725863.563, 6564672.302] m\n#   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-01-01 12:00:00.000 UTC\n\n    // Convert to ECI Cartesian state\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    println!(\"ECI state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci[0], state_eci[1], state_eci[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eci[3], state_eci[4], state_eci[5]);\n    // ECI state vector:\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ECEF at specific epoch\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"\\nECEF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // ECEF state vector:\n    //   Position: [757164.267, 1725863.563, 6564672.302] m\n    //   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n}\n</code></pre> <p>Velocity Transformation</p> <p>Simply rotating velocity vectors will not yield correct velocity components in the ECEF frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes in the ECEF frame due to Earth's rotation.</p>"},{"location":"learn/frames/eci_ecef.html#rotation-matrix","title":"Rotation Matrix","text":"<p>Get the rotation matrix from ECI to ECEF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from ECI to ECEF\nR_eci_to_ecef = bh.rotation_eci_to_ecef(epc)\n\nprint(f\"Epoch: {epc}\")  # Epoch: 2024-01-01 12:00:00 UTC\nprint(\"\\nECI to ECEF rotation matrix:\")\nprint(\n    f\"  [{R_eci_to_ecef[0, 0]:10.7f}, {R_eci_to_ecef[0, 1]:10.7f}, {R_eci_to_ecef[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_eci_to_ecef[1, 0]:10.7f}, {R_eci_to_ecef[1, 1]:10.7f}, {R_eci_to_ecef[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_eci_to_ecef[2, 0]:10.7f}, {R_eci_to_ecef[2, 1]:10.7f}, {R_eci_to_ecef[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538, -0.9837663, -0.0003836]\n# [ 0.9837637,  0.1794542, -0.0022908]\n# [ 0.0023225,  0.0000338,  0.9999973]\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to ECI Cartesian state and extract position\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_eci = state_eci[0:3]\n\nprint(\"Position in ECI:\")\nprint(f\"  [{pos_eci[0]:.3f}, {pos_eci[1]:.3f}, {pos_eci[2]:.3f}] m\\n\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Transform position using rotation matrix\npos_ecef = R_eci_to_ecef @ pos_eci\n\nprint(\"Position in ECEF (using rotation matrix):\")\nprint(f\"  [{pos_ecef[0]:.3f}, {pos_ecef[1]:.3f}, {pos_ecef[2]:.3f}] m\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Verify using position transformation function\npos_ecef_direct = bh.position_eci_to_ecef(epc, pos_eci)\nprint(\"\\nPosition in ECEF (using position_eci_to_ecef):\")\nprint(\n    f\"  [{pos_ecef_direct[0]:.3f}, {pos_ecef_direct[1]:.3f}, {pos_ecef_direct[2]:.3f}] m\"\n)\n# [757164.267, 1725863.563, 6564672.302] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from ECI to ECEF\n    let r_eci_to_ecef = bh::rotation_eci_to_ecef(epc);\n\n    println!(\"Epoch: {}\", epc); // Epoch: 2024-01-01 12:00:00 UTC\n    println!(\"\\nECI to ECEF rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_eci_to_ecef[(0, 0)], r_eci_to_ecef[(0, 1)], r_eci_to_ecef[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_eci_to_ecef[(1, 0)], r_eci_to_ecef[(1, 1)], r_eci_to_ecef[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_eci_to_ecef[(2, 0)], r_eci_to_ecef[(2, 1)], r_eci_to_ecef[(2, 2)]);\n    // [ 0.1794538, -0.9837663, -0.0003836]\n    // [ 0.9837637,  0.1794542, -0.0022908]\n    // [ 0.0023225,  0.0000338,  0.9999973]\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to ECI Cartesian state and extract position\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_eci = na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]);\n\n    println!(\"Position in ECI:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eci[0], pos_eci[1], pos_eci[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform position using rotation matrix\n    let pos_ecef = r_eci_to_ecef * pos_eci;\n\n    println!(\"Position in ECEF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_ecef[0], pos_ecef[1], pos_ecef[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Verify using position transformation function\n    let pos_ecef_direct = bh::position_eci_to_ecef(epc, pos_eci);\n    println!(\"\\nPosition in ECEF (using position_eci_to_ecef):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_ecef_direct[0], pos_ecef_direct[1], pos_ecef_direct[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n}\n</code></pre>"},{"location":"learn/frames/eci_ecef.html#ecef-to-eci","title":"ECEF to ECI","text":"<p>Converting from ECEF to ECI reverses the transformation, converting Earth-fixed coordinates back to the inertial frame.</p>"},{"location":"learn/frames/eci_ecef.html#state-vector_1","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from ECEF to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n\n# Convert to ECI Cartesian state\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\nprint(\"ECI state vector:\")\nprint(f\"  Position: [{state_eci[0]:.3f}, {state_eci[1]:.3f}, {state_eci[2]:.3f}] m\")\nprint(f\"  Velocity: [{state_eci[3]:.6f}, {state_eci[4]:.6f}, {state_eci[5]:.6f}] m/s\\n\")\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\n\nprint(\"ECEF state vector:\")\nprint(f\"  Position: [{state_ecef[0]:.3f}, {state_ecef[1]:.3f}, {state_ecef[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_ecef[3]:.6f}, {state_ecef[4]:.6f}, {state_ecef[5]:.6f}] m/s\\n\"\n)\n# Position: [757164.267, 1725863.563, 6564672.302] m\n# Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n# Transform back to ECI\nstate_eci_back = bh.state_ecef_to_eci(epc, state_ecef)\n\nprint(\"\\nECI state vector (transformed from ECEF):\")\nprint(\n    f\"  Position: [{state_eci_back[0]:.3f}, {state_eci_back[1]:.3f}, {state_eci_back[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_eci_back[3]:.6f}, {state_eci_back[4]:.6f}, {state_eci_back[5]:.6f}] m/s\"\n)\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Verify round-trip transformation\ndiff_pos = np.linalg.norm(state_eci[0:3] - state_eci_back[0:3])\ndiff_vel = np.linalg.norm(state_eci[3:6] - state_eci_back[3:6])\nprint(\"\\nRound-trip error:\")\nprint(f\"  Position: {diff_pos:.6e} m\")\nprint(f\"  Velocity: {diff_vel:.6e} m/s\")\n\n# Expected output:\n#   Position: 9.617484e-10 m\n#   Velocity: 9.094947e-13 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n\n    // Convert to ECI Cartesian state\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    println!(\"ECI state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci[0], state_eci[1], state_eci[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eci[3], state_eci[4], state_eci[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ECEF\n    let state_ecef = bh::state_eci_to_ecef(epc, state_eci);\n\n    println!(\"ECEF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_ecef[0], state_ecef[1], state_ecef[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_ecef[3], state_ecef[4], state_ecef[5]);\n    // Position: [757164.267, 1725863.563, 6564672.302] m\n    // Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n    // Transform back to ECI\n    let state_eci_back = bh::state_ecef_to_eci(epc, state_ecef);\n\n    println!(\"\\nECI state vector (transformed from ECEF):\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eci_back[0], state_eci_back[1], state_eci_back[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_eci_back[3], state_eci_back[4], state_eci_back[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Verify round-trip transformation\n    let diff_pos = (na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]) -\n                    na::Vector3::new(state_eci_back[0], state_eci_back[1], state_eci_back[2])).norm();\n    let diff_vel = (na::Vector3::new(state_eci[3], state_eci[4], state_eci[5]) -\n                    na::Vector3::new(state_eci_back[3], state_eci_back[4], state_eci_back[5])).norm();\n    println!(\"\\nRound-trip error:\");\n    println!(\"  Position: {:.6e} m\", diff_pos);\n    println!(\"  Velocity: {:.6e} m/s\", diff_vel);\n\n    // Expected output:\n    //   Position: 9.617484e-10 m\n    //   Velocity: 9.094947e-13 m/s\n}\n</code></pre> <p>Velocity Transformation</p> <p>Simply rotating velocity vectors will not yield correct velocity components in the ECI frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes when transforming from the rotating ECEF frame.</p>"},{"location":"learn/frames/eci_ecef.html#rotation-matrix_1","title":"Rotation Matrix","text":"<p>Get the rotation matrix from ECEF to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR_ecef_to_eci = bh.rotation_ecef_to_eci(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nECEF to ECI rotation matrix:\")\nprint(\n    f\"  [{R_ecef_to_eci[0, 0]:10.7f}, {R_ecef_to_eci[0, 1]:10.7f}, {R_ecef_to_eci[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_ecef_to_eci[1, 0]:10.7f}, {R_ecef_to_eci[1, 1]:10.7f}, {R_ecef_to_eci[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_ecef_to_eci[2, 0]:10.7f}, {R_ecef_to_eci[2, 1]:10.7f}, {R_ecef_to_eci[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538,  0.9837637,  0.0023225]\n# [-0.9837663,  0.1794542,  0.0000338]\n# [-0.0003836, -0.0022908,  0.9999973]\n\n# Verify it's the transpose of ECI to ECEF rotation\nR_eci_to_ecef = bh.rotation_eci_to_ecef(epc)\nprint(\"Verification: R_ecef_to_eci = R_eci_to_ecef^T\")\nprint(f\"  Max difference: {np.max(np.abs(R_ecef_to_eci - R_eci_to_ecef.T)):.2e}\\n\")\n# Max difference: 0.00e0\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to ECI Cartesian state and extract position\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Transform to ECEF\npos_ecef = bh.position_eci_to_ecef(epc, state_eci[0:3])\n\nprint(\"Satellite position in ECEF:\")\nprint(f\"  [{pos_ecef[0]:.3f}, {pos_ecef[1]:.3f}, {pos_ecef[2]:.3f}] m\\n\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Transform back to ECI using rotation matrix\npos_eci = R_ecef_to_eci @ pos_ecef\n\nprint(\"Satellite position in ECI (using rotation matrix):\")\nprint(f\"  [{pos_eci[0]:.3f}, {pos_eci[1]:.3f}, {pos_eci[2]:.3f}] m\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Verify using position transformation function\npos_eci_direct = bh.position_ecef_to_eci(epc, pos_ecef)\nprint(\"\\nSatellite position in ECI (using position_ecef_to_eci):\")\nprint(\n    f\"  [{pos_eci_direct[0]:.3f}, {pos_eci_direct[1]:.3f}, {pos_eci_direct[2]:.3f}] m\"\n)\n# [1848964.106, -434937.468, 6560410.530] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from ECEF to ECI\n    let r_ecef_to_eci = bh::rotation_ecef_to_eci(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nECEF to ECI rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_ecef_to_eci[(0, 0)], r_ecef_to_eci[(0, 1)], r_ecef_to_eci[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_ecef_to_eci[(1, 0)], r_ecef_to_eci[(1, 1)], r_ecef_to_eci[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_ecef_to_eci[(2, 0)], r_ecef_to_eci[(2, 1)], r_ecef_to_eci[(2, 2)]);\n    // [ 0.1794538,  0.9837637,  0.0023225]\n    // [-0.9837663,  0.1794542,  0.0000338]\n    // [-0.0003836, -0.0022908,  0.9999973]\n\n    // Verify it's the transpose of ECI to ECEF rotation\n    let r_eci_to_ecef = bh::rotation_eci_to_ecef(epc);\n    let diff = (r_ecef_to_eci - r_eci_to_ecef.transpose()).abs();\n    let max_diff = diff.max();\n    println!(\"Verification: R_ecef_to_eci = R_eci_to_ecef^T\");\n    println!(\"  Max difference: {:.2e}\\n\", max_diff);\n    // Max difference: 0.00e+00\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to ECI Cartesian state and extract position\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_eci_orig = na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]);\n\n    // Transform to ECEF\n    let pos_ecef = bh::position_eci_to_ecef(epc, pos_eci_orig);\n\n    println!(\"Satellite position in ECEF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_ecef[0], pos_ecef[1], pos_ecef[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Transform back to ECI using rotation matrix\n    let pos_eci = r_ecef_to_eci * pos_ecef;\n\n    println!(\"Satellite position in ECI (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eci[0], pos_eci[1], pos_eci[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify using position transformation function\n    let pos_eci_direct = bh::position_ecef_to_eci(epc, pos_ecef);\n    println!(\"\\nSatellite position in ECI (using position_ecef_to_eci):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eci_direct[0], pos_eci_direct[1], pos_eci_direct[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n}\n</code></pre>"},{"location":"learn/frames/eci_ecef.html#see-also","title":"See Also","text":"<ul> <li>GCRF \u2194 ITRF Transformations - Detailed documentation of the underlying reference frame implementations</li> <li>Reference Frames Overview - Complete overview of all reference frames in Brahe</li> </ul>"},{"location":"learn/frames/eme2000_gcrf.html","title":"EME2000 \u2194 GCRF Transformations","text":"<p>The EME2000 (Earth Mean Equator and Equinox of J2000.0) to GCRF (Geocentric Celestial Reference Frame) transformation accounts for the frame bias between the classical J2000.0 reference frame and the modern ICRS-aligned GCRF.</p> <p>When to Use EME2000</p> <p>EME2000 should primarily be used when:</p> <ul> <li>Working with older systems or datasets that use EME2000 coordinates</li> <li>Interfacing with software that requires EME2000 input/output</li> <li>Comparing results with historical analyses performed in EME2000</li> </ul> <p>For new applications, use GCRF as your standard inertial frame. GCRF is the current IAU/IERS standard and provides the most accurate representation of an inertial reference frame.</p>"},{"location":"learn/frames/eme2000_gcrf.html#reference-frames","title":"Reference Frames","text":""},{"location":"learn/frames/eme2000_gcrf.html#eme2000-earth-mean-equator-and-equinox-of-j20000","title":"EME2000 (Earth Mean Equator and Equinox of J2000.0)","text":"<p>EME2000, also known as J2000.0, is the classical inertial reference frame defined by the mean equator and mean equinox of the Earth at the J2000.0 epoch (January 1, 2000, 12:00 TT). This frame was widely used in older astrodynamics systems and is still found in many datasets and applications.</p> <p>Key characteristics:</p> <ul> <li>Inertial frame (non-rotating)</li> <li>Defined using the mean equator and equinox at J2000.0</li> <li>Origin at Earth's center of mass</li> </ul>"},{"location":"learn/frames/eme2000_gcrf.html#geocentric-celestial-reference-frame-gcrf","title":"Geocentric Celestial Reference Frame (GCRF)","text":"<p>The GCRF is the modern standard inertial reference frame, aligned with the International Celestial Reference System (ICRS). It is realized using observations of distant quasars and represents the current best realization of an inertial frame.</p> <p>Key characteristics:</p> <ul> <li>Inertial frame (non-rotating)</li> <li>ICRS-aligned (quasi-inertial with respect to distant objects)</li> <li>Origin at Earth's center of mass</li> <li>Standard frame for modern astrodynamics applications</li> </ul>"},{"location":"learn/frames/eme2000_gcrf.html#frame-bias","title":"Frame Bias","text":"<p>The transformation between EME2000 and GCRF is a constant frame bias that does not vary with time. This bias accounts for the small offset between the J2000.0 mean equator/equinox and the ICRS alignment arising from the improved observational data used to define the ICRS.</p> <p>The bias is very small (on the order of milliarcseconds) but can matter for high-precision applications.</p> <p>Time Independence</p> <p>Unlike GCRF \u2194 ITRF transformations, which are time-dependent and require Earth Orientation Parameters, the EME2000 \u2194 GCRF transformation is constant and does not require an epoch parameter. The transformation is the same at all times.</p>"},{"location":"learn/frames/eme2000_gcrf.html#eme2000-to-gcrf","title":"EME2000 to GCRF","text":"<p>Transform coordinates from the EME2000 frame to the modern GCRF.</p>"},{"location":"learn/frames/eme2000_gcrf.html#state-vector","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from EME2000 to GCRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n# Convert to EME2000 Cartesian state\n# Note: state_koe_to_eci produces EME2000 states by default\nstate_eme2000 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\nprint(\"EME2000 state vector:\")\nprint(\n    f\"  Position: [{state_eme2000[0]:.3f}, {state_eme2000[1]:.3f}, {state_eme2000[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_eme2000[3]:.6f}, {state_eme2000[4]:.6f}, {state_eme2000[5]:.6f}] m/s\\n\"\n)\n# EME2000 state vector:\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to GCRF (constant transformation, no epoch needed)\nstate_gcrf = bh.state_eme2000_to_gcrf(state_eme2000)\n\nprint(\"GCRF state vector:\")\nprint(f\"  Position: [{state_gcrf[0]:.3f}, {state_gcrf[1]:.3f}, {state_gcrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_gcrf[3]:.6f}, {state_gcrf[4]:.6f}, {state_gcrf[5]:.6f}] m/s\\n\"\n)\n# GCRF state vector:\n#   Position: [1848963.547, -434937.816, 6560410.665] m\n#   Velocity: [-7098.380042, -2173.344428, 1913.332741] m/s\n\n# Transform back to EME2000 to verify round-trip\nstate_eme2000_back = bh.state_gcrf_to_eme2000(state_gcrf)\n\nprint(\"EME2000 state vector (transformed from GCRF):\")\nprint(\n    f\"  Position: [{state_eme2000_back[0]:.3f}, {state_eme2000_back[1]:.3f}, {state_eme2000_back[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_eme2000_back[3]:.6f}, {state_eme2000_back[4]:.6f}, {state_eme2000_back[5]:.6f}] m/s\\n\"\n)\n# EME2000 state vector (transformed from GCRF):\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Verify round-trip transformation\ndiff_pos = np.linalg.norm(state_eme2000[0:3] - state_eme2000_back[0:3])\ndiff_vel = np.linalg.norm(state_eme2000[3:6] - state_eme2000_back[3:6])\nprint(\"Round-trip error:\")\nprint(f\"  Position: {diff_pos:.6e} m\")\nprint(f\"  Velocity: {diff_vel:.6e} m/s\")\nprint(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\")\n# Round-trip error:\n#   Position: 3.863884e-08 m\n#   Velocity: 3.876304e-11 m/s\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    // Convert to EME2000 Cartesian state\n    // Note: state_koe_to_eci produces EME2000 states by default\n    let state_eme2000 = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    println!(\"EME2000 state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eme2000[0], state_eme2000[1], state_eme2000[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eme2000[3], state_eme2000[4], state_eme2000[5]);\n    // EME2000 state vector:\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to GCRF (constant transformation, no epoch needed)\n    let state_gcrf = bh::state_eme2000_to_gcrf(state_eme2000);\n\n    println!(\"GCRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_gcrf[3], state_gcrf[4], state_gcrf[5]);\n    // GCRF state vector:\n    //   Position: [1848963.547, -434937.816, 6560410.665] m\n    //   Velocity: [-7098.380042, -2173.344428, 1913.332741] m/s\n\n    // Transform back to EME2000 to verify round-trip\n    let state_eme2000_back = bh::state_gcrf_to_eme2000(state_gcrf);\n\n    println!(\"EME2000 state vector (transformed from GCRF):\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eme2000_back[0], state_eme2000_back[1], state_eme2000_back[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eme2000_back[3], state_eme2000_back[4], state_eme2000_back[5]);\n    // EME2000 state vector (transformed from GCRF):\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Verify round-trip transformation\n    let diff_pos = (na::Vector3::new(state_eme2000[0], state_eme2000[1], state_eme2000[2]) -\n                    na::Vector3::new(state_eme2000_back[0], state_eme2000_back[1], state_eme2000_back[2])).norm();\n    let diff_vel = (na::Vector3::new(state_eme2000[3], state_eme2000[4], state_eme2000[5]) -\n                    na::Vector3::new(state_eme2000_back[3], state_eme2000_back[4], state_eme2000_back[5])).norm();\n    println!(\"Round-trip error:\");\n    println!(\"  Position: {:.6e} m\", diff_pos);\n    println!(\"  Velocity: {:.6e} m/s\", diff_vel);\n    println!(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\");\n// Round-trip error:\n//   Position: 3.863884e-08 m\n//   Velocity: 3.876304e-11 m/s\n}\n</code></pre> <p>Velocity Transformation</p> <p>Because the transformation does not vary with time, velocity vectors are directly rotated without additional correction terms. There is no time-varying rotation rate to account for.</p>"},{"location":"learn/frames/eme2000_gcrf.html#position-vector","title":"Position Vector","text":"<p>Transform a position vector from EME2000 to GCRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n# Convert to EME2000 Cartesian state and extract position\nstate_eme2000 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_eme2000 = state_eme2000[0:3]\n\nprint(\"Position in EME2000:\")\nprint(f\"  [{pos_eme2000[0]:.3f}, {pos_eme2000[1]:.3f}, {pos_eme2000[2]:.3f}] m\\n\")\n# Position in EME2000:\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Transform to GCRF (constant transformation, no epoch needed)\npos_gcrf = bh.position_eme2000_to_gcrf(pos_eme2000)\n\nprint(\"Position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# Position in GCRF:\n# [1848963.547, -434937.816, 6560410.665] m\n\n# Verify using rotation matrix\nR_eme2000_to_gcrf = bh.rotation_eme2000_to_gcrf()\npos_gcrf_matrix = R_eme2000_to_gcrf @ pos_eme2000\n\nprint(\"Position in GCRF (using rotation matrix):\")\nprint(\n    f\"  [{pos_gcrf_matrix[0]:.3f}, {pos_gcrf_matrix[1]:.3f}, {pos_gcrf_matrix[2]:.3f}] m\\n\"\n)\n# Position in GCRF (using rotation matrix):\n# [1848963.547, -434937.816, 6560410.665] m\n\n# Verify both methods give same result\ndiff = np.linalg.norm(pos_gcrf - pos_gcrf_matrix)\nprint(f\"Difference between methods: {diff:.6e} m\")\nprint(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\")\n# Difference between methods: 0.000000e+00 m\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    // Convert to EME2000 Cartesian state and extract position\n    let state_eme2000 = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_eme2000 = na::Vector3::new(state_eme2000[0], state_eme2000[1], state_eme2000[2]);\n\n    println!(\"Position in EME2000:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eme2000[0], pos_eme2000[1], pos_eme2000[2]);\n    // Position in EME2000:\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform to GCRF (constant transformation, no epoch needed)\n    let pos_gcrf = bh::position_eme2000_to_gcrf(pos_eme2000);\n\n    println!(\"Position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // Position in GCRF:\n    // [1848963.547, -434937.816, 6560410.665] m\n\n    // Verify using rotation matrix\n    let r_eme2000_to_gcrf = bh::rotation_eme2000_to_gcrf();\n    let pos_gcrf_matrix = r_eme2000_to_gcrf * pos_eme2000;\n\n    println!(\"Position in GCRF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf_matrix[0], pos_gcrf_matrix[1], pos_gcrf_matrix[2]);\n    // Position in GCRF (using rotation matrix):\n    // [1848963.547, -434937.816, 6560410.665] m\n\n    // Verify both methods give same result\n    let diff = (pos_gcrf - pos_gcrf_matrix).norm();\n    println!(\"Difference between methods: {:.6e} m\", diff);\n    println!(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\");\n    // Difference between methods: 0.000000e+00 m\n}\n</code></pre>"},{"location":"learn/frames/eme2000_gcrf.html#rotation-matrix","title":"Rotation Matrix","text":"<p>Get the constant rotation matrix from EME2000 to GCRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Get constant rotation matrix from EME2000 to GCRF\nR_eme2000_to_gcrf = bh.rotation_eme2000_to_gcrf()\n\nprint(\"EME2000 to GCRF rotation matrix:\")\nprint(\n    f\"  [{R_eme2000_to_gcrf[0, 0]:13.10f}, {R_eme2000_to_gcrf[0, 1]:13.10f}, {R_eme2000_to_gcrf[0, 2]:13.10f}]\"\n)\nprint(\n    f\"  [{R_eme2000_to_gcrf[1, 0]:13.10f}, {R_eme2000_to_gcrf[1, 1]:13.10f}, {R_eme2000_to_gcrf[1, 2]:13.10f}]\"\n)\nprint(\n    f\"  [{R_eme2000_to_gcrf[2, 0]:13.10f}, {R_eme2000_to_gcrf[2, 1]:13.10f}, {R_eme2000_to_gcrf[2, 2]:13.10f}]\\n\"\n)\n# EME2000 to GCRF rotation matrix:\n#   [ 1.0000000000,  0.0000000708, -0.0000000806]\n#   [-0.0000000708,  1.0000000000, -0.0000000331]\n#   [ 0.0000000806,  0.0000000331,  1.0000000000]\n\n# Verify matrix is orthonormal (rotation matrix property)\nidentity = R_eme2000_to_gcrf @ R_eme2000_to_gcrf.T\nprint(\"Verify orthonormality (R @ R^T should be identity):\")\nprint(f\"  Max deviation from identity: {np.max(np.abs(identity - np.eye(3))):.2e}\\n\")\n# Verify orthonormality (R @ R^T should be identity):\n#   Max deviation from identity: 4.68e-15\n\n# Define orbital elements for testing transformation\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to EME2000 Cartesian state and extract position\nstate_eme2000 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_eme2000 = state_eme2000[0:3]\n\nprint(\"Satellite position in EME2000:\")\nprint(f\"  [{pos_eme2000[0]:.3f}, {pos_eme2000[1]:.3f}, {pos_eme2000[2]:.3f}] m\\n\")\n# Satellite position in EME2000:\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Transform using rotation matrix\npos_gcrf_matrix = R_eme2000_to_gcrf @ pos_eme2000\n\nprint(\"Satellite position in GCRF (using rotation matrix):\")\nprint(\n    f\"  [{pos_gcrf_matrix[0]:.3f}, {pos_gcrf_matrix[1]:.3f}, {pos_gcrf_matrix[2]:.3f}] m\"\n)\n# Satellite position in GCRF (using rotation matrix):\n#   [1848963.547, -434937.816, 6560410.665] m\n\n# Verify using position transformation function\npos_gcrf_direct = bh.position_eme2000_to_gcrf(pos_eme2000)\nprint(\"\\nSatellite position in GCRF (using position_eme2000_to_gcrf):\")\nprint(\n    f\"  [{pos_gcrf_direct[0]:.3f}, {pos_gcrf_direct[1]:.3f}, {pos_gcrf_direct[2]:.3f}] m\"\n)\n# Satellite position in GCRF (using position_eme2000_to_gcrf):\n#   [1848963.547, -434937.816, 6560410.665] m\n\n# Verify both methods agree\ndiff = np.linalg.norm(pos_gcrf_matrix - pos_gcrf_direct)\nprint(f\"\\nDifference between methods: {diff:.6e} m\")\nprint(\"\\nNote: Frame bias is constant (same at all epochs)\")\n# Difference between methods: 0.000000e+00 m\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Get constant rotation matrix from EME2000 to GCRF\n    let r_eme2000_to_gcrf = bh::rotation_eme2000_to_gcrf();\n\n    println!(\"EME2000 to GCRF rotation matrix:\");\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", r_eme2000_to_gcrf[(0, 0)], r_eme2000_to_gcrf[(0, 1)], r_eme2000_to_gcrf[(0, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", r_eme2000_to_gcrf[(1, 0)], r_eme2000_to_gcrf[(1, 1)], r_eme2000_to_gcrf[(1, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\\n\", r_eme2000_to_gcrf[(2, 0)], r_eme2000_to_gcrf[(2, 1)], r_eme2000_to_gcrf[(2, 2)]);\n    // EME2000 to GCRF rotation matrix:\n    //   [ 0.9999999999, -0.0000000707, -0.0000000308]\n    //   [ 0.0000000707,  0.9999999999, -0.0000000001]\n    //   [ 0.0000000308,  0.0000000000,  1.0000000000]\n\n    // Verify matrix is orthonormal (rotation matrix property)\n    let identity = r_eme2000_to_gcrf * r_eme2000_to_gcrf.transpose();\n    let identity_ref = na::Matrix3::&lt;f64&gt;::identity();\n    let max_dev = (identity - identity_ref).abs().max();\n    println!(\"Verify orthonormality (R @ R^T should be identity):\");\n    println!(\"  Max deviation from identity: {:.2e}\\n\", max_dev);\n    // Verify orthonormality (R @ R^T should be identity):\n    //   Max deviation from identity: 4.68e-15\n\n    // Define orbital elements for testing transformation\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to EME2000 Cartesian state and extract position\n    let state_eme2000 = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_eme2000 = na::Vector3::new(state_eme2000[0], state_eme2000[1], state_eme2000[2]);\n\n    println!(\"Satellite position in EME2000:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eme2000[0], pos_eme2000[1], pos_eme2000[2]);\n    // Satellite position in EME2000:\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform using rotation matrix\n    let pos_gcrf_matrix = r_eme2000_to_gcrf * pos_eme2000;\n\n    println!(\"Satellite position in GCRF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_gcrf_matrix[0], pos_gcrf_matrix[1], pos_gcrf_matrix[2]);\n    // Satellite position in GCRF (using rotation matrix):\n    //   [1848963.547, -434937.816, 6560410.665] m\n\n    // Verify using position transformation function\n    let pos_gcrf_direct = bh::position_eme2000_to_gcrf(pos_eme2000);\n    println!(\"\\nSatellite position in GCRF (using position_eme2000_to_gcrf):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_gcrf_direct[0], pos_gcrf_direct[1], pos_gcrf_direct[2]);\n    // Satellite position in GCRF (using position_eme2000_to_gcrf):\n    //   [1848963.547, -434937.816, 6560410.665] m\n\n    // Verify both methods agree\n    let diff = (pos_gcrf_matrix - pos_gcrf_direct).norm();\n    println!(\"\\nDifference between methods: {:.6e} m\", diff);\n    println!(\"\\nNote: Frame bias is constant (same at all epochs)\");\n    // Difference between methods: 0.000000e+00 m\n}\n</code></pre>"},{"location":"learn/frames/eme2000_gcrf.html#gcrf-to-eme2000","title":"GCRF to EME2000","text":"<p>Transform coordinates from the modern GCRF to the older EME2000 frame.</p>"},{"location":"learn/frames/eme2000_gcrf.html#state-vector_1","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from GCRF to EME2000:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n# Convert to EME2000 state, then transform to GCRF\n# (Starting in EME2000 to get GCRF representation)\nstate_eme2000_orig = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nstate_gcrf = bh.state_eme2000_to_gcrf(state_eme2000_orig)\n\nprint(\"GCRF state vector:\")\nprint(f\"  Position: [{state_gcrf[0]:.3f}, {state_gcrf[1]:.3f}, {state_gcrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_gcrf[3]:.6f}, {state_gcrf[4]:.6f}, {state_gcrf[5]:.6f}] m/s\\n\"\n)\n# GCRF state vector:\n#   Position: [1848963.547, -434937.816, 6560410.665] m\n#   Velocity: [-7098.380042, -2173.344428, 1913.332741] m/s\n\n# Transform to EME2000 (constant transformation, no epoch needed)\nstate_eme2000 = bh.state_gcrf_to_eme2000(state_gcrf)\n\nprint(\"EME2000 state vector:\")\nprint(\n    f\"  Position: [{state_eme2000[0]:.3f}, {state_eme2000[1]:.3f}, {state_eme2000[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_eme2000[3]:.6f}, {state_eme2000[4]:.6f}, {state_eme2000[5]:.6f}] m/s\\n\"\n)\n# EME2000 state vector:\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform back to GCRF to verify round-trip\nstate_gcrf_back = bh.state_eme2000_to_gcrf(state_eme2000)\n\nprint(\"GCRF state vector (transformed from EME2000):\")\nprint(\n    f\"  Position: [{state_gcrf_back[0]:.3f}, {state_gcrf_back[1]:.3f}, {state_gcrf_back[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_gcrf_back[3]:.6f}, {state_gcrf_back[4]:.6f}, {state_gcrf_back[5]:.6f}] m/s\\n\"\n)\n# GCRF state vector (transformed from EME2000):\n#   Position: [1848963.547, -434937.816, 6560410.665] m\n#   Velocity: [-7098.380042, -2173.344428, 1913.332741] m/s\n\n# Verify round-trip transformation\ndiff_pos = np.linalg.norm(state_gcrf[0:3] - state_gcrf_back[0:3])\ndiff_vel = np.linalg.norm(state_gcrf[3:6] - state_gcrf_back[3:6])\nprint(\"Round-trip error:\")\nprint(f\"  Position: {diff_pos:.6e} m\")\nprint(f\"  Velocity: {diff_vel:.6e} m/s\")\nprint(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\")\n# Round-trip error:\n#   Position: 3.863884e-08 m\n#   Velocity: 3.876304e-11 m/s\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    // Convert to EME2000 state, then transform to GCRF\n    // (Starting in EME2000 to get GCRF representation)\n    let state_eme2000_orig = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let state_gcrf = bh::state_eme2000_to_gcrf(state_eme2000_orig);\n\n    println!(\"GCRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_gcrf[3], state_gcrf[4], state_gcrf[5]);\n    // GCRF state vector:    \n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to EME2000 (constant transformation, no epoch needed)\n    let state_eme2000 = bh::state_gcrf_to_eme2000(state_gcrf);\n\n    println!(\"EME2000 state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_eme2000[0], state_eme2000[1], state_eme2000[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_eme2000[3], state_eme2000[4], state_eme2000[5]);\n    // EME2000 state vector:\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform back to GCRF to verify round-trip\n    let state_gcrf_back = bh::state_eme2000_to_gcrf(state_eme2000);\n\n    println!(\"GCRF state vector (transformed from EME2000):\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf_back[0], state_gcrf_back[1], state_gcrf_back[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_gcrf_back[3], state_gcrf_back[4], state_gcrf_back[5]);\n    // GCRF state vector (transformed from EME2000):\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Verify round-trip transformation\n    let diff_pos = (na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]) -\n                    na::Vector3::new(state_gcrf_back[0], state_gcrf_back[1], state_gcrf_back[2])).norm();\n    let diff_vel = (na::Vector3::new(state_gcrf[3], state_gcrf[4], state_gcrf[5]) -\n                    na::Vector3::new(state_gcrf_back[3], state_gcrf_back[4], state_gcrf_back[5])).norm();\n    println!(\"Round-trip error:\");\n    println!(\"  Position: {:.6e} m\", diff_pos);\n    println!(\"  Velocity: {:.6e} m/s\", diff_vel);\n    println!(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\");\n    // Round-trip error:\n    //   Position: 3.863884e-08 m\n    //   Velocity: 3.876304e-11 m/s\n}\n</code></pre>"},{"location":"learn/frames/eme2000_gcrf.html#position-vector_1","title":"Position Vector","text":"<p>Transform a position vector from GCRF to EME2000:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n# Convert to EME2000 state, transform to GCRF, and extract position\nstate_eme2000 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nstate_gcrf = bh.state_eme2000_to_gcrf(state_eme2000)\npos_gcrf = state_gcrf[0:3]\n\nprint(\"Position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# Position in GCRF:\n#   [1848963.547, -434937.816, 6560410.665] m\n\n# Transform to EME2000 (constant transformation, no epoch needed)\npos_eme2000 = bh.position_gcrf_to_eme2000(pos_gcrf)\n\nprint(\"Position in EME2000:\")\nprint(f\"  [{pos_eme2000[0]:.3f}, {pos_eme2000[1]:.3f}, {pos_eme2000[2]:.3f}] m\\n\")\n# Position in EME2000:\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Verify using rotation matrix\nR_gcrf_to_eme2000 = bh.rotation_gcrf_to_eme2000()\npos_eme2000_matrix = R_gcrf_to_eme2000 @ pos_gcrf\n\nprint(\"Position in EME2000 (using rotation matrix):\")\nprint(\n    f\"  [{pos_eme2000_matrix[0]:.3f}, {pos_eme2000_matrix[1]:.3f}, {pos_eme2000_matrix[2]:.3f}] m\\n\"\n)\n# Position in EME2000 (using rotation matrix):\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Verify both methods give same result\ndiff = np.linalg.norm(pos_eme2000 - pos_eme2000_matrix)\nprint(f\"Difference between methods: {diff:.6e} m\")\nprint(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\")\n# Difference between methods: 0.000000e+00 m\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    // Convert to EME2000 state, transform to GCRF, and extract position\n    let state_eme2000 = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let state_gcrf = bh::state_eme2000_to_gcrf(state_eme2000);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    println!(\"Position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // Position in GCRF:\n    //   [1848963.547, -434937.816, 6560410.665] m\n\n    // Transform to EME2000 (constant transformation, no epoch needed)\n    let pos_eme2000 = bh::position_gcrf_to_eme2000(pos_gcrf);\n\n    println!(\"Position in EME2000:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eme2000[0], pos_eme2000[1], pos_eme2000[2]);\n    // Position in EME2000:\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify using rotation matrix\n    let r_gcrf_to_eme2000 = bh::rotation_gcrf_to_eme2000();\n    let pos_eme2000_matrix = r_gcrf_to_eme2000 * pos_gcrf;\n\n    println!(\"Position in EME2000 (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_eme2000_matrix[0], pos_eme2000_matrix[1], pos_eme2000_matrix[2]);\n    // Position in EME2000 (using rotation matrix):\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify both methods give same result\n    let diff = (pos_eme2000 - pos_eme2000_matrix).norm();\n    println!(\"Difference between methods: {:.6e} m\", diff);\n    println!(\"\\nNote: Transformation is constant (time-independent, no epoch needed)\");\n    // Difference between methods: 0.000000e+00 m\n}\n</code></pre>"},{"location":"learn/frames/eme2000_gcrf.html#rotation-matrix_1","title":"Rotation Matrix","text":"<p>Get the constant rotation matrix from GCRF to EME2000:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Get constant rotation matrix from GCRF to EME2000\nR_gcrf_to_eme2000 = bh.rotation_gcrf_to_eme2000()\n\nprint(\"GCRF to EME2000 rotation matrix:\")\nprint(\n    f\"  [{R_gcrf_to_eme2000[0, 0]:13.10f}, {R_gcrf_to_eme2000[0, 1]:13.10f}, {R_gcrf_to_eme2000[0, 2]:13.10f}]\"\n)\nprint(\n    f\"  [{R_gcrf_to_eme2000[1, 0]:13.10f}, {R_gcrf_to_eme2000[1, 1]:13.10f}, {R_gcrf_to_eme2000[1, 2]:13.10f}]\"\n)\nprint(\n    f\"  [{R_gcrf_to_eme2000[2, 0]:13.10f}, {R_gcrf_to_eme2000[2, 1]:13.10f}, {R_gcrf_to_eme2000[2, 2]:13.10f}]\\n\"\n)\n# GCRF to EME2000 rotation matrix:\n#   [ 1.0000000000, -0.0000000708,  0.0000000806]\n#   [ 0.0000000708,  1.0000000000,  0.0000000331]\n#   [-0.0000000806, -0.0000000331,  1.0000000000]\n\n# Verify it's the transpose of EME2000 to GCRF rotation\nR_eme2000_to_gcrf = bh.rotation_eme2000_to_gcrf()\nprint(\"Verification: R_gcrf_to_eme2000 = R_eme2000_to_gcrf^T\")\nprint(\n    f\"  Max difference: {np.max(np.abs(R_gcrf_to_eme2000 - R_eme2000_to_gcrf.T)):.2e}\\n\"\n)\n# Verification: R_gcrf_to_eme2000 = R_eme2000_to_gcrf^T\n#   Max difference: 0.00e+00\n\n# Verify matrix is orthonormal (rotation matrix property)\nidentity = R_gcrf_to_eme2000 @ R_gcrf_to_eme2000.T\nprint(\"Verify orthonormality (R @ R^T should be identity):\")\nprint(f\"  Max deviation from identity: {np.max(np.abs(identity - np.eye(3))):.2e}\\n\")\n# Verify orthonormality (R @ R^T should be identity):\n#   Max deviation from identity: 4.68e-15\n\n# Define orbital elements for testing transformation\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to EME2000, transform to GCRF, and extract position\nstate_eme2000 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nstate_gcrf = bh.state_eme2000_to_gcrf(state_eme2000)\npos_gcrf = state_gcrf[0:3]\n\nprint(\"Satellite position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# Satellite position in GCRF:\n#   [1848963.547, -434937.816, 6560410.665] m\n\n# Transform using rotation matrix\npos_eme2000_matrix = R_gcrf_to_eme2000 @ pos_gcrf\n\nprint(\"Satellite position in EME2000 (using rotation matrix):\")\nprint(\n    f\"  [{pos_eme2000_matrix[0]:.3f}, {pos_eme2000_matrix[1]:.3f}, {pos_eme2000_matrix[2]:.3f}] m\"\n)\n# Satellite position in EME2000 (using rotation matrix):\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Verify using position transformation function\npos_eme2000_direct = bh.position_gcrf_to_eme2000(pos_gcrf)\nprint(\"\\nSatellite position in EME2000 (using position_gcrf_to_eme2000):\")\nprint(\n    f\"  [{pos_eme2000_direct[0]:.3f}, {pos_eme2000_direct[1]:.3f}, {pos_eme2000_direct[2]:.3f}] m\"\n)\n# Satellite position in EME2000 (using position_gcrf_to_eme2000):\n#   [1848964.106, -434937.468, 6560410.530] m\n\n# Verify both methods agree\ndiff = np.linalg.norm(pos_eme2000_matrix - pos_eme2000_direct)\nprint(f\"\\nDifference between methods: {diff:.6e} m\")\nprint(\"\\nNote: Frame bias is constant (same at all epochs)\")\n# Difference between methods: 0.000000e+00 m\n</code></pre> <pre><code>use nalgebra as na;\n\nfn main() {\n    // Get constant rotation matrix from GCRF to EME2000\n    let r_gcrf_to_eme2000 = bh::rotation_gcrf_to_eme2000();\n\n    println!(\"GCRF to EME2000 rotation matrix:\");\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", r_gcrf_to_eme2000[(0, 0)], r_gcrf_to_eme2000[(0, 1)], r_gcrf_to_eme2000[(0, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", r_gcrf_to_eme2000[(1, 0)], r_gcrf_to_eme2000[(1, 1)], r_gcrf_to_eme2000[(1, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\\n\", r_gcrf_to_eme2000[(2, 0)], r_gcrf_to_eme2000[(2, 1)], r_gcrf_to_eme2000[(2, 2)]);\n    // GCRF to EME2000 rotation matrix:\n    //   [ 1.0000000000, -0.0000000708,  0.0000000806]\n    //   [ 0.0000000708,  1.0000000000,  0.0000000331]\n    //   [-0.0000000806, -0.0000000331,  1.0000000000]\n\n    // Verify it's the transpose of EME2000 to GCRF rotation\n    let r_eme2000_to_gcrf = bh::rotation_eme2000_to_gcrf();\n    let diff = (r_gcrf_to_eme2000 - r_eme2000_to_gcrf.transpose()).abs();\n    let max_diff = diff.max();\n    println!(\"Verification: R_gcrf_to_eme2000 = R_eme2000_to_gcrf^T\");\n    println!(\"  Max difference: {:.2e}\\n\", max_diff);\n    // Verification: R_gcrf_to_eme2000 = R_eme2000_to_gcrf^T\n    //   Max difference: 0.00e+00\n\n    // Verify matrix is orthonormal (rotation matrix property)\n    let identity = r_gcrf_to_eme2000 * r_gcrf_to_eme2000.transpose();\n    let identity_ref = na::Matrix3::&lt;f64&gt;::identity();\n    let max_dev = (identity - identity_ref).abs().max();\n    println!(\"Verify orthonormality (R @ R^T should be identity):\");\n    println!(\"  Max deviation from identity: {:.2e}\\n\", max_dev);\n    // Verify orthonormality (R @ R^T should be identity):\n    //   Max deviation from identity: 4.68e-15\n\n    // Define orbital elements for testing transformation\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to EME2000, transform to GCRF, and extract position\n    let state_eme2000 = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let state_gcrf = bh::state_eme2000_to_gcrf(state_eme2000);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    println!(\"Satellite position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // Satellite position in GCRF:\n    //   [1848963.547, -434937.816, 6560410.665] m\n\n    // Transform using rotation matrix\n    let pos_eme2000_matrix = r_gcrf_to_eme2000 * pos_gcrf;\n\n    println!(\"Satellite position in EME2000 (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eme2000_matrix[0], pos_eme2000_matrix[1], pos_eme2000_matrix[2]);\n    // Satellite position in EME2000 (using rotation matrix):\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify using position transformation function\n    let pos_eme2000_direct = bh::position_gcrf_to_eme2000(pos_gcrf);\n    println!(\"\\nSatellite position in EME2000 (using position_gcrf_to_eme2000):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_eme2000_direct[0], pos_eme2000_direct[1], pos_eme2000_direct[2]);\n    // Satellite position in EME2000 (using position_gcrf_to_eme2000):\n    //   [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify both methods agree\n    let diff = (pos_eme2000_matrix - pos_eme2000_direct).norm();\n    println!(\"\\nDifference between methods: {:.6e} m\", diff);\n    println!(\"\\nNote: Frame bias is constant (same at all epochs)\");\n    // Difference between methods: 0.000000e+00 m\n}\n</code></pre>"},{"location":"learn/frames/eme2000_gcrf.html#frame-bias-matrix","title":"Frame Bias Matrix","text":"<p>The underlying frame bias transformation can also be accessed directly:</p> PythonRust <pre><code>import brahe as bh\n\n# Get the EME2000 frame bias matrix\nB = bh.bias_eme2000()\n\nprint(\"EME2000 frame bias matrix:\")\nprint(f\"  [{B[0, 0]:13.10f}, {B[0, 1]:13.10f}, {B[0, 2]:13.10f}]\")\nprint(f\"  [{B[1, 0]:13.10f}, {B[1, 1]:13.10f}, {B[1, 2]:13.10f}]\")\nprint(f\"  [{B[2, 0]:13.10f}, {B[2, 1]:13.10f}, {B[2, 2]:13.10f}]\\n\")\n# EME2000 frame bias matrix:\n#   [ 1.0000000000, -0.0000000708,  0.0000000806]\n#   [ 0.0000000708,  1.0000000000,  0.0000000331]\n#   [-0.0000000806, -0.0000000331,  1.0000000000]\n</code></pre> <pre><code>fn main() {\n    // Get the EME2000 frame bias matrix\n    let b = bh::bias_eme2000();\n\n    println!(\"EME2000 frame bias matrix:\");\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", b[(0, 0)], b[(0, 1)], b[(0, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\", b[(1, 0)], b[(1, 1)], b[(1, 2)]);\n    println!(\"  [{:13.10}, {:13.10}, {:13.10}]\\n\", b[(2, 0)], b[(2, 1)], b[(2, 2)]);\n    // EME2000 frame bias matrix:\n    //   [ 1.0000000000, -0.0000000708,  0.0000000806]\n    //   [ 0.0000000708,  1.0000000000,  0.0000000331]\n    //   [-0.0000000806, -0.0000000331,  1.0000000000]\n}\n</code></pre> <p>The bias matrix is identical to <code>rotation_gcrf_to_eme2000()</code> and represents the constant transformation from GCRF to EME2000.</p>"},{"location":"learn/frames/eme2000_gcrf.html#see-also","title":"See Also","text":"<ul> <li>GCRF \u2194 ITRF Transformations - Time-dependent transformations between inertial and Earth-fixed frames</li> <li>Reference Frames Overview - Complete overview of all reference frames in Brahe</li> </ul>"},{"location":"learn/frames/gcrf_itrf.html","title":"GCRF \u2194 ITRF Transformations","text":"<p>The Geocentric Celestial Reference Frame (GCRF) and International Terrestrial Reference Frame (ITRF) are the modern IAU/IERS standard reference frames for Earth-orbiting satellite applications. </p>"},{"location":"learn/frames/gcrf_itrf.html#reference-frames","title":"Reference Frames","text":""},{"location":"learn/frames/gcrf_itrf.html#geocentric-celestial-reference-frame-gcrf","title":"Geocentric Celestial Reference Frame (GCRF)","text":"<p>The Geocentric Celestial Reference Frame is the standard modern inertial reference frame for Earth-orbiting satellites. It is aligned with the International Celestial Reference Frame (ICRF) and realized using the positions of distant quasars. The GCRF has its origin at the Earth's center of mass and its axes are fixed with respect to distant stars.</p> <p>The GCRF is an Earth-centered inertial (ECI) frame, meaning it does not rotate with the Earth.</p>"},{"location":"learn/frames/gcrf_itrf.html#international-terrestrial-reference-frame-itrf","title":"International Terrestrial Reference Frame (ITRF)","text":"<p>The International Terrestrial Reference Frame is the standard Earth-fixed reference frame maintained by the International Earth Rotation and Reference Systems Service (IERS). The ITRF rotates with the Earth and its axes are aligned with the Earth's geographic coordinate system (polar axis and Greenwich meridian).</p> <p>The ITRF is an Earth-centered Earth-fixed (ECEF) frame, meaning it rotates with the Earth.</p>"},{"location":"learn/frames/gcrf_itrf.html#transformation-model","title":"Transformation Model","text":"<p>Brahe implements the IAU 2006/2000A precession-nutation model with Celestial Intermediate Origin (CIO) based transformation, following IERS conventions. The transformation is accomplished using the IAU 2006/2000A, CIO-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook. The transformation accounts for:</p> <ul> <li>Precession and nutation of Earth's rotation axis</li> <li>Earth's rotation about its instantaneous spin axis</li> <li>Polar motion and UT1-UTC corrections</li> </ul> <p>These transformations are time-dependent and require Earth Orientation Parameters (EOP) for high accuracy. The transformations will use the currently loaded Earth orientation data provider to obtain the necessary parameters automatically. See Earth Orientation Data for more details.</p>"},{"location":"learn/frames/gcrf_itrf.html#gcrf-to-itrf","title":"GCRF to ITRF","text":"<p>Transform coordinates from the inertial GCRF to the Earth-fixed ITRF.</p>"},{"location":"learn/frames/gcrf_itrf.html#state-vector","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from GCRF to ITRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n# Orbital elements (degrees):\n#   a    = 6878136.300 m = 500.0 km altitude\n#   e    = 0.0100\n#   i    = 97.8000\u00b0\n#   \u03a9    = 15.0000\u00b0\n#   \u03c9    = 30.0000\u00b0\n#   M    = 45.0000\u00b0\n\n\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-01-01 12:00:00.000 UTC\n\n# Convert to GCRF Cartesian state\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\nprint(\"GCRF state vector:\")\nprint(f\"  Position: [{state_gcrf[0]:.3f}, {state_gcrf[1]:.3f}, {state_gcrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_gcrf[3]:.6f}, {state_gcrf[4]:.6f}, {state_gcrf[5]:.6f}] m/s\\n\"\n)\n\n# GCRF state vector:\n#   Position: [1848964.106, -434937.468, 6560410.530] m\n#   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ITRF at specific epoch\nstate_itrf = bh.state_gcrf_to_itrf(epc, state_gcrf)\n\nprint(\"\\nITRF state vector:\")\nprint(f\"  Position: [{state_itrf[0]:.3f}, {state_itrf[1]:.3f}, {state_itrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_itrf[3]:.6f}, {state_itrf[4]:.6f}, {state_itrf[5]:.6f}] m/s\"\n)\n# ITRF state vector:\n#   Position: [757164.267, 1725863.563, 6564672.302] m\n#   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n    // Orbital elements (degrees):\n    //   a    = 6878136.300 m = 500.0 km altitude\n    //   e    = 0.0100\n    //   i    = 97.8000\u00b0\n    //   \u03a9    = 15.0000\u00b0\n    //   \u03c9    = 30.0000\u00b0\n    //   M    = 45.0000\u00b0\n\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-01-01 12:00:00.000 UTC\n\n    // Convert to GCRF Cartesian state\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    println!(\"GCRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_gcrf[3], state_gcrf[4], state_gcrf[5]);\n    // GCRF state vector:\n    //   Position: [1848964.106, -434937.468, 6560410.530] m\n    //   Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ITRF at specific epoch\n    let state_itrf = bh::state_gcrf_to_itrf(epc, state_gcrf);\n\n    println!(\"\\nITRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_itrf[0], state_itrf[1], state_itrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_itrf[3], state_itrf[4], state_itrf[5]);\n    // ITRF state vector:\n    //   Position: [757164.267, 1725863.563, 6564672.302] m\n    //   Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n}\n</code></pre> <p>Velocity Transformation</p> <p>Simply rotating velocity vectors will not yield correct velocity components in the ITRF frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes in the ITRF frame due to Earth's rotation.</p>"},{"location":"learn/frames/gcrf_itrf.html#rotation-matrix","title":"Rotation Matrix","text":"<p>Get the rotation matrix from GCRF to ITRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from GCRF to ITRF\nR_gcrf_to_itrf = bh.rotation_gcrf_to_itrf(epc)\n\nprint(f\"Epoch: {epc}\")  # Epoch: 2024-01-01 12:00:00 UTC\nprint(\"\\nGCRF to ITRF rotation matrix:\")\nprint(\n    f\"  [{R_gcrf_to_itrf[0, 0]:10.7f}, {R_gcrf_to_itrf[0, 1]:10.7f}, {R_gcrf_to_itrf[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_gcrf_to_itrf[1, 0]:10.7f}, {R_gcrf_to_itrf[1, 1]:10.7f}, {R_gcrf_to_itrf[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_gcrf_to_itrf[2, 0]:10.7f}, {R_gcrf_to_itrf[2, 1]:10.7f}, {R_gcrf_to_itrf[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538, -0.9837663, -0.0003836]\n# [ 0.9837637,  0.1794542, -0.0022908]\n# [ 0.0023225,  0.0000338,  0.9999973]\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF Cartesian state and extract position\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\n\nprint(\"Position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Transform position using rotation matrix\npos_itrf = R_gcrf_to_itrf @ pos_gcrf\n\nprint(\"Position in ITRF (using rotation matrix):\")\nprint(f\"  [{pos_itrf[0]:.3f}, {pos_itrf[1]:.3f}, {pos_itrf[2]:.3f}] m\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Verify using position transformation function\npos_itrf_direct = bh.position_gcrf_to_itrf(epc, pos_gcrf)\nprint(\"\\nPosition in ITRF (using position_gcrf_to_itrf):\")\nprint(\n    f\"  [{pos_itrf_direct[0]:.3f}, {pos_itrf_direct[1]:.3f}, {pos_itrf_direct[2]:.3f}] m\"\n)\n# [757164.267, 1725863.563, 6564672.302] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from GCRF to ITRF\n    let r_gcrf_to_itrf = bh::rotation_gcrf_to_itrf(epc);\n\n    println!(\"Epoch: {}\", epc); // Epoch: 2024-01-01 12:00:00 UTC\n    println!(\"\\nGCRF to ITRF rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_gcrf_to_itrf[(0, 0)], r_gcrf_to_itrf[(0, 1)], r_gcrf_to_itrf[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_gcrf_to_itrf[(1, 0)], r_gcrf_to_itrf[(1, 1)], r_gcrf_to_itrf[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_gcrf_to_itrf[(2, 0)], r_gcrf_to_itrf[(2, 1)], r_gcrf_to_itrf[(2, 2)]);\n    // [ 0.1794538, -0.9837663, -0.0003836]\n    // [ 0.9837637,  0.1794542, -0.0022908]\n    // [ 0.0023225,  0.0000338,  0.9999973]\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF Cartesian state and extract position\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    println!(\"Position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform position using rotation matrix\n    let pos_itrf = r_gcrf_to_itrf * pos_gcrf;\n\n    println!(\"Position in ITRF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_itrf[0], pos_itrf[1], pos_itrf[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Verify using position transformation function\n    let pos_itrf_direct = bh::position_gcrf_to_itrf(epc, pos_gcrf);\n    println!(\"\\nPosition in ITRF (using position_gcrf_to_itrf):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_itrf_direct[0], pos_itrf_direct[1], pos_itrf_direct[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n}\n</code></pre>"},{"location":"learn/frames/gcrf_itrf.html#itrf-to-gcrf","title":"ITRF to GCRF","text":"<p>Transform coordinates from the Earth-fixed ITRF to the inertial GCRF.</p>"},{"location":"learn/frames/gcrf_itrf.html#state-vector_1","title":"State Vector","text":"<p>Transform a complete state vector (position and velocity) from ITRF to GCRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements in degrees\n# LEO satellite: 500 km altitude, sun-synchronous orbit\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\nprint(\"Orbital elements (degrees):\")\nprint(f\"  a    = {oe[0]:.3f} m = {(oe[0] - bh.R_EARTH) / 1e3:.1f} km altitude\")\nprint(f\"  e    = {oe[1]:.4f}\")\nprint(f\"  i    = {oe[2]:.4f}\u00b0\")\nprint(f\"  \u03a9    = {oe[3]:.4f}\u00b0\")\nprint(f\"  \u03c9    = {oe[4]:.4f}\u00b0\")\nprint(f\"  M    = {oe[5]:.4f}\u00b0\\n\")\n\n# Convert to GCRF Cartesian state\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\nprint(f\"Epoch: {epc}\")\nprint(\"GCRF state vector:\")\nprint(f\"  Position: [{state_gcrf[0]:.3f}, {state_gcrf[1]:.3f}, {state_gcrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_gcrf[3]:.6f}, {state_gcrf[4]:.6f}, {state_gcrf[5]:.6f}] m/s\\n\"\n)\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Transform to ITRF\nstate_itrf = bh.state_gcrf_to_itrf(epc, state_gcrf)\n\nprint(\"ITRF state vector:\")\nprint(f\"  Position: [{state_itrf[0]:.3f}, {state_itrf[1]:.3f}, {state_itrf[2]:.3f}] m\")\nprint(\n    f\"  Velocity: [{state_itrf[3]:.6f}, {state_itrf[4]:.6f}, {state_itrf[5]:.6f}] m/s\\n\"\n)\n# Position: [757164.267, 1725863.563, 6564672.302] m\n# Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n# Transform back to GCRF\nstate_gcrf_back = bh.state_itrf_to_gcrf(epc, state_itrf)\n\nprint(\"\\nGCRF state vector (transformed from ITRF):\")\nprint(\n    f\"  Position: [{state_gcrf_back[0]:.3f}, {state_gcrf_back[1]:.3f}, {state_gcrf_back[2]:.3f}] m\"\n)\nprint(\n    f\"  Velocity: [{state_gcrf_back[3]:.6f}, {state_gcrf_back[4]:.6f}, {state_gcrf_back[5]:.6f}] m/s\"\n)\n# Position: [1848964.106, -434937.468, 6560410.530] m\n# Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n# Verify round-trip transformation\ndiff_pos = np.linalg.norm(state_gcrf[0:3] - state_gcrf_back[0:3])\ndiff_vel = np.linalg.norm(state_gcrf[3:6] - state_gcrf_back[3:6])\nprint(\"\\nRound-trip error:\")\nprint(f\"  Position: {diff_pos:.6e} m\")\nprint(f\"  Velocity: {diff_vel:.6e} m/s\")\n\n# Expected output:\n#   Position: 9.617484e-10 m\n#   Velocity: 9.094947e-13 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements in degrees\n    // LEO satellite: 500 km altitude, sun-synchronous orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // Right ascension of ascending node (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    println!(\"Orbital elements (degrees):\");\n    println!(\"  a    = {:.3} m = {:.1} km altitude\", oe[0], (oe[0] - bh::R_EARTH) / 1e3);\n    println!(\"  e    = {:.4}\", oe[1]);\n    println!(\"  i    = {:.4}\u00b0\", oe[2]);\n    println!(\"  \u03a9    = {:.4}\u00b0\", oe[3]);\n    println!(\"  \u03c9    = {:.4}\u00b0\", oe[4]);\n    println!(\"  M    = {:.4}\u00b0\\n\", oe[5]);\n\n    // Convert to GCRF Cartesian state\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    println!(\"GCRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_gcrf[3], state_gcrf[4], state_gcrf[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Transform to ITRF\n    let state_itrf = bh::state_gcrf_to_itrf(epc, state_gcrf);\n\n    println!(\"ITRF state vector:\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_itrf[0], state_itrf[1], state_itrf[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\\n\", state_itrf[3], state_itrf[4], state_itrf[5]);\n    // Position: [757164.267, 1725863.563, 6564672.302] m\n    // Velocity: [989.350643, -7432.740021, 1896.768934] m/s\n\n    // Transform back to GCRF\n    let state_gcrf_back = bh::state_itrf_to_gcrf(epc, state_itrf);\n\n    println!(\"\\nGCRF state vector (transformed from ITRF):\");\n    println!(\"  Position: [{:.3}, {:.3}, {:.3}] m\", state_gcrf_back[0], state_gcrf_back[1], state_gcrf_back[2]);\n    println!(\"  Velocity: [{:.6}, {:.6}, {:.6}] m/s\", state_gcrf_back[3], state_gcrf_back[4], state_gcrf_back[5]);\n    // Position: [1848964.106, -434937.468, 6560410.530] m\n    // Velocity: [-7098.379734, -2173.344867, 1913.333385] m/s\n\n    // Verify round-trip transformation\n    let diff_pos = (na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]) -\n                    na::Vector3::new(state_gcrf_back[0], state_gcrf_back[1], state_gcrf_back[2])).norm();\n    let diff_vel = (na::Vector3::new(state_gcrf[3], state_gcrf[4], state_gcrf[5]) -\n                    na::Vector3::new(state_gcrf_back[3], state_gcrf_back[4], state_gcrf_back[5])).norm();\n    println!(\"\\nRound-trip error:\");\n    println!(\"  Position: {:.6e} m\", diff_pos);\n    println!(\"  Velocity: {:.6e} m/s\", diff_vel);\n\n    // Expected output:\n    //   Position: 9.617484e-10 m\n    //   Velocity: 9.094947e-13 m/s\n}\n</code></pre> <p>Velocity Transformation</p> <p>Simply rotating velocity vectors will not yield correct velocity components in the GCRF frame due to the Earth's rotation. State vector transformation functions properly account for observed velocity changes when transforming from the rotating ITRF frame.</p>"},{"location":"learn/frames/gcrf_itrf.html#rotation-matrix_1","title":"Rotation Matrix","text":"<p>Get the rotation matrix from ITRF to GCRF:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get rotation matrix from ITRF to GCRF\nR_itrf_to_gcrf = bh.rotation_itrf_to_gcrf(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nITRF to GCRF rotation matrix:\")\nprint(\n    f\"  [{R_itrf_to_gcrf[0, 0]:10.7f}, {R_itrf_to_gcrf[0, 1]:10.7f}, {R_itrf_to_gcrf[0, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_itrf_to_gcrf[1, 0]:10.7f}, {R_itrf_to_gcrf[1, 1]:10.7f}, {R_itrf_to_gcrf[1, 2]:10.7f}]\"\n)\nprint(\n    f\"  [{R_itrf_to_gcrf[2, 0]:10.7f}, {R_itrf_to_gcrf[2, 1]:10.7f}, {R_itrf_to_gcrf[2, 2]:10.7f}]\\n\"\n)\n# [ 0.1794538,  0.9837637,  0.0023225]\n# [-0.9837663,  0.1794542,  0.0000338]\n# [-0.0003836, -0.0022908,  0.9999973]\n\n# Verify it's the transpose of GCRF to ITRF rotation\nR_gcrf_to_itrf = bh.rotation_gcrf_to_itrf(epc)\nprint(\"Verification: R_itrf_to_gcrf = R_gcrf_to_itrf^T\")\nprint(f\"  Max difference: {np.max(np.abs(R_itrf_to_gcrf - R_gcrf_to_itrf.T)):.2e}\\n\")\n# Max difference: 0.00e0\n\n# Define orbital elements in degrees for satellite position\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF Cartesian state and extract position\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Transform to ITRF\npos_itrf = bh.position_gcrf_to_itrf(epc, state_gcrf[0:3])\n\nprint(\"Satellite position in ITRF:\")\nprint(f\"  [{pos_itrf[0]:.3f}, {pos_itrf[1]:.3f}, {pos_itrf[2]:.3f}] m\\n\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Transform back to GCRF using rotation matrix\npos_gcrf = R_itrf_to_gcrf @ pos_itrf\n\nprint(\"Satellite position in GCRF (using rotation matrix):\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Verify using position transformation function\npos_gcrf_direct = bh.position_itrf_to_gcrf(epc, pos_itrf)\nprint(\"\\nSatellite position in GCRF (using position_itrf_to_gcrf):\")\nprint(\n    f\"  [{pos_gcrf_direct[0]:.3f}, {pos_gcrf_direct[1]:.3f}, {pos_gcrf_direct[2]:.3f}] m\"\n)\n# [1848964.106, -434937.468, 6560410.530] m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get rotation matrix from ITRF to GCRF\n    let r_itrf_to_gcrf = bh::rotation_itrf_to_gcrf(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nITRF to GCRF rotation matrix:\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_itrf_to_gcrf[(0, 0)], r_itrf_to_gcrf[(0, 1)], r_itrf_to_gcrf[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_itrf_to_gcrf[(1, 0)], r_itrf_to_gcrf[(1, 1)], r_itrf_to_gcrf[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_itrf_to_gcrf[(2, 0)], r_itrf_to_gcrf[(2, 1)], r_itrf_to_gcrf[(2, 2)]);\n    // [ 0.1794538,  0.9837637,  0.0023225]\n    // [-0.9837663,  0.1794542,  0.0000338]\n    // [-0.0003836, -0.0022908,  0.9999973]\n\n    // Verify it's the transpose of GCRF to ITRF rotation\n    let r_gcrf_to_itrf = bh::rotation_gcrf_to_itrf(epc);\n    let diff = (r_itrf_to_gcrf - r_gcrf_to_itrf.transpose()).abs();\n    let max_diff = diff.max();\n    println!(\"Verification: R_itrf_to_gcrf = R_gcrf_to_itrf^T\");\n    println!(\"  Max difference: {:.2e}\\n\", max_diff);\n    // Max difference: 0.00e+00\n\n    // Define orbital elements in degrees for satellite position\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF Cartesian state and extract position\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf_orig = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    // Transform to ITRF\n    let pos_itrf = bh::position_gcrf_to_itrf(epc, pos_gcrf_orig);\n\n    println!(\"Satellite position in ITRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_itrf[0], pos_itrf[1], pos_itrf[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Transform back to GCRF using rotation matrix\n    let pos_gcrf = r_itrf_to_gcrf * pos_itrf;\n\n    println!(\"Satellite position in GCRF (using rotation matrix):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Verify using position transformation function\n    let pos_gcrf_direct = bh::position_itrf_to_gcrf(epc, pos_itrf);\n    println!(\"\\nSatellite position in GCRF (using position_itrf_to_gcrf):\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_gcrf_direct[0], pos_gcrf_direct[1], pos_gcrf_direct[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n}\n</code></pre>"},{"location":"learn/frames/gcrf_itrf.html#intermediate-rotation-matrices","title":"Intermediate Rotation Matrices","text":"<p>The full GCRF to ITRF transformation is composed of three sequential rotations. Brahe provides access to these intermediate rotation matrices for advanced applications or for understanding the transformation components.</p> <p>The complete transformation chain is:</p> <pre><code>GCRF \u2194 CIRS \u2194 TIRS \u2194 ITRF\n      (BPN)   (ER)   (PM)\n</code></pre> <p>where:</p> <ul> <li>BPN = Bias-Precession-Nutation: Accounts for Earth's precession and nutation</li> <li>ER = Earth Rotation: Accounts for Earth's daily rotation</li> <li>PM = Polar Motion: Accounts for polar motion and UT1-UTC corrections</li> </ul>"},{"location":"learn/frames/gcrf_itrf.html#bias-precession-nutation-matrix","title":"Bias-Precession-Nutation Matrix","text":"<p>Get the bias-precession-nutation matrix (GCRF to CIRS):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get BPN matrix (GCRF to CIRS transformation)\nR_bpn = bh.bias_precession_nutation(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nBias-Precession-Nutation (BPN) matrix:\")\nprint(\"Transforms from GCRF to CIRS\")\nprint(f\"  [{R_bpn[0, 0]:10.7f}, {R_bpn[0, 1]:10.7f}, {R_bpn[0, 2]:10.7f}]\")\nprint(f\"  [{R_bpn[1, 0]:10.7f}, {R_bpn[1, 1]:10.7f}, {R_bpn[1, 2]:10.7f}]\")\nprint(f\"  [{R_bpn[2, 0]:10.7f}, {R_bpn[2, 1]:10.7f}, {R_bpn[2, 2]:10.7f}]\\n\")\n# [ 0.9999973,  0.0000000, -0.0023216]\n# [-0.0000001,  1.0000000, -0.0000329]\n# [ 0.0023216,  0.0000329,  0.9999973]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF (ECI) position\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\n\nprint(\"Satellite position in GCRF:\")\nprint(f\"  [{pos_gcrf[0]:.3f}, {pos_gcrf[1]:.3f}, {pos_gcrf[2]:.3f}] m\\n\")\n# [1848964.106, -434937.468, 6560410.530] m\n\n# Transform to CIRS using BPN matrix\npos_cirs = R_bpn @ pos_gcrf\n\nprint(\"Satellite position in CIRS:\")\nprint(f\"  [{pos_cirs[0]:.3f}, {pos_cirs[1]:.3f}, {pos_cirs[2]:.3f}] m\")\n# [1833728.342, -435153.781, 6564671.107] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_gcrf - pos_cirs)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\n# Position change magnitude: 15821.751 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get BPN matrix (GCRF to CIRS transformation)\n    let r_bpn = bh::bias_precession_nutation(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nBias-Precession-Nutation (BPN) matrix:\");\n    println!(\"Transforms from GCRF to CIRS\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_bpn[(0, 0)], r_bpn[(0, 1)], r_bpn[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_bpn[(1, 0)], r_bpn[(1, 1)], r_bpn[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_bpn[(2, 0)], r_bpn[(2, 1)], r_bpn[(2, 2)]);\n    //  [ 0.9999973,  0.0000000, -0.0023216]\n    // [-0.0000001,  1.0000000, -0.0000329]\n    // [ 0.0023216,  0.0000329,  0.9999973]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF (ECI) position\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n\n    println!(\"Satellite position in GCRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_gcrf[0], pos_gcrf[1], pos_gcrf[2]);\n    // [1848964.106, -434937.468, 6560410.530] m\n\n    // Transform to CIRS using BPN matrix\n    let pos_cirs = r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in CIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_cirs[0], pos_cirs[1], pos_cirs[2]);\n    // [1833728.342, -435153.781, 6564671.107] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_gcrf - pos_cirs).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: BPN effects are typically meters to tens of meters\");\n    // Position change magnitude: 15821.751 m\n}\n</code></pre>"},{"location":"learn/frames/gcrf_itrf.html#earth-rotation-matrix","title":"Earth Rotation Matrix","text":"<p>Get the Earth rotation matrix (CIRS to TIRS):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get Earth rotation matrix (CIRS to TIRS transformation)\nR_er = bh.earth_rotation(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nEarth Rotation matrix:\")\nprint(\"Transforms from CIRS to TIRS\")\nprint(f\"  [{R_er[0, 0]:10.7f}, {R_er[0, 1]:10.7f}, {R_er[0, 2]:10.7f}]\")\nprint(f\"  [{R_er[1, 0]:10.7f}, {R_er[1, 1]:10.7f}, {R_er[1, 2]:10.7f}]\")\nprint(f\"  [{R_er[2, 0]:10.7f}, {R_er[2, 1]:10.7f}, {R_er[2, 2]:10.7f}]\\n\")\n# [ 0.1794542, -0.9837663,  0.0000000]\n# [ 0.9837663,  0.1794542,  0.0000000]\n# [ 0.0000000,  0.0000000,  1.0000000]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to GCRF and then to CIRS\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\nR_bpn = bh.bias_precession_nutation(epc)\npos_cirs = R_bpn @ pos_gcrf\n\nprint(\"Satellite position in CIRS:\")\nprint(f\"  [{pos_cirs[0]:.3f}, {pos_cirs[1]:.3f}, {pos_cirs[2]:.3f}] m\\n\")\n# [1833728.342, -435153.781, 6564671.107] m\n\n# Apply Earth rotation to get TIRS\npos_tirs = R_er @ pos_cirs\n\nprint(\"Satellite position in TIRS:\")\nprint(f\"  [{pos_tirs[0]:.3f}, {pos_tirs[1]:.3f}, {pos_tirs[2]:.3f}] m\")\n# [757159.942, 1725870.003, 6564671.107] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_cirs - pos_tirs)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\nprint(\"Note: Earth rotation causes large position changes (km scale)\")\nprint(f\"      due to ~{np.degrees(bh.OMEGA_EARTH * 3600):.3f}\u00b0 rotation per hour\")\n# Position change magnitude: 2414337.034 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get Earth rotation matrix (CIRS to TIRS transformation)\n    let r_er = bh::earth_rotation(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nEarth Rotation matrix:\");\n    println!(\"Transforms from CIRS to TIRS\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_er[(0, 0)], r_er[(0, 1)], r_er[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_er[(1, 0)], r_er[(1, 1)], r_er[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_er[(2, 0)], r_er[(2, 1)], r_er[(2, 2)]);\n    // [ 0.1794542, -0.9837663,  0.0000000]\n    // [ 0.9837663,  0.1794542,  0.0000000]\n    // [ 0.0000000,  0.0000000,  1.0000000]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert to GCRF and then to CIRS\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    let r_bpn = bh::bias_precession_nutation(epc);\n    let pos_cirs = r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in CIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_cirs[0], pos_cirs[1], pos_cirs[2]);\n    // [1833728.342, -435153.781, 6564671.107] m\n\n    // Apply Earth rotation to get TIRS\n    let pos_tirs = r_er * pos_cirs;\n\n    println!(\"Satellite position in TIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_tirs[0], pos_tirs[1], pos_tirs[2]);\n    // [757159.942, 1725870.003, 6564671.107] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_cirs - pos_tirs).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: Earth rotation causes large position changes (km scale)\");\n    println!(\"      due to ~{:.3}\u00b0 rotation per hour\", (bh::OMEGA_EARTH * 3600.0).to_degrees());\n    // Position change magnitude: 2414337.034 m\n}\n</code></pre>"},{"location":"learn/frames/gcrf_itrf.html#polar-motion-matrix","title":"Polar Motion Matrix","text":"<p>Get the polar motion matrix (TIRS to ITRF):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define epoch\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.UTC)\n\n# Get polar motion matrix (TIRS to ITRF transformation)\nR_pm = bh.polar_motion(epc)\n\nprint(f\"Epoch: {epc.to_datetime()}\")\nprint(\"\\nPolar Motion matrix:\")\nprint(\"Transforms from TIRS to ITRF\")\nprint(f\"  [{R_pm[0, 0]:10.7f}, {R_pm[0, 1]:10.7f}, {R_pm[0, 2]:10.7f}]\")\nprint(f\"  [{R_pm[1, 0]:10.7f}, {R_pm[1, 1]:10.7f}, {R_pm[1, 2]:10.7f}]\")\nprint(f\"  [{R_pm[2, 0]:10.7f}, {R_pm[2, 1]:10.7f}, {R_pm[2, 2]:10.7f}]\\n\")\n# [ 1.0000000, -0.0000000,  0.0000007]\n# [ 0.0000000,  1.0000000, -0.0000010]\n# [-0.0000007,  0.0000010,  1.0000000]\n\n# Define orbital elements in degrees\noe = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.01,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # RAAN (deg)\n        30.0,  # Argument of periapsis (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert through the full chain: GCRF \u2192 CIRS \u2192 TIRS\nstate_gcrf = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npos_gcrf = state_gcrf[0:3]\nR_bpn = bh.bias_precession_nutation(epc)\nR_er = bh.earth_rotation(epc)\npos_tirs = R_er @ R_bpn @ pos_gcrf\n\nprint(\"Satellite position in TIRS:\")\nprint(f\"  [{pos_tirs[0]:.3f}, {pos_tirs[1]:.3f}, {pos_tirs[2]:.3f}] m\\n\")\n# [757159.942, 1725870.003, 6564671.107] m\n\n# Apply polar motion to get ITRF\npos_itrf = R_pm @ pos_tirs\n\nprint(\"Satellite position in ITRF:\")\nprint(f\"  [{pos_itrf[0]:.3f}, {pos_itrf[1]:.3f}, {pos_itrf[2]:.3f}] m\")\n# [757164.267, 1725863.563, 6564672.302] m\n\n# Calculate the magnitude of the change\ndiff = np.linalg.norm(pos_tirs - pos_itrf)\nprint(f\"\\nPosition change magnitude: {diff:.3f} m\")\nprint(\"Note: Polar motion effects are typically centimeters to meters\")\n# Position change magnitude: 7.849 m\n\n# Verify against full transformation\npos_itrf_direct = bh.position_gcrf_to_itrf(epc, pos_gcrf)\nprint(\"\\nVerification using position_gcrf_to_itrf:\")\nprint(\n    f\"  [{pos_itrf_direct[0]:.3f}, {pos_itrf_direct[1]:.3f}, {pos_itrf_direct[2]:.3f}] m\"\n)\nprint(f\"  Max difference: {np.max(np.abs(pos_itrf - pos_itrf_direct)):.2e} m\")\n# [757164.267, 1725863.563, 6564672.302] m\n# Max difference: 1.16e-10 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define epoch\n    let epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc = epc + 12.0 * 3600.0;  // Add 12 hours\n\n    // Get polar motion matrix (TIRS to ITRF transformation)\n    let r_pm = bh::polar_motion(epc);\n\n    println!(\"Epoch: 2024-01-01 12:00:00 UTC\");\n    println!(\"\\nPolar Motion matrix:\");\n    println!(\"Transforms from TIRS to ITRF\");\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_pm[(0, 0)], r_pm[(0, 1)], r_pm[(0, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\", r_pm[(1, 0)], r_pm[(1, 1)], r_pm[(1, 2)]);\n    println!(\"  [{:10.7}, {:10.7}, {:10.7}]\\n\", r_pm[(2, 0)], r_pm[(2, 1)], r_pm[(2, 2)]);\n    // [ 1.0000000, -0.0000000,  0.0000007]\n    // [ 0.0000000,  1.0000000, -0.0000010]\n    // [-0.0000007,  0.0000010,  1.0000000]\n\n    // Define orbital elements in degrees\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.01,                  // Eccentricity\n        97.8,                  // Inclination (deg)\n        15.0,                  // RAAN (deg)\n        30.0,                  // Argument of periapsis (deg)\n        45.0,                  // Mean anomaly (deg)\n    );\n\n    // Convert through the full chain: GCRF \u2192 CIRS \u2192 TIRS\n    let state_gcrf = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let pos_gcrf = na::Vector3::new(state_gcrf[0], state_gcrf[1], state_gcrf[2]);\n    let r_bpn = bh::bias_precession_nutation(epc);\n    let r_er = bh::earth_rotation(epc);\n    let pos_tirs = r_er * r_bpn * pos_gcrf;\n\n    println!(\"Satellite position in TIRS:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\\n\", pos_tirs[0], pos_tirs[1], pos_tirs[2]);\n    // [757159.942, 1725870.003, 6564671.107] m\n\n    // Apply polar motion to get ITRF\n    let pos_itrf = r_pm * pos_tirs;\n\n    println!(\"Satellite position in ITRF:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_itrf[0], pos_itrf[1], pos_itrf[2]);\n    // [757164.267, 1725863.563, 6564672.302] m\n\n    // Calculate the magnitude of the change\n    let diff = (pos_tirs - pos_itrf).norm();\n    println!(\"\\nPosition change magnitude: {:.3} m\", diff);\n    println!(\"Note: Polar motion effects are typically centimeters to meters\");\n    // Position change magnitude: 7.849 m\n\n    // Verify against full transformation\n    let pos_itrf_direct = bh::position_gcrf_to_itrf(epc, pos_gcrf);\n    println!(\"\\nVerification using position_gcrf_to_itrf:\");\n    println!(\"  [{:.3}, {:.3}, {:.3}] m\", pos_itrf_direct[0], pos_itrf_direct[1], pos_itrf_direct[2]);\n    let max_diff = (pos_itrf - pos_itrf_direct).abs().max();\n    println!(\"  Max difference: {:.2e} m\", max_diff);\n    // [757164.267, 1725863.563, 6564672.302] m\n    // Max difference: 1.16e-10 m\n}\n</code></pre> <p>Note</p> <p>For most applications, use the combined <code>rotation_gcrf_to_itrf</code> or <code>state_gcrf_to_itrf</code> functions rather than computing intermediate matrices separately. The intermediate matrices are provided for educational purposes and specialized applications.</p>"},{"location":"learn/frames/gcrf_itrf.html#see-also","title":"See Also","text":"<ul> <li>ECI \u2194 ECEF Naming Convention - Legacy naming convention that maps to GCRF/ITRF</li> <li>Reference Frames Overview - Complete overview of all reference frames in Brahe</li> </ul>"},{"location":"learn/integrators/index.html","title":"Numerical Integration","text":"<p>Numerical integration is fundamental to spacecraft trajectory propagation, orbit determination, and mission planning. Brahe provides multiple integration methods optimized for different accuracy and performance requirements.</p> <p>Experimental Feature</p> <p>The integrators module is currently experimental. While the core functionality should be stable, the API may change in future MINOR releases as we refine the design and add features.</p>"},{"location":"learn/integrators/index.html#what-is-numerical-integration","title":"What is Numerical Integration?","text":"<p>Numerical integration solves ordinary differential equations (ODEs) of the form:</p> \\[\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x})\\] <p>\\(\\mathbf{x}\\) is the state vector, typically position and velocity \\(\\mathbf{x} = \\begin{bmatrix} \\mathbf{p} \\\\ \\mathbf{v} \\end{bmatrix}\\), and \\(\\mathbf{f}\\) defines the dynamics (gravity, perturbations, thrust, etc.). The integrator advances the state forward in time from an initial condition \\(\\mathbf{x}_0\\) at time \\(t_0\\) to \\(\\mathbf{x}(t)\\) at some future time \\(t\\).</p> <p>In an ideal world, we would have closed-form analytical solutions for these equations. However, real-world dynamics are often too complex for exact solutions, necessitating numerical methods that approximate the solution. It is often much easier to write down the equations for the dynamics (force models) than to derive analytical solutions for them. Numerical integrators provide a way to compute these approximations efficiently and accurately.</p>"},{"location":"learn/integrators/index.html#available-integrators","title":"Available Integrators","text":"<p>Brahe provides four integration methods with different accuracy and performance characteristics:</p> Integrator Order Type Stages RK4 4 Fixed 4 RKF45 4(5) Adaptive 6 DP54 5(4) Adaptive 7 (6 effective) RKN1210 12(10) Adaptive 17"},{"location":"learn/integrators/index.html#common-interfaces","title":"Common Interfaces","text":"<p>All integrators implement a consistent interface, making it easy to switch between methods.</p>"},{"location":"learn/integrators/index.html#core-types","title":"Core Types","text":"<p><code>IntegratorConfig</code>: Configuration controlling integration behavior</p> <ul> <li><code>abs_tol</code>, <code>rel_tol</code>: Error tolerances (adaptive mode)</li> <li><code>min_step</code>, <code>max_step</code>: Step size bounds</li> <li><code>step_safety_factor</code>: Conservative factor for step size adjustment (default 0.9)</li> </ul> <p><code>AdaptiveStepResult</code>: Result from adaptive integration step</p> <ul> <li><code>state</code>: New state vector after integration</li> <li><code>dt_used</code>: Actual time step taken (may differ from requested)</li> <li><code>error_estimate</code>: Estimated error in the step</li> <li><code>dt_next</code>: Recommended step size for next integration</li> </ul>"},{"location":"learn/integrators/index.html#dynamics-function-signature","title":"Dynamics Function Signature","text":""},{"location":"learn/integrators/index.html#control-input-function-signature","title":"Control Input Function Signature","text":"<p>The control input function must follow specific signatures depending on the language:</p> PythonRust <pre><code>def dynamics_fn(t: float, state: np.ndarray, params: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Args:\n        t: Current time\n        state: Current state vector\n        params: Fixed auxiliary parameters\n\n    Returns:\n        d_state: Derivative of state vector\n    \"\"\"\n    pass\n</code></pre> <p>Must be a closure or function with the signature, that either uses dynamic or static sized vectors:</p> <pre><code>Fn(f64, DVector&lt;f64&gt;, DVector&lt;f64&gt;) -&gt; DVector&lt;f64&gt;\n</code></pre> <p>or</p> <pre><code>Fn(f64, SVector&lt;f64, S&gt;, SVector&lt;f64, P&gt;) -&gt; SVector&lt;f64, S&gt;\n</code></pre>"},{"location":"learn/integrators/index.html#integration-methods","title":"Integration Methods","text":"<p>All integrators provide these methods:</p> <p><code>step(t, state, dt)</code>: Advance state by one time step</p> <ul> <li>For fixed-step integrators: Returns new state</li> <li>For adaptive integrators: Returns <code>AdaptiveStepResult</code></li> </ul> <p><code>step_with_varmat(t, state, phi, dt)</code>: Advance state and state transition matrix</p> <ul> <li>Propagates both state and variational equations</li> <li>Requires a Jacobian provider</li> <li>Essential for orbit determination and uncertainty propagation</li> </ul>"},{"location":"learn/integrators/index.html#comparing-integrator-accuracy","title":"Comparing Integrator Accuracy","text":"<p>The plot below shows position error vs. time for different integrators propagating a highly elliptical orbit (HEO) compared to analytical Keplerian propagation. All adaptive integrators use the same tolerances (abs_tol=1e-10, rel_tol=1e-9). In the figure, we can see that after one orbit, RKN1210 achieves sub-millimeter accuracy, while DP54 and RKF45 reach meter-level accuracy. The fixed-step RK4 with a 60s step has the most error, reaching about 1000m after one orbit.</p> Plot Source integrator_accuracy_comparison.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport numpy as np\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import save_themed_html, get_color_sequence\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize Brahe\nbh.initialize_eop()\n\n# Define Molniya-type HEO orbit\n# Semi-major axis for 12-hour period\na = 26554e3  # meters\ne = 0.74  # eccentricity\ni = np.radians(63.4)  # inclination (critical inclination)\nomega = 0.0  # argument of perigee\nOmega = 0.0  # RAAN\nM0 = 0.0  # mean anomaly\n\n# Convert to Cartesian state\noe = np.array([a, e, i, Omega, omega, M0])\ninitial_state = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\n# Orbital period\nperiod = 2 * np.pi * np.sqrt(a**3 / bh.GM_EARTH)\n\n\n# Define two-body dynamics\ndef two_body_dynamics(t, state):\n    \"\"\"Simple two-body dynamics for integration.\"\"\"\n    mu = bh.GM_EARTH\n    r = state[0:3]\n    v = state[3:6]\n    r_norm = np.linalg.norm(r)\n    a = -mu / r_norm**3 * r\n    return np.concatenate([v, a])\n\n\n# Analytical solution using Keplerian propagation\ndef analytical_solution(t):\n    \"\"\"Compute analytical Keplerian state at time t.\"\"\"\n    # Mean motion\n    n = np.sqrt(bh.GM_EARTH / a**3)\n    # Mean anomaly at time t\n    M = M0 + n * t\n    # Convert back to Cartesian\n    oe_t = np.array([a, e, i, Omega, omega, M])\n    return bh.state_koe_to_eci(oe_t, bh.AngleFormat.RADIANS)\n\n\n# Integration parameters\nt_start = 0.0\nt_end = period  # One orbital period\noutput_interval = 60.0  # Output every 60 seconds\n\n# Common configuration for adaptive integrators\nabs_tol = 1e-10\nrel_tol = 1e-9\n\n# Create integrators\nconfig_rk4 = bh.IntegratorConfig.fixed_step(step_size=60.0)\nconfig_adaptive = bh.IntegratorConfig.adaptive(abs_tol=abs_tol, rel_tol=rel_tol)\n\nintegrator_rk4 = bh.RK4Integrator(6, two_body_dynamics, config=config_rk4)\nintegrator_rkf45 = bh.RKF45Integrator(6, two_body_dynamics, config=config_adaptive)\nintegrator_dp54 = bh.DP54Integrator(6, two_body_dynamics, config=config_adaptive)\nintegrator_rkn1210 = bh.RKN1210Integrator(6, two_body_dynamics, config=config_adaptive)\n\n\n# Propagate with each integrator\ndef propagate(integrator, is_adaptive=True):\n    \"\"\"Propagate orbit and record states at output intervals.\"\"\"\n    times = []\n    states = []\n    errors = []\n\n    t = t_start\n    state = initial_state.copy()\n    dt = 60.0  # Initial step guess\n    next_output = 0.0\n\n    while t &lt; t_end:\n        # Check if we should save output\n        if t &gt;= next_output:\n            times.append(t)\n            states.append(state.copy())\n\n            # Compute error vs analytical solution\n            analytical = analytical_solution(t)\n            pos_error = np.linalg.norm(state[0:3] - analytical[0:3])\n            errors.append(pos_error)\n\n            next_output += output_interval\n\n        # Integrate one step\n        if is_adaptive:\n            result = integrator.step(t, state, min(dt, t_end - t))\n            t += result.dt_used\n            state = result.state\n            dt = result.dt_next\n        else:\n            # Fixed step\n            dt_actual = min(dt, t_end - t)\n            new_state = integrator.step(t, state, dt_actual)\n            t += dt_actual\n            state = new_state\n\n    # Final output\n    if t &gt;= t_end - 1e-6:  # Handle floating point comparison\n        times.append(t_end)\n        analytical = analytical_solution(t_end)\n        pos_error = np.linalg.norm(state[0:3] - analytical[0:3])\n        errors.append(pos_error)\n\n    return np.array(times), np.array(errors)\n\n\nprint(\"Propagating with RK4...\")\ntimes_rk4, errors_rk4 = propagate(integrator_rk4, is_adaptive=False)\n\nprint(\"Propagating with RKF45...\")\ntimes_rkf45, errors_rkf45 = propagate(integrator_rkf45, is_adaptive=True)\n\nprint(\"Propagating with DP54...\")\ntimes_dp54, errors_dp54 = propagate(integrator_dp54, is_adaptive=True)\n\nprint(\"Propagating with RKN1210...\")\ntimes_rkn1210, errors_rkn1210 = propagate(integrator_rkn1210, is_adaptive=True)\n\n\n# Create figure with theme support\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_color_sequence(theme, num_colors=4)\n\n    fig = go.Figure()\n\n    # Add traces for each integrator with custom hover templates\n    # First trace includes time at top, others don't to avoid duplication\n    fig.add_trace(\n        go.Scatter(\n            x=times_rk4 / 3600,  # Convert to hours\n            y=errors_rk4,\n            name=\"RK4 (Fixed, dt=60s)\",\n            mode=\"lines\",\n            line=dict(color=colors[0], width=2),\n            hovertemplate=\"t=%{x:.2f} hours&lt;br&gt;&lt;b&gt;RK4&lt;/b&gt;&lt;br&gt;Error: %{y:.2e} m&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times_rkf45 / 3600,\n            y=errors_rkf45,\n            name=\"RKF45 (Adaptive)\",\n            mode=\"lines\",\n            line=dict(color=colors[1], width=2),\n            hovertemplate=\"&lt;b&gt;RKF45&lt;/b&gt;&lt;br&gt;Error: %{y:.2e} m&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times_dp54 / 3600,\n            y=errors_dp54,\n            name=\"DP54 (Adaptive)\",\n            mode=\"lines\",\n            line=dict(color=colors[2], width=2),\n            hovertemplate=\"&lt;b&gt;DP54&lt;/b&gt;&lt;br&gt;Error: %{y:.2e} m&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times_rkn1210 / 3600,\n            y=errors_rkn1210,\n            name=\"RKN1210 (Adaptive)\",\n            mode=\"lines\",\n            line=dict(color=colors[3], width=2),\n            hovertemplate=\"&lt;b&gt;RKN1210&lt;/b&gt;&lt;br&gt;Error: %{y:.2e} m&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Configure layout\n    fig.update_layout(\n        title=\"Integrator Accuracy Comparison: HEO Orbit\",\n        xaxis_title=\"Time (hours)\",\n        yaxis_title=\"Position Error (m)\",\n        yaxis_type=\"log\",\n        hovermode=\"x unified\",\n        legend=dict(yanchor=\"top\", y=0.99, xanchor=\"left\", x=0.01),\n    )\n\n    # Configure axes - hide default x-value in hover since we show it in first trace\n    fig.update_xaxes(title_text=\"Time (hours)\", unifiedhovertitle=dict(text=\"\"))\n    fig.update_yaxes(title_text=\"Position Error (m)\", type=\"log\")\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/integrators/index.html#basic-usage-patterns","title":"Basic Usage Patterns","text":""},{"location":"learn/integrators/index.html#fixed-step-integration","title":"Fixed-Step Integration","text":"<p>To use a fixed-step integrator like RK4, you create an instance with the desired step size and call <code>step</code> in a loop:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\ndef dynamics(t, state):\n    \"\"\"Exponential decay dynamics: dx/dt = -k*x\"\"\"\n    k = 0.1\n    return np.array([-k * state[0]])\n\n\n# Create fixed-step integrator\nconfig = bh.IntegratorConfig.fixed_step(step_size=10.0)\nintegrator = bh.RK4Integrator(1, dynamics, config=config)\n\n# Integrate one step\nt = 0.0\ninitial_state = np.array([1.0])\nnew_state = integrator.step(t, initial_state, dt=10.0)\n\nprint(f\"Initial state: {initial_state[0]:.6f}\")\nprint(f\"State after 10s: {new_state[0]:.6f}\")\nprint(f\"Analytical: {initial_state[0] * np.exp(-0.1 * 10.0):.6f}\")\n</code></pre> <pre><code>//! Simple fixed-step integration pattern example.\n//!\n//! Demonstrates the basic pattern for using a fixed-step integrator\n//! with exponential decay dynamics.\n\nuse brahe::integrators::*;\nuse nalgebra::DVector;\n\nfn main() {\n    // Dynamics function: Exponential decay dx/dt = -k*x\n    let k = 0.1;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![-k * state[0]])\n    };\n\n    // Create fixed-step integrator\n    let config = IntegratorConfig::fixed_step(10.0);\n    let integrator = RK4DIntegrator::with_config(\n        1,\n        Box::new(dynamics),\n        None,\n        None,\n        None,\n        config\n    );\n\n    // Integrate one step\n    let t = 0.0;\n    let initial_state = DVector::from_vec(vec![1.0]);\n    let result = integrator.step(t, initial_state.clone(), None, None);\n    let new_state = result.state;\n\n    println!(\"Initial state: {:.6}\", initial_state[0]);\n    println!(\"State after 10s: {:.6}\", new_state[0]);\n    println!(\"Analytical: {:.6}\", initial_state[0] * (-0.1 * 10.0_f64).exp());\n}\n</code></pre>"},{"location":"learn/integrators/index.html#adaptive-integration","title":"Adaptive Integration","text":"<p>To use an adaptive-step integrator like RKF45, you create it with an <code>IntegratorConfig</code> specifying tolerances, then call <code>step</code>. The adaptive integrator returns an <code>AdaptiveStepResult</code> containing the new state and recommended next step size.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\ndef dynamics(t, state):\n    \"\"\"Exponential decay dynamics: dx/dt = -k*x\"\"\"\n    k = 0.1\n    return np.array([-k * state[0]])\n\n\n# Create adaptive integrator\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-10, rel_tol=1e-9)\nintegrator = bh.DP54Integrator(1, dynamics, config=config)\n\n# Integrate with automatic step control\nt = 0.0\ninitial_state = np.array([1.0])\ndt = 60.0  # Initial guess\n\nresult = integrator.step(t, initial_state, dt)\n\nprint(f\"Initial state: {initial_state[0]:.6f}\")\nprint(f\"State after step: {result.state[0]:.6f}\")\nprint(f\"Step used: {result.dt_used:.2f}s\")\nprint(f\"Recommended next step: {result.dt_next:.2f}s\")\nprint(f\"Error estimate: {result.error_estimate:.2e}\")\n</code></pre> <pre><code>//! Simple adaptive-step integration pattern example.\n//!\n//! Demonstrates the basic pattern for using an adaptive-step integrator\n//! with exponential decay dynamics.\n\nuse brahe::integrators::*;\nuse nalgebra::DVector;\n\nfn main() {\n    // Dynamics function: Exponential decay dx/dt = -k*x\n    let k = 0.1;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![-k * state[0]])\n    };\n\n    // Create adaptive integrator\n    let config = IntegratorConfig::adaptive(1e-10, 1e-9);\n    let integrator = DormandPrince54DIntegrator::with_config(\n        1,\n        Box::new(dynamics),\n        None,\n        None,\n        None,\n        config\n    );\n\n    // Integrate with automatic step control\n    let t = 0.0;\n    let initial_state = DVector::from_vec(vec![1.0]);\n    let dt = 60.0; // Initial guess\n\n    let result = integrator.step(t, initial_state.clone(), None, Some(dt));\n\n    println!(\"Initial state: {:.6}\", initial_state[0]);\n    println!(\"State after step: {:.6}\", result.state[0]);\n    println!(\"Step used: {:.2}s\", result.dt_used);\n    println!(\"Recommended next step: {:.2}s\", result.dt_next);\n    println!(\"Error estimate: {:.2e}\", result.error_estimate.unwrap());\n}\n</code></pre> <p>To take multiple steps until a final time, you can use a loop that updates the time and state based on the <code>dt_used</code> and <code>dt_next</code> values from the result.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\ndef dynamics(t, state):\n    \"\"\"Exponential decay dynamics: dx/dt = -k*x\"\"\"\n    k = 0.1\n    return np.array([-k * state[0]])\n\n\n# Create adaptive integrator\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-10, rel_tol=1e-9)\nintegrator = bh.DP54Integrator(1, dynamics, config=config)\n\n# Propagate from t=0 to t_end\nt = 0.0\nt_end = 86400.0  # One day\nstate = np.array([1.0])\ndt = 60.0\n\nstep_count = 0\nwhile t &lt; t_end:\n    result = integrator.step(t, state, min(dt, t_end - t))\n    t += result.dt_used\n    state = result.state\n    dt = result.dt_next\n    step_count += 1\n\nprint(f\"Propagated from 0 to {t_end}s in {step_count} steps\")\nprint(f\"Final state: {state[0]:.6e}\")\nprint(f\"Analytical: {np.exp(-0.1 * t_end):.6e}\")\nprint(f\"Error: {abs(state[0] - np.exp(-0.1 * t_end)):.2e}\")\n</code></pre> <pre><code>//!\n//! Demonstrates the pattern for propagating over an extended time period\n//! using an adaptive integrator, using the recommended step size from\n//! each step for the next step.\n\nuse brahe::integrators::*;\nuse nalgebra::DVector;\n\nfn main() {\n    // Dynamics function: Exponential decay dx/dt = -k*x\n    let k = 0.1;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![-k * state[0]])\n    };\n\n    // Create adaptive integrator\n    let config = IntegratorConfig::adaptive(1e-10, 1e-9);\n    let integrator = DormandPrince54DIntegrator::with_config(\n        1,\n        Box::new(dynamics),\n        None,\n        None,\n        None,\n        config\n    );\n\n    // Propagate from t=0 to t_end\n    let mut t = 0.0;\n    let t_end = 86400.0; // One day\n    let mut state = DVector::from_vec(vec![1.0]);\n    let mut dt: f64 = 60.0;\n\n    let mut step_count = 0;\n    while t &lt; t_end {\n        let result = integrator.step(t, state, None, Some(dt.min(t_end - t)));\n        t += result.dt_used;\n        state = result.state;\n        dt = result.dt_next;\n        step_count += 1;\n    }\n\n    let analytical = (-0.1 * t_end).exp();\n    println!(\"Propagated from 0 to {}s in {} steps\", t_end, step_count);\n    println!(\"Final state: {:.6e}\", state[0]);\n    println!(\"Analytical: {:.6e}\", analytical);\n    println!(\"Error: {:.2e}\", (state[0] - analytical).abs());\n}\n</code></pre>"},{"location":"learn/integrators/index.html#state-transition-matrix-propagation","title":"State Transition Matrix Propagation","text":"<p>For orbit determination and covariance propagation, you often need to propagate the state transition matrix (STM) alongside the state. The STM \\(\\Phi(t, t_0)\\) maps perturbations in initial state to perturbations in final state:</p> \\[\\delta\\mathbf{x}(t) = \\Phi(t, t_0) \\cdot \\delta\\mathbf{x}(t_0)\\] <p>State transition matrices are needed for a few key aspects of astrodynamics including:</p> <ul> <li>Covariance propagation: \\(P(t) = \\Phi(t, t_0) P(t_0) \\Phi(t, t_0)^T\\)</li> <li>Sensitivity analysis: How errors in initial conditions affect trajectory</li> <li>Orbit determination: Computing measurement sensitivities</li> </ul> <p>They can be propagated by integrating the variational equations alongside the state, which requires computing the Jacobian of the dynamics. Brahe's integrators support this via the <code>step_with_varmat</code> method. You can learn more about defining Jacobians in the Jacobian Computation guide.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\ndef dynamics(t, state):\n    \"\"\"Exponential decay dynamics: dx/dt = -k*x\"\"\"\n    k = 0.1\n    return np.array([-k * state[0]])\n\n\n# Create Jacobian for variational equations\njacobian = bh.NumericalJacobian.central(dynamics).with_adaptive(\n    scale_factor=1e-8, min_value=1e-6\n)\n\n# Create integrator with Jacobian\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-12, rel_tol=1e-11)\nintegrator = bh.DP54Integrator(1, dynamics, jacobian=jacobian, config=config)\n\n# Propagate state and STM\nt = 0.0\nstate = np.array([1.0])\nphi = np.eye(1)  # Identity matrix\ndt = 60.0\n\nnew_state, new_phi, dt_used, error_est, dt_next = integrator.step_with_varmat(\n    t, state, phi, dt\n)\n\nprint(f\"Initial state: {state[0]:.6f}\")\nprint(f\"State after {dt_used:.2f}s: {new_state[0]:.6f}\")\nprint(\"State transition matrix:\")\nprint(f\"  \u03a6 = {new_phi[0, 0]:.6f}\")\nprint(f\"  (Analytical \u03a6 = {np.exp(-0.1 * dt_used):.6f})\")\n</code></pre> <pre><code>//! State Transition Matrix propagation pattern example.\n//!\n//! Demonstrates the basic pattern for propagating a state transition matrix\n//! alongside the state using variational equations.\n\nuse brahe::integrators::*;\nuse brahe::math::jacobian::*;\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Dynamics function: Exponential decay dx/dt = -k*x\n    let k = 0.1;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![-k * state[0]])\n    };\n    // Clone for Jacobian computation\n    let dynamics_for_jac = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![-k * state[0]])\n    };\n\n    // Create Jacobian for variational equations\n    let jacobian = DNumericalJacobian::central(Box::new(dynamics_for_jac))\n        .with_adaptive(1e-8, 1e-6);\n\n    // Create integrator with Jacobian\n    let config = IntegratorConfig::adaptive(1e-12, 1e-11);\n    let integrator = DormandPrince54DIntegrator::with_config(\n        1,\n        Box::new(dynamics),\n        Some(Box::new(jacobian)),\n        None,\n        None,\n        config\n    );\n\n    // Propagate state and STM\n    let t = 0.0;\n    let state = DVector::from_vec(vec![1.0]);\n    let phi = DMatrix::identity(1, 1); // 1x1 identity matrix\n    let dt = 60.0;\n\n    let result = integrator.step_with_varmat(t, state, None, phi, Some(dt));\n    let new_state = result.state;\n    let new_phi = result.phi.unwrap();\n    let dt_used = result.dt_used;\n\n    println!(\"Initial state: {:.6}\", 1.0);\n    println!(\"State after {:.2}s: {:.6}\", dt_used, new_state[0]);\n    println!(\"State transition matrix:\");\n    println!(\"  \u03a6 = {:.6}\", new_phi[(0, 0)]);\n    println!(\"  (Analytical \u03a6 = {:.6})\", (-0.1 * dt_used).exp());\n}\n</code></pre>"},{"location":"learn/integrators/index.html#module-contents","title":"Module Contents","text":"<ul> <li>Fixed-Step Integrators - RK4 and fixed-step integration</li> <li>Adaptive-Step Integrators - RKF45, DP54, and RKN1210</li> <li>Variational Equations - State Transition Matrix propagation and theory</li> <li>Configuration Guide - Choosing tolerances and tuning parameters</li> </ul>"},{"location":"learn/integrators/index.html#see-also","title":"See Also","text":"<ul> <li>Comparing Integrator Performance - Complete example comparing all integrators on a 7-day orbit propagation</li> <li>Integrators API Reference - Complete API documentation</li> <li>Jacobian Computation - Required for variational equations</li> <li>Keplerian Propagation - Analytical propagation alternative</li> </ul>"},{"location":"learn/integrators/adaptive_step.html","title":"Adaptive-Step Integrators","text":"<p>Adaptive-step integrators automatically adjust their step size to maintain a specified error tolerance. This makes them efficient and reliable for problems where the optimal step size isn't known in advance or varies during integration. They are particularly useful for orbital mechanics, where dynamics can change rapidly due to close encounters or perturbations. In elliptical orbits, for example, smaller steps are needed near periapsis to capture rapid motion, while taking larger steps near apoapsis is acceptable and saves computation.</p>"},{"location":"learn/integrators/adaptive_step.html#how-adaptive-stepping-works","title":"How Adaptive Stepping Works","text":"<p>Adaptive methods estimate the local truncation error at each step by computing two solutions of different orders:</p> <ol> <li>Higher-order solution (order \\(p\\)): More accurate, used for propagation</li> <li>Lower-order solution (order \\(p-1\\)): Less accurate, used for error estimation</li> </ol> <p>The error estimate is the difference between these solutions:</p> \\[ \\varepsilon \\approx \\|\\mathbf{x}_p - \\mathbf{x}_{p-1}\\| \\] <p>This is compared against a tolerance:</p> \\[ \\text{tol} = \\text{abs\\_tol} + \\text{rel\\_tol} \\times \\|\\mathbf{x}\\| \\] <ul> <li>If \\(\\varepsilon &lt; \\text{tol}\\): Step accepted, state advances</li> <li>If \\(\\varepsilon \\geq \\text{tol}\\): Step rejected, retry with smaller \\(h\\)</li> </ul>"},{"location":"learn/integrators/adaptive_step.html#available-adaptive-integrators","title":"Available Adaptive Integrators","text":""},{"location":"learn/integrators/adaptive_step.html#rkf45-runge-kutta-fehlberg-45","title":"RKF45: Runge-Kutta-Fehlberg 4(5)","text":"<p>An embedded Runge-Kutta method using 5th-order solution for propagation and 4th-order solution for error estimation.</p>"},{"location":"learn/integrators/adaptive_step.html#dp54-dormand-prince-54","title":"DP54: Dormand-Prince 5(4)","text":"<p>An embedded Runge-Kutta method widely used in scientific computing (e.g., MATLAB's <code>ode45</code>).</p>"},{"location":"learn/integrators/adaptive_step.html#rkn1210-runge-kutta-nystrom-1210","title":"RKN1210: Runge-Kutta-Nystr\u00f6m 12(10)","text":"<p>A high-order method specialized for second-order differential equations, particularly well-suited to orbital mechanics.</p> <p>Requirements:</p> <ul> <li>State dimension must be even (position and velocity components)</li> <li>Best suited for problems naturally expressed as second-order systems (e.g., \\(\\mathbf{F} = m\\mathbf{a}\\))</li> </ul>"},{"location":"learn/integrators/adaptive_step.html#basic-usage","title":"Basic Usage","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define dynamics: Van der Pol oscillator (stiff for large mu)\nmu = 1.0\n\n\ndef dynamics(t, state):\n    x, v = state\n    return np.array([v, mu * (1 - x**2) * v - x])\n\n\n# Initial conditions\nt0 = 0.0\nstate0 = np.array([2.0, 0.0])\nt_end = 10.0\n\n# Create adaptive integrator\nabs_tol = 1e-8\nrel_tol = 1e-7\nconfig = bh.IntegratorConfig.adaptive(abs_tol=abs_tol, rel_tol=rel_tol)\nintegrator = bh.DP54Integrator(2, dynamics, config=config)\n\nprint(f\"Adaptive integration of Van der Pol oscillator (\u03bc={mu})\")\nprint(f\"Tolerances: abs_tol={abs_tol}, rel_tol={rel_tol}\")\nprint(f\"Integration time: 0 to {t_end} seconds\\n\")\n\n# Integrate with adaptive stepping\nt = t0\nstate = state0.copy()\ndt = 0.1  # Initial guess\nsteps = 0\nmin_dt = float(\"inf\")\nmax_dt = 0.0\n\nprint(\"   Time    State              Step Size   Error Est\")\nprint(\"-\" * 65)\n\nwhile t &lt; t_end:\n    result = integrator.step(t, state, min(dt, t_end - t))\n\n    # Track step size statistics\n    min_dt = min(min_dt, result.dt_used)\n    max_dt = max(max_dt, result.dt_used)\n\n    # Update state\n    t += result.dt_used\n    state = result.state\n    dt = result.dt_next\n    steps += 1\n\n    # Print progress\n    if steps % 10 == 1:\n        print(\n            f\"{t:7.3f}    [{state[0]:6.3f}, {state[1]:6.3f}]    {result.dt_used:7.4f}     {result.error_estimate:.2e}\"\n        )\n\nprint(\"\\nIntegration complete!\")\nprint(f\"Total steps: {steps}\")\nprint(f\"Min step size: {min_dt:.6f} s\")\nprint(f\"Max step size: {max_dt:.6f} s\")\nprint(f\"Average step: {t_end / steps:.6f} s\")\nprint(\"\\nAdaptive stepping automatically adjusted step size\")\nprint(f\"by {max_dt / min_dt:.1f}x during integration\")\n</code></pre> <pre><code>use brahe::integrators::*;\nuse nalgebra::DVector;\n\nfn main() {\n    // Define dynamics: Van der Pol oscillator (stiff for large mu)\n    let mu = 1.0;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let x = state[0];\n        let v = state[1];\n        DVector::from_vec(vec![v, mu * (1.0 - x.powi(2)) * v - x])\n    };\n\n    // Initial conditions\n    let t0 = 0.0;\n    let state0 = DVector::from_vec(vec![2.0, 0.0]);\n    let t_end = 10.0;\n\n    // Create adaptive integrator\n    let abs_tol = 1e-8;\n    let rel_tol = 1e-7;\n    let config = IntegratorConfig::adaptive(abs_tol, rel_tol);\n    let integrator = DormandPrince54DIntegrator::with_config(2, Box::new(dynamics), None, None, None, config);\n\n    println!(\"Adaptive integration of Van der Pol oscillator (\u03bc={})\", mu);\n    println!(\"Tolerances: abs_tol={}, rel_tol={}\", abs_tol, rel_tol);\n    println!(\"Integration time: 0 to {} seconds\\n\", t_end);\n\n    // Integrate with adaptive stepping\n    let mut t = t0;\n    let mut state = state0.clone();\n    let mut dt = 0.1_f64;  // Initial guess\n    let mut steps = 0;\n    let mut min_dt = f64::INFINITY;\n    let mut max_dt = 0.0_f64;\n\n    println!(\"   Time    State              Step Size   Error Est\");\n    println!(\"{}\", \"-\".repeat(65));\n\n    while t &lt; t_end {\n        let result = integrator.step(t, state, None, Some(dt.min(t_end - t)));\n\n        // Track step size statistics\n        let dt_used = result.dt_used;\n        min_dt = min_dt.min(dt_used);\n        max_dt = max_dt.max(dt_used);\n\n        // Update state\n        t += dt_used;\n        state = result.state;\n        dt = result.dt_next;\n        steps += 1;\n\n        // Print progress\n        if steps % 10 == 1 {\n            println!(\"{:7.3}    [{:6.3}, {:6.3}]    {:7.4}     {:.2e}\",\n                     t, state[0], state[1], dt_used, result.error_estimate.unwrap());\n        }\n    }\n\n    println!(\"\\nIntegration complete!\");\n    println!(\"Total steps: {}\", steps);\n    println!(\"Min step size: {:.6} s\", min_dt);\n    println!(\"Max step size: {:.6} s\", max_dt);\n    println!(\"Average step: {:.6} s\", t_end / steps as f64);\n    println!(\"\\nAdaptive stepping automatically adjusted step size\");\n    println!(\"by {:.1}x during integration\", max_dt / min_dt);\n}\n</code></pre>"},{"location":"learn/integrators/adaptive_step.html#step-size-control-algorithm","title":"Step Size Control Algorithm","text":"<p>After computing error estimate \\(\\varepsilon\\), the integrator calculates a new step size:</p> \\[h_{\\text{new}} = \\text{safety\\_factor} \\times h \\times \\left(\\frac{\\text{tol}}{\\varepsilon}\\right)^{1/p}\\] <p>where: - safety_factor: Conservative multiplier (default 0.9) - \\(p\\): Order of error estimate - \\(h\\): Current step size</p> <p>This is clamped to reasonable bounds:</p> \\[h_{\\text{new}} = \\text{clip}(h_{\\text{new}}, \\text{min\\_scale} \\times h, \\text{max\\_scale} \\times h)\\] <p>and absolute limits:</p> \\[h_{\\text{new}} = \\text{clip}(h_{\\text{new}}, h_{\\text{min}}, h_{\\text{max}})\\]"},{"location":"learn/integrators/adaptive_step.html#control-parameters","title":"Control Parameters","text":"<p>From <code>IntegratorConfig</code>:</p> <ul> <li><code>abs_tol</code>: Absolute error tolerance (default 1e-10)</li> <li><code>rel_tol</code>: Relative error tolerance (default 1e-9)</li> <li><code>min_step</code>: Minimum allowed step size (default 1e-12 s)</li> <li><code>max_step</code>: Maximum allowed step size (default 900 s)</li> <li><code>step_safety_factor</code>: Safety margin (default 0.9)</li> <li><code>min_step_scale_factor</code>: Min step change ratio (default 0.2)</li> <li><code>max_step_scale_factor</code>: Max step change ratio (default 10.0)</li> <li><code>max_step_attempts</code>: Max tries before error (default 10)</li> </ul>"},{"location":"learn/integrators/adaptive_step.html#highly-elliptical-orbit-example","title":"Highly Elliptical Orbit Example","text":"<p>The following example demonstrates propagating a highly elliptical orbit (HEO) using the RKN1210 adaptive-step integrator with tight tolerances for high precision.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define HEO orbit (Molniya-type)\na = 26554e3  # Semi-major axis (m)\ne = 0.74  # Eccentricity\ni = 63.4  # Inclination\n\n# Convert to Cartesian state\noe = np.array([a, e, i, 0.0, 0.0, 0.0])\nstate0 = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Orbital period\nperiod = bh.orbital_period(a)\n\n\n# Two-body dynamics\ndef dynamics(t, state):\n    mu = bh.GM_EARTH\n    r = state[0:3]\n    v = state[3:6]\n    r_norm = np.linalg.norm(r)\n    a = -mu / r_norm**3 * r\n    return np.concatenate([v, a])\n\n\nprint(\"High-Precision HEO Orbit Propagation\")\nprint(f\"Semi-major axis: {a / 1e3:.1f} km\")\nprint(f\"Eccentricity: {e}\")\nprint(f\"Period: {period / 3600:.2f} hours\\n\")\n\n# Create RKN1210 integrator with very tight tolerances\nabs_tol = 1e-14\nrel_tol = 1e-13\nconfig = bh.IntegratorConfig.adaptive(abs_tol=abs_tol, rel_tol=rel_tol)\nintegrator = bh.RKN1210Integrator(6, dynamics, config=config)\n\nprint(f\"Using RKN1210 with tol={abs_tol:.0e}\")\nprint(\"Propagating for one orbital period...\\n\")\n\n# Propagate for one orbit\nt = 0.0\nstate = state0.copy()\ndt = 60.0\nsteps = 0\ntotal_error = 0.0\n\nwhile t &lt; period:\n    result = integrator.step(t, state, min(dt, period - t))\n\n    t += result.dt_used\n    state = result.state\n    dt = result.dt_next\n    steps += 1\n    total_error += result.error_estimate\n\n    # Print at apogee and perigee\n    r_norm = np.linalg.norm(state[0:3])\n    if steps % 10 == 1:\n        print(\n            f\"t={t / 3600:6.2f}h  r={r_norm / 1e3:8.1f}km  dt={result.dt_used:6.1f}s  err={result.error_estimate:.2e}\"\n        )\n\nprint(\"\\nPropagation complete!\")\nprint(f\"Total steps: {steps}\")\nprint(f\"Average step: {period / steps:.1f} s\")\nprint(f\"Cumulative error estimate: {total_error:.2e}\")\n\n# Verify orbit closure (should return close to initial state)\nfinal_oe = bh.state_eci_to_koe(state, bh.AngleFormat.DEGREES)\ninitial_oe = bh.state_eci_to_koe(state0, bh.AngleFormat.DEGREES)\n\nprint(\"\\nOrbit element errors after one period:\")\nprint(f\"  Semi-major axis: {abs(final_oe[0] - initial_oe[0]):.3e} m\")\nprint(f\"  Eccentricity:    {abs(final_oe[1] - initial_oe[1]):.3e}\")\n\n# Expected Output:\n# High-Precision HEO Orbit Propagation\n# Semi-major axis: 26554.0 km\n# Eccentricity: 0.74\n# Period: 11.96 hours\n\n# Using RKN1210 with tol=1e-14\n# Propagating for one orbital period...\n\n# t=  0.02h  r=  6915.2km  dt=  60.0s  err=1.14e-03\n# t=  0.61h  r= 14336.8km  dt= 308.4s  err=2.37e-02\n# t=  2.54h  r= 34813.8km  dt= 900.0s  err=1.52e-03\n# t=  5.04h  r= 45404.2km  dt= 900.0s  err=1.65e-03\n# t=  7.54h  r= 44004.3km  dt= 900.0s  err=0.00e+00\n# t= 10.04h  r= 29862.5km  dt= 900.0s  err=6.33e-03\n# t= 11.66h  r=  9739.4km  dt= 291.4s  err=2.59e-01\n\n# Propagation complete!\n# Total steps: 67\n# Average step: 642.7 s\n# Cumulative error estimate: 5.85e+00\n\n# Orbit element errors after one period:\n#   Semi-major axis: 3.725e-08 m\n#   Eccentricity:    4.441e-16\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::{constants::*, integrators::*};\nuse nalgebra::DVector;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Define HEO orbit (Molniya-type)\n    let a = 26554e3;  // Semi-major axis (m)\n    let e = 0.74;     // Eccentricity\n    let i = 63.4;  // Inclination\n\n    // Convert to Cartesian state\n    let oe = [a, e, i, 0.0, 0.0, 0.0];\n    let state0 = bh::state_koe_to_eci(oe.into(), bh::AngleFormat::Degrees);\n    let state0_dv = DVector::from_vec(state0.as_slice().to_vec());\n\n    // Orbital period\n    let period = bh::orbital_period(a);\n\n    // Two-body dynamics\n    let dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let r = nalgebra::Vector3::new(state[0], state[1], state[2]);\n        let v = nalgebra::Vector3::new(state[3], state[4], state[5]);\n        let r_norm = r.norm();\n        let a = -GM_EARTH / r_norm.powi(3) * r;\n        DVector::from_vec(vec![v[0], v[1], v[2], a[0], a[1], a[2]])\n    };\n\n    println!(\"High-Precision HEO Orbit Propagation\");\n    println!(\"Semi-major axis: {:.1} km\", a / 1e3);\n    println!(\"Eccentricity: {}\", e);\n    println!(\"Period: {:.2} hours\\n\", period / 3600.0);\n\n    // Create RKN1210 integrator with very tight tolerances\n    let abs_tol = 1e-14;\n    let rel_tol = 1e-13;\n    let config = IntegratorConfig::adaptive(abs_tol, rel_tol);\n    let integrator = RKN1210DIntegrator::with_config(6, Box::new(dynamics), None, None, None, config);\n\n    println!(\"Using RKN1210 with tol={:.0e}\", abs_tol);\n    println!(\"Propagating for one orbital period...\\n\");\n\n    // Propagate for one orbit\n    let mut t = 0.0;\n    let mut state = state0_dv.clone();\n    let mut dt: f64 = 60.0;\n    let mut steps = 0;\n    let mut total_error = 0.0;\n\n    while t &lt; period {\n        let result = integrator.step(t, state, None, Some(dt.min(period - t)));\n\n        let dt_used = result.dt_used;\n        t += dt_used;\n        state = result.state;\n        dt = result.dt_next;\n        steps += 1;\n        total_error += result.error_estimate.unwrap();\n\n        // Print at intervals\n        if steps % 10 == 1 {\n            let r = nalgebra::Vector3::new(state[0], state[1], state[2]);\n            let r_norm = r.norm();\n            println!(\"t={:6.2}h  r={:8.1}km  dt={:6.1}s  err={:.2e}\",\n                     t / 3600.0, r_norm / 1e3, dt_used, result.error_estimate.unwrap());\n        }\n    }\n\n    println!(\"\\nPropagation complete!\");\n    println!(\"Total steps: {}\", steps);\n    println!(\"Average step: {:.1} s\", period / steps as f64);\n    println!(\"Cumulative error estimate: {:.2e}\", total_error);\n\n    // Verify orbit closure\n    let final_state = [state[0], state[1], state[2], state[3], state[4], state[5]];\n    let final_oe = bh::state_eci_to_koe(final_state.into(), bh::AngleFormat::Degrees);\n    let initial_oe = bh::state_eci_to_koe(state0, bh::AngleFormat::Degrees);\n\n    println!(\"\\nOrbit element errors after one period:\");\n    println!(\"  Semi-major axis: {:.3e} m\", (final_oe[0] - initial_oe[0]).abs());\n    println!(\"  Eccentricity:    {:.3e}\", (final_oe[1] - initial_oe[1]).abs());\n}\n\n// Expected output:\n// High-Precision HEO Orbit Propagation\n// Semi-major axis: 26554.0 km\n// Eccentricity: 0.74\n// Period: 11.96 hours\n\n// Using RKN1210 with tol=1e-14\n// Propagating for one orbital period...\n\n// t=  0.02h  r=  6915.2km  dt=  60.0s  err=1.14e-03\n// t=  0.61h  r= 14336.8km  dt= 308.4s  err=2.37e-02\n// t=  2.54h  r= 34813.8km  dt= 900.0s  err=1.52e-03\n// t=  5.04h  r= 45404.2km  dt= 900.0s  err=1.65e-03\n// t=  7.54h  r= 44004.3km  dt= 900.0s  err=0.00e+00\n// t= 10.04h  r= 29862.5km  dt= 900.0s  err=6.33e-03\n// t= 11.66h  r=  9739.4km  dt= 291.4s  err=2.59e-01\n\n// Propagation complete!\n// Total steps: 67\n// Average step: 642.7 s\n// Cumulative error estimate: 5.85e+00\n\n// Orbit element errors after one period:\n//   Semi-major axis: 3.725e-08 m\n//   Eccentricity:    4.441e-16\n</code></pre>"},{"location":"learn/integrators/adaptive_step.html#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Detailed parameter tuning</li> <li>Fixed-Step Integrators - For comparison</li> <li>RKF45 API Reference - RKF45 documentation</li> <li>DP54 API Reference - DP54 documentation</li> <li>RKN1210 API Reference - RKN1210 documentation</li> <li>Integrators Overview - Comparison of all integrators</li> </ul>"},{"location":"learn/integrators/configuration.html","title":"Integrator Configuration","text":"<p>Proper integrator configuration is essential for balancing accuracy, performance, and reliability. This guide explains all configuration parameters and how to choose appropriate values.</p>"},{"location":"learn/integrators/configuration.html#integratorconfig-class","title":"IntegratorConfig Class","text":"<p>The <code>IntegratorConfig</code> class encapsulates all settings for adaptive-step integrators. Key parameters include:</p> <ul> <li>Error Tolerances: <code>abs_tol</code>, <code>rel_tol</code></li> <li>Step Size Limits: <code>min_step</code>, <code>max_step</code></li> <li>Step Size Control: <code>step_safety_factor</code>, <code>min_step_scale_factor</code>, <code>max_step_scale_factor</code></li> <li>Maximum Step Attempts: <code>max_step_attempts</code></li> </ul>"},{"location":"learn/integrators/configuration.html#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"learn/integrators/configuration.html#error-tolerances","title":"Error Tolerances","text":"<p><code>abs_tol</code> (float): Absolute error tolerance</p> <ul> <li>Controls maximum absolute error allowed per step</li> <li>Units match state units (meters for position, m/s for velocity)</li> <li>Prevents excessively small steps when state approaches zero</li> </ul> <p><code>rel_tol</code> (float): Relative error tolerance</p> <ul> <li>Controls maximum relative error as fraction of state magnitude</li> <li>Dimensionless</li> <li>Scales with state magnitude</li> </ul> <p>Combined tolerance:</p> \\[\\text{tol}_i = \\text{abs\\_tol} + \\text{rel\\_tol} \\times |x_i|\\]"},{"location":"learn/integrators/configuration.html#step-size-limits","title":"Step Size Limits","text":"<p><code>min_step</code> (float): Minimum allowed step size (seconds)</p> <ul> <li>Safety limit preventing infinitesimally small steps</li> <li>If integrator hits this limit repeatedly, tolerances may be too tight</li> </ul> <p><code>max_step</code> (float): Maximum allowed step size (seconds)</p> <ul> <li>Prevents missing important dynamics by taking too-large steps</li> <li>Critical for problems with events or discontinuities</li> </ul>"},{"location":"learn/integrators/configuration.html#step-size-control","title":"Step Size Control","text":"<p><code>step_safety_factor</code> (float): Safety margin for step size adjustment</p> <ul> <li>Multiplier applied to calculated optimal step size</li> <li>Makes step size more conservative</li> <li>Default: 0.9 (use 90% of optimal)</li> <li>Range: 0.8 to 0.95</li> </ul> <p>Formula:</p> \\[ h_{\\text{new}} = \\text{safety\\_factor} \\times h \\times \\left(\\frac{\\text{tol}}{\\varepsilon}\\right)^{1/p} \\] <p>Decreasing the safety factor results in smaller steps and higher accuracy but more function evaluations. Increasing it yields larger steps and faster performance but risks exceeding error tolerances and more rejections, which in turn results in wasted computation.</p> <p><code>min_step_scale_factor</code> (float): Minimum step size change ratio</p> <ul> <li>Prevents dramatic step size reductions</li> <li>Ensures step doesn't shrink too rapidly</li> <li>Default: 0.2 (can shrink to 20% of current)</li> </ul> <p><code>max_step_scale_factor</code> (float): Maximum step size change ratio</p> <ul> <li>Prevents dramatic step size increases</li> <li>Ensures gradual adaptation</li> <li>Default: 10.0 (can grow to 10\u00d7 current)</li> </ul> <p>Why limit step changes: - Prevents oscillating step sizes - Smooths adaptation</p>"},{"location":"learn/integrators/configuration.html#step-attempts","title":"Step Attempts","text":"<p><code>max_step_attempts</code> (int): Maximum retry attempts before error</p> <ul> <li>If step rejected more than this many times, raise error</li> <li>Prevents infinite loops with pathological problems</li> <li>Default: 10</li> </ul> <p>Typical causes of many rejections: 1. Tolerances too tight for integrator order 2. Stiff differential equations 3. Discontinuity in dynamics 4. Bug in dynamics function</p>"},{"location":"learn/integrators/configuration.html#configuration-examples","title":"Configuration Examples","text":"<p>These examples illustrate different parameter combinations representing different points on the accuracy-performance spectrum:</p>"},{"location":"learn/integrators/configuration.html#conservative-configuration","title":"Conservative Configuration","text":"<p>Tight tolerances and restrictive step size controls:</p> PythonRust <pre><code>conservative_config = bh.IntegratorConfig(\n    abs_tol=1e-12,\n    rel_tol=1e-11,\n    min_step=0.01,\n    max_step=100.0,\n    step_safety_factor=0.85,  # More conservative\n    min_step_scale_factor=0.3,\n    max_step_scale_factor=5.0,  # Limit step growth\n    max_step_attempts=15,\n)\n</code></pre> <pre><code>    let conservative_config = IntegratorConfig {\n        abs_tol: 1e-12,\n        rel_tol: 1e-11,\n        initial_step: Some(10.0),\n        min_step: Some(0.01),\n        max_step: Some(100.0),\n        step_safety_factor: Some(0.85),  // More conservative\n        min_step_scale_factor: Some(0.3),\n        max_step_scale_factor: Some(5.0),  // Limit step growth\n        max_step_attempts: 15,\n        fixed_step_size: None,\n    };\n</code></pre>"},{"location":"learn/integrators/configuration.html#balanced-configuration","title":"Balanced Configuration","text":"<p>Moderate settings suitable for many applications:</p> PythonRust <pre><code>balanced_config = bh.IntegratorConfig.adaptive(abs_tol=1e-10, rel_tol=1e-9)\n</code></pre> <pre><code>    let balanced_config = IntegratorConfig::adaptive(1e-10, 1e-9);\n</code></pre>"},{"location":"learn/integrators/configuration.html#aggressive-configuration","title":"Aggressive Configuration","text":"<p>Relaxed tolerances for faster computation:</p> PythonRust <pre><code>aggressive_config = bh.IntegratorConfig(\n    abs_tol=1e-8,\n    rel_tol=1e-7,\n    initial_step=60.0,\n    min_step=1.0,\n    max_step=1000.0,  # Large steps allowed\n    step_safety_factor=0.95,  # Less conservative\n    min_step_scale_factor=0.1,\n    max_step_scale_factor=15.0,  # Allow rapid growth\n    max_step_attempts=8,\n)\n</code></pre> <pre><code>    let aggressive_config = IntegratorConfig {\n        abs_tol: 1e-8,\n        rel_tol: 1e-7,\n        initial_step: Some(60.0),\n        min_step: Some(1.0),\n        max_step: Some(1000.0),  // Large steps allowed\n        step_safety_factor: Some(0.95),  // Less conservative\n        min_step_scale_factor: Some(0.1),\n        max_step_scale_factor: Some(15.0),  // Allow rapid growth\n        max_step_attempts: 8,\n        fixed_step_size: None,\n    };\n</code></pre>"},{"location":"learn/integrators/configuration.html#high-precision-configuration","title":"High-Precision Configuration","text":"<p>Very tight tolerances for high-accuracy needs:</p> PythonRust <pre><code>high_precision_config = bh.IntegratorConfig(\n    abs_tol=1e-14,\n    rel_tol=1e-13,\n    min_step=0.001,\n    max_step=200.0,\n    step_safety_factor=0.9,\n    min_step_scale_factor=0.2,\n    max_step_scale_factor=10.0,\n    max_step_attempts=12,\n)\n</code></pre> <pre><code>    let high_precision_config = IntegratorConfig {\n        abs_tol: 1e-14,\n        rel_tol: 1e-13,\n        initial_step: Some(10.0),\n        min_step: Some(0.001),\n        max_step: Some(200.0),\n        step_safety_factor: Some(0.9),\n        min_step_scale_factor: Some(0.2),\n        max_step_scale_factor: Some(10.0),\n        max_step_attempts: 12,\n        fixed_step_size: None,\n    };\n</code></pre>"},{"location":"learn/integrators/configuration.html#tuning-strategy","title":"Tuning Strategy","text":""},{"location":"learn/integrators/configuration.html#1-start-with-defaults","title":"1. Start with Defaults","text":"<pre><code>config = bh.IntegratorConfig.adaptive(abs_tol=1e-10, rel_tol=1e-9)\nintegrator = bh.DP54Integrator(dynamics, config)\n</code></pre>"},{"location":"learn/integrators/configuration.html#2-assess-performance","title":"2. Assess Performance","text":"<p>Run test integration and monitor: - Number of steps taken - Number of rejected steps (should be &lt; 1%) - Error estimates - Step size variation</p>"},{"location":"learn/integrators/configuration.html#3-adjust-based-on-observations","title":"3. Adjust Based on Observations","text":"<p>If steps too small: <pre><code># Relax tolerances by 10\u00d7\nconfig.abs_tol = 1e-9\nconfig.rel_tol = 1e-8\n</code></pre></p> <p>If missing features: <pre><code># Reduce max step\nconfig.max_step = orbital_period / 50\n</code></pre></p> <p>If many rejections: <pre><code># Decrease safety factor\nconfig.step_safety_factor = 0.7\n\n# Or reduce step scale factors\nconfig.max_step_scale_factor = 5.0\n</code></pre></p> <p>If hitting min_step: <pre><code># Switch to higher-order integrator or relax tolerances\nintegrator = bh.RKN1210Integrator(dynamics, config)\n</code></pre></p>"},{"location":"learn/integrators/configuration.html#4-validate","title":"4. Validate","text":"<p>Compare against:</p> <ul> <li>Analytical solution (if available)</li> <li>Same integration with 10\u00d7 tighter tolerances</li> <li>Energy/momentum conservation</li> <li>Independent integration software</li> </ul>"},{"location":"learn/integrators/configuration.html#5-document","title":"5. Document","text":"<p>Record final configuration with rationale: <pre><code># Configuration tuned for LEO orbit propagation\n# - Tolerances provide ~5m position accuracy over 1 day\n# - Max step prevents missing station-keeping maneuvers\n# - Validated against analytical two-body solution\nconfig = bh.IntegratorConfig.adaptive(\n    abs_tol=1e-11,\n    rel_tol=1e-10,\n    max_step=300.0  # 5 minutes\n)\n</code></pre></p>"},{"location":"learn/integrators/configuration.html#see-also","title":"See Also","text":"<ul> <li>Adaptive-Step Integrators - How adaptive integration works</li> <li>Fixed-Step Integrators - Fixed-step integration guide</li> <li>Configuration API Reference - Complete API documentation</li> <li>Integrators Overview - Comparison of all integrators</li> </ul>"},{"location":"learn/integrators/control_inputs.html","title":"Control Inputs","text":"<p>Control inputs allow you to add external forcing functions to your dynamics without modifying the core dynamics function. This separation is useful for modeling thrust, drag, or other perturbations that can be toggled on and off.</p>"},{"location":"learn/integrators/control_inputs.html#what-are-control-inputs","title":"What are Control Inputs?","text":"<p>In control theory, a dynamical system with control inputs is written as:</p> \\[\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}) + \\mathbf{u}(t, \\mathbf{x})\\] <p>where:</p> <ul> <li>\\(\\mathbf{f}(t, \\mathbf{x})\\) is the nominal dynamics (e.g., gravitational acceleration)</li> <li>\\(\\mathbf{u}(t, \\mathbf{x})\\) is the control input (e.g., thrust acceleration)</li> </ul> <p>The control input function \\(\\mathbf{u}\\) takes the current time and state and returns a vector that is added to the state derivative. This additive structure makes it easy to:</p> <ul> <li>Switch control on/off without changing the dynamics function</li> <li>Combine different control strategies</li> <li>Test different control laws with the same dynamics</li> </ul>"},{"location":"learn/integrators/control_inputs.html#control-input-function-signature","title":"Control Input Function Signature","text":"<p>The control input function must follow specific signatures depending on the language:</p> PythonRust <pre><code>def control_function(t: float, state: np.ndarray, params: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Args:\n        t: Current time\n        state: Current state vector\n        params: Additional parameters\n\n    Returns:\n        Control vector of same dimension as state\n    \"\"\"\n    pass\n</code></pre> <p>Must be a closure or function with the signature, that either uses dynamic or static sized vectors:</p> <pre><code>Fn(f64, DVector&lt;f64&gt;, DVector&lt;f64&gt;) -&gt; DVector&lt;f64&gt;\n</code></pre> <p>or</p> <pre><code>Fn(f64, SVector&lt;f64, S&gt;, SVector&lt;f64, P&gt;) -&gt; SVector&lt;f64, S&gt;\n</code></pre> <p>The function receives: - Current time as a scalar - Current state vector - Additional parameters as a vector</p> <p>And returns a control vector of the same dimension as the state, which is added to the derivative computed by the dynamics function. The additional parameters can be ignored if not needed, but the signature must be maintained.</p>"},{"location":"learn/integrators/control_inputs.html#using-control-inputs","title":"Using Control Inputs","text":"<p>Control inputs are passed as a separate parameter to the integrator constructor. The dynamics function computes the nominal state derivative, and the control function computes the perturbation that is added to it.</p> PythonRust <pre><code>def dynamics(t, state):\n    \"\"\"Orbital dynamics (gravity only).\n\n    Args:\n        t: Time\n        state: [x, y, z, vx, vy, vz]\n    \"\"\"\n    r = state[:3]\n    v = state[3:]\n    r_norm = np.linalg.norm(r)\n    a_grav = -bh.GM_EARTH / (r_norm**3) * r\n    return np.concatenate([v, a_grav])\n\n\ndef control_input(t, state):\n    \"\"\"Control input: constant low thrust in velocity direction.\n\n    Args:\n        t: Time\n        state: [x, y, z, vx, vy, vz]\n\n    Returns:\n        Control vector added to state derivative\n    \"\"\"\n    v = state[3:]\n    v_norm = np.linalg.norm(v)\n\n    control = np.zeros(6)\n    if v_norm &gt; 0:\n        thrust_magnitude = 0.001  # m/s^2\n        control[3:] = thrust_magnitude * v / v_norm\n\n    return control\n\n\n# Initial LEO state (500 km altitude, circular orbit)\nsma = bh.R_EARTH + 500e3\nstate_initial = np.array([sma, 0.0, 0.0, 0.0, 7612.6, 0.0])\n\n# Orbital period\nperiod = bh.orbital_period(sma)\n\n# Create integrator WITH control input parameter\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-10, rel_tol=1e-8)\nintegrator_thrust = bh.DP54Integrator(\n    6, dynamics, jacobian=None, control_fn=control_input, config=config\n)\n\n# Create integrator without control (for comparison)\nintegrator_coast = bh.DP54Integrator(6, dynamics, config=config)\n\n# Propagate with thrust for one orbit\nstate_thrust = state_initial.copy()\nt = 0.0\ndt = 60.0\n\nwhile t &lt; period:\n    result = integrator_thrust.step(t, state_thrust, dt)\n    state_thrust = result.state\n    t += result.dt_used\n    dt = result.dt_next\n\n# Propagate without thrust for comparison\nstate_coast = state_initial.copy()\nt = 0.0\ndt = 60.0\n\nwhile t &lt; period:\n    result = integrator_coast.step(t, state_coast, dt)\n    state_coast = result.state\n    t += result.dt_used\n    dt = result.dt_next\n\n# Results\nr_initial = np.linalg.norm(state_initial[:3])\nr_thrust = np.linalg.norm(state_thrust[:3])\nr_coast = np.linalg.norm(state_coast[:3])\n\nprint(f\"Initial radius: {r_initial / 1000:.3f} km\")\nprint(f\"Orbital period: {period / 3600:.2f} hours\")\nprint(\"\\nAfter one orbit:\")\nprint(\n    f\"  With thrust: {r_thrust / 1000:.3f} km (delta_r = {(r_thrust - r_initial) / 1000:.3f} km)\"\n)\nprint(\n    f\"  Coast only:  {r_coast / 1000:.3f} km (delta_r = {(r_coast - r_initial) / 1000:.3f} km)\"\n)\n# Initial radius: 6878.136 km\n# Orbital period: 1.58 hours\n\n# After one orbit:\n#   With thrust: 6889.325 km (delta_r = 11.189 km)\n#   Coast only:  6878.136 km (delta_r = 0.000 km)\n</code></pre> <pre><code>use brahe::constants::{GM_EARTH, R_EARTH};\nuse brahe::integrators::*;\nuse brahe::orbits::keplerian::orbital_period;\nuse nalgebra::DVector;\n\nfn main() {\n    // Orbital dynamics (gravity only)\n    let dynamics =\n        move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n            let r = state.fixed_rows::&lt;3&gt;(0);\n            let v = state.fixed_rows::&lt;3&gt;(3);\n            let r_norm = r.norm();\n            let a_grav = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n            let mut state_dot = DVector::&lt;f64&gt;::zeros(6);\n            state_dot\n                .fixed_rows_mut::&lt;3&gt;(0)\n                .copy_from(&amp;v.clone_owned());\n            state_dot.fixed_rows_mut::&lt;3&gt;(3).copy_from(&amp;a_grav);\n            state_dot\n        };\n\n    // Control input: constant low thrust in velocity direction\n    let control_input = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let v = state.fixed_rows::&lt;3&gt;(3);\n        let v_norm = v.norm();\n\n        let mut control = DVector::&lt;f64&gt;::zeros(6);\n        if v_norm &gt; 0.0 {\n            let thrust_magnitude = 0.001; // m/s^2\n            let a_thrust = thrust_magnitude * v / v_norm;\n            control.fixed_rows_mut::&lt;3&gt;(3).copy_from(&amp;a_thrust);\n        }\n        control\n    };\n\n    // Create integrator with control input\n    let config = IntegratorConfig::adaptive(1e-10, 1e-8);\n    let integrator = DormandPrince54DIntegrator::with_config(\n        6,\n        Box::new(dynamics),\n        None,                          // No Jacobian\n        None,                          // No sensitivity provider\n        Some(Box::new(control_input)), // Control input\n        config,\n    );\n\n    // Initial LEO state (500 km altitude)\n    let sma = R_EARTH + 500e3;\n    let state = DVector::from_vec(vec![\n        sma, 0.0, 0.0, // Position\n        0.0, 7612.6, 0.0, // Velocity (circular orbit)\n    ]);\n\n    // Integrate for one orbit period\n    let period = orbital_period(sma);\n    let mut t = 0.0;\n    let mut dt = 60.0;\n    let mut current_state = state.clone();\n\n    println!(\"Initial semi-major axis: {:.3} km\", sma / 1000.0);\n    println!(\n        \"Integrating with continuous thrust for {:.2} hours...\",\n        period / 3600.0\n    );\n\n    while t &lt; period {\n        let result = integrator.step(t, current_state, None, Some(dt));\n        current_state = result.state;\n        t += result.dt_used;\n        dt = result.dt_next;\n    }\n\n    let final_r = current_state.fixed_rows::&lt;3&gt;(0).norm();\n    let delta_r = final_r - sma;\n    println!(\"Final radius: {:.3} km\", final_r / 1000.0);\n    println!(\"Orbit raised by: {:.3} km\", delta_r / 1000.0);\n}\n\n// Initial radius: 6878.136 km\n// Orbital period: 1.58 hours\n\n// After one orbit:\n//   With thrust: 6889.325 km (delta_r = 11.189 km)\n//   Coast only:  6878.136 km (delta_r = 0.000 km)\n</code></pre>"},{"location":"learn/integrators/control_inputs.html#applications","title":"Applications","text":"<p>Control inputs are particularly useful for:</p> <ul> <li>Orbit raising/lowering: Frequent thrusting to get to desired orbit</li> <li>Station keeping: Small corrections to maintain orbit and compensate for drag</li> <li>Redezvous and Proximity Operations: Relative motion control between satellites</li> <li>Spacecraft Collision Avoidance: Maneuvering to avoid debris</li> </ul>"},{"location":"learn/integrators/control_inputs.html#see-also","title":"See Also","text":"<ul> <li>Adaptive Step Integration - Recommended for control problems</li> <li>Variational Equations - For control sensitivity analysis</li> <li>Configuration Guide - Tuning integrator parameters</li> </ul>"},{"location":"learn/integrators/fixed_step.html","title":"Fixed-Step Integrators","text":"<p>Fixed-step integrators use a constant time step throughout the integration. Unlike adaptive methods, they don't automatically adjust step size based on error estimates. They are simpler to implement and have predictable computational costs, but require careful step size selection to ensure accuracy. They provide regular output at fixed intervals, making them suitable for applications needing uniform sampling.</p>"},{"location":"learn/integrators/fixed_step.html#rk4-classical-runge-kutta","title":"RK4: Classical Runge-Kutta","text":"<p>Brahe implements the classical 4th-order Runge-Kutta (RK4) method as it's primary fixed-step integrator. The 4th-order Runge-Kutta method (RK4) is the most popular fixed-step integrator, offering an excellent balance of accuracy and simplicity.</p>"},{"location":"learn/integrators/fixed_step.html#algorithm","title":"Algorithm","text":"<p>For \\(\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x})\\), the RK4 method computes:</p> \\[\\begin{align} \\mathbf{k}_1 &amp;= \\mathbf{f}(t, \\mathbf{x}) \\\\ \\mathbf{k}_2 &amp;= \\mathbf{f}(t + h/2, \\mathbf{x} + h\\mathbf{k}_1/2) \\\\ \\mathbf{k}_3 &amp;= \\mathbf{f}(t + h/2, \\mathbf{x} + h\\mathbf{k}_2/2) \\\\ \\mathbf{k}_4 &amp;= \\mathbf{f}(t + h, \\mathbf{x} + h\\mathbf{k}_3) \\end{align}\\] <p>The next state is then given by:</p> \\[\\mathbf{x}(t + h) = \\mathbf{x}(t) + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\\]"},{"location":"learn/integrators/fixed_step.html#choosing-step-size","title":"Choosing Step Size","text":"<p>The step size h must balance accuracy and computational cost. Too large causes unacceptable errors; too small wastes computation. A decent starting point is to relate h to the characteristic time scale of the dynamics. For orbital dynamics, a common heuristic is </p> \\[ h \\approx \\frac{T}{100 \\text{ \\textemdash } 1000} \\] <p>where T is the orbital period.</p> <p>Since fixed-step methods lack automatic error control, it is critical to validate that the step-size choice achieves the desired level of accuracy. Common validation approaches include:</p> <ol> <li>Analytical solution: Compare against closed-form solution (when available)</li> <li>Step Size Comparison: Run with both \\(h\\) and \\(h/2\\), compare results to confirm convergence</li> <li>Energy/momentum conservation: If you have a conserative system (in astrodynamics, this would be a gravitional-only system), check that total energy and angular momentum remain constant over time.</li> <li>Reference integrator: Compare against adaptive integrator with tight tolerances</li> </ol>"},{"location":"learn/integrators/fixed_step.html#basic-integration-example","title":"Basic Integration Example","text":"<p>The following example demonstrates using the RK4 fixed-step integrator to  integrate a simple harmonic oscillator.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define simple harmonic oscillator\nomega = 1.0\n\n\ndef dynamics(t, state):\n    x, v = state\n    return np.array([v, -(omega**2) * x])\n\n\n# Analytical solution\ndef analytical(t, x0=1.0, v0=0.0):\n    x = x0 * np.cos(omega * t) + (v0 / omega) * np.sin(omega * t)\n    v = -omega * x0 * np.sin(omega * t) + v0 * np.cos(omega * t)\n    return np.array([x, v])\n\n\n# Initial conditions\nstate0 = np.array([1.0, 0.0])\nt_end = 4 * np.pi  # Two periods\n\nprint(\"RK4 Fixed-Step Integration Demonstration\")\nprint(\"System: Simple Harmonic Oscillator (\u03c9=1.0)\")\nprint(f\"Integration time: 0 to {t_end:.2f} (2 periods)\\n\")\n\n# Test different step sizes\nstep_sizes = [0.5, 0.2, 0.1, 0.05]\n\nfor dt in step_sizes:\n    config = bh.IntegratorConfig.fixed_step(step_size=dt)\n    integrator = bh.RK4Integrator(2, dynamics, config=config)\n\n    t = 0.0\n    state = state0.copy()\n    steps = 0\n\n    # Integrate to end\n    while t &lt; t_end - 1e-10:\n        state = integrator.step(t, state, dt)\n        t += dt\n        steps += 1\n\n    # Compare with analytical solution\n    exact = analytical(t)\n    error = np.linalg.norm(state - exact)\n\n    print(f\"Step size dt={dt:5.2f}:\")\n    print(f\"  Steps:      {steps}\")\n    print(f\"  Final state: [{state[0]:.6f}, {state[1]:.6f}]\")\n    print(f\"  Exact:       [{exact[0]:.6f}, {exact[1]:.6f}]\")\n    print(f\"  Error:       {error:.2e}\")\n    print()\n\n# Expected Output:\n# RK4 Fixed-Step Integration Demonstration\n# System: Simple Harmonic Oscillator (\u03c9=1.0)\n# Integration time: 0 to 12.57 (2 periods)\n\n# Step size dt= 0.50:\n#   Steps:      26\n#   Final state: [0.907541, -0.413422]\n#   Exact:       [0.907447, -0.420167]\n#   Error:       6.75e-03\n\n# Step size dt= 0.20:\n#   Steps:      63\n#   Final state: [0.999412, -0.033457]\n#   Exact:       [0.999435, -0.033623]\n#   Error:       1.68e-04\n\n# Step size dt= 0.10:\n#   Steps:      126\n#   Final state: [0.999434, -0.033613]\n#   Exact:       [0.999435, -0.033623]\n#   Error:       1.05e-05\n\n# Step size dt= 0.05:\n#   Steps:      252\n#   Final state: [0.999435, -0.033622]\n#   Exact:       [0.999435, -0.033623]\n#   Error:       6.56e-07\n</code></pre> <pre><code>use brahe::integrators::*;\nuse nalgebra::DVector;\n\nfn main() {\n    // Define simple harmonic oscillator\n    let omega: f64 = 1.0;\n    let dynamics = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let x = state[0];\n        let v = state[1];\n        DVector::from_vec(vec![v, -omega.powi(2) * x])\n    };\n\n    // Analytical solution\n    let analytical = |t: f64, x0: f64, v0: f64| -&gt; (f64, f64) {\n        let x = x0 * (omega * t).cos() + (v0 / omega) * (omega * t).sin();\n        let v = -omega * x0 * (omega * t).sin() + v0 * (omega * t).cos();\n        (x, v)\n    };\n\n    // Initial conditions\n    let state0 = DVector::from_vec(vec![1.0, 0.0]);\n    let t_end = 4.0 * std::f64::consts::PI;  // Two periods\n\n    println!(\"RK4 Fixed-Step Integration Demonstration\");\n    println!(\"System: Simple Harmonic Oscillator (\u03c9=1.0)\");\n    println!(\"Integration time: 0 to {:.2} (2 periods)\\n\", t_end);\n\n    // Test different step sizes\n    let step_sizes = vec![0.5, 0.2, 0.1, 0.05];\n\n    for &amp;dt in &amp;step_sizes {\n        let config = IntegratorConfig::fixed_step(dt);\n        let integrator = RK4DIntegrator::with_config(2, Box::new(dynamics), None, None, None, config);\n\n        let mut t = 0.0;\n        let mut state = state0.clone();\n        let mut steps = 0;\n\n        // Integrate to end\n        while t &lt; t_end - 1e-10 {\n            state = integrator.step(t, state, None, None).state;\n            t += dt;\n            steps += 1;\n        }\n\n        // Compare with analytical solution\n        let (exact_x, exact_v) = analytical(t, 1.0, 0.0);\n        let error = ((state[0] - exact_x).powi(2) + (state[1] - exact_v).powi(2)).sqrt();\n\n        println!(\"Step size dt={:5.2}:\", dt);\n        println!(\"  Steps:      {}\", steps);\n        println!(\"  Final state: [{:.6}, {:.6}]\", state[0], state[1]);\n        println!(\"  Exact:       [{:.6}, {:.6}]\", exact_x, exact_v);\n        println!(\"  Error:       {:.2e}\", error);\n        println!();\n    }\n}\n\n// Expected output:\n// RK4 Fixed-Step Integration Demonstration\n// System: Simple Harmonic Oscillator (\u03c9=1.0)\n// Integration time: 0 to 12.57 (2 periods)\n\n// Step size dt= 0.50:\n//   Steps:      26\n//   Final state: [0.907541, -0.413422]\n//   Exact:       [0.907447, -0.420167]\n//   Error:       6.75e-03\n\n// Step size dt= 0.20:\n//   Steps:      63\n//   Final state: [0.999412, -0.033457]\n//   Exact:       [0.999435, -0.033623]\n//   Error:       1.68e-04\n\n// Step size dt= 0.10:\n//   Steps:      126\n//   Final state: [0.999434, -0.033613]\n//   Exact:       [0.999435, -0.033623]\n//   Error:       1.05e-05\n\n// Step size dt= 0.05:\n//   Steps:      252\n//   Final state: [0.999435, -0.033622]\n//   Exact:       [0.999435, -0.033623]\n//   Error:       6.56e-07\n</code></pre>"},{"location":"learn/integrators/fixed_step.html#see-also","title":"See Also","text":"<ul> <li>Adaptive-Step Integrators - For automatic error control</li> <li>Configuration Guide - Detailed configuration options</li> <li>RK4 API Reference - Complete RK4 documentation</li> <li>Integrators Overview - Comparison of all integrators</li> </ul>"},{"location":"learn/integrators/sensitivity_matrix.html","title":"Sensitivity Matrix","text":"<p>The sensitivity matrix extends variational equations to include the effect of uncertain parameters on the state. While the State Transition Matrix (STM) maps initial state uncertainties to final state uncertainties, the sensitivity matrix maps parameter uncertainties to state uncertainties.</p>"},{"location":"learn/integrators/sensitivity_matrix.html#what-is-the-sensitivity-matrix","title":"What is the Sensitivity Matrix?","text":"<p>For a dynamical system that depends on both state and parameters:</p> \\[\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x}, \\mathbf{p})\\] <p>where \\(\\mathbf{p}\\) is a vector of \"consider parameters\" (parameters that affect dynamics but aren't estimated), the sensitivity matrix \\(\\mathbf{S}\\) describes how state evolves with respect to parameter changes:</p> \\[\\mathbf{S}(t) = \\frac{\\partial \\mathbf{x}(t)}{\\partial \\mathbf{p}}\\] <p>The sensitivity matrix satisfies the differential equation:</p> \\[\\dot{\\mathbf{S}} = \\frac{\\partial \\mathbf{f}(t, \\mathbf{x}, \\mathbf{p})}{\\partial \\mathbf{x}} \\mathbf{S} + \\frac{\\partial \\mathbf{f}(t, \\mathbf{x}, \\mathbf{p})}{\\partial \\mathbf{p}}\\] <p>Sensitivity matrices are essential for accounting for parameter uncertainties in orbit determination.</p>"},{"location":"learn/integrators/sensitivity_matrix.html#relationship-to-stm","title":"Relationship to STM","text":"<p>The sensitivity matrix and STM serve related but distinct purposes:</p> Matrix Equation Maps STM \\(\\Phi\\) \\(\\dot{\\Phi} = \\mathbf{A}\\Phi\\) Initial state \u2192 Final state Sensitivity \\(\\mathbf{S}\\) \\(\\dot{\\mathbf{S}} = \\mathbf{A}\\mathbf{S} + \\mathbf{B}\\) Parameters \u2192 Final state"},{"location":"learn/integrators/sensitivity_matrix.html#propagating-the-sensitivity-matrix","title":"Propagating the Sensitivity Matrix","text":"<p>Brahe integrators provide <code>step_with_sensmat()</code> for propagating the sensitivity matrix alongside the state:</p> <pre><code>// Result: (new_state, new_sensitivity, dt_used, error, dt_next)\nlet (state, sens, dt_used, error, dt_next) =\n    integrator.step_with_sensmat(t, state, sensitivity, &amp;params, dt);\n</code></pre> <p>For combined STM and sensitivity propagation:</p> <pre><code>// Result: (new_state, new_stm, new_sensitivity, dt_used, error, dt_next)\nlet (state, phi, sens, dt_used, error, dt_next) =\n    integrator.step_with_varmat_sensmat(t, state, phi, sensitivity, &amp;params, dt);\n</code></pre>"},{"location":"learn/integrators/sensitivity_matrix.html#using-sensitivity-providers","title":"Using Sensitivity Providers","text":"<p>Brahe provides two approaches for computing the sensitivity matrix \\(\\partial \\mathbf{f}/\\partial \\mathbf{p}\\)---<code>NumericalSensitivity</code> and <code>AnalyticSensitivity</code> classes. The <code>NumericalSensitivity</code> provider computes sensitivities automatically by perturbing parameters, while <code>AnalyticSensitivity</code> allows you to supply analytical derivatives for better performance. When you know the analytical form of \\(\\partial \\mathbf{f}/\\partial \\mathbf{p}\\), use <code>AnalyticSensitivity</code> for better accuracy and performance. The example files below demonstrate both numerical and analytical approaches.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\ndef dynamics_with_params(t, state, params):\n    \"\"\"Orbital dynamics with consider parameters.\n\n    Args:\n        t: Time\n        state: [x, y, z, vx, vy, vz]\n        params: [cd_area_m] - drag coefficient * area / mass\n    \"\"\"\n    # Extract parameter\n    cd_area_m = params[0]\n\n    # Gravitational dynamics\n    r = state[:3]\n    v = state[3:]\n    r_norm = np.linalg.norm(r)\n    a_grav = -bh.GM_EARTH / (r_norm**3) * r\n\n    # Atmospheric drag (simplified exponential model)\n    h = r_norm - bh.R_EARTH\n    rho0 = 1.225  # kg/m^3 at sea level\n    H = 8500.0  # Scale height in meters\n    rho = rho0 * np.exp(-h / H)\n\n    v_norm = np.linalg.norm(v)\n    a_drag = -0.5 * rho * cd_area_m * v_norm * v\n\n    return np.concatenate([v, a_grav + a_drag])\n\n\ndef analytical_sensitivity(t, state, params):\n    \"\"\"Analytical sensitivity \u2202f/\u2202p for drag parameter.\n\n    Args:\n        t: Time\n        state: [x, y, z, vx, vy, vz]\n        params: [cd_area_m]\n\n    Returns:\n        6x1 sensitivity matrix\n    \"\"\"\n    r = state[:3]\n    v = state[3:]\n    r_norm = np.linalg.norm(r)\n\n    # Atmospheric density\n    h = r_norm - bh.R_EARTH\n    rho0 = 1.225\n    H = 8500.0\n    rho = rho0 * np.exp(-h / H)\n\n    v_norm = np.linalg.norm(v)\n\n    # \u2202(state_dot)/\u2202(cd_area_m)\n    sens = np.zeros((6, 1))\n    if v_norm &gt; 0:\n        # \u2202(a_drag)/\u2202(cd_area_m) = -0.5 * rho * v_norm * v\n        sens[3:6, 0] = -0.5 * rho * v_norm * v\n\n    return sens\n\n\n# Initial state (400 km LEO circular orbit)\noe = np.array([bh.R_EARTH + 250e3, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Consider parameters\nparams = np.array([0.044])  # cd_area_m = Cd*A/m = 2.2*10/500\n\n# Create numerical sensitivity provider (use class directly as constructor)\nnumerical_sens = bh.NumericalSensitivity(dynamics_with_params)\n\n# Compute sensitivity matrix numerically\nsens_numerical = numerical_sens.compute(0.0, state, params)\n\nprint(\"Numerical sensitivity (\u2202f/\u2202p):\")\nprint(\n    f\"  Position rates: [{sens_numerical[0, 0]}, {sens_numerical[1, 0]}, {sens_numerical[2, 0]}]\"\n)\nprint(\n    f\"  Velocity rates: [{sens_numerical[3, 0]}, {sens_numerical[4, 0]}, {sens_numerical[5, 0]}]\"\n)\n\n# Create analytical sensitivity provider\nanalytic_sens = bh.AnalyticSensitivity(analytical_sensitivity)\n\n# Compute sensitivity matrix analytically\nsens_analytical = analytic_sens.compute(0.0, state, params)\n\nprint(\"\\nAnalytical sensitivity (\u2202f/\u2202p):\")\nprint(\n    f\"  Position rates: [{sens_analytical[0, 0]}, {sens_analytical[1, 0]}, {sens_analytical[2, 0]}]\"\n)\nprint(\n    f\"  Velocity rates: [{sens_analytical[3, 0]}, {sens_analytical[4, 0]}, {sens_analytical[5, 0]}]\"\n)\n\n# Compare numerical and analytical\ndiff = np.abs(sens_numerical - sens_analytical)\nprint(f\"\\nMax difference: {np.max(diff):.3e}\")\n\n# Numerical sensitivity (\u2202f/\u2202p):\n#   Position rates: [0, 0, 0]\n#   Velocity rates: [0, -0.000008425648220011794, -0.000010630522385923769]\n\n# Analytical sensitivity (\u2202f/\u2202p):\n#   Position rates: [0, 0, 0]\n#   Velocity rates: [0, -0.000008425648218908737, -0.00001063052238539645]\n\n# Max difference: 1.103e-15\n</code></pre> <pre><code>use brahe::constants::{GM_EARTH, R_EARTH};\nuse brahe::math::sensitivity::{\n    DAnalyticSensitivity, DNumericalSensitivity, DSensitivityProvider,\n};\nuse brahe::state_koe_to_eci;\nuse brahe::AngleFormat;\nuse nalgebra::{DMatrix, DVector, SVector};\n\nfn main() {\n    // Dynamics function that takes consider parameters\n    let dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, params: &amp;DVector&lt;f64&gt;| -&gt; DVector&lt;f64&gt; {\n        let cd_area_m = params[0];\n\n        let r = state.fixed_rows::&lt;3&gt;(0);\n        let v = state.fixed_rows::&lt;3&gt;(3);\n        let r_norm = r.norm();\n\n        // Gravitational acceleration\n        let a_grav = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n        // Atmospheric drag (simplified exponential model)\n        let h = r_norm - R_EARTH;\n        let rho0 = 1.225; // kg/m^3\n        let scale_height = 8500.0; // m\n        let rho = rho0 * (-h / scale_height).exp();\n\n        let v_norm = v.norm();\n        let a_drag = if v_norm &gt; 0.0 {\n            -0.5 * rho * cd_area_m * v_norm * v\n        } else {\n            nalgebra::Vector3::zeros()\n        };\n\n        let mut state_dot = DVector::&lt;f64&gt;::zeros(6);\n        state_dot\n            .fixed_rows_mut::&lt;3&gt;(0)\n            .copy_from(&amp;v.clone_owned());\n        state_dot\n            .fixed_rows_mut::&lt;3&gt;(3)\n            .copy_from(&amp;(a_grav + a_drag));\n        state_dot\n    };\n\n    // Analytical sensitivity function\n    let analytical_sensitivity =\n        |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: &amp;DVector&lt;f64&gt;| -&gt; DMatrix&lt;f64&gt; {\n            let r = state.fixed_rows::&lt;3&gt;(0);\n            let v = state.fixed_rows::&lt;3&gt;(3);\n            let r_norm = r.norm();\n\n            // Atmospheric density\n            let h = r_norm - R_EARTH;\n            let rho0 = 1.225;\n            let scale_height = 8500.0;\n            let rho = rho0 * (-h / scale_height).exp();\n\n            let v_norm = v.norm();\n\n            // \u2202(state_dot)/\u2202(cd_area_m)\n            let mut sens = DMatrix::&lt;f64&gt;::zeros(6, 1);\n            if v_norm &gt; 0.0 {\n                // \u2202(a_drag)/\u2202(cd_area_m) = -0.5 * rho * v_norm * v\n                for i in 0..3 {\n                    sens[(i + 3, 0)] = -0.5 * rho * v_norm * v[i];\n                }\n            }\n\n            sens\n        };\n\n    // Initial state (400 km LEO circular orbit)\n    let oe = SVector::&lt;f64, 6&gt;::from_row_slice(&amp;[R_EARTH + 250e3, 0.001, 51.6, 0.0, 0.0, 0.0]);\n    let state_vec = state_koe_to_eci(oe, AngleFormat::Degrees);\n    let state = DVector::from_iterator(6, state_vec.iter().copied());\n\n    // Consider parameters\n    let params = DVector::from_vec(vec![0.044]); // cd_area_m = Cd*A/m = 2.2*10/500\n\n    // Create numerical sensitivity provider\n    let numerical_sens = DNumericalSensitivity::central(Box::new(dynamics.clone()));\n\n    // Compute sensitivity matrix numerically\n    let sens_numerical = numerical_sens.compute(0.0, &amp;state, &amp;params);\n\n    println!(\"Numerical sensitivity (\u2202f/\u2202p):\");\n    println!(\n        \"  Position rates: [{}, {}, {}]\",\n        sens_numerical[(0, 0)],\n        sens_numerical[(1, 0)],\n        sens_numerical[(2, 0)]\n    );\n    println!(\n        \"  Velocity rates: [{}, {}, {}]\",\n        sens_numerical[(3, 0)],\n        sens_numerical[(4, 0)],\n        sens_numerical[(5, 0)]\n    );\n\n    // Create analytical sensitivity provider\n    let analytic_sens = DAnalyticSensitivity::new(Box::new(analytical_sensitivity));\n\n    // Compute sensitivity matrix analytically\n    let sens_analytical = analytic_sens.compute(0.0, &amp;state, &amp;params);\n\n    println!(\"\\nAnalytical sensitivity (\u2202f/\u2202p):\");\n    println!(\n        \"  Position rates: [{}, {}, {}]\",\n        sens_analytical[(0, 0)],\n        sens_analytical[(1, 0)],\n        sens_analytical[(2, 0)]\n    );\n    println!(\n        \"  Velocity rates: [{}, {}, {}]\",\n        sens_analytical[(3, 0)],\n        sens_analytical[(4, 0)],\n        sens_analytical[(5, 0)]\n    );\n\n    // Compare numerical and analytical\n    let diff = &amp;sens_numerical - &amp;sens_analytical;\n    let max_diff = diff.abs().max();\n    println!(\"\\nMax difference: {:.3e}\", max_diff);\n}\n\n// Numerical sensitivity (\u2202f/\u2202p):\n//   Position rates: [0, 0, 0]\n//   Velocity rates: [0, -0.000008425648220011794, -0.000010630522385923769]\n\n// Analytical sensitivity (\u2202f/\u2202p):\n//   Position rates: [0, 0, 0]\n//   Velocity rates: [0, -0.000008425648218908737, -0.00001063052238539645]\n\n// Max difference: 1.103e-15\n</code></pre>"},{"location":"learn/integrators/sensitivity_matrix.html#when-to-use-analytical-sensitivity","title":"When to Use Analytical Sensitivity","text":"<p>Use analytical sensitivity when:</p> <ul> <li>Derivatives \\(\\partial \\mathbf{f}/\\partial \\mathbf{p}\\) are simple to derive (e.g., drag coefficient, solar radiation pressure coefficient)</li> <li>Maximum accuracy is required (no finite difference errors)</li> <li>Sensitivity will be computed many times (performance critical)</li> <li>Working with well-understood parameter dependencies</li> </ul> <p>Recommendation</p> <p>For common parameters like atmospheric drag coefficient or solar radiation pressure coefficient, the analytical derivatives are often straightforward. When analytical forms are available, they provide better accuracy and performance than numerical approximations.</p>"},{"location":"learn/integrators/sensitivity_matrix.html#perturbation-strategies","title":"Perturbation Strategies","text":"<p>The <code>NumericalSensitivity</code> provider uses the same perturbation strategies as <code>NumericalJacobian</code>:</p> <ul> <li>Fixed perturbation: Constant step size for all parameters</li> <li>Percentage perturbation: Scale by parameter magnitude</li> <li>Adaptive perturbation: Balance accuracy and robustness</li> </ul> <p>See the Jacobian Computation guide for detailed information on configuring perturbation strategies.</p>"},{"location":"learn/integrators/sensitivity_matrix.html#integrating-sensitivity-matrices","title":"Integrating Sensitivity Matrices","text":"PythonRust <pre><code>\"\"\"\n\nimport brahe as bh\nimport numpy as np\n\n\ndef dynamics_with_params(t, state, params):\n    \"\"\"Orbital dynamics with atmospheric drag.\n\n    Args:\n        t: Time\n        state: [x, y, z, vx, vy, vz]\n        params: [cd_area_m] - drag coefficient * area / mass\n    \"\"\"\n    cd_area_m = params[0]\n\n    r = state[:3]\n    v = state[3:]\n    r_norm = np.linalg.norm(r)\n    a_grav = -bh.GM_EARTH / (r_norm**3) * r\n\n    # Atmospheric drag (simplified exponential model)\n    h = r_norm - bh.R_EARTH\n    rho0 = 1.225  # kg/m^3 at sea level\n    H = 8500.0  # Scale height in meters\n    rho = rho0 * np.exp(-h / H)\n\n    v_norm = np.linalg.norm(v)\n    a_drag = -0.5 * rho * cd_area_m * v_norm * v\n\n    return np.concatenate([v, a_grav + a_drag])\n\n\n# Consider parameters\ncd_area_m = 2.2 * 10.0 / 500.0  # Cd=2.2, A=10m^2, m=500kg\nparams = np.array([cd_area_m])\nnum_params = len(params)\n\n# Create sensitivity provider using NumericalSensitivity\nsensitivity_provider = bh.NumericalSensitivity.central(dynamics_with_params)\n\n# Create Jacobian provider using NumericalJacobian\njacobian_provider = bh.NumericalJacobian.central(\n    lambda t, s: dynamics_with_params(t, s, params)\n)\n\n\ndef augmented_dynamics(t, aug_state):\n    \"\"\"Augmented dynamics for state + sensitivity matrix propagation.\n\n    Propagates:\n        dx/dt = f(t, x, p)\n        d\u03a6/dt = (\u2202f/\u2202x) * \u03a6 + (\u2202f/\u2202p)\n\n    Args:\n        t: Time\n        aug_state: [state (6), vec(\u03a6) (6*num_params)]\n    \"\"\"\n    state = aug_state[:6]\n    phi = aug_state[6:].reshape(6, num_params)\n\n    # State derivative\n    state_dot = dynamics_with_params(t, state, params)\n\n    # Compute Jacobian \u2202f/\u2202x\n    jacobian = jacobian_provider.compute(t, state)\n\n    # Compute sensitivity \u2202f/\u2202p\n    sensitivity = sensitivity_provider.compute(t, state, params)\n\n    # Sensitivity matrix derivative: d\u03a6/dt = J*\u03a6 + S\n    phi_dot = jacobian @ phi + sensitivity\n\n    return np.concatenate([state_dot, phi_dot.flatten()])\n\n\n# Initial state (200 km LEO for significant drag effects)\noe = np.array([bh.R_EARTH + 200e3, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Initial sensitivity matrix (identity would mean we start with unit sensitivity,\n# but we start with zero since we're interested in how sensitivity develops)\nphi0 = np.zeros((6, num_params))\n\n# Augmented initial state\naug_state = np.concatenate([state, phi0.flatten()])\n\n# Create integrator for augmented system\n# Using fixed step RK4 for simplicity and exact parity with Rust\naug_dim = 6 + 6 * num_params\nconfig = bh.IntegratorConfig.fixed_step(1.0)\nintegrator = bh.RK4Integrator(aug_dim, augmented_dynamics, config=config)\n\n# Propagate for 1 hour\nt = 0.0\ndt = 1.0\nt_final = 3600.0\n\nwhile t &lt; t_final:\n    aug_state = integrator.step(t, aug_state, dt)\n    t += dt\n\n# Extract final state and sensitivity matrix\nfinal_state = aug_state[:6]\nfinal_phi = aug_state[6:].reshape(6, num_params)\n\nprint(f\"Final position after {t_final / 60:.0f} minutes:\")\nprint(f\"  x: {final_state[0] / 1000:.3f} km\")\nprint(f\"  y: {final_state[1] / 1000:.3f} km\")\nprint(f\"  z: {final_state[2] / 1000:.3f} km\")\n\nprint(\"\\nSensitivity matrix \u03a6 = \u2202x/\u2202p (position per unit Cd*A/m):\")\nprint(f\"  dx/dp: {final_phi[0, 0]:.3f} m/(m\u00b2/kg)\")\nprint(f\"  dy/dp: {final_phi[1, 0]:.3f} m/(m\u00b2/kg)\")\nprint(f\"  dz/dp: {final_phi[2, 0]:.3f} m/(m\u00b2/kg)\")\n\nprint(\"\\nSensitivity matrix \u03a6 = \u2202x/\u2202p (velocity per unit Cd*A/m):\")\nprint(f\"  dvx/dp: {final_phi[3, 0]:.6f} m/s/(m\u00b2/kg)\")\nprint(f\"  dvy/dp: {final_phi[4, 0]:.6f} m/s/(m\u00b2/kg)\")\nprint(f\"  dvz/dp: {final_phi[5, 0]:.6f} m/s/(m\u00b2/kg)\")\n\n# Interpret: If we have 10% uncertainty in Cd*A/m (0.1 * 0.044 = 0.0044),\n# the position uncertainty after 1 hour would be:\ndelta_p = 0.1 * cd_area_m\npos_uncertainty = np.linalg.norm(final_phi[:3, 0]) * delta_p\nprint(f\"\\nPosition uncertainty for 10% parameter uncertainty: {pos_uncertainty:.1f} m\")\n\n# Expected output:\n# Final position after 60 minutes:\n#   x: -2884.245 km\n#   y: -3673.659 km\n#   z: -4635.004 km\n\n# Sensitivity matrix \u03a6 = \u2202x/\u2202p (position per unit Cd*A/m):\n#   dx/dp: 59942.894 m/(m\u00b2/kg)\n#   dy/dp: -3796.878 m/(m\u00b2/kg)\n#   dz/dp: -4790.467 m/(m\u00b2/kg)\n\n# Sensitivity matrix \u03a6 = \u2202x/\u2202p (velocity per unit Cd*A/m):\n#   dvx/dp: 44.091413 m/s/(m\u00b2/kg)\n#   dvy/dp: 33.444231 m/s/(m\u00b2/kg)\n#   dvz/dp: 42.196119 m/s/(m\u00b2/kg)\n\n# Position uncertainty for 10% parameter uncertainty: 265.1 m\n</code></pre> <pre><code>//! Sensitivity matrix propagation pattern example.\n//!\n//! Demonstrates propagating the sensitivity matrix alongside state to map\n//! parameter uncertainties to state uncertainties over time.\n//!\n//! The sensitivity matrix \u03a6 = \u2202x/\u2202p evolves according to:\n//!     d\u03a6/dt = (\u2202f/\u2202x) * \u03a6 + (\u2202f/\u2202p)\n//!\n//! This augmented state approach propagates [state, vec(\u03a6)] together.\n\nuse brahe::constants::{GM_EARTH, R_EARTH};\nuse brahe::integrators::*;\nuse brahe::math::jacobian::{DJacobianProvider, DNumericalJacobian};\nuse brahe::math::sensitivity::{DNumericalSensitivity, DSensitivityProvider};\nuse brahe::{state_koe_to_eci, AngleFormat};\nuse nalgebra::{DVector, SVector};\n\nfn main() {\n    // Consider parameters\n    let cd_area_m = 2.2 * 10.0 / 500.0; // Cd=2.2, A=10m^2, m=500kg\n    let params = DVector::from_vec(vec![cd_area_m]);\n    let num_params = params.len();\n\n    // Dynamics function with parameters\n    let dynamics_with_params =\n        |_t: f64, state: &amp;DVector&lt;f64&gt;, params: &amp;DVector&lt;f64&gt;| -&gt; DVector&lt;f64&gt; {\n            let cd_area_m = params[0];\n\n            let r = state.fixed_rows::&lt;3&gt;(0);\n            let v = state.fixed_rows::&lt;3&gt;(3);\n            let r_norm = r.norm();\n\n            // Gravitational acceleration\n            let a_grav = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n            // Atmospheric drag (simplified exponential model)\n            let h = r_norm - R_EARTH;\n            let rho0 = 1.225; // kg/m^3\n            let scale_height = 8500.0; // m\n            let rho = rho0 * (-h / scale_height).exp();\n\n            let v_norm = v.norm();\n            let a_drag = if v_norm &gt; 0.0 {\n                -0.5 * rho * cd_area_m * v_norm * v\n            } else {\n                nalgebra::Vector3::zeros()\n            };\n\n            let mut state_dot = DVector::&lt;f64&gt;::zeros(6);\n            state_dot\n                .fixed_rows_mut::&lt;3&gt;(0)\n                .copy_from(&amp;v.clone_owned());\n            state_dot\n                .fixed_rows_mut::&lt;3&gt;(3)\n                .copy_from(&amp;(a_grav + a_drag));\n            state_dot\n        };\n\n    // Create sensitivity provider\n    let sensitivity_provider =\n        DNumericalSensitivity::central(Box::new(dynamics_with_params.clone()));\n\n    // Create Jacobian provider (dynamics without explicit params for Jacobian)\n    let params_clone = params.clone();\n    let dynamics_for_jacobian = move |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let cd_area_m = params_clone[0];\n\n        let r = state.fixed_rows::&lt;3&gt;(0);\n        let v = state.fixed_rows::&lt;3&gt;(3);\n        let r_norm = r.norm();\n\n        let a_grav = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n        let h = r_norm - R_EARTH;\n        let rho0 = 1.225;\n        let scale_height = 8500.0;\n        let rho = rho0 * (-h / scale_height).exp();\n\n        let v_norm = v.norm();\n        let a_drag = if v_norm &gt; 0.0 {\n            -0.5 * rho * cd_area_m * v_norm * v\n        } else {\n            nalgebra::Vector3::zeros()\n        };\n\n        let mut state_dot = DVector::&lt;f64&gt;::zeros(6);\n        state_dot\n            .fixed_rows_mut::&lt;3&gt;(0)\n            .copy_from(&amp;v.clone_owned());\n        state_dot\n            .fixed_rows_mut::&lt;3&gt;(3)\n            .copy_from(&amp;(a_grav + a_drag));\n        state_dot\n    };\n\n    let jacobian_provider = DNumericalJacobian::central(Box::new(dynamics_for_jacobian));\n\n    // Augmented dynamics for state + sensitivity matrix propagation\n    let params_for_aug = params.clone();\n    let augmented_dynamics = move |t: f64,\n                                   aug_state: &amp;DVector&lt;f64&gt;,\n                                   _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;|\n          -&gt; DVector&lt;f64&gt; {\n        // Extract state and sensitivity matrix\n        let state = aug_state.rows(0, 6).into_owned();\n        let phi_flat = aug_state.rows(6, 6 * num_params).into_owned();\n\n        // Reshape phi from flat vector to matrix (column-major)\n        let mut phi = nalgebra::DMatrix::&lt;f64&gt;::zeros(6, num_params);\n        for j in 0..num_params {\n            for i in 0..6 {\n                phi[(i, j)] = phi_flat[j * 6 + i];\n            }\n        }\n\n        // State derivative\n        let state_dot = dynamics_with_params(t, &amp;state, &amp;params_for_aug);\n\n        // Compute Jacobian \u2202f/\u2202x\n        let jacobian = jacobian_provider.compute(t, &amp;state, None);\n\n        // Compute sensitivity \u2202f/\u2202p\n        let sensitivity = sensitivity_provider.compute(t, &amp;state, &amp;params_for_aug);\n\n        // Sensitivity matrix derivative: d\u03a6/dt = J*\u03a6 + S\n        let phi_dot = &amp;jacobian * &amp;phi + &amp;sensitivity;\n\n        // Flatten phi_dot back to vector (column-major)\n        let mut phi_dot_flat = DVector::&lt;f64&gt;::zeros(6 * num_params);\n        for j in 0..num_params {\n            for i in 0..6 {\n                phi_dot_flat[j * 6 + i] = phi_dot[(i, j)];\n            }\n        }\n\n        // Concatenate state_dot and phi_dot\n        let mut aug_dot = DVector::&lt;f64&gt;::zeros(6 + 6 * num_params);\n        aug_dot.rows_mut(0, 6).copy_from(&amp;state_dot);\n        aug_dot.rows_mut(6, 6 * num_params).copy_from(&amp;phi_dot_flat);\n        aug_dot\n    };\n\n    // Initial state (200 km LEO for significant drag effects)\n    let oe = SVector::&lt;f64, 6&gt;::from_row_slice(&amp;[R_EARTH + 200e3, 0.001, 51.6, 0.0, 0.0, 0.0]);\n    let state_vec = state_koe_to_eci(oe, AngleFormat::Degrees);\n    let state = DVector::from_iterator(6, state_vec.iter().copied());\n\n    // Initial sensitivity matrix (zeros - we're interested in how it develops)\n    let phi0 = DVector::&lt;f64&gt;::zeros(6 * num_params);\n\n    // Augmented initial state\n    let mut aug_state = DVector::&lt;f64&gt;::zeros(6 + 6 * num_params);\n    aug_state.rows_mut(0, 6).copy_from(&amp;state);\n    aug_state.rows_mut(6, 6 * num_params).copy_from(&amp;phi0);\n\n    // Create integrator for augmented system\n    // Using fixed step RK4 for simplicity and exact parity with Python\n    let aug_dim = 6 + 6 * num_params;\n    let config = IntegratorConfig::fixed_step(1.0);\n    let integrator = RK4DIntegrator::with_config(\n        aug_dim,\n        Box::new(augmented_dynamics),\n        None,\n        None,\n        None,\n        config,\n    );\n\n    // Propagate for 1 hour\n    let t_final = 3600.0;\n    let mut t = 0.0;\n    let dt = 1.0;\n\n    while t &lt; t_final {\n        aug_state = integrator.step(t, aug_state, None, None).state;\n        t += dt;\n    }\n\n    // Extract final state and sensitivity matrix\n    let final_state = aug_state.rows(0, 6).into_owned();\n    let final_phi_flat = aug_state.rows(6, 6 * num_params).into_owned();\n\n    // Reshape to matrix\n    let mut final_phi = nalgebra::DMatrix::&lt;f64&gt;::zeros(6, num_params);\n    for j in 0..num_params {\n        for i in 0..6 {\n            final_phi[(i, j)] = final_phi_flat[j * 6 + i];\n        }\n    }\n\n    println!(\"Final position after {} minutes:\", t_final / 60.0);\n    println!(\"  x: {:.3} km\", final_state[0] / 1000.0);\n    println!(\"  y: {:.3} km\", final_state[1] / 1000.0);\n    println!(\"  z: {:.3} km\", final_state[2] / 1000.0);\n\n    println!(\"\\nSensitivity matrix \u03a6 = \u2202x/\u2202p (position per unit Cd*A/m):\");\n    println!(\"  dx/dp: {:.3} m/(m\u00b2/kg)\", final_phi[(0, 0)]);\n    println!(\"  dy/dp: {:.3} m/(m\u00b2/kg)\", final_phi[(1, 0)]);\n    println!(\"  dz/dp: {:.3} m/(m\u00b2/kg)\", final_phi[(2, 0)]);\n\n    println!(\"\\nSensitivity matrix \u03a6 = \u2202x/\u2202p (velocity per unit Cd*A/m):\");\n    println!(\"  dvx/dp: {:.6} m/s/(m\u00b2/kg)\", final_phi[(3, 0)]);\n    println!(\"  dvy/dp: {:.6} m/s/(m\u00b2/kg)\", final_phi[(4, 0)]);\n    println!(\"  dvz/dp: {:.6} m/s/(m\u00b2/kg)\", final_phi[(5, 0)]);\n\n    // Interpret: If we have 10% uncertainty in Cd*A/m,\n    // the position uncertainty after 1 hour would be:\n    let delta_p = 0.1 * cd_area_m;\n    let pos_uncertainty = (final_phi[(0, 0)].powi(2)\n        + final_phi[(1, 0)].powi(2)\n        + final_phi[(2, 0)].powi(2))\n    .sqrt()\n        * delta_p;\n    println!(\n        \"\\nPosition uncertainty for 10% parameter uncertainty: {:.1} m\",\n        pos_uncertainty\n    );\n}\n\n// Example output:\n// Final position after 60 minutes:\n//   x: -2884.245 km\n//   y: -3673.659 km\n//   z: -4635.004 km\n\n// Sensitivity matrix \u03a6 = \u2202x/\u2202p (position per unit Cd*A/m):\n//   dx/dp: 59942.895 m/(m\u00b2/kg)\n//   dy/dp: -3796.877 m/(m\u00b2/kg)\n//   dz/dp: -4790.467 m/(m\u00b2/kg)\n\n// Sensitivity matrix \u03a6 = \u2202x/\u2202p (velocity per unit Cd*A/m):\n//   dvx/dp: 44.091415 m/s/(m\u00b2/kg)\n//   dvy/dp: 33.444232 m/s/(m\u00b2/kg)\n//   dvz/dp: 42.196119 m/s/(m\u00b2/kg)\n\n// Position uncertainty for 10% parameter uncertainty: 265.1 m\n</code></pre>"},{"location":"learn/integrators/sensitivity_matrix.html#see-also","title":"See Also","text":"<ul> <li>Variational Equations - State Transition Matrix theory</li> <li>Configuration Guide - Integrator tuning</li> <li>Jacobian Computation - Computing the A matrix</li> </ul>"},{"location":"learn/integrators/variational_equations.html","title":"Variational Equations and State Transition Matrix","text":"<p>Variational equations enable propagating not just the statye dynamics, but also how small perturbations would affect the state over time. They help relate how changes in state at one time map to changes at a later time which is critical for orbit determination and control.</p>"},{"location":"learn/integrators/variational_equations.html#what-are-variational-equations","title":"What are Variational Equations?","text":"<p>For a dynamical system \\(\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x})\\), variational equations describe how small deviations from the nominal trajectory evolve. Consider two nearby initial conditions:</p> <ul> <li>Nominal: \\(\\mathbf{x}_0\\)</li> <li>Perturbed: \\(\\mathbf{x}_0 + \\delta\\mathbf{x}_0\\)</li> </ul> <p>The difference in trajectories can be approximated by the State Transition Matrix (STM) \\(\\Phi(t, t_0)\\):</p> \\[\\delta\\mathbf{x}(t) \\approx \\Phi(t, t_0) \\cdot \\delta\\mathbf{x}_0\\] <p>This relationship is exact for linear systems and accurate for nonlinear systems when \\(||\\delta\\mathbf{x}_0||\\) is small.</p>"},{"location":"learn/integrators/variational_equations.html#the-state-transition-matrix","title":"The State Transition Matrix","text":"<p>The State Transition Matrix (STM) satisfies the matrix differential equation:</p> \\[\\dot{\\Phi}(t, t_0) = \\mathbf{J}(t, \\mathbf{x}(t)) \\cdot \\Phi(t, t_0)\\] <p>where \\(\\mathbf{J}\\) is the Jacobian matrix of the dynamics:</p> \\[\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial x_j}\\] <p>The STM has a few key properites. First, the intial condition of the STM is always the indentity matrix. That is:</p> <p>\\(\\Phi(t_0, t_0) = \\mathbf{I}\\) (identity matrix)</p> <p>For linear systems: \\(\\Phi(t, t_0)\\) is the matrix exponential \\(e^{\\mathbf{A}(t-t_0)}\\).</p>"},{"location":"learn/integrators/variational_equations.html#stm-propagation-in-brahe","title":"STM Propagation in Brahe","text":"<p>Brahe integrators can propagate the state and STM simultaneously using <code>step_with_varmat()</code>. What happens under the hood is:</p> <ol> <li>The integrator advances both the state (\\(\\mathbf{x}\\)) and the STM (\\(\\Phi\\)) using the same time step</li> <li>At each stage of the Runge-Kutta method, the Jacobian is evaluated at the current state</li> <li>The variational equations \\(\\dot{\\Phi} = \\mathbf{J} \\cdot \\Phi\\) are integrated alongside the state equations</li> </ol> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP\nbh.initialize_eop()\n\n\n# Define two-body dynamics\ndef dynamics(t, state):\n    mu = bh.GM_EARTH\n    r = state[0:3]\n    v = state[3:6]\n    r_norm = np.linalg.norm(r)\n    a = -mu / r_norm**3 * r\n    return np.concatenate([v, a])\n\n\n# Create numerical Jacobian for variational equations\njacobian = bh.NumericalJacobian.central(dynamics).with_adaptive(\n    scale_factor=1.0, min_value=1e-6\n)\n\n# Initial orbit (LEO)\nr0 = np.array([bh.R_EARTH + 600e3, 0.0, 0.0])\nv0 = np.array([0.0, 7.5e3, 0.0])\nstate0 = np.concatenate([r0, v0])\n\n# Initial state transition matrix (identity)\nphi0 = np.eye(6)\n\nprint(\"Integration with State Transition Matrix\")\nprint(f\"Initial orbit: {r0[0] / 1e3:.1f} km altitude\")\n\n# Create integrator with Jacobian\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-12, rel_tol=1e-11)\nintegrator = bh.DP54Integrator(6, dynamics, jacobian=jacobian, config=config)\n\n# Propagate for one orbit period\nt = 0.0\nstate = state0.copy()\nphi = phi0.copy()\ndt = 60.0\n\n# Approximate orbital period\nperiod = bh.orbital_period(np.linalg.norm(r0))\n\nprint(\"Time   Position STM[0,0]  Velocity STM[3,3]  Det(STM)\")\nprint(\"-\" * 60)\n\nsteps = 0\nwhile t &lt; period:\n    # Propagate state and STM together (adaptive integrator returns 5-tuple)\n    new_state, new_phi, dt_used, error_est, dt_next = integrator.step_with_varmat(\n        t, state, phi, min(dt, period - t)\n    )\n\n    t += dt_used\n    state = new_state\n    phi = new_phi\n    dt = dt_next\n    steps += 1\n\n    # Print progress\n    if steps % 20 == 1:\n        det_phi = np.linalg.det(phi)\n        print(\n            f\"{t:6.0f}s    {phi[0, 0]:8.4f}      {phi[3, 3]:8.4f}        {det_phi:8.4f}\"\n        )\n\nprint(f\"\\nPropagation complete! ({steps} steps)\")\n\n# Example: Map initial position uncertainty to final uncertainty\nprint(\"\\nExample: Uncertainty Propagation\")\ndx = 100.0\nprint(f\"Initial position uncertainty: \u00b1{dx} m in each direction\")\ndelta_r0 = np.array([dx, dx, dx, 0.0, 0.0, 0.0])\ndelta_rf = phi @ delta_r0\nprint(\n    f\"Final position uncertainty: [{delta_rf[0]:.1f}, {delta_rf[1]:.1f}, {delta_rf[2]:.1f}] m\"\n)\nprint(\n    f\"Uncertainty growth: {np.linalg.norm(delta_rf[0:3]) / np.linalg.norm(delta_r0[0:3]):.1f}x\"\n)\n\n# Example output:\n# Integration with State Transition Matrix\n# Initial orbit: 6978.1 km altitude\n# Time   Position STM[0,0]  Velocity STM[3,3]  Det(STM)\n# ------------------------------------------------------------\n#      0s      1.0000        1.0000          1.0000\n#    223s      1.0580        1.0564          1.0000\n#    594s      1.3993        1.3227          1.0000\n#   1007s      2.0473        1.5071          1.0000\n#   1346s      2.5985        1.1989          1.0000\n#   1530s      2.8009        0.7891          1.0000\n#   1849s      2.7780       -0.2849          1.0000\n#   2245s      1.6741       -1.8673          1.0000\n#   2608s     -0.7226       -2.9191          1.0000\n#   2835s     -2.8726       -3.1249          1.0000\n#   3091s     -5.7502       -2.8654          1.0000\n#   3455s    -10.0598       -1.7595          1.0000\n#   3850s    -13.8989       -0.1764          1.0000\n#   4169s    -15.4760        0.8634          1.0000\n#   4360s    -15.5400        1.2575          1.0000\n#   4700s    -13.8708        1.5097          1.0000\n#   5114s     -8.9723        1.2931          1.0000\n#   5484s     -2.6152        1.0402          1.0000\n#   5697s      1.5156        1.0008          1.0000\n\n# Propagation complete! (370 steps)\n\n# Example: Uncertainty Propagation\n# Initial position uncertainty: \u00b1100.0 m in each direction\n# Final position uncertainty: [357.4, -1684.0, 99.0] m\n# Uncertainty growth: 10.0x\n</code></pre> <pre><code>use brahe::*;\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Initialize EOP\n    initialize_eop().unwrap();\n\n    // Define two-body dynamics (for integrator - takes optional params)\n    let dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let r = nalgebra::Vector3::new(state[0], state[1], state[2]);\n        let v = nalgebra::Vector3::new(state[3], state[4], state[5]);\n        let r_norm = r.norm();\n        let a = -GM_EARTH / r_norm.powi(3) * r;\n        DVector::from_vec(vec![v[0], v[1], v[2], a[0], a[1], a[2]])\n    };\n\n    // Same dynamics for Jacobian (without params argument)\n    let dynamics_for_jac = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let r = nalgebra::Vector3::new(state[0], state[1], state[2]);\n        let v = nalgebra::Vector3::new(state[3], state[4], state[5]);\n        let r_norm = r.norm();\n        let a = -GM_EARTH / r_norm.powi(3) * r;\n        DVector::from_vec(vec![v[0], v[1], v[2], a[0], a[1], a[2]])\n    };\n\n    // Create numerical Jacobian for variational equations\n    let jacobian = DNumericalJacobian::central(Box::new(dynamics_for_jac))\n        .with_adaptive(1.0, 1e-6);\n\n    // Initial orbit (LEO)\n    let r0 = DVector::from_vec(vec![R_EARTH + 600e3, 0.0, 0.0]);\n    let v0 = DVector::from_vec(vec![0.0, 7.5e3, 0.0]);\n    let state0 = DVector::from_vec(vec![r0[0], r0[1], r0[2], v0[0], v0[1], v0[2]]);\n\n    // Initial state transition matrix (identity)\n    let phi0 = DMatrix::identity(6, 6);\n\n    println!(\"Integration with State Transition Matrix\");\n    println!(\"Initial orbit: {:.1} km altitude\", r0[0] / 1e3);\n\n    // Create integrator with Jacobian\n    let config = IntegratorConfig::adaptive(1e-12, 1e-11);\n    let integrator = DormandPrince54DIntegrator::with_config(6, Box::new(dynamics), Some(Box::new(jacobian)), None, None, config);\n\n    // Propagate for one orbit period\n    let mut t = 0.0;\n    let mut state = state0.clone();\n    let mut phi = phi0.clone();\n    let mut dt: f64 = 60.0;\n\n    // Approximate orbital period\n    let period = orbital_period(r0.norm());\n\n    println!(\"Time   Position STM[0,0]  Velocity STM[3,3]  Det(STM)\");\n    println!(\"{}\", \"-\".repeat(60));\n\n    let mut steps = 0;\n    while t &lt; period {\n        // Propagate state and STM together\n        let result = integrator.step_with_varmat(t, state, None, phi, Some(dt.min(period - t)));\n\n        let new_state = result.state;\n        let new_phi = result.phi.unwrap();\n        let dt_used = result.dt_used;\n        let dt_next = result.dt_next;\n\n        t += dt_used;\n        state = new_state;\n        phi = new_phi;\n        dt = dt_next;\n        steps += 1;\n\n        // Print progress\n        if steps % 20 == 1 {\n            let det_phi = phi.clone().lu().determinant();\n            println!(\"{:6.0}s    {:8.4}      {:8.4}        {:8.4}\",\n                     t, phi[(0, 0)], phi[(3, 3)], det_phi);\n        }\n    }\n\n    println!(\"\\nPropagation complete! ({} steps)\", steps);\n\n    // Example: Map initial position uncertainty to final uncertainty\n    println!(\"\\nExample: Uncertainty Propagation\");\n    let dx = 100.0;\n    println!(\"Initial position uncertainty: \u00b1{} m in each direction\", dx);\n    let delta_r0 = DVector::from_vec(vec![dx, dx, dx, 0.0, 0.0, 0.0]);\n    let delta_rf = &amp;phi * &amp;delta_r0;\n    println!(\"Final position uncertainty: [{:.1}, {:.1}, {:.1}] m\",\n             delta_rf[0], delta_rf[1], delta_rf[2]);\n\n    let r0_norm = (delta_r0[0].powi(2) + delta_r0[1].powi(2) + delta_r0[2].powi(2)).sqrt();\n    let rf_norm = (delta_rf[0].powi(2) + delta_rf[1].powi(2) + delta_rf[2].powi(2)).sqrt();\n    println!(\"Uncertainty growth: {:.1}x\", rf_norm / r0_norm);\n}\n\n// Example output:\n// Integration with State Transition Matrix\n// Initial orbit: 6978.1 km altitude\n// Time   Position STM[0,0]  Velocity STM[3,3]  Det(STM)\n// ------------------------------------------------------------\n//      0s      1.0000        1.0000          1.0000\n//    223s      1.0580        1.0564          1.0000\n//    594s      1.3993        1.3227          1.0000\n//   1007s      2.0473        1.5071          1.0000\n//   1346s      2.5985        1.1989          1.0000\n//   1530s      2.8009        0.7891          1.0000\n//   1849s      2.7780       -0.2849          1.0000\n//   2245s      1.6741       -1.8673          1.0000\n//   2608s     -0.7226       -2.9191          1.0000\n//   2835s     -2.8726       -3.1249          1.0000\n//   3091s     -5.7502       -2.8654          1.0000\n//   3455s    -10.0598       -1.7595          1.0000\n//   3850s    -13.8989       -0.1764          1.0000\n//   4169s    -15.4760        0.8634          1.0000\n//   4360s    -15.5400        1.2575          1.0000\n//   4700s    -13.8708        1.5097          1.0000\n//   5114s     -8.9723        1.2931          1.0000\n//   5484s     -2.6152        1.0402          1.0000\n//   5697s      1.5156        1.0008          1.0000\n\n// Propagation complete! (370 steps)\n\n// Example: Uncertainty Propagation\n// Initial position uncertainty: \u00b1100.0 m in each direction\n// Final position uncertainty: [357.4, -1684.0, 99.0] m\n// Uncertainty growth: 10.0x\n</code></pre>"},{"location":"learn/integrators/variational_equations.html#equivalence-to-direct-perturbation","title":"Equivalence to Direct Perturbation","text":"<p>The power of the STM is that it allows predicting many perturbed trajectories efficiently. Instead of integrating each perturbed initial condition separately, we can integrate the nominal trajectory once (with STM) and map any initial perturbation through the STM.</p> <p>The following example demonstrates this equivalence:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP\nbh.initialize_eop()\n\n\n# Define two-body orbital dynamics\ndef dynamics(t, state):\n    \"\"\"Two-body point-mass dynamics with Earth gravity.\"\"\"\n    mu = bh.GM_EARTH\n    r = state[0:3]\n    v = state[3:6]\n    r_norm = np.linalg.norm(r)\n    a = -mu / r_norm**3 * r\n    return np.concatenate([v, a])\n\n\n# Create numerical Jacobian for variational equations\njacobian = bh.NumericalJacobian.central(dynamics).with_fixed_offset(0.1)\n\n# Configuration for high accuracy\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-12, rel_tol=1e-10)\n\n# Create two integrators:\n# 1. With Jacobian - propagates STM alongside state\nintegrator_nominal = bh.RKN1210Integrator(6, dynamics, jacobian=jacobian, config=config)\n\n# 2. Without Jacobian - for direct perturbation integration\nintegrator_pert = bh.RKN1210Integrator(6, dynamics, config=config)\n\n# Initial state: circular orbit at 500 km altitude\noe0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\nstate0 = bh.state_koe_to_eci(oe0, bh.AngleFormat.DEGREES)\n\n# Apply 10-meter perturbation in X direction\nperturbation = np.array([10.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n\n# Integration parameters\ntotal_time = 100.0  # Total propagation time (seconds)\nnum_steps = 10  # Number of steps\ndt = total_time / num_steps\n\n# Initialize states\nstate_nominal = state0.copy()\nphi = np.eye(6)  # State Transition Matrix starts as identity\nstate_pert = state0 + perturbation\n\nprint(\"STM vs Direct Perturbation Comparison\")\nprint(\"=\" * 70)\nprint(f\"Initial orbit: {(oe0[0] - bh.R_EARTH) / 1e3:.1f} km altitude (circular)\")\nprint(f\"Perturbation: {perturbation[0]:.1f} m in X direction\")\nprint(f\"Propagating for {total_time:.0f} seconds in {num_steps} steps\\n\")\nprint(\"Theory: For small \u03b4x\u2080, the perturbed state should satisfy:\")\nprint(\"        x_pert(t) \u2248 x_nominal(t) + \u03a6(t,t\u2080)\u00b7\u03b4x\u2080\\n\")\nprint(\"Step   Time(s)  ||Error||(m)  Max Component(m)  Relative Error\")\nprint(\"-\" * 70)\n\nt = 0.0\nfor step in range(num_steps):\n    # Propagate nominal trajectory with STM\n    new_state_nominal, new_phi, dt_used, _, _ = integrator_nominal.step_with_varmat(\n        t, state_nominal, phi, dt\n    )\n\n    # Propagate perturbed trajectory directly\n    result_pert = integrator_pert.step(t, state_pert, dt)\n\n    # Predict perturbed state using STM: x_pert \u2248 x_nominal + \u03a6\u00b7\u03b4x\u2080\n    state_pert_predicted = new_state_nominal + new_phi @ perturbation\n\n    # Compute error between STM prediction and direct integration\n    error = result_pert.state - state_pert_predicted\n    error_norm = np.linalg.norm(error)\n    error_max = np.max(np.abs(error))\n\n    # Relative error compared to perturbation magnitude\n    relative_error = error_norm / np.linalg.norm(perturbation)\n\n    print(\n        f\"{step + 1:4d}  {t + dt_used:7.1f}  {error_norm:12.6f}  {error_max:16.6f}  {relative_error:13.6f}\"\n    )\n\n    # Update for next step\n    state_nominal = new_state_nominal\n    phi = new_phi\n    state_pert = result_pert.state\n    t += dt_used\n\n# Example output:\n# STM vs Direct Perturbation Comparison\n# ======================================================================\n# Initial orbit: 500.0 km altitude (circular)\n# Perturbation: 10.0 m in X direction\n# Propagating for 100 seconds in 10 steps\n#\n# Theory: For small \u03b4x\u2080, the perturbed state should satisfy:\n#         x_pert(t) \u2248 x_nominal(t) + \u03a6(t,t\u2080)\u00b7\u03b4x\u2080\n#\n# Step   Time(s)  ||Error||(m)  Max Component(m)  Relative Error\n# ----------------------------------------------------------------------\n#    1     10.0      0.000078          0.000053      0.000008\n#    2     20.0      0.000299          0.000211      0.000030\n#    3     30.0      0.000627          0.000462      0.000063\n#    4     40.0      0.001025          0.000791      0.000103\n#    5     50.0      0.001463          0.001176      0.000146\n#    6     60.0      0.001919          0.001600      0.000192\n#    7     70.0      0.002378          0.002057      0.000238\n#    8     80.0      0.002831          0.002539      0.000283\n#    9     90.0      0.003271          0.003040      0.000327\n#   10    100.0      0.003693          0.003556      0.000369\n</code></pre> <pre><code>use brahe::*;\nuse nalgebra::{DMatrix, DVector, SVector};\n\n/// Two-body point-mass dynamics with Earth gravity (for integrator)\nfn dynamics(_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;) -&gt; DVector&lt;f64&gt; {\n    let r = state.rows(0, 3);\n    let v = state.rows(3, 3);\n    let r_norm = r.norm();\n    let a = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n    let mut state_dot = DVector::zeros(6);\n    state_dot.rows_mut(0, 3).copy_from(&amp;v);\n    state_dot.rows_mut(3, 3).copy_from(&amp;a);\n    state_dot\n}\n\n/// Two-body dynamics (for Jacobian computation - no params)\nfn dynamics_for_jac(_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;) -&gt; DVector&lt;f64&gt; {\n    let r = state.rows(0, 3);\n    let v = state.rows(3, 3);\n    let r_norm = r.norm();\n    let a = -GM_EARTH / (r_norm * r_norm * r_norm) * r;\n\n    let mut state_dot = DVector::zeros(6);\n    state_dot.rows_mut(0, 3).copy_from(&amp;v);\n    state_dot.rows_mut(3, 3).copy_from(&amp;a);\n    state_dot\n}\n\nfn main() {\n    // Initialize EOP\n    initialize_eop().unwrap();\n\n    // Create numerical Jacobian for variational equations\n    let jacobian = DNumericalJacobian::central(Box::new(dynamics_for_jac))\n        .with_fixed_offset(0.1);\n\n    // Configuration for high accuracy\n    let config = IntegratorConfig::adaptive(1e-12, 1e-10);\n\n    // Create two integrators:\n    // 1. With Jacobian - propagates STM alongside state\n    let integrator_nominal = RKN1210DIntegrator::with_config(\n        6,\n        Box::new(dynamics),\n        Some(Box::new(jacobian)),\n        None,\n        None,\n        config.clone(),\n    );\n\n    // 2. Without Jacobian - for direct perturbation integration\n    let integrator_pert = RKN1210DIntegrator::with_config(\n        6,\n        Box::new(dynamics),\n        None,\n        None,\n        None,\n        config,\n    );\n\n    // Initial state: circular orbit at 500 km altitude\n    let oe0 = SVector::&lt;f64, 6&gt;::new(R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0);\n    let state0_static = state_koe_to_eci(oe0, AngleFormat::Degrees);\n    let state0 = DVector::from_vec(state0_static.as_slice().to_vec());\n\n    // Apply 10-meter perturbation in X direction\n    let perturbation = DVector::from_vec(vec![10.0, 0.0, 0.0, 0.0, 0.0, 0.0]);\n\n    // Integration parameters\n    let total_time = 100.0; // Total propagation time (seconds)\n    let num_steps = 10;     // Number of steps\n    let dt = total_time / num_steps as f64;\n\n    // Initialize states\n    let mut state_nominal = state0.clone();\n    let mut phi = DMatrix::identity(6, 6); // State Transition Matrix starts as identity\n    let mut state_pert = &amp;state0 + &amp;perturbation;\n    let mut t = 0.0;\n\n    println!(\"STM vs Direct Perturbation Comparison\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"Initial orbit: {:.1} km altitude (circular)\", (oe0[0] - R_EARTH) / 1e3);\n    println!(\"Perturbation: {:.1} m in X direction\", perturbation[0]);\n    println!(\"Propagating for {:.0} seconds in {} steps\\n\", total_time, num_steps);\n    println!(\"Theory: For small \u03b4x\u2080, the perturbed state should satisfy:\");\n    println!(\"        x_pert(t) \u2248 x_nominal(t) + \u03a6(t,t\u2080)\u00b7\u03b4x\u2080\\n\");\n    println!(\"Step   Time(s)  ||Error||(m)  Max Component(m)  Relative Error\");\n    println!(\"{}\", \"-\".repeat(70));\n\n    for step in 0..num_steps {\n        // Propagate nominal trajectory with STM\n        let result_nominal = integrator_nominal.step_with_varmat(\n            t,\n            state_nominal.clone(),\n            None,\n            phi.clone(),\n            Some(dt),\n        );\n        let new_state_nominal = result_nominal.state;\n        let new_phi = result_nominal.phi.unwrap();\n        let dt_used = result_nominal.dt_used;\n\n        // Propagate perturbed trajectory directly\n        let result_pert = integrator_pert.step(\n            t,\n            state_pert.clone(),\n            None,\n            Some(dt),\n        );\n\n        // Predict perturbed state using STM: x_pert \u2248 x_nominal + \u03a6\u00b7\u03b4x\u2080\n        let state_pert_predicted = &amp;new_state_nominal + &amp;new_phi * &amp;perturbation;\n\n        // Compute error between STM prediction and direct integration\n        let error = &amp;result_pert.state - &amp;state_pert_predicted;\n        let error_norm = error.norm();\n        let error_max = error.abs().max();\n\n        // Relative error compared to perturbation magnitude\n        let relative_error = error_norm / perturbation.norm();\n\n        println!(\n            \"{:4}  {:7.1}  {:12.6}  {:16.6}  {:13.6}\",\n            step + 1,\n            t + dt_used,\n            error_norm,\n            error_max,\n            relative_error\n        );\n\n        // Update for next step\n        state_nominal = new_state_nominal;\n        phi = new_phi;\n        state_pert = result_pert.state;\n        t += dt_used;\n    }\n}\n\n// Example output:\n// STM vs Direct Perturbation Comparison\n// ======================================================================\n// Initial orbit: 500.0 km altitude (circular)\n// Perturbation: 10.0 m in X direction\n// Propagating for 100 seconds in 10 steps\n//\n// Theory: For small \u03b4x\u2080, the perturbed state should satisfy:\n//         x_pert(t) \u2248 x_nominal(t) + \u03a6(t,t\u2080)\u00b7\u03b4x\u2080\n//\n// Step   Time(s)  ||Error||(m)  Max Component(m)  Relative Error\n// ----------------------------------------------------------------------\n//    1     10.0      0.000078          0.000053      0.000008\n//    2     20.0      0.000299          0.000211      0.000030\n//    3     30.0      0.000627          0.000462      0.000063\n//    4     40.0      0.001025          0.000791      0.000103\n//    5     50.0      0.001463          0.001176      0.000146\n//    6     60.0      0.001919          0.001600      0.000192\n//    7     70.0      0.002378          0.002057      0.000238\n//    8     80.0      0.002831          0.002539      0.000283\n//    9     90.0      0.003271          0.003040      0.000327\n//   10    100.0      0.003693          0.003556      0.000369\n</code></pre>"},{"location":"learn/integrators/variational_equations.html#see-also","title":"See Also","text":"<ul> <li>Fixed Step Integration - Constant time step methods</li> <li>Adaptive Step Integration - Automatic step size control</li> <li>Mathematics: Jacobian - Jacobian provider API reference</li> </ul>"},{"location":"learn/mathematics/index.html","title":"Mathematics","text":"<p>The mathematics module provides mathematical utilities for numerical computations in Brahe.</p>"},{"location":"learn/mathematics/index.html#module-contents","title":"Module Contents","text":"<p>The mathematics module currently only provides Jacobian computation:</p> <ul> <li>Jacobian Computation - Detailed guide on analytical and numerical Jacobian computation</li> </ul>"},{"location":"learn/mathematics/index.html#see-also","title":"See Also","text":"<ul> <li>Jacobian Computation - Detailed guide with examples</li> <li>Jacobian API Reference - Complete API documentation</li> <li>Numerical Integration - Integrators that use Jacobians for variational equations</li> </ul>"},{"location":"learn/mathematics/jacobian.html","title":"Jacobian Computation","text":"<p>Jacobian matrices are fundamental to many advanced astrodynamics computations. This guide explains how to compute and use Jacobians in Brahe for both analytical and numerical approaches.</p>"},{"location":"learn/mathematics/jacobian.html#understanding-jacobians","title":"Understanding Jacobians","text":"<p>A Jacobian matrix describes how a function's outputs change with respect to changes in its inputs. For a vector function \\(\\mathbf{f}: \\mathbb{R}^n \\rightarrow \\mathbb{R}^n\\) that maps state \\(\\mathbf{x}\\) to derivative \\(\\dot{\\mathbf{x}}\\):</p> \\[\\dot{\\mathbf{x}} = \\mathbf{f}(t, \\mathbf{x})\\] <p>The Jacobian matrix \\(\\mathbf{J}\\) is:</p> \\[J_{ij} = \\frac{\\partial f_i}{\\partial x_j}\\] <p>\\(\\mathbf{J}\\) is a real-valued \\(n \\times n\\) matrix (\\(J \\in \\mathbb{R}^{n \\times n}\\)). In astrodynamics, this describes how the rate of change of each state component depends on all other state components.</p> <p>In astrodynamics, Jacobians are crucial for:</p> <ul> <li>State Transition Matrices: Describing how small changes in initial conditions affect future states</li> <li>Orbit Determination: Propagating covariance matrices and computing measurement sensitivities</li> <li>Trajectory Optimization: Computing gradients for optimization algorithms</li> <li>Uncertainty Propagation: Tracking how uncertainties (covariances) evolve over time</li> </ul>"},{"location":"learn/mathematics/jacobian.html#analytical-vs-numerical-jacobians","title":"Analytical vs. Numerical Jacobians","text":"<p>Brahe supports both analytical and numerical Jacobian computation. Analytical Jacobians, represented by the <code>AnalyticJacobian</code> class require you to provide closed-form derivative expressions, while numerical Jacobians, provided by <code>NumericalJacobian</code> use finite difference methods to approximate derivatives automatically when given only the dynamics function.</p>"},{"location":"learn/mathematics/jacobian.html#analytical-jacobians","title":"Analytical Jacobians","text":"<p>When you know the closed-form derivatives \\(\\frac{\\partial f_i}{\\partial x_j}\\), analytical Jacobians provide the most accurate and efficient computation.</p>"},{"location":"learn/mathematics/jacobian.html#simple-harmonic-oscillator-example","title":"Simple Harmonic Oscillator Example","text":"<p>For a simple example, let's consider a 2D harmonic oscillator with state vector \\(\\mathbf{x} = \\begin{bmatrix} x \\\\ v \\end{bmatrix}\\) where \\(x\\) is position and \\(v\\) is velocity. The dynamics are:</p> \\[\\begin{bmatrix} \\dot{x} \\\\ \\dot{v} \\end{bmatrix} = \\begin{bmatrix} v \\\\ -x \\end{bmatrix}\\] <p>The analytical Jacobian is:</p> \\[\\mathbf{J} = \\begin{bmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{bmatrix}\\] <p>We can implement this analytical Jacobian in Brahe as follows:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\n# Define dynamics: Simple harmonic oscillator\n# State: [position, velocity]\n# Dynamics: dx/dt = v, dv/dt = -x\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\n\n# Define analytical Jacobian\n# J = [[0,  1],\n#      [-1, 0]]\ndef jacobian_func(t, state):\n    return np.array([[0.0, 1.0], [-1.0, 0.0]])\n\n\n# Create analytical Jacobian provider\njacobian = bh.AnalyticJacobian(jacobian_func)\n\n# Compute Jacobian at a specific state\nt = 0.0\nstate = np.array([1.0, 0.0])\nJ = jacobian.compute(t, state)\n\nprint(\"Analytical Jacobian:\")\nprint(J)\n# Expected output:\n# [[ 0.  1.]\n#  [-1.  0.]]\n\n# Verify it's time-invariant for this system\nt2 = 10.0\nstate2 = np.array([0.5, 0.866])\nJ2 = jacobian.compute(t2, state2)\n\nprint(\"\\nJacobian at different time and state:\")\nprint(J2)\n# Should be identical for linear system\n\nprint(\"\\nJacobians are equal:\", np.allclose(J, J2))\n# Output: True\n</code></pre> <pre><code>use brahe::math::jacobian::{DAnalyticJacobian, DJacobianProvider};\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Define analytical Jacobian function\n    // For simple harmonic oscillator: J = [[0, 1], [-1, 0]]\n    let jacobian_fn = |_t: f64, _state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DMatrix&lt;f64&gt; {\n        DMatrix::from_row_slice(2, 2, &amp;[\n            0.0,  1.0,\n           -1.0,  0.0\n        ])\n    };\n\n    // Create analytical Jacobian provider\n    let jacobian = DAnalyticJacobian::new(Box::new(jacobian_fn));\n\n    // Compute Jacobian at a specific state\n    let t = 0.0;\n    let state = DVector::from_vec(vec![1.0, 0.0]);\n    let jac = jacobian.compute(t, &amp;state, None);\n\n    println!(\"Analytical Jacobian:\");\n    println!(\"{}\", jac);\n    // Expected output:\n    // [[ 0.  1.]\n    //  [-1.  0.]]\n\n    // Verify it's time-invariant for this system\n    let t2 = 10.0;\n    let state2 = DVector::from_vec(vec![0.5, 0.866]);\n    let jac2 = jacobian.compute(t2, &amp;state2, None);\n\n    println!(\"\\nJacobian at different time and state:\");\n    println!(\"{}\", jac2);\n\n    // Check if matrices are equal\n    let are_equal = (jac - jac2).norm() &lt; 1e-10;\n    println!(\"\\nJacobians are equal: {}\", are_equal);\n    // Output: true\n}\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#when-to-use-analytical-jacobians","title":"When to Use Analytical Jacobians","text":"<ul> <li>Derivatives are simple to compute (e.g., linear systems, Keplerian dynamics)</li> <li>Maximum accuracy is required (no finite difference errors)</li> <li>Jacobian will be evaluated many times (performance critical)</li> <li>Working with well-studied systems (two-body problem, etc.)</li> </ul>"},{"location":"learn/mathematics/jacobian.html#numerical-jacobians","title":"Numerical Jacobians","text":"<p>Numerical Jacobians use finite differences to approximate derivatives automatically. This is essential when analytical derivatives are complex or unknown. Brahe supports three difference methods: forward, central, and backward differences.</p>"},{"location":"learn/mathematics/jacobian.html#forward-difference","title":"Forward Difference","text":"<p>The forward difference method approximates the derivative by perturbing the input state positively along each dimension \\(e_j\\) and measuring the change in output, as follows:</p> \\[ J_{ij} \\approx \\frac{f_i(\\mathbf{x} + h \\cdot \\mathbf{e}_j) - f_i(\\mathbf{x})}{h} \\] <p>Forward differences have first-order accuracy with an error on the order of \\(O(h)\\), where \\(h\\) is the perturbation size. This method requires \\(n + 1\\) function evaluations for an \\(n\\)-dimensional state vector.</p>"},{"location":"learn/mathematics/jacobian.html#central-difference","title":"Central Difference","text":"<p>The central difference method improves accuracy by perturbing the input state both positively and negatively along each dimension \\(e_j\\):</p> \\[ J_{ij} \\approx \\frac{f_i(\\mathbf{x} + h \\cdot \\mathbf{e}_j) - f_i(\\mathbf{x} - h \\cdot \\mathbf{e}_j)}{2h} \\] <p>Central differences have second-order accuracy with an error on the order of \\(O(h^2)\\). This method requires \\(2n\\) function evaluations for an \\(n\\)-dimensional state vector.</p> <p>Recommendation</p> <p>Use central differences unless computational cost is prohibitive. The ~2x increase in function evaluations is usually worth the improved accuracy.</p>"},{"location":"learn/mathematics/jacobian.html#backward-difference","title":"Backward Difference","text":"<p>Finally, the backward difference method approximates the derivative by perturbing the input state negatively along each dimension:</p> \\[ J_{ij} \\approx \\frac{f_i(\\mathbf{x}) - f_i(\\mathbf{x} - h \\cdot \\mathbf{e}_j)}{h} \\] <p>Similar to forward differences, backward differences have first-order accuracy with an error on the order of \\(O(h)\\) and require \\(n + 1\\) function evaluations. They are less commonly used but implemented for completeness.</p>"},{"location":"learn/mathematics/jacobian.html#basic-numerical-jacobian","title":"Basic Numerical Jacobian","text":"<p>We can implement the same 2D harmonic oscillator example using a numerical Jacobian with central differences:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\n# Define dynamics: Simple harmonic oscillator\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\n\n# Create numerical Jacobian with default settings (central differences)\njacobian = bh.NumericalJacobian(dynamics)\n\n# Compute Jacobian at a specific state\nt = 0.0\nstate = np.array([1.0, 0.0])\nJ_numerical = jacobian.compute(t, state)\n\nprint(\"Numerical Jacobian (central differences):\")\nprint(J_numerical)\n# Expected output (should be very close to analytical):\n# [[ 0.  1.]\n#  [-1.  0.]]\n\n# Compare with analytical solution\nJ_analytical = np.array([[0.0, 1.0], [-1.0, 0.0]])\n\nerror = np.linalg.norm(J_numerical - J_analytical)\nprint(f\"\\nError vs analytical: {error:.2e}\")\n# Output: ~1e-8 (machine precision)\n\n# Verify accuracy at different state\nstate2 = np.array([0.5, 0.866])\nJ_numerical2 = jacobian.compute(t, state2)\n\nprint(\"\\nNumerical Jacobian at different state:\")\nprint(J_numerical2)\n\nerror2 = np.linalg.norm(J_numerical2 - J_analytical)\nprint(f\"Error vs analytical: {error2:.2e}\")\n# Output: ~1e-8 (consistent accuracy)\n</code></pre> <pre><code>use brahe::math::jacobian::{DNumericalJacobian, DJacobianProvider};\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Define dynamics function\n    let dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        DVector::from_vec(vec![state[1], -state[0]])\n    };\n\n    // Create numerical Jacobian with default settings (central differences)\n    let jacobian = DNumericalJacobian::central(Box::new(dynamics));\n\n    // Compute Jacobian at a specific state\n    let t = 0.0;\n    let state = DVector::from_vec(vec![1.0, 0.0]);\n    let jac_numerical = jacobian.compute(t, &amp;state, None);\n\n    println!(\"Numerical Jacobian (central differences):\");\n    println!(\"{}\", jac_numerical);\n    // Expected output (should be very close to analytical):\n    // [[ 0.  1.]\n    //  [-1.  0.]]\n\n    // Compare with analytical solution\n    let jac_analytical = DMatrix::from_row_slice(2, 2, &amp;[\n        0.0,  1.0,\n       -1.0,  0.0\n    ]);\n\n    let error = (jac_numerical.clone() - jac_analytical.clone()).norm();\n    println!(\"\\nError vs analytical: {:.2e}\", error);\n    // Output: ~1e-8 (machine precision)\n\n    // Verify accuracy at different state\n    let state2 = DVector::from_vec(vec![0.5, 0.866]);\n    let jac_numerical2 = jacobian.compute(t, &amp;state2, None);\n\n    println!(\"\\nNumerical Jacobian at different state:\");\n    println!(\"{}\", jac_numerical2);\n\n    let error2 = (jac_numerical2 - jac_analytical).norm();\n    println!(\"Error vs analytical: {:.2e}\", error2);\n    // Output: ~1e-8 (consistent accuracy)\n}\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#comparing-methods","title":"Comparing Methods","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\n# Define two-body gravity dynamics: state = [x, y, z, vx, vy, vz]\ndef gravity_dynamics(t, state):\n    r = state[0:3]  # Position\n    v = state[3:6]  # Velocity\n    r_norm = np.linalg.norm(r)\n\n    # Acceleration from two-body gravity: a = -mu * r / |r|^3\n    a = -bh.GM_EARTH * r / r_norm**3\n\n    return np.concatenate([v, a])\n\n\n# Analytical Jacobian for two-body gravity\ndef analytical_jacobian(state):\n    r = state[0:3]\n    r_norm = np.linalg.norm(r)\n    r3 = r_norm**3\n    r5 = r_norm**5\n\n    # Top-left: zeros (3x3)\n    # Top-right: identity (3x3)\n    # Bottom-left: gravity gradient (3x3)\n    # Bottom-right: zeros (3x3)\n    J = np.zeros((6, 6))\n    J[0:3, 3:6] = np.eye(3)  # Velocity contribution to position derivative\n\n    # Gravity gradient term - Motenbruck Eqn 7.56\n    J[3:6, 0:3] = -bh.GM_EARTH * (np.eye(3) / r3 - 3 * np.outer(r, r) / r5)\n\n    return J\n\n\n# Create numerical Jacobians with different methods\njacobian_forward = bh.NumericalJacobian.forward(gravity_dynamics)\njacobian_central = bh.NumericalJacobian.central(gravity_dynamics)\njacobian_backward = bh.NumericalJacobian.backward(gravity_dynamics)\n\n# Test state: Low Earth Orbit position and velocity\nt = 0.0\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7500.0, 0.0])  # Circular orbit\n\n# Compute analytical Jacobian\nJ_analytical = analytical_jacobian(state)\n\n# Compute Jacobians with each method\nJ_forward = jacobian_forward.compute(t, state)\nJ_central = jacobian_central.compute(t, state)\nJ_backward = jacobian_backward.compute(t, state)\n\nprint(\"Forward Difference Jacobian:\")\nfor row in J_forward:\n    print(\"[\" + \"  \".join(f\"{val: .2e}\" for val in row) + \"]\")\nerror_forward = np.linalg.norm(J_forward - J_analytical)\nprint(f\"Error: {error_forward:.2e}\\n\")\n\nprint(\"Central Difference Jacobian:\")\nfor row in J_central:\n    print(\"[\" + \"  \".join(f\"{val: .2e}\" for val in row) + \"]\")\nerror_central = np.linalg.norm(J_central - J_analytical)\nprint(f\"Error: {error_central:.2e}\\n\")\n\nprint(\"Backward Difference Jacobian:\")\nfor row in J_backward:\n    print(\"[\" + \"  \".join(f\"{val: .2e}\" for val in row) + \"]\")\nerror_backward = np.linalg.norm(J_backward - J_analytical)\nprint(f\"Error: {error_backward:.2e}\\n\")\n\n# Summary\nprint(\"Accuracy Comparison:\")\nprint(f\"  Forward:  {error_forward:.2e} (O(h))\")\nprint(f\"  Central:  {error_central:.2e} (O(h\u00b2))\")\nprint(f\"  Backward: {error_backward:.2e} (O(h))\")\nprint(f\"\\nCentral is {error_forward / error_central:.1f}x more accurate than forward\")\nprint(f\"Central is {error_backward / error_central:.1f}x more accurate than backward\")\n\n# Expected output:\n# Forward Difference Jacobian:\n# [ 0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00]\n# [ 2.45e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00]\n# Error: 5.54e-14\n\n# Central Difference Jacobian:\n# [ 0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00]\n# [ 2.45e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00]\n# Error: 5.27e-15\n\n# Backward Difference Jacobian:\n# [ 0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00   1.00e+00]\n# [ 2.45e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00   0.00e+00]\n# [ 0.00e+00   0.00e+00  -1.22e-06   0.00e+00   0.00e+00   0.00e+00]\n# Error: 6.59e-14\n\n# Accuracy Comparison:\n#   Forward:  5.54e-14 (O(h))\n#   Central:  5.27e-15 (O(h\u00b2))\n#   Backward: 6.59e-14 (O(h))\n\n# Central is 10.5x more accurate than forward\n# Central is 12.5x more accurate than backward\n</code></pre> <pre><code>use brahe::math::jacobian::{DNumericalJacobian, DJacobianProvider};\nuse brahe::constants::GM_EARTH;\nuse brahe::R_EARTH;\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Define two-body gravity dynamics: state = [x, y, z, vx, vy, vz]\n    let gravity_dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let r = state.fixed_rows::&lt;3&gt;(0);  // Position\n        let v = state.fixed_rows::&lt;3&gt;(3);  // Velocity\n        let r_norm = r.norm();\n\n        // Acceleration from two-body gravity: a = -mu * r / |r|^3\n        let a = -GM_EARTH * r / r_norm.powi(3);\n\n        DVector::from_iterator(6, v.iter().chain(a.iter()).copied())\n    };\n\n    // Analytical Jacobian for two-body gravity\n    let analytical_jacobian = |state: &amp;DVector&lt;f64&gt;| -&gt; DMatrix&lt;f64&gt; {\n        let r = state.fixed_rows::&lt;3&gt;(0);\n        let r_norm = r.norm();\n        let r3 = r_norm.powi(3);\n        let r5 = r_norm.powi(5);\n\n        // Top-left: zeros (3x3)\n        // Top-right: identity (3x3)\n        // Bottom-left: gravity gradient (3x3)\n        // Bottom-right: zeros (3x3)\n        let mut jac = DMatrix::zeros(6, 6);\n\n        // Velocity contribution to position derivative\n        for i in 0..3 {\n            jac[(i, 3 + i)] = 1.0;\n        }\n\n        // Gravity gradient term - Montenbruck Eqn 7.56\n        let r_vec = r.into_owned();\n        let gradient = -GM_EARTH * (DMatrix::identity(3, 3) / r3 - 3.0 * r_vec * r_vec.transpose() / r5);\n        jac.view_mut((3, 0), (3, 3)).copy_from(&amp;gradient);\n\n        jac\n    };\n\n    // Create numerical Jacobians with different methods\n    let jacobian_forward = DNumericalJacobian::forward(Box::new(gravity_dynamics));\n    let jacobian_central = DNumericalJacobian::central(Box::new(gravity_dynamics));\n    let jacobian_backward = DNumericalJacobian::backward(Box::new(gravity_dynamics));\n\n    // Test state: Low Earth Orbit position and velocity\n    let t = 0.0;\n    let state = DVector::from_vec(vec![\n        R_EARTH + 500e3,  // x position (m)\n        0.0,               // y position\n        0.0,               // z position\n        0.0,               // x velocity\n        7500.0,            // y velocity (m/s)\n        0.0                // z velocity\n    ]);\n\n    // Compute analytical Jacobian\n    let j_analytical = analytical_jacobian(&amp;state);\n\n    // Compute Jacobians with each method\n    let j_forward = jacobian_forward.compute(t, &amp;state, None);\n    let j_central = jacobian_central.compute(t, &amp;state, None);\n    let j_backward = jacobian_backward.compute(t, &amp;state, None);\n\n    println!(\"Forward Difference Jacobian:\");\n    for i in 0..6 {\n        print!(\"[\");\n        for j in 0..6 {\n            print!(\"{:&gt;10.2e}\", j_forward[(i, j)]);\n            if j &lt; 5 { print!(\"  \"); }\n        }\n        println!(\"]\");\n    }\n    let error_forward = (j_forward.clone() - j_analytical.clone()).norm();\n    println!(\"Error: {:.2e}\\n\", error_forward);\n\n    println!(\"Central Difference Jacobian:\");\n    for i in 0..6 {\n        print!(\"[\");\n        for j in 0..6 {\n            print!(\"{:&gt;10.2e}\", j_central[(i, j)]);\n            if j &lt; 5 { print!(\"  \"); }\n        }\n        println!(\"]\");\n    }\n    let error_central = (j_central.clone() - j_analytical.clone()).norm();\n    println!(\"Error: {:.2e}\\n\", error_central);\n\n    println!(\"Backward Difference Jacobian:\");\n    for i in 0..6 {\n        print!(\"[\");\n        for j in 0..6 {\n            print!(\"{:&gt;10.2e}\", j_backward[(i, j)]);\n            if j &lt; 5 { print!(\"  \"); }\n        }\n        println!(\"]\");\n    }\n    let error_backward = (j_backward - j_analytical).norm();\n    println!(\"Error: {:.2e}\\n\", error_backward);\n\n    // Summary\n    println!(\"Accuracy Comparison:\");\n    println!(\"  Forward:  {:.2e} (O(h))\", error_forward);\n    println!(\"  Central:  {:.2e} (O(h\u00b2))\", error_central);\n    println!(\"  Backward: {:.2e} (O(h))\", error_backward);\n    println!(\"\\nCentral is {:.1}x more accurate than forward\", error_forward / error_central);\n    println!(\"Central is {:.1}x more accurate than backward\", error_backward / error_central);\n}\n\n// Expected output:\n// Forward Difference Jacobian:\n// [    0.00e0      0.00e0      0.00e0      1.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      1.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      0.00e0      1.00e0]\n// [   2.45e-6      0.00e0      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0]\n// Error: 5.54e-14\n\n// Central Difference Jacobian:\n// [    0.00e0      0.00e0      0.00e0      1.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      1.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      0.00e0      1.00e0]\n// [   2.45e-6      0.00e0      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0]\n// Error: 3.40e-15\n\n// Backward Difference Jacobian:\n// [    0.00e0      0.00e0      0.00e0      1.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      1.00e0      0.00e0]\n// [    0.00e0      0.00e0      0.00e0      0.00e0      0.00e0      1.00e0]\n// [   2.45e-6      0.00e0      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0      0.00e0]\n// [    0.00e0      0.00e0    -1.22e-6      0.00e0      0.00e0      0.00e0]\n// Error: 4.86e-14\n\n// Accuracy Comparison:\n//   Forward:  5.54e-14 (O(h))\n//   Central:  3.40e-15 (O(h\u00b2))\n//   Backward: 4.86e-14 (O(h))\n\n// Central is 16.3x more accurate than forward\n// Central is 14.3x more accurate than backward\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#perturbation-strategies","title":"Perturbation Strategies","text":"<p>The choice of perturbation size \\(h\\) significantly affects numerical Jacobian accuracy. Too large does not provide an accurate approximation of the local derivative; too small causes roundoff errors. Brahe provides several perturbation strategies to provide options for choosing \\(h\\). However it is ultimately up to the user to select the best strategy for their specific application.</p>"},{"location":"learn/mathematics/jacobian.html#fixed-perturbation","title":"Fixed Perturbation","text":"<p>One simple approach is to use a fixed perturbation size for all state components. This generally works well when all state components have similar magnitudes.</p> \\[ h = \\text{constant} \\] <pre><code>jacobian = bh.NumericalJacobian.central(dynamics) \\\\\n    .with_fixed_offset(1e-6)\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#percentage-perturbation","title":"Percentage Perturbation","text":"<p>Another approach is to use a percentage of each state component's magnitude as the perturbation size.</p> \\[ h_j = \\text{percentage} \\times |x_j| \\] <pre><code>jacobian = bh.NumericalJacobian.central(dynamics) \\\\\n    .with_percentage(1e-5)  # 0.001% perturbation\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#adaptive-perturbation","title":"Adaptive Perturbation","text":"<p>The adaptive perturbation strategy combines both absolute and relative scaling to choose an appropriate perturbation size for each state component. It multiples the component scale factor \\(s\\) by \\(\\sqrt(\\epsilon)\\) where \\(\\espilon\\) is machine epsilon for double precision (\\(\\approx 2.22e-16\\)) and enforces a minimum value \\(h_{min}\\) to avoid excessively small perturbations.</p> \\[ h_j = s \\times \\sqrt(\\epsilon) \\times \\max(|x_j|, h_{min}) \\] <pre><code>jacobian = bh.NumericalJacobian.central(dynamics) \\\\\n    .with_adaptive(scale_factor=1e-8, min_value=1e-6)\n</code></pre> <p>Recommendation</p> <p>Adaptive perturbation is will generally best choice for most applications, as it balances accuracy and robustness across a wide range of state magnitudes, but percentage-based perturbations can also work well without much tuning.</p>"},{"location":"learn/mathematics/jacobian.html#comparing-strategies","title":"Comparing Strategies","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n\n# Define dynamics with mixed-scale state\n# State: [large_position (km), small_velocity (km/s)]\ndef dynamics(t, state):\n    # Simple dynamics with different scales\n    x, v = state\n    return np.array([v, -x * 1e-6])  # Different scales\n\n\n# Analytical Jacobian\ndef analytical_jacobian(t, state):\n    return np.array([[0.0, 1.0], [-1e-6, 0.0]])\n\n\n# Test state with very different magnitudes\nstate = np.array([7000.0, 7.5])  # Position in km, velocity in km/s\nt = 0.0\n\nJ_analytical = analytical_jacobian(t, state)\n\nprint(\"Testing perturbation strategies on mixed-scale state:\")\nprint(f\"State: position={state[0]} km, velocity={state[1]} km/s\\n\")\n\n# Strategy 1: Fixed perturbation\nprint(\"1. Fixed Perturbation (h = 1e-6)\")\njacobian_fixed = bh.NumericalJacobian.central(dynamics).with_fixed_offset(1e-6)\nJ_fixed = jacobian_fixed.compute(t, state)\nerror_fixed = np.linalg.norm(J_fixed - J_analytical)\nprint(f\"   Error: {error_fixed:.2e}\\n\")\n\n# Strategy 2: Percentage perturbation\nprint(\"2. Percentage Perturbation (0.001%)\")\njacobian_pct = bh.NumericalJacobian.central(dynamics).with_percentage(1e-5)\nJ_pct = jacobian_pct.compute(t, state)\nerror_pct = np.linalg.norm(J_pct - J_analytical)\nprint(f\"   Error: {error_pct:.2e}\\n\")\n\n# Strategy 3: Adaptive perturbation (recommended)\nprint(\"3. Adaptive Perturbation (scale=1.0, min=1.0)\")\njacobian_adaptive = bh.NumericalJacobian.central(dynamics).with_adaptive(\n    scale_factor=1.0, min_value=1.0\n)\nJ_adaptive = jacobian_adaptive.compute(t, state)\nerror_adaptive = np.linalg.norm(J_adaptive - J_analytical)\nprint(f\"   Error: {error_adaptive:.2e}\\n\")\n\n# Summary\nprint(\"Strategy Comparison:\")\nprint(f\"  Fixed:      {error_fixed:.2e}\")\nprint(f\"  Percentage: {error_pct:.2e}\")\nprint(f\"  Adaptive:   {error_adaptive:.2e}\")\nprint(\"\\nBest strategy: Adaptive (handles mixed scales robustly)\")\n\n# Test with state component near zero\nprint(\"\\n\" + \"=\" * 60)\nprint(\"Testing with component near zero:\")\nstate_zero = np.array([7000.0, 1e-9])  # Very small velocity\nprint(f\"State: position={state_zero[0]} km, velocity={state_zero[1]} km/s\\n\")\n\nJ_analytical_zero = analytical_jacobian(t, state_zero)\n\n# Percentage fails when component is near zero\ntry:\n    J_pct_zero = jacobian_pct.compute(t, state_zero)\n    error_pct_zero = np.linalg.norm(J_pct_zero - J_analytical_zero)\n    print(f\"Percentage: Error = {error_pct_zero:.2e}\")\nexcept ZeroDivisionError:\n    print(\"Percentage: FAILED (division by near-zero)\")\n\n# Adaptive handles it gracefully\nJ_adaptive_zero = jacobian_adaptive.compute(t, state_zero)\nerror_adaptive_zero = np.linalg.norm(J_adaptive_zero - J_analytical_zero)\nprint(f\"Adaptive:   Error = {error_adaptive_zero:.2e}\")\n\nprint(\"\\nConclusion: Adaptive perturbation is most robust\")\n</code></pre> <pre><code>use brahe::math::jacobian::{DNumericalJacobian, DJacobianProvider};\nuse nalgebra::{DMatrix, DVector};\n\nfn main() {\n    // Define dynamics with mixed-scale state\n    let dynamics = |_t: f64, state: &amp;DVector&lt;f64&gt;, _params: Option&lt;&amp;DVector&lt;f64&gt;&gt;| -&gt; DVector&lt;f64&gt; {\n        let x = state[0];\n        let v = state[1];\n        DVector::from_vec(vec![v, -x * 1e-6])\n    };\n\n    // Analytical Jacobian\n    let analytical_jacobian = || -&gt; DMatrix&lt;f64&gt; {\n        DMatrix::from_row_slice(2, 2, &amp;[\n            0.0, 1.0,\n            -1e-6, 0.0\n        ])\n    };\n\n    // Test state with very different magnitudes\n    let state = DVector::from_vec(vec![7000.0, 7.5]); // Position in km, velocity in km/s\n    let t = 0.0;\n\n    let j_analytical = analytical_jacobian();\n\n    println!(\"Testing perturbation strategies on mixed-scale state:\");\n    println!(\"State: position={} km, velocity={} km/s\\n\", state[0], state[1]);\n\n    // Strategy 1: Fixed perturbation\n    println!(\"1. Fixed Perturbation (h = 1e-6)\");\n    let jacobian_fixed = DNumericalJacobian::central(Box::new(dynamics))\n        .with_fixed_offset(1e-6);\n    let j_fixed = jacobian_fixed.compute(t, &amp;state, None);\n    let error_fixed = (j_fixed - j_analytical.clone()).norm();\n    println!(\"   Error: {:.2e}\\n\", error_fixed);\n\n    // Strategy 2: Percentage perturbation\n    println!(\"2. Percentage Perturbation (0.001%)\");\n    let jacobian_pct = DNumericalJacobian::central(Box::new(dynamics))\n        .with_percentage(1e-5);\n    let j_pct = jacobian_pct.compute(t, &amp;state, None);\n    let error_pct = (j_pct - j_analytical.clone()).norm();\n    println!(\"   Error: {:.2e}\\n\", error_pct);\n\n    // Strategy 3: Adaptive perturbation (recommended)\n    println!(\"3. Adaptive Perturbation (scale=1.0, min=1.0)\");\n    let jacobian_adaptive = DNumericalJacobian::central(Box::new(dynamics))\n        .with_adaptive(1.0, 1.0);\n    let j_adaptive = jacobian_adaptive.compute(t, &amp;state, None);\n    let error_adaptive = (j_adaptive - j_analytical.clone()).norm();\n    println!(\"   Error: {:.2e}\\n\", error_adaptive);\n\n    // Summary\n    println!(\"Strategy Comparison:\");\n    println!(\"  Fixed:      {:.2e}\", error_fixed);\n    println!(\"  Percentage: {:.2e}\", error_pct);\n    println!(\"  Adaptive:   {:.2e}\", error_adaptive);\n    println!(\"\\nBest strategy: Adaptive (handles mixed scales robustly)\");\n\n    // Test with state component near zero\n    println!(\"\\n{}\", \"=\".repeat(60));\n    println!(\"Testing with component near zero:\");\n    let state_zero = DVector::from_vec(vec![7000.0, 1e-9]); // Very small velocity\n    println!(\"State: position={} km, velocity={} km/s\\n\", state_zero[0], state_zero[1]);\n\n    let j_analytical_zero = analytical_jacobian();\n\n    // Percentage can be problematic when component is near zero\n    let j_pct_zero = jacobian_pct.compute(t, &amp;state_zero, None);\n    let error_pct_zero = (j_pct_zero - j_analytical_zero.clone()).norm();\n    println!(\"Percentage: Error = {:.2e}\", error_pct_zero);\n\n    // Adaptive handles it gracefully\n    let j_adaptive_zero = jacobian_adaptive.compute(t, &amp;state_zero, None);\n    let error_adaptive_zero = (j_adaptive_zero - j_analytical_zero).norm();\n    println!(\"Adaptive:   Error = {:.2e}\", error_adaptive_zero);\n\n    println!(\"\\nConclusion: Adaptive perturbation is most robust\");\n}\n</code></pre>"},{"location":"learn/mathematics/jacobian.html#using-with-integrators","title":"Using with Integrators","text":"<p>Jacobians are primarily used with numerical integrators for variational equation propagation see the Numerical Integration guide for more details.</p>"},{"location":"learn/mathematics/jacobian.html#see-also","title":"See Also","text":"<ul> <li>Mathematics Module - Mathematics module overview</li> <li>Jacobian API Reference - Complete API documentation</li> <li>Numerical Integration - Using Jacobians with integrators</li> </ul>"},{"location":"learn/orbit_propagation/index.html","title":"Orbit Propagation","text":"<p>Orbit propagation is the process of computing a satellite's trajectory over time from an initial state. Brahe's propagation system is built on a set of Rust traits that define common functionality. This design allows for common usage patterns making it easy to switch between different propagator implementations.</p> <p>All propagators in Brahe implement the <code>OrbitPropagator</code> trait, which provides methods for stepping through time, managing trajectory history, and accessing the current state. All propagators store their state history in an <code>OrbitTrajectory</code>, which implements the <code>Trajectory</code> and <code>Interpolatable</code> traits for state storage and interpolation. See the Trajectory documentation for more details on these traits and the methods they provide.</p> <p>There is also the <code>StateProvider</code> trait, which extends propagators with the ability to compute states directly at arbitrary epochs. How this is implemented depends on the specific propagator. Analytic propagators like <code>KeplerianPropagator</code> and <code>SGPPropagator</code> can compute states at any time using closed-form solutions, while numerical propagators typically require time-stepping to the desired epoch, then interpolating the result.</p> <p>The <code>IdentifiableStateProvider</code> trait combines <code>StateProvider</code> with <code>Identifiable</code>, enabling identification of Propagators by name, ID, or UUID. This is useful for tracking multiple satellites in applications like ground station access computation or conjunction analysis.</p>"},{"location":"learn/orbit_propagation/index.html#orbitpropagator-trait","title":"OrbitPropagator Trait","text":"<p>The <code>OrbitPropagator</code> trait is the foundation for all propagator implementations. It defines the core interface for stepping through time, managing state, and controlling trajectory accumulation.</p> <p>Stepping Operations:</p> <ul> <li><code>step()</code> - Advance by the default step size</li> <li><code>step_by(step_size)</code> - Advance by a specified duration (seconds)</li> <li><code>step_past(target_epoch)</code> - Step until the given Epoch is passed</li> <li><code>propagate_steps(n)</code> - Take N steps of default step size</li> <li><code>propagate_to(target_epoch)</code> - Propagate precisely to a target epoch</li> </ul> <p>State Access:</p> <ul> <li><code>current_epoch()</code> - Get the most recent propagated epoch</li> <li><code>current_state()</code> - Get the most recent propagated state</li> <li><code>initial_epoch()</code> - Get the initial epoch</li> <li><code>initial_state()</code> - Get the initial state</li> </ul> <p>Configuration:</p> <ul> <li><code>step_size()</code> - Get the default step size (seconds)</li> <li><code>set_step_size(step_size)</code> - Set the default step size (seconds)</li> <li><code>reset()</code> - Reset propagator to initial conditions</li> <li><code>set_initial_conditions(epoch, state, frame, representation, angle_format)</code> - Update initial conditions</li> </ul> <p>Trajectory Management:</p> <ul> <li><code>propagate_trajectory(epochs)</code> - Propagate to multiple epochs with <code>propagate_to()</code> calls for each provided epoch</li> <li><code>set_eviction_policy_max_size(n)</code> - Keep only N most recent states</li> <li><code>set_eviction_policy_max_age(duration)</code> - Keep only states within time window (seconds)</li> </ul>"},{"location":"learn/orbit_propagation/index.html#stateprovider-trait","title":"StateProvider Trait","text":"<p>The <code>StateProvider</code> trait extends propagators with methods to get the state at arbitrary epochs. For analytic propagators, this is done using closed-form solutions which immediately compute the state without time-stepping. Numerical propagators typically step to the desired epoch and interpolate the result. This trait provides both single-epoch and multi-epoch (batch) query methods.</p> <p>Single Epoch Queries:</p> <ul> <li><code>state(epoch)</code> - Get state in propagator's native format</li> <li><code>state_eci(epoch)</code> - Get Cartesian state in ECI frame</li> <li><code>state_ecef(epoch)</code> - Get Cartesian state in ECEF frame</li> <li><code>state_koe_osc(epoch, angle_format)</code> - Get Keplerian elements</li> </ul> <p>Multi-Epoch Queries (Batch Operations):</p> <ul> <li><code>states(epochs)</code> - Get states at multiple epochs in native format</li> <li><code>states_eci(epochs)</code> - Get ECI Cartesian states at multiple epochs</li> <li><code>states_ecef(epochs)</code> - Get ECEF Cartesian states at multiple epochs</li> <li><code>states_koe(epochs, angle_format)</code> - Get Keplerian elements at multiple epochs</li> </ul>"},{"location":"learn/orbit_propagation/index.html#identifiablestateprovider-trait","title":"IdentifiableStateProvider Trait","text":"<p>The <code>IdentifiableStateProvider</code> trait combines <code>StateProvider</code> with <code>Identifiable</code>, identifying propagator objects by name, ID, or UUID. This trait inherits all methods from: - <code>StateProvider</code>: All state query methods - <code>Identifiable</code>: <code>with_name()</code>, <code>with_id()</code>, <code>with_uuid()</code>, <code>get_name()</code>, <code>get_id()</code>, <code>get_uuid()</code></p>"},{"location":"learn/orbit_propagation/index.html#choosing-a-propagator","title":"Choosing a Propagator","text":"<p>Brahe currently provides two propagator implementations: - <code>KeplerianPropagator</code>: An analytic two-body propagator using Keplerian orbital elements. Suitable for high-level mission design and long-term propagation where perturbations are negligible. - <code>SGPPropagator</code>: An analytic propagator based on the SGP4/SDP4 models using TLE data. Suitable for tracking Earth-orbiting satellites with moderate accuracy.</p>"},{"location":"learn/orbit_propagation/index.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Propagation - Analytical two-body propagator</li> <li>SGP Propagation - TLE-based SGP4/SDP4 propagator</li> <li>Trajectories - Trajectory storage and management</li> <li>Frame Transformations - ECI/ECEF conversions</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"learn/orbit_propagation/keplerian_propagation.html","title":"Keplerian Propagation","text":"<p>The <code>KeplerianPropagator</code> provides fast, analytical two-body orbital propagation using Kepler's equations. It assumes only gravitational attraction from a central body (Earth) with no perturbations, making it ideal for rapid trajectory generation, high-altitude orbits, or when perturbations are negligible.</p> <p>For complete API documentation, see the KeplerianPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#initialization","title":"Initialization","text":"<p>The <code>KeplerianPropagator</code> can be initialized from several state representations.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-keplerian-elements","title":"From Keplerian Elements","text":"<p>The most direct initialization method uses classical Keplerian orbital elements.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define Keplerian elements [a, e, i, \u03a9, \u03c9, M]\nelements = np.array(\n    [\n        bh.R_EARTH + 500e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (degrees)\n        15.0,  # RAAN (degrees)\n        30.0,  # Argument of perigee (degrees)\n        45.0,  # Mean anomaly (degrees)\n    ]\n)\n\n# Create propagator with 60-second step size\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\nprint(f\"Orbital period: {bh.orbital_period(elements[0]):.1f} seconds\")\n# Orbital period: 5677.0 seconds\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define Keplerian elements [a, e, i, \u03a9, \u03c9, M]\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (degrees)\n        15.0,                 // RAAN (degrees)\n        30.0,                 // Argument of perigee (degrees)\n        45.0                  // Mean anomaly (degrees)\n    );\n\n    // Create propagator with 60-second step size\n    let _prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    println!(\"Orbital period: {:.1} seconds\", bh::orbital_period(elements[0]));\n    // Orbital period: 5677.0 seconds\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-eci-cartesian-state","title":"From ECI Cartesian State","text":"<p>Initialize from position and velocity vectors in the Earth-Centered Inertial (ECI) frame.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define Cartesian state in ECI frame [x, y, z, vx, vy, vz]\n# Convert from Keplerian elements for this example\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate_eci = bh.state_koe_to_eci(elements, bh.AngleFormat.DEGREES)\n\n# Create propagator from ECI state\nprop = bh.KeplerianPropagator.from_eci(epoch, state_eci, 60.0)\n\nprint(f\"Initial position magnitude: {np.linalg.norm(state_eci[:3]) / 1e3:.1f} km\")\n# Initial position magnitude: 6873.3 km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define Cartesian state in ECI frame [x, y, z, vx, vy, vz]\n    // Convert from Keplerian elements for this example\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let state_eci = bh::state_koe_to_eci(elements, bh::AngleFormat::Degrees);\n\n    // Create propagator from ECI state\n    let _prop = bh::KeplerianPropagator::from_eci(epoch, state_eci, 60.0);\n\n    println!(\"Initial position magnitude: {:.1} km\",\n             state_eci.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // Initial position magnitude: 6873.3 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#from-ecef-cartesian-state","title":"From ECEF Cartesian State","text":"<p>Initialize from position and velocity vectors in the Earth-Centered Earth-Fixed (ECEF) frame. The propagator will automatically convert to ECI internally.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for ECEF \u2194 ECI transformations\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get state in ECI, then convert to ECEF for demonstration\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate_eci = bh.state_koe_to_eci(elements, bh.AngleFormat.DEGREES)\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\n\n# Create propagator from ECEF state\nprop = bh.KeplerianPropagator.from_ecef(epoch, state_ecef, 60.0)\n\nprint(f\"ECEF position magnitude: {np.linalg.norm(state_ecef[:3]) / 1e3:.1f} km\")\n# ECEF position magnitude: 6873.3 km\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for ECEF \u2194 ECI transformations\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Get state in ECI, then convert to ECEF for demonstration\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let state_eci = bh::state_koe_to_eci(elements, bh::AngleFormat::Degrees);\n    let state_ecef = bh::state_eci_to_ecef(epoch, state_eci);\n\n    // Create propagator from ECEF state\n    let _prop = bh::KeplerianPropagator::from_ecef(epoch, state_ecef, 60.0);\n\n    println!(\"ECEF position magnitude: {:.1} km\",\n             state_ecef.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECEF position magnitude: 6873.3 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#stepping-through-time","title":"Stepping Through Time","text":"<p>One of the primary functions of propagators is to step forward in time, generating new states at regular intervals. There are several methods to advance the propagator's internal state. Each stepping operation adds new state(s) to the internal trajectory.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#single-steps","title":"Single Steps","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Take one step (60 seconds)\nprop.step()\nprint(f\"After 1 step: {prop.current_epoch}\")\n# After 1 step: 2024-01-01 00:01:00.000 UTC\n\n# Step by custom duration (120 seconds)\nprop.step_by(120.0)\nprint(f\"After custom step: {prop.current_epoch}\")\n# After custom step: 2024-01-01 00:03:00.000 UTC\n\n# Trajectory now contains 3 states (initial + 2 steps)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create propagator\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Take one step (60 seconds)\n    prop.step();\n    println!(\"After 1 step: {}\", prop.current_epoch());\n    // After 1 step: 2024-01-01 00:01:00.000 UTC\n\n    // Step by custom duration (120 seconds)\n    prop.step_by(120.0);\n    println!(\"After custom step: {}\", prop.current_epoch());\n    // After custom step: 2024-01-01 00:03:00.000 UTC\n\n    // Trajectory now contains 3 states (initial + 2 steps)\n    println!(\"Trajectory length: {}\", prop.trajectory.len());\n    // Trajectory length: 3\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#multiple-steps","title":"Multiple Steps","text":"<p>The <code>propagate_steps()</code> method allows taking multiple fixed-size steps in one call.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Take 10 steps (10 \u00d7 60 = 600 seconds)\nprop.propagate_steps(10)\nprint(f\"After 10 steps: {(prop.current_epoch - epoch):.1f} seconds elapsed\")\n# After 10 steps: 600.0 seconds elapsed\nprint(f\"Trajectory length: {len(prop.trajectory)}\")\n# Trajectory length: 11\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Take 10 steps (10 \u00d7 60 = 600 seconds)\n    prop.propagate_steps(10);\n    println!(\"After 10 steps: {:.1} seconds elapsed\",\n             prop.current_epoch() - epoch);\n    // After 10 steps: 600.0 seconds elapsed\n    println!(\"Trajectory length: {}\", prop.trajectory.len());\n    // Trajectory length: 11\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#propagate-to-target-epoch","title":"Propagate to Target Epoch","text":"<p>For precise time targeting, use <code>propagate_to()</code> which adjusts the final step size to exactly reach the target epoch.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate exactly 500 seconds (not evenly divisible by step size)\ntarget = epoch + 500.0\nprop.propagate_to(target)\n\nprint(f\"Target epoch: {target}\")\n# Target epoch: 2024-01-01 00:08:20.000 UTC\nprint(f\"Current epoch: {prop.current_epoch}\")\n# Current epoch: 2024-01-01 00:08:20.000 UTC\nprint(f\"Difference: {abs(prop.current_epoch - target):.10f} seconds\")\n# Difference: 0.0000000000 seconds\n# Output shows machine precision agreement\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::SStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate exactly 500 seconds (not evenly divisible by step size)\n    let target = epoch + 500.0;\n    prop.propagate_to(target);\n\n    println!(\"Target epoch: {}\", target);\n    // Target epoch: 2024-01-01 00:08:20.000 UTC\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    // Current epoch: 2024-01-01 00:08:20.000 UTC\n    println!(\"Difference: {:.10} seconds\",\n             (prop.current_epoch() - target).abs());\n    // Difference: 0.0000000000 seconds\n    // Output shows machine precision agreement\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#direct-state-queries","title":"Direct State Queries","text":"<p>The <code>StateProvider</code> trait allows computing states at arbitrary epochs without building a trajectory. This is useful for sparse sampling or parallel batch computation.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#single-epoch-queries","title":"Single Epoch Queries","text":"<p>Single epoch queries like <code>state()</code>, <code>state_eci()</code>, and <code>state_ecef()</code> compute the state at a specific epoch on demand.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for frame transformations\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Query state 1 hour later (doesn't add to trajectory)\nquery_epoch = epoch + 3600.0\nstate_native = prop.state(\n    query_epoch\n)  # Native format of propagator internal state (Keplerian)\nstate_eci = prop.state_eci(query_epoch)  # ECI Cartesian\nstate_ecef = prop.state_ecef(query_epoch)  # ECEF Cartesian\nstate_kep = prop.state_koe_osc(query_epoch, bh.AngleFormat.DEGREES)\n\nprint(f\"Native state (Keplerian): a={state_native[0] / 1e3:.1f} km\")\n# Native state (Keplerian): a=6878.1 km\nprint(f\"ECI position magnitude: {np.linalg.norm(state_eci[:3]) / 1e3:.1f} km\")\n# ECI position magnitude: 6877.7 km\nprint(f\"ECEF position magnitude: {np.linalg.norm(state_ecef[:3]) / 1e3:.1f} km\")\n# ECEF position magnitude: 6877.7 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::{DStateProvider, DOrbitStateProvider};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for frame transformations\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Query state 1 hour later (doesn't add to trajectory)\n    let query_epoch = epoch + 3600.0;\n    let state_native = prop.state(query_epoch).unwrap();       // Native format of propagator internal state  (Keplerian)\n    let state_eci = prop.state_eci(query_epoch).unwrap();      // ECI Cartesian\n    let state_ecef = prop.state_ecef(query_epoch).unwrap();    // ECEF Cartesian\n    let _state_kep = prop.state_koe_osc(\n        query_epoch, bh::AngleFormat::Degrees\n    ).unwrap();\n\n    println!(\"Native state (Keplerian): a={:.1} km\", state_native[0] / 1e3);\n    // Native state (Keplerian): a=6878.1 km\n    println!(\"ECI position magnitude: {:.1} km\",\n             state_eci.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECI position magnitude: 6877.7 km\n    println!(\"ECEF position magnitude: {:.1} km\",\n             state_ecef.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // ECEF position magnitude: 6877.7 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#batch-queries","title":"Batch Queries","text":"<p>Batch queries like <code>states()</code> and <code>states_eci()</code> compute states at each epoch in a provided list.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Generate states at irregular intervals\nquery_epochs = [epoch + t for t in [0.0, 100.0, 500.0, 1000.0, 3600.0]]\nstates_eci = prop.states_eci(query_epochs)\n\nprint(f\"Generated {len(states_eci)} states\")\n# Generated 5 states\nfor i, state in enumerate(states_eci):\n    print(f\"  Epoch {i}: position magnitude = {np.linalg.norm(state[:3]) / 1e3:.1f} km\")\n\n# Output:\n# Generated 5 states\n#   Epoch 0: position magnitude = 6873.3 km\n#   Epoch 1: position magnitude = 6873.8 km\n#   Epoch 2: position magnitude = 6876.6 km\n#   Epoch 3: position magnitude = 6880.3 km\n#   Epoch 4: position magnitude = 6877.7 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::DOrbitStateProvider;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Generate states at irregular intervals\n    let query_epochs = vec![\n        epoch, epoch + 100.0, epoch + 500.0, epoch + 1000.0, epoch + 3600.0\n    ];\n    let states_eci = prop.states_eci(&amp;query_epochs).unwrap();\n\n    println!(\"Generated {} states\", states_eci.len());\n    // Generated 5 states\n    for (i, state) in states_eci.iter().enumerate() {\n        println!(\"  Epoch {}: position magnitude = {:.1} km\",\n                 i, state.fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    }\n}\n\n// Output:\n// Generated 5 states\n//   Epoch 0: position magnitude = 6873.3 km\n//   Epoch 1: position magnitude = 6873.8 km\n//   Epoch 2: position magnitude = 6876.6 km\n//   Epoch 3: position magnitude = 6880.3 km\n//   Epoch 4: position magnitude = 6877.7 km\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#trajectory-management","title":"Trajectory Management","text":"<p>The propagator stores all stepped states in an internal <code>OrbitTrajectory</code>. This trajectory can be accessed, converted, and managed.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#accessing-the-trajectory","title":"Accessing the Trajectory","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate for several steps\nprop.propagate_steps(5)\n\n# Access trajectory\ntraj = prop.trajectory\nprint(f\"Trajectory contains {len(traj)} states\")\n# Trajectory contains 6 states\n\n# Iterate over epoch-state pairs\nfor epoch, state in traj:\n    print(f\"Epoch: {epoch}, semi-major axis: {state[0] / 1e3:.1f} km\")\n# Epoch: 2024-01-01 00:00:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:01:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:02:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:03:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:04:00.000 UTC, semi-major axis: 6878.1 km\n# Epoch: 2024-01-01 00:05:00.000 UTC, semi-major axis: 6878.1 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate for several steps\n    prop.propagate_steps(5);\n\n    // Access trajectory\n    let traj = &amp;prop.trajectory;\n    println!(\"Trajectory contains {} states\", traj.len());\n    // Trajectory contains 6 states\n\n    // Access by index\n    for i in 0..traj.len() {\n        let epoch = traj.epoch_at_idx(i).unwrap();\n        let state = traj.state_at_idx(i).unwrap();\n        println!(\"Epoch: {}, semi-major axis: {:.1} km\", epoch, state[0] / 1e3);\n    }\n    // Epoch: 2024-01-01 00:00:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:01:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:02:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:03:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:04:00.000 UTC, semi-major axis: 6878.1 km\n    // Epoch: 2024-01-01 00:05:00.000 UTC, semi-major axis: 6878.1 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#frame-conversions","title":"Frame Conversions","text":"<p>You can use the OrbitTrajectory's frame conversion methods to get the trajectory in different reference frames.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for ECEF conversions\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\nprop.propagate_steps(10)\n\n# Convert entire trajectory to different frames\ntraj_eci = prop.trajectory.to_eci()  # ECI Cartesian\ntraj_ecef = prop.trajectory.to_ecef()  # ECEF Cartesian\ntraj_kep = prop.trajectory.to_keplerian(bh.AngleFormat.RADIANS)\n\nprint(f\"ECI trajectory: {len(traj_eci)} states\")\n# ECI trajectory: 11 states\nprint(f\"ECEF trajectory: {len(traj_ecef)} states\")\n# ECEF trajectory: 11 states\nprint(f\"Keplerian trajectory: {len(traj_kep)} states\")\n# Keplerian trajectory: 11 states\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for ECEF conversions\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n    prop.propagate_steps(10);\n\n    // Convert entire trajectory to different frames\n    let traj_eci = prop.trajectory.to_eci();       // ECI Cartesian\n    let traj_ecef = prop.trajectory.to_ecef();     // ECEF Cartesian\n    let traj_kep = prop.trajectory.to_keplerian(bh::AngleFormat::Radians);\n\n    println!(\"ECI trajectory: {} states\", traj_eci.len());\n    // ECI trajectory: 11 states\n    println!(\"ECEF trajectory: {} states\", traj_ecef.len());\n    // ECEF trajectory: 11 states\n    println!(\"Keplerian trajectory: {} states\", traj_kep.len());\n    // Keplerian trajectory: 11 states\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#memory-management","title":"Memory Management","text":"<p>Propagators support trajectory memory management via eviction policies to limit memory usage for long-running applications.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Keep only 100 most recent states\nprop.set_eviction_policy_max_size(100)\n\n# Propagate many steps\nprop.propagate_steps(500)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")  # Will be 100\n# Trajectory length: 100\n\n# Alternative: Keep only states within 1 hour of current time\nprop.reset()\nprop.set_eviction_policy_max_age(3600.0)  # 3600 seconds = 1 hour\nprop.propagate_steps(500)\nprint(f\"Trajectory length after age policy: {len(prop.trajectory)}\")\n# Trajectory length after age policy: 61\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Keep only 100 most recent states\n    prop.set_eviction_policy_max_size(100).unwrap();\n\n    // Propagate many steps\n    prop.propagate_steps(500);\n    println!(\"Trajectory length: {}\", prop.trajectory.len());  // Will be 100\n    // Trajectory length: 100\n\n    // Alternative: Keep only states within 1 hour of current time\n    prop.reset();\n    prop.set_eviction_policy_max_age(3600.0).unwrap();  // 3600 seconds = 1 hour\n    prop.propagate_steps(500);\n    println!(\"Trajectory length after age policy: {}\", prop.trajectory.len());\n    // Trajectory length after age policy: 61\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#configuration-and-control","title":"Configuration and Control","text":"<p>There are several methods to manage and configure the propagator during its lifecycle.</p>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#resetting-the-propagator","title":"Resetting the Propagator","text":"<p>You can reset the propagator to its initial conditions using the <code>reset()</code> method.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate forward\nprop.propagate_steps(100)\nprint(f\"After propagation: {len(prop.trajectory)} states\")\n# After propagation: 101 states\n\n# Reset to initial conditions\nprop.reset()\nprint(f\"After reset: {len(prop.trajectory)} states\")\n# After reset: 1 states\nprint(f\"Current epoch: {prop.current_epoch}\")\n# Current epoch: 2024-01-01 00:00:00.000 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{SStatePropagator, Trajectory};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    // Propagate forward\n    prop.propagate_steps(100);\n    println!(\"After propagation: {} states\", prop.trajectory.len());\n    // After propagation: 101 states\n\n    // Reset to initial conditions\n    prop.reset();\n    println!(\"After reset: {} states\", prop.trajectory.len());\n    // After reset: 1 states\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    // Current epoch: 2024-01-01 00:00:00.000 UTC\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#changing-step-size","title":"Changing Step Size","text":"<p>If you need to adjust the default step size during propagation, use the <code>set_step_size()</code> method.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epoch, elements, bh.AngleFormat.DEGREES, 60.0\n)\n\nprint(f\"Initial step size: {prop.step_size} seconds\")\n# Initial step size: 60.0 seconds\n\n# Change step size\nprop.set_step_size(120.0)\nprint(f\"New step size: {prop.step_size} seconds\")\n# New step size: 120.0 seconds\n\n# Subsequent steps use new step size\nprop.step()  # Advances 120 seconds\nprint(f\"After step: {(prop.current_epoch - epoch):.1f} seconds elapsed\")\n# After step: 120.0 seconds elapsed\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::SStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n    let mut prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    );\n\n    println!(\"Initial step size: {} seconds\", prop.step_size());\n    // Initial step size: 60 seconds\n\n    // Change step size\n    prop.set_step_size(120.0);\n    println!(\"New step size: {} seconds\", prop.step_size());\n    // New step size: 120 seconds\n\n    // Subsequent steps use new step size\n    prop.step();  // Advances 120 seconds\n    println!(\"After step: {:.1} seconds elapsed\", prop.current_epoch() - epoch);\n    // After step: 120.0 seconds elapsed\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#identity-tracking","title":"Identity Tracking","text":"<p>Finally, the <code>IdentifiableStateProvider</code> trait allows you to set and get identity information for the propagator. This can be useful when managing multiple propagators in an application.</p> <p>Track propagators with names, IDs, or UUIDs for multi-satellite scenarios.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\n\n# Create propagator with identity (builder pattern)\nprop = (\n    bh.KeplerianPropagator.from_keplerian(epoch, elements, bh.AngleFormat.DEGREES, 60.0)\n    .with_name(\"Satellite-A\")\n    .with_id(12345)\n)\n\nprint(f\"Name: {prop.get_name()}\")\n# Name: Satellite-A\nprint(f\"ID: {prop.get_id()}\")\n# ID: 12345\nprint(f\"UUID: {prop.get_uuid()}\")\n# UUID: None (because not set)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let elements = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0);\n\n    // Create propagator with identity (builder pattern)\n    let prop = bh::KeplerianPropagator::from_keplerian(\n        epoch, elements, bh::AngleFormat::Degrees, 60.0\n    ).with_name(\"Satellite-A\").with_id(12345);\n\n    println!(\"Name: {:?}\", prop.get_name());\n    // Name: Some(\"Satellite-A\")\n    println!(\"ID: {:?}\", prop.get_id());\n    // ID: Some(12345)\n    println!(\"UUID: {:?}\", prop.get_uuid());\n    // UUID: None (because not set)\n}\n</code></pre>"},{"location":"learn/orbit_propagation/keplerian_propagation.html#see-also","title":"See Also","text":"<ul> <li>Orbit Propagation Overview - Propagation concepts and trait hierarchy</li> <li>SGP Propagation - TLE-based SGP4/SDP4 propagator</li> <li>Trajectories - Trajectory storage and operations</li> <li>KeplerianPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/parallel_propagation.html","title":"Parallel Orbit Propagation","text":"<p>When working with multiple satellites (constellations, Monte Carlo simulations, etc.), propagating each satellite sequentially can be slow. The <code>par_propagate_to</code> function enables efficient parallel propagation by utilizing multiple CPU cores. The parallel propagation function uses Rayon's work-stealing thread pool, configured via <code>brahe.set_num_threads()</code>.</p> <p>When to Use Parallel Propagation</p> <ul> <li>Propagating constellations (10s to 1000s of satellites)</li> <li>Running Monte Carlo simulations</li> <li>Batch processing orbital predictions</li> <li>You have multiple CPU cores available</li> </ul> <p>See the threading documentation for more details on configuring threading in Brahe.</p>"},{"location":"learn/orbit_propagation/parallel_propagation.html#basic-example","title":"Basic Example","text":"<p>This example creates a constellation of 10 satellites and propagates them 24 hours forward in parallel:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\nimport time\n\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create multiple propagators for a constellation\nnum_sats = 10\npropagators = []\n\nfor i in range(num_sats):\n    # Vary semi-major axis slightly for each satellite\n    a = bh.R_EARTH + 500e3 + i * 10e3\n    oe = np.array([a, 0.001, 98.0, i * 36.0, 0.0, i * 36.0])\n    state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\n    propagators.append(prop)\n\n# Target epoch: 24 hours later\ntarget = epoch + 86400.0\n\n# Propagate all satellites in parallel\nstart = time.time()\nbh.par_propagate_to(propagators, target)\nparallel_time = time.time() - start\n\nprint(f\"Propagated {num_sats} satellites in parallel: {parallel_time:.4f} seconds\")\nprint(\"\\nFinal states:\")\nfor i, prop in enumerate(propagators):\n    state = prop.current_state()\n    print(f\"  Satellite {i}: r = {np.linalg.norm(state[:3]) / 1e3:.1f} km\")\n\n# Output:\n# Propagated 10 satellites in parallel: 0.0026 seconds\n\n# Final states:\n#   Satellite 0: r = 6876.8 km\n#   Satellite 1: r = 6889.7 km\n#   Satellite 2: r = 6902.3 km\n#   Satellite 3: r = 6914.2 km\n#   Satellite 4: r = 6925.0 km\n#   Satellite 5: r = 6934.7 km\n#   Satellite 6: r = 6943.1 km\n#   Satellite 7: r = 6950.7 km\n#   Satellite 8: r = 6957.8 km\n#   Satellite 9: r = 6965.0 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::SStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Create multiple propagators for a constellation\n    let num_sats = 10;\n    let mut propagators = Vec::new();\n\n    for i in 0..num_sats {\n        // Vary semi-major axis slightly for each satellite\n        let a = bh::R_EARTH + 500e3 + (i as f64) * 10e3;\n        let oe = na::SVector::&lt;f64, 6&gt;::new(\n            a,\n            0.001,\n            98.0,\n            (i as f64) * 36.0,\n            0.0,\n            (i as f64) * 36.0,\n        );\n        let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n        let prop = bh::KeplerianPropagator::from_eci(epoch, state, 60.0);\n        propagators.push(prop);\n    }\n\n    // Target epoch: 24 hours later\n    let target = epoch + 86400.0;\n\n    // Propagate all satellites in parallel\n    let start = std::time::Instant::now();\n    bh::par_propagate_to_s(&amp;mut propagators, target);\n    let parallel_time = start.elapsed();\n\n    println!(\n        \"Propagated {} satellites in parallel: {:.4} seconds\",\n        num_sats,\n        parallel_time.as_secs_f64()\n    );\n    println!(\"\\nFinal states:\");\n    for (i, prop) in propagators.iter().enumerate() {\n        let state = prop.current_state();\n        let r = (state[0].powi(2) + state[1].powi(2) + state[2].powi(2)).sqrt();\n        println!(\"  Satellite {}: r = {:.1} km\", i, r / 1e3);\n    }\n}\n\n// Output:\n// Propagated 10 satellites in parallel: 0.0026 seconds\n\n// Final states:\n//   Satellite 0: r = 6876.8 km\n//   Satellite 1: r = 6889.7 km\n//   Satellite 2: r = 6902.3 km\n//   Satellite 3: r = 6914.2 km\n//   Satellite 4: r = 6925.0 km\n//   Satellite 5: r = 6934.7 km\n//   Satellite 6: r = 6943.1 km\n//   Satellite 7: r = 6950.7 km\n//   Satellite 8: r = 6957.8 km\n//   Satellite 9: r = 6965.0 km\n</code></pre>"},{"location":"learn/orbit_propagation/parallel_propagation.html#mixing-propagator-types","title":"Mixing Propagator Types","text":"<p>All propagators in the list must be the same type (either all <code>KeplerianPropagator</code> or all <code>SGPPropagator</code>). Mixing types will raise a <code>TypeError</code>:</p> Python <pre><code>import brahe as bh\n\n# Example propgator intiailization\nkep_prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\nsgp_prop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# This will raise TypeError\nbh.par_propagate_to([kep_prop, sgp_prop], target)\n</code></pre>"},{"location":"learn/orbit_propagation/parallel_propagation.html#memory-considerations","title":"Memory Considerations","text":"<p>The parallel function clones each propagator before propagation, then updates the originals with final states. Memory usage scales linearly with the number of propagators.</p> <p>For very large constellations (1000s of satellites), consider processing in batches and monitoring memory usage to avoid crashes from memory exhaustion.</p>"},{"location":"learn/orbit_propagation/parallel_propagation.html#error-handling","title":"Error Handling","text":"<p>If any propagator fails during parallel propagation, the function will panic (Rust) or raise an exception (Python). This can occur with SGP4 propagators when satellites decay below Earth's surface.</p>"},{"location":"learn/orbit_propagation/parallel_propagation.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Propagator - Two-body orbital propagation</li> <li>SGP4 Propagator - TLE-based propagation</li> <li>API Reference: par_propagate_to</li> </ul>"},{"location":"learn/orbit_propagation/sgp_propagation.html","title":"SGP Propagation","text":"<p>The <code>SGPPropagator</code> implements the SGP4/SDP4 propagation models for orbital prediction. SGP4 is a standard method for satellite tracking and includes simplified perturbations from Earth oblateness and atmospheric drag, making it suitable for operational satellite tracking and near-Earth orbit propagation. It is widely used with Two-Line Element (TLE) data provided by NORAD and other space tracking organizations.</p> <p>For complete API documentation, see the SGPPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#tle-format-support","title":"TLE Format Support","text":"<p>SGP4 propagation is based on Two-Line Element (TLE) sets, a compact data format for orbital elements. Brahe supports both traditional and modern TLE formats:</p> <ul> <li>Classic Format: Traditional numeric NORAD catalog numbers (5 digits, up to 99999)</li> <li>Alpha-5 Format: Extended alphanumeric catalog numbers for satellites beyond 99999</li> </ul> <p>The initialization automatically detects and handles both formats.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#initialization","title":"Initialization","text":"<p>The <code>SGPPropagator</code> is initialized from TLE data. The TLE lines contain all orbital parameters needed for propagation.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#from-two-line-elements-tle","title":"From Two Line Elements (TLE)","text":"<p>The most common initialization uses two lines of TLE data.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()  # Required for accurate frame transformations\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator with 60-second step size\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\nprint(f\"NORAD ID: {prop.norad_id}\")\nprint(f\"TLE epoch: {prop.epoch}\")\nprint(\n    f\"Initial position magnitude: {np.linalg.norm(prop.initial_state()[:3]) / 1e3:.1f} km\"\n)\n# Expected output:\n# NORAD ID: 25544\n# TLE epoch: 2008-09-20 12:25:40.104 UTC\n# Initial position magnitude: 6720.2 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::SStatePropagator;\n\nfn main() {\n    bh::initialize_eop().unwrap();  // Required for accurate frame transformations\n\n    // ISS TLE data (example)\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator with 60-second step size\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    println!(\"NORAD ID: {}\", prop.norad_id);\n    println!(\"TLE epoch: {}\", prop.epoch);\n    println!(\"Initial position magnitude: {:.1} km\",\n             prop.initial_state().fixed_rows::&lt;3&gt;(0).norm() / 1e3);\n    // Expected output:\n    // NORAD ID: 25544\n    // TLE epoch: 2008-09-20 12:25:40.104 UTC\n    // Initial position magnitude: 6720.2 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#from-3-line-elements-3le","title":"From 3-Line Elements (3LE)","text":"<p>Three-line TLE format includes an optional satellite name on the first line.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# 3-line TLE with satellite name\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator with satellite name\nprop = bh.SGPPropagator.from_3le(name, line1, line2, 60.0)\n\nprint(f\"Satellite name: {prop.satellite_name}\")\nprint(f\"NORAD ID: {prop.norad_id}\")\n# Expected output:\n# Satellite name: ISS (ZARYA)\n# NORAD ID: 25544\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // 3-line TLE with satellite name\n    let name = \"ISS (ZARYA)\";\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator with satellite name\n    let prop = bh::SGPPropagator::from_3le(Some(name), line1, line2, 60.0).unwrap();\n\n    println!(\"Satellite name: {:?}\", prop.satellite_name);\n    println!(\"NORAD ID: {}\", prop.norad_id);\n    // Expected output:\n    // Satellite name: Some(\"ISS (ZARYA)\")\n    // NORAD ID: 25544\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#configuring-output-format","title":"Configuring Output Format","text":"<p>By default, SGP4 outputs states in ECI Cartesian coordinates. Use <code>with_output_format()</code> to configure the output frame and representation.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create with ECEF Cartesian output\nprop_ecef = bh.SGPPropagator.from_tle(line1, line2, 60.0)\nprop_ecef.set_output_format(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\n\n# Or with Keplerian output (ECI only)\nprop_kep = bh.SGPPropagator.from_tle(line1, line2, 60.0)\nprop_kep.set_output_format(\n    bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES\n)\n\n# Propagate to 1 hour after epoch\ndt = 3600.0\nprop_ecef.propagate_to(prop_ecef.epoch + dt)\nprop_kep.propagate_to(prop_kep.epoch + dt)\nprint(f\"ECEF position (km): {prop_ecef.current_state()[:3] / 1e3}\")\nstate_kep = prop_kep.current_state()\nprint(\n    f\"Keplerian elements: [{state_kep[0]:.1f} km, {state_kep[1]:.4f}, {state_kep[2]:.4f}, \"\n    f\"{state_kep[3]:.4f} deg, {state_kep[4]:.4f} deg, {state_kep[5]:.4f} deg]\"\n)\n\n# Expected output:\n# ECEF position (km): [ 5548.63233725  2869.31027561 -2526.64252368]\n# Keplerian elements: [8198150.8 km, 0.1789, 47.9402, 249.8056 deg, 323.0545 deg, 4.5675 deg]\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{OrbitFrame, SStatePropagator, OrbitRepresentation};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create with ECEF Cartesian output\n    let mut prop_ecef = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap()\n        .with_output_format(OrbitFrame::ECEF, OrbitRepresentation::Cartesian, None);\n\n    // Or with Keplerian output (ECI only)\n    let mut prop_kep = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap()\n        .with_output_format(OrbitFrame::ECI, OrbitRepresentation::Keplerian, Some(bh::AngleFormat::Degrees));\n\n    // Propagate to 1 hour after epoch\n    let dt = 3600.0;\n    prop_ecef.propagate_to(prop_ecef.epoch + dt);\n    prop_kep.propagate_to(prop_kep.epoch + dt);\n\n    let state_ecef = prop_ecef.current_state();\n    println!(\"ECEF position (km): [{:.3}, {:.3}, {:.3}]\",\n             state_ecef[0] / 1e3, state_ecef[1] / 1e3, state_ecef[2] / 1e3);\n\n    let state_kep = prop_kep.current_state();\n    println!(\"Keplerian elements: [{:.1} km, {:.4}, {:.4}, {:.4} deg, {:.4} deg, {:.4} deg]\",\n             state_kep[0] / 1e3, state_kep[1], state_kep[2],\n             state_kep[3], state_kep[4], state_kep[5]);\n}\n\n// Output:\n// ECEF position (km): [5548.632, 2869.310, -2526.643]\n// Keplerian elements: [8198.2 km, 0.1789, 47.9402, 249.8056 deg, 323.0545 deg, 4.5675 deg]\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#stepping-through-time","title":"Stepping Through Time","text":"<p>The SGP propagator uses the same stepping interface as other propagators through the <code>OrbitPropagator</code> trait.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#single-and-multiple-steps","title":"Single and Multiple Steps","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Single step (60 seconds)\nprop.step()\nprint(f\"After 1 step: {prop.current_epoch}\")\n\n# Multiple steps\nprop.propagate_steps(10)\nprint(f\"After 11 total steps: {len(prop.trajectory)} states\")\n\n# Step by custom duration\nprop.step_by(120.0)\nprint(f\"After custom step: {prop.current_epoch}\")\n\n# Expected output:\n# After 1 step: 2008-09-20 12:26:40.104 UTC\n# After 11 total steps: 12 states\n# After custom step: 2008-09-20 12:38:40.104 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{SStatePropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Single step (60 seconds)\n    prop.step();\n    println!(\"After 1 step: {}\", prop.current_epoch());\n\n    // Multiple steps\n    prop.propagate_steps(10);\n    println!(\"After 11 total steps: {} states\", prop.trajectory.len());\n\n    // Step by custom duration\n    prop.step_by(120.0);\n    println!(\"After custom step: {}\", prop.current_epoch());\n}\n\n// Output\n// After 1 step: 2008-09-20 12:26:40.104 UTC\n// After 11 total steps: 12 states\n// After custom step: 2008-09-20 12:38:40.104 UTC\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#propagate-to-target-epoch","title":"Propagate to Target Epoch","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Propagate to specific epoch\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\n\nprint(f\"Target epoch: {target}\")\nprint(f\"Current epoch: {prop.current_epoch}\")\nprint(f\"Trajectory contains {len(prop.trajectory)} states\")\n\n# Expected output:\n# Target epoch: 2008-09-20 14:25:40.104 UTC\n# Current epoch: 2008-09-20 14:25:40.104 UTC\n# Trajectory contains 121 states\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{SStatePropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Propagate to specific epoch\n    let target = prop.epoch + 7200.0;  // 2 hours later\n    prop.propagate_to(target);\n\n    println!(\"Target epoch: {}\", target);\n    println!(\"Current epoch: {}\", prop.current_epoch());\n    println!(\"Trajectory contains {} states\", prop.trajectory.len());\n\n    // Expected output:\n    // Target epoch: 2008-09-20 14:25:40.104 UTC\n    // Current epoch: 2008-09-20 14:25:40.104 UTC\n    // Trajectory contains 121 states\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#direct-state-queries","title":"Direct State Queries","text":"<p>The SGP propagator implements the <code>StateProvider</code> trait, allowing direct state computation at arbitrary epochs without stepping. Because SGP4 uses closed-form solutions, state queries are efficient and do not require building a trajectory.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#single-epoch-queries","title":"Single Epoch Queries","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Query state 1 orbit later (doesn't add to trajectory)\nquery_epoch = prop.epoch + 5400.0  # ~90 minutes\n\nstate_eci = prop.state_eci(query_epoch)  # ECI Cartesian\nstate_ecef = prop.state_ecef(query_epoch)  # ECEF Cartesian\nstate_kep = prop.state_koe_osc(\n    query_epoch, bh.AngleFormat.DEGREES\n)  # Osculating Keplerian\n\nprint(\n    f\"ECI position: [{state_eci[0] / 1e3:.1f}, {state_eci[1] / 1e3:.1f}, \"\n    f\"{state_eci[2] / 1e3:.1f}] km\"\n)\nprint(f\"Osculating semi-major axis: {state_kep[0] / 1e3:.1f} km\")\n\n# Expected output:\n# ECI position: [3822.2, -1684.2, 5264.9] km\n# Osculating semi-major axis: 6725.4 km\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::SOrbitStateProvider;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Query state 1 orbit later (doesn't add to trajectory)\n    let query_epoch = prop.epoch + 5400.0;  // ~90 minutes\n\n    let state_eci = prop.state_eci(query_epoch).unwrap();          // ECI Cartesian\n    let _state_ecef = prop.state_ecef(query_epoch).unwrap();        // ECEF Cartesian\n    let state_kep = prop.state_koe_osc(query_epoch, bh::AngleFormat::Degrees).unwrap();    // Osculating Keplerian\n\n    println!(\"ECI position: [{:.1}, {:.1}, {:.1}] km\",\n             state_eci[0]/1e3, state_eci[1]/1e3, state_eci[2]/1e3);\n    println!(\"Osculating semi-major axis: {:.1} km\", state_kep[0]/1e3);\n\n    // Expected output:\n    // ECI position: [3822.2, -1684.2, 5264.9] km\n    // Osculating semi-major axis: 6725.4 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#batch-queries","title":"Batch Queries","text":"PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Generate states for multiple orbits\norbital_period = 5400.0  # Approximate ISS period (seconds)\nquery_epochs = [prop.epoch + i * orbital_period for i in range(5)]\nstates_eci = prop.states_eci(query_epochs)\n\nprint(f\"Generated {len(states_eci)} states over {len(query_epochs)} orbits\")\nfor i, state in enumerate(states_eci):\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1e3\n    print(f\"  Orbit {i}: altitude = {altitude:.1f} km\")\n# Expected output:\n# Generated 5 states over 5 orbits\n#   Orbit 0: altitude = 342.1 km\n#   Orbit 1: altitude = 342.3 km\n#   Orbit 2: altitude = 342.7 km\n#   Orbit 3: altitude = 343.3 km\n#   Orbit 4: altitude = 344.0 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::DOrbitStateProvider;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Generate states for multiple orbits\n    let orbital_period = 5400.0;  // Approximate ISS period (seconds)\n    let query_epochs: Vec&lt;bh::Epoch&gt; = (0..5)\n        .map(|i| prop.epoch + i as f64 * orbital_period)\n        .collect();\n    let states_eci = prop.states_eci(&amp;query_epochs).unwrap();\n\n    println!(\"Generated {} states over {} orbits\", states_eci.len(), query_epochs.len());\n    for (i, state) in states_eci.iter().enumerate() {\n        let altitude = (state.fixed_rows::&lt;3&gt;(0).norm() - bh::R_EARTH) / 1e3;\n        println!(\"  Orbit {}: altitude = {:.1} km\", i, altitude);\n    }\n    // Expected output:\n    // Generated 5 states over 5 orbits\n    //   Orbit 0: altitude = 342.1 km\n    //   Orbit 1: altitude = 342.3 km\n    //   Orbit 2: altitude = 342.7 km\n    //   Orbit 3: altitude = 343.3 km\n    //   Orbit 4: altitude = 344.0 km\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#special-pef-frame","title":"Special: PEF Frame","text":"<p>SGP4 natively outputs states in the TEME (True Equator Mean Equinox) frame. For specialized applications, you can access states in the intermediate PEF (Pseudo-Earth-Fixed) frame:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Get state in PEF frame (TEME rotated by GMST)\nstate_pef = prop.state_pef(prop.epoch)\nprint(f\"PEF position: {state_pef[:3] / 1e3}\")\n# Expected output:\n# PEF position: [-3953.20574821  1427.51460044  5243.61453697]\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Get state in PEF frame (TEME rotated by GMST)\n    let state_pef = prop.state_pef(prop.epoch);\n    println!(\"PEF position: {:?}\", state_pef.fixed_rows::&lt;3&gt;(0) / 1e3);\n    // Expected output:\n    // PEF position: [[-3953.2057482107907, 1427.514600436758, 5243.614536966578]]\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#extracting-orbital-elements-from-tle","title":"Extracting Orbital Elements from TLE","text":"<p>The propagator can extract Keplerian orbital elements directly from the TLE data:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Extract Keplerian elements from TLE\nelements_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nelements_rad = prop.get_elements(bh.AngleFormat.RADIANS)\n\nprint(f\"Semi-major axis: {elements_deg[0] / 1e3:.1f} km\")\nprint(f\"Eccentricity: {elements_deg[1]:.6f}\")\nprint(f\"Inclination: {elements_deg[2]:.4f} degrees\")\nprint(f\"RAAN: {elements_deg[3]:.4f} degrees\")\nprint(f\"Argument of perigee: {elements_deg[4]:.4f} degrees\")\nprint(f\"Mean anomaly: {elements_deg[5]:.4f} degrees\")\n# Expected output:\n# Semi-major axis: 6758.7 km\n# Eccentricity: 0.000670\n# Inclination: 51.6416 degrees\n# RAAN: 247.4627 degrees\n# Argument of perigee: 130.5360 degrees\n# Mean anomaly: 325.0288 degrees\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Extract Keplerian elements from TLE\n    let elements_deg = prop.get_elements(bh::AngleFormat::Degrees).unwrap();\n    let _elements_rad = prop.get_elements(bh::AngleFormat::Radians).unwrap();\n\n    println!(\"Semi-major axis: {:.1} km\", elements_deg[0]/1e3);\n    println!(\"Eccentricity: {:.6}\", elements_deg[1]);\n    println!(\"Inclination: {:.4} degrees\", elements_deg[2]);\n    println!(\"RAAN: {:.4} degrees\", elements_deg[3]);\n    println!(\"Argument of perigee: {:.4} degrees\", elements_deg[4]);\n    println!(\"Mean anomaly: {:.4} degrees\", elements_deg[5]);\n    // Expected output:\n    // Semi-major axis: 6758.7 km\n    // Eccentricity: 0.000670\n    // Inclination: 51.6416 degrees\n    // RAAN: 247.4627 degrees\n    // Argument of perigee: 130.5360 degrees\n    // Mean anomaly: 325.0288 degrees\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#trajectory-management","title":"Trajectory Management","text":"<p>SGP propagators support the same trajectory management as Keplerian propagators, including frame conversions and memory management.</p>"},{"location":"learn/orbit_propagation/sgp_propagation.html#memory-management","title":"Memory Management","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# Keep only 50 most recent states for memory efficiency\nprop.set_eviction_policy_max_size(50)\n\n# Propagate many steps\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {len(prop.trajectory)}\")  # Will be 50\n\n# Alternative: Keep states within 30 minutes of current\nprop.reset()\nprop.set_eviction_policy_max_age(1800.0)  # 1800 seconds = 30 minutes\nprop.propagate_steps(200)\nprint(f\"Trajectory length with age policy: {len(prop.trajectory)}\")\n# Expected output:\n# Trajectory length: 50\n# Trajectory length with age policy: 31\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::traits::{SStatePropagator, Trajectory};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n    let mut prop = bh::SGPPropagator::from_tle(line1, line2, 60.0).unwrap();\n\n    // Keep only 50 most recent states for memory efficiency\n    prop.set_eviction_policy_max_size(50).unwrap();\n\n    // Propagate many steps\n    prop.propagate_steps(200);\n    println!(\"Trajectory length: {}\", prop.trajectory.len());  // Will be 50\n\n    // Alternative: Keep states within 30 minutes of current\n    prop.reset();\n    prop.set_eviction_policy_max_age(1800.0).unwrap();  // 1800 seconds = 30 minutes\n    prop.propagate_steps(200);\n    println!(\"Trajectory length with age policy: {}\", prop.trajectory.len());\n    // Expected output:\n    // Trajectory length: 50\n    // Trajectory length with age policy: 31\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#limitations-and-considerations","title":"Limitations and Considerations","text":""},{"location":"learn/orbit_propagation/sgp_propagation.html#immutable-initial-conditions","title":"Immutable Initial Conditions","text":"<p>Unlike the Keplerian propagator, SGP4 initial conditions are derived from the TLE and cannot be changed. Attempting to call <code>set_initial_conditions()</code> will result in a panic:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2, 60.0)\n\n# This will raise an error - SGP initial conditions come from TLE\n# prop.set_initial_conditions(...)  # Don't do this!\n\n# To use different orbital elements, create a KeplerianPropagator instead\n</code></pre> <pre><code>// This will panic - SGP initial conditions come from TLE\n// prop.set_initial_conditions(...);  // Don't do this!\n\n// To use different orbital elements, create a KeplerianPropagator instead\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#identity-tracking","title":"Identity Tracking","text":"<p>Like Keplerian propagators, SGP propagators support identity tracking:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nline0 = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\n\n# Create propagator and set identity\nprop = bh.SGPPropagator.from_3le(line0, line1, line2, 60.0)\n\nprint(f\"Name: {prop.get_name()}\")\nprint(f\"ID: {prop.get_id()}\")\nprint(f\"NORAD ID from TLE: {prop.norad_id}\")\n# Expected output:\n# Name: ISS (ZARYA)\n# ID: 25544\n# NORAD ID from TLE: 25544\n</code></pre> <pre><code>use brahe as bh;\nuse brahe::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let line0 = \"ISS (ZARYA)\";\n    let line1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\";\n    let line2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\";\n\n    // Create propagator and set identity\n    let prop = bh::SGPPropagator::from_3le(Some(line0), line1, line2, 60.0).unwrap();\n\n    println!(\"Name: {:?}\", prop.get_name());\n    println!(\"ID: {:?}\", prop.get_id());\n    println!(\"NORAD ID from TLE: {}\", prop.norad_id);\n    // Expected output:\n    // Name:  Some(\"ISS (ZARYA)\")\n    // ID: Some(25544)\n    // NORAD ID from TLE: 25544\n}\n</code></pre>"},{"location":"learn/orbit_propagation/sgp_propagation.html#see-also","title":"See Also","text":"<ul> <li>Orbit Propagation Overview - Propagation concepts and trait hierarchy</li> <li>Keplerian Propagation - Analytical two-body propagator</li> <li>Trajectories - Trajectory storage and operations</li> <li>Two-Line Elements - Working with TLE data</li> <li>SGPPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html","title":"Numerical Propagation","text":"<p>Numerical propagation solves equations of motion through numerical integration, enabling high-fidelity dynamics modeling with arbitrary force models. Unlike analytical propagators that use closed-form solutions, numerical propagators step through time, computing accelerations at each step and integrating to get the next state. This approach allows for complex perturbations, control input modeling, covariance propagation, sensitivity analysis, and event detection.</p> <p>For orbital mechanics, Brahe provides the <code>NumericalOrbitPropagator</code> class built, which provides a fast way to propagate satellite orbits using the force models defined and discussed in Orbital Dynamics. The NumericalOrbitPropagator supports a variety of integrators, including fixed-step and adaptive methods, and can model perturbations such as atmospheric drag, solar radiation pressure, third-body effects, and relativistic corrections. It also supports covariance propagation and sensitivity analysis for orbit determination and parameter estimation. Finally, it supports event detection for orbital events like eclipses, node crossings, and altitude values. Event detection is covered in more detail in the Event Detection section, and premade event types are documented in Premade Events.</p> <p>Brahe also includes a more general <code>NumericalPropagator</code> class for propagating arbitrary dynamical system systems. This class allows users to integrate equations of motion for non-orbital dynamical systems. This capability is discussed in more depth in General Dynamics Propagation. </p> <p>Experimental Feature</p> <p>The numerical propagation system is one of the newer parts of Brahe and is still considered experimental. While the core functionality has been tested and verified, it is one of the most complex features so the design needs further testing and use before finalization. Users are encouraged to provide feedback and report any issues they encounter.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#architecture-overview","title":"Architecture Overview","text":"<p>The numerical propagation system consists of several configurable components:</p>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#force-model-configuration","title":"Force Model Configuration","text":"<p>The <code>ForceModelConfig</code> is a data structure that specifies which physical perturbations to include in the dynamics and their parameters. Supported force include:</p> <ul> <li>Gravity: Point-mass or spherical harmonics (EGMS2008, GGM05S, or user-defined)</li> <li>Atmospheric Drag: NRLMSISE-00, Harris-Priester, or exponential atmosphere models</li> <li>Solar Radiation Pressure: Cannonball model with conical or cylindrical eclipse</li> <li>Third-Body: Sun and Moon gravitational perturbations with analytic or DE440 ephemerides </li> <li>Relativistic Effects: Special and general relativistic corrections</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#integrator-configuration","title":"Integrator Configuration","text":"<p>The <code>NumericalPropagationConfig</code> specifies the integration method, integrator configuration, and variational equations settings:</p> <ul> <li>Integrator: Fixed-step (e.g., Runge-Kutta 4) or adaptive (e.g., Dormand-Prince 8(5,3)) methods</li> <li>Integrator Settings: Step size, error tolerances, and maximum step constraints</li> <li>Variational Equations: Enable/disable covariance and sensitivity propagation, with settings for state transition matrix and sensitivity matrix computation</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#event-detection","title":"Event Detection","text":"<p>The numerical propagator supports event detection through configurable event detectors. Brahe includes several premade event types (detailed in Premade Events):</p> <ul> <li>Time Events: Trigger at specific epochs</li> <li>Value Events: Trigger when a computed quantity crosses a value</li> <li>Binary Events: Trigger on boolean state changes</li> <li>Altitude Events: Trigger at specific altitudes</li> </ul> <p>Events can be configured to execute callbacks for impulsive maneuvers.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#trajectory-storage","title":"Trajectory Storage","text":"<p>All propagators maintain an internal <code>OrbitTrajectory</code> storing propagated states, covariances, state transition matricies, and sensitivities.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#quick-start","title":"Quick Start","text":"<p>The simplest way to create a numerical propagator uses default configurations:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define orbital elements: [a, e, i, raan, argp, M] in SI units\n# LEO satellite: 500 km altitude, near-circular, sun-synchronous inclination\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator with default configuration\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Propagate for 1 hour\nprop.propagate_to(epoch + 3600.0)\n\n# Get final state\nfinal_epoch = prop.current_epoch\nfinal_state = prop.current_state()\n\n# Validate propagation completed\nassert final_epoch == epoch + 3600.0\nassert len(final_state) == 6\nassert np.linalg.norm(final_state[:3]) &gt; bh.R_EARTH  # Still in orbit\n\nprint(f\"Initial epoch: {epoch}\")\nprint(f\"Final epoch:   {final_epoch}\")\nprint(\n    f\"Position (km): [{final_state[0] / 1e3:.3f}, {final_state[1] / 1e3:.3f}, {final_state[2] / 1e3:.3f}]\"\n)\nprint(\n    f\"Velocity (m/s): [{final_state[3]:.3f}, {final_state[4]:.3f}, {final_state[5]:.3f}]\"\n)\nprint(\"Example validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define orbital elements: [a, e, i, raan, argp, M] in SI units\n    // LEO satellite: 500 km altitude, near-circular, sun-synchronous inclination\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8,\n        15.0,\n        30.0,\n        45.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Parameters: [mass, drag_area, Cd, srp_area, Cr]\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator with default configuration\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,  // No additional dynamics\n        None,  // No control input\n        None,  // No initial covariance\n    )\n    .unwrap();\n\n    // Propagate for 1 hour\n    prop.propagate_to(epoch + 3600.0);\n\n    // Get final state\n    let final_epoch = prop.current_epoch();\n    let final_state = prop.current_state();\n\n    // Validate propagation completed\n    assert_eq!(final_epoch, epoch + 3600.0);\n    assert_eq!(final_state.len(), 6);\n    assert!(final_state.fixed_rows::&lt;3&gt;(0).norm() &gt; bh::R_EARTH);\n\n    println!(\"Initial epoch: {}\", epoch);\n    println!(\"Final epoch:   {}\", final_epoch);\n    println!(\n        \"Position (km): [{:.3}, {:.3}, {:.3}]\",\n        final_state[0] / 1e3,\n        final_state[1] / 1e3,\n        final_state[2] / 1e3\n    );\n    println!(\n        \"Velocity (m/s): [{:.3}, {:.3}, {:.3}]\",\n        final_state[3], final_state[4], final_state[5]\n    );\n    println!(\"Example validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#section-contents","title":"Section Contents","text":"<ul> <li>Numerical Orbit Propagator - Getting started with numerical propagation</li> <li>Force Models - Configuring physical force models</li> <li>Integrator Configuration - Choosing integration methods</li> <li>Event Detection - Detecting orbital events</li> <li>Premade Events - Built-in event types</li> <li>Event Callbacks - Responding to detected events</li> <li>Maneuvers - Impulsive and continuous thrust</li> <li>Covariance and Sensitivity - Uncertainty propagation</li> <li>Extending Spacecraft State - Additional state variables</li> <li>General Dynamics Propagation - Propagating arbitrary ODEs</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/index.html#see-also","title":"See Also","text":"<ul> <li>NumericalOrbitPropagator API Reference</li> <li>NumericalPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html","title":"Covariance and Sensitivity","text":"<p>The <code>NumericalOrbitPropagator</code> can propagate additional quantities alongside the orbital state, enabling covariance propagation and sensitivity analysis. This is essential for uncertainty quantification, orbit determination, and mission analysis.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#full-example","title":"Full Example","text":"<p>Here is a complete example demonstrating STM, covariance, and sensitivity propagation together:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state (LEO satellite)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Define spacecraft parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagation config enabling STM and sensitivity with history storage\nprop_config = (\n    bh.NumericalPropagationConfig.default()\n    .with_stm()\n    .with_stm_history()\n    .with_sensitivity()\n    .with_sensitivity_history()\n)\n\n# Define initial covariance (diagonal)\n# Position uncertainty: 10 m (variance = 100 m\u00b2)\n# Velocity uncertainty: 0.01 m/s (variance = 0.0001 m\u00b2/s\u00b2)\nP0 = np.diag([100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001])\n\n# Create propagator with full force model\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.default(),\n    params=params,\n    initial_covariance=P0,\n)\n\nprint(\"=== Variational Propagation Overview ===\\n\")\nprint(\"Initial State:\")\nprint(f\"  Semi-major axis: {oe[0] / 1000:.1f} km\")\nprint(f\"  Position std: {np.sqrt(P0[0, 0]):.1f} m\")\nprint(f\"  Velocity std: {np.sqrt(P0[3, 3]) * 1000:.2f} mm/s\")\n\n# Propagate for one orbital period\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + orbital_period)\n\n# === STM Access ===\nprint(\"\\n--- State Transition Matrix (STM) ---\")\nstm = prop.stm()\nprint(f\"STM shape: {stm.shape}\")\nprint(\n    f\"STM determinant: {np.linalg.det(stm):.6f} (should be ~1 for conservative forces)\"\n)\n\n# STM at intermediate time (half orbit)\nstm_half = prop.stm_at(epoch + orbital_period / 2)\nprint(f\"STM at t/2 available: {stm_half is not None}\")\n\n# === Covariance Propagation ===\nprint(\"\\n--- Covariance Propagation ---\")\n\n# Manual propagation: P(t) = STM @ P0 @ STM^T\nP_manual = stm @ P0 @ stm.T\n\n# Using built-in covariance retrieval\nP_gcrf = prop.covariance_gcrf(epoch + orbital_period)\nP_rtn = prop.covariance_rtn(epoch + orbital_period)\n\n# Extract position uncertainties\npos_std_gcrf = np.sqrt(np.diag(P_gcrf[:3, :3]))\npos_std_rtn = np.sqrt(np.diag(P_rtn[:3, :3]))\n\nprint(\"Position std (GCRF frame):\")\nprint(\n    f\"  X: {pos_std_gcrf[0]:.1f} m, Y: {pos_std_gcrf[1]:.1f} m, Z: {pos_std_gcrf[2]:.1f} m\"\n)\nprint(\"Position std (RTN frame):\")\nprint(\n    f\"  R: {pos_std_rtn[0]:.1f} m, T: {pos_std_rtn[1]:.1f} m, N: {pos_std_rtn[2]:.1f} m\"\n)\n\n# === Sensitivity Analysis ===\nprint(\"\\n--- Parameter Sensitivity ---\")\nsens = prop.sensitivity()\nprint(f\"Sensitivity matrix shape: {sens.shape}\")\n\n# Position sensitivity magnitude to each parameter\nparam_names = [\"mass\", \"drag_area\", \"Cd\", \"srp_area\", \"Cr\"]\nprint(\"\\nPosition sensitivity to 1% parameter uncertainty:\")\nfor i, name in enumerate(param_names):\n    pos_sens_mag = np.linalg.norm(sens[:3, i])\n    param_uncertainty = params[i] * 0.01  # 1% uncertainty\n    pos_error = pos_sens_mag * param_uncertainty\n    print(f\"  {name:10s}: {pos_error:.2f} m\")\n\n# === Summary ===\nprint(\"\\n--- Summary ---\")\ntotal_pos_std_initial = np.sqrt(np.trace(P0[:3, :3]))\ntotal_pos_std_final = np.sqrt(np.trace(P_gcrf[:3, :3]))\nprint(\n    f\"Total position uncertainty: {total_pos_std_initial:.1f} m -&gt; {total_pos_std_final:.1f} m\"\n)\nprint(f\"Uncertainty growth factor: {total_pos_std_final / total_pos_std_initial:.1f}x\")\n\n# Validate outputs\nassert stm.shape == (6, 6)\nassert sens.shape == (6, 5)\nassert P_gcrf.shape == (6, 6)\nassert P_rtn.shape == (6, 6)\nassert total_pos_std_final &gt;= total_pos_std_initial\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DOrbitCovarianceProvider, DStatePropagator};\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state (LEO satellite)\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Define spacecraft parameters: [mass, drag_area, Cd, srp_area, Cr]\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagation config enabling STM and sensitivity with history storage\n    let mut prop_config = bh::NumericalPropagationConfig::default();\n    prop_config.variational.enable_stm = true;\n    prop_config.variational.store_stm_history = true;\n    prop_config.variational.enable_sensitivity = true;\n    prop_config.variational.store_sensitivity_history = true;\n\n    // Define initial covariance (diagonal)\n    // Position uncertainty: 10 m (variance = 100 m\u00b2)\n    // Velocity uncertainty: 0.01 m/s (variance = 0.0001 m\u00b2/s\u00b2)\n    let p0: na::DMatrix&lt;f64&gt; = na::DMatrix::from_diagonal(&amp;na::DVector::from_vec(vec![\n        100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001,\n    ]));\n\n    // Create propagator with full force model\n    // Arguments: epoch, state, config, force_config, params, additional_dynamics, control_input, initial_covariance\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        prop_config,\n        bh::ForceModelConfig::default(),\n        Some(params.clone()),\n        None,  // additional_dynamics\n        None,  // control_input\n        Some(p0.clone()),  // initial_covariance\n    )\n    .unwrap();\n\n    println!(\"=== Variational Propagation Overview ===\\n\");\n    println!(\"Initial State:\");\n    println!(\"  Semi-major axis: {:.1} km\", oe[0] / 1000.0);\n    println!(\"  Position std: {:.1} m\", p0[(0, 0)].sqrt());\n    println!(\"  Velocity std: {:.2} mm/s\", p0[(3, 3)].sqrt() * 1000.0);\n\n    // Propagate for one orbital period\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + orbital_period);\n\n    // === STM Access ===\n    println!(\"\\n--- State Transition Matrix (STM) ---\");\n    let stm = prop.stm().expect(\"STM should be available\");\n    println!(\"STM shape: ({}, {})\", stm.nrows(), stm.ncols());\n    println!(\n        \"STM determinant: {:.6} (should be ~1 for conservative forces)\",\n        stm.determinant()\n    );\n\n    // STM at intermediate time (half orbit)\n    let stm_half = prop.stm_at(epoch + orbital_period / 2.0);\n    println!(\"STM at t/2 available: {}\", stm_half.is_some());\n\n    // === Covariance Propagation ===\n    println!(\"\\n--- Covariance Propagation ---\");\n\n    // Manual propagation: P(t) = STM @ P0 @ STM^T\n    let _p_manual = stm * &amp;p0 * stm.transpose();\n\n    // Using built-in covariance retrieval\n    let p_gcrf = prop.covariance_gcrf(epoch + orbital_period).unwrap();\n    let p_rtn = prop.covariance_rtn(epoch + orbital_period).unwrap();\n\n    // Extract position uncertainties\n    println!(\"Position std (GCRF frame):\");\n    println!(\n        \"  X: {:.1} m, Y: {:.1} m, Z: {:.1} m\",\n        p_gcrf[(0, 0)].sqrt(),\n        p_gcrf[(1, 1)].sqrt(),\n        p_gcrf[(2, 2)].sqrt()\n    );\n    println!(\"Position std (RTN frame):\");\n    println!(\n        \"  R: {:.1} m, T: {:.1} m, N: {:.1} m\",\n        p_rtn[(0, 0)].sqrt(),\n        p_rtn[(1, 1)].sqrt(),\n        p_rtn[(2, 2)].sqrt()\n    );\n\n    // === Sensitivity Analysis ===\n    println!(\"\\n--- Parameter Sensitivity ---\");\n    let sens = prop.sensitivity().expect(\"Sensitivity should be available\");\n    println!(\"Sensitivity matrix shape: ({}, {})\", sens.nrows(), sens.ncols());\n\n    // Position sensitivity magnitude to each parameter\n    let param_names = [\"mass\", \"drag_area\", \"Cd\", \"srp_area\", \"Cr\"];\n    println!(\"\\nPosition sensitivity to 1% parameter uncertainty:\");\n    for (i, name) in param_names.iter().enumerate() {\n        let pos_sens = na::Vector3::new(sens[(0, i)], sens[(1, i)], sens[(2, i)]);\n        let pos_sens_mag = pos_sens.norm();\n        let param_uncertainty = params[i] * 0.01; // 1% uncertainty\n        let pos_error = pos_sens_mag * param_uncertainty;\n        println!(\"  {:10}: {:.2} m\", name, pos_error);\n    }\n\n    // === Summary ===\n    println!(\"\\n--- Summary ---\");\n    let total_pos_std_initial = (p0[(0, 0)] + p0[(1, 1)] + p0[(2, 2)]).sqrt();\n    let total_pos_std_final = (p_gcrf[(0, 0)] + p_gcrf[(1, 1)] + p_gcrf[(2, 2)]).sqrt();\n    println!(\n        \"Total position uncertainty: {:.1} m -&gt; {:.1} m\",\n        total_pos_std_initial, total_pos_std_final\n    );\n    println!(\n        \"Uncertainty growth factor: {:.1}x\",\n        total_pos_std_final / total_pos_std_initial\n    );\n\n    // Validate outputs\n    assert_eq!(stm.nrows(), 6);\n    assert_eq!(stm.ncols(), 6);\n    assert_eq!(sens.nrows(), 6);\n    assert_eq!(sens.ncols(), 5);\n    assert_eq!(p_gcrf.nrows(), 6);\n    assert_eq!(p_rtn.nrows(), 6);\n    assert!(total_pos_std_final &gt;= total_pos_std_initial);\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#architecture-overview","title":"Architecture Overview","text":""},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Variational propagation is configured through the <code>VariationalConfig</code> within <code>NumericalPropagationConfig</code>:</p> <pre><code>NumericalPropagationConfig\n\u251c\u2500\u2500 method: IntegrationMethod\n\u251c\u2500\u2500 integrator: IntegratorConfig\n\u2514\u2500\u2500 variational: VariationalConfig\n    \u251c\u2500\u2500 enable_stm: bool\n    \u251c\u2500\u2500 enable_sensitivity: bool\n    \u251c\u2500\u2500 store_stm_history: bool\n    \u251c\u2500\u2500 store_sensitivity_history: bool\n    \u251c\u2500\u2500 jacobian_method: DifferenceMethod\n    \u2514\u2500\u2500 sensitivity_method: DifferenceMethod\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#auto-enable-behavior","title":"Auto-Enable Behavior","text":"<p>Providing <code>initial_covariance</code> when creating the propagator automatically enables STM propagation, even without explicitly setting <code>enable_stm = true</code>.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#state-transition-matrices-stm","title":"State Transition Matrices (STM)","text":"<p>The State Transition Matrix (STM) is a foundational tool for linear uncertainty propagation. It describes how small perturbations in the initial state map to perturbations at a later time:</p> \\[\\delta \\mathbf{x}(t) = \\Phi(t, t_0) \\delta \\mathbf{x}(t_0)\\] <p>where \\(\\Phi(t, t_0)\\) is the 6x6 STM from epoch \\(t_0\\) to time \\(t\\).</p>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#stm-structure","title":"STM Structure","text":"<p>For orbital mechanics with state \\(\\mathbf{x} = [x, y, z, v_x, v_y, v_z]^T\\), the 6x6 STM has structure:</p> \\[\\Phi = \\begin{bmatrix} \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{r}_0} &amp; \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{v}_0} \\\\ \\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{r}_0} &amp; \\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{v}_0} \\end{bmatrix}\\] Submatrix Location Physical Meaning \\(\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{r}_0}\\) Upper left Position sensitivity to initial position \\(\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{v}_0}\\) Upper right Position sensitivity to initial velocity \\(\\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{r}_0}\\) Lower left Velocity sensitivity to initial position \\(\\frac{\\partial \\mathbf{v}}{\\partial \\mathbf{v}_0}\\) Lower right Velocity sensitivity to initial velocity"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#stm-properties","title":"STM Properties","text":"<p>The STM has several important mathematical properties:</p> <ol> <li> <p>Identity at initial time: \\(\\Phi(t_0, t_0) = I\\)</p> </li> <li> <p>Composition: STMs can be composed to span longer intervals:    \\(\\Phi(t_2, t_0) = \\Phi(t_2, t_1) \\Phi(t_1, t_0)\\)</p> </li> <li> <p>Determinant preservation: For Hamiltonian systems (conservative forces only), \\(\\det(\\Phi) = 1\\)</p> </li> </ol>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#enabling-stm-propagation","title":"Enabling STM Propagation","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Method 1: Enable STM via builder pattern\nprop_config = bh.NumericalPropagationConfig.default().with_stm().with_stm_history()\n\n# Create propagator with two-body gravity\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\nprint(\"=== STM Propagation Example ===\\n\")\n\n# Propagate for one orbital period\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + orbital_period)\n\n# Access STM at final time\nstm = prop.stm()\nprint(f\"Final STM shape: {stm.shape}\")\nprint(f\"STM determinant: {np.linalg.det(stm):.6f}\")\n\n# STM at initial time should be identity\nstm_initial = prop.stm_at(epoch)\nprint(\"\\nSTM at t=0 (should be identity):\")\nprint(f\"  Max off-diagonal: {np.max(np.abs(stm_initial - np.eye(6))):.2e}\")\n\n# STM at intermediate time\nhalf_period = epoch + orbital_period / 2\nstm_half = prop.stm_at(half_period)\nprint(\"\\nSTM at t=T/2:\")\nprint(f\"  Determinant: {np.linalg.det(stm_half):.6f}\")\n\n# STM composition property: Phi(t2,t0) = Phi(t2,t1) * Phi(t1,t0)\n# For verification, we check that the STM is invertible\nstm_inv = np.linalg.inv(stm)\nidentity_check = stm @ stm_inv\nprint(\"\\nSTM * STM^-1 (should be identity):\")\nprint(f\"  Max deviation from I: {np.max(np.abs(identity_check - np.eye(6))):.2e}\")\n\n# STM structure interpretation\nprint(\"\\n=== STM Structure ===\")\nprint(\"Upper-left 3x3: Position sensitivity to initial position\")\nprint(\"Upper-right 3x3: Position sensitivity to initial velocity\")\nprint(\"Lower-left 3x3: Velocity sensitivity to initial position\")\nprint(\"Lower-right 3x3: Velocity sensitivity to initial velocity\")\n\n# Show magnitude of each block\npos_pos = np.linalg.norm(stm[:3, :3])\npos_vel = np.linalg.norm(stm[:3, 3:])\nvel_pos = np.linalg.norm(stm[3:, :3])\nvel_vel = np.linalg.norm(stm[3:, 3:])\n\nprint(\"\\nBlock Frobenius norms after one orbit:\")\nprint(f\"  dr/dr0: {pos_pos:.2f}\")\nprint(f\"  dr/dv0: {pos_vel:.2f}\")\nprint(f\"  dv/dr0: {vel_pos:.6f}\")\nprint(f\"  dv/dv0: {vel_vel:.2f}\")\n\n# Validate\nassert stm.shape == (6, 6)\nassert np.abs(np.linalg.det(stm) - 1.0) &lt; 1e-6  # Hamiltonian system preserves volume\nassert stm_initial is not None\nassert stm_half is not None\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Enable STM via config\n    let mut prop_config = bh::NumericalPropagationConfig::default();\n    prop_config.variational.enable_stm = true;\n    prop_config.variational.store_stm_history = true;\n\n    // Create propagator with two-body gravity\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        prop_config,\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    println!(\"=== STM Propagation Example ===\\n\");\n\n    // Propagate for one orbital period\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + orbital_period);\n\n    // Access STM at final time\n    let stm = prop.stm().expect(\"STM should be available\");\n    println!(\"Final STM shape: ({}, {})\", stm.nrows(), stm.ncols());\n    println!(\"STM determinant: {:.6}\", stm.determinant());\n\n    // STM at initial time should be identity\n    let stm_initial = prop.stm_at(epoch).expect(\"STM at t=0 should be available\");\n    let identity = na::DMatrix::identity(6, 6);\n    let max_diff = (&amp;stm_initial - &amp;identity).abs().max();\n    println!(\"\\nSTM at t=0 (should be identity):\");\n    println!(\"  Max off-diagonal: {:.2e}\", max_diff);\n\n    // STM at intermediate time\n    let half_period = epoch + orbital_period / 2.0;\n    let stm_half = prop.stm_at(half_period).expect(\"STM at t=T/2 should be available\");\n    println!(\"\\nSTM at t=T/2:\");\n    println!(\"  Determinant: {:.6}\", stm_half.determinant());\n\n    // STM composition property verification\n    let stm_inv = stm.clone().try_inverse().expect(\"STM should be invertible\");\n    let identity_check = stm * &amp;stm_inv;\n    let max_deviation = (&amp;identity_check - &amp;identity).abs().max();\n    println!(\"\\nSTM * STM^-1 (should be identity):\");\n    println!(\"  Max deviation from I: {:.2e}\", max_deviation);\n\n    // STM structure interpretation\n    println!(\"\\n=== STM Structure ===\");\n    println!(\"Upper-left 3x3: Position sensitivity to initial position\");\n    println!(\"Upper-right 3x3: Position sensitivity to initial velocity\");\n    println!(\"Lower-left 3x3: Velocity sensitivity to initial position\");\n    println!(\"Lower-right 3x3: Velocity sensitivity to initial velocity\");\n\n    // Show magnitude of each block\n    let stm = prop.stm().unwrap();\n    let pos_pos = stm.view((0, 0), (3, 3)).norm();\n    let pos_vel = stm.view((0, 3), (3, 3)).norm();\n    let vel_pos = stm.view((3, 0), (3, 3)).norm();\n    let vel_vel = stm.view((3, 3), (3, 3)).norm();\n\n    println!(\"\\nBlock Frobenius norms after one orbit:\");\n    println!(\"  dr/dr0: {:.2}\", pos_pos);\n    println!(\"  dr/dv0: {:.2}\", pos_vel);\n    println!(\"  dv/dr0: {:.6}\", vel_pos);\n    println!(\"  dv/dv0: {:.2}\", vel_vel);\n\n    // Validate\n    assert_eq!(stm.nrows(), 6);\n    assert_eq!(stm.ncols(), 6);\n    assert!((stm.determinant() - 1.0).abs() &lt; 1e-6); // Hamiltonian system preserves volume\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#covariance-propagation","title":"Covariance Propagation","text":"<p>The primary application of the STM is propagating uncertainty. Given an initial covariance \\(P_0\\), the propagated covariance is:</p> \\[P(t) = \\Phi(t, t_0) P_0 \\Phi(t, t_0)^T\\]"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#creating-a-propagator-with-initial-covariance","title":"Creating a Propagator with Initial Covariance","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagation config with STM enabled\nprop_config = bh.NumericalPropagationConfig.default().with_stm()\n\n# Create propagator (two-body for clean demonstration)\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Define initial covariance (diagonal)\n# Position uncertainty: 10 m in each axis\n# Velocity uncertainty: 0.01 m/s in each axis\nP0 = np.diag([100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001])\n\nprint(\"Initial Covariance (diagonal, sqrt):\")\nprint(f\"  Position std: {np.sqrt(P0[0, 0]):.1f} m\")\nprint(f\"  Velocity std: {np.sqrt(P0[3, 3]) * 1000:.2f} mm/s\")\n\n# Propagate for one orbital period\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + orbital_period)\n\n# Get the State Transition Matrix\nstm = prop.stm()\nprint(f\"\\nSTM shape: {stm.shape}\")\n\n# Propagate covariance: P(t) = Phi @ P0 @ Phi^T\nP = stm @ P0 @ stm.T\n\n# Extract position and velocity uncertainties\npos_cov = P[:3, :3]\nvel_cov = P[3:, 3:]\n\nprint(\"\\nPropagated Covariance after one orbit:\")\nprint(\n    f\"  Position std (x,y,z): ({np.sqrt(pos_cov[0, 0]):.1f}, {np.sqrt(pos_cov[1, 1]):.1f}, {np.sqrt(pos_cov[2, 2]):.1f}) m\"\n)\nprint(\n    f\"  Velocity std (x,y,z): ({np.sqrt(vel_cov[0, 0]) * 1000:.2f}, {np.sqrt(vel_cov[1, 1]) * 1000:.2f}, {np.sqrt(vel_cov[2, 2]) * 1000:.2f}) mm/s\"\n)\n\n# Compute position uncertainty magnitude\npos_uncertainty_initial = np.sqrt(np.trace(P0[:3, :3]))\npos_uncertainty_final = np.sqrt(np.trace(pos_cov))\n\nprint(\"\\nTotal position uncertainty:\")\nprint(f\"  Initial: {pos_uncertainty_initial:.1f} m\")\nprint(f\"  Final:   {pos_uncertainty_final:.1f} m\")\nprint(f\"  Growth:  {pos_uncertainty_final / pos_uncertainty_initial:.1f}x\")\n\n# Validate that covariance was propagated\nassert stm is not None\nassert stm.shape == (6, 6)\nassert pos_uncertainty_final &gt;= pos_uncertainty_initial  # Uncertainty grows\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Create propagation config with STM enabled\n    let mut prop_config = bh::NumericalPropagationConfig::default();\n    prop_config.variational.enable_stm = true;\n\n    // Create propagator (two-body for clean demonstration)\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        prop_config,\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Define initial covariance (diagonal)\n    // Position uncertainty: 10 m in each axis (100 m\u00b2 variance)\n    // Velocity uncertainty: 0.01 m/s in each axis (0.0001 m\u00b2/s\u00b2 variance)\n    let p0: na::DMatrix&lt;f64&gt; = na::DMatrix::from_diagonal(&amp;na::DVector::from_vec(vec![\n        100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001,\n    ]));\n\n    println!(\"Initial Covariance (diagonal, sqrt):\");\n    println!(\"  Position std: {:.1} m\", p0[(0, 0)].sqrt());\n    println!(\"  Velocity std: {:.2} mm/s\", p0[(3, 3)].sqrt() * 1000.0);\n\n    // Propagate for one orbital period\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + orbital_period);\n\n    // Get the State Transition Matrix\n    let stm = prop.stm().expect(\"STM should be available\").clone();\n    println!(\"\\nSTM shape: ({}, {})\", stm.nrows(), stm.ncols());\n\n    // Propagate covariance: P(t) = Phi @ P0 @ Phi^T\n    let p = &amp;stm * &amp;p0 * stm.transpose();\n\n    // Extract position and velocity uncertainties\n    let pos_std_x = p[(0, 0)].sqrt();\n    let pos_std_y = p[(1, 1)].sqrt();\n    let pos_std_z = p[(2, 2)].sqrt();\n    let vel_std_x = p[(3, 3)].sqrt() * 1000.0;\n    let vel_std_y = p[(4, 4)].sqrt() * 1000.0;\n    let vel_std_z = p[(5, 5)].sqrt() * 1000.0;\n\n    println!(\"\\nPropagated Covariance after one orbit:\");\n    println!(\n        \"  Position std (x,y,z): ({:.1}, {:.1}, {:.1}) m\",\n        pos_std_x, pos_std_y, pos_std_z\n    );\n    println!(\n        \"  Velocity std (x,y,z): ({:.2}, {:.2}, {:.2}) mm/s\",\n        vel_std_x, vel_std_y, vel_std_z\n    );\n\n    // Compute position uncertainty magnitude\n    let pos_uncertainty_initial = (p0[(0, 0)] + p0[(1, 1)] + p0[(2, 2)]).sqrt();\n    let pos_uncertainty_final = (p[(0, 0)] + p[(1, 1)] + p[(2, 2)]).sqrt();\n\n    println!(\"\\nTotal position uncertainty:\");\n    println!(\"  Initial: {:.1} m\", pos_uncertainty_initial);\n    println!(\"  Final:   {:.1} m\", pos_uncertainty_final);\n    println!(\n        \"  Growth:  {:.1}x\",\n        pos_uncertainty_final / pos_uncertainty_initial\n    );\n\n    // Validate that covariance was propagated\n    assert_eq!(stm.nrows(), 6);\n    assert_eq!(stm.ncols(), 6);\n    assert!(pos_uncertainty_final &gt;= pos_uncertainty_initial); // Uncertainty grows\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#covariance-in-rtn-frame","title":"Covariance in RTN Frame","text":"<p>The RTN (Radial-Tangential-Normal) frame provides physical insight into how uncertainty evolves relative to the orbit.</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Enable STM for covariance propagation\nprop_config = bh.NumericalPropagationConfig.default().with_stm().with_stm_history()\n\n# Define initial covariance in ECI frame\n# Position uncertainty: 10 m in each axis\n# Velocity uncertainty: 0.01 m/s in each axis\nP0 = np.diag([100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001])\n\n# Create propagator with initial covariance\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.two_body(),\n    None,\n    initial_covariance=P0,\n)\n\nprint(\"=== Covariance in RTN Frame ===\\n\")\nprint(\"Initial position std (ECI): 10.0 m in each axis\")\n\n# Propagate for one orbital period\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + orbital_period)\n\n# Get covariance in different frames\ntarget = epoch + orbital_period\nP_gcrf = prop.covariance_gcrf(target)\nP_rtn = prop.covariance_rtn(target)\n\n# Extract position covariances (3x3 upper-left block)\npos_cov_gcrf = P_gcrf[:3, :3]\npos_cov_rtn = P_rtn[:3, :3]\n\nprint(\"\\n--- GCRF Frame Results ---\")\nprint(\"Position std (X, Y, Z):\")\nprint(f\"  X: {np.sqrt(pos_cov_gcrf[0, 0]):.1f} m\")\nprint(f\"  Y: {np.sqrt(pos_cov_gcrf[1, 1]):.1f} m\")\nprint(f\"  Z: {np.sqrt(pos_cov_gcrf[2, 2]):.1f} m\")\n\nprint(\"\\n--- RTN Frame Results ---\")\nprint(\"Position std (R, T, N):\")\nprint(f\"  Radial (R):     {np.sqrt(pos_cov_rtn[0, 0]):.1f} m  &lt;- Altitude uncertainty\")\nprint(f\"  Tangential (T): {np.sqrt(pos_cov_rtn[1, 1]):.1f} m  &lt;- Along-track timing\")\nprint(f\"  Normal (N):     {np.sqrt(pos_cov_rtn[2, 2]):.1f} m  &lt;- Cross-track offset\")\n\n# Physical interpretation\nprint(\"\\n--- Physical Interpretation ---\")\nprint(\"RTN frame aligns with the orbit:\")\nprint(\"  R (Radial): Points from Earth center to satellite\")\nprint(\"  T (Tangential): Points along velocity direction\")\nprint(\"  N (Normal): Completes right-hand system (cross-track)\")\nprint()\nprint(\"Key insight: Along-track (T) uncertainty grows fastest because\")\nprint(\"velocity uncertainty causes timing errors that accumulate.\")\nprint(\n    f\"After one orbit: T/R ratio = {np.sqrt(pos_cov_rtn[1, 1]) / np.sqrt(pos_cov_rtn[0, 0]):.1f}x\"\n)\n\n# Show correlation structure\nprint(\"\\n--- Position Correlation Matrix (RTN) ---\")\npos_std_rtn = np.sqrt(np.diag(pos_cov_rtn))\ncorr_rtn = pos_cov_rtn / np.outer(pos_std_rtn, pos_std_rtn)\nprint(\"       R      T      N\")\nfor i, name in enumerate([\"R\", \"T\", \"N\"]):\n    print(\n        f\"  {name}  {corr_rtn[i, 0]:6.3f} {corr_rtn[i, 1]:6.3f} {corr_rtn[i, 2]:6.3f}\"\n    )\n\n# Validate\nassert P_gcrf.shape == (6, 6)\nassert P_rtn.shape == (6, 6)\nassert np.sqrt(pos_cov_rtn[1, 1]) &gt; np.sqrt(pos_cov_rtn[0, 0])  # T &gt; R\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DOrbitCovarianceProvider, DStatePropagator};\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Enable STM for covariance propagation\n    let mut prop_config = bh::NumericalPropagationConfig::default();\n    prop_config.variational.enable_stm = true;\n    prop_config.variational.store_stm_history = true;\n\n    // Define initial covariance in ECI frame\n    // Position uncertainty: 10 m in each axis\n    // Velocity uncertainty: 0.01 m/s in each axis\n    let p0: na::DMatrix&lt;f64&gt; = na::DMatrix::from_diagonal(&amp;na::DVector::from_vec(vec![\n        100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001,\n    ]));\n\n    // Create propagator with initial covariance\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        prop_config,\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        Some(p0),\n    )\n    .unwrap();\n\n    println!(\"=== Covariance in RTN Frame ===\\n\");\n    println!(\"Initial position std (ECI): 10.0 m in each axis\");\n\n    // Propagate for one orbital period\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + orbital_period);\n\n    // Get covariance in different frames\n    let target = epoch + orbital_period;\n    let p_gcrf = prop.covariance_gcrf(target).unwrap();\n    let p_rtn = prop.covariance_rtn(target).unwrap();\n\n    println!(\"\\n--- GCRF Frame Results ---\");\n    println!(\"Position std (X, Y, Z):\");\n    println!(\"  X: {:.1} m\", p_gcrf[(0, 0)].sqrt());\n    println!(\"  Y: {:.1} m\", p_gcrf[(1, 1)].sqrt());\n    println!(\"  Z: {:.1} m\", p_gcrf[(2, 2)].sqrt());\n\n    println!(\"\\n--- RTN Frame Results ---\");\n    println!(\"Position std (R, T, N):\");\n    println!(\n        \"  Radial (R):     {:.1} m  &lt;- Altitude uncertainty\",\n        p_rtn[(0, 0)].sqrt()\n    );\n    println!(\n        \"  Tangential (T): {:.1} m  &lt;- Along-track timing\",\n        p_rtn[(1, 1)].sqrt()\n    );\n    println!(\n        \"  Normal (N):     {:.1} m  &lt;- Cross-track offset\",\n        p_rtn[(2, 2)].sqrt()\n    );\n\n    // Physical interpretation\n    println!(\"\\n--- Physical Interpretation ---\");\n    println!(\"RTN frame aligns with the orbit:\");\n    println!(\"  R (Radial): Points from Earth center to satellite\");\n    println!(\"  T (Tangential): Points along velocity direction\");\n    println!(\"  N (Normal): Completes right-hand system (cross-track)\");\n    println!();\n    println!(\"Key insight: Along-track (T) uncertainty grows fastest because\");\n    println!(\"velocity uncertainty causes timing errors that accumulate.\");\n    println!(\n        \"After one orbit: T/R ratio = {:.1}x\",\n        p_rtn[(1, 1)].sqrt() / p_rtn[(0, 0)].sqrt()\n    );\n\n    // Show correlation structure\n    println!(\"\\n--- Position Correlation Matrix (RTN) ---\");\n    let std_r = p_rtn[(0, 0)].sqrt();\n    let std_t = p_rtn[(1, 1)].sqrt();\n    let std_n = p_rtn[(2, 2)].sqrt();\n\n    println!(\"       R      T      N\");\n    println!(\n        \"  R  {:6.3} {:6.3} {:6.3}\",\n        p_rtn[(0, 0)] / (std_r * std_r),\n        p_rtn[(0, 1)] / (std_r * std_t),\n        p_rtn[(0, 2)] / (std_r * std_n)\n    );\n    println!(\n        \"  T  {:6.3} {:6.3} {:6.3}\",\n        p_rtn[(1, 0)] / (std_t * std_r),\n        p_rtn[(1, 1)] / (std_t * std_t),\n        p_rtn[(1, 2)] / (std_t * std_n)\n    );\n    println!(\n        \"  N  {:6.3} {:6.3} {:6.3}\",\n        p_rtn[(2, 0)] / (std_n * std_r),\n        p_rtn[(2, 1)] / (std_n * std_t),\n        p_rtn[(2, 2)] / (std_n * std_n)\n    );\n\n    // Validate\n    assert_eq!(p_gcrf.nrows(), 6);\n    assert_eq!(p_rtn.nrows(), 6);\n    assert!(p_rtn[(1, 1)].sqrt() &gt; p_rtn[(0, 0)].sqrt()); // T &gt; R\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#rtn-frame-interpretation","title":"RTN Frame Interpretation","text":"Component Physical Meaning Typical Behavior Radial (R) Altitude uncertainty Bounded oscillation Tangential (T) Along-track timing Unbounded growth Normal (N) Cross-track offset Bounded oscillation <p>The along-track (tangential) uncertainty grows fastest because velocity uncertainty causes timing errors that accumulate over time. After one orbit, the T/R ratio is typically 20-30x.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#covariance-evolution-visualization","title":"Covariance Evolution Visualization","text":"<p>The following plot shows how position uncertainty evolves over three orbital periods in the ECI frame:</p> Plot Source covariance_evolution.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagation config with STM enabled and history storage\nprop_config = bh.NumericalPropagationConfig.default().with_stm().with_stm_history()\n\n# Create propagator (two-body for clean demonstration)\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Define initial covariance (diagonal)\n# Position uncertainty: 10 m in each axis (100 m\u00b2 variance)\n# Velocity uncertainty: 0.01 m/s in each axis (0.0001 m\u00b2/s\u00b2 variance)\nP0 = np.diag([100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001])\n\n# Propagate for 3 orbital periods\norbital_period = bh.orbital_period(oe[0])\ntotal_time = 3 * orbital_period\nprop.propagate_to(epoch + total_time)\n\n# Sample covariance evolution\ntimes = []  # in orbital periods\npos_sigma_r = []  # Radial (x) std dev\npos_sigma_t = []  # Tangential (y) std dev\npos_sigma_n = []  # Normal (z) std dev\npos_total = []  # Total position std dev\n\ndt = orbital_period / 50  # 50 samples per orbit\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    stm = prop.stm_at(current_epoch)\n\n    if stm is not None:\n        # Propagate covariance: P(t) = STM @ P0 @ STM^T\n        P = stm @ P0 @ stm.T\n\n        # Extract position standard deviations\n        sigma_x = np.sqrt(P[0, 0])\n        sigma_y = np.sqrt(P[1, 1])\n        sigma_z = np.sqrt(P[2, 2])\n\n        times.append(t / orbital_period)  # Convert to orbital periods\n        pos_sigma_r.append(sigma_x)\n        pos_sigma_t.append(sigma_y)\n        pos_sigma_n.append(sigma_z)\n        pos_total.append(np.sqrt(sigma_x**2 + sigma_y**2 + sigma_z**2))\n\n    t += dt\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Position uncertainty traces\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=pos_sigma_r,\n            mode=\"lines\",\n            name=\"X (radial-like)\",\n            line=dict(color=colors[\"primary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=pos_sigma_t,\n            mode=\"lines\",\n            name=\"Y (along-track-like)\",\n            line=dict(color=colors[\"secondary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=pos_sigma_n,\n            mode=\"lines\",\n            name=\"Z (cross-track-like)\",\n            line=dict(color=colors[\"accent\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=pos_total,\n            mode=\"lines\",\n            name=\"Total (RSS)\",\n            line=dict(color=colors[\"error\"], width=2, dash=\"dash\"),\n        )\n    )\n\n    # Initial uncertainty reference\n    initial_total = np.sqrt(3 * 100.0)  # sqrt(3 * 100 m\u00b2)\n    fig.add_hline(\n        y=initial_total,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        annotation_text=f\"Initial: {initial_total:.1f} m\",\n        annotation_position=\"top right\",\n    )\n\n    fig.update_layout(\n        title=\"Position Uncertainty Evolution (Two-Body)\",\n        xaxis_title=\"Time (orbital periods)\",\n        yaxis_title=\"Position Std Dev (m)\",\n        showlegend=True,\n        legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#rtn-covariance-evolution","title":"RTN Covariance Evolution","text":"<p>The RTN frame clearly shows why along-track error dominates:</p> Plot Source covariance_rtn_evolution.py<pre><code>import brahe as bh\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagation config with STM enabled and history storage\nprop_config = bh.NumericalPropagationConfig.default().with_stm().with_stm_history()\n\n# Define initial covariance (diagonal)\n# Position uncertainty: 10 m in each axis (100 m\u00b2 variance)\n# Velocity uncertainty: 0.01 m/s in each axis (0.0001 m\u00b2/s\u00b2 variance)\nP0 = np.diag([100.0, 100.0, 100.0, 0.0001, 0.0001, 0.0001])\n\n# Create propagator with initial covariance\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.two_body(),\n    None,\n    initial_covariance=P0,\n)\n\n# Propagate for 3 orbital periods\norbital_period = bh.orbital_period(oe[0])\ntotal_time = 3 * orbital_period\nprop.propagate_to(epoch + total_time)\n\n# Sample RTN covariance evolution using STM-based propagation\n# This avoids numerical issues with covariance interpolation\ntimes = []  # in orbital periods\nsigma_r = []  # Radial std dev\nsigma_t = []  # Tangential std dev\nsigma_n = []  # Normal std dev\n\ndt = orbital_period / 50  # 50 samples per orbit\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    stm = prop.stm_at(current_epoch)\n\n    if stm is not None:\n        # Propagate covariance in ECI: P(t) = STM @ P0 @ STM^T\n        P_eci = stm @ P0 @ stm.T\n\n        # Get state at current epoch to compute RTN rotation\n        state_t = prop.state(current_epoch)\n        if state_t is not None:\n            # Compute RTN rotation matrix from ECI state\n            r = state_t[:3]\n            v = state_t[3:]\n\n            # RTN basis vectors\n            r_hat = r / np.linalg.norm(r)  # Radial\n            h = np.cross(r, v)  # Angular momentum\n            n_hat = h / np.linalg.norm(h)  # Normal (cross-track)\n            t_hat = np.cross(n_hat, r_hat)  # Tangential (along-track)\n\n            # Rotation matrix from ECI to RTN (for position)\n            R_eci_to_rtn = np.array([r_hat, t_hat, n_hat])\n\n            # Transform position covariance to RTN\n            P_pos_eci = P_eci[:3, :3]\n            P_pos_rtn = R_eci_to_rtn @ P_pos_eci @ R_eci_to_rtn.T\n\n            times.append(t / orbital_period)\n            sigma_r.append(np.sqrt(P_pos_rtn[0, 0]))\n            sigma_t.append(np.sqrt(P_pos_rtn[1, 1]))\n            sigma_n.append(np.sqrt(P_pos_rtn[2, 2]))\n\n    t += dt\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # RTN uncertainty traces\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=sigma_r,\n            mode=\"lines\",\n            name=\"Radial (R)\",\n            line=dict(color=colors[\"primary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=sigma_t,\n            mode=\"lines\",\n            name=\"Tangential (T)\",\n            line=dict(color=colors[\"secondary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=sigma_n,\n            mode=\"lines\",\n            name=\"Normal (N)\",\n            line=dict(color=colors[\"accent\"], width=2),\n        )\n    )\n\n    # Add annotations for physical interpretation\n    fig.add_annotation(\n        x=2.5,\n        y=sigma_t[-1] * 0.9,\n        text=\"Along-track: unbounded growth\",\n        showarrow=False,\n        font=dict(size=10),\n    )\n\n    fig.add_annotation(\n        x=2.5,\n        y=sigma_r[-1] * 1.5,\n        text=\"Radial/Normal: bounded oscillation\",\n        showarrow=False,\n        font=dict(size=10),\n    )\n\n    # Initial uncertainty reference\n    initial_std = 10.0  # m\n    fig.add_hline(\n        y=initial_std,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        annotation_text=f\"Initial: {initial_std:.0f} m\",\n        annotation_position=\"top left\",\n    )\n\n    fig.update_layout(\n        title=\"Position Uncertainty Evolution in RTN Frame\",\n        xaxis_title=\"Time (orbital periods)\",\n        yaxis_title=\"Position Std Dev (m)\",\n        showlegend=True,\n        legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#sensitivity-propagation","title":"Sensitivity Propagation","text":"<p>In addition to STM propagation (which tracks sensitivity to initial state), the propagator can compute parameter sensitivity - how the state changes with respect to configuration parameters.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#parameter-sensitivity","title":"Parameter Sensitivity","text":"<p>The sensitivity matrix \\(S(t)\\) describes how the state at time \\(t\\) depends on the parameters:</p> \\[S(t) = \\frac{\\partial \\mathbf{x}(t)}{\\partial \\mathbf{p}}\\] <p>where \\(\\mathbf{p}\\) is the parameter vector. This enables answering questions like:</p> <ul> <li>\"How does a 1% uncertainty in drag coefficient affect position prediction?\"</li> <li>\"What is the impact of mass uncertainty on orbit determination?\"</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#configuration-parameters","title":"Configuration Parameters","text":"<p>The default parameter vector contains spacecraft physical properties:</p> Index Parameter Units Description 0 mass kg Spacecraft mass 1 drag_area m\u00b2 Cross-sectional area for drag 2 Cd - Drag coefficient 3 srp_area m\u00b2 Cross-sectional area for SRP 4 Cr - Solar radiation pressure coefficient"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#enabling-sensitivity-propagation","title":"Enabling Sensitivity Propagation","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 400e3, 0.01, 45.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagation config with sensitivity enabled\nprop_config = (\n    bh.NumericalPropagationConfig.default()\n    .with_sensitivity()\n    .with_sensitivity_history()\n)\n\n# Define spacecraft parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator with full force model (needed for parameter sensitivity)\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.default(),\n    params=params,\n)\n\nprint(\"Spacecraft Parameters:\")\nprint(f\"  Mass: {params[0]:.1f} kg\")\nprint(f\"  Drag area: {params[1]:.1f} m\u00b2\")\nprint(f\"  Drag coefficient (Cd): {params[2]:.1f}\")\nprint(f\"  SRP area: {params[3]:.1f} m\u00b2\")\nprint(f\"  SRP coefficient (Cr): {params[4]:.1f}\")\n\n# Propagate for one orbital period\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + orbital_period)\n\n# Get the sensitivity matrix (6 x 5)\nsens = prop.sensitivity()\n\nif sens is not None:\n    print(f\"\\nSensitivity Matrix shape: {sens.shape}\")\n    print(\n        \"(Rows: state components [x,y,z,vx,vy,vz], Cols: params [mass,A_d,Cd,A_s,Cr])\"\n    )\n\n    # Analyze position sensitivity to each parameter\n    pos_sens = sens[:3, :]  # First 3 rows\n    param_names = [\"mass\", \"drag_area\", \"Cd\", \"srp_area\", \"Cr\"]\n\n    print(\"\\nPosition sensitivity magnitude to each parameter:\")\n    for i, name in enumerate(param_names):\n        # Position sensitivity magnitude for this parameter\n        mag = np.linalg.norm(pos_sens[:, i])\n        print(f\"  {name:10s}: {mag:.3e} m per unit param\")\n\n    # Compute impact of 1% parameter uncertainties\n    print(\"\\nPosition error from 1% parameter uncertainty:\")\n    param_uncertainties = params * 0.01  # 1% of each parameter\n    for i, name in enumerate(param_names):\n        # dpos = sensitivity * dparam\n        pos_error = np.linalg.norm(pos_sens[:, i]) * param_uncertainties[i]\n        print(f\"  {name:10s}: {pos_error:.1f} m\")\n\n    # Total position error (RSS)\n    total_pos_error = 0.0\n    for i in range(len(params)):\n        pos_error = np.linalg.norm(pos_sens[:, i]) * param_uncertainties[i]\n        total_pos_error += pos_error**2\n    total_pos_error = np.sqrt(total_pos_error)\n    print(f\"\\n  Total (RSS): {total_pos_error:.1f} m\")\n\n    # Validate\n    assert sens.shape == (6, 5)\n    print(\"\\nExample validated successfully!\")\nelse:\n    print(\"\\nSensitivity not available (may require full force model)\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 400e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Create propagation config with sensitivity enabled\n    let mut prop_config = bh::NumericalPropagationConfig::default();\n    prop_config.variational.enable_sensitivity = true;\n    prop_config.variational.store_sensitivity_history = true;\n\n    // Define spacecraft parameters: [mass, drag_area, Cd, srp_area, Cr]\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator with full force model (needed for parameter sensitivity)\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        prop_config,\n        bh::ForceModelConfig::default(),\n        Some(params.clone()),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    println!(\"Spacecraft Parameters:\");\n    println!(\"  Mass: {:.1} kg\", params[0]);\n    println!(\"  Drag area: {:.1} m\u00b2\", params[1]);\n    println!(\"  Drag coefficient (Cd): {:.1}\", params[2]);\n    println!(\"  SRP area: {:.1} m\u00b2\", params[3]);\n    println!(\"  SRP coefficient (Cr): {:.1}\", params[4]);\n\n    // Propagate for one orbital period\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + orbital_period);\n\n    // Get the sensitivity matrix (6 x 5)\n    if let Some(sens) = prop.sensitivity() {\n        println!(\n            \"\\nSensitivity Matrix shape: ({}, {})\",\n            sens.nrows(),\n            sens.ncols()\n        );\n        println!(\"(Rows: state components [x,y,z,vx,vy,vz], Cols: params [mass,A_d,Cd,A_s,Cr])\");\n\n        let param_names = [\"mass\", \"drag_area\", \"Cd\", \"srp_area\", \"Cr\"];\n\n        println!(\"\\nPosition sensitivity magnitude to each parameter:\");\n        for (i, name) in param_names.iter().enumerate() {\n            // Position sensitivity magnitude for this parameter\n            let pos_sens = na::Vector3::new(sens[(0, i)], sens[(1, i)], sens[(2, i)]);\n            let mag = pos_sens.norm();\n            println!(\"  {:10}: {:.3e} m per unit param\", name, mag);\n        }\n\n        // Compute impact of 1% parameter uncertainties\n        println!(\"\\nPosition error from 1% parameter uncertainty:\");\n        let param_uncertainties: Vec&lt;f64&gt; = params.iter().map(|p| p * 0.01).collect();\n\n        let mut total_pos_error_sq = 0.0;\n        for (i, name) in param_names.iter().enumerate() {\n            let pos_sens = na::Vector3::new(sens[(0, i)], sens[(1, i)], sens[(2, i)]);\n            let pos_error = pos_sens.norm() * param_uncertainties[i];\n            total_pos_error_sq += pos_error.powi(2);\n            println!(\"  {:10}: {:.1} m\", name, pos_error);\n        }\n\n        let total_pos_error = total_pos_error_sq.sqrt();\n        println!(\"\\n  Total (RSS): {:.1} m\", total_pos_error);\n\n        // Validate\n        assert_eq!(sens.nrows(), 6);\n        assert_eq!(sens.ncols(), 5);\n        println!(\"\\nExample validated successfully!\");\n    } else {\n        println!(\"\\nSensitivity not available (may require full force model)\");\n    }\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#interpreting-sensitivity-results","title":"Interpreting Sensitivity Results","text":"<p>The sensitivity matrix \\(S\\) is 6x5 (state dimension x parameter count):</p> <ul> <li>Column 0: Sensitivity to mass - affects drag acceleration (\\(a \\propto 1/m\\))</li> <li>Column 1: Sensitivity to drag area - affects drag force</li> <li>Column 2: Sensitivity to Cd - drag coefficient uncertainty</li> <li>Column 3: Sensitivity to SRP area - solar radiation pressure</li> <li>Column 4: Sensitivity to Cr - SRP coefficient uncertainty</li> </ul> <p>Physical insights:</p> <ul> <li>For LEO orbits, drag parameters (mass, drag_area, Cd) typically dominate</li> <li>For GEO orbits, SRP parameters (srp_area, Cr) become more important</li> <li>Two-body propagation shows zero sensitivity (no force depends on parameters)</li> <li>Sensitivity grows over time as perturbation effects accumulate</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#sensitivity-evolution-visualization","title":"Sensitivity Evolution Visualization","text":"<p>The following plot shows how position sensitivity to each parameter evolves over time for a LEO orbit:</p> Plot Source sensitivity_evolution.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP and space weather data\n# (Space weather is required for NRLMSISE00 atmospheric model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state (LEO orbit with significant drag)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 400e3, 0.01, 45.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagation config with sensitivity enabled and history storage\nprop_config = (\n    bh.NumericalPropagationConfig.default()\n    .with_sensitivity()\n    .with_sensitivity_history()\n)\n\n# Define spacecraft parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator with full force model (uses NRLMSISE00 for drag)\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    prop_config,\n    bh.ForceModelConfig.default(),\n    params=params,\n)\n\n# Propagate for 3 orbital periods\norbital_period = bh.orbital_period(oe[0])\ntotal_time = 3 * orbital_period\nprop.propagate_to(epoch + total_time)\n\n# Sample sensitivity evolution\nparam_names = [\"mass\", \"drag_area\", \"Cd\", \"srp_area\", \"Cr\"]\ntimes = []  # in orbital periods\nsens_mag = {name: [] for name in param_names}  # Position sensitivity magnitude\n\ndt = orbital_period / 50  # 50 samples per orbit\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    sens = prop.sensitivity_at(current_epoch)\n\n    if sens is not None:\n        times.append(t / orbital_period)  # Convert to orbital periods\n\n        # Compute position sensitivity magnitude for each parameter\n        for i, name in enumerate(param_names):\n            pos_sens = np.linalg.norm(sens[:3, i])\n            sens_mag[name].append(pos_sens)\n\n    t += dt\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    color_map = {\n        \"mass\": colors[\"primary\"],\n        \"drag_area\": colors[\"secondary\"],\n        \"Cd\": colors[\"accent\"],\n        \"srp_area\": colors[\"error\"],\n        \"Cr\": \"gray\",\n    }\n\n    # Add traces for each parameter\n    for name in param_names:\n        if sens_mag[name]:\n            fig.add_trace(\n                go.Scatter(\n                    x=times,\n                    y=sens_mag[name],\n                    mode=\"lines\",\n                    name=name,\n                    line=dict(color=color_map[name], width=2),\n                )\n            )\n\n    fig.update_layout(\n        title=\"Position Sensitivity to Parameters (LEO, 400 km)\",\n        xaxis_title=\"Time (orbital periods)\",\n        yaxis_title=\"Position Sensitivity (m per unit param)\",\n        yaxis_type=\"log\",\n        showlegend=True,\n        legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#configuration-reference","title":"Configuration Reference","text":""},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#variationalconfig-options","title":"VariationalConfig Options","text":"Option Type Default Description <code>enable_stm</code> bool false Enable State Transition Matrix computation <code>enable_sensitivity</code> bool false Enable parameter sensitivity computation <code>store_stm_history</code> bool false Store STM at each trajectory point <code>store_sensitivity_history</code> bool false Store sensitivity at each trajectory point <code>jacobian_method</code> DifferenceMethod Central Finite difference method for Jacobian <code>sensitivity_method</code> DifferenceMethod Central Finite difference method for sensitivity"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#differencemethod-options","title":"DifferenceMethod Options","text":"Method Accuracy Cost Description Forward O(h) S+1 evaluations First-order forward differences Central O(h\u00b2) 2S evaluations Second-order central differences (default) Backward O(h) S+1 evaluations First-order backward differences"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#computational-considerations","title":"Computational Considerations","text":"<p>STM and sensitivity computation significantly increase computational cost:</p> Configuration State dimension Memory per step State only 6 ~48 bytes With STM 42 (6 + 36) ~336 bytes With Sensitivity 36 (6 + 30) ~288 bytes With Both 72 (6 + 36 + 30) ~576 bytes"},{"location":"learn/orbit_propagation/numerical_propagation/covariance_sensitivity.html#see-also","title":"See Also","text":"<ul> <li>Integrator Configuration - Variational equation settings</li> <li>Numerical Orbit Propagator - Propagator fundamentals</li> <li>Force Models - Force model configuration</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html","title":"Event Callbacks","text":"<p>Event callbacks allow you to respond to detected events during propagation. Callbacks can log information, inspect state, modify the spacecraft state (for impulsive maneuvers), or control propagation flow.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#callback-function-signature","title":"Callback Function Signature","text":"<p>To define a callback, create a function matching the following signature:</p> PythonRust <pre><code>def callback(epoch: Epoch, state: np.ndarray) -&gt; tuple[np.ndarray, EventAction]:\n    \"\"\"\n    Args:\n        epoch: The epoch when the event occurred\n        state: The spacecraft state vector at event time [x, y, z, vx, vy, vz]\n\n    Returns:\n        tuple: (new_state, action)\n            - new_state: Modified state vector (or original if unchanged)\n            - action: EventAction.CONTINUE or EventAction.STOP\n    \"\"\"\n    # Process event...\n    return (state, bh.EventAction.CONTINUE)\n</code></pre> <pre><code>type DEventCallback = Box&lt;\n    dyn Fn(\n        Epoch,                           // Event epoch\n        &amp;DVector&lt;f64&gt;,                   // Current state\n        Option&lt;&amp;DVector&lt;f64&gt;&gt;,           // Optional parameters\n    ) -&gt; (\n        Option&lt;DVector&lt;f64&gt;&gt;,            // New state (None = unchanged)\n        Option&lt;DVector&lt;f64&gt;&gt;,            // New params (None = unchanged)\n        EventAction,                     // Continue or Stop\n    ) + Send + Sync,\n&gt;;\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#eventaction-options","title":"EventAction Options","text":"<p>The callback return value includes an <code>EventAction</code> that controls propagation behavior:</p> Action Behavior <code>CONTINUE</code> Continue propagation after processing the event <code>STOP</code> Halt propagation immediately after the event"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#when-to-use-stop","title":"When to Use STOP","text":"<p>Use <code>EventAction.STOP</code> when:</p> <ul> <li>A terminal condition has been reached (e.g., re-entry)</li> <li>The propagation goal has been achieved</li> <li>An error condition is detected</li> <li>You want to examine state at a specific event before deciding to continue</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#when-to-use-continue","title":"When to Use CONTINUE","text":"<p>Use <code>EventAction.CONTINUE</code> for:</p> <ul> <li>Logging and monitoring events</li> <li>Impulsive maneuvers (state changes but propagation continues)</li> <li>Intermediate waypoints</li> <li>Data collection triggers</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#defining-callbacks","title":"Defining Callbacks","text":"<p>Callbacks receive the event epoch and state, and return a tuple containing the (possibly modified) state and an action directive.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#logging-callback","title":"Logging Callback","text":"<p>A simple callback that logs event information without modifying state:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state - elliptical orbit\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Track callback invocations\ncallback_count = 0\n\n\n# Define a logging callback\ndef logging_callback(event_epoch, event_state):\n    \"\"\"Log event details without modifying state.\"\"\"\n    global callback_count\n    callback_count += 1\n\n    # Compute orbital elements at event time\n    koe = bh.state_eci_to_koe(event_state, bh.AngleFormat.DEGREES)\n    altitude = koe[0] - bh.R_EARTH\n\n    print(f\"  Event #{callback_count}:\")\n    print(f\"    Epoch: {event_epoch}\")\n    print(f\"    Altitude: {altitude / 1e3:.1f} km\")\n    print(f\"    True anomaly: {koe[5]:.1f} deg\")\n\n    # Return unchanged state with CONTINUE action\n    return (event_state, bh.EventAction.CONTINUE)\n\n\n# Define a callback that stops propagation\ndef stop_callback(event_epoch, event_state):\n    \"\"\"Stop propagation when event occurs.\"\"\"\n    print(f\"  Stopping at {event_epoch}\")\n    return (event_state, bh.EventAction.STOP)\n\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Create time event with logging callback\nevent_log = bh.TimeEvent(epoch + 1000.0, \"Log Event\").with_callback(logging_callback)\nprop.add_event_detector(event_log)\n\n# Create another time event\nevent_log2 = bh.TimeEvent(epoch + 2000.0, \"Log Event 2\").with_callback(logging_callback)\nprop.add_event_detector(event_log2)\n\n# Propagate for half an orbit\norbital_period = bh.orbital_period(oe[0])\nprint(\"Propagating with logging callbacks:\")\nprop.propagate_to(epoch + orbital_period / 2)\n\nprint(f\"\\nCallback invoked {callback_count} times\")\n\n# Now demonstrate STOP action\nprint(\"\\nDemonstrating STOP action:\")\nprop2 = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Event that stops propagation at t+500s\nstop_event = bh.TimeEvent(epoch + 500.0, \"Stop Event\").with_callback(stop_callback)\nprop2.add_event_detector(stop_event)\n\n# Try to propagate for one full orbit\nprop2.propagate_to(epoch + orbital_period)\n\n# Check where propagation actually stopped\nactual_duration = prop2.current_epoch - epoch\nprint(f\"  Requested duration: {orbital_period:.1f}s\")\nprint(f\"  Actual duration: {actual_duration:.1f}s\")\nprint(f\"  Stopped early: {actual_duration &lt; orbital_period}\")\n\n# Validate\nassert callback_count == 2\nassert actual_duration &lt; orbital_period\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DEventCallback, DTimeEvent, EventAction};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state - elliptical orbit\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Track callback invocations\n    let callback_count = Arc::new(AtomicUsize::new(0));\n\n    // Define a logging callback\n    let count_ref = callback_count.clone();\n    let logging_callback: DEventCallback = Box::new(\n        move |event_epoch: bh::Epoch,\n              event_state: &amp;na::DVector&lt;f64&gt;,\n              _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;|\n              -&gt; (\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            EventAction,\n        ) {\n            let count = count_ref.fetch_add(1, Ordering::SeqCst) + 1;\n\n            // Compute orbital elements at event time\n            let state_vec = na::SVector::&lt;f64, 6&gt;::from_column_slice(event_state.as_slice());\n            let koe = bh::state_eci_to_koe(state_vec, bh::AngleFormat::Degrees);\n            let altitude = koe[0] - bh::R_EARTH;\n\n            println!(\"  Event #{}:\", count);\n            println!(\"    Epoch: {}\", event_epoch);\n            println!(\"    Altitude: {:.1} km\", altitude / 1e3);\n            println!(\"    True anomaly: {:.1} deg\", koe[5]);\n\n            // Return unchanged state with CONTINUE action\n            (None, None, EventAction::Continue)\n        },\n    );\n\n    // Define another logging callback for second event\n    let count_ref2 = callback_count.clone();\n    let logging_callback2: DEventCallback = Box::new(\n        move |event_epoch: bh::Epoch,\n              event_state: &amp;na::DVector&lt;f64&gt;,\n              _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;|\n              -&gt; (\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            EventAction,\n        ) {\n            let count = count_ref2.fetch_add(1, Ordering::SeqCst) + 1;\n\n            let state_vec = na::SVector::&lt;f64, 6&gt;::from_column_slice(event_state.as_slice());\n            let koe = bh::state_eci_to_koe(state_vec, bh::AngleFormat::Degrees);\n            let altitude = koe[0] - bh::R_EARTH;\n\n            println!(\"  Event #{}:\", count);\n            println!(\"    Epoch: {}\", event_epoch);\n            println!(\"    Altitude: {:.1} km\", altitude / 1e3);\n            println!(\"    True anomaly: {:.1} deg\", koe[5]);\n\n            (None, None, EventAction::Continue)\n        },\n    );\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Create time events with logging callbacks\n    let event_log = DTimeEvent::new(epoch + 1000.0, \"Log Event\".to_string())\n        .with_callback(logging_callback);\n    prop.add_event_detector(Box::new(event_log));\n\n    let event_log2 = DTimeEvent::new(epoch + 2000.0, \"Log Event 2\".to_string())\n        .with_callback(logging_callback2);\n    prop.add_event_detector(Box::new(event_log2));\n\n    // Propagate for half an orbit\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    println!(\"Propagating with logging callbacks:\");\n    prop.propagate_to(epoch + orbital_period / 2.0);\n\n    let final_count = callback_count.load(Ordering::SeqCst);\n    println!(\"\\nCallback invoked {} times\", final_count);\n\n    // Now demonstrate STOP action\n    println!(\"\\nDemonstrating STOP action:\");\n\n    // Define a callback that stops propagation\n    let stop_callback: DEventCallback = Box::new(\n        move |event_epoch: bh::Epoch,\n              _event_state: &amp;na::DVector&lt;f64&gt;,\n              _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;|\n              -&gt; (\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            EventAction,\n        ) {\n            println!(\"  Stopping at {}\", event_epoch);\n            (None, None, EventAction::Stop)\n        },\n    );\n\n    let mut prop2 = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Event that stops propagation at t+500s\n    let stop_event =\n        DTimeEvent::new(epoch + 500.0, \"Stop Event\".to_string()).with_callback(stop_callback);\n    prop2.add_event_detector(Box::new(stop_event));\n\n    // Try to propagate for one full orbit\n    prop2.propagate_to(epoch + orbital_period);\n\n    // Check where propagation actually stopped\n    let actual_duration = prop2.current_epoch() - epoch;\n    println!(\"  Requested duration: {:.1}s\", orbital_period);\n    println!(\"  Actual duration: {:.1}s\", actual_duration);\n    println!(\"  Stopped early: {}\", actual_duration &lt; orbital_period);\n\n    // Validate\n    assert_eq!(final_count, 2);\n    assert!(actual_duration &lt; orbital_period);\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#attaching-callbacks-to-events","title":"Attaching Callbacks to Events","text":"<p>Use the <code>with_callback()</code> method to attach a callback to any event detector:</p> <pre><code># Create event\nevent = bh.TimeEvent(target_epoch, \"My Event\")\n\n# Attach callback\nevent_with_callback = event.with_callback(my_callback_function)\n\n# Add to propagator\nprop.add_event_detector(event_with_callback)\n</code></pre> <p>The <code>with_callback()</code> method returns a new event detector with the callback attached, allowing method chaining.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#state-modification","title":"State Modification","text":"<p>Callbacks can modify the spacecraft state by returning a new state vector. This is the mechanism for implementing impulsive maneuvers.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#modifying-state","title":"Modifying State","text":"<pre><code>def velocity_change_callback(epoch, state):\n    new_state = state.copy()\n\n    # Add delta-v in velocity direction\n    v = state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    delta_v = 100.0  # m/s\n    new_state[3:6] += delta_v * v_hat\n\n    return (new_state, bh.EventAction.CONTINUE)\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#physical-consistency","title":"Physical Consistency","text":"<p>When modifying state, ensure physical consistency:</p> <ul> <li>Position changes are unusual except for specific scenarios</li> <li>Velocity changes should respect momentum conservation for realistic maneuvers</li> <li>Large changes may cause numerical issues in subsequent integration steps</li> </ul> <p>For complete impulsive maneuver examples, see Maneuvers.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#multiple-callbacks","title":"Multiple Callbacks","text":"<p>Each event detector can have one callback. For multiple actions at the same event, either:</p> <ol> <li>Perform all actions within a single callback</li> <li>Create multiple event detectors at the same time/condition</li> </ol> <pre><code># Single callback performing multiple actions\ndef multi_action_callback(epoch, state):\n    log_event(epoch, state)\n    record_telemetry(epoch, state)\n    new_state = apply_correction(state)\n    return (new_state, bh.EventAction.CONTINUE)\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#callback-execution-order","title":"Callback Execution Order","text":"<p>When multiple events occur at the same epoch:</p> <ol> <li>Events are processed in the order their detectors were added</li> <li>State modifications from earlier callbacks are passed to later callbacks</li> <li>If any callback returns <code>STOP</code>, propagation halts after all callbacks execute</li> </ol>"},{"location":"learn/orbit_propagation/numerical_propagation/event_callbacks.html#see-also","title":"See Also","text":"<ul> <li>Event Detection - Event detection fundamentals</li> <li>Premade Events - Built-in event types</li> <li>Maneuvers - Using callbacks for orbit maneuvers</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html","title":"Event Detection","text":"<p>The numerical propagator includes an event detection system that identifies specific orbital conditions during propagation. Events are defined by user-configurable detectors that monitor the spacecraft state and trigger when certain criteria are met. They can also be coupled with event callbacks to respond to detected events in real-time.</p> <p>When an event is detected, the propagator uses a bisection algorithm to precisely locate the event time within a specified tolerance. The detected events are logged and can be accessed after propagation. Users can also configure how an event will affect the propagation, such as stopping propagation or continuing without interruption.</p> <p>Events provide an extensible mechanism for implementing complex mission scenarios, such as maneuver execution, autonomous operations, and other condition-based actions.</p> <p>The library also provides a set of premade event detectors for common scenarios, which can be used directly or serve as templates for custom detectors. You can find more details about premade events in the Premade Events documentation with a complete list of available types in the library API docuementation at Premade Event Detectors.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#event-types","title":"Event Types","text":"<p>Brahe provides three event fundamental event detector types:</p> Type Trigger Condition <code>TimeEvent</code> Specific epoch reached <code>ValueEvent</code> Computed quantity crosses a given value <code>BinaryEvent</code> Boolean condition changes"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#adding-event-detectors","title":"Adding Event Detectors","text":"<p>Event detectors are added to the propagator before propagation:</p> <pre><code>prop = bh.NumericalOrbitPropagator(...)\nprop.add_event_detector(event1)\nprop.add_event_detector(event2)\nprop.propagate_to(end_epoch)\n</code></pre> <p>Multiple detectors can be active simultaneously.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#accessing-event-results","title":"Accessing Event Results","text":"<p>After propagation, detected events are available via the event log:</p> <pre><code>events = prop.event_log()\nfor event in events:\n    print(f\"Event '{event.name}' at {event.window_open}\")\n    print(f\"  State: {event.entry_state}\")\n</code></pre> <p>Each event record contains:</p> Field Description <code>name</code> Event detector name <code>window_open</code> Epoch when event occurred <code>window_close</code> Same as window_open for instantaneous events <code>entry_state</code> State vector at event time"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#time-events","title":"Time Events","text":"<p>Time events trigger at specific epochs. They're useful for scheduled operations like data collection windows, communication passes, or timed maneuvers.</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Add time events at specific epochs\nevent_30min = bh.TimeEvent(epoch + 1800.0, \"30-minute mark\")\nevent_1hr = bh.TimeEvent(epoch + 3600.0, \"1-hour mark\")\n\n# Add a terminal event that stops propagation\nevent_terminal = bh.TimeEvent(epoch + 5400.0, \"90-minute stop\").set_terminal()\n\nprop.add_event_detector(event_30min)\nprop.add_event_detector(event_1hr)\nprop.add_event_detector(event_terminal)\n\n# Propagate for 2 hours (will stop at 90 minutes due to terminal event)\nprop.propagate_to(epoch + 7200.0)\n\n# Check detected events\nevents = prop.event_log()\nprint(f\"Detected {len(events)} events:\")\nfor event in events:\n    dt = event.window_open - epoch\n    print(f\"  '{event.name}' at t+{dt:.1f}s\")\n\n# Verify propagation stopped at terminal event\nfinal_time = prop.current_epoch - epoch\nprint(f\"\\nPropagation stopped at: t+{final_time:.1f}s (requested: t+7200s)\")\n\n# Validate\nassert len(events) == 3  # All three events detected\nassert abs(final_time - 5400.0) &lt; 1.0  # Stopped at 90 min\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::DTimeEvent;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8,\n        15.0,\n        30.0,\n        45.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Add time events at specific epochs\n    let event_30min = DTimeEvent::new(epoch + 1800.0, \"30-minute mark\".to_string());\n    let event_1hr = DTimeEvent::new(epoch + 3600.0, \"1-hour mark\".to_string());\n\n    // Add a terminal event that stops propagation\n    let event_terminal =\n        DTimeEvent::new(epoch + 5400.0, \"90-minute stop\".to_string()).set_terminal();\n\n    prop.add_event_detector(Box::new(event_30min));\n    prop.add_event_detector(Box::new(event_1hr));\n    prop.add_event_detector(Box::new(event_terminal));\n\n    // Propagate for 2 hours (will stop at 90 minutes due to terminal event)\n    prop.propagate_to(epoch + 7200.0);\n\n    // Check detected events\n    let events = prop.event_log();\n    println!(\"Detected {} events:\", events.len());\n    for event in events {\n        let dt = event.window_open - epoch;\n        println!(\"  '{}' at t+{:.1}s\", event.name, dt);\n    }\n\n    // Verify propagation stopped at terminal event\n    let final_time = prop.current_epoch() - epoch;\n    println!(\n        \"\\nPropagation stopped at: t+{:.1}s (requested: t+7200s)\",\n        final_time\n    );\n\n    // Validate\n    assert_eq!(events.len(), 3); // All three events detected\n    assert!((final_time - 5400.0).abs() &lt; 1.0); // Stopped at 90 min\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#value-events","title":"Value Events","text":"<p>Value events trigger when a user-defined function crosses a value value. This is the most flexible event type, enabling detection of arbitrary orbital conditions.</p> <p>Value events are defined with a value function which accepts the current epoch and state vector, returning a scalar value.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#event-direction","title":"Event Direction","text":"<p>Value events can detect:</p> <ul> <li><code>INCREASING</code> - Value crosses value from below</li> <li><code>DECREASING</code> - Value crosses value from above</li> <li><code>ANY</code> - Any value crossing</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#custom-value-functions","title":"Custom Value Functions","text":"<p>The value function receives the current epoch and state vector, returning a scalar value:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n\n# Define custom value function: detect when z-component crosses zero\n# This detects equator crossings (ascending and descending node)\ndef z_position(epoch, state):\n    \"\"\"Return z-component of position (meters).\"\"\"\n    return state[2]\n\n\n# Create ValueEvent: detect when z crosses 0 (equator crossing)\n# Ascending node: z goes from negative to positive (INCREASING)\nascending_node = bh.ValueEvent(\n    \"Ascending Node\",\n    z_position,\n    0.0,  # target value\n    bh.EventDirection.INCREASING,\n)\n\n# Descending node: z goes from positive to negative (DECREASING)\ndescending_node = bh.ValueEvent(\n    \"Descending Node\",\n    z_position,\n    0.0,\n    bh.EventDirection.DECREASING,\n)\n\nprop.add_event_detector(ascending_node)\nprop.add_event_detector(descending_node)\n\n# Propagate for 3 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 3 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nascending = [e for e in events if \"Ascending\" in e.name]\ndescending = [e for e in events if \"Descending\" in e.name]\n\nprint(\"Equator crossings over 3 orbits:\")\nprint(f\"  Ascending nodes: {len(ascending)}\")\nprint(f\"  Descending nodes: {len(descending)}\")\n\nfor event in events[:6]:  # Show first 6\n    dt = event.window_open - epoch\n    z = event.entry_state[2]\n    print(f\"  '{event.name}' at t+{dt:.1f}s (z={z:.1f} m)\")\n\n# Validate\nassert len(ascending) == 3  # One per orbit\nassert len(descending) == 3  # One per orbit\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DValueEvent, EventDirection};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.01,\n        45.0,\n        0.0,\n        0.0,\n        0.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Create ValueEvent: detect when z crosses 0 (equator crossing)\n    // Ascending node: z goes from negative to positive (INCREASING)\n    let ascending_node_fn =\n        |_t: bh::Epoch, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| state[2];\n    let ascending_node = DValueEvent::new(\n        \"Ascending Node\",\n        ascending_node_fn, // z-component\n        0.0,               // target value\n        EventDirection::Increasing,\n    );\n\n    // Descending node: z goes from positive to negative (DECREASING)\n    let descending_node_fn =\n        |_t: bh::Epoch, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| state[2];\n    let descending_node = DValueEvent::new(\n        \"Descending Node\",\n        descending_node_fn,\n        0.0,\n        EventDirection::Decreasing,\n    );\n\n    prop.add_event_detector(Box::new(ascending_node));\n    prop.add_event_detector(Box::new(descending_node));\n\n    // Propagate for 3 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + 3.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    let ascending: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Ascending\"))\n        .collect();\n    let descending: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Descending\"))\n        .collect();\n\n    println!(\"Equator crossings over 3 orbits:\");\n    println!(\"  Ascending nodes: {}\", ascending.len());\n    println!(\"  Descending nodes: {}\", descending.len());\n\n    for event in events.iter().take(6) {\n        let dt = event.window_open - epoch;\n        let z = event.entry_state[2];\n        println!(\"  '{}' at t+{:.1}s (z={:.1} m)\", event.name, dt, z);\n    }\n\n    // Validate\n    assert_eq!(ascending.len(), 3); // One per orbit\n    assert_eq!(descending.len(), 3); // One per orbit\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#binary-events","title":"Binary Events","text":"<p>Binary events detect when a boolean condition transitions between true and false. They use <code>EdgeType</code> to specify which transition to detect:</p> <ul> <li><code>RISING_EDGE</code> - Condition becomes true (false \u2192 true)</li> <li><code>FALLING_EDGE</code> - Condition becomes false (true \u2192 false)</li> <li><code>ANY_EDGE</code> - Either transition</li> </ul> <p>The binary condition function receives the current epoch and state vector, returning a boolean value.</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n\n# Define condition function: check if spacecraft is in northern hemisphere\ndef in_northern_hemisphere(epoch, state):\n    \"\"\"Returns True if z-position is positive (northern hemisphere).\"\"\"\n    return state[2] &gt; 0\n\n\n# Create binary events for hemisphere crossings\n# Rising edge: false \u2192 true (entering northern hemisphere)\nenter_north = bh.BinaryEvent(\n    \"Enter Northern\",\n    in_northern_hemisphere,\n    bh.EdgeType.RISING_EDGE,\n)\n\n# Falling edge: true \u2192 false (exiting northern hemisphere)\nexit_north = bh.BinaryEvent(\n    \"Exit Northern\",\n    in_northern_hemisphere,\n    bh.EdgeType.FALLING_EDGE,\n)\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\nprop.add_event_detector(enter_north)\nprop.add_event_detector(exit_north)\n\n# Propagate for 2 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 2 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nenters = [e for e in events if \"Enter\" in e.name]\nexits = [e for e in events if \"Exit\" in e.name]\n\nprint(\"Hemisphere crossings over 2 orbits:\")\nprint(f\"  Entered northern: {len(enters)} times\")\nprint(f\"  Exited northern:  {len(exits)} times\")\n\nprint(\"\\nEvent timeline:\")\nfor event in events[:8]:  # First 8 events\n    dt = event.window_open - epoch\n    z_km = event.entry_state[2] / 1e3\n    print(f\"  t+{dt:7.1f}s: {event.name:16} (z = {z_km:+.1f} km)\")\n\n# Validate\nassert len(enters) == 2  # Once per orbit\nassert len(exits) == 2  # Once per orbit\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DBinaryEvent, EdgeType};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Create binary events for hemisphere crossings\n    // Rising edge: false \u2192 true (entering northern hemisphere)\n    let enter_north = DBinaryEvent::new(\n        \"Enter Northern\",\n        |_t, state: &amp;na::DVector&lt;f64&gt;, _params| {\n            // Returns True if z-position is positive (northern hemisphere)\n            state[2] &gt; 0.0\n        },\n        EdgeType::RisingEdge,\n    );\n\n    // Falling edge: true \u2192 false (exiting northern hemisphere)\n    let exit_north = DBinaryEvent::new(\n        \"Exit Northern\",\n        |_t, state: &amp;na::DVector&lt;f64&gt;, _params| state[2] &gt; 0.0,\n        EdgeType::FallingEdge,\n    );\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    prop.add_event_detector(Box::new(enter_north));\n    prop.add_event_detector(Box::new(exit_north));\n\n    // Propagate for 2 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + 2.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    let enters: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"Enter\")).collect();\n    let exits: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"Exit\")).collect();\n\n    println!(\"Hemisphere crossings over 2 orbits:\");\n    println!(\"  Entered northern: {} times\", enters.len());\n    println!(\"  Exited northern:  {} times\", exits.len());\n\n    println!(\"\\nEvent timeline:\");\n    for event in events.iter().take(8) {\n        let dt = event.window_open - epoch;\n        let z_km = event.entry_state[2] / 1e3;\n        println!(\n            \"  t+{:7.1}s: {:16} (z = {:+.1} km)\",\n            dt, event.name, z_km\n        );\n    }\n\n    // Validate\n    assert_eq!(enters.len(), 2); // Once per orbit\n    assert_eq!(exits.len(), 2); // Once per orbit\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/event_detection.html#see-also","title":"See Also","text":"<ul> <li>Numerical Propagation Overview - Architecture and concepts</li> <li>Premade Events - Built-in event types</li> <li>Event Callbacks - Responding to detected events</li> <li>Maneuvers - Using events for orbit maneuvers</li> <li>Numerical Orbit Propagator - Propagator fundamentals</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html","title":"Extending Spacecraft State","text":"<p>The <code>NumericalOrbitPropagator</code> supports extending state vectors beyond the standard 6-element orbital state, enabling modeling of additional state variables and dynamics like propellant mass, battery charge, or attiude alongside orbital dynamics. This is achieved through the <code>additional_dynamics</code> function.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#state-extension-approach","title":"State Extension Approach","text":"<p>To extend the state vector with <code>NumericalOrbitPropagator</code>:</p> <ol> <li>Define an extended state vector (e.g., 7 elements: <code>[pos, vel, mass]</code>)</li> <li>Implement an <code>additional_dynamics</code> function that returns a full state-sized derivative vector, where the first 6 elements are zeros (orbital dynamics handled by the force model) and the remaining elements contain derivatives for the extended state</li> <li>Optionally provide a <code>control_input</code> function for thrust accelerations</li> <li>Create the propagator with these functions</li> </ol> <p>The key advantage of using <code>NumericalOrbitPropagator</code> is that orbital dynamics (gravity, drag, SRP, etc.) are handled automatically by the force model configuration, while your <code>additional_dynamics</code> function adds derivatives for the extended state elements.</p> <p>To showcase how to extend the spacecraft state, we present an example of tracking propellant mass during a thrust maneuver below.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#mass-tracking-example","title":"Mass Tracking Example","text":"<p>One common extension is tracking propellant mass during the mission. To model propelant mass we augment the state vector from 6 to 7 elements, by adding mass \\(m\\) as the 7th element:</p> \\[\\mathbf{x} = [x, y, z, v_x, v_y, v_z, m]^T\\]"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#mass-flow-dynamics","title":"Mass Flow Dynamics","text":"<p>We model mass flow rate during thrust as:</p> \\[\\dot{m} = -\\frac{F}{I_{sp} \\cdot g_0}\\] <p>where:</p> <ul> <li>\\(F\\) is thrust force (N)</li> <li>\\(I_{sp}\\) is specific impulse (s)</li> <li>\\(g_0\\) is standard gravity (9.80665 m/s\u00b2)</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#implementation-with-numericalorbitpropagator","title":"Implementation with NumericalOrbitPropagator","text":"<p>Both <code>additional_dynamics</code> and <code>control_input</code> functions return full state-sized vectors. The propagator adds these to the orbital dynamics computed from the force model.</p> <p>The <code>additional_dynamics</code> function returns a state-sized vector with derivatives for extended elements:</p> PythonRust <pre><code>def additional_dynamics(t, state, params):\n    \"\"\"Return full state-sized vector with mass rate.\"\"\"\n    dx = np.zeros(len(state))  # Full state size\n    if burn_start &lt;= t &lt; burn_end:\n        dx[6] = -mass_flow_rate  # dm/dt = -F/(Isp*g0)\n    return dx\n</code></pre> <pre><code>let additional_dynamics: bh::DAdditionalDynamics = Some(Box::new(\n    |t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n        if burn_start &lt;= t &amp;&amp; t &lt; burn_end {\n            dx[6] = -mass_flow_rate;  // dm/dt = -F/(Isp*g0)\n        }\n        dx\n    },\n));\n</code></pre> <p>The <code>control_input</code> function returns a state-sized vector with acceleration in indices 3-5:</p> PythonRust <pre><code>def control_input(t, state, params):\n    \"\"\"Return full state-sized vector with thrust acceleration.\"\"\"\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        mass = state[6]  # Access mass from extended state\n        vel = state[3:6]\n        v_hat = vel / np.linalg.norm(vel)  # Prograde direction\n        acc = (thrust_force / mass) * v_hat\n        dx[3:6] = acc  # Add to velocity derivatives\n    return dx\n</code></pre> <pre><code>let control_input: bh::DControlInput = Some(Box::new(\n    |t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n        if burn_start &lt;= t &amp;&amp; t &lt; burn_end {\n            let mass = state[6];  // Access mass from extended state\n            let vel = na::Vector3::new(state[3], state[4], state[5]);\n            let v_hat = vel.normalize();  // Prograde direction\n            let acc = (thrust_force / mass) * v_hat;\n            dx[3] = acc[0];\n            dx[4] = acc[1];\n            dx[5] = acc[2];\n        }\n        dx\n    },\n));\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#complete-example","title":"Complete Example","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial orbital elements and state\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\norbital_state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Extended state: [x, y, z, vx, vy, vz, mass]\ninitial_mass = 1000.0  # kg\ninitial_state = np.concatenate([orbital_state, [initial_mass]])\n\n# Thruster parameters\nthrust_force = 10.0  # N\nspecific_impulse = 300.0  # s\ng0 = 9.80665  # m/s^2\nmass_flow_rate = thrust_force / (specific_impulse * g0)  # kg/s\n\n# Timing parameters\npre_burn_coast = 300.0  # 5 minutes coast before burn\nburn_duration = 600.0  # 10 minutes burn\npost_burn_coast = 600.0  # 10 minutes coast after burn\nburn_start = pre_burn_coast\nburn_end = pre_burn_coast + burn_duration\ntotal_time = pre_burn_coast + burn_duration + post_burn_coast\n\n# Spacecraft parameters for force model [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([initial_mass, 2.0, 2.2, 2.0, 1.3])\n\nprint(\"Thruster parameters:\")\nprint(f\"  Thrust: {thrust_force} N\")\nprint(f\"  Isp: {specific_impulse} s\")\nprint(f\"  Mass flow rate: {mass_flow_rate * 1000:.2f} g/s\")\nprint(f\"  Burn duration: {burn_duration} s\")\nprint(f\"  Burn window: {burn_start} - {burn_end} s\")\nprint(f\"  Expected fuel consumption: {mass_flow_rate * burn_duration:.2f} kg\")\n\n\n# Define additional dynamics for mass tracking\ndef additional_dynamics(t, state, params):\n    \"\"\"\n    Return full state derivative vector with contributions for extended state.\n    State: [x, y, z, vx, vy, vz, mass] - return same-sized vector.\n    Elements 0-5 should be zero (orbital dynamics handled by force model).\n    \"\"\"\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        dx[6] = -mass_flow_rate  # dm/dt = -F/(Isp*g0)\n    return dx\n\n\n# Define control input for thrust acceleration\ndef control_input(t, state, params):\n    \"\"\"\n    Return full state derivative with acceleration contributions.\n    Returns state-sized vector with acceleration in indices 3-5.\n    \"\"\"\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        mass = state[6]  # Access mass from extended state\n        vel = state[3:6]\n        v_hat = vel / np.linalg.norm(vel)  # Prograde direction\n        acc = (thrust_force / mass) * v_hat  # Thrust acceleration\n        dx[3:6] = acc  # Add to velocity derivatives\n    return dx\n\n\n# Create propagator with two-body dynamics (no drag/SRP for clean mass tracking)\nforce_config = bh.ForceModelConfig.two_body()\nprop_config = bh.NumericalPropagationConfig.default()\n\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state,\n    prop_config,\n    force_config,\n    params=params,\n    additional_dynamics=additional_dynamics,\n    control_input=control_input,\n)\n\nprint(\"\\nInitial state:\")\nprint(f\"  Mass: {initial_mass:.1f} kg\")\nprint(f\"  Semi-major axis: {oe[0] / 1e3:.1f} km\")\n\n# Propagate through pre-burn coast, burn, and post-burn coast\nprop.propagate_to(epoch + total_time)\n\n# Check final state\nfinal_state = prop.current_state()\nfinal_mass = final_state[6]\nfuel_consumed = initial_mass - final_mass\n\n# Compute final orbital elements\nfinal_orbital_state = final_state[:6]\nfinal_koe = bh.state_eci_to_koe(final_orbital_state, bh.AngleFormat.DEGREES)\n\nprint(\"\\nFinal state:\")\nprint(f\"  Mass: {final_mass:.1f} kg\")\nprint(f\"  Fuel consumed: {fuel_consumed:.2f} kg\")\nprint(f\"  Semi-major axis: {final_koe[0] / 1e3:.1f} km\")\nprint(f\"  Delta-a: {(final_koe[0] - oe[0]) / 1e3:.1f} km\")\n\n# Verify Tsiolkovsky equation\ndelta_v_expected = specific_impulse * g0 * np.log(initial_mass / final_mass)\nprint(\"\\nTsiolkovsky verification:\")\nprint(f\"  Expected delta-v: {delta_v_expected:.1f} m/s\")\n\n# Validate\nexpected_fuel = mass_flow_rate * burn_duration\nassert abs(fuel_consumed - expected_fuel) &lt; 0.1  # Within 0.1 kg\nassert final_mass &lt; initial_mass\nassert final_koe[0] &gt; oe[0]  # Orbit raised\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::integrators::traits::DStateDynamics;\nuse bh::propagators::{DNumericalOrbitPropagator, ForceModelConfig, NumericalPropagationConfig};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Initial orbital elements and state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let orbital_state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Extended state: [x, y, z, vx, vy, vz, mass]\n    let initial_mass = 1000.0; // kg\n    let mut initial_state = na::DVector::zeros(7);\n    for i in 0..6 {\n        initial_state[i] = orbital_state[i];\n    }\n    initial_state[6] = initial_mass;\n\n    // Thruster parameters\n    let thrust_force = 10.0; // N\n    let specific_impulse = 300.0; // s\n    let g0 = 9.80665; // m/s^2\n    let mass_flow_rate = thrust_force / (specific_impulse * g0); // kg/s\n\n    // Timing parameters\n    let pre_burn_coast = 300.0; // 5 minutes coast before burn\n    let burn_duration = 600.0; // 10 minutes burn\n    let post_burn_coast = 600.0; // 10 minutes coast after burn\n    let burn_start = pre_burn_coast;\n    let burn_end = pre_burn_coast + burn_duration;\n    let total_time = pre_burn_coast + burn_duration + post_burn_coast;\n\n    println!(\"Thruster parameters:\");\n    println!(\"  Thrust: {} N\", thrust_force);\n    println!(\"  Isp: {} s\", specific_impulse);\n    println!(\"  Mass flow rate: {:.2} g/s\", mass_flow_rate * 1000.0);\n    println!(\"  Burn duration: {} s\", burn_duration);\n    println!(\"  Burn window: {} - {} s\", burn_start, burn_end);\n    println!(\n        \"  Expected fuel consumption: {:.2} kg\",\n        mass_flow_rate * burn_duration\n    );\n\n    // Additional dynamics for mass tracking\n    // Returns full state-sized vector with mass derivative\n    let additional_dynamics: DStateDynamics = Box::new(move |t, state, _params| {\n        let mut dx = na::DVector::zeros(state.len());\n        if burn_start &lt;= t &amp;&amp; t &lt; burn_end {\n            dx[6] = -mass_flow_rate; // dm/dt = -F/(Isp*g0)\n        }\n        dx\n    });\n\n    // Control input for thrust acceleration\n    // Returns full state-sized vector with acceleration in indices 3-5\n    let control_input = Some(Box::new(move |t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n        if burn_start &lt;= t &amp;&amp; t &lt; burn_end {\n            let mass = state[6];\n            let vel = state.fixed_rows::&lt;3&gt;(3);\n            let v_hat = vel.normalize();\n            let acc = (thrust_force / mass) * v_hat;\n            dx[3] = acc[0];\n            dx[4] = acc[1];\n            dx[5] = acc[2];\n        }\n        dx\n    }) as Box&lt;dyn Fn(f64, &amp;na::DVector&lt;f64&gt;, Option&lt;&amp;na::DVector&lt;f64&gt;&gt;) -&gt; na::DVector&lt;f64&gt; + Send + Sync&gt;);\n\n    // Create propagator with two-body dynamics (no drag/SRP for clean mass tracking)\n    let mut prop = DNumericalOrbitPropagator::new(\n        epoch,\n        initial_state.clone(),\n        NumericalPropagationConfig::default(),\n        ForceModelConfig::earth_gravity(),\n        None, // params\n        Some(additional_dynamics),\n        control_input,\n        None, // initial_covariance\n    )\n    .unwrap();\n\n    println!(\"\\nInitial state:\");\n    println!(\"  Mass: {:.1} kg\", initial_mass);\n    println!(\"  Semi-major axis: {:.1} km\", oe[0] / 1e3);\n\n    // Propagate through pre-burn coast, burn, and post-burn coast\n    prop.propagate_to(epoch + total_time);\n\n    // Check final state\n    let final_state = prop.current_state();\n    let final_mass = final_state[6];\n    let fuel_consumed = initial_mass - final_mass;\n\n    // Compute final orbital elements\n    let final_orbital_state =\n        na::SVector::&lt;f64, 6&gt;::from_column_slice(&amp;final_state.as_slice()[..6]);\n    let final_koe = bh::state_eci_to_koe(final_orbital_state, bh::AngleFormat::Degrees);\n\n    println!(\"\\nFinal state:\");\n    println!(\"  Mass: {:.1} kg\", final_mass);\n    println!(\"  Fuel consumed: {:.2} kg\", fuel_consumed);\n    println!(\"  Semi-major axis: {:.1} km\", final_koe[0] / 1e3);\n    println!(\"  Delta-a: {:.1} km\", (final_koe[0] - oe[0]) / 1e3);\n\n    // Verify Tsiolkovsky equation\n    let delta_v_expected = specific_impulse * g0 * (initial_mass / final_mass).ln();\n    println!(\"\\nTsiolkovsky verification:\");\n    println!(\"  Expected delta-v: {:.1} m/s\", delta_v_expected);\n\n    // Validate\n    let expected_fuel = mass_flow_rate * burn_duration;\n    assert!((fuel_consumed - expected_fuel).abs() &lt; 0.1); // Within 0.1 kg\n    assert!(final_mass &lt; initial_mass);\n    assert!(final_koe[0] &gt; oe[0]); // Orbit raised\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#orbital-elements-evolution","title":"Orbital Elements Evolution","text":"<p>The following plot shows how orbital elements evolve during the thrust maneuver:</p> Plot Source mass_tracking_elements.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\norbital_state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Extended state: [x, y, z, vx, vy, vz, mass]\ninitial_mass = 1000.0  # kg\ninitial_state = np.concatenate([orbital_state, [initial_mass]])\n\n# Thruster parameters\nthrust_force = 10.0  # N\nspecific_impulse = 300.0  # s\ng0 = 9.80665  # m/s^2\nmass_flow_rate = thrust_force / (specific_impulse * g0)  # kg/s\n\n# Timing parameters\npre_burn_coast = 300.0  # 5 minutes coast before burn\nburn_duration = 600.0  # 10 minutes burn\npost_burn_coast = 600.0  # 10 minutes coast after burn\nburn_start = pre_burn_coast\nburn_end = pre_burn_coast + burn_duration\ntotal_time = pre_burn_coast + burn_duration + post_burn_coast\n\n# Spacecraft parameters for force model\nparams = np.array([initial_mass, 2.0, 2.2, 2.0, 1.3])\n\n\n# Define additional dynamics for mass tracking\ndef additional_dynamics(t, state, params):\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        dx[6] = -mass_flow_rate\n    return dx\n\n\n# Define control input for thrust acceleration\ndef control_input(t, state, params):\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        mass = state[6]\n        vel = state[3:6]\n        v_hat = vel / np.linalg.norm(vel)\n        acc = (thrust_force / mass) * v_hat\n        dx[3:6] = acc\n    return dx\n\n\n# Create propagator with two-body dynamics\nforce_config = bh.ForceModelConfig.two_body()\nprop_config = bh.NumericalPropagationConfig.default()\n\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state,\n    prop_config,\n    force_config,\n    params=params,\n    additional_dynamics=additional_dynamics,\n    control_input=control_input,\n)\n\n# Propagate and collect orbital elements over time\nprop.propagate_to(epoch + total_time)\n\n# Sample trajectory using trajectory interpolation\ntraj = prop.trajectory\ntimes = []\na_vals = []  # Semi-major axis (km)\ne_vals = []  # Eccentricity\ni_vals = []  # Inclination (deg)\nraan_vals = []  # RAAN (deg)\nargp_vals = []  # Argument of periapsis (deg)\nma_vals = []  # Mean anomaly (deg)\n\ndt = 10.0  # 10 second samples\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    try:\n        state = traj.interpolate(current_epoch)\n        # Convert to orbital elements\n        orbital_state_6d = state[:6]\n        koe = bh.state_eci_to_koe(orbital_state_6d, bh.AngleFormat.DEGREES)\n\n        times.append(t / 60.0)  # Convert to minutes\n        a_vals.append((koe[0] - bh.R_EARTH) / 1e3)  # Altitude in km\n        e_vals.append(koe[1])\n        i_vals.append(koe[2])\n        raan_vals.append(koe[3])\n        argp_vals.append(koe[4])\n        ma_vals.append(koe[5])  # Mean anomaly (koe[5] is mean anomaly)\n    except RuntimeError:\n        pass  # Skip if interpolation fails\n\n    t += dt\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    # Create 2x3 subplots\n    fig = make_subplots(\n        rows=2,\n        cols=3,\n        subplot_titles=(\n            \"Semi-major Axis (Altitude)\",\n            \"Eccentricity\",\n            \"Inclination\",\n            \"RAAN\",\n            \"Arg. Periapsis\",\n            \"Mean Anomaly\",\n        ),\n        vertical_spacing=0.15,\n        horizontal_spacing=0.08,\n    )\n\n    # Semi-major axis (altitude)\n    fig.add_trace(\n        go.Scatter(\n            x=times, y=a_vals, mode=\"lines\", line=dict(color=colors[\"primary\"], width=2)\n        ),\n        row=1,\n        col=1,\n    )\n    fig.update_yaxes(title_text=\"Altitude (km)\", row=1, col=1)\n\n    # Eccentricity\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=e_vals,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=2),\n        ),\n        row=1,\n        col=2,\n    )\n    fig.update_yaxes(title_text=\"e\", range=[0, 0.1], row=1, col=2)\n\n    # Inclination\n    fig.add_trace(\n        go.Scatter(\n            x=times, y=i_vals, mode=\"lines\", line=dict(color=colors[\"accent\"], width=2)\n        ),\n        row=1,\n        col=3,\n    )\n    fig.update_yaxes(title_text=\"i (deg)\", range=[0, 90], row=1, col=3)\n\n    # RAAN\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=raan_vals,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n        ),\n        row=2,\n        col=1,\n    )\n    fig.update_yaxes(title_text=\"RAAN (deg)\", range=[0, 360], row=2, col=1)\n\n    # Argument of periapsis\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=argp_vals,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=2),\n        ),\n        row=2,\n        col=2,\n    )\n    fig.update_yaxes(title_text=\"\\u03c9 (deg)\", range=[0, 360], row=2, col=2)\n\n    # Mean anomaly\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=ma_vals,\n            mode=\"lines\",\n            line=dict(color=colors[\"accent\"], width=2),\n        ),\n        row=2,\n        col=3,\n    )\n    fig.update_yaxes(title_text=\"M (deg)\", range=[0, 360], row=2, col=3)\n\n    # Add burn start and end indicators to all subplots\n    burn_start_min = burn_start / 60.0\n    burn_end_min = burn_end / 60.0\n    for row in [1, 2]:\n        for col in [1, 2, 3]:\n            # Burn start indicator\n            fig.add_vline(\n                x=burn_start_min,\n                line_dash=\"dot\",\n                line_color=colors[\"accent\"],\n                line_width=1,\n                row=row,\n                col=col,\n            )\n            # Burn end indicator\n            fig.add_vline(\n                x=burn_end_min,\n                line_dash=\"dot\",\n                line_color=colors[\"error\"],\n                line_width=1,\n                row=row,\n                col=col,\n            )\n\n    # Update x-axis labels for bottom row\n    for col in [1, 2, 3]:\n        fig.update_xaxes(title_text=\"Time (min)\", row=2, col=col)\n\n    fig.update_layout(\n        title=\"Orbital Elements During Prograde Thrust (10 N, 10 min burn)\",\n        showlegend=False,\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#mass-depletion-profile","title":"Mass Depletion Profile","text":"<p>The mass decreases linearly during the thrust phase:</p> Plot Source mass_tracking_mass.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\norbital_state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Extended state: [x, y, z, vx, vy, vz, mass]\ninitial_mass = 1000.0  # kg\ninitial_state = np.concatenate([orbital_state, [initial_mass]])\n\n# Thruster parameters\nthrust_force = 10.0  # N\nspecific_impulse = 300.0  # s\ng0 = 9.80665  # m/s^2\nmass_flow_rate = thrust_force / (specific_impulse * g0)  # kg/s\n\n# Timing parameters\npre_burn_coast = 300.0  # 5 minutes coast before burn\nburn_duration = 600.0  # 10 minutes burn\npost_burn_coast = 600.0  # 10 minutes coast after burn\nburn_start = pre_burn_coast\nburn_end = pre_burn_coast + burn_duration\ntotal_time = pre_burn_coast + burn_duration + post_burn_coast\n\n# Spacecraft parameters for force model\nparams = np.array([initial_mass, 2.0, 2.2, 2.0, 1.3])\n\n\n# Define additional dynamics for mass tracking\ndef additional_dynamics(t, state, params):\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        dx[6] = -mass_flow_rate\n    return dx\n\n\n# Define control input for thrust acceleration\ndef control_input(t, state, params):\n    dx = np.zeros(len(state))\n    if burn_start &lt;= t &lt; burn_end:\n        mass = state[6]\n        vel = state[3:6]\n        v_hat = vel / np.linalg.norm(vel)\n        acc = (thrust_force / mass) * v_hat\n        dx[3:6] = acc\n    return dx\n\n\n# Create propagator with two-body dynamics\nforce_config = bh.ForceModelConfig.two_body()\nprop_config = bh.NumericalPropagationConfig.default()\n\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state,\n    prop_config,\n    force_config,\n    params=params,\n    additional_dynamics=additional_dynamics,\n    control_input=control_input,\n)\n\n# Propagate and collect mass over time\nprop.propagate_to(epoch + total_time)\n\n# Sample trajectory using trajectory interpolation\ntraj = prop.trajectory\ntimes = []\nmass_vals = []\nthrust_active = []\n\ndt = 5.0  # 5 second samples\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    try:\n        state = traj.interpolate(current_epoch)\n        times.append(t / 60.0)  # Convert to minutes\n        mass_vals.append(state[6])\n        thrust_active.append(1 if burn_start &lt;= t &lt; burn_end else 0)\n    except RuntimeError:\n        pass  # Skip if interpolation fails\n\n    t += dt\n\n# Compute expected values\nexpected_fuel = mass_flow_rate * burn_duration\nfinal_mass_expected = initial_mass - expected_fuel\ndelta_v_expected = specific_impulse * g0 * np.log(initial_mass / final_mass_expected)\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Mass profile\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=mass_vals,\n            mode=\"lines\",\n            name=\"Spacecraft Mass\",\n            line=dict(color=colors[\"primary\"], width=3),\n        )\n    )\n\n    # Initial mass reference\n    fig.add_hline(\n        y=initial_mass,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        annotation_text=f\"Initial: {initial_mass:.0f} kg\",\n        annotation_position=\"top right\",\n    )\n\n    # Final mass reference\n    fig.add_hline(\n        y=final_mass_expected,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        annotation_text=f\"Final: {final_mass_expected:.1f} kg\",\n        annotation_position=\"bottom right\",\n    )\n\n    # Thrust phase shading\n    burn_start_min = burn_start / 60.0\n    burn_end_min = burn_end / 60.0\n    fig.add_vrect(\n        x0=burn_start_min,\n        x1=burn_end_min,\n        fillcolor=colors[\"secondary\"],\n        opacity=0.1,\n        layer=\"below\",\n        line_width=0,\n        annotation_text=\"Thrust On\",\n        annotation_position=\"top left\",\n    )\n\n    # Burn start indicator\n    fig.add_vline(\n        x=burn_start_min,\n        line_dash=\"dash\",\n        line_color=colors[\"accent\"],\n        line_width=2,\n        annotation_text=\"Burn Start\",\n        annotation_position=\"top left\",\n    )\n\n    # Burn end indicator\n    fig.add_vline(\n        x=burn_end_min,\n        line_dash=\"dash\",\n        line_color=colors[\"error\"],\n        line_width=2,\n        annotation_text=\"Burn End\",\n        annotation_position=\"top right\",\n    )\n\n    fig.update_layout(\n        title=f\"Mass Depletion Profile (F={thrust_force} N, Isp={specific_impulse} s)\",\n        xaxis_title=\"Time (min)\",\n        yaxis_title=\"Mass (kg)\",\n        showlegend=False,\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    # Add annotation with summary\n    summary_text = (\n        f\"Fuel consumed: {expected_fuel:.2f} kg&lt;br&gt;\"\n        f\"Mass flow rate: {mass_flow_rate * 1000:.2f} g/s&lt;br&gt;\"\n        f\"Expected \\u0394v: {delta_v_expected:.1f} m/s\"\n    )\n    fig.add_annotation(\n        x=0.98,\n        y=0.5,\n        xref=\"paper\",\n        yref=\"paper\",\n        text=summary_text,\n        showarrow=False,\n        font=dict(size=11),\n        align=\"right\",\n        bordercolor=\"gray\",\n        borderwidth=1,\n        borderpad=4,\n        bgcolor=\"white\" if theme == \"light\" else \"#1e1e1e\",\n        opacity=0.9,\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#tsiolkovsky-verification","title":"Tsiolkovsky Verification","text":"<p>The mass ratio determines achievable \\(\\Delta v\\):</p> \\[\\Delta v = I_{sp} \\cdot g_0 \\cdot \\ln\\left(\\frac{m_0}{m_f}\\right)\\] <p>This provides a useful validation check for mass tracking implementations.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#battery-tracking-example","title":"Battery Tracking Example","text":"<p>Another common extension is tracking battery state of charge during eclipse and sunlit periods. This models solar panel charging using the conical shadow model for accurate illumination calculation.</p> <p>We augment the state vector with battery energy \\(E_{bat}\\) in Watt-hours:</p> \\[\\mathbf{x} = [x, y, z, v_x, v_y, v_z, E_{bat}]^T\\]"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#power-balance-dynamics","title":"Power Balance Dynamics","text":"<p>The battery state of charge changes based on the power balance:</p> \\[\\dot{E}_{bat} = \\nu \\cdot P_{solar} - P_{load}\\] <p>where:</p> <ul> <li>\\(\\nu\\) is the illumination fraction (0 = full shadow, 1 = full sunlight)</li> <li>\\(P_{solar}\\) is the solar panel output when fully illuminated (W)</li> <li>\\(P_{load}\\) is the spacecraft power consumption (W)</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#implementation","title":"Implementation","text":"<p>The <code>additional_dynamics</code> function computes the illumination at each timestep using <code>eclipse_conical</code>:</p> PythonRust <pre><code>def additional_dynamics(t, state, params):\n    \"\"\"Battery dynamics with eclipse-aware solar charging.\"\"\"\n    dx = np.zeros(len(state))\n    r_eci = state[:3]\n\n    # Get sun position at current epoch\n    current_epoch = epoch + t\n    r_sun = bh.sun_position(current_epoch)\n\n    # Get illumination fraction (0 = umbra, 0-1 = penumbra, 1 = sunlit)\n    illumination = bh.eclipse_conical(r_eci, r_sun)\n\n    # Battery dynamics (Wh/s = W / 3600)\n    power_in = illumination * solar_panel_power  # W\n    power_out = load_power  # W\n    dx[6] = (power_in - power_out) / 3600.0  # Wh/s\n\n    return dx\n</code></pre> <pre><code>let additional_dynamics: DStateDynamics = Box::new(move |t, state, _params| {\n    let mut dx = na::DVector::zeros(state.len());\n    let r_eci = na::Vector3::new(state[0], state[1], state[2]);\n\n    // Get sun position at current epoch\n    let current_epoch = *epoch_ref + t;\n    let r_sun = bh::sun_position(current_epoch);\n\n    // Get illumination fraction (0 = umbra, 0-1 = penumbra, 1 = sunlit)\n    let illumination = bh::eclipse_conical(r_eci, r_sun);\n\n    // Battery dynamics (Wh/s = W / 3600)\n    let power_in = illumination * solar_panel_power;  // W\n    let power_out = load_power;  // W\n    dx[6] = (power_in - power_out) / 3600.0;  // Wh/s\n\n    dx\n});\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#complete-example_1","title":"Complete Example","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial orbital elements and state - LEO orbit\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\norbital_state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Extended state: [x, y, z, vx, vy, vz, battery_charge]\nbattery_capacity = 100.0  # Wh\ninitial_charge = 80.0  # Wh (80% SOC)\ninitial_state = np.concatenate([orbital_state, [initial_charge]])\n\n# Power system parameters\nsolar_panel_power = 50.0  # W (when fully illuminated)\nload_power = 30.0  # W (continuous consumption)\n\nprint(\"Power system parameters:\")\nprint(f\"  Battery capacity: {battery_capacity} Wh\")\nprint(\n    f\"  Initial charge: {initial_charge} Wh ({100 * initial_charge / battery_capacity:.0f}% SOC)\"\n)\nprint(f\"  Solar panel power: {solar_panel_power} W\")\nprint(f\"  Load power: {load_power} W\")\nprint(f\"  Net charging rate (sunlit): {solar_panel_power - load_power} W\")\nprint(f\"  Net discharge rate (eclipse): {load_power} W\")\n\n# Spacecraft parameters for force model [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n\n# Define additional dynamics for battery tracking\ndef additional_dynamics(t, state, params):\n    \"\"\"\n    Return full state derivative vector with battery charge dynamics.\n    State: [x, y, z, vx, vy, vz, battery_charge] - return same-sized vector.\n    Elements 0-5 should be zero (orbital dynamics handled by force model).\n    \"\"\"\n    dx = np.zeros(len(state))\n    r_eci = state[:3]\n\n    # Get sun position at current epoch\n    current_epoch = epoch + t\n    r_sun = bh.sun_position(current_epoch)\n\n    # Get illumination fraction (0 = umbra, 0-1 = penumbra, 1 = sunlit)\n    illumination = bh.eclipse_conical(r_eci, r_sun)\n\n    # Battery dynamics (Wh/s = W / 3600)\n    power_in = illumination * solar_panel_power  # W\n    power_out = load_power  # W\n    charge_rate = (power_in - power_out) / 3600.0  # Wh/s\n\n    # Apply battery limits (0 to capacity)\n    charge = state[6]\n    if charge &gt;= battery_capacity and charge_rate &gt; 0:\n        charge_rate = 0.0  # Battery full\n    elif charge &lt;= 0 and charge_rate &lt; 0:\n        charge_rate = 0.0  # Battery empty\n\n    dx[6] = charge_rate\n    return dx\n\n\n# Create propagator with two-body dynamics\nforce_config = bh.ForceModelConfig.two_body()\nprop_config = bh.NumericalPropagationConfig.default()\n\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state,\n    prop_config,\n    force_config,\n    params=params,\n    additional_dynamics=additional_dynamics,\n)\n\n# Calculate orbital period and propagate for 3 orbits\norbital_period = bh.orbital_period(oe[0])\nnum_orbits = 3\ntotal_time = num_orbits * orbital_period\n\nprint(f\"\\nOrbital period: {orbital_period:.1f} s ({orbital_period / 60:.1f} min)\")\nprint(f\"Propagating for {num_orbits} orbits ({total_time / 60:.1f} min)\")\n\n# Propagate\nprop.propagate_to(epoch + total_time)\n\n# Check final state\nfinal_state = prop.current_state()\nfinal_charge = final_state[6]\ncharge_change = final_charge - initial_charge\n\nprint(\"\\nFinal battery state:\")\nprint(\n    f\"  Final charge: {final_charge:.2f} Wh ({100 * final_charge / battery_capacity:.1f}% SOC)\"\n)\nprint(f\"  Charge change: {charge_change:+.2f} Wh\")\n\n# Sample trajectory to find eclipse statistics\ntraj = prop.trajectory\ndt = 30.0  # 30 second samples\nt = 0.0\neclipse_time = 0.0\nsunlit_time = 0.0\n\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    try:\n        state = traj.interpolate(current_epoch)\n        r_eci = state[:3]\n        r_sun = bh.sun_position(current_epoch)\n        illumination = bh.eclipse_conical(r_eci, r_sun)\n\n        if illumination &lt; 0.01:  # In eclipse (&lt; 1% illumination)\n            eclipse_time += dt\n        else:\n            sunlit_time += dt\n    except RuntimeError:\n        pass\n    t += dt\n\neclipse_fraction = eclipse_time / (eclipse_time + sunlit_time)\nprint(\"\\nEclipse statistics:\")\nprint(\n    f\"  Sunlit time: {sunlit_time / 60:.1f} min ({100 * (1 - eclipse_fraction):.1f}%)\"\n)\nprint(f\"  Eclipse time: {eclipse_time / 60:.1f} min ({100 * eclipse_fraction:.1f}%)\")\n\n# Validate\nassert final_charge &gt; 0, \"Battery should not be depleted\"\nassert final_charge &lt;= battery_capacity, \"Battery should not exceed capacity\"\nassert eclipse_time &gt; 0, \"Should have some eclipse periods\"\nassert sunlit_time &gt; 0, \"Should have some sunlit periods\"\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::integrators::traits::DStateDynamics;\nuse bh::propagators::{DNumericalOrbitPropagator, ForceModelConfig, NumericalPropagationConfig};\nuse bh::time::Epoch;\nuse bh::traits::{DStatePropagator, InterpolatableTrajectory};\nuse nalgebra as na;\nuse std::sync::Arc;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = Epoch::from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Initial orbital elements and state - LEO orbit\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let orbital_state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Extended state: [x, y, z, vx, vy, vz, battery_charge]\n    let battery_capacity = 100.0; // Wh\n    let initial_charge = 80.0; // Wh (80% SOC)\n    let mut initial_state = na::DVector::zeros(7);\n    for i in 0..6 {\n        initial_state[i] = orbital_state[i];\n    }\n    initial_state[6] = initial_charge;\n\n    // Power system parameters\n    let solar_panel_power = 50.0; // W (when fully illuminated)\n    let load_power = 30.0; // W (continuous consumption)\n\n    println!(\"Power system parameters:\");\n    println!(\"  Battery capacity: {} Wh\", battery_capacity);\n    println!(\n        \"  Initial charge: {} Wh ({:.0}% SOC)\",\n        initial_charge,\n        100.0 * initial_charge / battery_capacity\n    );\n    println!(\"  Solar panel power: {} W\", solar_panel_power);\n    println!(\"  Load power: {} W\", load_power);\n    println!(\n        \"  Net charging rate (sunlit): {} W\",\n        solar_panel_power - load_power\n    );\n    println!(\"  Net discharge rate (eclipse): {} W\", load_power);\n\n    // Store epoch in Arc for closure\n    let epoch_ref = Arc::new(epoch);\n    let epoch_clone = Arc::clone(&amp;epoch_ref);\n\n    // Additional dynamics for battery tracking\n    let additional_dynamics: DStateDynamics = Box::new(move |t, state, _params| {\n        let mut dx = na::DVector::zeros(state.len());\n        let r_eci = na::Vector3::new(state[0], state[1], state[2]);\n\n        // Get sun position at current epoch\n        let current_epoch = *epoch_clone + t;\n        let r_sun = bh::sun_position(current_epoch);\n\n        // Get illumination fraction (0 = umbra, 0-1 = penumbra, 1 = sunlit)\n        let illumination = bh::eclipse_conical(r_eci, r_sun);\n\n        // Battery dynamics (Wh/s = W / 3600)\n        let power_in = illumination * solar_panel_power; // W\n        let power_out = load_power; // W\n        let mut charge_rate = (power_in - power_out) / 3600.0; // Wh/s\n\n        // Apply battery limits (0 to capacity)\n        let charge = state[6];\n        if charge &gt;= battery_capacity &amp;&amp; charge_rate &gt; 0.0 {\n            charge_rate = 0.0; // Battery full\n        } else if charge &lt;= 0.0 &amp;&amp; charge_rate &lt; 0.0 {\n            charge_rate = 0.0; // Battery empty\n        }\n\n        dx[6] = charge_rate;\n        dx\n    });\n\n    // Create propagator with two-body dynamics\n    let mut prop = DNumericalOrbitPropagator::new(\n        epoch,\n        initial_state.clone(),\n        NumericalPropagationConfig::default(),\n        ForceModelConfig::two_body_gravity(),\n        None, // params\n        Some(additional_dynamics),\n        None, // control_input\n        None, // initial_covariance\n    )\n    .unwrap();\n\n    // Calculate orbital period and propagate for 3 orbits\n    let orbital_period = bh::orbital_period(oe[0]);\n    let num_orbits = 3;\n    let total_time = num_orbits as f64 * orbital_period;\n\n    println!(\n        \"\\nOrbital period: {:.1} s ({:.1} min)\",\n        orbital_period,\n        orbital_period / 60.0\n    );\n    println!(\n        \"Propagating for {} orbits ({:.1} min)\",\n        num_orbits,\n        total_time / 60.0\n    );\n\n    // Propagate\n    prop.propagate_to(epoch + total_time);\n\n    // Check final state\n    let final_state = prop.current_state();\n    let final_charge = final_state[6];\n    let charge_change = final_charge - initial_charge;\n\n    println!(\"\\nFinal battery state:\");\n    println!(\n        \"  Final charge: {:.2} Wh ({:.1}% SOC)\",\n        final_charge,\n        100.0 * final_charge / battery_capacity\n    );\n    println!(\"  Charge change: {:+.2} Wh\", charge_change);\n\n    // Sample trajectory to find eclipse statistics\n    let traj = prop.trajectory();\n    let dt = 30.0; // 30 second samples\n    let mut t = 0.0;\n    let mut eclipse_time = 0.0;\n    let mut sunlit_time = 0.0;\n\n    while t &lt;= total_time {\n        let current_epoch = epoch + t;\n        if let Ok(state) = traj.interpolate(&amp;current_epoch) {\n            let r_eci = na::Vector3::new(state[0], state[1], state[2]);\n            let r_sun = bh::sun_position(current_epoch);\n            let illumination = bh::eclipse_conical(r_eci, r_sun);\n\n            if illumination &lt; 0.01 {\n                // In eclipse (&lt; 1% illumination)\n                eclipse_time += dt;\n            } else {\n                sunlit_time += dt;\n            }\n        }\n        t += dt;\n    }\n\n    let eclipse_fraction = eclipse_time / (eclipse_time + sunlit_time);\n    println!(\"\\nEclipse statistics:\");\n    println!(\n        \"  Sunlit time: {:.1} min ({:.1}%)\",\n        sunlit_time / 60.0,\n        100.0 * (1.0 - eclipse_fraction)\n    );\n    println!(\n        \"  Eclipse time: {:.1} min ({:.1}%)\",\n        eclipse_time / 60.0,\n        100.0 * eclipse_fraction\n    );\n\n    // Validate\n    assert!(final_charge &gt; 0.0, \"Battery should not be depleted\");\n    assert!(\n        final_charge &lt;= battery_capacity,\n        \"Battery should not exceed capacity\"\n    );\n    assert!(eclipse_time &gt; 0.0, \"Should have some eclipse periods\");\n    assert!(sunlit_time &gt; 0.0, \"Should have some sunlit periods\");\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#battery-charge-and-illumination-profile","title":"Battery Charge and Illumination Profile","text":"<p>The following plot shows battery state of charge over 3 orbits, with illumination fraction and eclipse periods clearly visible:</p> Plot Source battery_tracking.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state - LEO orbit\nepoch = bh.Epoch.from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\norbital_state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Extended state: [x, y, z, vx, vy, vz, battery_charge]\nbattery_capacity = 100.0  # Wh\ninitial_charge = 80.0  # Wh (80% SOC)\ninitial_state = np.concatenate([orbital_state, [initial_charge]])\n\n# Power system parameters\nsolar_panel_power = 50.0  # W (when fully illuminated)\nload_power = 30.0  # W (continuous consumption)\n\n# Spacecraft parameters for force model\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n\n# Define additional dynamics for battery tracking\ndef additional_dynamics(t, state, params):\n    dx = np.zeros(len(state))\n    r_eci = state[:3]\n\n    # Get sun position at current epoch\n    current_epoch = epoch + t\n    r_sun = bh.sun_position(current_epoch)\n\n    # Get illumination fraction (0 = umbra, 0-1 = penumbra, 1 = sunlit)\n    illumination = bh.eclipse_conical(r_eci, r_sun)\n\n    # Battery dynamics (Wh/s = W / 3600)\n    power_in = illumination * solar_panel_power\n    power_out = load_power\n    charge_rate = (power_in - power_out) / 3600.0\n\n    # Apply battery limits\n    charge = state[6]\n    if charge &gt;= battery_capacity and charge_rate &gt; 0:\n        charge_rate = 0.0\n    elif charge &lt;= 0 and charge_rate &lt; 0:\n        charge_rate = 0.0\n\n    dx[6] = charge_rate\n    return dx\n\n\n# Create propagator with two-body dynamics\nforce_config = bh.ForceModelConfig.two_body()\nprop_config = bh.NumericalPropagationConfig.default()\n\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    initial_state,\n    prop_config,\n    force_config,\n    params=params,\n    additional_dynamics=additional_dynamics,\n)\n\n# Propagate for 3 orbits\norbital_period = bh.orbital_period(oe[0])\nnum_orbits = 3\ntotal_time = num_orbits * orbital_period\n\nprop.propagate_to(epoch + total_time)\n\n# Sample trajectory for plotting\ntraj = prop.trajectory\ntimes = []\ncharge_vals = []\nillumination_vals = []\n\ndt = 10.0  # 10 second samples\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n    try:\n        state = traj.interpolate(current_epoch)\n        r_eci = state[:3]\n        r_sun = bh.sun_position(current_epoch)\n        illumination = bh.eclipse_conical(r_eci, r_sun)\n\n        times.append(t / 60.0)  # Convert to minutes\n        charge_vals.append(state[6])\n        illumination_vals.append(illumination)\n    except RuntimeError:\n        pass\n\n    t += dt\n\n# Find eclipse regions for shading\neclipse_starts = []\neclipse_ends = []\nin_eclipse = False\neclipse_threshold = 0.01  # Consider &lt;1% illumination as eclipse\n\nfor i, illum in enumerate(illumination_vals):\n    if illum &lt; eclipse_threshold and not in_eclipse:\n        eclipse_starts.append(times[i])\n        in_eclipse = True\n    elif illum &gt;= eclipse_threshold and in_eclipse:\n        eclipse_ends.append(times[i])\n        in_eclipse = False\n\n# Close last eclipse if still in eclipse at end\nif in_eclipse and len(eclipse_starts) &gt; len(eclipse_ends):\n    eclipse_ends.append(times[-1])\n\n# Calculate statistics\nfinal_charge = charge_vals[-1]\ncharge_change = final_charge - initial_charge\nsunlit_time = sum(1 for i in illumination_vals if i &gt; eclipse_threshold) * dt / 60.0\neclipse_time = len(times) * dt / 60.0 - sunlit_time\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    # Create figure with secondary y-axis\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n    # Battery charge (primary y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=charge_vals,\n            mode=\"lines\",\n            name=\"Battery Charge\",\n            line=dict(color=colors[\"primary\"], width=3),\n        ),\n        secondary_y=False,\n    )\n\n    # Illumination fraction (secondary y-axis) as filled area\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=illumination_vals,\n            mode=\"lines\",\n            name=\"Illumination\",\n            line=dict(color=colors[\"secondary\"], width=1),\n            fill=\"tozeroy\",\n            fillcolor=\"rgba(255, 165, 0, 0.15)\"\n            if theme == \"light\"\n            else \"rgba(255, 170, 68, 0.15)\",\n        ),\n        secondary_y=True,\n    )\n\n    # Add eclipse shading\n    for start, end in zip(eclipse_starts, eclipse_ends):\n        fig.add_vrect(\n            x0=start,\n            x1=end,\n            fillcolor=\"rgba(100, 100, 100, 0.2)\"\n            if theme == \"light\"\n            else \"rgba(50, 50, 50, 0.4)\",\n            layer=\"below\",\n            line_width=0,\n        )\n\n    # Add reference lines\n    fig.add_hline(\n        y=initial_charge,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        annotation_text=f\"Initial: {initial_charge:.0f} Wh\",\n        annotation_position=\"top right\",\n        secondary_y=False,\n    )\n\n    fig.add_hline(\n        y=battery_capacity,\n        line_dash=\"dot\",\n        line_color=colors[\"accent\"],\n        annotation_text=f\"Capacity: {battery_capacity:.0f} Wh\",\n        annotation_position=\"bottom right\",\n        secondary_y=False,\n    )\n\n    # Update layout\n    fig.update_layout(\n        title=f\"Battery Charge with Eclipse Cycles (LEO, {num_orbits} orbits)\",\n        xaxis_title=\"Time (min)\",\n        height=500,\n        margin=dict(l=60, r=80, t=80, b=60),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor=\"rgba(255,255,255,0.8)\"\n            if theme == \"light\"\n            else \"rgba(30,30,30,0.8)\",\n        ),\n    )\n\n    # Update y-axes\n    fig.update_yaxes(\n        title_text=\"Battery Charge (Wh)\",\n        range=[60, 105],\n        secondary_y=False,\n    )\n    fig.update_yaxes(\n        title_text=\"Illumination Fraction\",\n        range=[0, 1.1],\n        secondary_y=True,\n    )\n\n    # Add summary annotation\n    summary_text = (\n        f\"Charge change: {charge_change:+.2f} Wh&lt;br&gt;\"\n        f\"Final SOC: {100 * final_charge / battery_capacity:.1f}%&lt;br&gt;\"\n        f\"Eclipse: {eclipse_time:.1f} min ({100 * eclipse_time / (eclipse_time + sunlit_time):.0f}%)\"\n    )\n    fig.add_annotation(\n        x=0.98,\n        y=0.02,\n        xref=\"paper\",\n        yref=\"paper\",\n        text=summary_text,\n        showarrow=False,\n        font=dict(size=11),\n        align=\"right\",\n        bordercolor=\"gray\",\n        borderwidth=1,\n        borderpad=4,\n        bgcolor=\"white\" if theme == \"light\" else \"#1e1e1e\",\n        opacity=0.9,\n    )\n\n    # Add \"Eclipse\" label to first eclipse region\n    if eclipse_starts:\n        mid_eclipse = (eclipse_starts[0] + eclipse_ends[0]) / 2\n        fig.add_annotation(\n            x=mid_eclipse,\n            y=0.95,\n            xref=\"x\",\n            yref=\"paper\",\n            text=\"Eclipse\",\n            showarrow=False,\n            font=dict(size=10, color=colors[\"font_color\"]),\n        )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre> <p>The battery charges during sunlit periods (illumination = 1) and discharges during eclipse (illumination = 0). The penumbra regions show gradual transitions in illumination.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#other-common-extensions","title":"Other Common Extensions","text":""},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#attitude-dynamics","title":"Attitude Dynamics","text":"<p>Track spacecraft attitude alongside orbital motion. This example shows quaternion attitude propagation:</p> PythonRust <pre><code># State: [pos(3), vel(3), q0, q1, q2, q3, wx, wy, wz] = 13 elements\n# Quaternion [q0, q1, q2, q3] + angular velocity [wx, wy, wz]\ndef additional_dynamics_attitude(t, state, params):\n    \"\"\"Attitude dynamics only - orbital handled by force model.\"\"\"\n    dx = np.zeros(len(state))\n\n    # Extract quaternion and angular velocity\n    q = state[6:10]  # [q0, q1, q2, q3]\n    omega = state[10:13]  # [wx, wy, wz] rad/s\n\n    # Quaternion kinematics: dq/dt = 0.5 * Omega(omega) * q\n    omega_matrix = np.array([\n        [0, -omega[0], -omega[1], -omega[2]],\n        [omega[0], 0, omega[2], -omega[1]],\n        [omega[1], -omega[2], 0, omega[0]],\n        [omega[2], omega[1], -omega[0], 0]\n    ])\n    dq = 0.5 * omega_matrix @ q\n    dx[6:10] = dq\n\n    # Angular velocity dynamics: I * domega/dt = -omega x (I * omega) + torque\n    I = np.diag([10.0, 12.0, 8.0])  # Inertia tensor (kg*m^2)\n    torque = np.zeros(3)  # External torques\n    domega = np.linalg.solve(I, -np.cross(omega, I @ omega) + torque)\n    dx[10:13] = domega\n\n    return dx\n</code></pre> <pre><code>// State: [pos(3), vel(3), q0, q1, q2, q3, wx, wy, wz] = 13 elements\nlet additional_dynamics_attitude: DStateDynamics = Box::new(\n    |_t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n\n        // Extract quaternion and angular velocity\n        let q = na::Vector4::new(state[6], state[7], state[8], state[9]);\n        let omega = na::Vector3::new(state[10], state[11], state[12]);\n\n        // Quaternion kinematics: dq/dt = 0.5 * Omega(omega) * q\n        let omega_matrix = na::Matrix4::new(\n            0.0, -omega[0], -omega[1], -omega[2],\n            omega[0], 0.0, omega[2], -omega[1],\n            omega[1], -omega[2], 0.0, omega[0],\n            omega[2], omega[1], -omega[0], 0.0,\n        );\n        let dq = 0.5 * omega_matrix * q;\n        dx[6] = dq[0]; dx[7] = dq[1]; dx[8] = dq[2]; dx[9] = dq[3];\n\n        // Angular velocity dynamics: I * domega/dt = -omega x (I * omega) + torque\n        let inertia = na::Matrix3::from_diagonal(&amp;na::Vector3::new(10.0, 12.0, 8.0));\n        let torque = na::Vector3::zeros();\n        let domega = inertia.try_inverse().unwrap()\n            * (-omega.cross(&amp;(inertia * omega)) + torque);\n        dx[10] = domega[0]; dx[11] = domega[1]; dx[12] = domega[2];\n\n        dx\n    },\n);\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#thermal-state","title":"Thermal State","text":"<p>Track spacecraft temperature:</p> PythonRust <pre><code># State: [pos(3), vel(3), temperature]\ndef additional_dynamics_thermal(t, state, params):\n    \"\"\"Thermal dynamics only - orbital handled by force model.\"\"\"\n    dx = np.zeros(len(state))\n    temp = state[6]\n\n    # Simplified radiation balance\n    q_solar = solar_flux_absorbed(state[:3])\n    q_radiated = emissivity * stefan_boltzmann * temp**4 * area\n    dx[6] = (q_solar - q_radiated) / (mass * specific_heat)\n\n    return dx\n</code></pre> <pre><code>// State: [pos(3), vel(3), temperature]\nlet additional_dynamics_thermal: bh::DAdditionalDynamics = Some(Box::new(\n    |_t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n        let temp = state[6];\n\n        // Simplified radiation balance\n        let q_solar = solar_flux_absorbed(&amp;state.fixed_rows::&lt;3&gt;(0).into());\n        let q_radiated = emissivity * stefan_boltzmann * temp.powi(4) * area;\n        dx[6] = (q_solar - q_radiated) / (mass * specific_heat);\n\n        dx\n    },\n));\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#multiple-extensions","title":"Multiple Extensions","text":"<p>State vectors can include multiple extensions:</p> PythonRust <pre><code># State: [pos(3), vel(3), mass, battery, temperature] = 9 elements\ninitial_state = np.array([\n    *orbital_state,  # Position and velocity (6)\n    1000.0,          # Mass (kg)\n    100.0,           # Battery (Wh)\n    293.0,           # Temperature (K)\n])\n\ndef additional_dynamics_multi(t, state, params):\n    \"\"\"Return full state-sized vector with derivatives for extended elements.\"\"\"\n    dx = np.zeros(len(state))\n    mass = state[6]\n    charge = state[7]\n    temp = state[8]\n\n    dx[6] = -mass_flow_rate if thrusting else 0.0\n    dx[7] = solar_input - power_consumption if is_sunlit(state[:3]) else -power_consumption\n    dx[8] = (q_solar - q_radiated) / (mass * specific_heat)\n\n    return dx\n</code></pre> <pre><code>// State: [pos(3), vel(3), mass, battery, temperature] = 9 elements\nlet initial_state = na::DVector::from_vec(vec![\n    orbital_state[0], orbital_state[1], orbital_state[2],  // Position\n    orbital_state[3], orbital_state[4], orbital_state[5],  // Velocity\n    1000.0,  // Mass (kg)\n    100.0,   // Battery (Wh)\n    293.0,   // Temperature (K)\n]);\n\nlet additional_dynamics_multi: bh::DAdditionalDynamics = Some(Box::new(\n    |_t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        let mut dx = na::DVector::zeros(state.len());\n        let mass = state[6];\n        let _charge = state[7];\n        let _temp = state[8];\n\n        dx[6] = if thrusting { -mass_flow_rate } else { 0.0 };\n        dx[7] = if is_sunlit(&amp;state.fixed_rows::&lt;3&gt;(0).into()) {\n            solar_input - power_consumption\n        } else {\n            -power_consumption\n        };\n        dx[8] = (q_solar - q_radiated) / (mass * specific_heat);\n\n        dx\n    },\n));\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#implementation-notes","title":"Implementation Notes","text":"<p>Another way to implement extended state propagation is to use <code>NumericalPropagator</code>, which requires implementing the full dynamics function including orbital and extended state dynamics. However, using <code>NumericalOrbitPropagator</code> with <code>additional_dynamics</code> is often more convenient for orbital applications, as it handles standard orbital perturbations automatically. See the Generic Dynamics Propagation guide for details on using <code>NumericalPropagator</code> which may be preferable for highly customized dynamics.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/extending_state.html#see-also","title":"See Also","text":"<ul> <li>General Dynamics Propagation - Using <code>NumericalPropagator</code> for custom dynamics</li> <li>Impulsive and Continuous Control - Thrust implementation</li> <li>Numerical Orbit Propagator - Standard 6-DOF propagation</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html","title":"Force Models","text":"<p>The <code>ForceModelConfig</code> (Python) / <code>ForceModelConfig</code> (Rust) defines which physical forces affect the spacecraft during propagation. Brahe provides preset configurations for common scenarios and allows custom configurations for specific requirements.</p> <p>For API details, see the ForceModelConfig API Reference.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#full-example","title":"Full Example","text":"<p>here is a complete example creating a <code>ForceModelConfig</code> exercising all available configuration options:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a fully-configured force model\nforce_config = bh.ForceModelConfig(\n    # Gravity: Spherical harmonic model (EGM2008, 20x20 degree/order)\n    gravity=bh.GravityConfiguration.spherical_harmonic(\n        degree=20,\n        order=20,\n        model_type=bh.GravityModelType.EGM2008_360,\n    ),\n    # Atmospheric drag: Harris-Priester model with parameter indices\n    drag=bh.DragConfiguration(\n        model=bh.AtmosphericModel.HARRIS_PRIESTER,\n        area=bh.ParameterSource.parameter_index(1),  # Index into parameter vector\n        cd=bh.ParameterSource.parameter_index(2),\n    ),\n    # Solar radiation pressure: Conical eclipse model\n    srp=bh.SolarRadiationPressureConfiguration(\n        area=bh.ParameterSource.parameter_index(3),\n        cr=bh.ParameterSource.parameter_index(4),\n        eclipse_model=bh.EclipseModel.CONICAL,\n    ),\n    # Third-body: Sun and Moon with DE440s ephemeris\n    third_body=bh.ThirdBodyConfiguration(\n        ephemeris_source=bh.EphemerisSource.DE440s,\n        bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON],\n    ),\n    # General relativistic corrections\n    relativity=True,\n    # Spacecraft mass (can also use parameter_index for estimation)\n    mass=bh.ParameterSource.value(1000.0),  # kg\n)\n\nprint(f\"Gravity: {force_config.gravity}\")\nprint(f\"Drag: {force_config.drag}\")\nprint(f\"SRP: {force_config.srp}\")\nprint(f\"Third-body: {force_config.third_body}\")\nprint(f\"Relativity: {force_config.relativity}\")\nprint(f\"Mass: {force_config.mass}\")\n# Gravity: SphericalHarmonic(source=EGM2008_360, degree=20, order=20)\n# Drag: DragConfiguration(model=HarrisPriester, area=ParameterIndex(1), cd=ParameterIndex(2))\n# SRP: SolarRadiationPressureConfiguration(area=ParameterIndex(3), cr=ParameterIndex(4), eclipse_model=Conical)\n# Third-body: ThirdBodyConfiguration(ephemeris_source=DE440s, bodies=[Sun, Moon])\n# Relativity: True\n# Mass: Value(1000.0)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::GravityModelType;\n\nfn main() {\n\n    // Create a fully-configured force model\n    let force_config = bh::ForceModelConfig {\n        // Gravity: Spherical harmonic model (EGM2008, 20x20 degree/order)\n        gravity: bh::GravityConfiguration::SphericalHarmonic {\n            source: bh::GravityModelSource::ModelType(GravityModelType::EGM2008_360),\n            degree: 20,\n            order: 20,\n        },\n        // Atmospheric drag: Harris-Priester model with parameter indices\n        drag: Some(bh::DragConfiguration {\n            model: bh::AtmosphericModel::HarrisPriester,\n            area: bh::ParameterSource::ParameterIndex(1), // Index into parameter vector\n            cd: bh::ParameterSource::ParameterIndex(2),\n        }),\n        // Solar radiation pressure: Conical eclipse model\n        srp: Some(bh::SolarRadiationPressureConfiguration {\n            area: bh::ParameterSource::ParameterIndex(3),\n            cr: bh::ParameterSource::ParameterIndex(4),\n            eclipse_model: bh::EclipseModel::Conical,\n        }),\n        // Third-body: Sun and Moon with DE440s ephemeris\n        third_body: Some(bh::ThirdBodyConfiguration {\n            ephemeris_source: bh::EphemerisSource::DE440s,\n            bodies: vec![bh::ThirdBody::Sun, bh::ThirdBody::Moon],\n        }),\n        // General relativistic corrections\n        relativity: true,\n        // Spacecraft mass (can also use ParameterIndex for estimation)\n        mass: Some(bh::ParameterSource::Value(1000.0)), // kg\n    };\n\n    println!(\"Gravity: {:?}\", force_config.gravity);\n    println!(\"Drag: {:?}\", force_config.drag);\n    println!(\"SRP: {:?}\", force_config.srp);\n    println!(\"Third-body: {:?}\", force_config.third_body);\n    println!(\"Relativity: {:?}\", force_config.relativity);\n    println!(\"Mass: {:?}\", force_config.mass);\n    // Gravity: SphericalHarmonic { source: ModelType(EGM2008_360), degree: 20, order: 20 }\n    // Drag: Some(DragConfiguration { model: HarrisPriester, area: ParameterIndex(1), cd: ParameterIndex(2) })\n    // SRP: Some(SolarRadiationPressureConfiguration { area: ParameterIndex(3), cr: ParameterIndex(4), eclipse_model: Conical })\n    // Third-body: Some(ThirdBodyConfiguration { ephemeris_source: DE440s, bodies: [Sun, Moon] })\n    // Relativity: true\n    // Mass: Some(Value(1000.0))\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#architecture-overview","title":"Architecture Overview","text":""},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p><code>ForceModelConfig</code> is the top-level container that aggregates all force model settings. Each force type has its own configuration struct:</p> <pre><code>ForceModelConfig\n\u251c\u2500\u2500 gravity: GravityConfiguration\n\u2502   \u251c\u2500\u2500 PointMass\n\u2502   \u2514\u2500\u2500 SphericalHarmonic { source, degree, order }\n\u251c\u2500\u2500 drag: DragConfiguration\n\u2502   \u251c\u2500\u2500 model: AtmosphericModel\n\u2502   \u251c\u2500\u2500 area: ParameterSource\n\u2502   \u2514\u2500\u2500 cd: ParameterSource\n\u251c\u2500\u2500 srp: SolarRadiationPressureConfiguration\n\u2502   \u251c\u2500\u2500 area: ParameterSource\n\u2502   \u251c\u2500\u2500 cr: ParameterSource\n\u2502   \u2514\u2500\u2500 eclipse_model: EclipseModel\n\u251c\u2500\u2500 third_body: ThirdBodyConfiguration\n\u2502   \u251c\u2500\u2500 ephemeris_source: EphemerisSource\n\u2502   \u2514\u2500\u2500 bodies: Vec&lt;ThirdBody&gt;\n\u251c\u2500\u2500 relativity: bool\n\u2514\u2500\u2500 mass: ParameterSource\n</code></pre> <p>Each sub-configuration is optional (<code>None</code> disables that force). The configuration is captured at propagator construction time and remains immutable during propagation.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#parameter-sources","title":"Parameter Sources","text":"<p>Spacecraft parameters (mass \\(m\\), drag area \\(A_d\\), coefficient of drag \\(C_d\\), SRP area \\(A_{SRP}\\), coefficient of reflectivity \\(C_r\\)) can be specified in two ways via <code>ParameterSource</code>:</p> <ul> <li> <p><code>Value(f64)</code> - Fixed constant embedded at construction. The value is baked into the dynamics function and cannot change during propagation.</p> </li> <li> <p><code>ParameterIndex(usize)</code> - Index into an parameter vector. This allows parameters to be varied or estimated as part of orbit determination or sensitivity analysis.</p> </li> </ul> <p>The Parameter Configuration section below provides detailed examples of both approaches.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#force-model-components","title":"Force Model Components","text":""},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#gravity-configuration","title":"Gravity Configuration","text":"<p>Gravity is the primary force in orbital mechanics. Brahe supports two gravity models:</p> <p>Point Mass: Simple two-body central gravity. Fast but ignores Earth's non-spherical shape.</p> \\[ \\mathbf{a} = -\\frac{GM}{r^3} \\mathbf{r} \\] PythonRust <pre><code>import brahe as bh\n\n# Point mass gravity is configured using GravityConfiguration.point_mass()\n# This uses only central body gravity (mu/r^2) - no spherical harmonics\n\n# Create point mass gravity configuration\ngravity = bh.GravityConfiguration.point_mass()\n\n# Use two_body() preset which includes point mass gravity\nforce_config = bh.ForceModelConfig.two_body()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Point mass gravity configuration\n    // Uses only central body gravity (mu/r^2)\n    // No spherical harmonics, J2, or higher-order terms\n    let _force_config = bh::ForceModelConfig {\n        gravity: bh::GravityConfiguration::PointMass,\n        drag: None,\n        srp: None,\n        third_body: None,\n        relativity: false,\n        mass: None,\n    };\n}\n</code></pre> <p>Spherical Harmonics: High-fidelity gravity using EGM2008, GGM05S, or user-defined <code>.gfc</code> model. Degree and order control accuracy vs computation time.</p> \\[ \\mathbf{a} = -\\nabla V, \\quad V(r, \\phi, \\lambda) = \\frac{GM}{r} \\sum_{n=0}^{N} \\sum_{m=0}^{n} \\left(\\frac{R_E}{r}\\right)^n \\bar{P}_{nm}(\\sin\\phi) \\left(\\bar{C}_{nm}\\cos(m\\lambda) + \\bar{S}_{nm}\\sin(m\\lambda)\\right) \\] PythonRust <pre><code>import brahe as bh\n\n# ==============================================================================\n# Packaged Gravity Models\n# ==============================================================================\n\n# EGM2008 - High-fidelity NGA model (360x360 max)\ngravity_egm2008 = bh.GravityConfiguration.spherical_harmonic(\n    degree=20, order=20, model_type=bh.GravityModelType.EGM2008_360\n)\n\n# GGM05S - GRACE mission model (180x180 max)\ngravity_ggm05s = bh.GravityConfiguration.spherical_harmonic(\n    degree=20, order=20, model_type=bh.GravityModelType.GGM05S\n)\n\n# JGM3 - Legacy model, fast computation (70x70 max)\ngravity_jgm3 = bh.GravityConfiguration.spherical_harmonic(\n    degree=20, order=20, model_type=bh.GravityModelType.JGM3\n)\n\n# ==============================================================================\n# Custom Model from File\n# ==============================================================================\n\n# Load custom gravity model from GFC format file\n# GravityModelType.from_file validates the path exists\ncustom_model_type = bh.GravityModelType.from_file(\"data/gravity_models/EGM2008_360.gfc\")\ngravity_custom = bh.GravityConfiguration.spherical_harmonic(\n    degree=20, order=20, model_type=custom_model_type\n)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::GravityModelType;\n\nfn main() {\n    // ==========================================================================\n    // Packaged Gravity Models\n    // ==========================================================================\n\n    // EGM2008 - High-fidelity NGA model (360x360 max)\n    let _gravity_egm2008 = bh::GravityConfiguration::SphericalHarmonic {\n        source: bh::GravityModelSource::ModelType(GravityModelType::EGM2008_360),\n        degree: 20,\n        order: 20,\n    };\n\n    // GGM05S - GRACE mission model (180x180 max)\n    let _gravity_ggm05s = bh::GravityConfiguration::SphericalHarmonic {\n        source: bh::GravityModelSource::ModelType(GravityModelType::GGM05S),\n        degree: 20,\n        order: 20,\n    };\n\n    // JGM3 - Legacy model, fast computation (70x70 max)\n    let _gravity_jgm3 = bh::GravityConfiguration::SphericalHarmonic {\n        source: bh::GravityModelSource::ModelType(GravityModelType::JGM3),\n        degree: 20,\n        order: 20,\n    };\n\n    // ==========================================================================\n    // Custom Model from File\n    // ==========================================================================\n\n    // Load custom gravity model from GFC format file\n    // GravityModelType::from_file validates the path exists\n    let custom_model_type =\n        GravityModelType::from_file(\"data/gravity_models/EGM2008_360.gfc\").unwrap();\n    let _gravity_custom = bh::GravityConfiguration::SphericalHarmonic {\n        source: bh::GravityModelSource::ModelType(custom_model_type),\n        degree: 20,\n        order: 20,\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#atmospheric-drag","title":"Atmospheric Drag","text":"<p>Atmospheric drag is significant for LEO satellites.</p> \\[ \\mathbf{a}_D = -\\frac{1}{2} C_D \\frac{A}{m} \\rho v_{rel}^2 \\mathbf{\\hat{v}}_{rel} \\] <p>where \\(\\rho\\) is atmospheric density, \\(v_{rel}\\) is velocity relative to the atmosphere, \\(C_D\\) is drag coefficient, and \\(A/m\\) is area-to-mass ratio.</p> <p>Three atmospheric models are available:</p> <p>Harris-Priester: Fast model with diurnal density variations. Valid 100-1000 km altitude. No space weather data required.</p> PythonRust <pre><code>import brahe as bh\n\n# Harris-Priester atmospheric drag configuration\n# - Valid for altitudes 100-1000 km\n# - Accounts for latitude-dependent diurnal bulge\n# - Does not require space weather data (F10.7, Ap)\n\n# Create drag configuration using parameter indices (default layout)\ndrag_config = bh.DragConfiguration(\n    model=bh.AtmosphericModel.HARRIS_PRIESTER,\n    area=bh.ParameterSource.parameter_index(1),  # drag_area from params[1]\n    cd=bh.ParameterSource.parameter_index(2),  # Cd from params[2]\n)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Harris-Priester atmospheric drag configuration\n    // - Valid for altitudes 100-1000 km\n    // - Accounts for latitude-dependent diurnal bulge\n    // - Does not require space weather data (F10.7, Ap)\n\n    // Using parameter indices (default layout)\n    let _drag_config = bh::DragConfiguration {\n        model: bh::AtmosphericModel::HarrisPriester,\n        area: bh::ParameterSource::ParameterIndex(1), // drag_area from params[1]\n        cd: bh::ParameterSource::ParameterIndex(2),   // Cd from params[2]\n    };\n}\n</code></pre> <p>NRLMSISE-00: High-fidelity empirical model using space weather data. Valid from ground to thermosphere (~1000 km). More computationally intensive.</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize space weather data provider\nbh.initialize_sw()\n\n# NRLMSISE-00 atmospheric drag configuration\n# - Naval Research Laboratory Mass Spectrometer and Incoherent Scatter Radar\n# - High-fidelity empirical model\n# - Valid from ground to thermospheric heights\n# - Uses space weather data (F10.7, Ap) when available\n# - More computationally expensive than Harris-Priester\n\n# Create drag configuration with NRLMSISE-00\ndrag_config = bh.DragConfiguration(\n    model=bh.AtmosphericModel.NRLMSISE00,\n    area=bh.ParameterSource.parameter_index(1),  # drag_area from params[1]\n    cd=bh.ParameterSource.parameter_index(2),  # Cd from params[2]\n)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Initialize space weather data provider\n    bh::initialize_sw().unwrap();\n\n    // NRLMSISE-00 atmospheric drag configuration\n    // - Naval Research Laboratory Mass Spectrometer and Incoherent Scatter Radar\n    // - High-fidelity empirical model\n    // - Valid from ground to thermospheric heights\n    // - Uses space weather data (F10.7, Ap) when available\n    // - More computationally expensive than Harris-Priester\n\n    let _drag_config = bh::DragConfiguration {\n        model: bh::AtmosphericModel::NRLMSISE00,\n        area: bh::ParameterSource::ParameterIndex(1), // drag_area from params[1]\n        cd: bh::ParameterSource::ParameterIndex(2),   // Cd from params[2]\n    };\n}\n</code></pre> <p>Exponential: An expontential atmospheric density model defined by which provides a simple approximation that is fast for rough calculations:</p> \\[ \\rho(h) = \\rho_0 e^{-\\frac{h-h_0}{H}} \\] <p>\\(\\rho_0\\) is reference density at altitude \\(h_0\\) and \\(H\\) is scale height.</p> PythonRust <pre><code>import brahe as bh\n\n# Create exponential atmospheric model\nexp_model = bh.AtmosphericModel.exponential(\n    scale_height=53000.0,  # Scale height H in meters (53 km for ~300 km altitude)\n    rho0=1.225e-11,  # Reference density at h0 in kg/m^3\n    h0=300000.0,  # Reference altitude in meters (300 km)\n)\n\n# Create drag configuration with exponential model\ndrag_config = bh.DragConfiguration(\n    model=exp_model,\n    area=bh.ParameterSource.parameter_index(1),\n    cd=bh.ParameterSource.parameter_index(2),\n)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::GravityModelType;\n\nfn main() {\n\n    let drag_config = bh::DragConfiguration {\n        model: bh::AtmosphericModel::Exponential {\n            scale_height: 53000.0, // Scale height H in meters (53 km for ~300 km altitude)\n            rho0: 1.225e-11,       // Reference density at h0 in kg/m^3\n            h0: 300000.0,          // Reference altitude in meters (300 km)\n        },\n        area: bh::ParameterSource::ParameterIndex(1),\n        cd: bh::ParameterSource::ParameterIndex(2),\n    };\n\n    // Create force model with exponential drag\n    let _force_config = bh::ForceModelConfig {\n        gravity: bh::GravityConfiguration::SphericalHarmonic {\n            source: bh::GravityModelSource::ModelType(GravityModelType::EGM2008_360),\n            degree: 20,\n            order: 20,\n        },\n        drag: Some(drag_config),\n        srp: None,\n        third_body: None,\n        relativity: false,\n        mass: Some(bh::ParameterSource::ParameterIndex(0)),\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#solar-radiation-pressure","title":"Solar Radiation Pressure","text":"<p>SRP is significant for high-altitude orbits and high area-to-mass ratio spacecraft.</p> \\[ \\mathbf{a}_{SRP} = -P_{\\odot} C_R \\frac{A}{m} \\nu \\frac{\\mathbf{r}_{\\odot}}{|\\mathbf{r}_{\\odot}|} \\] <p>where \\(P_{\\odot} \\approx 4.56 \\times 10^{-6}\\) N/m\u00b2 is solar pressure at 1 AU, \\(C_R\\) is reflectivity coefficient, \\(\\nu\\) is shadow function (0-1), and \\(\\mathbf{r}_{\\odot}\\) is the Sun position vector.</p> <p>Eclipse models determine shadow effects:</p> <ul> <li>None: Always illuminated (fast, inaccurate in shadow)</li> <li>Cylindrical: Sharp shadow boundary (simple, fast)</li> <li>Conical: Penumbra and umbra regions (most accurate)</li> </ul> PythonRust <pre><code>import brahe as bh\n\n# Solar Radiation Pressure configuration\n# Parameters:\n# - area: Cross-sectional area facing the Sun (m^2)\n# - cr: Coefficient of reflectivity (1.0=absorbing to 2.0=perfectly reflecting)\n# - eclipse_model: How to handle Earth's shadow\n\n# Option 1: No eclipse model (always illuminated)\n# Fast but inaccurate during eclipse periods\nsrp_cylindrical = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.parameter_index(3),  # srp_area from params[3]\n    cr=bh.ParameterSource.parameter_index(4),  # Cr from params[4]\n    eclipse_model=bh.EclipseModel.NONE,\n)\n\n# Option 2: Cylindrical shadow model\n# Simple and fast, sharp shadow boundary (no penumbra)\nsrp_cylindrical = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.parameter_index(3),  # srp_area from params[3]\n    cr=bh.ParameterSource.parameter_index(4),  # Cr from params[4]\n    eclipse_model=bh.EclipseModel.CYLINDRICAL,\n)\n\n# Option 2: Conical shadow model (recommended)\n# Accounts for penumbra and umbra regions\nsrp_conical = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.parameter_index(3),\n    cr=bh.ParameterSource.parameter_index(4),\n    eclipse_model=bh.EclipseModel.CONICAL,\n)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Solar Radiation Pressure configuration\n    // Parameters:\n    // - area: Cross-sectional area facing the Sun (m^2)\n    // - cr: Coefficient of reflectivity (1.0=absorbing to 2.0=perfectly reflecting)\n    // - eclipse_model: How to handle Earth's shadow\n\n    // Option 1: No eclipse model (always illuminated)\n    // Fast but inaccurate during eclipse periods\n    let _srp_no_eclipse = bh::SolarRadiationPressureConfiguration {\n        area: bh::ParameterSource::ParameterIndex(3), // srp_area from params[3]\n        cr: bh::ParameterSource::ParameterIndex(4),   // Cr from params[4]\n        eclipse_model: bh::EclipseModel::None,\n    };\n\n    // Option 2: Cylindrical shadow model\n    // Simple and fast, sharp shadow boundary (no penumbra)\n    let _srp_cylindrical = bh::SolarRadiationPressureConfiguration {\n        area: bh::ParameterSource::ParameterIndex(3),\n        cr: bh::ParameterSource::ParameterIndex(4),\n        eclipse_model: bh::EclipseModel::Cylindrical,\n    };\n\n    // Option 3: Conical shadow model (recommended)\n    // Accounts for penumbra and umbra regions\n    let _srp_conical = bh::SolarRadiationPressureConfiguration {\n        area: bh::ParameterSource::ParameterIndex(3),\n        cr: bh::ParameterSource::ParameterIndex(4),\n        eclipse_model: bh::EclipseModel::Conical,\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#third-body-perturbations","title":"Third-Body Perturbations","text":"<p>Gravitational attraction from Sun, Moon, and planets causes long-period variations in orbital elements.</p> \\[ \\mathbf{a}_{TB} = GM_{b} \\left(\\frac{\\mathbf{r}_b - \\mathbf{r}}{|\\mathbf{r}_b - \\mathbf{r}|^3} - \\frac{\\mathbf{r}_b}{|\\mathbf{r}_b|^3}\\right) \\] <p>where \\(GM_b\\) is the gravitational parameter of the third body, \\(\\mathbf{r}_b\\) is its position, and \\(\\mathbf{r}\\) is the satellite position.</p> <p>Ephemeris sources:</p> <ul> <li>LowPrecision: Fast analytical, Sun/Moon only</li> <li>DE440s: JPL high precision, all planets, 1550-2650 CE</li> <li>DE440: JPL high precision, all planets, 13200 BCE-17191 CE</li> </ul> PythonRust <pre><code>import brahe as bh\n\n# Third-body perturbations configuration\n# Gravitational attraction from other celestial bodies\n\n# Option 1: Low-precision analytical ephemerides\n# Fast but less accurate (~km level errors for Sun/Moon)\n# Only Sun and Moon are available\nthird_body_low = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.LowPrecision,\n    bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON],\n)\n\n# Option 2: DE440s high-precision ephemerides (recommended)\n# Uses JPL Development Ephemeris 440 (small bodies version)\n# ~m level accuracy, valid 1550-2650 CE\n# All planets available, ~17 MB file\nthird_body_de440s = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.DE440s,\n    bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON],\n)\n\n# Option 3: DE440 full-precision ephemerides\n# Highest accuracy (~mm level), valid 13200 BCE-17191 CE\n# All planets available, ~114 MB file\nthird_body_de440 = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.DE440,\n    bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON],\n)\n\n# Option 4: Include all major planets (high-fidelity)\nthird_body_all_planets = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.DE440s,\n    bodies=[\n        bh.ThirdBody.SUN,\n        bh.ThirdBody.MOON,\n        bh.ThirdBody.MERCURY,\n        bh.ThirdBody.VENUS,\n        bh.ThirdBody.MARS,\n        bh.ThirdBody.JUPITER,\n        bh.ThirdBody.SATURN,\n        bh.ThirdBody.URANUS,\n        bh.ThirdBody.NEPTUNE,\n    ],\n)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::GravityModelType;\n\nfn main() {\n    // Third-body perturbations configuration\n    // Gravitational attraction from other celestial bodies\n\n    // Option 1: Low-precision analytical ephemerides\n    // Fast but less accurate (~km level errors for Sun/Moon)\n    // Only Sun and Moon are available\n    let _third_body_low = bh::ThirdBodyConfiguration {\n        ephemeris_source: bh::EphemerisSource::LowPrecision,\n        bodies: vec![bh::ThirdBody::Sun, bh::ThirdBody::Moon],\n    };\n\n    // Option 2: DE440s high-precision ephemerides (recommended)\n    // Uses JPL Development Ephemeris 440 (small bodies version)\n    // ~m level accuracy, valid 1550-2650 CE\n    // All planets available, ~17 MB file\n    let third_body_de440s = bh::ThirdBodyConfiguration {\n        ephemeris_source: bh::EphemerisSource::DE440s,\n        bodies: vec![bh::ThirdBody::Sun, bh::ThirdBody::Moon],\n    };\n\n    // Option 3: DE440 full-precision ephemerides\n    // Highest accuracy (~mm level), valid 13200 BCE-17191 CE\n    // All planets available, ~114 MB file\n    let _third_body_de440 = bh::ThirdBodyConfiguration {\n        ephemeris_source: bh::EphemerisSource::DE440,\n        bodies: vec![bh::ThirdBody::Sun, bh::ThirdBody::Moon],\n    };\n\n    // Option 4: Include all major planets (high-fidelity)\n    let _third_body_all_planets = bh::ThirdBodyConfiguration {\n        ephemeris_source: bh::EphemerisSource::DE440s,\n        bodies: vec![\n            bh::ThirdBody::Sun,\n            bh::ThirdBody::Moon,\n            bh::ThirdBody::Mercury,\n            bh::ThirdBody::Venus,\n            bh::ThirdBody::Mars,\n            bh::ThirdBody::Jupiter,\n            bh::ThirdBody::Saturn,\n            bh::ThirdBody::Uranus,\n            bh::ThirdBody::Neptune,\n        ],\n    };\n\n    // Create force model with Sun/Moon perturbations (common case)\n    let _force_config = bh::ForceModelConfig {\n        gravity: bh::GravityConfiguration::SphericalHarmonic {\n            source: bh::GravityModelSource::ModelType(GravityModelType::EGM2008_360),\n            degree: 20,\n            order: 20,\n        },\n        drag: None,\n        srp: None,\n        third_body: Some(third_body_de440s),\n        relativity: false,\n        mass: None,\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#relativistic-effects","title":"Relativistic Effects","text":"<p>General relativistic corrections can be enabled via the <code>relativity</code> boolean flag. These effects are typically small but can be significant for precision orbit determination.</p> \\[ \\mathbf{a} = -\\frac{GM}{r^2} \\left( \\left( 4\\frac{GM}{c^2r} - \\frac{v^2}{c^2} \\right)\\mathbf{e}_r + 4\\frac{v^2}{c^2}\\left(\\mathbf{e}_r \\cdot \\mathbf{e}_v\\right)\\mathbf{e}_v\\right) \\] <p>where \\(c\\) is the speed of light, \\(\\mathbf{e}_r\\) is the radial unit vector, and \\(\\mathbf{e}_v\\) is the velocity unit vector.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#parameter-configuration","title":"Parameter Configuration","text":"<p>Force model parameters (mass, drag area, Cd, etc.) can be specified either as fixed values or as indices into a parameter vector.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#using-fixed-values","title":"Using Fixed Values","text":"<p>Use <code>ParameterSource.value()</code> (Python) / <code>ParameterSource::Value</code> (Rust) for parameters that don't change:</p> PythonRust <pre><code>import brahe as bh\n\n# ParameterSource.value() creates a fixed constant parameter\n# Use when the parameter doesn't change and doesn't need to be estimated\n\n# Example: Fixed drag configuration\n# Mass, drag area, and Cd are all constant\ndrag_config = bh.DragConfiguration(\n    model=bh.AtmosphericModel.HARRIS_PRIESTER,\n    area=bh.ParameterSource.value(10.0),  # Fixed 10 m^2 drag area\n    cd=bh.ParameterSource.value(2.2),  # Fixed Cd of 2.2\n)\n\n# Example: Fixed SRP configuration\nsrp_config = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.value(15.0),  # Fixed 15 m^2 SRP area\n    cr=bh.ParameterSource.value(1.3),  # Fixed Cr of 1.3\n    eclipse_model=bh.EclipseModel.CONICAL,\n)\n\n# Create force model with all fixed parameters\n# Start from two_body preset and add components\nforce_config = bh.ForceModelConfig.two_body()\nforce_config.gravity = bh.GravityConfiguration.spherical_harmonic(20, 20)\nforce_config.drag = drag_config\nforce_config.srp = srp_config\nforce_config.third_body = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.LowPrecision,\n    bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON],\n)\nforce_config.mass = bh.ParameterSource.value(500.0)  # Fixed 500 kg mass\n</code></pre> <pre><code>use brahe as bh;\nuse bh::GravityModelType;\n\nfn main() {\n    // ParameterSource::Value creates a fixed constant parameter\n    // Use when the parameter doesn't change and doesn't need to be estimated\n\n    // Example: Fixed drag configuration\n    // Mass, drag area, and Cd are all constant\n    let drag_config = bh::DragConfiguration {\n        model: bh::AtmosphericModel::HarrisPriester,\n        area: bh::ParameterSource::Value(10.0), // Fixed 10 m^2 drag area\n        cd: bh::ParameterSource::Value(2.2),    // Fixed Cd of 2.2\n    };\n\n    // Example: Fixed SRP configuration\n    let srp_config = bh::SolarRadiationPressureConfiguration {\n        area: bh::ParameterSource::Value(15.0), // Fixed 15 m^2 SRP area\n        cr: bh::ParameterSource::Value(1.3),    // Fixed Cr of 1.3\n        eclipse_model: bh::EclipseModel::Conical,\n    };\n\n    // Create force model with all fixed parameters\n    let _force_config = bh::ForceModelConfig {\n        gravity: bh::GravityConfiguration::SphericalHarmonic {\n            source: bh::GravityModelSource::ModelType(GravityModelType::EGM2008_360),\n            degree: 20,\n            order: 20,\n        },\n        drag: Some(drag_config),\n        srp: Some(srp_config),\n        third_body: Some(bh::ThirdBodyConfiguration {\n            ephemeris_source: bh::EphemerisSource::LowPrecision,\n            bodies: vec![bh::ThirdBody::Sun, bh::ThirdBody::Moon],\n        }),\n        relativity: false,\n        mass: Some(bh::ParameterSource::Value(500.0)), // Fixed 500 kg mass\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#using-parameter-indices","title":"Using Parameter Indices","text":"<p>Use <code>ParameterSource.from_index()</code> (Python) / <code>ParameterSource::ParameterIndex</code> (Rust) for parameters that may be varied or estimated:</p> PythonRust <pre><code>import brahe as bh\n\n# ParameterSource.parameter_index() references a value in the parameter vector\n# Use when parameters may change or need to be estimated\n\n# Default parameter layout:\n# Index 0: mass (kg)\n# Index 1: drag_area (m^2)\n# Index 2: Cd (dimensionless)\n# Index 3: srp_area (m^2)\n# Index 4: Cr (dimensionless)\n\ndrag_config = bh.DragConfiguration(\n    model=bh.AtmosphericModel.HARRIS_PRIESTER,\n    area=bh.ParameterSource.parameter_index(1),  # params[1] = drag_area\n    cd=bh.ParameterSource.parameter_index(2),  # params[2] = Cd\n)\n\nsrp_config = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.parameter_index(3),  # params[3] = srp_area\n    cr=bh.ParameterSource.parameter_index(4),  # params[4] = Cr\n    eclipse_model=bh.EclipseModel.CONICAL,\n)\n\n# Custom parameter layout example\ncustom_drag = bh.DragConfiguration(\n    model=bh.AtmosphericModel.HARRIS_PRIESTER,\n    area=bh.ParameterSource.parameter_index(5),  # Custom index\n    cd=bh.ParameterSource.parameter_index(10),  # Custom index\n)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // ParameterSource::ParameterIndex references a value in the parameter vector\n    // Use when parameters may change or need to be estimated\n\n    // Default parameter layout:\n    // Index 0: mass (kg)\n    // Index 1: drag_area (m^2)\n    // Index 2: Cd (dimensionless)\n    // Index 3: srp_area (m^2)\n    // Index 4: Cr (dimensionless)\n\n    let _drag_config = bh::DragConfiguration {\n        model: bh::AtmosphericModel::HarrisPriester,\n        area: bh::ParameterSource::ParameterIndex(1), // params[1] = drag_area\n        cd: bh::ParameterSource::ParameterIndex(2),   // params[2] = Cd\n    };\n\n    let _srp_config = bh::SolarRadiationPressureConfiguration {\n        area: bh::ParameterSource::ParameterIndex(3), // params[3] = srp_area\n        cr: bh::ParameterSource::ParameterIndex(4),   // params[4] = Cr\n        eclipse_model: bh::EclipseModel::Conical,\n    };\n\n    // Custom parameter layout example\n    println!(\"\\nCustom parameter layout example:\");\n    println!(\"  You can map parameters to any indices:\");\n    let _custom_drag = bh::DragConfiguration {\n        model: bh::AtmosphericModel::HarrisPriester,\n        area: bh::ParameterSource::ParameterIndex(5),  // Custom index\n        cd: bh::ParameterSource::ParameterIndex(10),   // Custom index\n    };\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#default-parameter-layout","title":"Default Parameter Layout","text":"<p>When using parameter indices, the default layout is:</p> Index Parameter Units Typical Value 0 mass kg 1000.0 1 drag_area m\u00b2 10.0 2 Cd - 2.2 3 srp_area m\u00b2 10.0 4 Cr - 1.3"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#preset-configurations","title":"Preset Configurations","text":"<p>Brahe provides preset configurations for common scenarios:</p> Preset Gravity Drag SRP Third-Body Relativity Requires Params <code>two_body()</code> PointMass None None None No No <code>earth_gravity()</code> 20\u00d720 None None None No No <code>conservative_forces()</code> 80\u00d780 None None Sun/Moon (DE440s) Yes No <code>default()</code> 20\u00d720 Harris-Priester Conical Sun/Moon (LP) No Yes <code>leo_default()</code> 30\u00d730 NRLMSISE-00 Conical Sun/Moon (DE440s) No Yes <code>geo_default()</code> 8\u00d78 None Conical Sun/Moon (DE440s) No Yes <code>high_fidelity()</code> 120\u00d7120 NRLMSISE-00 Conical All planets (DE440s) Yes Yes PythonRust <pre><code>import brahe as bh\n\n# Brahe provides several preset configurations for common scenarios\n\n# 1. two_body() - Point mass gravity only\n# Use for: Validation, comparison with Keplerian, quick estimates\ntwo_body = bh.ForceModelConfig.two_body()\n\n# 2. earth_gravity() - Spherical harmonic gravity only (20x20)\n# Use for: Studying gravity perturbations in isolation\nearth_gravity = bh.ForceModelConfig.earth_gravity()\n\n# 3. conservative_forces() - Gravity + third-body + relativity (no drag/SRP)\n# Use for: Long-term orbit evolution, conservative dynamics studies\nconservative = bh.ForceModelConfig.conservative_forces()\n\n# 4. default() - Balanced configuration for LEO to GEO\n# Use for: General mission analysis, initial studies\ndefault = bh.ForceModelConfig.default()\n\n# 5. leo_default() - Optimized for Low Earth Orbit\n# Use for: LEO missions where drag is dominant\nleo = bh.ForceModelConfig.leo_default()\n\n# 6. geo_default() - Optimized for Geostationary Orbit\n# Use for: GEO missions where SRP and third-body dominate\ngeo = bh.ForceModelConfig.geo_default()\n\n# 7. high_fidelity() - Maximum precision\n# Use for: Precision orbit determination, research applications\nhigh_fidelity = bh.ForceModelConfig.high_fidelity()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Brahe provides several preset configurations for common scenarios\n\n    // 1. two_body_gravity() - Point mass gravity only\n    // Use for: Validation, comparison with Keplerian, quick estimates\n    let _two_body = bh::ForceModelConfig::two_body_gravity();\n\n    // 2. earth_gravity() - Spherical harmonic gravity only (20x20)\n    // Use for: Studying gravity perturbations in isolation\n    let _earth_gravity = bh::ForceModelConfig::earth_gravity();\n\n    // 3. conservative_forces() - Gravity + third-body + relativity (no drag/SRP)\n    // Use for: Long-term orbit evolution, conservative dynamics studies\n    let _conservative = bh::ForceModelConfig::conservative_forces();\n\n    // 4. default() - Balanced configuration for LEO to GEO\n    // Use for: General mission analysis, initial studies\n    let _default = bh::ForceModelConfig::default();\n\n    // 5. leo_default() - Optimized for Low Earth Orbit\n    // Use for: LEO missions where drag is dominant\n    let _leo = bh::ForceModelConfig::leo_default();\n\n    // 6. geo_default() - Optimized for Geostationary Orbit\n    // Use for: GEO missions where SRP and third-body dominate\n    let _geo = bh::ForceModelConfig::geo_default();\n\n    // 7. high_fidelity() - Maximum precision\n    // Use for: Precision orbit determination, research applications\n    let _high_fidelity = bh::ForceModelConfig::high_fidelity();\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/force_models.html#see-also","title":"See Also","text":"<ul> <li>Numerical Propagation Overview - Architecture and concepts</li> <li>Integrator Configuration - Integration methods</li> <li>ForceModelConfig API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html","title":"General Dynamics Propagation","text":"<p>The <code>NumericalPropagator</code> provides a general-purpose numerical integrator for arbitrary ordinary differential equations (ODEs). Unlike <code>NumericalOrbitPropagator</code> which has built-in orbital force models, the generic propagator accepts user-defined dynamics functions for any dynamical system.</p> <p>For API details, see the NumericalPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#when-to-use-general-dynamics","title":"When to Use General Dynamics","text":"<p>Use <code>NumericalPropagator</code> when:</p> <ul> <li>Propagating non-orbital systems (simple harmonic oscillators, population models, etc.)</li> <li>Implementing custom force models not available in <code>NumericalOrbitPropagator</code></li> <li>Integrating coupled systems (orbit + attitude, multiple bodies, etc.)</li> <li>Prototyping custom dynamics before committing to the orbital framework</li> </ul> <p>For orbital mechanics with extended state (mass, battery, temperature tracking), prefer <code>NumericalOrbitPropagator</code> with <code>additional_dynamics</code>. See Extending Spacecraft State.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#full-example","title":"Full Example","text":"<p>The following example demonstrates propagating a simple harmonic oscillator (SHO), a canonical test case for numerical integrators:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data (needed for epoch operations)\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Simple Harmonic Oscillator (SHO)\n# State: [x, v] where x is position and v is velocity\n# Dynamics: dx/dt = v, dv/dt = -omega^2 * x\nomega = 2.0 * np.pi  # 1 Hz oscillation frequency\n\n# Initial state: displaced from equilibrium\nx0 = 1.0  # 1 meter displacement\nv0 = 0.0  # Starting from rest\ninitial_state = np.array([x0, v0])\n\n\ndef sho_dynamics(t, state, params):\n    \"\"\"Simple harmonic oscillator dynamics.\"\"\"\n    x, v = state[0], state[1]\n    omega_sq = params[0] if params is not None else omega**2\n    return np.array([v, -omega_sq * x])\n\n\n# Parameters (omega^2)\nparams = np.array([omega**2])\n\n# Create generic numerical propagator\nprop = bh.NumericalPropagator(\n    epoch,\n    initial_state,\n    sho_dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params,\n)\n\n# Propagate for several periods\nperiod = 2 * np.pi / omega  # Period = 2*pi/omega = 1 second\nprop.propagate_to(epoch + 5 * period)\n\n# Sample trajectory\nprint(\"Simple Harmonic Oscillator Trajectory:\")\nprint(\"  omega = 2*pi rad/s (1 Hz)\")\nprint(\"  x0 = 1.0 m, v0 = 0.0 m/s\")\nprint(\"\\nTime (s)  Position (m)  Velocity (m/s)  Analytical x\")\nprint(\"-\" * 55)\n\nfor i in range(11):\n    t = i * period / 2  # Sample at half-period intervals\n    state = prop.state(epoch + t)\n    # Analytical solution: x(t) = x0*cos(omega*t), v(t) = -x0*omega*sin(omega*t)\n    x_analytical = x0 * np.cos(omega * t)\n    print(\n        f\"  {t:.2f}      {state[0]:+.6f}      {state[1]:+.6f}      {x_analytical:+.6f}\"\n    )\n\n# Validate - after full period should return to initial\nfinal_state = prop.state(epoch + 5 * period)\nerror_x = abs(final_state[0] - x0)\nerror_v = abs(final_state[1] - v0)\n\nprint(\"\\nAfter 5 periods:\")\nprint(f\"  Position error: {error_x:.2e} m\")\nprint(f\"  Velocity error: {error_v:.2e} m/s\")\n\nassert error_x &lt; 0.01  # Within 1 cm\nassert error_v &lt; 0.1  # Within 10 cm/s\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DStatePropagator, DStateProvider};\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data (needed for epoch operations)\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Simple Harmonic Oscillator (SHO)\n    // State: [x, v] where x is position and v is velocity\n    // Dynamics: dx/dt = v, dv/dt = -omega^2 * x\n    let omega = 2.0 * PI; // 1 Hz oscillation frequency\n\n    // Initial state: displaced from equilibrium\n    let x0 = 1.0; // 1 meter displacement\n    let v0 = 0.0; // Starting from rest\n    let initial_state = na::DVector::from_vec(vec![x0, v0]);\n\n    // SHO dynamics function\n    let dynamics_fn: bh::DStateDynamics = Box::new(\n        move |_t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let x = state[0];\n            let v = state[1];\n            let omega_sq = params.map(|p| p[0]).unwrap_or(omega * omega);\n            na::DVector::from_vec(vec![v, -omega_sq * x])\n        },\n    );\n\n    // Parameters (omega^2)\n    let params = na::DVector::from_vec(vec![omega * omega]);\n\n    // Create generic numerical propagator\n    let mut prop = bh::DNumericalPropagator::new(\n        epoch,\n        initial_state,\n        dynamics_fn,\n        bh::NumericalPropagationConfig::default(),\n        Some(params),\n        None, // No control input\n        None, // No initial covariance\n    )\n    .unwrap();\n\n    // Propagate for several periods\n    let period = 2.0 * PI / omega; // Period = 2*pi/omega = 1 second\n    prop.propagate_to(epoch + 5.0 * period);\n\n    // Sample trajectory\n    println!(\"Simple Harmonic Oscillator Trajectory:\");\n    println!(\"  omega = 2*pi rad/s (1 Hz)\");\n    println!(\"  x0 = 1.0 m, v0 = 0.0 m/s\");\n    println!(\"\\nTime (s)  Position (m)  Velocity (m/s)  Analytical x\");\n    println!(\"{}\", \"-\".repeat(55));\n\n    for i in 0..11 {\n        let t = (i as f64) * period / 2.0; // Sample at half-period intervals\n        let state = prop.state(epoch + t).unwrap();\n        // Analytical solution: x(t) = x0*cos(omega*t), v(t) = -x0*omega*sin(omega*t)\n        let x_analytical = x0 * (omega * t).cos();\n        println!(\n            \"  {:.2}      {:+.6}      {:+.6}      {:+.6}\",\n            t, state[0], state[1], x_analytical\n        );\n    }\n\n    // Validate - after full period should return to initial\n    let final_state = prop.state(epoch + 5.0 * period).unwrap();\n    let error_x = (final_state[0] - x0).abs();\n    let error_v = (final_state[1] - v0).abs();\n\n    println!(\"\\nAfter 5 periods:\");\n    println!(\"  Position error: {:.2e} m\", error_x);\n    println!(\"  Velocity error: {:.2e} m/s\", error_v);\n\n    assert!(error_x &lt; 0.01);  // Within 1 cm\n    assert!(error_v &lt; 0.1);   // Within 10 cm/s\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#sho-visualization","title":"SHO Visualization","text":"<p>The following plot shows the position and velocity of the SHO over 3 periods, comparing numerical and analytical solutions:</p> Plot Source generic_dynamics_sho.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Simple Harmonic Oscillator parameters\nomega = 2.0 * np.pi  # 1 Hz oscillation frequency\nx0 = 1.0  # 1 meter initial displacement\nv0 = 0.0  # Starting from rest\ninitial_state = np.array([x0, v0])\n\n\ndef sho_dynamics(t, state, params):\n    \"\"\"Simple harmonic oscillator dynamics.\"\"\"\n    x, v = state[0], state[1]\n    omega_sq = params[0] if params is not None else omega**2\n    return np.array([v, -omega_sq * x])\n\n\n# Parameters (omega^2)\nparams = np.array([omega**2])\n\n# Create propagator\nprop = bh.NumericalPropagator(\n    epoch,\n    initial_state,\n    sho_dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params,\n)\n\n# Propagate for 3 periods\nperiod = 2 * np.pi / omega  # Period = 1 second\ntotal_time = 3 * period\nprop.propagate_to(epoch + total_time)\n\n# Sample trajectory at high resolution\ndt = 0.01  # 10 ms intervals\ntimes = []\npositions = []\nvelocities = []\npositions_analytical = []\nvelocities_analytical = []\n\nt = 0.0\nwhile t &lt;= total_time:\n    state = prop.state(epoch + t)\n    times.append(t)\n    positions.append(state[0])\n    velocities.append(state[1])\n\n    # Analytical solution: x(t) = x0*cos(omega*t), v(t) = -x0*omega*sin(omega*t)\n    positions_analytical.append(x0 * np.cos(omega * t))\n    velocities_analytical.append(-x0 * omega * np.sin(omega * t))\n\n    t += dt\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    # Create subplot with 2 rows\n    fig = make_subplots(\n        rows=2,\n        cols=1,\n        subplot_titles=(\"Position vs Time\", \"Velocity vs Time\"),\n        vertical_spacing=0.15,\n    )\n\n    # Position trace (numerical)\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=positions,\n            mode=\"lines\",\n            name=\"Numerical\",\n            line=dict(color=colors[\"primary\"], width=2),\n            legendgroup=\"numerical\",\n        ),\n        row=1,\n        col=1,\n    )\n\n    # Position trace (analytical) - dashed\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=positions_analytical,\n            mode=\"lines\",\n            name=\"Analytical\",\n            line=dict(color=colors[\"secondary\"], width=2, dash=\"dash\"),\n            legendgroup=\"analytical\",\n        ),\n        row=1,\n        col=1,\n    )\n\n    # Velocity trace (numerical)\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=velocities,\n            mode=\"lines\",\n            name=\"Numerical\",\n            line=dict(color=colors[\"primary\"], width=2),\n            legendgroup=\"numerical\",\n            showlegend=False,\n        ),\n        row=2,\n        col=1,\n    )\n\n    # Velocity trace (analytical) - dashed\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=velocities_analytical,\n            mode=\"lines\",\n            name=\"Analytical\",\n            line=dict(color=colors[\"secondary\"], width=2, dash=\"dash\"),\n            legendgroup=\"analytical\",\n            showlegend=False,\n        ),\n        row=2,\n        col=1,\n    )\n\n    # Update layout\n    fig.update_layout(\n        title=\"Simple Harmonic Oscillator (\u03c9 = 2\u03c0 rad/s)\",\n        height=600,\n        margin=dict(l=60, r=40, t=80, b=60),\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"center\",\n            x=0.5,\n        ),\n    )\n\n    # Update x-axes\n    fig.update_xaxes(title_text=\"Time (s)\", row=2, col=1)\n\n    # Update y-axes\n    fig.update_yaxes(title_text=\"Position (m)\", row=1, col=1)\n    fig.update_yaxes(title_text=\"Velocity (m/s)\", row=2, col=1)\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#architecture-overview","title":"Architecture Overview","text":""},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#numericalpropagator-vs-numericalorbitpropagator","title":"NumericalPropagator vs NumericalOrbitPropagator","text":"Feature NumericalOrbitPropagator NumericalPropagator Orbital dynamics Built-in via ForceModelConfig Must implement in dynamics_fn State dimension 6+ (orbital + extended) Any dimension Extended state Via <code>additional_dynamics</code> Include in dynamics_fn Control Via <code>control_input</code> Via <code>control_input</code> Trajectory type <code>(D)OrbitTrajectory</code> with interpolation <code>(D)Trajectory</code> Use case Orbital mechanics Any ODE system"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#dynamics-function","title":"Dynamics Function","text":"<p>The dynamics function defines the system's equations of motion. It receives the current time (seconds from epoch), state vector, and optional parameters, returning the state derivative.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#function-signature","title":"Function Signature","text":"PythonRust <pre><code>def dynamics(t: float, state: np.ndarray, params: np.ndarray | None) -&gt; np.ndarray:\n    \"\"\"\n    Compute state derivative for given time and state.\n\n    Args:\n        t: Time in seconds from reference epoch\n        state: Current state vector (N-dimensional)\n        params: Optional parameter vector\n\n    Returns:\n        State derivative vector (same dimension as state)\n    \"\"\"\n    dstate = np.zeros(len(state))\n    # Compute derivatives based on your equations of motion\n    # ...\n    return dstate\n</code></pre> <pre><code>let dynamics_fn: bh::DStateDynamics = Box::new(\n    |t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| -&gt; na::DVector&lt;f64&gt; {\n        // t: Time in seconds from reference epoch\n        // state: Current state vector (N-dimensional)\n        // params: Optional parameter vector\n\n        let mut dstate = na::DVector::zeros(state.len());\n        // Compute derivatives based on your equations of motion\n        // ...\n        dstate\n    }\n);\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#mathematical-form","title":"Mathematical Form","text":"<p>For a general system, the dynamics function computes:</p> \\[\\dot{\\mathbf{x}} = f(t, \\mathbf{x}, \\mathbf{p})\\] <p>where \\(\\mathbf{x}\\) is the state vector, \\(t\\) is time, and \\(\\mathbf{p}\\) is the parameter vector.</p> <p>For orbital mechanics, the standard 6-element state is:</p> \\[\\mathbf{x} = [x, y, z, v_x, v_y, v_z]^T\\] <p>With derivative:</p> \\[\\dot{\\mathbf{x}} = [v_x, v_y, v_z, a_x, a_y, a_z]^T\\]"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#parameter-handling","title":"Parameter Handling","text":"<p>Parameters allow passing constants to the dynamics function without hardcoding them:</p> PythonRust <pre><code># Define parameters\nparams = np.array([omega**2, damping_coeff, mass])\n\n# Access in dynamics function\ndef dynamics(t, state, params):\n    omega_sq = params[0]\n    damping = params[1]\n    mass = params[2]\n    # Use parameters in computation\n    ...\n\n# Create propagator with parameters\nprop = bh.NumericalPropagator(\n    epoch, initial_state, dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params  # Pass parameters here\n)\n</code></pre> <pre><code>// Define parameters\nlet params = na::DVector::from_vec(vec![omega * omega, damping_coeff, mass]);\n\n// Access in dynamics function\nlet dynamics_fn: bh::DStateDynamics = Box::new(\n    |_t, state, params| {\n        let p = params.unwrap();\n        let omega_sq = p[0];\n        let damping = p[1];\n        let mass = p[2];\n        // Use parameters in computation\n        ...\n    }\n);\n\n// Create propagator with parameters\nlet prop = bh::DNumericalPropagator::new(\n    epoch, initial_state, dynamics_fn,\n    bh::NumericalPropagationConfig::default(),\n    Some(params),  // Pass parameters here\n    None, None\n).unwrap();\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#control-inputs","title":"Control Inputs","text":"<p><code>NumericalPropagator</code> supports a separate <code>control_input</code> function that adds control contributions to the state derivative at each integration step. This separates the natural dynamics from control logic, making it easier to enable/disable control or swap control strategies.</p> <p>The following example shows a damped harmonic oscillator where damping is implemented via <code>control_input</code>:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data (needed for epoch operations)\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Simple Harmonic Oscillator with damping control\n# State: [x, v] where x is position and v is velocity\n# Natural dynamics: dx/dt = v, dv/dt = -omega^2 * x\n# Control adds damping: u = -c * v\nomega = 2.0 * np.pi  # 1 Hz natural frequency\ndamping_ratio = 0.1  # Damping ratio (zeta)\ndamping_coeff = 2 * damping_ratio * omega  # c = 2*zeta*omega\n\n# Initial state: displaced from equilibrium\nx0 = 1.0  # 1 meter displacement\nv0 = 0.0  # Starting from rest\ninitial_state = np.array([x0, v0])\n\n\ndef sho_dynamics(t, state, params):\n    \"\"\"Simple harmonic oscillator dynamics (undamped).\n\n    This function defines only the natural dynamics.\n    Control is added separately via control_input.\n    \"\"\"\n    x, v = state[0], state[1]\n    omega_sq = params[0] if params is not None else omega**2\n    return np.array([v, -omega_sq * x])\n\n\ndef damping_control(t, state, params):\n    \"\"\"Damping control input: u = -c * v (opposes velocity).\n\n    The control_input function returns a state derivative contribution\n    that is added to the dynamics output at each integration step.\n    \"\"\"\n    dx = np.zeros(len(state))\n    v = state[1]\n    # Control adds acceleration that opposes velocity\n    dx[1] = -damping_coeff * v\n    return dx\n\n\n# Parameters (omega^2)\nparams = np.array([omega**2])\n\n# Create propagator with dynamics AND control_input\nprop_damped = bh.NumericalPropagator(\n    epoch,\n    initial_state,\n    sho_dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params,\n    control_input=damping_control,  # Separate control function\n)\n\n# Create undamped propagator for comparison (no control_input)\nprop_undamped = bh.NumericalPropagator(\n    epoch,\n    initial_state,\n    sho_dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params,\n)\n\n# Propagate for several periods\nperiod = 2 * np.pi / omega  # Period = 1 second\nprop_damped.propagate_to(epoch + 10 * period)\nprop_undamped.propagate_to(epoch + 10 * period)\n\n# Sample trajectory and compare\nprint(\"Damped vs Undamped Harmonic Oscillator:\")\nprint(f\"  Natural frequency: {omega / (2 * np.pi):.1f} Hz\")\nprint(f\"  Damping ratio: {damping_ratio}\")\nprint(f\"  Damping coefficient: {damping_coeff:.3f} /s\")\nprint(\"\\nTime (s)  Damped x    Undamped x  Amplitude ratio\")\nprint(\"-\" * 55)\n\nfor i in range(11):\n    t = i * period  # Sample at period intervals\n    state_damped = prop_damped.state(epoch + t)\n    state_undamped = prop_undamped.state(epoch + t)\n    ratio = abs(state_damped[0]) / max(abs(state_undamped[0]), 1e-10)\n    print(\n        f\"  {t:.1f}       {state_damped[0]:+.4f}      {state_undamped[0]:+.4f}       {ratio:.3f}\"\n    )\n\n# Validate - damped oscillator should decay\nfinal_damped = prop_damped.state(epoch + 10 * period)\nfinal_undamped = prop_undamped.state(epoch + 10 * period)\n\n# Expected decay: amplitude ~ exp(-zeta*omega*t) = exp(-0.1 * 2*pi * 10) ~ 0.002\nexpected_ratio = np.exp(-damping_ratio * omega * 10 * period)\nactual_ratio = abs(final_damped[0]) / abs(x0)\n\nprint(\"\\nAfter 10 periods:\")\nprint(f\"  Damped amplitude: {abs(final_damped[0]):.4f} m\")\nprint(f\"  Undamped amplitude: {abs(final_undamped[0]):.4f} m\")\nprint(f\"  Expected decay ratio: {expected_ratio:.4f}\")\nprint(f\"  Actual decay ratio: {actual_ratio:.4f}\")\n\nassert abs(final_damped[0]) &lt; abs(final_undamped[0])  # Damped has smaller amplitude\nassert actual_ratio &lt; 0.1  # Should decay significantly\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DStatePropagator, DStateProvider};\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data (needed for epoch operations)\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Simple Harmonic Oscillator with damping control\n    // State: [x, v] where x is position and v is velocity\n    // Natural dynamics: dx/dt = v, dv/dt = -omega^2 * x\n    // Control adds damping: u = -c * v\n    let omega = 2.0 * PI; // 1 Hz natural frequency\n    let damping_ratio = 0.1; // Damping ratio (zeta)\n\n    // Initial state: displaced from equilibrium\n    let x0 = 1.0; // 1 meter displacement\n    let v0 = 0.0; // Starting from rest\n    let initial_state = na::DVector::from_vec(vec![x0, v0]);\n\n    // SHO dynamics function (undamped - natural dynamics only)\n    // Control is added separately via control_input\n    let sho_dynamics: bh::DStateDynamics = Box::new(\n        move |_t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let x = state[0];\n            let v = state[1];\n            let omega_sq = params.map(|p| p[0]).unwrap_or(omega * omega);\n            na::DVector::from_vec(vec![v, -omega_sq * x])\n        },\n    );\n\n    // Another copy for the undamped propagator\n    let sho_dynamics_undamped: bh::DStateDynamics = Box::new(\n        move |_t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let x = state[0];\n            let v = state[1];\n            let omega_sq = params.map(|p| p[0]).unwrap_or(omega * omega);\n            na::DVector::from_vec(vec![v, -omega_sq * x])\n        },\n    );\n\n    // Damping control input: u = -c * v (opposes velocity)\n    // The control_input function returns a state derivative contribution\n    // that is added to the dynamics output at each integration step.\n    let damping_coeff = 2.0 * damping_ratio * omega;\n    let damping_control: bh::DControlInput = Some(Box::new(\n        move |_t: f64, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let v = state[1];\n            // Control adds acceleration that opposes velocity\n            na::DVector::from_vec(vec![0.0, -damping_coeff * v])\n        },\n    ));\n\n    // Parameters (omega^2)\n    let params = na::DVector::from_vec(vec![omega * omega]);\n\n    // Create propagator with dynamics AND control_input\n    let mut prop_damped = bh::DNumericalPropagator::new(\n        epoch,\n        initial_state.clone(),\n        sho_dynamics,\n        bh::NumericalPropagationConfig::default(),\n        Some(params.clone()),\n        damping_control, // Separate control function\n        None,            // No initial covariance\n    )\n    .unwrap();\n\n    // Create undamped propagator for comparison (no control_input)\n    let mut prop_undamped = bh::DNumericalPropagator::new(\n        epoch,\n        initial_state,\n        sho_dynamics_undamped,\n        bh::NumericalPropagationConfig::default(),\n        Some(params),\n        None, // No control input\n        None,\n    )\n    .unwrap();\n\n    // Propagate for several periods\n    let period = 2.0 * PI / omega; // Period = 1 second\n    prop_damped.propagate_to(epoch + 10.0 * period);\n    prop_undamped.propagate_to(epoch + 10.0 * period);\n\n    // Sample trajectory and compare\n    println!(\"Damped vs Undamped Harmonic Oscillator:\");\n    println!(\"  Natural frequency: {:.1} Hz\", omega / (2.0 * PI));\n    println!(\"  Damping ratio: {}\", damping_ratio);\n    println!(\"  Damping coefficient: {:.3} /s\", damping_coeff);\n    println!(\"\\nTime (s)  Damped x    Undamped x  Amplitude ratio\");\n    println!(\"{}\", \"-\".repeat(55));\n\n    for i in 0..11 {\n        let t = (i as f64) * period; // Sample at period intervals\n        let state_damped = prop_damped.state(epoch + t).unwrap();\n        let state_undamped = prop_undamped.state(epoch + t).unwrap();\n        let ratio = state_damped[0].abs() / state_undamped[0].abs().max(1e-10);\n        println!(\n            \"  {:.1}       {:+.4}      {:+.4}       {:.3}\",\n            t, state_damped[0], state_undamped[0], ratio\n        );\n    }\n\n    // Validate - damped oscillator should decay\n    let final_damped = prop_damped.state(epoch + 10.0 * period).unwrap();\n    let final_undamped = prop_undamped.state(epoch + 10.0 * period).unwrap();\n\n    // Expected decay: amplitude ~ exp(-zeta*omega*t) = exp(-0.1 * 2*pi * 10) ~ 0.002\n    let expected_ratio = (-damping_ratio * omega * 10.0 * period).exp();\n    let actual_ratio = final_damped[0].abs() / x0;\n\n    println!(\"\\nAfter 10 periods:\");\n    println!(\"  Damped amplitude: {:.4} m\", final_damped[0].abs());\n    println!(\"  Undamped amplitude: {:.4} m\", final_undamped[0].abs());\n    println!(\"  Expected decay ratio: {:.4}\", expected_ratio);\n    println!(\"  Actual decay ratio: {:.4}\", actual_ratio);\n\n    assert!(final_damped[0].abs() &lt; final_undamped[0].abs()); // Damped has smaller amplitude\n    assert!(actual_ratio &lt; 0.1); // Should decay significantly\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#event-detection","title":"Event Detection","text":"<p>The generic propagator supports the same event detection system as <code>NumericalOrbitPropagator</code>. Events can detect when computed quantities cross threshold values:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data (needed for epoch operations)\nbh.initialize_eop()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Simple Harmonic Oscillator\n# State: [x, v] where x is position and v is velocity\nomega = 2.0 * np.pi  # 1 Hz oscillation frequency\n\n# Initial state: displaced from equilibrium\nx0 = 1.0  # 1 meter displacement\nv0 = 0.0  # Starting from rest\ninitial_state = np.array([x0, v0])\n\n\ndef sho_dynamics(t, state, params):\n    \"\"\"Simple harmonic oscillator dynamics.\"\"\"\n    x, v = state[0], state[1]\n    omega_sq = params[0] if params is not None else omega**2\n    return np.array([v, -omega_sq * x])\n\n\n# Parameters (omega^2)\nparams = np.array([omega**2])\n\n# Create propagator\nprop = bh.NumericalPropagator(\n    epoch,\n    initial_state,\n    sho_dynamics,\n    bh.NumericalPropagationConfig.default(),\n    params,\n)\n\n\n# Define value function for zero crossing detection\n# ValueEvent receives (epoch, state) and returns a scalar\ndef position_value(current_epoch, state):\n    \"\"\"Return position component for event detection.\"\"\"\n    return state[0]\n\n\n# Create ValueEvent to detect position zero crossings\n# INCREASING: x goes from negative to positive (moving right through origin)\npositive_crossing = bh.ValueEvent(\n    \"Positive Crossing\",\n    position_value,\n    0.0,  # Target value\n    bh.EventDirection.INCREASING,\n)\n\n# DECREASING: x goes from positive to negative (moving left through origin)\nnegative_crossing = bh.ValueEvent(\n    \"Negative Crossing\",\n    position_value,\n    0.0,\n    bh.EventDirection.DECREASING,\n)\n\n# Add event detectors to propagator\nprop.add_event_detector(positive_crossing)\nprop.add_event_detector(negative_crossing)\n\n# Propagate for 5 periods\nperiod = 2 * np.pi / omega  # Period = 1 second\nprop.propagate_to(epoch + 5 * period)\n\n# Get event log\nevents = prop.event_log()\n\nprint(\"Simple Harmonic Oscillator Zero Crossings:\")\nprint(f\"  omega = {omega:.4f} rad/s (1 Hz)\")\nprint(f\"  Period = {period:.4f} s\")\nprint(\"  Expected crossings per period: 2 (one each direction)\")\nprint()\n\npositive_events = [e for e in events if \"Positive\" in e.name]\nnegative_events = [e for e in events if \"Negative\" in e.name]\n\nprint(f\"Total events detected: {len(events)}\")\nprint(f\"  Positive crossings: {len(positive_events)}\")\nprint(f\"  Negative crossings: {len(negative_events)}\")\nprint()\n\nprint(\"Event details:\")\nprint(\"  Time (s)   Type               Position     Velocity\")\nprint(\"-\" * 60)\n\nfor event in events[:10]:  # Show first 10 events\n    t = event.window_open - epoch\n    x = event.entry_state[0]\n    v = event.entry_state[1]\n    print(f\"  {t:.4f}     {event.name:&lt;18} {x:+.6f}   {v:+.6f}\")\n\n# Validate\n# In 5 periods, we should have 5 positive crossings and 5 negative crossings\nassert len(positive_events) == 5, (\n    f\"Expected 5 positive crossings, got {len(positive_events)}\"\n)\nassert len(negative_events) == 5, (\n    f\"Expected 5 negative crossings, got {len(negative_events)}\"\n)\n\n# Check timing: crossings should occur at quarter periods\n# Starting from x=1, v=0: oscillator moves left first (cosine motion)\n# Negative crossing (moving left) at T/4, 5T/4, 9T/4, ...\n# Positive crossing (moving right) at 3T/4, 7T/4, 11T/4, ...\nexpected_negative_times = [(0.25 + i) * period for i in range(5)]\nexpected_positive_times = [(0.75 + i) * period for i in range(5)]\n\nfor i, event in enumerate(negative_events):\n    t = event.window_open - epoch\n    expected = expected_negative_times[i]\n    error = abs(t - expected)\n    assert error &lt; 0.02, (\n        f\"Negative crossing {i}: expected t={expected:.4f}, got t={t:.4f}\"\n    )\n\nfor i, event in enumerate(positive_events):\n    t = event.window_open - epoch\n    expected = expected_positive_times[i]\n    error = abs(t - expected)\n    assert error &lt; 0.02, (\n        f\"Positive crossing {i}: expected t={expected:.4f}, got t={t:.4f}\"\n    )\n\nprint(\"\\nTiming verified: all crossings within 0.02s of expected times\")\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DValueEvent, EventDirection};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data (needed for epoch operations)\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Simple Harmonic Oscillator\n    // State: [x, v] where x is position and v is velocity\n    let omega = 2.0 * PI; // 1 Hz oscillation frequency\n\n    // Initial state: displaced from equilibrium\n    let x0 = 1.0; // 1 meter displacement\n    let v0 = 0.0; // Starting from rest\n    let initial_state = na::DVector::from_vec(vec![x0, v0]);\n\n    // SHO dynamics function\n    let dynamics_fn: bh::DStateDynamics = Box::new(\n        move |_t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let x = state[0];\n            let v = state[1];\n            let omega_sq = params.map(|p| p[0]).unwrap_or(omega * omega);\n            na::DVector::from_vec(vec![v, -omega_sq * x])\n        },\n    );\n\n    // Parameters (omega^2)\n    let params = na::DVector::from_vec(vec![omega * omega]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalPropagator::new(\n        epoch,\n        initial_state,\n        dynamics_fn,\n        bh::NumericalPropagationConfig::default(),\n        Some(params),\n        None, // No control input\n        None, // No initial covariance\n    )\n    .unwrap();\n\n    // Create ValueEvent to detect position zero crossings\n    // INCREASING: x goes from negative to positive (moving right through origin)\n    let positive_fn =\n        |_t: bh::Epoch, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| state[0];\n    let positive_crossing = DValueEvent::new(\n        \"Positive Crossing\",\n        positive_fn,\n        0.0, // Target value\n        EventDirection::Increasing,\n    );\n\n    // DECREASING: x goes from positive to negative (moving left through origin)\n    let negative_fn =\n        |_t: bh::Epoch, state: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| state[0];\n    let negative_crossing = DValueEvent::new(\n        \"Negative Crossing\",\n        negative_fn,\n        0.0,\n        EventDirection::Decreasing,\n    );\n\n    // Add event detectors to propagator\n    prop.add_event_detector(Box::new(positive_crossing));\n    prop.add_event_detector(Box::new(negative_crossing));\n\n    // Propagate for 5 periods\n    let period = 2.0 * PI / omega; // Period = 1 second\n    prop.propagate_to(epoch + 5.0 * period);\n\n    // Get event log\n    let events = prop.event_log();\n\n    println!(\"Simple Harmonic Oscillator Zero Crossings:\");\n    println!(\"  omega = {:.4} rad/s (1 Hz)\", omega);\n    println!(\"  Period = {:.4} s\", period);\n    println!(\"  Expected crossings per period: 2 (one each direction)\");\n    println!();\n\n    let positive_events: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Positive\"))\n        .collect();\n    let negative_events: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Negative\"))\n        .collect();\n\n    println!(\"Total events detected: {}\", events.len());\n    println!(\"  Positive crossings: {}\", positive_events.len());\n    println!(\"  Negative crossings: {}\", negative_events.len());\n    println!();\n\n    println!(\"Event details:\");\n    println!(\"  Time (s)   Type               Position     Velocity\");\n    println!(\"{}\", \"-\".repeat(60));\n\n    for event in events.iter().take(10) {\n        let t = event.window_open - epoch;\n        let x = event.entry_state[0];\n        let v = event.entry_state[1];\n        println!(\n            \"  {:.4}     {:&lt;18} {:+.6}   {:+.6}\",\n            t, event.name, x, v\n        );\n    }\n\n    // Validate\n    // In 5 periods, we should have 5 positive crossings and 5 negative crossings\n    assert_eq!(\n        positive_events.len(),\n        5,\n        \"Expected 5 positive crossings, got {}\",\n        positive_events.len()\n    );\n    assert_eq!(\n        negative_events.len(),\n        5,\n        \"Expected 5 negative crossings, got {}\",\n        negative_events.len()\n    );\n\n    // Check timing: crossings should occur at quarter periods\n    // Starting from x=1, v=0: oscillator moves left first (cosine motion)\n    // Negative crossing (moving left) at T/4, 5T/4, 9T/4, ...\n    // Positive crossing (moving right) at 3T/4, 7T/4, 11T/4, ...\n    let expected_negative_times: Vec&lt;f64&gt; = (0..5).map(|i| (0.25 + i as f64) * period).collect();\n    let expected_positive_times: Vec&lt;f64&gt; = (0..5).map(|i| (0.75 + i as f64) * period).collect();\n\n    for (i, event) in negative_events.iter().enumerate() {\n        let t = event.window_open - epoch;\n        let expected = expected_negative_times[i];\n        let error = (t - expected).abs();\n        assert!(\n            error &lt; 0.02,\n            \"Negative crossing {}: expected t={:.4}, got t={:.4}\",\n            i,\n            expected,\n            t\n        );\n    }\n\n    for (i, event) in positive_events.iter().enumerate() {\n        let t = event.window_open - epoch;\n        let expected = expected_positive_times[i];\n        let error = (t - expected).abs();\n        assert!(\n            error &lt; 0.02,\n            \"Positive crossing {}: expected t={:.4}, got t={:.4}\",\n            i,\n            expected,\n            t\n        );\n    }\n\n    println!(\"\\nTiming verified: all crossings within 0.02s of expected times\");\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#extended-state-vectors","title":"Extended State Vectors","text":"<p>The generic propagator supports arbitrary state dimensions. The following pseudocode illustrates common extensions:</p> <p>Illustrative Pseudocode</p> <p>The examples below are simplified pseudocode to illustrate the concepts. For complete, runnable examples of extended state propagation, see Extending Spacecraft State.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#attitude-dynamics","title":"Attitude Dynamics","text":"<p>Include quaternion and angular velocity for 6-DOF simulation (13-element state):</p> PythonRust <pre><code>def six_dof_dynamics(t, state, params):\n    # State: [pos(3), vel(3), quat(4), omega(3)] = 13 elements\n    pos = state[:3]\n    vel = state[3:6]\n    quat = state[6:10]   # [q0, q1, q2, q3]\n    omega = state[10:13]  # Angular velocity [rad/s]\n\n    # Translational dynamics (two-body gravity)\n    r = np.linalg.norm(pos)\n    acc = -bh.GM_EARTH * pos / r**3\n\n    # Attitude kinematics (quaternion derivative)\n    omega_quat = np.array([0, omega[0], omega[1], omega[2]])\n    q_dot = 0.5 * quaternion_multiply(quat, omega_quat)\n\n    # Angular dynamics (Euler's equations)\n    I = np.diag(params[:3])  # Inertia tensor diagonal [kg*m^2]\n    torque = np.zeros(3)     # External torques [N*m]\n    omega_dot = np.linalg.inv(I) @ (torque - np.cross(omega, I @ omega))\n\n    return np.concatenate([vel, acc, q_dot, omega_dot])\n</code></pre> <pre><code>let six_dof_dynamics: bh::DStateDynamics = Box::new(\n    |_t, state, params| {\n        // State: [pos(3), vel(3), quat(4), omega(3)] = 13 elements\n        let pos = na::Vector3::new(state[0], state[1], state[2]);\n        let vel = na::Vector3::new(state[3], state[4], state[5]);\n        let quat = na::Vector4::new(state[6], state[7], state[8], state[9]);\n        let omega = na::Vector3::new(state[10], state[11], state[12]);\n\n        // Translational dynamics (two-body gravity)\n        let r = pos.norm();\n        let acc = -bh::GM_EARTH * pos / r.powi(3);\n\n        // Attitude kinematics (quaternion derivative)\n        let omega_matrix = na::Matrix4::new(\n            0.0, -omega[0], -omega[1], -omega[2],\n            omega[0], 0.0, omega[2], -omega[1],\n            omega[1], -omega[2], 0.0, omega[0],\n            omega[2], omega[1], -omega[0], 0.0,\n        );\n        let q_dot = 0.5 * omega_matrix * quat;\n\n        // Angular dynamics (Euler's equations)\n        let p = params.unwrap();\n        let inertia = na::Matrix3::from_diagonal(&amp;na::Vector3::new(p[0], p[1], p[2]));\n        let torque = na::Vector3::zeros();\n        let omega_dot = inertia.try_inverse().unwrap()\n            * (-omega.cross(&amp;(inertia * omega)) + torque);\n\n        // Assemble derivative vector\n        let mut dx = na::DVector::zeros(13);\n        dx.fixed_rows_mut::&lt;3&gt;(0).copy_from(&amp;vel);\n        dx.fixed_rows_mut::&lt;3&gt;(3).copy_from(&amp;acc);\n        dx[6] = q_dot[0]; dx[7] = q_dot[1]; dx[8] = q_dot[2]; dx[9] = q_dot[3];\n        dx[10] = omega_dot[0]; dx[11] = omega_dot[1]; dx[12] = omega_dot[2];\n        dx\n    }\n);\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#relative-motion-hill-clohessy-wiltshire","title":"Relative Motion (Hill-Clohessy-Wiltshire)","text":"<p>Propagate relative position/velocity for formation flying in the Hill frame:</p> PythonRust <pre><code>def hill_clohessy_wiltshire(t, state, params):\n    # State: [x, y, z, vx, vy, vz] in Hill frame (RTN)\n    x, y, z, vx, vy, vz = state\n    n = params[0]  # Mean motion of reference orbit [rad/s]\n\n    # HCW equations (linearized relative motion)\n    ax = 3*n**2*x + 2*n*vy\n    ay = -2*n*vx\n    az = -n**2*z\n\n    return np.array([vx, vy, vz, ax, ay, az])\n</code></pre> <pre><code>let hcw_dynamics: bh::DStateDynamics = Box::new(\n    |_t, state, params| {\n        // State: [x, y, z, vx, vy, vz] in Hill frame (RTN)\n        let (x, y, z) = (state[0], state[1], state[2]);\n        let (vx, vy, vz) = (state[3], state[4], state[5]);\n        let n = params.unwrap()[0];  // Mean motion [rad/s]\n\n        // HCW equations (linearized relative motion)\n        let ax = 3.0 * n * n * x + 2.0 * n * vy;\n        let ay = -2.0 * n * vx;\n        let az = -n * n * z;\n\n        na::DVector::from_vec(vec![vx, vy, vz, ax, ay, az])\n    }\n);\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#quick-reference","title":"Quick Reference","text":""},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#numericalpropagator-constructor-parameters","title":"NumericalPropagator Constructor Parameters","text":"Parameter Type Description Required <code>epoch</code> Epoch Initial epoch Yes <code>initial_state</code> DVector / ndarray Initial state vector (N-dimensional) Yes <code>dynamics_fn</code> Closure / Callable State derivative function Yes <code>config</code> NumericalPropagationConfig Integrator settings Yes <code>params</code> DVector / ndarray Optional parameter vector No <code>control_input</code> Closure / Callable Optional control input function No <code>initial_covariance</code> DMatrix / ndarray Optional initial covariance (enables STM) No"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#performance-considerations","title":"Performance Considerations","text":"<p>Custom dynamics functions are called at every integration step, so efficiency matters:</p> <ol> <li>Minimize function calls: Cache expensive computations</li> <li>Avoid allocations: Reuse arrays where possible</li> <li>Use NumPy vectorization: Avoid Python loops for numerical operations</li> <li>Profile your dynamics: The dynamics function dominates runtime</li> </ol> <p>For Rust, ensure the dynamics closure captures minimal state and avoids unnecessary cloning.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/generic_dynamics.html#see-also","title":"See Also","text":"<ul> <li>Numerical Propagation Overview - Architecture and concepts</li> <li>Extending Spacecraft State - Extended state for orbital propagation</li> <li>Maneuvers - Control inputs for thrust</li> <li>Event Detection - Detecting conditions</li> <li>NumericalPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html","title":"Integrator Configuration","text":"<p>The <code>NumericalPropagationConfig</code> controls the numerical integration method, step sizes, and error tolerances. Brahe provides preset configurations for common scenarios and allows custom configurations for specific requirements.</p> <p>For API details, see the NumericalPropagationConfig API Reference. For detailed information about integrator theory and low-level usage, see the Numerical Integration guide.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#full-example","title":"Full Example","text":"<p>Here is a complete example creating a <code>NumericalPropagationConfig</code> exercising all available configuration options:</p> PythonRust <pre><code>import brahe as bh\n\n# Create a fully-configured integrator configuration\nconfig = bh.NumericalPropagationConfig(\n    # Integration method: Dormand-Prince 5(4)\n    bh.IntegrationMethod.DP54,\n    # Integrator settings: tolerances and step control\n    bh.IntegratorConfig(\n        abs_tol=1e-9,\n        rel_tol=1e-6,\n        initial_step=60.0,  # 60 second initial step\n        min_step=1e-6,  # Minimum step size\n        max_step=300.0,  # Maximum step size (5 minutes)\n        step_safety_factor=0.9,  # Safety margin for step control\n        min_step_scale_factor=0.2,  # Minimum step reduction\n        max_step_scale_factor=10.0,  # Maximum step growth\n        max_step_attempts=10,  # Max attempts per step\n    ),\n    # Variational configuration: STM and sensitivity settings\n    bh.VariationalConfig(\n        enable_stm=True,\n        enable_sensitivity=False,\n        store_stm_history=True,\n        store_sensitivity_history=False,\n    ),\n)\n\nprint(f\"Method: {config.method}\")\nprint(f\"abs_tol: {config.abs_tol}\")\nprint(f\"rel_tol: {config.rel_tol}\")\nprint(f\"Variational: {config.variational}\")\n# Method: IntegrationMethod.DP54\n# abs_tol: 1e-09\n# rel_tol: 1e-06\n# Variational: VariationalConfig(enable_stm=true, ...)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Create a fully-configured integrator configuration\n    let config = bh::NumericalPropagationConfig {\n        // Integration method: Dormand-Prince 5(4)\n        method: bh::IntegratorMethod::DP54,\n        // Integrator settings: tolerances and step control\n        integrator: bh::IntegratorConfig {\n            abs_tol: 1e-9,\n            rel_tol: 1e-6,\n            initial_step: Some(60.0), // 60 second initial step\n            min_step: Some(1e-6),     // Minimum step size\n            max_step: Some(300.0),    // Maximum step size (5 minutes)\n            step_safety_factor: Some(0.9),      // Safety margin\n            min_step_scale_factor: Some(0.2),   // Minimum step reduction\n            max_step_scale_factor: Some(10.0),  // Maximum step growth\n            max_step_attempts: 10,              // Max attempts per step\n            fixed_step_size: None,              // Not using fixed step\n        },\n        // Variational configuration: STM and sensitivity settings\n        variational: bh::VariationalConfig {\n            enable_stm: true,\n            enable_sensitivity: false,\n            store_stm_history: true,\n            store_sensitivity_history: false,\n            jacobian_method: bh::DifferenceMethod::Central,\n            sensitivity_method: bh::DifferenceMethod::Central,\n        },\n        // Acceleration storage for higher-order interpolation\n        store_accelerations: true,\n        // Interpolation method: Linear is safe for any state dimension\n        // Use HermiteCubic or HermiteQuintic for 6D orbital states\n        interpolation_method: bh::InterpolationMethod::Linear,\n    };\n\n    println!(\"Method: {:?}\", config.method);\n    println!(\"Integrator: {:?}\", config.integrator);\n    println!(\"Variational: {:?}\", config.variational);\n    // Method: DP54\n    // Integrator: IntegratorConfig { abs_tol: 1e-9, rel_tol: 1e-6, ... }\n    // Variational: VariationalConfig { enable_stm: true, enable_sensitivity: false, ... }\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#architecture-overview","title":"Architecture Overview","text":""},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p><code>NumericalPropagationConfig</code> is the top-level container that aggregates all integrator settings. Each component has its own configuration struct:</p> <pre><code>NumericalPropagationConfig\n\u251c\u2500\u2500 method: IntegratorMethod\n\u2502   \u251c\u2500\u2500 RK4 (fixed step)\n\u2502   \u251c\u2500\u2500 RKF45 (adaptive)\n\u2502   \u251c\u2500\u2500 DP54 (adaptive, default)\n\u2502   \u2514\u2500\u2500 RKN1210 (adaptive, high precision)\n\u251c\u2500\u2500 integrator: IntegratorConfig\n\u2502   \u251c\u2500\u2500 abs_tol, rel_tol\n\u2502   \u251c\u2500\u2500 initial_step, min_step, max_step\n\u2502   \u251c\u2500\u2500 step_safety_factor\n\u2502   \u251c\u2500\u2500 min/max_step_scale_factor\n\u2502   \u2514\u2500\u2500 fixed_step_size (for RK4)\n\u2514\u2500\u2500 variational: VariationalConfig\n    \u251c\u2500\u2500 enable_stm, enable_sensitivity\n    \u251c\u2500\u2500 store_stm_history, store_sensitivity_history\n    \u2514\u2500\u2500 jacobian_method, sensitivity_method\n</code></pre> <p>The configuration is captured at propagator construction time and remains immutable during propagation.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#integration-methods","title":"Integration Methods","text":"<p>Four integration methods are available:</p> Method Order Adaptive Function Evals Description RK4 4 No 4 Classic fixed-step Runge-Kutta RKF45 4(5) Yes 6 Runge-Kutta-Fehlberg adaptive DP54 5(4) Yes 6-7 Dormand-Prince (MATLAB ode45) RKN1210 12(10) Yes 17 High-precision Runge-Kutta-Nystrom"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#rk4-fixed-step","title":"RK4 (Fixed Step)","text":"<p>Classic 4th-order Runge-Kutta with fixed step size. No error control - requires careful step size selection.</p> PythonRust <pre><code>import brahe as bh\n\n# RK4: Fixed-step 4th-order Runge-Kutta\nconfig = bh.NumericalPropagationConfig(\n    bh.IntegrationMethod.RK4,\n    bh.IntegratorConfig.fixed_step(60.0),  # 60 second fixed steps\n    bh.VariationalConfig(),\n)\n\nprint(f\"Method: {config.method}\")\n# Method: IntegrationMethod.RK4\n</code></pre> <pre><code>fn main() {\n    // RK4: Fixed-step 4th-order Runge-Kutta\n    let config = bh::NumericalPropagationConfig {\n        method: bh::IntegratorMethod::RK4,\n        integrator: bh::IntegratorConfig::fixed_step(60.0), // 60 second fixed steps\n        variational: bh::VariationalConfig::default(),\n        store_accelerations: true,\n        interpolation_method: bh::InterpolationMethod::Linear,\n    };\n\n    println!(\"Method: {:?}\", config.method);\n    println!(\"Fixed step: {:?} seconds\", config.integrator.fixed_step_size);\n    // Method: RK4\n    // Fixed step: Some(60.0) seconds\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#dp54-default","title":"DP54 (Default)","text":"<p>Dormand-Prince 5(4) adaptive method. Uses FSAL (First-Same-As-Last) optimization for efficiency. MATLAB's <code>ode45</code> uses this method.</p> PythonRust <pre><code>import brahe as bh\n\n# DP54: Dormand-Prince 5(4) - the default integrator\nconfig = bh.NumericalPropagationConfig.default()\n\n# Customize tolerances using builder pattern\nconfig_tight = (\n    bh.NumericalPropagationConfig.default().with_abs_tol(1e-9).with_rel_tol(1e-6)\n)\n\nprint(f\"Method: {config.method}\")\nprint(f\"abs_tol: {config.abs_tol}\")\nprint(f\"rel_tol: {config.rel_tol}\")\n# Method: IntegrationMethod.DP54\n# abs_tol: 1e-06\n# rel_tol: 0.001\n</code></pre> <pre><code>fn main() {\n    // DP54: Dormand-Prince 5(4) - the default integrator\n    let config = bh::NumericalPropagationConfig::default();\n\n    // Customize tolerances\n    let config_tight = bh::NumericalPropagationConfig {\n        integrator: bh::IntegratorConfig::adaptive(1e-9, 1e-6),\n        ..bh::NumericalPropagationConfig::default()\n    };\n\n    println!(\"Method: {:?}\", config.method);\n    println!(\"abs_tol: {:e}\", config.integrator.abs_tol);\n    println!(\"rel_tol: {:e}\", config.integrator.rel_tol);\n\n    // Silence unused warning\n    let _ = config_tight;\n    // Method: DP54\n    // abs_tol: 1e-6\n    // rel_tol: 1e-3\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#rkn1210-high-precision","title":"RKN1210 (High Precision)","text":"<p>12th-order Runge-Kutta-Nystrom optimized for second-order ODEs like orbital mechanics. Achieves extreme accuracy with tight tolerances.</p> PythonRust <pre><code>import brahe as bh\n\n# RKN1210: High-order adaptive integrator for maximum precision\nconfig = bh.NumericalPropagationConfig.high_precision()\n\n# Or manually configure with custom tolerances\nconfig_custom = (\n    bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKN1210)\n    .with_abs_tol(1e-12)\n    .with_rel_tol(1e-10)\n)\n\nprint(f\"Method: {config.method}\")\nprint(f\"abs_tol: {config.abs_tol}\")\nprint(f\"rel_tol: {config.rel_tol}\")\n# Method: IntegrationMethod.RKN1210\n# abs_tol: 1e-10\n# rel_tol: 1e-08\n</code></pre> <pre><code>fn main() {\n    // RKN1210: High-order adaptive integrator for maximum precision\n    let config = bh::NumericalPropagationConfig::high_precision();\n\n    // Or manually configure with custom tolerances\n    let config_custom = bh::NumericalPropagationConfig {\n        method: bh::IntegratorMethod::RKN1210,\n        integrator: bh::IntegratorConfig::adaptive(1e-12, 1e-10),\n        variational: bh::VariationalConfig::default(),\n        store_accelerations: true,\n        interpolation_method: bh::InterpolationMethod::Linear,\n    };\n\n    println!(\"Method: {:?}\", config.method);\n    println!(\"abs_tol: {:e}\", config.integrator.abs_tol);\n    println!(\"rel_tol: {:e}\", config.integrator.rel_tol);\n\n    // Silence unused warning\n    let _ = config_custom;\n    // Method: RKN1210\n    // abs_tol: 1e-10\n    // rel_tol: 1e-8\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#error-tolerances","title":"Error Tolerances","text":"<p>Adaptive integrators adjust step size to keep error within:</p> \\[ \\text{error} &lt; \\text{abs\\_tol} + \\text{rel\\_tol} \\times |\\text{state}| \\] <ul> <li><code>abs_tol</code>: Bounds error when state components are small (default: 1e-6)</li> <li><code>rel_tol</code>: Bounds error proportional to state magnitude (default: 1e-3)</li> </ul> PythonRust <pre><code>import brahe as bh\n\n# Different tolerance levels for various use cases\nconfig_quick = (\n    bh.NumericalPropagationConfig.default().with_abs_tol(1e-3).with_rel_tol(1e-1)\n)\nconfig_standard = bh.NumericalPropagationConfig.default()  # abs=1e-6, rel=1e-3\nconfig_precision = (\n    bh.NumericalPropagationConfig.default().with_abs_tol(1e-9).with_rel_tol(1e-6)\n)\nconfig_maximum = bh.NumericalPropagationConfig.high_precision()  # abs=1e-10, rel=1e-8\n\nprint(f\"Quick:     abs={config_quick.abs_tol}, rel={config_quick.rel_tol}\")\nprint(f\"Standard:  abs={config_standard.abs_tol}, rel={config_standard.rel_tol}\")\nprint(f\"Precision: abs={config_precision.abs_tol}, rel={config_precision.rel_tol}\")\nprint(f\"Maximum:   abs={config_maximum.abs_tol}, rel={config_maximum.rel_tol}\")\n# Quick:     abs=0.001, rel=0.1\n# Standard:  abs=1e-06, rel=0.001\n# Precision: abs=1e-09, rel=1e-06\n# Maximum:   abs=1e-10, rel=1e-08\n</code></pre> <pre><code>fn main() {\n    // Different tolerance levels for various use cases\n    let config_quick = bh::NumericalPropagationConfig {\n        integrator: bh::IntegratorConfig::adaptive(1e-3, 1e-1),\n        ..bh::NumericalPropagationConfig::default()\n    };\n    let config_standard = bh::NumericalPropagationConfig::default(); // abs=1e-6, rel=1e-3\n    let config_precision = bh::NumericalPropagationConfig {\n        integrator: bh::IntegratorConfig::adaptive(1e-9, 1e-6),\n        ..bh::NumericalPropagationConfig::default()\n    };\n    let config_maximum = bh::NumericalPropagationConfig::high_precision(); // abs=1e-10, rel=1e-8\n\n    println!(\"Quick:     abs={:e}, rel={:e}\", config_quick.integrator.abs_tol, config_quick.integrator.rel_tol);\n    println!(\"Standard:  abs={:e}, rel={:e}\", config_standard.integrator.abs_tol, config_standard.integrator.rel_tol);\n    println!(\"Precision: abs={:e}, rel={:e}\", config_precision.integrator.abs_tol, config_precision.integrator.rel_tol);\n    println!(\"Maximum:   abs={:e}, rel={:e}\", config_maximum.integrator.abs_tol, config_maximum.integrator.rel_tol);\n    // Quick:     abs=1e-3, rel=1e-1\n    // Standard:  abs=1e-6, rel=1e-3\n    // Precision: abs=1e-9, rel=1e-6\n    // Maximum:   abs=1e-10, rel=1e-8\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#customizing-configuration","title":"Customizing Configuration","text":""},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#python-builder-pattern","title":"Python Builder Pattern","text":"<p>Python supports method chaining to customize from a preset:</p> Python <pre><code>import brahe as bh\n\n# Chain with_* methods to customize from a preset\nconfig = (\n    bh.NumericalPropagationConfig.default()\n    .with_abs_tol(1e-9)\n    .with_rel_tol(1e-6)\n    .with_max_step(300.0)\n    .with_initial_step(60.0)\n)\n\nprint(f\"Method: {config.method}\")\nprint(f\"abs_tol: {config.abs_tol}\")\nprint(f\"rel_tol: {config.rel_tol}\")\n# Method: IntegrationMethod.DP54\n# abs_tol: 1e-09\n# rel_tol: 1e-06\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#rust-struct-syntax","title":"Rust Struct Syntax","text":"<p>In Rust, use struct update syntax (<code>..</code>) to customize from defaults:</p> Rust <pre><code>fn main() {\n    // Use struct update syntax (..) to customize from a preset\n    let config = bh::NumericalPropagationConfig {\n        integrator: bh::IntegratorConfig {\n            abs_tol: 1e-9,\n            rel_tol: 1e-6,\n            initial_step: Some(60.0),\n            max_step: Some(300.0),\n            ..bh::IntegratorConfig::default()\n        },\n        ..bh::NumericalPropagationConfig::default()\n    };\n\n    println!(\"Method: {:?}\", config.method);\n    println!(\"abs_tol: {:e}\", config.integrator.abs_tol);\n    println!(\"rel_tol: {:e}\", config.integrator.rel_tol);\n    println!(\"max_step: {:?}\", config.integrator.max_step);\n    // Method: DP54\n    // abs_tol: 1e-9\n    // rel_tol: 1e-6\n    // max_step: Some(300.0)\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#preset-configurations","title":"Preset Configurations","text":"<p>Brahe provides preset configurations for common use cases:</p> Preset Method abs_tol rel_tol Description <code>default()</code> DP54 1e-6 1e-3 General purpose <code>high_precision()</code> RKN1210 1e-10 1e-8 Maximum accuracy <code>with_method(M)</code> M 1e-6 1e-3 Custom method with defaults PythonRust <pre><code>import brahe as bh\n\n# Preset configurations for common use cases\ndefault = bh.NumericalPropagationConfig.default()\nhigh_precision = bh.NumericalPropagationConfig.high_precision()\nrkf45 = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\nrk4 = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RK4)\n\nprint(f\"default():        {default.method}\")\nprint(f\"high_precision(): {high_precision.method}\")\nprint(f\"with_method(RKF45): {rkf45.method}\")\nprint(f\"with_method(RK4):   {rk4.method}\")\n# default():        DP54\n# high_precision(): RKN1210\n# with_method(RKF45): RKF45\n# with_method(RK4):   RK4\n</code></pre> <pre><code>fn main() {\n    // Preset configurations for common use cases\n    let default = bh::NumericalPropagationConfig::default();\n    let high_precision = bh::NumericalPropagationConfig::high_precision();\n    let rkf45 = bh::NumericalPropagationConfig::with_method(bh::IntegratorMethod::RKF45);\n    let rk4 = bh::NumericalPropagationConfig::with_method(bh::IntegratorMethod::RK4);\n\n    println!(\"default():          {:?}\", default.method);\n    println!(\"high_precision():   {:?}\", high_precision.method);\n    println!(\"with_method(RKF45): {:?}\", rkf45.method);\n    println!(\"with_method(RK4):   {:?}\", rk4.method);\n    // default():          DP54\n    // high_precision():   RKN1210\n    // with_method(RKF45): RKF45\n    // with_method(RK4):   RK4\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#variational-equations","title":"Variational Equations","text":"<p>The propagator can optionally integrate variational equations to compute the State Transition Matrix (STM) and sensitivity matrices. This is enabled via <code>VariationalConfig</code>:</p> <ul> <li><code>enable_stm</code>: Compute the State Transition Matrix</li> <li><code>enable_sensitivity</code>: Compute parameter sensitivity matrix</li> <li><code>store_*_history</code>: Store matrices at output times in trajectory</li> <li><code>jacobian_method</code>/<code>sensitivity_method</code>: Finite difference method (Forward, Backward, Central)</li> </ul> <p>The STM maps initial state perturbations to final state perturbations: \\(\\delta\\mathbf{x}(t) = \\Phi(t, t_0) \\cdot \\delta\\mathbf{x}(t_0)\\)</p> <p>See Covariance and Sensitivity for detailed usage.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/integrator_configuration.html#see-also","title":"See Also","text":"<ul> <li>Numerical Propagation Overview - Architecture and concepts</li> <li>Force Models - Configuring force models</li> <li>Covariance and Sensitivity - Variational equations</li> <li>Integrators - Detailed integrator documentation</li> <li>NumericalPropagationConfig API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html","title":"Impulsive and Continuous Control","text":"<p>The numerical propagator supports both impulsive and continuous thrust maneuvers, enabling orbit transfer, station-keeping, and trajectory optimization studies.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#impulsive-maneuvers","title":"Impulsive Maneuvers","text":"<p>Impulsive maneuvers model instantaneous velocity changes (\\(\\Delta v\\)). They're implemented using event callbacks that modify the state at specific conditions.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#using-event-callbacks","title":"Using Event Callbacks","text":"<p>Impulsive maneuvers combine event detection with state modification. For callback details, see Event Callbacks.</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial circular orbit at 400 km\nr1 = bh.R_EARTH + 400e3\n# Target circular orbit at 800 km\nr2 = bh.R_EARTH + 800e3\n\n# Initial state (circular orbit at perigee of transfer)\noe_initial = np.array([r1, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\n# Calculate Hohmann transfer delta-vs\nv1_circular = np.sqrt(bh.GM_EARTH / r1)\nv2_circular = np.sqrt(bh.GM_EARTH / r2)\n\n# Transfer ellipse parameters\na_transfer = (r1 + r2) / 2\nv_perigee_transfer = np.sqrt(bh.GM_EARTH * (2 / r1 - 1 / a_transfer))\nv_apogee_transfer = np.sqrt(bh.GM_EARTH * (2 / r2 - 1 / a_transfer))\n\n# Delta-v magnitudes\ndv1 = v_perigee_transfer - v1_circular  # First burn (prograde at perigee)\ndv2 = v2_circular - v_apogee_transfer  # Second burn (prograde at apogee)\n\nprint(\n    f\"Hohmann Transfer: {(r1 - bh.R_EARTH) / 1e3:.0f} km -&gt; {(r2 - bh.R_EARTH) / 1e3:.0f} km\"\n)\nprint(f\"  First burn (perigee):  {dv1:.3f} m/s\")\nprint(f\"  Second burn (apogee):  {dv2:.3f} m/s\")\nprint(f\"  Total delta-v:         {dv1 + dv2:.3f} m/s\")\n\n# Transfer time (half period of transfer ellipse)\ntransfer_time = np.pi * np.sqrt(a_transfer**3 / bh.GM_EARTH)\nprint(f\"  Transfer time:         {transfer_time / 60:.1f} min\")\n\n\n# Create callback for first burn\ndef first_burn_callback(event_epoch, event_state):\n    \"\"\"Apply first delta-v at departure.\"\"\"\n    new_state = event_state.copy()\n    # Add delta-v in velocity direction (prograde)\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv1 * v_hat\n    print(f\"  First burn applied at t+0s: dv = {dv1:.3f} m/s\")\n    return (new_state, bh.EventAction.CONTINUE)\n\n\n# Create callback for second burn\ndef second_burn_callback(event_epoch, event_state):\n    \"\"\"Apply second delta-v at arrival.\"\"\"\n    new_state = event_state.copy()\n    v = event_state[3:6]\n    v_hat = v / np.linalg.norm(v)\n    new_state[3:6] += dv2 * v_hat\n    dt = event_epoch - epoch\n    print(f\"  Second burn applied at t+{dt:.1f}s: dv = {dv2:.3f} m/s\")\n    return (new_state, bh.EventAction.CONTINUE)\n\n\n# Create propagator (two-body for clean Hohmann)\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# First burn at t=0 (immediate)\nevent1 = bh.TimeEvent(epoch + 1.0, \"First Burn\").with_callback(first_burn_callback)\n\n# Second burn at apogee (half transfer period)\nevent2 = bh.TimeEvent(epoch + transfer_time, \"Second Burn\").with_callback(\n    second_burn_callback\n)\n\nprop.add_event_detector(event1)\nprop.add_event_detector(event2)\n\n# Propagate through both burns plus one orbit of final orbit\nfinal_orbit_period = bh.orbital_period(r2)\nprop.propagate_to(epoch + transfer_time + final_orbit_period)\n\n# Check final orbit\nfinal_koe = prop.state_koe_osc(prop.current_epoch, bh.AngleFormat.DEGREES)\nfinal_altitude = final_koe[0] - bh.R_EARTH\n\nprint(\"\\nFinal orbit:\")\nprint(f\"  Semi-major axis: {final_koe[0] / 1e3:.3f} km\")\nprint(\n    f\"  Altitude:        {final_altitude / 1e3:.3f} km (target: {(r2 - bh.R_EARTH) / 1e3:.0f} km)\"\n)\nprint(f\"  Eccentricity:    {final_koe[1]:.6f}\")\n\n# Validate final orbit achieved significant altitude gain\n# Note: Some error expected due to numerical integration and event timing\naltitude_gain = final_altitude - (r1 - bh.R_EARTH)\nassert altitude_gain &gt; 200e3  # Significant altitude gain achieved\nassert final_koe[1] &lt; 0.1  # Reasonably circular\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DEventCallback, DTimeEvent, EventAction};\nuse bh::traits::{DOrbitStateProvider, DStatePropagator};\nuse nalgebra as na;\nuse std::f64::consts::PI;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Initial circular orbit at 400 km\n    let r1 = bh::R_EARTH + 400e3;\n    // Target circular orbit at 800 km\n    let r2 = bh::R_EARTH + 800e3;\n\n    // Initial state (circular orbit at perigee of transfer)\n    let oe_initial = na::SVector::&lt;f64, 6&gt;::new(r1, 0.0001, 0.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe_initial, bh::AngleFormat::Degrees);\n\n    // Calculate Hohmann transfer delta-vs\n    let v1_circular = (bh::GM_EARTH / r1).sqrt();\n    let v2_circular = (bh::GM_EARTH / r2).sqrt();\n\n    // Transfer ellipse parameters\n    let a_transfer = (r1 + r2) / 2.0;\n    let v_perigee_transfer = (bh::GM_EARTH * (2.0 / r1 - 1.0 / a_transfer)).sqrt();\n    let v_apogee_transfer = (bh::GM_EARTH * (2.0 / r2 - 1.0 / a_transfer)).sqrt();\n\n    // Delta-v magnitudes\n    let dv1 = v_perigee_transfer - v1_circular; // First burn (prograde at perigee)\n    let dv2 = v2_circular - v_apogee_transfer; // Second burn (prograde at apogee)\n\n    println!(\n        \"Hohmann Transfer: {:.0} km -&gt; {:.0} km\",\n        (r1 - bh::R_EARTH) / 1e3,\n        (r2 - bh::R_EARTH) / 1e3\n    );\n    println!(\"  First burn (perigee):  {:.3} m/s\", dv1);\n    println!(\"  Second burn (apogee):  {:.3} m/s\", dv2);\n    println!(\"  Total delta-v:         {:.3} m/s\", dv1 + dv2);\n\n    // Transfer time (half period of transfer ellipse)\n    let transfer_time = PI * (a_transfer.powi(3) / bh::GM_EARTH).sqrt();\n    println!(\"  Transfer time:         {:.1} min\", transfer_time / 60.0);\n\n    // Create propagator (two-body for clean Hohmann)\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Track if burns have been applied\n    let burn1_applied = Arc::new(AtomicBool::new(false));\n    let burn2_applied = Arc::new(AtomicBool::new(false));\n\n    // First burn callback\n    let burn1_flag = burn1_applied.clone();\n    let first_burn_callback: DEventCallback = Box::new(\n        move |_t: bh::Epoch,\n              state: &amp;na::DVector&lt;f64&gt;,\n              _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;|\n              -&gt; (\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            EventAction,\n        ) {\n            let mut new_state = state.clone();\n            // Add delta-v in velocity direction (prograde)\n            let v = state.fixed_rows::&lt;3&gt;(3);\n            let v_hat = v.normalize();\n            new_state[3] += dv1 * v_hat[0];\n            new_state[4] += dv1 * v_hat[1];\n            new_state[5] += dv1 * v_hat[2];\n            burn1_flag.store(true, Ordering::SeqCst);\n            println!(\"  First burn applied at t+0s: dv = {:.3} m/s\", dv1);\n            (Some(new_state), None, EventAction::Continue)\n        },\n    );\n\n    // Second burn callback\n    let burn2_flag = burn2_applied.clone();\n    let epoch_ref = epoch;\n    let second_burn_callback: DEventCallback = Box::new(\n        move |t: bh::Epoch,\n              state: &amp;na::DVector&lt;f64&gt;,\n              _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;|\n              -&gt; (\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            Option&lt;na::DVector&lt;f64&gt;&gt;,\n            EventAction,\n        ) {\n            let mut new_state = state.clone();\n            let v = state.fixed_rows::&lt;3&gt;(3);\n            let v_hat = v.normalize();\n            new_state[3] += dv2 * v_hat[0];\n            new_state[4] += dv2 * v_hat[1];\n            new_state[5] += dv2 * v_hat[2];\n            burn2_flag.store(true, Ordering::SeqCst);\n            let dt = t - epoch_ref;\n            println!(\"  Second burn applied at t+{:.1}s: dv = {:.3} m/s\", dt, dv2);\n            (Some(new_state), None, EventAction::Continue)\n        },\n    );\n\n    // First burn at t=1s (near immediate)\n    let event1 = DTimeEvent::new(epoch + 1.0, \"First Burn\".to_string())\n        .with_callback(first_burn_callback);\n\n    // Second burn at apogee (half transfer period)\n    let event2 = DTimeEvent::new(epoch + transfer_time, \"Second Burn\".to_string())\n        .with_callback(second_burn_callback);\n\n    prop.add_event_detector(Box::new(event1));\n    prop.add_event_detector(Box::new(event2));\n\n    // Propagate through both burns plus one orbit of final orbit\n    let final_orbit_period = 2.0 * PI * (r2.powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + transfer_time + final_orbit_period);\n\n    // Check final orbit\n    let final_koe = prop\n        .state_koe_osc(prop.current_epoch(), bh::AngleFormat::Degrees)\n        .unwrap();\n    let final_altitude = final_koe[0] - bh::R_EARTH;\n\n    println!(\"\\nFinal orbit:\");\n    println!(\"  Semi-major axis: {:.3} km\", final_koe[0] / 1e3);\n    println!(\n        \"  Altitude:        {:.3} km (target: {:.0} km)\",\n        final_altitude / 1e3,\n        (r2 - bh::R_EARTH) / 1e3\n    );\n    println!(\"  Eccentricity:    {:.6}\", final_koe[1]);\n\n    // Validate final orbit achieved significant altitude gain\n    // Note: Some error expected due to numerical integration and event timing\n    let altitude_gain = final_altitude - (r1 - bh::R_EARTH);\n    assert!(altitude_gain &gt; 200e3); // Significant altitude gain achieved\n    assert!(final_koe[1] &lt; 0.1); // Reasonably circular\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#hohmann-transfer-visualization","title":"Hohmann Transfer Visualization","text":"<p>The following plots show the altitude and velocity changes during the Hohmann transfer example above.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#orbit-geometry","title":"Orbit Geometry","text":"<p>A top-down view showing the initial circular orbit, Hohmann transfer ellipse, and final circular orbit:</p> Plot Source hohmann_transfer_orbit.py<pre><code>import plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Earth radius in km for display\nR_EARTH_KM = 6378.137\n\n# Orbit parameters (matching the impulsive maneuver example)\nr1_km = R_EARTH_KM + 400  # Initial orbit radius (400 km altitude)\nr2_km = R_EARTH_KM + 800  # Final orbit radius (800 km altitude)\n\n# Transfer orbit parameters\na_transfer_km = (r1_km + r2_km) / 2  # Semi-major axis of transfer ellipse\ne_transfer = (r2_km - r1_km) / (r2_km + r1_km)  # Eccentricity of transfer ellipse\n\n\ndef generate_circle(radius, n_points=100):\n    \"\"\"Generate x, y coordinates for a circle.\"\"\"\n    theta = np.linspace(0, 2 * np.pi, n_points)\n    x = radius * np.cos(theta)\n    y = radius * np.sin(theta)\n    return x, y\n\n\ndef generate_ellipse_arc(a, e, theta_start, theta_end, n_points=100):\n    \"\"\"Generate x, y coordinates for an ellipse arc.\n\n    The ellipse is centered at one focus (Earth), with perigee at theta=0.\n    \"\"\"\n    theta = np.linspace(theta_start, theta_end, n_points)\n    # Orbit equation: r = a(1-e^2) / (1 + e*cos(theta))\n    r = a * (1 - e**2) / (1 + e * np.cos(theta))\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return x, y\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Earth (filled circle)\n    earth_x, earth_y = generate_circle(R_EARTH_KM, n_points=50)\n    fig.add_trace(\n        go.Scatter(\n            x=earth_x,\n            y=earth_y,\n            mode=\"lines\",\n            fill=\"toself\",\n            fillcolor=\"#4a90d9\" if theme == \"light\" else \"#3a7bc8\",\n            line=dict(color=\"#2d5986\", width=1),\n            name=\"Earth\",\n            hoverinfo=\"name\",\n        )\n    )\n\n    # Initial orbit (dashed circle)\n    initial_x, initial_y = generate_circle(r1_km)\n    fig.add_trace(\n        go.Scatter(\n            x=initial_x,\n            y=initial_y,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=2, dash=\"dash\"),\n            name=f\"Initial Orbit ({r1_km - R_EARTH_KM:.0f} km)\",\n            hoverinfo=\"name\",\n        )\n    )\n\n    # Final orbit (dashed circle)\n    final_x, final_y = generate_circle(r2_km)\n    fig.add_trace(\n        go.Scatter(\n            x=final_x,\n            y=final_y,\n            mode=\"lines\",\n            line=dict(color=colors[\"accent\"], width=2, dash=\"dash\"),\n            name=f\"Final Orbit ({r2_km - R_EARTH_KM:.0f} km)\",\n            hoverinfo=\"name\",\n        )\n    )\n\n    # Transfer orbit arc (solid line, only the transfer portion from perigee to apogee)\n    transfer_x, transfer_y = generate_ellipse_arc(a_transfer_km, e_transfer, 0, np.pi)\n    fig.add_trace(\n        go.Scatter(\n            x=transfer_x,\n            y=transfer_y,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=3),\n            name=\"Transfer Orbit\",\n            hoverinfo=\"name\",\n        )\n    )\n\n    # Burn 1 point (at perigee, rightmost point)\n    burn1_x = r1_km\n    burn1_y = 0\n    fig.add_trace(\n        go.Scatter(\n            x=[burn1_x],\n            y=[burn1_y],\n            mode=\"markers\",\n            marker=dict(color=colors[\"error\"], size=12, symbol=\"star\"),\n            name=\"Burn 1\",\n            hoverinfo=\"name+text\",\n            text=[\"Prograde burn to enter transfer orbit\"],\n        )\n    )\n\n    # Burn 2 point (at apogee, leftmost point)\n    burn2_x = -r2_km\n    burn2_y = 0\n    fig.add_trace(\n        go.Scatter(\n            x=[burn2_x],\n            y=[burn2_y],\n            mode=\"markers\",\n            marker=dict(color=colors[\"error\"], size=12, symbol=\"star\"),\n            name=\"Burn 2\",\n            hoverinfo=\"name+text\",\n            text=[\"Circularization burn at apogee\"],\n        )\n    )\n\n    # Annotations for burns\n    fig.add_annotation(\n        x=burn1_x + 300,\n        y=burn1_y + 400,\n        text=\"Burn 1\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor=colors[\"error\"],\n        ax=40,\n        ay=-30,\n        font=dict(size=11, color=colors[\"font_color\"]),\n    )\n\n    fig.add_annotation(\n        x=burn2_x - 300,\n        y=burn2_y + 400,\n        text=\"Burn 2\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor=colors[\"error\"],\n        ax=-40,\n        ay=-30,\n        font=dict(size=11, color=colors[\"font_color\"]),\n    )\n\n    # Layout\n    max_r = r2_km * 1.15\n    fig.update_layout(\n        title=\"Hohmann Transfer: Orbit Geometry (Top-Down View)\",\n        xaxis=dict(\n            title=\"X (km)\",\n            range=[-max_r, max_r],\n            scaleanchor=\"y\",\n            scaleratio=1,\n            showgrid=True,\n            gridcolor=colors[\"grid_color\"],\n            zeroline=True,\n            zerolinecolor=colors[\"line_color\"],\n        ),\n        yaxis=dict(\n            title=\"Y (km)\",\n            range=[-max_r, max_r],\n            showgrid=True,\n            gridcolor=colors[\"grid_color\"],\n            zeroline=True,\n            zerolinecolor=colors[\"line_color\"],\n        ),\n        showlegend=True,\n        legend=dict(\n            orientation=\"h\",\n            yanchor=\"bottom\",\n            y=1.02,\n            xanchor=\"center\",\n            x=0.5,\n        ),\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#altitude-profile","title":"Altitude Profile","text":"<p>The spacecraft altitude increases from 400 km to 800 km through two impulsive burns:</p> Plot Source impulsive_maneuver_altitude.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial and target orbits\nr1 = bh.R_EARTH + 400e3  # 400 km altitude\nr2 = bh.R_EARTH + 800e3  # 800 km altitude\n\n# Initial state (circular orbit)\noe_initial = np.array([r1, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\n# Calculate Hohmann transfer parameters\nv1_circular = np.sqrt(bh.GM_EARTH / r1)\na_transfer = (r1 + r2) / 2\nv_perigee_transfer = np.sqrt(bh.GM_EARTH * (2 / r1 - 1 / a_transfer))\nv_apogee_transfer = np.sqrt(bh.GM_EARTH * (2 / r2 - 1 / a_transfer))\nv2_circular = np.sqrt(bh.GM_EARTH / r2)\n\ndv1 = v_perigee_transfer - v1_circular\ndv2 = v2_circular - v_apogee_transfer\ntransfer_time = np.pi * np.sqrt(a_transfer**3 / bh.GM_EARTH)\n\n# Burn times\nburn1_time_s = 1.0  # First burn at t=1s\nburn2_time_s = burn1_time_s + transfer_time  # Second burn after half-transfer\n\n# Calculate total propagation time\nfinal_orbit_period = bh.orbital_period(r2)\ntotal_time = burn2_time_s + final_orbit_period\n\n# Use multi-stage propagation to avoid trajectory interpolation issues with events\n# Stage 1: Initial orbit (t=0 to burn1)\nprop1 = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop1.propagate_to(epoch + burn1_time_s)\n\n# Apply first burn\nstate_at_burn1 = prop1.current_state()\nv = state_at_burn1[3:6]\nv_hat = v / np.linalg.norm(v)\nstate_post_burn1 = state_at_burn1.copy()\nstate_post_burn1[3:6] += dv1 * v_hat\n\n# Stage 2: Transfer orbit (burn1 to burn2)\nepoch_burn1 = epoch + burn1_time_s\nprop2 = bh.NumericalOrbitPropagator(\n    epoch_burn1,\n    state_post_burn1,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop2.propagate_to(epoch_burn1 + transfer_time)\n\n# Apply second burn\nstate_at_burn2 = prop2.current_state()\nv = state_at_burn2[3:6]\nv_hat = v / np.linalg.norm(v)\nstate_post_burn2 = state_at_burn2.copy()\nstate_post_burn2[3:6] += dv2 * v_hat\n\n# Stage 3: Final circular orbit (burn2 onwards)\nepoch_burn2 = epoch_burn1 + transfer_time\nprop3 = bh.NumericalOrbitPropagator(\n    epoch_burn2,\n    state_post_burn2,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop3.propagate_to(epoch_burn2 + final_orbit_period)\n\n# Sample the trajectory at high resolution\ntimes = []\naltitudes = []\ndt = 30.0  # 30 second intervals\n\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n\n    # Determine which propagator to query\n    if t &lt; burn1_time_s:\n        s = prop1.state_eci(current_epoch)\n    elif t &lt; burn2_time_s:\n        s = prop2.state_eci(current_epoch)\n    else:\n        s = prop3.state_eci(current_epoch)\n\n    r = np.linalg.norm(s[:3])\n    alt = (r - bh.R_EARTH) / 1e3  # Convert to km\n    times.append(t / 60.0)  # Convert to minutes\n    altitudes.append(alt)\n    t += dt\n\n# Get burn times for vertical lines (in minutes)\nburn1_time_min = burn1_time_s / 60.0\nburn2_time_min = burn2_time_s / 60.0\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Altitude trace\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=altitudes,\n            mode=\"lines\",\n            name=\"Altitude\",\n            line=dict(color=colors[\"primary\"], width=2),\n        )\n    )\n\n    # Initial altitude reference\n    fig.add_hline(\n        y=400,\n        line_dash=\"dash\",\n        line_color=colors[\"secondary\"],\n        annotation_text=\"Initial: 400 km\",\n        annotation_position=\"top right\",\n    )\n\n    # Target altitude reference\n    fig.add_hline(\n        y=800,\n        line_dash=\"dash\",\n        line_color=colors[\"accent\"],\n        annotation_text=\"Target: 800 km\",\n        annotation_position=\"top right\",\n    )\n\n    # Burn 1 marker\n    fig.add_vline(\n        x=burn1_time_min,\n        line_dash=\"dot\",\n        line_color=colors[\"error\"],\n        annotation_text=f\"Burn 1: {dv1:.1f} m/s\",\n        annotation_position=\"top left\",\n    )\n\n    # Burn 2 marker\n    fig.add_vline(\n        x=burn2_time_min,\n        line_dash=\"dot\",\n        line_color=colors[\"error\"],\n        annotation_text=f\"Burn 2: {dv2:.1f} m/s\",\n        annotation_position=\"top left\",\n    )\n\n    fig.update_layout(\n        title=\"Hohmann Transfer: Altitude vs Time\",\n        xaxis_title=\"Time (minutes)\",\n        yaxis_title=\"Altitude (km)\",\n        showlegend=False,\n        height=500,\n        margin=dict(l=60, r=40, t=60, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#velocity-components","title":"Velocity Components","text":"<p>The velocity components show the discrete jumps from each impulsive burn:</p> Plot Source impulsive_maneuver_velocity.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial and target orbits\nr1 = bh.R_EARTH + 400e3  # 400 km altitude\nr2 = bh.R_EARTH + 800e3  # 800 km altitude\n\n# Initial state (circular orbit)\noe_initial = np.array([r1, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe_initial, bh.AngleFormat.DEGREES)\n\n# Calculate Hohmann transfer parameters\nv1_circular = np.sqrt(bh.GM_EARTH / r1)\na_transfer = (r1 + r2) / 2\nv_perigee_transfer = np.sqrt(bh.GM_EARTH * (2 / r1 - 1 / a_transfer))\nv_apogee_transfer = np.sqrt(bh.GM_EARTH * (2 / r2 - 1 / a_transfer))\nv2_circular = np.sqrt(bh.GM_EARTH / r2)\n\ndv1 = v_perigee_transfer - v1_circular\ndv2 = v2_circular - v_apogee_transfer\ntransfer_time = np.pi * np.sqrt(a_transfer**3 / bh.GM_EARTH)\n\n# Burn times\nburn1_time_s = 1.0  # First burn at t=1s\nburn2_time_s = burn1_time_s + transfer_time  # Second burn after half-transfer\n\n# Calculate total propagation time\nfinal_orbit_period = bh.orbital_period(r2)\ntotal_time = burn2_time_s + final_orbit_period\n\n# Use multi-stage propagation to avoid trajectory interpolation issues with events\n# Stage 1: Initial orbit (t=0 to burn1)\nprop1 = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop1.propagate_to(epoch + burn1_time_s)\n\n# Apply first burn\nstate_at_burn1 = prop1.current_state()\nv = state_at_burn1[3:6]\nv_hat = v / np.linalg.norm(v)\nstate_post_burn1 = state_at_burn1.copy()\nstate_post_burn1[3:6] += dv1 * v_hat\n\n# Stage 2: Transfer orbit (burn1 to burn2)\nepoch_burn1 = epoch + burn1_time_s\nprop2 = bh.NumericalOrbitPropagator(\n    epoch_burn1,\n    state_post_burn1,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop2.propagate_to(epoch_burn1 + transfer_time)\n\n# Apply second burn\nstate_at_burn2 = prop2.current_state()\nv = state_at_burn2[3:6]\nv_hat = v / np.linalg.norm(v)\nstate_post_burn2 = state_at_burn2.copy()\nstate_post_burn2[3:6] += dv2 * v_hat\n\n# Stage 3: Final circular orbit (burn2 onwards)\nepoch_burn2 = epoch_burn1 + transfer_time\nprop3 = bh.NumericalOrbitPropagator(\n    epoch_burn2,\n    state_post_burn2,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\nprop3.propagate_to(epoch_burn2 + final_orbit_period)\n\n# Sample the trajectory at high resolution\ntimes = []\nvx_data = []\nvy_data = []\nvz_data = []\ndt = 30.0  # 30 second intervals\n\nt = 0.0\nwhile t &lt;= total_time:\n    current_epoch = epoch + t\n\n    # Determine which propagator to query\n    if t &lt; burn1_time_s:\n        s = prop1.state_eci(current_epoch)\n    elif t &lt; burn2_time_s:\n        s = prop2.state_eci(current_epoch)\n    else:\n        s = prop3.state_eci(current_epoch)\n\n    times.append(t / 60.0)  # Convert to minutes\n    vx_data.append(s[3] / 1e3)  # Convert to km/s\n    vy_data.append(s[4] / 1e3)\n    vz_data.append(s[5] / 1e3)\n    t += dt\n\n# Get burn times for vertical lines (in minutes)\nburn1_time_min = burn1_time_s / 60.0\nburn2_time_min = burn2_time_s / 60.0\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Velocity component traces\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=vx_data,\n            mode=\"lines\",\n            name=\"vx\",\n            line=dict(color=colors[\"primary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=vy_data,\n            mode=\"lines\",\n            name=\"vy\",\n            line=dict(color=colors[\"secondary\"], width=2),\n        )\n    )\n\n    fig.add_trace(\n        go.Scatter(\n            x=times,\n            y=vz_data,\n            mode=\"lines\",\n            name=\"vz\",\n            line=dict(color=colors[\"accent\"], width=2),\n        )\n    )\n\n    # Burn 1 marker\n    fig.add_vline(\n        x=burn1_time_min,\n        line_dash=\"dot\",\n        line_color=colors[\"error\"],\n        annotation_text=\"Burn 1\",\n        annotation_position=\"top left\",\n    )\n\n    # Burn 2 marker\n    fig.add_vline(\n        x=burn2_time_min,\n        line_dash=\"dot\",\n        line_color=colors[\"error\"],\n        annotation_text=\"Burn 2\",\n        annotation_position=\"top left\",\n    )\n\n    fig.update_layout(\n        title=\"Hohmann Transfer: Velocity Components\",\n        xaxis_title=\"Time (minutes)\",\n        yaxis_title=\"Velocity (km/s)\",\n        showlegend=True,\n        legend=dict(orientation=\"h\", yanchor=\"bottom\", y=1.02, xanchor=\"right\", x=1),\n        height=500,\n        margin=dict(l=60, r=40, t=80, b=60),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#common-impulsive-maneuvers","title":"Common Impulsive Maneuvers","text":"Maneuver Implementation Hohmann transfer Two burns at apoapsis/periapsis Plane change Burn perpendicular to velocity at ascending/descending node Orbit raising Prograde burn at periapsis/apoapsis Circularization Burn at target altitude"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#continuous-thrust","title":"Continuous Thrust","text":"<p>Continuous thrust maneuvers apply acceleration over extended periods. They're implemented via control input functions that add acceleration at each integration step.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#control-input-functions","title":"Control Input Functions","text":"<p>The control input function is called at each integration step and returns a state derivative contribution:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial circular orbit at 400 km\noe = np.array([bh.R_EARTH + 400e3, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Spacecraft parameters\nmass = 500.0  # kg\nthrust = 0.1  # N (100 mN thruster - typical ion engine)\nparams = np.array([mass, 0.0, 0.0, 0.0, 0.0])  # No drag/SRP\n\n\n# Define continuous control input: constant tangential thrust\ndef tangential_thrust(t, state_vec, params_vec):\n    \"\"\"Apply constant thrust in velocity direction.\n\n    Control input must return a derivative vector with the same\n    dimension as the state. For 6D orbital state:\n    - Elements 0-2: position derivatives (zeros for control)\n    - Elements 3-5: velocity derivatives (acceleration)\n    \"\"\"\n    v = state_vec[3:6]\n    v_mag = np.linalg.norm(v)\n\n    # Return full state derivative (same dimension as state)\n    dx = np.zeros(len(state_vec))\n\n    if v_mag &gt; 1e-10:\n        # Unit vector in velocity direction\n        v_hat = v / v_mag\n        # Acceleration from thrust (F = ma -&gt; a = F/m)\n        accel_mag = thrust / mass\n        acceleration = accel_mag * v_hat\n        dx[3:6] = acceleration  # Add to velocity derivatives\n\n    return dx\n\n\n# Create propagator with continuous control\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),  # Two-body + control\n    None,\n    control_input=tangential_thrust,\n)\n\n# Also create reference propagator without thrust\nprop_ref = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Propagate for 10 orbits\norbital_period = bh.orbital_period(oe[0])\nend_time = epoch + 10 * orbital_period\n\nprop.propagate_to(end_time)\nprop_ref.propagate_to(end_time)\n\n# Compare orbits\nkoe_thrust = prop.state_koe_osc(end_time, bh.AngleFormat.DEGREES)\nkoe_ref = prop_ref.state_koe_osc(end_time, bh.AngleFormat.DEGREES)\n\nalt_thrust = koe_thrust[0] - bh.R_EARTH\nalt_ref = koe_ref[0] - bh.R_EARTH\nalt_gain = alt_thrust - alt_ref\n\n# Calculate total delta-v applied\ntotal_time = 10 * orbital_period\ndv_total = (thrust / mass) * total_time\n\nprint(\"Low-Thrust Orbit Raising (10 orbits):\")\nprint(f\"  Thrust: {thrust * 1000:.1f} mN\")\nprint(f\"  Spacecraft mass: {mass:.0f} kg\")\nprint(f\"  Acceleration: {thrust / mass * 1e6:.2f} micro-m/s^2\")\nprint(f\"\\nAfter {10 * orbital_period / 3600:.1f} hours:\")\nprint(f\"  Reference altitude: {alt_ref / 1e3:.3f} km\")\nprint(f\"  With thrust altitude: {alt_thrust / 1e3:.3f} km\")\nprint(f\"  Altitude gain: {alt_gain / 1e3:.3f} km\")\nprint(f\"  Total delta-v applied: {dv_total:.3f} m/s\")\n\n# Validate - thrust should raise orbit\nassert alt_thrust &gt; alt_ref\nassert alt_gain &gt; 0\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DStatePropagator, DOrbitStateProvider};\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Initial circular orbit at 400 km\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 400e3, 0.0001, 0.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Spacecraft parameters\n    let mass = 500.0; // kg\n    let thrust = 0.1; // N (100 mN thruster - typical ion engine)\n\n    // Define continuous control input: constant tangential thrust\n    // Control input must return a derivative vector with the same dimension as state.\n    // For 6D orbital state:\n    // - Elements 0-2: position derivatives (zeros for control)\n    // - Elements 3-5: velocity derivatives (acceleration)\n    let control_fn: bh::DControlInput = Some(Box::new(\n        move |_t: f64, state_vec: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            let v = state_vec.fixed_rows::&lt;3&gt;(3);\n            let v_mag = v.norm();\n\n            // Return full state derivative (same dimension as state)\n            let mut dx = na::DVector::zeros(state_vec.len());\n\n            if v_mag &gt; 1e-10 {\n                // Unit vector in velocity direction\n                let v_hat = v / v_mag;\n\n                // Acceleration from thrust (F = ma -&gt; a = F/m)\n                let accel_mag = thrust / mass;\n                dx[3] = accel_mag * v_hat[0];\n                dx[4] = accel_mag * v_hat[1];\n                dx[5] = accel_mag * v_hat[2];\n            }\n\n            dx\n        },\n    ));\n\n    // Create propagator with continuous control\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(), // Two-body + control\n        None,\n        None,\n        control_fn,\n        None,\n    )\n    .unwrap();\n\n    // Also create reference propagator without thrust\n    let mut prop_ref = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Propagate for 10 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    let end_time = epoch + 10.0 * orbital_period;\n\n    prop.propagate_to(end_time);\n    prop_ref.propagate_to(end_time);\n\n    // Compare orbits\n    let koe_thrust = prop\n        .state_koe_osc(end_time, bh::AngleFormat::Degrees)\n        .unwrap();\n    let koe_ref = prop_ref\n        .state_koe_osc(end_time, bh::AngleFormat::Degrees)\n        .unwrap();\n\n    let alt_thrust = koe_thrust[0] - bh::R_EARTH;\n    let alt_ref = koe_ref[0] - bh::R_EARTH;\n    let alt_gain = alt_thrust - alt_ref;\n\n    // Calculate total delta-v applied\n    let total_time = 10.0 * orbital_period;\n    let dv_total = (thrust / mass) * total_time;\n\n    println!(\"Low-Thrust Orbit Raising (10 orbits):\");\n    println!(\"  Thrust: {:.1} mN\", thrust * 1000.0);\n    println!(\"  Spacecraft mass: {:.0} kg\", mass);\n    println!(\"  Acceleration: {:.2} micro-m/s^2\", thrust / mass * 1e6);\n    println!(\"\\nAfter {:.1} hours:\", 10.0 * orbital_period / 3600.0);\n    println!(\"  Reference altitude: {:.3} km\", alt_ref / 1e3);\n    println!(\"  With thrust altitude: {:.3} km\", alt_thrust / 1e3);\n    println!(\"  Altitude gain: {:.3} km\", alt_gain / 1e3);\n    println!(\"  Total delta-v applied: {:.3} m/s\", dv_total);\n\n    // Validate - thrust should raise orbit\n    assert!(alt_thrust &gt; alt_ref);\n    assert!(alt_gain &gt; 0.0);\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#control-function-signature","title":"Control Function Signature","text":"<p>The control function receives the epoch, current state, and optional parameters. It returns a state derivative vector (same dimension as state):</p> PythonRust <pre><code>def control_input(epoch, state, params):\n    # Create derivative vector (zeros for positions, acceleration for velocities)\n    dx = np.zeros(len(state))\n\n    # Compute acceleration\n    acceleration = compute_thrust_acceleration(epoch, state, params)\n\n    # Apply to velocity derivatives only\n    dx[3:6] = acceleration\n\n    return dx\n</code></pre> <pre><code>let control_fn: bh::DControlInput = Some(Box::new(\n    |t: f64, state: &amp;na::DVector&lt;f64&gt;, params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n        // Create derivative vector (zeros for positions, acceleration for velocities)\n        let mut dx = na::DVector::zeros(state.len());\n\n        // Compute acceleration\n        let acceleration = compute_thrust_acceleration(t, state, params);\n\n        // Apply to velocity derivatives only\n        dx[3] = acceleration[0];\n        dx[4] = acceleration[1];\n        dx[5] = acceleration[2];\n\n        dx\n    },\n));\n</code></pre> <p>The returned vector is added to the equations of motion:</p> \\[\\dot{\\mathbf{x}} = f(\\mathbf{x}, t) + \\mathbf{u}(t, \\mathbf{x})\\] <p>where \\(f\\) is the natural dynamics and \\(\\mathbf{u}\\) is the control input.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#variable-thrust","title":"Variable Thrust","text":"<p>The control function can implement time-varying or state-dependent thrust:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create initial epoch and state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Initial circular orbit at 400 km\noe = np.array([bh.R_EARTH + 400e3, 0.0001, 0.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Spacecraft and maneuver parameters\nmass = 500.0  # kg\nmax_thrust = 0.5  # N (500 mN thruster)\nramp_time = 300.0  # s (5 minute ramp)\nburn_duration = 1800.0  # s (30 minute burn)\nmaneuver_start = epoch + 600.0  # Start 10 minutes into propagation\n\n\n# Define variable thrust control input\ndef variable_thrust(t, state_vec, params_vec):\n    \"\"\"Apply thrust with ramp-up and ramp-down profile.\n\n    The thrust magnitude follows a trapezoidal profile:\n    - Ramp up from 0 to max_thrust over ramp_time\n    - Hold at max_thrust\n    - Ramp down from max_thrust to 0 over ramp_time\n    \"\"\"\n    # Return zeros if outside burn window\n    dx = np.zeros(len(state_vec))\n\n    # Time since maneuver start (t is seconds since epoch)\n    t_maneuver = t - 600.0  # maneuver_start offset in seconds\n\n    # Check if within burn window\n    if t_maneuver &lt; 0 or t_maneuver &gt; burn_duration:\n        return dx\n\n    # Compute thrust magnitude with ramp profile\n    if t_maneuver &lt; ramp_time:\n        # Ramp up phase\n        magnitude = max_thrust * (t_maneuver / ramp_time)\n    elif t_maneuver &gt; burn_duration - ramp_time:\n        # Ramp down phase\n        magnitude = max_thrust * ((burn_duration - t_maneuver) / ramp_time)\n    else:\n        # Constant thrust phase\n        magnitude = max_thrust\n\n    # Thrust direction along velocity\n    v = state_vec[3:6]\n    v_mag = np.linalg.norm(v)\n\n    if v_mag &gt; 1e-10:\n        v_hat = v / v_mag\n        # Acceleration from thrust (F = ma -&gt; a = F/m)\n        acceleration = (magnitude / mass) * v_hat\n        dx[3:6] = acceleration\n\n    return dx\n\n\n# Create propagator with variable thrust control\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n    control_input=variable_thrust,\n)\n\n# Create reference propagator without thrust\nprop_ref = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.two_body(),\n    None,\n)\n\n# Propagate for duration covering the entire maneuver\nend_time = epoch + 3600.0  # 1 hour (covers 30-min burn starting at 10 min)\n\nprop.propagate_to(end_time)\nprop_ref.propagate_to(end_time)\n\n# Compare final orbits\nkoe_thrust = prop.state_koe_osc(end_time, bh.AngleFormat.DEGREES)\nkoe_ref = prop_ref.state_koe_osc(end_time, bh.AngleFormat.DEGREES)\n\nalt_thrust = koe_thrust[0] - bh.R_EARTH\nalt_ref = koe_ref[0] - bh.R_EARTH\nalt_gain = alt_thrust - alt_ref\n\n# Calculate approximate delta-v (trapezoidal profile integration)\n# Full thrust duration minus ramp portions: burn_duration - ramp_time\neffective_time = burn_duration - ramp_time\ndv_approx = (max_thrust / mass) * effective_time\n\nprint(\"Variable Thrust Orbit Raising:\")\nprint(f\"  Max thrust: {max_thrust * 1000:.1f} mN\")\nprint(f\"  Spacecraft mass: {mass:.0f} kg\")\nprint(f\"  Burn duration: {burn_duration:.0f} s ({burn_duration / 60:.0f} min)\")\nprint(f\"  Ramp time: {ramp_time:.0f} s ({ramp_time / 60:.0f} min)\")\nprint(\"\\nAfter 1 hour propagation:\")\nprint(f\"  Reference altitude: {alt_ref / 1e3:.3f} km\")\nprint(f\"  With thrust altitude: {alt_thrust / 1e3:.3f} km\")\nprint(f\"  Altitude gain: {alt_gain / 1e3:.3f} km\")\nprint(f\"  Approx delta-v applied: {dv_approx:.3f} m/s\")\n\n# Validate - thrust should raise orbit\nassert alt_thrust &gt; alt_ref, \"Thrust should raise orbit\"\nassert alt_gain &gt; 0, \"Altitude gain should be positive\"\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::{DOrbitStateProvider, DStatePropagator};\nuse nalgebra as na;\n\nfn main() {\n    // Initialize EOP data\n    bh::initialize_eop().unwrap();\n\n    // Create initial epoch and state\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Initial circular orbit at 400 km\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 400e3, 0.0001, 0.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Spacecraft and maneuver parameters\n    let mass = 500.0; // kg\n    let max_thrust = 0.5; // N (500 mN thruster)\n    let ramp_time = 300.0; // s (5 minute ramp)\n    let burn_duration = 1800.0; // s (30 minute burn)\n    let maneuver_start_offset = 600.0; // Start 10 minutes into propagation\n\n    // Define variable thrust control input\n    // The closure captures the maneuver parameters\n    let control_fn: bh::DControlInput = Some(Box::new(\n        move |t: f64, state_vec: &amp;na::DVector&lt;f64&gt;, _params: Option&lt;&amp;na::DVector&lt;f64&gt;&gt;| {\n            // Return zeros if outside burn window\n            let mut dx = na::DVector::zeros(state_vec.len());\n\n            // Time since maneuver start (t is seconds since epoch)\n            let t_maneuver = t - maneuver_start_offset;\n\n            // Check if within burn window\n            if t_maneuver &lt; 0.0 || t_maneuver &gt; burn_duration {\n                return dx;\n            }\n\n            // Compute thrust magnitude with ramp profile\n            let magnitude = if t_maneuver &lt; ramp_time {\n                // Ramp up phase\n                max_thrust * (t_maneuver / ramp_time)\n            } else if t_maneuver &gt; burn_duration - ramp_time {\n                // Ramp down phase\n                max_thrust * ((burn_duration - t_maneuver) / ramp_time)\n            } else {\n                // Constant thrust phase\n                max_thrust\n            };\n\n            // Thrust direction along velocity\n            let v = state_vec.fixed_rows::&lt;3&gt;(3);\n            let v_mag = v.norm();\n\n            if v_mag &gt; 1e-10 {\n                let v_hat = v / v_mag;\n                // Acceleration from thrust (F = ma -&gt; a = F/m)\n                let accel_mag = magnitude / mass;\n                dx[3] = accel_mag * v_hat[0];\n                dx[4] = accel_mag * v_hat[1];\n                dx[5] = accel_mag * v_hat[2];\n            }\n\n            dx\n        },\n    ));\n\n    // Create propagator with variable thrust control\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        control_fn,\n        None,\n    )\n    .unwrap();\n\n    // Create reference propagator without thrust\n    let mut prop_ref = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::two_body_gravity(),\n        None,\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Propagate for duration covering the entire maneuver\n    let end_time = epoch + 3600.0; // 1 hour (covers 30-min burn starting at 10 min)\n\n    prop.propagate_to(end_time);\n    prop_ref.propagate_to(end_time);\n\n    // Compare final orbits\n    let koe_thrust = prop.state_koe_osc(end_time, bh::AngleFormat::Degrees).unwrap();\n    let koe_ref = prop_ref\n        .state_koe_osc(end_time, bh::AngleFormat::Degrees)\n        .unwrap();\n\n    let alt_thrust = koe_thrust[0] - bh::R_EARTH;\n    let alt_ref = koe_ref[0] - bh::R_EARTH;\n    let alt_gain = alt_thrust - alt_ref;\n\n    // Calculate approximate delta-v (trapezoidal profile integration)\n    // Full thrust duration minus ramp portions: burn_duration - ramp_time\n    let effective_time = burn_duration - ramp_time;\n    let dv_approx = (max_thrust / mass) * effective_time;\n\n    println!(\"Variable Thrust Orbit Raising:\");\n    println!(\"  Max thrust: {:.1} mN\", max_thrust * 1000.0);\n    println!(\"  Spacecraft mass: {:.0} kg\", mass);\n    println!(\n        \"  Burn duration: {:.0} s ({:.0} min)\",\n        burn_duration,\n        burn_duration / 60.0\n    );\n    println!(\n        \"  Ramp time: {:.0} s ({:.0} min)\",\n        ramp_time,\n        ramp_time / 60.0\n    );\n    println!(\"\\nAfter 1 hour propagation:\");\n    println!(\"  Reference altitude: {:.3} km\", alt_ref / 1e3);\n    println!(\"  With thrust altitude: {:.3} km\", alt_thrust / 1e3);\n    println!(\"  Altitude gain: {:.3} km\", alt_gain / 1e3);\n    println!(\"  Approx delta-v applied: {:.3} m/s\", dv_approx);\n\n    // Validate - thrust should raise orbit\n    assert!(alt_thrust &gt; alt_ref, \"Thrust should raise orbit\");\n    assert!(alt_gain &gt; 0.0, \"Altitude gain should be positive\");\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#thrust-profile-visualization","title":"Thrust Profile Visualization","text":"<p>The following plot shows the trapezoidal thrust profile with ramp-up and ramp-down phases:</p> Plot Source variable_thrust_profile.py<pre><code>import numpy as np\nimport plotly.graph_objects as go\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Maneuver parameters (matching the variable_thrust.py example)\nmax_thrust = 0.5  # N (500 mN thruster)\nmass = 500.0  # kg\nramp_time = 300.0  # s (5 minute ramp)\nburn_duration = 1800.0  # s (30 minute burn)\nmaneuver_start = 600.0  # s (10 minutes into propagation)\n\n\ndef thrust_profile(t):\n    \"\"\"Calculate thrust magnitude at time t (seconds from propagation start).\"\"\"\n    t_maneuver = t - maneuver_start\n\n    if t_maneuver &lt; 0 or t_maneuver &gt; burn_duration:\n        return 0.0\n    elif t_maneuver &lt; ramp_time:\n        # Ramp up phase\n        return max_thrust * (t_maneuver / ramp_time)\n    elif t_maneuver &gt; burn_duration - ramp_time:\n        # Ramp down phase\n        return max_thrust * ((burn_duration - t_maneuver) / ramp_time)\n    else:\n        # Constant thrust phase\n        return max_thrust\n\n\n# Generate time series data\ntotal_time = 3600.0  # 1 hour total propagation\ndt = 5.0  # 5 second intervals for smooth curve\n\ntimes = np.arange(0, total_time + dt, dt)\nthrust_values = np.array([thrust_profile(t) for t in times])\naccel_values = thrust_values / mass * 1e6  # Convert to micro-m/s^2\n\n# Convert times to minutes for display\ntimes_min = times / 60.0\n\n# Key times for annotations (in minutes)\nmaneuver_start_min = maneuver_start / 60.0\nramp_end_min = (maneuver_start + ramp_time) / 60.0\nconstant_end_min = (maneuver_start + burn_duration - ramp_time) / 60.0\nmaneuver_end_min = (maneuver_start + burn_duration) / 60.0\n\n\ndef create_figure(theme):\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Thrust magnitude trace\n    fig.add_trace(\n        go.Scatter(\n            x=times_min,\n            y=thrust_values * 1000,  # Convert to mN\n            mode=\"lines\",\n            name=\"Thrust\",\n            line=dict(color=colors[\"primary\"], width=2.5),\n            fill=\"tozeroy\",\n            fillcolor=f\"rgba{tuple(list(int(colors['primary'].lstrip('#')[i : i + 2], 16) for i in (0, 2, 4)) + [0.2])}\",\n        )\n    )\n\n    # Phase annotations\n    fig.add_annotation(\n        x=(maneuver_start_min + ramp_end_min) / 2,\n        y=max_thrust * 1000 * 0.5,\n        text=\"Ramp Up\",\n        showarrow=False,\n        font=dict(size=11, color=colors[\"font_color\"]),\n    )\n\n    fig.add_annotation(\n        x=(ramp_end_min + constant_end_min) / 2,\n        y=max_thrust * 1000 * 1.1,\n        text=\"Constant Thrust\",\n        showarrow=False,\n        font=dict(size=11, color=colors[\"font_color\"]),\n    )\n\n    fig.add_annotation(\n        x=(constant_end_min + maneuver_end_min) / 2,\n        y=max_thrust * 1000 * 0.5,\n        text=\"Ramp Down\",\n        showarrow=False,\n        font=dict(size=11, color=colors[\"font_color\"]),\n    )\n\n    # Vertical lines marking phase boundaries\n    for x_val, label in [\n        (maneuver_start_min, \"Burn Start\"),\n        (maneuver_end_min, \"Burn End\"),\n    ]:\n        fig.add_vline(\n            x=x_val,\n            line_dash=\"dot\",\n            line_color=colors[\"secondary\"],\n            annotation_text=label,\n            annotation_position=\"top\",\n        )\n\n    # Max thrust reference line\n    fig.add_hline(\n        y=max_thrust * 1000,\n        line_dash=\"dash\",\n        line_color=colors[\"accent\"],\n        annotation_text=f\"Max: {max_thrust * 1000:.0f} mN\",\n        annotation_position=\"right\",\n    )\n\n    fig.update_layout(\n        title=\"Variable Thrust Profile: Trapezoidal Maneuver\",\n        xaxis_title=\"Time (minutes)\",\n        yaxis_title=\"Thrust (mN)\",\n        showlegend=False,\n        height=500,\n        margin=dict(l=60, r=80, t=60, b=60),\n        yaxis=dict(range=[-20, max_thrust * 1000 * 1.3]),\n    )\n\n    return fig\n\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"Generated {light_path}\")\nprint(f\"Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#fuel-consumption-tracking","title":"Fuel Consumption Tracking","text":"<p>Neither maneuver type automatically tracks fuel consumption. To track propellant:</p> <ol> <li>Extend the state vector to include mass</li> <li>Add mass derivative to control input or additional dynamics</li> </ol> <p>See Extending Spacecraft State for complete examples.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/maneuvers.html#see-also","title":"See Also","text":"<ul> <li>Event Detection - Event system fundamentals</li> <li>Event Callbacks - Callback function details</li> <li>Extending Spacecraft State - Extended state vectors</li> <li>General Dynamics Propagation - Extended state vectors</li> <li>Numerical Orbit Propagator - Propagator fundamentals</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html","title":"Numerical Orbit Propagator","text":"<p>This guide covers the fundamental operations of the <code>NumericalOrbitPropagator</code>: creating propagators, stepping through time, accessing states, and managing trajectories.</p> <p>For API details, see the NumericalOrbitPropagator API Reference.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#creating-a-propagator","title":"Creating a Propagator","text":"<p>The <code>NumericalOrbitPropagator</code> requires an initial epoch, state, propagation configuration, force model configuration, and optional parameters. The propagator state vector follows a standard layout with the 6D orbital state in the first elements:</p> <pre><code>State Vector (6+ elements)\n\u251c\u2500\u2500 [0] x  - Position X (m, ECI)\n\u251c\u2500\u2500 [1] y  - Position Y (m, ECI)\n\u251c\u2500\u2500 [2] z  - Position Z (m, ECI)\n\u251c\u2500\u2500 [3] vx - Velocity X (m/s, ECI)\n\u251c\u2500\u2500 [4] vy - Velocity Y (m/s, ECI)\n\u251c\u2500\u2500 [5] vz - Velocity Z (m/s, ECI)\n\u2514\u2500\u2500 [6+]   - Extended state (optional, if user-defined additional_dynamics set)\n</code></pre> <p>All force models read from the first 6 elements and contribute accelerations to indices 3-5. Extended state elements (index 6+) are available for user-defined dynamics such as mass depletion, battery state, attitude dynamics, or other user-defined states.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#minimal-setup","title":"Minimal Setup","text":"<p>The simplest setup uses default configurations:</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define orbital elements: [a, e, i, raan, argp, M] in SI units\n# LEO satellite: 500 km altitude, near-circular, sun-synchronous inclination\noe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator with default configuration\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Propagate for 1 hour\nprop.propagate_to(epoch + 3600.0)\n\n# Get final state\nfinal_epoch = prop.current_epoch\nfinal_state = prop.current_state()\n\n# Validate propagation completed\nassert final_epoch == epoch + 3600.0\nassert len(final_state) == 6\nassert np.linalg.norm(final_state[:3]) &gt; bh.R_EARTH  # Still in orbit\n\nprint(f\"Initial epoch: {epoch}\")\nprint(f\"Final epoch:   {final_epoch}\")\nprint(\n    f\"Position (km): [{final_state[0] / 1e3:.3f}, {final_state[1] / 1e3:.3f}, {final_state[2] / 1e3:.3f}]\"\n)\nprint(\n    f\"Velocity (m/s): [{final_state[3]:.3f}, {final_state[4]:.3f}, {final_state[5]:.3f}]\"\n)\nprint(\"Example validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define orbital elements: [a, e, i, raan, argp, M] in SI units\n    // LEO satellite: 500 km altitude, near-circular, sun-synchronous inclination\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 500e3,\n        0.001,\n        97.8,\n        15.0,\n        30.0,\n        45.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Parameters: [mass, drag_area, Cd, srp_area, Cr]\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator with default configuration\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,  // No additional dynamics\n        None,  // No control input\n        None,  // No initial covariance\n    )\n    .unwrap();\n\n    // Propagate for 1 hour\n    prop.propagate_to(epoch + 3600.0);\n\n    // Get final state\n    let final_epoch = prop.current_epoch();\n    let final_state = prop.current_state();\n\n    // Validate propagation completed\n    assert_eq!(final_epoch, epoch + 3600.0);\n    assert_eq!(final_state.len(), 6);\n    assert!(final_state.fixed_rows::&lt;3&gt;(0).norm() &gt; bh::R_EARTH);\n\n    println!(\"Initial epoch: {}\", epoch);\n    println!(\"Final epoch:   {}\", final_epoch);\n    println!(\n        \"Position (km): [{:.3}, {:.3}, {:.3}]\",\n        final_state[0] / 1e3,\n        final_state[1] / 1e3,\n        final_state[2] / 1e3\n    );\n    println!(\n        \"Velocity (m/s): [{:.3}, {:.3}, {:.3}]\",\n        final_state[3], final_state[4], final_state[5]\n    );\n    println!(\"Example validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#stepping-through-time","title":"Stepping Through Time","text":"<p>The propagator provides several methods for advancing through time, following the same interface as analytical propagators.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#single-steps","title":"Single Steps","text":"<ul> <li><code>step()</code> - Advance by the integrator's current step size</li> <li><code>step_by(dt)</code> - Advance by a specific duration (seconds)</li> <li><code>step_past(epoch)</code> - Step until past a target epoch</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#multiple-steps","title":"Multiple Steps","text":"<ul> <li><code>propagate_steps(n)</code> - Take N steps</li> <li><code>propagate_to(epoch)</code> - Propagate exactly to a target epoch</li> </ul> <p>The <code>propagate_to()</code> method is the most commonly used, as it handles step-size adjustment to reach the exact target epoch.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#accessing-state","title":"Accessing State","text":""},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#current-state","title":"Current State","text":"<p>After propagation, access the current state using:</p> <ul> <li><code>current_epoch()</code> - Returns the propagator's current epoch</li> <li><code>current_state()</code> - Returns the current state vector (Cartesian ECI)</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#state-at-arbitrary-epochs","title":"State at Arbitrary Epochs","text":"<p>The <code>StateProvider</code> trait enables state queries at any epoch:</p> <ul> <li><code>state(epoch)</code> - State in the propagator's native format</li> <li><code>state_eci(epoch)</code> - Cartesian state in ECI frame</li> <li><code>state_ecef(epoch)</code> - Cartesian state in ECEF frame</li> <li><code>state_koe_osc(epoch, angle_format)</code> - Keplerian orbital elements</li> </ul> <p>Propagator Advancement and State Queries</p> <p>When querying states at epochs beyond the current propagated time, the propagator MUST have already been advanced to at least that epoch using one of the propagation methods, such as <code>propagate_to()</code> or <code>step_past()</code>, before calling the state query methods otherwise an error will be raised.</p> <p>For epochs within the propagated trajectory, interpolation is used. For epochs beyond the trajectory, the propagator advances to that epoch.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#batch-queries","title":"Batch Queries","text":"<p>For multiple epochs, use the batch query methods:</p> <ul> <li><code>states(epochs)</code> - States at multiple epochs</li> <li><code>states_eci(epochs)</code> - ECI states at multiple epochs</li> <li><code>states_koe(epochs, angle_format)</code> - Keplerian elements at multiple epochs</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#trajectory-management","title":"Trajectory Management","text":"<p>The propagator maintains an internal <code>OrbitTrajectory</code> containing all propagated states.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#accessing-the-trajectory","title":"Accessing the Trajectory","text":"<p>Access the trajectory directly via the <code>trajectory</code> property. The trajectory provides:</p> <ul> <li><code>len()</code> - Number of stored states</li> <li><code>epochs()</code> - List of all epoch times</li> <li><code>states()</code> - Array of all state vectors</li> <li><code>state_at_epoch(epoch)</code> - Interpolated state at any epoch within the trajectory</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#memory-management","title":"Memory Management","text":"<p>For long propagations, use eviction policies to limit memory:</p> <ul> <li><code>set_eviction_policy_max_size(n)</code> - Keep only the N most recent states</li> <li><code>set_eviction_policy_max_age(duration)</code> - Keep only states within a time window</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#resetting","title":"Resetting","text":"<p>Use <code>reset()</code> to return the propagator to its initial conditions, clearing the trajectory.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#propagator-parameters","title":"Propagator Parameters","text":"<p>Some force models require additional parameters. These are provided as a parameter vector during construction:</p> Index Parameter Units Description 0 mass kg Spacecraft mass 1 drag_area m\\(^2\\) Cross-sectional area for drag 2 Cd - Drag coefficient 3 srp_area m\\(^2\\) Cross-sectional area for SRP 4 Cr - Reflectivity coefficient <p>The <code>ForceModelConfig.requires_params()</code> method indicates whether parameters are needed.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#identity-tracking","title":"Identity Tracking","text":"<p>For applications such as access computation that can identify events based on the satellite, propagators can be identified by name, ID, or UUID:</p> <pre><code>prop = bh.NumericalOrbitPropagator(...)\nprop = prop.with_name(\"ISS\")\nprop = prop.with_id(25544)\n</code></pre> <p>This enables tracking propagators in access computation, conjunction analysis, and other multi-object scenarios.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#performance-considerations","title":"Performance Considerations","text":"<p>Custom dynamics functions are called at every integration step, so efficiency matters:</p> <ol> <li>Minimize function calls: Cache expensive computations</li> <li>Avoid allocations: Reuse arrays where possible</li> <li>Use NumPy vectorization: Avoid Python loops for numerical operations</li> <li>Profile your dynamics: The dynamics function dominates runtime</li> </ol> <p>For Rust, ensure the dynamics closure captures minimal state and avoids unnecessary cloning.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/numerical_orbit_propagator.html#see-also","title":"See Also","text":"<ul> <li>Numerical Propagation Overview - Architecture and concepts</li> <li>Force Models - Configuring force models</li> <li>Integrator Configuration - Integration method selection</li> <li>NumericalOrbitPropagator API Reference</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html","title":"Premade Events","text":"<p>Brahe provides built-in event detectors for common orbital conditions. These premade events handle the underlying value function implementation, making it easy to detect frequently-needed conditions without writing custom detection logic.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#event-categories","title":"Event Categories","text":"<p>Premade events fall into four categories based on what they detect:</p> Category What They Detect Event Type Orbital Elements value crossings of Keplerian elements Value State-Derived Altitude, speed, geodetic position Value Eclipse/Shadow Shadow transitions (umbra, penumbra, sunlit) Binary Node Crossings Equatorial plane crossings Value <p>The distinction between value events and binary events is important:</p> <ul> <li>Value events detect when a continuously-varying quantity crosses a value (e.g., altitude = 400 km)</li> <li>Binary events detect when a boolean condition changes state (e.g., enters shadow)</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#orbital-element-events","title":"Orbital Element Events","text":"<p>Orbital element events detect when Keplerian elements cross value values. These are value events with configurable values and directions.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#available-events","title":"Available Events","text":"Event Element Units <code>SemiMajorAxisEvent</code> \\(a\\) meters <code>EccentricityEvent</code> \\(e\\) dimensionless <code>InclinationEvent</code> \\(i\\) degrees or radians <code>ArgumentOfPerigeeEvent</code> \\(\\omega\\) degrees or radians <code>MeanAnomalyEvent</code> \\(M\\) degrees or radians <code>EccentricAnomalyEvent</code> \\(E\\) degrees or radians <code>TrueAnomalyEvent</code> \\(\\nu\\) degrees or radians <code>ArgumentOfLatitudeEvent</code> \\(u = \\omega + \\nu\\) degrees or radians"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#configuration","title":"Configuration","text":"<p>Orbital element events take up to four parameters:</p> <ul> <li><code>value</code> - Target value to detect</li> <li><code>name</code> - Identifier for the event in the event log</li> <li><code>direction</code> - Which crossings to detect (<code>INCREASING</code>, <code>DECREASING</code>, or <code>ANY</code>)</li> <li><code>angle_format</code> - For angle-based events: <code>AngleFormat.DEGREES</code> or <code>AngleFormat.RADIANS</code></li> </ul> <p>Non-angle events (<code>SemiMajorAxisEvent</code>, <code>EccentricityEvent</code>) omit the <code>angle_format</code> parameter.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#example","title":"Example","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state - orbit with inclination near value\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n# SSO-like orbit\noe = np.array([bh.R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Add orbital element events\n# Detect when inclination crosses 97.79 degrees (monitoring for stability)\ninc_event = bh.InclinationEvent(\n    97.79,  # value in degrees\n    \"Inc value\",\n    bh.EventDirection.ANY,\n    bh.AngleFormat.DEGREES,\n)\n\n# Detect semi-major axis value (orbit decay monitoring)\nsma_event = bh.SemiMajorAxisEvent(\n    bh.R_EARTH + 599.5e3,  # value in meters\n    \"SMA value\",\n    bh.EventDirection.DECREASING,\n)\n\nprop.add_event_detector(inc_event)\nprop.add_event_detector(sma_event)\n\n# Propagate for 3 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 3 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nprint(f\"Detected {len(events)} orbital element events:\")\n\nfor event in events:\n    dt = event.window_open - epoch\n    # Get current orbital elements\n    r = event.entry_state[:3]\n    v = event.entry_state[3:]\n    alt = np.linalg.norm(r) - bh.R_EARTH\n    print(f\"  '{event.name}' at t+{dt:.1f}s (altitude: {alt / 1e3:.1f} km)\")\n\n# Count events by type\ninc_events = [e for e in events if \"Inc\" in e.name]\nsma_events = [e for e in events if \"SMA\" in e.name]\n\nprint(f\"\\nInclination value crossings: {len(inc_events)}\")\nprint(f\"SMA value crossings: {len(sma_events)}\")\n\n# The J2 perturbation causes slow variations - we may or may not cross values\n# depending on the exact parameters, so we just validate the events work\nprint(\"\\nExample completed successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DInclinationEvent, DSemiMajorAxisEvent, EventDirection};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state - SSO-like orbit\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Add orbital element events\n    // Detect when inclination crosses 97.79 degrees (monitoring for stability)\n    let inc_event = DInclinationEvent::new(\n        97.79, // value in degrees\n        \"Inc value\".to_string(),\n        EventDirection::Any,\n        bh::AngleFormat::Degrees,\n    );\n\n    // Detect semi-major axis value (orbit decay monitoring)\n    let sma_event = DSemiMajorAxisEvent::new(\n        bh::R_EARTH + 599.5e3, // value in meters\n        \"SMA value\".to_string(),\n        EventDirection::Decreasing,\n    );\n\n    prop.add_event_detector(Box::new(inc_event));\n    prop.add_event_detector(Box::new(sma_event));\n\n    // Propagate for 3 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + 3.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    println!(\"Detected {} orbital element events:\", events.len());\n\n    for event in events {\n        let dt = event.window_open - epoch;\n        let alt = event.entry_state.fixed_rows::&lt;3&gt;(0).norm() - bh::R_EARTH;\n        println!(\n            \"  '{}' at t+{:.1}s (altitude: {:.1} km)\",\n            event.name,\n            dt,\n            alt / 1e3\n        );\n    }\n\n    // Count events by type\n    let inc_events: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"Inc\")).collect();\n    let sma_events: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"SMA\")).collect();\n\n    println!(\"\\nInclination value crossings: {}\", inc_events.len());\n    println!(\"SMA value crossings: {}\", sma_events.len());\n\n    // The J2 perturbation causes slow variations - we may or may not cross values\n    // depending on the exact parameters, so we just validate the events work\n    println!(\"\\nExample completed successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#applications","title":"Applications","text":"Event Use Cases <code>TrueAnomalyEvent</code> Apoapsis detection (\\(\\nu = 180\u00b0\\)), periapsis detection (\\(\\nu = 0\u00b0\\)) <code>SemiMajorAxisEvent</code> Orbit decay monitoring, altitude maintenance <code>EccentricityEvent</code> Circularization detection, orbit stability <code>InclinationEvent</code> Plane change monitoring, SSO maintenance"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#state-derived-events","title":"State-Derived Events","text":"<p>State-derived events compute quantities from the instantaneous state vector rather than orbital elements.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#available-events_1","title":"Available Events","text":"Event Quantity Units <code>AltitudeEvent</code> Geodetic altitude (WGS84) meters <code>SpeedEvent</code> Velocity magnitude m/s <code>LongitudeEvent</code> Geodetic longitude degrees or radians <code>LatitudeEvent</code> Geodetic latitude degrees or radians"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#configuration_1","title":"Configuration","text":"<p>State-derived events follow the same pattern as orbital element events:</p> <ul> <li><code>value</code> - Target value to detect</li> <li><code>name</code> - Identifier for the event in the event log</li> <li><code>direction</code> - Which crossings to detect (<code>INCREASING</code>, <code>DECREASING</code>, or <code>ANY</code>)</li> <li><code>angle_format</code> - For geodetic events: <code>AngleFormat.DEGREES</code> or <code>AngleFormat.RADIANS</code></li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#example-altitude-event","title":"Example: Altitude Event","text":"<p>The <code>AltitudeEvent</code> is one of the most commonly used premade events. It detects when a spacecraft crosses a specified geodetic altitude.</p> PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state - elliptical orbit\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n# Elliptical orbit: 300 km perigee, 800 km apogee\noe = np.array([bh.R_EARTH + 550e3, 0.036, 45.0, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Add altitude events\n# Detect when crossing 500 km altitude (both directions)\nevent_500km = bh.AltitudeEvent(\n    500e3,  # value altitude in meters\n    \"500km crossing\",\n    bh.EventDirection.ANY,  # Detect both increasing and decreasing\n)\n\n# Detect only when ascending through 600 km\nevent_600km_up = bh.AltitudeEvent(\n    600e3,\n    \"600km ascending\",\n    bh.EventDirection.INCREASING,\n)\n\nprop.add_event_detector(event_500km)\nprop.add_event_detector(event_600km_up)\n\n# Propagate for 2 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 2 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nprint(f\"Detected {len(events)} altitude events:\")\n\nfor event in events:\n    dt = event.window_open - epoch\n    alt = np.linalg.norm(event.entry_state[:3]) - bh.R_EARTH\n    print(f\"  '{event.name}' at t+{dt:.1f}s (altitude: {alt / 1e3:.1f} km)\")\n\n# Count events by type\ncrossings_500 = [e for e in events if \"500km\" in e.name]\ncrossings_600 = [e for e in events if \"600km\" in e.name]\n\nprint(f\"\\n500 km crossings (any direction): {len(crossings_500)}\")\nprint(f\"600 km ascending crossings: {len(crossings_600)}\")\n\n# Validate\nassert len(crossings_500) &gt;= 4  # At least 2 per orbit, 2 orbits\nassert len(crossings_600) &gt;= 2  # At least 1 per orbit (ascending only)\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DAltitudeEvent, EventDirection};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state - elliptical orbit\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    // Elliptical orbit: 300 km perigee, 800 km apogee\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 550e3,\n        0.036,\n        45.0,\n        0.0,\n        0.0,\n        0.0,\n    );\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Add altitude events\n    // Detect when crossing 500 km altitude (both directions)\n    let event_500km = DAltitudeEvent::new(\n        500e3, // value altitude in meters\n        \"500km crossing\".to_string(),\n        EventDirection::Any, // Detect both increasing and decreasing\n    );\n\n    // Detect only when ascending through 600 km\n    let event_600km_up = DAltitudeEvent::new(\n        600e3,\n        \"600km ascending\".to_string(),\n        EventDirection::Increasing,\n    );\n\n    prop.add_event_detector(Box::new(event_500km));\n    prop.add_event_detector(Box::new(event_600km_up));\n\n    // Propagate for 2 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + 2.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    println!(\"Detected {} altitude events:\", events.len());\n\n    for event in events {\n        let dt = event.window_open - epoch;\n        let alt = event.entry_state.fixed_rows::&lt;3&gt;(0).norm() - bh::R_EARTH;\n        println!(\n            \"  '{}' at t+{:.1}s (altitude: {:.1} km)\",\n            event.name,\n            dt,\n            alt / 1e3\n        );\n    }\n\n    // Count events by type\n    let crossings_500: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"500km\"))\n        .collect();\n    let crossings_600: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"600km\"))\n        .collect();\n\n    println!(\"\\n500 km crossings (any direction): {}\", crossings_500.len());\n    println!(\"600 km ascending crossings: {}\", crossings_600.len());\n\n    // Validate\n    assert!(crossings_500.len() &gt;= 4); // At least 2 per orbit, 2 orbits\n    assert!(crossings_600.len() &gt;= 2); // At least 1 per orbit (ascending only)\n\n    println!(\"\\nExample validated successfully!\");\n}\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#applications_1","title":"Applications","text":"Use Case Configuration Atmospheric interface detection <code>AltitudeEvent(100e3, \"Karman line\", DECREASING)</code> Re-entry monitoring <code>AltitudeEvent(100e3, \"Re-entry\", DECREASING)</code> Orbit raising trigger <code>AltitudeEvent(target_alt, \"Target\", DECREASING)</code> Perigee passage <code>AltitudeEvent(perigee_alt, \"Perigee\", ANY)</code>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#eclipseshadow-events","title":"Eclipse/Shadow Events","text":"<p>Eclipse events detect shadow conditions using the conical shadow model. These are binary events that trigger on state transitions.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#available-events_2","title":"Available Events","text":"Event Condition <code>RISING_EDGE</code> <code>FALLING_EDGE</code> <code>EclipseEvent</code> Any shadow (illumination &lt; 1) Enter eclipse Exit eclipse <code>UmbraEvent</code> Full shadow (illumination = 0) Enter umbra Exit umbra <code>PenumbraEvent</code> Partial shadow (0 &lt; illumination &lt; 1) Enter penumbra Exit penumbra <code>SunlitEvent</code> Full sunlight (illumination = 1) Exit eclipse Enter eclipse"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#configuration_2","title":"Configuration","text":"<p>Eclipse events take three parameters:</p> <ul> <li><code>name</code> - Identifier for the event in the event log</li> <li><code>edge_type</code> - Which transition to detect (<code>RISING_EDGE</code>, <code>FALLING_EDGE</code>, or <code>ANY_EDGE</code>)</li> <li><code>ephemeris_source</code> - Sun position source (<code>None</code> for analytical, or <code>EphemerisSource.DE440s</code>/<code>DE440</code>)</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#example_1","title":"Example","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state - LEO orbit\nepoch = bh.Epoch.from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n# LEO orbit with some inclination\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Add eclipse events with different edge types\n# Detect entry into eclipse (any shadow - umbra or penumbra)\neclipse_entry = bh.EclipseEvent(\"Eclipse Entry\", bh.EdgeType.RISING_EDGE, None)\n\n# Detect exit from eclipse\neclipse_exit = bh.EclipseEvent(\"Eclipse Exit\", bh.EdgeType.FALLING_EDGE, None)\n\nprop.add_event_detector(eclipse_entry)\nprop.add_event_detector(eclipse_exit)\n\n# Propagate for 5 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 5 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nprint(f\"Detected {len(events)} eclipse events:\")\n\nfor event in events:\n    dt = event.window_open - epoch\n    print(f\"  '{event.name}' at t+{dt:.1f}s\")\n\n# Count events by type\nentries = [e for e in events if \"Entry\" in e.name]\nexits = [e for e in events if \"Exit\" in e.name]\n\nprint(f\"\\nEclipse entries: {len(entries)}\")\nprint(f\"Eclipse exits: {len(exits)}\")\n\n# Calculate eclipse durations\nif len(entries) &gt; 0 and len(exits) &gt; 0:\n    # Find pairs of entry/exit events\n    durations = []\n    for i, entry in enumerate(entries):\n        # Find next exit after this entry\n        for exit_event in exits:\n            if exit_event.window_open &gt; entry.window_open:\n                duration = exit_event.window_open - entry.window_open\n                durations.append(duration)\n                break\n\n    if durations:\n        avg_duration = sum(durations) / len(durations)\n        print(\n            f\"\\nAverage eclipse duration: {avg_duration:.1f}s ({avg_duration / 60:.1f} min)\"\n        )\n\n# Validate - should have roughly equal entries and exits\nassert abs(len(entries) - len(exits)) &lt;= 1, \"Entry/exit count mismatch\"\nassert len(entries) &gt;= 4, \"Expected at least 4 eclipse entries in 5 orbits\"\n\nprint(\"\\nExample validated successfully!\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::events::{DEclipseEvent, EdgeType};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state - LEO orbit\n    let epoch = bh::Epoch::from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    // LEO orbit with some inclination\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Add eclipse events with different edge types\n    // Detect entry into eclipse (any shadow - umbra or penumbra)\n    let eclipse_entry = DEclipseEvent::new(\"Eclipse Entry\", EdgeType::RisingEdge, None);\n\n    // Detect exit from eclipse\n    let eclipse_exit = DEclipseEvent::new(\"Eclipse Exit\", EdgeType::FallingEdge, None);\n\n    prop.add_event_detector(Box::new(eclipse_entry));\n    prop.add_event_detector(Box::new(eclipse_exit));\n\n    // Propagate for 5 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    let _ = prop.propagate_to(epoch + 5.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    println!(\"Detected {} eclipse events:\", events.len());\n\n    for event in events {\n        let dt = event.window_open - epoch;\n        println!(\"  '{}' at t+{:.1}s\", event.name, dt);\n    }\n\n    // Count events by type\n    let entries: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"Entry\")).collect();\n    let exits: Vec&lt;_&gt; = events.iter().filter(|e| e.name.contains(\"Exit\")).collect();\n\n    println!(\"\\nEclipse entries: {}\", entries.len());\n    println!(\"Eclipse exits: {}\", exits.len());\n\n    // Calculate eclipse durations\n    if !entries.is_empty() &amp;&amp; !exits.is_empty() {\n        let mut durations: Vec&lt;f64&gt; = Vec::new();\n        for entry in &amp;entries {\n            // Find next exit after this entry\n            for exit_event in &amp;exits {\n                if exit_event.window_open &gt; entry.window_open {\n                    let duration = exit_event.window_open - entry.window_open;\n                    durations.push(duration);\n                    break;\n                }\n            }\n        }\n\n        if !durations.is_empty() {\n            let avg_duration: f64 = durations.iter().sum::&lt;f64&gt;() / durations.len() as f64;\n            println!(\n                \"\\nAverage eclipse duration: {:.1}s ({:.1} min)\",\n                avg_duration,\n                avg_duration / 60.0\n            );\n        }\n    }\n\n    // Validate - should have roughly equal entries and exits\n    assert!(\n        (entries.len() as i32 - exits.len() as i32).abs() &lt;= 1,\n        \"Entry/exit count mismatch\"\n    );\n    assert!(\n        entries.len() &gt;= 4,\n        \"Expected at least 4 eclipse entries in 5 orbits\"\n    );\n\n    println!(\"\\nExample validated successfully!\");\n}\n\n// Expected output:\n// Detected 10 eclipse events:\n//   'Eclipse Entry' at t+1923.4s\n//   'Eclipse Exit' at t+4078.2s\n//   'Eclipse Entry' at t+7508.5s\n//   'Eclipse Exit' at t+9663.3s\n//   'Eclipse Entry' at t+13093.6s\n//   'Eclipse Exit' at t+15248.4s\n//   'Eclipse Entry' at t+18678.7s\n//   'Eclipse Exit' at t+20833.5s\n//   'Eclipse Entry' at t+24263.8s\n//   'Eclipse Exit' at t+26418.6s\n//\n// Eclipse entries: 5\n// Eclipse exits: 5\n//\n// Average eclipse duration: 2154.9s (35.9 min)\n//\n// Example validated successfully!\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#ephemeris-sources","title":"Ephemeris Sources","text":"Source Description <code>LowPrecision</code> Analytical approximation (fastest) <code>DE440s</code> JPL DE440s ephemeris (short-term, high precision) <code>DE440</code> JPL DE440 ephemeris (long-term, high precision)"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#node-crossing-events","title":"Node Crossing Events","text":"<p>Node crossing events detect when a spacecraft passes through the equatorial plane. These are specialized value events with fixed values.</p>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#available-events_3","title":"Available Events","text":"Event Trigger Condition Direction <code>AscendingNodeEvent</code> Argument of latitude = 0 (northward crossing) Increasing <code>DescendingNodeEvent</code> Argument of latitude = \\(\\pi\\) or \\(180\\) (southward crossing) Increasing"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#configuration_3","title":"Configuration","text":"<p>Node events take only a name parameter:</p> <pre><code>asc_event = bh.AscendingNodeEvent(\"Ascending Node\")\ndesc_event = bh.DescendingNodeEvent(\"Descending Node\")\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#example_2","title":"Example","text":"PythonRust <pre><code>import numpy as np\nimport brahe as bh\n\n# Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Create initial epoch and state - inclined orbit\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n# Inclined orbit for clear node crossings\noe = np.array([bh.R_EARTH + 500e3, 0.01, 45.0, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nparams = np.array([500.0, 2.0, 2.2, 2.0, 1.3])\n\n# Create propagator\nprop = bh.NumericalOrbitPropagator(\n    epoch,\n    state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params,\n)\n\n# Add node crossing events\n# Ascending node: spacecraft crosses equator heading north (argument of latitude = 0)\nasc_event = bh.AscendingNodeEvent(\"Ascending Node\")\n\n# Descending node: spacecraft crosses equator heading south (argument of latitude = 180 deg)\ndesc_event = bh.DescendingNodeEvent(\"Descending Node\")\n\nprop.add_event_detector(asc_event)\nprop.add_event_detector(desc_event)\n\n# Propagate for 3 orbits\norbital_period = bh.orbital_period(oe[0])\nprop.propagate_to(epoch + 3 * orbital_period)\n\n# Check detected events\nevents = prop.event_log()\nprint(f\"Detected {len(events)} node crossing events:\")\n\nfor event in events:\n    dt = event.window_open - epoch\n    # Compute geodetic latitude at event\n    r_eci = event.entry_state[:3]\n    r_ecef = bh.position_eci_to_ecef(event.window_open, r_eci)\n    geodetic = bh.position_ecef_to_geodetic(r_ecef, bh.AngleFormat.DEGREES)\n    lat = geodetic[1]\n    print(f\"  '{event.name}' at t+{dt:.1f}s (latitude: {lat:.2f} deg)\")\n\n# Count events by type\nascending = [e for e in events if \"Ascending\" in e.name]\ndescending = [e for e in events if \"Descending\" in e.name]\n\nprint(f\"\\nAscending node crossings: {len(ascending)}\")\nprint(f\"Descending node crossings: {len(descending)}\")\n\n# Validate\nassert len(ascending) &gt;= 3  # At least 3 ascending in 3 orbits\nassert len(descending) &gt;= 3  # At least 3 descending in 3 orbits\n</code></pre> <pre><code>//! nalgebra = \"0.34\"\n//! ```\n//!\n//! Using node crossing events to detect equatorial crossings.\n//! Demonstrates detecting ascending and descending node passages.\n\nuse brahe as bh;\nuse bh::events::{DAscendingNodeEvent, DDescendingNodeEvent};\nuse bh::traits::DStatePropagator;\nuse nalgebra as na;\nuse std::f64::consts::PI;\n\nfn main() {\n    // Initialize EOP and space weather data (required for NRLMSISE-00 drag model)\n    bh::initialize_eop().unwrap();\n    bh::initialize_sw().unwrap();\n\n    // Create initial epoch and state - inclined orbit\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    // Inclined orbit for clear node crossings\n    let oe = na::SVector::&lt;f64, 6&gt;::new(bh::R_EARTH + 500e3, 0.01, 45.0, 0.0, 0.0, 0.0);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let params = na::DVector::from_vec(vec![500.0, 2.0, 2.2, 2.0, 1.3]);\n\n    // Create propagator\n    let mut prop = bh::DNumericalOrbitPropagator::new(\n        epoch,\n        na::DVector::from_column_slice(state.as_slice()),\n        bh::NumericalPropagationConfig::default(),\n        bh::ForceModelConfig::default(),\n        Some(params),\n        None,\n        None,\n        None,\n    )\n    .unwrap();\n\n    // Add node crossing events\n    // Ascending node: spacecraft crosses equator heading north (argument of latitude = 0)\n    let asc_event = DAscendingNodeEvent::new(\"Ascending Node\");\n\n    // Descending node: spacecraft crosses equator heading south (argument of latitude = 180 deg)\n    let desc_event = DDescendingNodeEvent::new(\"Descending Node\");\n\n    prop.add_event_detector(Box::new(asc_event));\n    prop.add_event_detector(Box::new(desc_event));\n\n    // Propagate for 3 orbits\n    let orbital_period = 2.0 * PI * (oe[0].powi(3) / bh::GM_EARTH).sqrt();\n    prop.propagate_to(epoch + 3.0 * orbital_period);\n\n    // Check detected events\n    let events = prop.event_log();\n    println!(\"Detected {} node crossing events:\", events.len());\n\n    for event in events {\n        let dt = event.window_open - epoch;\n        // Compute geodetic latitude at event\n        let r_eci = na::Vector3::new(\n            event.entry_state[0],\n            event.entry_state[1],\n            event.entry_state[2],\n        );\n        let r_ecef = bh::position_eci_to_ecef(event.window_open, r_eci);\n        let geodetic = bh::position_ecef_to_geodetic(r_ecef, bh::AngleFormat::Degrees);\n        let lat = geodetic[1];\n        println!(\n            \"  '{}' at t+{:.1}s (latitude: {:.2} deg)\",\n            event.name, dt, lat\n        );\n    }\n\n    // Count events by type\n    let ascending: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Ascending\"))\n        .collect();\n    let descending: Vec&lt;_&gt; = events\n        .iter()\n        .filter(|e| e.name.contains(\"Descending\"))\n        .collect();\n\n    println!(\"\\nAscending node crossings: {}\", ascending.len());\n    println!(\"Descending node crossings: {}\", descending.len());\n\n    // Validate\n    assert!(\n        ascending.len() &gt;= 3,\n        \"Expected at least 3 ascending node crossings\"\n    );\n    assert!(\n        descending.len() &gt;= 3,\n        \"Expected at least 3 descending node crossings\"\n    );\n}\n\n// Expected output:\n// Detected 6 node crossing events:\n//   'Descending Node' at t+2831.5s (latitude: -0.13 deg)\n//   'Ascending Node' at t+5663.2s (latitude: 0.13 deg)\n//   'Descending Node' at t+8494.6s (latitude: -0.13 deg)\n//   'Ascending Node' at t+11326.4s (latitude: 0.13 deg)\n//   'Descending Node' at t+14157.5s (latitude: -0.13 deg)\n//   'Ascending Node' at t+16989.6s (latitude: 0.13 deg)\n//\n// Ascending node crossings: 3\n// Descending node crossings: 3\n</code></pre>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#applications_2","title":"Applications","text":"<ul> <li>Ground track analysis</li> <li>Orbit determination campaigns</li> <li>RAAN drift monitoring</li> <li>Conjunction screening at nodes</li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#quick-reference","title":"Quick Reference","text":""},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#all-premade-events","title":"All Premade Events","text":"Category Event Parameters Eclipse/Shadow <code>EclipseEvent</code> name, edge_type, ephemeris_source <code>UmbraEvent</code> name, edge_type, ephemeris_source <code>PenumbraEvent</code> name, edge_type, ephemeris_source <code>SunlitEvent</code> name, edge_type, ephemeris_source Node Crossings <code>AscendingNodeEvent</code> name <code>DescendingNodeEvent</code> name Orbital Elements <code>SemiMajorAxisEvent</code> value (m), name, direction <code>EccentricityEvent</code> value, name, direction <code>InclinationEvent</code> value, name, direction, angle_format <code>ArgumentOfPerigeeEvent</code> value, name, direction, angle_format <code>MeanAnomalyEvent</code> value, name, direction, angle_format <code>EccentricAnomalyEvent</code> value, name, direction, angle_format <code>TrueAnomalyEvent</code> value, name, direction, angle_format <code>ArgumentOfLatitudeEvent</code> value, name, direction, angle_format State-Derived <code>AltitudeEvent</code> value (m), name, direction <code>SpeedEvent</code> value (m/s), name, direction <code>LongitudeEvent</code> value, name, direction, angle_format <code>LatitudeEvent</code> value, name, direction, angle_format"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#parameter-types","title":"Parameter Types","text":"<p>Value Events (value crossing):</p> <ul> <li><code>direction</code>: <code>EventDirection.INCREASING</code>, <code>EventDirection.DECREASING</code>, or <code>EventDirection.ANY</code></li> <li><code>angle_format</code>: <code>AngleFormat.DEGREES</code> or <code>AngleFormat.RADIANS</code> (angle-based events only)</li> </ul> <p>Binary Events (boolean condition transitions):</p> <ul> <li><code>edge_type</code>: <code>EdgeType.RISING_EDGE</code>, <code>EdgeType.FALLING_EDGE</code>, or <code>EdgeType.ANY_EDGE</code></li> <li><code>ephemeris_source</code>: <code>None</code> (low precision), <code>EphemerisSource.DE440s</code>, or <code>EphemerisSource.DE440</code></li> </ul>"},{"location":"learn/orbit_propagation/numerical_propagation/premade_events.html#see-also","title":"See Also","text":"<ul> <li>Event Detection - Core event detection concepts</li> <li>Event Callbacks - Responding to detected events</li> <li>Maneuvers - Using events for orbit maneuvers</li> </ul>"},{"location":"learn/orbital_dynamics/index.html","title":"Orbital Dynamics and Perturbations","text":"<p>Orbital dynamics describes how satellites and celestial bodies move under the influence of various forces. While simple two-body motion (Keplerian orbits) provides a useful first approximation, real satellite motion is affected by numerous perturbations that cause deviations from these idealized orbits.</p>"},{"location":"learn/orbital_dynamics/index.html#overview-of-perturbation-forces","title":"Overview of Perturbation Forces","text":"<p>The motion of an Earth-orbiting satellite is influenced by several perturbation forces beyond the central body's point-mass gravity:</p> <ul> <li>Non-spherical Earth gravity: The is not actually a perfect, uniform-density sphere. The Earth's non-spherical shape and mass distribution create additional gravitational forces. This distribution we model using spherical harmonics</li> <li>Third-body perturbations: Gravitational effects from the Moon, Sun, and planets also impact satellite orbits with the Moon and Sun being the most significant</li> <li>Atmospheric drag: Despite being in space, satellites in low Earth orbit still encounter traces of the Earth's atmosphere which create drag forces that cause orbital decay. Drag is a non-conservative force that dissipates energy from the orbit. It is highly dependent on atmospheric density, which varies with altitude, solar activity, and geomagnetic conditions, making it challenging to model accurately and the greatest source of uncertainty in LEO orbit prediction. Drag does not affect higher altitude orbits significantly.</li> <li>Solar radiation pressure: The sun emits photons that exert pressure on satellite surfaces. This force is more pronounced for satellites with large surface areas relative to their mass, such as those with solar panels or large antennas.</li> <li>Relativistic effects: While generally small, corrections from general relativity can be significant for high-precision orbit determination and timekeeping.</li> </ul> <p>The relative importance of these forces varies significantly with orbital altitude and satellite characteristics.</p>"},{"location":"learn/orbital_dynamics/index.html#force-magnitude-comparison","title":"Force Magnitude Comparison","text":"<p>The following interactive plot shows the magnitude of various perturbation accelerations as a function of altitude for a satellite with \\(500 \\text{ kg}\\) mass, an area of \\(2.0 \\text{ m}^2\\), a coefficient of drag of \\(C_d = 2.3\\), and a coefficient of reflectivity of \\(C_r = 1.8\\). This visualization helps determine which force models are necessary for different orbital regimes from low Earth orbit (LEO) through geostationary orbit (GEO).</p> Plot Source fig_perturbation_magnitudes.py<pre><code>import pathlib\nimport sys\nimport plotly.graph_objects as go\nimport numpy as np\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import save_themed_html, get_theme_colors\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize Brahe\nbh.initialize_eop()\n\n# Initialize DE440s ephemeris for high-accuracy planetary positions\nbh.initialize_ephemeris()\n\n# Reference epoch for calculations (J2000)\nepoch = bh.Epoch.from_datetime(2000, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Satellite parameters for drag and SRP\nMASS = 500.0  # kg\nAREA = 2.0  # m\u00b2\nCD = 2.3  # Drag coefficient\nCR = 1.8  # Radiation pressure coefficient\n\n# Altitude range: 200 km to 40,000 km\naltitudes_km = np.linspace(200, 40000, 500)\naltitudes_m = altitudes_km * 1e3\n\n# Storage for acceleration magnitudes\naccel_point_mass = np.zeros_like(altitudes_m)\naccel_j2 = np.zeros_like(altitudes_m)\naccel_j22 = np.zeros_like(altitudes_m)\naccel_sun = np.zeros_like(altitudes_m)\naccel_moon = np.zeros_like(altitudes_m)\naccel_venus = np.zeros_like(altitudes_m)\naccel_jupiter = np.zeros_like(altitudes_m)\naccel_saturn = np.zeros_like(altitudes_m)\naccel_drag_mag = np.zeros_like(altitudes_m)\naccel_srp_mag = np.zeros_like(altitudes_m)\naccel_relativity_mag = np.zeros_like(altitudes_m)\n\nprint(\"Calculating perturbation accelerations...\")\n\n# Get Sun and Moon positions for reference epoch using DE ephemeris\nr_sun = bh.sun_position_de(epoch, bh.EphemerisSource.DE440s)\nr_moon = bh.moon_position_de(epoch, bh.EphemerisSource.DE440s)\n\n# Identity rotation matrix for gravity calculations (assuming circular equatorial orbit for simplicity)\nR_identity = np.eye(3)\n\n# Load gravity model for harmonics calculations\ngravity_model = bh.GravityModel.from_model_type(bh.GravityModelType.JGM3)\n\n# Calculate accelerations at each altitude\nfor i, alt_m in enumerate(altitudes_m):\n    r = bh.R_EARTH + alt_m\n\n    # Position vector (assume circular equatorial orbit for reference)\n    r_vec = np.array([r, 0.0, 0.0])\n\n    # Orbital velocity for circular orbit\n    v_circ = np.sqrt(bh.GM_EARTH / r)\n    v_vec = np.array([0.0, v_circ, 0.0])\n    state = np.concatenate([r_vec, v_vec])\n\n    # Point mass gravity (for reference)\n    a_pm = bh.accel_point_mass_gravity(r_vec, np.zeros(3), bh.GM_EARTH)\n    accel_point_mass[i] = np.linalg.norm(a_pm)\n\n    # Spherical harmonics (J2 only, n=2, m=0)\n    a_sh_j2 = bh.accel_gravity_spherical_harmonics(\n        r_vec, R_identity, gravity_model, 2, 0\n    )\n    accel_j2[i] = np.linalg.norm(a_sh_j2 - a_pm)  # Perturbation only\n\n    # J22 component (n=2, m=2)\n    a_sh_j22 = bh.accel_gravity_spherical_harmonics(\n        r_vec, R_identity, gravity_model, 2, 2\n    )\n    accel_j22[i] = np.linalg.norm(a_sh_j22 - a_sh_j2)  # J22 perturbation only\n\n    # Third-body: Sun (using DE ephemeris)\n    a_sun = bh.accel_third_body_sun_de(epoch, r_vec, bh.EphemerisSource.DE440s)\n    accel_sun[i] = np.linalg.norm(a_sun)\n\n    # Third-body: Moon (using DE ephemeris)\n    a_moon = bh.accel_third_body_moon_de(epoch, r_vec, bh.EphemerisSource.DE440s)\n    accel_moon[i] = np.linalg.norm(a_moon)\n\n    # Third-body: Venus (using DE ephemeris)\n    a_venus = bh.accel_third_body_venus_de(epoch, r_vec, bh.EphemerisSource.DE440s)\n    accel_venus[i] = np.linalg.norm(a_venus)\n\n    # Third-body: Jupiter (using DE ephemeris)\n    a_jupiter = bh.accel_third_body_jupiter_de(epoch, r_vec, bh.EphemerisSource.DE440s)\n    accel_jupiter[i] = np.linalg.norm(a_jupiter)\n\n    # Third-body: Saturn (using DE ephemeris)\n    a_saturn = bh.accel_third_body_saturn_de(epoch, r_vec, bh.EphemerisSource.DE440s)\n    accel_saturn[i] = np.linalg.norm(a_saturn)\n\n    # Atmospheric drag (only significant below ~1000 km)\n    if alt_m &lt; 1000e3:\n        # Use Harris-Priester atmospheric density model\n        density = bh.density_harris_priester(r_vec, r_sun)\n\n        # Only calculate drag if density is non-zero\n        if density &gt; 0.0:\n            # Rotation matrix (identity for inertial frame)\n            T_matrix = np.eye(3)\n\n            a_drag = bh.accel_drag(state, density, MASS, AREA, CD, T_matrix)\n            accel_drag_mag[i] = np.linalg.norm(a_drag)\n        else:\n            accel_drag_mag[i] = np.nan  # Below 100 km or above 1000 km\n    else:\n        accel_drag_mag[i] = np.nan  # Not plotted\n\n    # Solar radiation pressure\n    P0 = 4.56e-6  # N/m\u00b2 at 1 AU\n    a_srp = bh.accel_solar_radiation_pressure(r_vec, r_sun, MASS, CR, AREA, P0)\n    accel_srp_mag[i] = np.linalg.norm(a_srp)\n\n    # Relativistic effects\n    a_rel = bh.accel_relativity(state)\n    accel_relativity_mag[i] = np.linalg.norm(a_rel)\n\nprint(\"Calculations complete. Generating plots...\")\n\n\n# Create figure with theme support\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    theme_colors = get_theme_colors(theme)\n\n    # Define category-specific colors\n    if theme == \"light\":\n        color_gravity = \"#1f77b4\"  # Blue - gravitational forces\n        color_third_body = \"#2ca02c\"  # Green - third-body perturbations\n        color_drag = \"#d62728\"  # Red - atmospheric drag\n        color_srp = \"#ffa500\"  # Gold/Orange - solar radiation pressure\n        color_relativity = \"#9467bd\"  # Purple - relativistic effects\n    else:  # dark theme\n        color_gravity = \"#5599ff\"  # Lighter blue\n        color_third_body = \"#55cc55\"  # Lighter green\n        color_drag = \"#ff6b6b\"  # Lighter red\n        color_srp = \"#ffcc44\"  # Lighter gold\n        color_relativity = \"#bb88dd\"  # Lighter purple\n\n    fig = go.Figure()\n\n    # Add shaded regions for orbital regimes\n    # LEO: 200-2000 km (shaded red/purple - where drag dominates)\n    fig.add_vrect(\n        x0=200,\n        x1=2000,\n        fillcolor=color_drag,\n        opacity=0.08,\n        layer=\"below\",\n        line_width=0,\n        annotation_text=\"LEO\",\n        annotation_position=\"top left\",\n        annotation_font_size=11,\n        annotation_font_color=theme_colors[\"font_color\"],\n    )\n\n    # MEO: 2000-35786 km (no shading, just annotation)\n    fig.add_annotation(\n        x=10000,  # Position in middle of MEO range\n        y=1,\n        yref=\"paper\",\n        text=\"MEO\",\n        showarrow=False,\n        font=dict(size=11, color=theme_colors[\"font_color\"]),\n        yanchor=\"top\",\n        yshift=-10,\n    )\n\n    # GEO: 35786-40000 km (shaded gold - where SRP is significant)\n    fig.add_vrect(\n        x0=35786,\n        x1=40000,\n        fillcolor=color_srp,\n        opacity=0.08,\n        layer=\"below\",\n        line_width=0,\n        annotation_text=\"GEO\",\n        annotation_position=\"top right\",\n        annotation_font_size=11,\n        annotation_font_color=theme_colors[\"font_color\"],\n    )\n\n    # ============================================================================\n    # GRAVITATIONAL FORCES (Blue)\n    # ============================================================================\n\n    # Point mass gravity (reference)\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_point_mass,\n            name=\"Point Mass Gravity\",\n            mode=\"lines\",\n            line=dict(color=color_gravity, width=2.5),\n            hovertemplate=\"&lt;b&gt;Point Mass&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # J2 (oblateness)\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_j2,\n            name=\"J\u2082 (Oblateness)\",\n            mode=\"lines\",\n            line=dict(color=color_gravity, width=2, dash=\"dash\"),\n            hovertemplate=\"&lt;b&gt;J\u2082&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # J22\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_j22,\n            name=\"J\u2082\u2082\",\n            mode=\"lines\",\n            line=dict(color=color_gravity, width=1.5, dash=\"dot\"),\n            hovertemplate=\"&lt;b&gt;J\u2082\u2082&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # ============================================================================\n    # THIRD-BODY PERTURBATIONS (Green)\n    # ============================================================================\n\n    # Third-body: Sun\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_sun,\n            name=\"Third-Body (Sun)\",\n            mode=\"lines\",\n            line=dict(color=color_third_body, width=2.5),\n            hovertemplate=\"&lt;b&gt;Sun&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Third-body: Moon\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_moon,\n            name=\"Third-Body (Moon)\",\n            mode=\"lines\",\n            line=dict(color=color_third_body, width=2.5, dash=\"dash\"),\n            hovertemplate=\"&lt;b&gt;Moon&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Third-body: Venus\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_venus,\n            name=\"Third-Body (Venus)\",\n            mode=\"lines\",\n            line=dict(color=color_third_body, width=1.5, dash=\"dash\"),\n            hovertemplate=\"&lt;b&gt;Venus&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Third-body: Jupiter\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_jupiter,\n            name=\"Third-Body (Jupiter)\",\n            mode=\"lines\",\n            line=dict(color=color_third_body, width=1.5, dash=\"dot\"),\n            hovertemplate=\"&lt;b&gt;Jupiter&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Third-body: Saturn\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_saturn,\n            name=\"Third-Body (Saturn)\",\n            mode=\"lines\",\n            line=dict(color=color_third_body, width=1.5, dash=\"dashdot\"),\n            hovertemplate=\"&lt;b&gt;Saturn&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # ============================================================================\n    # ATMOSPHERIC DRAG (Red)\n    # ============================================================================\n\n    # Atmospheric drag\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_drag_mag,\n            name=\"Atmospheric Drag\",\n            mode=\"lines\",\n            line=dict(color=color_drag, width=2.5),\n            connectgaps=False,\n            hovertemplate=\"&lt;b&gt;Drag&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # ============================================================================\n    # SOLAR RADIATION PRESSURE (Gold)\n    # ============================================================================\n\n    # Solar radiation pressure\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_srp_mag,\n            name=\"Solar Radiation Pressure\",\n            mode=\"lines\",\n            line=dict(color=color_srp, width=2),\n            hovertemplate=\"&lt;b&gt;SRP&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # ============================================================================\n    # RELATIVISTIC EFFECTS (Purple)\n    # ============================================================================\n\n    # Relativistic effects\n    fig.add_trace(\n        go.Scatter(\n            x=altitudes_km,\n            y=accel_relativity_mag,\n            name=\"Relativistic Effects\",\n            mode=\"lines\",\n            line=dict(color=color_relativity, width=1.5),\n            hovertemplate=\"&lt;b&gt;Relativity&lt;/b&gt;&lt;br&gt;Altitude: %{x:.0f} km&lt;br&gt;Accel: %{y:.2e} m/s\u00b2&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Configure layout\n    fig.update_layout(\n        title=\"Orbital Perturbation Force Magnitudes vs Altitude\",\n        xaxis_title=\"Altitude (km)\",\n        yaxis_title=\"Acceleration Magnitude (m/s\u00b2)\",\n        yaxis_type=\"log\",\n        hovermode=\"closest\",\n        legend=dict(yanchor=\"top\", y=0.99, xanchor=\"right\", x=0.99),\n    )\n\n    fig.update_xaxes(title_text=\"Altitude (km)\")\n    fig.update_yaxes(title_text=\"Acceleration Magnitude (m/s\u00b2)\", type=\"log\")\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbital_dynamics/index.html#available-perturbation-models","title":"Available Perturbation Models","text":"<p>Brahe provides implementations of the following perturbation acceleration models:</p> <ul> <li>Gravity Models: Point-mass and spherical harmonic expansion (EGM2008, GGM05S, JGM3)</li> <li>Third-Body Perturbations: Sun, Moon, and planetary effects using analytical or DE440s ephemerides</li> <li>Atmospheric Drag: With Harris-Priester density model</li> <li>Solar Radiation Pressure: Including conical Earth shadow model</li> <li>Relativistic Effects: General relativistic corrections</li> </ul> <p>Each model is available in both Rust and Python with identical interfaces. See the individual pages for detailed explanations and usage examples.</p>"},{"location":"learn/orbital_dynamics/index.html#references","title":"References","text":"<ol> <li>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Chapter 3: Force Model.</li> </ol>"},{"location":"learn/orbital_dynamics/drag.html","title":"Atmospheric Drag","text":"<p>Atmospheric drag is one of the most significant perturbations for satellites in low Earth orbit (LEO). Even at altitudes of up to 2000 km, there are still traces of the Earth's atmosphere that create drag forces on satellites. This drag causes orbital decay, leading to a gradual decrease in altitude over time.</p> <p>Drag is a non-conservative force that dissipates orbital energy. It is also highly dependent on atmospheric density, which varies with altitude, solar activity, geomagnetic conditions, and other factors. This variability makes drag one of the most challenging perturbations to model accurately and is often the largest source of uncertainty in LEO orbit prediction.</p> <p>Note</p> <p>Brahe implements both the simple Harris-Priester model and the more advanced NRLMSISE-00 empirical atmospheric model for drag calculations.</p>"},{"location":"learn/orbital_dynamics/drag.html#physical-model","title":"Physical Model","text":"<p>The drag acceleration on a satellite moving through the atmosphere is:</p> \\[ \\mathbf{a}_D = -\\frac{1}{2} C_D \\frac{A}{m} \\rho v_{rel}^2 \\mathbf{\\hat{v}}_{rel} \\] <p>where:</p> <ul> <li>\\(\\rho\\) is atmospheric density (kg/m\u00b3)</li> <li>\\(v_{rel}\\) is the satellite's speed relative to the atmosphere (m/s)</li> <li>\\(C_D\\) is the drag coefficient (dimensionless, typically 2.0-2.5)</li> <li>\\(A\\) is the cross-sectional area perpendicular to velocity (m\u00b2)</li> <li>\\(m\\) is the satellite mass (kg)</li> <li>\\(\\mathbf{\\hat{v}}_{rel}\\) is the unit velocity vector relative to the atmosphere</li> </ul>"},{"location":"learn/orbital_dynamics/drag.html#key-dependencies","title":"Key Dependencies","text":""},{"location":"learn/orbital_dynamics/drag.html#atmospheric-density","title":"Atmospheric Density","text":"<p>Atmospheric density is the most uncertain and variable parameter in drag modeling. It depends on, altitude, solar and geomagnetic activity, time of day, geographic location, and season.</p>"},{"location":"learn/orbital_dynamics/drag.html#satellite-properties","title":"Satellite Properties","text":"<p>The satellite's ballistic coefficient \\(B = C_D A / m\\) determines drag sensitivity:</p> <ul> <li>Large area-to-mass ratio (high B): Lightweight satellites, large solar panels - sensitive to drag</li> <li>Small area-to-mass ratio (low B): Dense satellites - less affected by drag</li> </ul>"},{"location":"learn/orbital_dynamics/drag.html#density-models","title":"Density Models","text":"<p>There are many atmospheric density models available, ranging from simple empirical models to complex physics-based models.</p>"},{"location":"learn/orbital_dynamics/drag.html#harris-priester-atmospheric-model","title":"Harris-Priester Atmospheric Model","text":"<p>The Harris-Priester model is a simple, semi-empirical static atmospheric density model that accounts for:</p> <ul> <li>Exponential density decrease with altitude</li> <li>Day-night density variations (diurnal bulge)</li> <li>Solar activity effects through minimum/maximum density tables</li> </ul> <p>The model divides the atmosphere into altitude bins and provides density values for minimum and maximum solar activity conditions. Interpolation between these values allows modeling of different solar cycle phases.</p>"},{"location":"learn/orbital_dynamics/drag.html#nrlmsise-00-atmospheric-model","title":"NRLMSISE-00 Atmospheric Model","text":"<p>The NRLMSISE-00 (Naval Research Laboratory Mass Spectrometer and Incoherent Scatter Radar Exosphere) model is an empirical atmospheric model that provides temperature and density profiles from ground to thermospheric heights.</p> <p>Key features:</p> <ul> <li>Uses space weather data (F10.7 solar flux, Ap geomagnetic indices)</li> <li>Accounts for temporal variations (diurnal, seasonal, solar cycle)</li> <li>Includes atmospheric composition (\\(He\\), \\(O\\), \\(N_2\\), \\(O_2\\), \\(Ar\\), \\(H\\), \\(N\\))</li> <li>Valid for altitudes from ground to ~1000+ km</li> </ul> <p>The model requires initialization of both Earth orientation data and space weather data:</p> <ul> <li>Earth orientation data: <code>bh.initialize_eop()</code></li> <li>Space weather data: <code>bh.initialize_sw()</code></li> </ul> <p>For full API details, see the NRLMSISE-00 API Reference.</p>"},{"location":"learn/orbital_dynamics/drag.html#usage-examples","title":"Usage Examples","text":""},{"location":"learn/orbital_dynamics/drag.html#computing-drag-acceleration","title":"Computing Drag Acceleration","text":"<p>Calculate the atmospheric drag acceleration on a satellite using the Harris-Priester density model.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create an epoch\nepoch = bh.Epoch.from_datetime(2024, 3, 15, 14, 30, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define satellite state in ECI frame (LEO satellite at 450 km altitude)\na = bh.R_EARTH + 450e3  # Semi-major axis (m)\ne = 0.002  # Eccentricity\ni = 51.6  # Inclination (deg)\nraan = 90.0  # RAAN (deg)\nargp = 45.0  # Argument of perigee (deg)\nnu = 120.0  # True anomaly (deg)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\nprint(\"Satellite state (ECI):\")\nprint(\n    f\"  Position: [{state_eci[0] / 1e3:.1f}, {state_eci[1] / 1e3:.1f}, {state_eci[2] / 1e3:.1f}] km\"\n)\nprint(\n    f\"  Velocity: [{state_eci[3] / 1e3:.3f}, {state_eci[4] / 1e3:.3f}, {state_eci[5] / 1e3:.3f}] km/s\"\n)\nprint(f\"  Altitude: {(np.linalg.norm(state_eci[0:3]) - bh.R_EARTH) / 1e3:.1f} km\")\n\n# Atmospheric density\n# For this example, use a typical density for the given altitude (~450 km)\n# In practice, this would be computed using atmospheric density models like Harris-Priester\n# Typical value for ~450 km altitude: 3-5 \u00d7 10^-12 kg/m\u00b3\ndensity = 4.0e-12  # kg/m\u00b3\n\nprint(f\"\\nAtmospheric density (exponential model): {density:.6e} kg/m\u00b3\")\n\n# Define satellite properties\nmass = 500.0  # kg (typical small satellite)\narea = 2.5  # m\u00b2 (cross-sectional area)\ncd = 2.2  # Drag coefficient (typical for satellites)\n\nprint(\"\\nSatellite properties:\")\nprint(f\"  Mass: {mass:.1f} kg\")\nprint(f\"  Area: {area:.1f} m\u00b2\")\nprint(f\"  Drag coefficient: {cd:.1f}\")\nprint(f\"  Ballistic coefficient: {cd * area / mass:.6f} m\u00b2/kg\")\n\n# Compute ECI to ECEF rotation matrix for atmospheric velocity\nR_eci_ecef = bh.rotation_eci_to_ecef(epoch)\n\n# Compute drag acceleration\naccel_drag = bh.accel_drag(state_eci, density, mass, area, cd, R_eci_ecef)\n\nprint(\"\\nDrag acceleration (ECI, m/s\u00b2):\")\nprint(f\"  ax = {accel_drag[0]:.9f}\")\nprint(f\"  ay = {accel_drag[1]:.9f}\")\nprint(f\"  az = {accel_drag[2]:.9f}\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_drag):.9f} m/s\u00b2\")\n\n# Compute velocity magnitude\nv_mag = np.linalg.norm(state_eci[3:6])\nprint(f\"\\nOrbital velocity: {v_mag:.3f} m/s ({v_mag / 1e3:.3f} km/s)\")\n\n# Theoretical drag magnitude check: 0.5 * rho * v\u00b2 * Cd * A / m\naccel_theory = 0.5 * density * v_mag**2 * cd * area / mass\nprint(f\"Theoretical drag magnitude: {accel_theory:.9f} m/s\u00b2\")\n\n# Expected output:\n# Satellite state (ECI):\n#   Position: [-1084.6, -6608.2, 1368.5] km\n#   Velocity: [4.582, -1.963, -5.781] km/s\n#   Altitude: 456.8 km\n\n# Atmospheric density (exponential model): 4.000000e-12 kg/m\u00b3\n\n# Satellite properties:\n#   Mass: 500.0 kg\n#   Area: 2.5 m\u00b2\n#   Drag coefficient: 2.2\n#   Ballistic coefficient: 0.011000 m\u00b2/kg\n\n# Drag acceleration (ECI, m/s\u00b2):\n#   ax = -0.000000661\n#   ay = 0.000000304\n#   az = 0.000000932\n#   Magnitude: 0.000001183 m/s\u00b2\n\n# Orbital velocity: 7632.770 m/s (7.633 km/s)\n# Theoretical drag magnitude: 0.000001282 m/s\u00b2\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute atmospheric drag acceleration using Harris-Priester density model\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epoch = bh::Epoch::from_datetime(2024, 3, 15, 14, 30, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define satellite state in ECI frame (LEO satellite at 450 km altitude)\n    let a = bh::constants::R_EARTH + 450e3; // Semi-major axis (m)\n    let e = 0.002;                          // Eccentricity\n    let i = 51.6;                           // Inclination (deg) - ISS-like\n    let raan = 90.0;                        // RAAN (deg)\n    let argp = 45.0;                        // Argument of perigee (deg)\n    let nu = 120.0;                         // True anomaly (deg)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    println!(\"Satellite state (ECI):\");\n    println!(\"  Position: [{:.1}, {:.1}, {:.1}] km\",\n             state_eci[0] / 1e3, state_eci[1] / 1e3, state_eci[2] / 1e3);\n    println!(\"  Velocity: [{:.3}, {:.3}, {:.3}] km/s\",\n             state_eci[3] / 1e3, state_eci[4] / 1e3, state_eci[5] / 1e3);\n    let r_eci = state_eci.fixed_rows::&lt;3&gt;(0);\n    println!(\"  Altitude: {:.1} km\", (r_eci.norm() - bh::constants::R_EARTH) / 1e3);\n\n    // Atmospheric density\n    // For this example, use a typical density for the given altitude (~450 km)\n    // In practice, this would be computed using atmospheric density models like Harris-Priester\n    // Typical value for ~450 km altitude: 3-5 \u00d7 10^-12 kg/m\u00b3\n    let density = 4.0e-12; // kg/m\u00b3\n\n    println!(\"\\nAtmospheric density (exponential model): {:.6e} kg/m\u00b3\", density);\n\n    // Define satellite properties\n    let mass = 500.0;   // kg (typical small satellite)\n    let area = 2.5;     // m\u00b2 (cross-sectional area)\n    let cd = 2.2;       // Drag coefficient (typical for satellites)\n\n    println!(\"\\nSatellite properties:\");\n    println!(\"  Mass: {:.1} kg\", mass);\n    println!(\"  Area: {:.1} m\u00b2\", area);\n    println!(\"  Drag coefficient: {:.1}\", cd);\n    println!(\"  Ballistic coefficient: {:.6} m\u00b2/kg\", cd * area / mass);\n\n    // Compute ECI to ECEF rotation matrix for atmospheric velocity\n    let r_eci_ecef = bh::rotation_eci_to_ecef(epoch);\n\n    // Compute drag acceleration\n    let accel_drag = bh::orbit_dynamics::accel_drag(state_eci, density, mass, area, cd, r_eci_ecef);\n\n    println!(\"\\nDrag acceleration (ECI, m/s\u00b2):\");\n    println!(\"  ax = {:.9}\", accel_drag[0]);\n    println!(\"  ay = {:.9}\", accel_drag[1]);\n    println!(\"  az = {:.9}\", accel_drag[2]);\n    println!(\"  Magnitude: {:.9} m/s\u00b2\", accel_drag.norm());\n\n    // Compute velocity magnitude\n    let v_eci = state_eci.fixed_rows::&lt;3&gt;(3);\n    let v_mag = v_eci.norm();\n    println!(\"\\nOrbital velocity: {:.3} m/s ({:.3} km/s)\", v_mag, v_mag / 1e3);\n\n    // Theoretical drag magnitude check: 0.5 * rho * v\u00b2 * Cd * A / m\n    let accel_theory = 0.5 * density * v_mag * v_mag * cd * area / mass;\n    println!(\"Theoretical drag magnitude: {:.9} m/s\u00b2\", accel_theory);\n\n    // Expected output:\n    // Satellite state (ECI):\n    //   Position: [-1084.6, -6608.2, 1368.5] km\n    //   Velocity: [4.582, -1.963, -5.781] km/s\n    //   Altitude: 456.8 km\n\n    // Atmospheric density (exponential model): 4.000000e-12 kg/m\u00b3\n\n    // Satellite properties:\n    //   Mass: 500.0 kg\n    //   Area: 2.5 m\u00b2\n    //   Drag coefficient: 2.2\n    //   Ballistic coefficient: 0.011000 m\u00b2/kg\n\n    // Drag acceleration (ECI, m/s\u00b2):\n    //   ax = -0.000000661\n    //   ay = 0.000000304\n    //   az = 0.000000932\n    //   Magnitude: 0.000001183 m/s\u00b2\n\n    // Orbital velocity: 7632.770 m/s (7.633 km/s)\n    // Theoretical drag magnitude: 0.000001282 m/s\u00b2\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/drag.html#see-also","title":"See Also","text":"<ul> <li>Library API Reference: Drag</li> <li>Library API Reference: Earth Models</li> <li>Orbital Dynamics Overview</li> </ul>"},{"location":"learn/orbital_dynamics/drag.html#references","title":"References","text":"<p>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Section 3.4: Atmospheric Drag.</p>"},{"location":"learn/orbital_dynamics/gravity.html","title":"Gravity Models","text":"<p>Earth's gravitational field is the dominant force acting on satellites and space debris. While a simple point-mass model provides a useful first approximation, the real Earth's non-spherical mass distribution creates additional gravitational effects that must be modeled for accurate orbit prediction.</p>"},{"location":"learn/orbital_dynamics/gravity.html#point-mass-gravity","title":"Point-Mass Gravity","text":"<p>The simplest model treats Earth (or any celestial body) as a point mass with all mass concentrated at its center. The gravitational acceleration is:</p> \\[ \\mathbf{a} = -\\frac{GM}{r^3} \\mathbf{r} \\] <p>where:</p> <ul> <li>\\(GM\\) is the gravitational parameter (m\u00b3/s\u00b2)</li> <li>\\(\\mathbf{r}\\) is the position vector from the central body's center (m)</li> <li>\\(r = |\\mathbf{r}|\\) is the distance</li> </ul> <p>This model for gravity is computationally efficient and works well for modeling the effect of third-body perturbations from other planets and moons. This is discussed further in the Third-Body Perturbations section.</p>"},{"location":"learn/orbital_dynamics/gravity.html#spherical-harmonic-expansion","title":"Spherical Harmonic Expansion","text":"<p>Newton's law is excellent since it allows us to analytically solve the two-body problem. However, for Earth-orbiting satellites, the point-mass assumption is insufficient due to the planet's non-uniform shape and mass distribution. The Earth's equatorial bulge, polar flattening, and irregular mass distribution cause the gravitational attraction to vary with location. These variations are modeled using spherical harmonics - a mathematical expansion in terms of Legendre polynomials.</p>"},{"location":"learn/orbital_dynamics/gravity.html#geopotential","title":"Geopotential","text":"<p>The gravitational potential at a point outside Earth can be expressed as:</p> \\[ V(r, \\phi, \\lambda) = \\frac{GM}{r} \\sum_{n=0}^{\\infty} \\sum_{m=0}^{n} \\left(\\frac{R_E}{r}\\right)^n \\bar{P}_{nm}(\\sin\\phi) \\left(\\bar{C}_{nm}\\cos(m\\lambda) + \\bar{S}_{nm}\\sin(m\\lambda)\\right) \\] <p>where:</p> <ul> <li>\\(r, \\phi, \\lambda\\) are spherical coordinates (radius, latitude, longitude)</li> <li>\\(R_E\\) is Earth's equatorial radius</li> <li>\\(\\bar{P}_{nm}\\) are normalized associated Legendre polynomials</li> <li>\\(\\bar{C}_{nm}, \\bar{S}_{nm}\\) are normalized geopotential coefficients</li> <li>\\(n\\) is the degree, \\(m\\) is the order</li> </ul> <p>The acceleration is computed as the gradient of this potential, yielding:</p> \\[ \\mathbf{a} = -\\nabla \\frac{GM}{r} \\sum_{n=0}^{\\infty} \\sum_{m=0}^{n} \\left(\\frac{R_E}{r}\\right)^n \\bar{P}_{nm}(\\sin\\phi) \\left(\\bar{C}_{nm}\\cos(m\\lambda) + \\bar{S}_{nm}\\sin(m\\lambda)\\right) \\]"},{"location":"learn/orbital_dynamics/gravity.html#dominant-terms","title":"Dominant Terms","text":"<p>The most significant non-spherical terms are:</p> <ul> <li> <p>\\(\\mathbf{J}_2\\) (the \\(C_{2,0}\\right\\) harmonic) models Earth's oblateness and is ~1000\u00d7 larger than any other term. It causes orbital precession, that is regression of the ascending node and rotation of the argument of perigee, which make sun-synchronous orbits possible.</p> </li> <li> <p>\\(\\mathbf{J}_{2,2}\\) (the \\(C_{2,2}, S_{2,2}\\right\\) harmonics) model Earth's ellipticity (difference between equatorial radii). Creates tesseral perturbations.</p> </li> <li> <p>Higher-order terms: Become important for precise orbit determination and long-term propagation, especially for low Earth orbit satellites.</p> </li> </ul>"},{"location":"learn/orbital_dynamics/gravity.html#gravity-models_1","title":"Gravity Models","text":"<p>Brahe includes several standard geopotential models with different degrees and orders of expansion:</p> <ul> <li>EGM2008: Earth Gravitational Model 2008, high-fidelity model to degree/order 360</li> <li>GGM05S: GRACE Gravity Model, degree/order 180</li> <li>JGM3: Joint Gravity Model 3, degree/order 70</li> </ul> <p>Higher degree/order models provide more accuracy but require more computation. For most applications:</p> <ul> <li>Low Earth Orbit: Degree/order 10-20 sufficient for short-term propagation</li> <li>Medium/Geostationary Orbit: Degree/order 4-8 usually adequate</li> <li>High-precision applications: Degree/order 50+ may be needed</li> </ul> <p>Additional gravity models (<code>.gfc</code> files) can be downloaded from the International Centre for Global Earth Models (ICGEM) repository and used with Brahe.</p>"},{"location":"learn/orbital_dynamics/gravity.html#computational-considerations","title":"Computational Considerations","text":"<p>Spherical harmonic evaluation involves recursive computation of Legendre polynomials and requires rotation between Earth-fixed and inertial frames. The computational cost scales as O(n\u00b2) where n is the maximum degree.</p> <p>For real-time applications or long propagations with many time steps, limiting the degree and order to only what's necessary for the required accuracy is important for performance.</p>"},{"location":"learn/orbital_dynamics/gravity.html#usage-examples","title":"Usage Examples","text":""},{"location":"learn/orbital_dynamics/gravity.html#point-mass-gravity_1","title":"Point-Mass Gravity","text":"<p>The point-mass gravity model can be used for any celestial body by providing its gravitational parameter and position.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define satellite position in ECI frame (LEO satellite at 500 km altitude)\n# Using Keplerian elements and converting to Cartesian\na = bh.R_EARTH + 500e3  # Semi-major axis (m)\ne = 0.001  # Eccentricity\ni = 97.8  # Inclination (deg)\nraan = 0.0  # RAAN (deg)\nargp = 0.0  # Argument of perigee (deg)\nnu = 0.0  # True anomaly (deg)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nr_sat = state[0:3]  # Position vector (m)\n\nprint(\"Satellite position (ECI, m):\")\nprint(f\"  x = {r_sat[0]:.3f}\")\nprint(f\"  y = {r_sat[1]:.3f}\")\nprint(f\"  z = {r_sat[2]:.3f}\")\n\n# Compute point-mass gravitational acceleration\n# For Earth-centered case, central body is at origin\nr_earth = np.array([0.0, 0.0, 0.0])\naccel = bh.accel_point_mass_gravity(r_sat, r_earth, bh.GM_EARTH)\n\nprint(\"\\nPoint-mass gravity acceleration (m/s\u00b2):\")\nprint(f\"  ax = {accel[0]:.6f}\")\nprint(f\"  ay = {accel[1]:.6f}\")\nprint(f\"  az = {accel[2]:.6f}\")\n\n# Compute magnitude\naccel_mag = np.linalg.norm(accel)\nprint(f\"\\nAcceleration magnitude: {accel_mag:.6f} m/s\u00b2\")\n\n# Compare to theoretical value: GM/r\u00b2\nr_mag = np.linalg.norm(r_sat)\naccel_theoretical = bh.GM_EARTH / (r_mag**2)\nprint(f\"Theoretical magnitude: {accel_theoretical:.6f} m/s\u00b2\")\n\n# Expected output:\n# Satellite position (ECI, m):\n#   x = 6871258.164\n#   y = 0.000\n#   z = 0.000\n\n# Point-mass gravity acceleration (m/s\u00b2):\n#   ax = -8.442387\n#   ay = -0.000000\n#   az = -0.000000\n\n# Acceleration magnitude: 8.442387 m/s\u00b2\n# Theoretical magnitude: 8.442387 m/s\u00b2\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute point-mass gravitational acceleration for an Earth satellite\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define satellite position in ECI frame (LEO satellite at 500 km altitude)\n    // Using Keplerian elements and converting to Cartesian\n    let a = bh::constants::R_EARTH + 500e3; // Semi-major axis (m)\n    let e = 0.001;                          // Eccentricity\n    let i = 97.8;                           // Inclination (deg)\n    let raan = 0.0;                         // RAAN (deg)\n    let argp = 0.0;                         // Argument of perigee (deg)\n    let nu = 0.0;                           // True anomaly (deg)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let r_sat = na::Vector3::new(state[0], state[1], state[2]); // Position vector (m)\n\n    println!(\"Satellite position (ECI, m):\");\n    println!(\"  x = {:.3}\", r_sat[0]);\n    println!(\"  y = {:.3}\", r_sat[1]);\n    println!(\"  z = {:.3}\", r_sat[2]);\n\n    // Compute point-mass gravitational acceleration\n    // For Earth-centered case, central body is at origin\n    let r_earth = na::Vector3::&lt;f64&gt;::zeros();\n    let accel = bh::orbit_dynamics::accel_point_mass_gravity(r_sat, r_earth, bh::constants::GM_EARTH);\n\n    println!(\"\\nPoint-mass gravity acceleration (m/s\u00b2):\");\n    println!(\"  ax = {:.6}\", accel[0]);\n    println!(\"  ay = {:.6}\", accel[1]);\n    println!(\"  az = {:.6}\", accel[2]);\n\n    // Compute magnitude\n    let accel_mag = accel.norm();\n    println!(\"\\nAcceleration magnitude: {:.6} m/s\u00b2\", accel_mag);\n\n    // Compare to theoretical value: GM/r\u00b2\n    let r_mag = r_sat.norm();\n    let accel_theoretical = bh::constants::GM_EARTH / (r_mag * r_mag);\n    println!(\"Theoretical magnitude: {:.6} m/s\u00b2\", accel_theoretical);\n\n    // Expected output:\n    // Satellite position (ECI, m):\n    //   x = 6871258.164\n    //   y = 0.000\n    //   z = 0.000\n\n    // Point-mass gravity acceleration (m/s\u00b2):\n    //   ax = -8.442387\n    //   ay = -0.000000\n    //   az = -0.000000\n\n    // Acceleration magnitude: 8.442387 m/s\u00b2\n    // Theoretical magnitude: 8.442387 m/s\u00b2\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/gravity.html#spherical-harmonics","title":"Spherical Harmonics","text":"<p>For high-fidelity Earth gravity modeling, use the spherical harmonic expansion with an appropriate geopotential model.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create an epoch for frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define satellite position in ECI frame (LEO satellite at 500 km altitude)\na = bh.R_EARTH + 500e3  # Semi-major axis (m)\ne = 0.001  # Eccentricity\ni = 97.8  # Inclination (deg)\nraan = 45.0  # RAAN (deg)\nargp = 30.0  # Argument of perigee (deg)\nnu = 60.0  # True anomaly (deg)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nr_eci = state_eci[0:3]  # Position vector (m)\n\nprint(\"Satellite position (ECI, m):\")\nprint(f\"  x = {r_eci[0]:.3f}\")\nprint(f\"  y = {r_eci[1]:.3f}\")\nprint(f\"  z = {r_eci[2]:.3f}\")\n\n# Load gravity model (GGM05S - degree/order 180)\ngravity_model = bh.GravityModel.from_model_type(bh.GravityModelType.GGM05S)\nprint(\n    f\"\\nGravity model: GGM05S (max degree {gravity_model.n_max}, max order {gravity_model.m_max})\"\n)\n\n# For spherical harmonics, we need the ECI to body-fixed rotation matrix\n# This rotates from ECI (inertial) to ECEF (Earth-fixed) frame\nR_eci_ecef = bh.rotation_eci_to_ecef(epoch)\n\n# Compute spherical harmonic acceleration (degree 10, order 10)\nn_max = 10\nm_max = 10\naccel_sh = bh.accel_gravity_spherical_harmonics(\n    r_eci, R_eci_ecef, gravity_model, n_max, m_max\n)\n\nprint(f\"\\nSpherical harmonic acceleration (degree {n_max}, order {m_max}):\")\nprint(f\"  ax = {accel_sh[0]:.9f} m/s\u00b2\")\nprint(f\"  ay = {accel_sh[1]:.9f} m/s\u00b2\")\nprint(f\"  az = {accel_sh[2]:.9f} m/s\u00b2\")\n\n# Compute point-mass for comparison\naccel_pm = bh.accel_point_mass_gravity(r_eci, np.array([0.0, 0.0, 0.0]), bh.GM_EARTH)\n\nprint(\"\\nPoint-mass acceleration:\")\nprint(f\"  ax = {accel_pm[0]:.9f} m/s\u00b2\")\nprint(f\"  ay = {accel_pm[1]:.9f} m/s\u00b2\")\nprint(f\"  az = {accel_pm[2]:.9f} m/s\u00b2\")\n\n# Compute difference (perturbation due to non-spherical Earth)\naccel_pert = accel_sh - accel_pm\n\nprint(\"\\nPerturbation (spherical harmonics - point mass):\")\nprint(f\"  \u0394ax = {accel_pert[0]:.9f} m/s\u00b2\")\nprint(f\"  \u0394ay = {accel_pert[1]:.9f} m/s\u00b2\")\nprint(f\"  \u0394az = {accel_pert[2]:.9f} m/s\u00b2\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_pert):.9f} m/s\u00b2\")\n\n# Expected output:\n# Satellite position (ECI, m):\n#   x = 651307.572\n#   y = -668157.599\n#   z = 6811086.322\n\n# Gravity model: GGM05S (max degree 180, max order 180)\n\n# Spherical harmonic acceleration (degree 10, order 10):\n#   ax = -0.794811805 m/s\u00b2\n#   ay = 0.815141691 m/s\u00b2\n#   az = -8.333760910 m/s\u00b2\n\n# Point-mass acceleration:\n#   ax = -0.799028363 m/s\u00b2\n#   ay = 0.819700085 m/s\u00b2\n#   az = -8.355884974 m/s\u00b2\n\n# Perturbation (spherical harmonics - point mass):\n#   \u0394ax = 0.004216558 m/s\u00b2\n#   \u0394ay = -0.004558395 m/s\u00b2\n#   \u0394az = 0.022124064 m/s\u00b2\n#   Magnitude: 0.022978958 m/s\u00b2\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute spherical harmonic gravitational acceleration for an Earth satellite\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch for frame transformations\n    let epoch = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define satellite position in ECI frame (LEO satellite at 500 km altitude)\n    let a = bh::constants::R_EARTH + 500e3; // Semi-major axis (m)\n    let e = 0.001;                          // Eccentricity\n    let i = 97.8;                           // Inclination (deg)\n    let raan = 45.0;                        // RAAN (deg)\n    let argp = 30.0;                        // Argument of perigee (deg)\n    let nu = 60.0;                          // True anomaly (deg)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let r_eci = na::Vector3::new(state_eci[0], state_eci[1], state_eci[2]); // Position vector (m)\n\n    println!(\"Satellite position (ECI, m):\");\n    println!(\"  x = {:.3}\", r_eci[0]);\n    println!(\"  y = {:.3}\", r_eci[1]);\n    println!(\"  z = {:.3}\", r_eci[2]);\n\n    // Load gravity model (GGM05S - degree/order 180)\n    let gravity_model = bh::orbit_dynamics::GravityModel::from_model_type(\n        &amp;bh::orbit_dynamics::GravityModelType::GGM05S\n    ).unwrap();\n    println!(\"\\nGravity model: GGM05S (max degree {}, max order {})\",\n             gravity_model.n_max, gravity_model.m_max);\n\n    // For spherical harmonics, we need the ECI to body-fixed rotation matrix\n    // This rotates from ECI (inertial) to ECEF (Earth-fixed) frame\n    let r_eci_ecef = bh::rotation_eci_to_ecef(epoch);\n\n    // Compute spherical harmonic acceleration (degree 10, order 10)\n    let n_max = 10;\n    let m_max = 10;\n    let accel_sh = bh::orbit_dynamics::accel_gravity_spherical_harmonics(\n        r_eci, r_eci_ecef, &amp;gravity_model, n_max, m_max\n    );\n\n    println!(\"\\nSpherical harmonic acceleration (degree {}, order {}):\", n_max, m_max);\n    println!(\"  ax = {:.9} m/s\u00b2\", accel_sh[0]);\n    println!(\"  ay = {:.9} m/s\u00b2\", accel_sh[1]);\n    println!(\"  az = {:.9} m/s\u00b2\", accel_sh[2]);\n\n    // Compute point-mass for comparison\n    let accel_pm = bh::orbit_dynamics::accel_point_mass_gravity(\n        r_eci, na::Vector3::&lt;f64&gt;::zeros(), bh::constants::GM_EARTH\n    );\n\n    println!(\"\\nPoint-mass acceleration:\");\n    println!(\"  ax = {:.9} m/s\u00b2\", accel_pm[0]);\n    println!(\"  ay = {:.9} m/s\u00b2\", accel_pm[1]);\n    println!(\"  az = {:.9} m/s\u00b2\", accel_pm[2]);\n\n    // Compute difference (perturbation due to non-spherical Earth)\n    let accel_pert = accel_sh - accel_pm;\n\n    println!(\"\\nPerturbation (spherical harmonics - point mass):\");\n    println!(\"  \u0394ax = {:.9} m/s\u00b2\", accel_pert[0]);\n    println!(\"  \u0394ay = {:.9} m/s\u00b2\", accel_pert[1]);\n    println!(\"  \u0394az = {:.9} m/s\u00b2\", accel_pert[2]);\n    println!(\"  Magnitude: {:.9} m/s\u00b2\", accel_pert.norm());\n\n    // Expected output:\n    // Satellite position (ECI, m):\n    //   x = 651307.572\n    //   y = -668157.599\n    //   z = 6811086.322\n\n    // Gravity model: GGM05S (max degree 180, max order 180)\n\n    // Spherical harmonic acceleration (degree 10, order 10):\n    //   ax = -0.794811805 m/s\u00b2\n    //   ay = 0.815141691 m/s\u00b2\n    //   az = -8.333760910 m/s\u00b2\n\n    // Point-mass acceleration:\n    //   ax = -0.799028363 m/s\u00b2\n    //   ay = 0.819700085 m/s\u00b2\n    //   az = -8.355884974 m/s\u00b2\n\n    // Perturbation (spherical harmonics - point mass):\n    //   \u0394ax = 0.004216558 m/s\u00b2\n    //   \u0394ay = -0.004558395 m/s\u00b2\n    //   \u0394az = 0.022124064 m/s\u00b2\n    //   Magnitude: 0.022978958 m/s\u00b2\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/gravity.html#see-also","title":"See Also","text":"<ul> <li>Library API Reference: Gravity</li> <li>Orbital Dynamics Overview</li> <li>Constants: Physical Parameters</li> </ul>"},{"location":"learn/orbital_dynamics/gravity.html#references","title":"References","text":"<p>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Section 3.2: The Geopotential.</p>"},{"location":"learn/orbital_dynamics/relativity.html","title":"Relativistic Effects","text":"<p>While Newtonian mechanics is sufficient for most satellite orbit calculations, general relativistic effects become measurable with modern precision orbit determination systems. These corrections are particularly important for:</p> <ul> <li>Global Navigation Satellite Systems (GPS, Galileo, GLONASS, BeiDou)</li> <li>Fundamental physics experiments in space</li> <li>Ultra-precise orbit determination (cm-level accuracy)</li> <li>Long-term orbit propagation</li> </ul>"},{"location":"learn/orbital_dynamics/relativity.html#physical-basis","title":"Physical Basis","text":"<p>General relativity modifies Newton's law of gravitation by accounting for the curvature of spacetime caused by mass. Mntenbruck &amp; Gill (2000) provide the post-Newtonian correction of the acceleration due to Earth's gravity as:</p> \\[ \\mathbf{a} = -\\frac{GM}{r^2} \\left( \\left( 4\\frac{GM}{c^2r} - \\frac{v^2}{c^2} \\right)\\mathbf{e}_r + 4\\frac{v^2}{c^2}\\left(\\mathbf{e}_r \\cdot \\mathbf{e}_v\\right)\\mathbf{e}_v\\right) \\] <p>where:</p> <ul> <li>\\(GM\\) is Earth's gravitational parameter (m\u00b3/s\u00b2)</li> <li>\\(c\\) is the speed of light (299,792,458 m/s)</li> <li>\\(r\\) is the satellite position magnitude (m)</li> <li>\\(v\\) is the satellite velocity magnitude (m/s)</li> <li>\\(\\mathbf{e}_r = \\frac{\\mathbf{r}}{r}\\) is the radial unit vector</li> <li>\\(\\mathbf{e}_v = \\frac{\\mathbf{v}}{v}\\) is the velocity unit vector</li> </ul>"},{"location":"learn/orbital_dynamics/relativity.html#usage-examples","title":"Usage Examples","text":""},{"location":"learn/orbital_dynamics/relativity.html#computing-relativistic-acceleration","title":"Computing Relativistic Acceleration","text":"<p>Calculate the general relativistic correction to a satellite's acceleration.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define GPS satellite state (MEO orbit where relativity is measurable)\na = bh.R_EARTH + 20180e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\ni = np.radians(55.0)  # Inclination (rad)\nraan = np.radians(30.0)  # RAAN (rad)\nargp = np.radians(45.0)  # Argument of perigee (rad)\nnu = np.radians(90.0)  # True anomaly (rad)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprint(\"GPS Satellite state (ECI):\")\nprint(\n    f\"  Position: [{state[0] / 1e3:.1f}, {state[1] / 1e3:.1f}, {state[2] / 1e3:.1f}] km\"\n)\nprint(\n    f\"  Velocity: [{state[3] / 1e3:.3f}, {state[4] / 1e3:.3f}, {state[5] / 1e3:.3f}] km/s\"\n)\nr_mag = np.linalg.norm(state[0:3])\nv_mag = np.linalg.norm(state[3:6])\nprint(f\"  Altitude: {(r_mag - bh.R_EARTH) / 1e3:.1f} km\")\nprint(f\"  Speed: {v_mag / 1e3:.3f} km/s\")\n\n# Compute relativistic acceleration\naccel_rel = bh.accel_relativity(state)\n\nprint(\"\\nRelativistic acceleration (m/s\u00b2):\")\nprint(f\"  ax = {accel_rel[0]:.15f}\")\nprint(f\"  ay = {accel_rel[1]:.15f}\")\nprint(f\"  az = {accel_rel[2]:.15f}\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_rel):.15e} m/s\u00b2\")\n\n# Compare to Newtonian point-mass gravity\naccel_newton = bh.accel_point_mass_gravity(\n    state[0:3], np.array([0.0, 0.0, 0.0]), bh.GM_EARTH\n)\naccel_newton_mag = np.linalg.norm(accel_newton)\n\nprint(f\"\\nNewtonian gravity magnitude: {accel_newton_mag:.9f} m/s\u00b2\")\nprint(\n    f\"Relativistic/Newtonian ratio: {np.linalg.norm(accel_rel) / accel_newton_mag:.6e}\"\n)\n\n# Estimate accumulated position error if relativity is ignored\n# Using simple approximation: \u0394r \u2248 0.5 * a * t\u00b2\n# For 1 day propagation\none_day = 86400.0  # seconds\npos_error_1day = 0.5 * np.linalg.norm(accel_rel) * one_day**2\n\nprint(\"\\nApproximate position error if relativity ignored:\")\nprint(f\"  After 1 day: {pos_error_1day:.3f} m\")\nprint(f\"  After 1 week: {pos_error_1day * 7:.1f} m\")\n\n# Compare to other perturbations at this altitude\n# J2 magnitude (approximate)\nj2 = 1.08263e-3\naccel_j2_approx = 1.5 * j2 * bh.GM_EARTH * (bh.R_EARTH / r_mag) ** 2 / r_mag**2\n\n# Third-body (Sun, approximate)\naccel_sun_approx = 5e-8  # Typical value for GPS altitude\n\nprint(\"\\nRelative magnitude of perturbations at GPS altitude:\")\nprint(f\"  J2: ~{accel_j2_approx:.6e} m/s\u00b2\")\nprint(f\"  Sun: ~{accel_sun_approx:.6e} m/s\u00b2\")\nprint(f\"  Relativity: {np.linalg.norm(accel_rel):.6e} m/s\u00b2\")\nprint(f\"  Relativity/J2 ratio: {np.linalg.norm(accel_rel) / accel_j2_approx:.6e}\")\n\n# Expected output:\n# GPS Satellite state (ECI):\n#   Position: [-21864.6, -435.7, 15074.0] km\n#   Velocity: [-1.555, -2.730, -2.266] km/s\n#   Altitude: 20182.7 km\n#   Speed: 3.874 km/s\n\n# Relativistic acceleration (m/s\u00b2):\n#   ax = -0.000000000234510\n#   ay = -0.000000000007302\n#   az = 0.000000000158426\n#   Magnitude: 2.831022208577214e-10 m/s\u00b2\n\n# Newtonian gravity magnitude: 0.565009481 m/s\u00b2\n# Relativistic/Newtonian ratio: 5.010575e-10\n\n# Approximate position error if relativity ignored:\n#   After 1 day: 1.057 m\n#   After 1 week: 7.4 m\n\n# Relative magnitude of perturbations at GPS altitude:\n#   J2: ~5.290937e-05 m/s\u00b2\n#   Sun: ~5.000000e-08 m/s\u00b2\n#   Relativity: 2.831022e-10 m/s\u00b2\n#   Relativity/J2 ratio: 5.350701e-06\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute general relativistic correction to satellite acceleration\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define GPS satellite state (MEO orbit where relativity is measurable)\n    let a = bh::constants::R_EARTH + 20180e3; // Semi-major axis (m)\n    let e = 0.01;                             // Eccentricity\n    let i = 55.0_f64.to_radians();            // Inclination (rad)\n    let raan = 30.0_f64.to_radians();         // RAAN (rad)\n    let argp = 45.0_f64.to_radians();         // Argument of perigee (rad)\n    let nu = 90.0_f64.to_radians();           // True anomaly (rad)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Radians);\n\n    println!(\"GPS Satellite state (ECI):\");\n    println!(\"  Position: [{:.1}, {:.1}, {:.1}] km\",\n             state[0] / 1e3, state[1] / 1e3, state[2] / 1e3);\n    println!(\"  Velocity: [{:.3}, {:.3}, {:.3}] km/s\",\n             state[3] / 1e3, state[4] / 1e3, state[5] / 1e3);\n\n    let r = na::Vector3::new(state[0], state[1], state[2]);\n    let v = na::Vector3::new(state[3], state[4], state[5]);\n    let r_mag = r.norm();\n    let v_mag = v.norm();\n\n    println!(\"  Altitude: {:.1} km\", (r_mag - bh::constants::R_EARTH) / 1e3);\n    println!(\"  Speed: {:.3} km/s\", v_mag / 1e3);\n\n    // Compute relativistic acceleration\n    let accel_rel = bh::orbit_dynamics::accel_relativity(state);\n\n    println!(\"\\nRelativistic acceleration (m/s\u00b2):\");\n    println!(\"  ax = {:.15}\", accel_rel[0]);\n    println!(\"  ay = {:.15}\", accel_rel[1]);\n    println!(\"  az = {:.15}\", accel_rel[2]);\n    println!(\"  Magnitude: {:.15e} m/s\u00b2\", accel_rel.norm());\n\n    // Compare to Newtonian point-mass gravity\n    let accel_newton = bh::orbit_dynamics::accel_point_mass_gravity(\n        r, na::Vector3::&lt;f64&gt;::zeros(), bh::constants::GM_EARTH\n    );\n    let accel_newton_mag = accel_newton.norm();\n\n    println!(\"\\nNewtonian gravity magnitude: {:.9} m/s\u00b2\", accel_newton_mag);\n    println!(\"Relativistic/Newtonian ratio: {:.6e}\", accel_rel.norm() / accel_newton_mag);\n\n    // Estimate accumulated position error if relativity is ignored\n    // Using simple approximation: \u0394r \u2248 0.5 * a * t\u00b2\n    // For 1 day propagation\n    let one_day = 86400.0; // seconds\n    let pos_error_1day = 0.5 * accel_rel.norm() * one_day * one_day;\n\n    println!(\"\\nApproximate position error if relativity ignored:\");\n    println!(\"  After 1 day: {:.3} m\", pos_error_1day);\n    println!(\"  After 1 week: {:.1} m\", pos_error_1day * 7.0);\n\n    // Compare to other perturbations at this altitude\n    // J2 magnitude (approximate)\n    let j2 = 1.08263e-3;\n    let accel_j2_approx = 1.5 * j2 * bh::constants::GM_EARTH *\n                          (bh::constants::R_EARTH / r_mag).powi(2) / (r_mag * r_mag);\n\n    // Third-body (Sun, approximate)\n    let accel_sun_approx = 5e-8; // Typical value for GPS altitude\n\n    println!(\"\\nRelative magnitude of perturbations at GPS altitude:\");\n    println!(\"  J2: ~{:.6e} m/s\u00b2\", accel_j2_approx);\n    println!(\"  Sun: ~{:.6e} m/s\u00b2\", accel_sun_approx);\n    println!(\"  Relativity: {:.6e} m/s\u00b2\", accel_rel.norm());\n    println!(\"  Relativity/J2 ratio: {:.6e}\", accel_rel.norm() / accel_j2_approx);\n\n    // Expected output:\n    // GPS Satellite state (ECI):\n    //   Position: [-21864.6, -435.7, 15074.0] km\n    //   Velocity: [-1.555, -2.730, -2.266] km/s\n    //   Altitude: 20182.7 km\n    //   Speed: 3.874 km/s\n\n    // Relativistic acceleration (m/s\u00b2):\n    //   ax = -0.000000000234510\n    //   ay = -0.000000000007302\n    //   az = 0.000000000158426\n    //   Magnitude: 2.831022208577214e-10 m/s\u00b2\n\n    // Newtonian gravity magnitude: 0.565009481 m/s\u00b2\n    // Relativistic/Newtonian ratio: 5.010575e-10\n\n    // Approximate position error if relativity ignored:\n    //   After 1 day: 1.057 m\n    //   After 1 week: 7.4 m\n\n    // Relative magnitude of perturbations at GPS altitude:\n    //   J2: ~5.290937e-05 m/s\u00b2\n    //   Sun: ~5.000000e-08 m/s\u00b2\n    //   Relativity: 2.831022e-10 m/s\u00b2\n    //   Relativity/J2 ratio: 5.350701e-06\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/relativity.html#see-also","title":"See Also","text":"<ul> <li>Library API Reference: Relativity</li> <li>Orbital Dynamics Overview</li> </ul>"},{"location":"learn/orbital_dynamics/relativity.html#references","title":"References","text":"<p>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Section 3.7: Relativistic Effects.</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html","title":"Solar Radiation Pressure","text":"<p>Solar radiation pressure (SRP) is the force exerted by photons emitted by the sun when they strike a satellite's surface. While small compared to gravitational forces, SRP can become a significant perturbations for satellites at higher altitude, particularly for those large solar panels or lightweight structures.</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#physical-principle","title":"Physical Principle","text":"<p>Photons carry momentum, and when they strike a surface, they transfer that momentum. The acceleration due to solar radiation pressure is:</p> \\[ \\mathbf{a}_{SRP} = -P_{\\odot} C_R \\frac{A}{m} \\nu \\frac{\\mathbf{r}_{\\odot}}{|\\mathbf{r}_{\\odot}|} \\] <p>where:</p> <ul> <li>\\(P_{\\odot}\\) is the solar radiation pressure at 1 AU (\u2248 4.56 \u00d7 10\u207b\u2076 N/m\u00b2)</li> <li>\\(C_R\\) is the radiation pressure coefficient (dimensionless, typically 1.0-1.5)</li> <li>\\(A\\) is the effective cross-sectional area perpendicular to Sun (m\u00b2)</li> <li>\\(m\\) is the satellite mass (kg)</li> <li>\\(\\nu\\) is the shadow function (0 = full shadow, 1 = full sunlight)</li> <li>\\(\\mathbf{r}_{\\odot}\\) is the Sun position vector relative to satellite</li> </ul> <p>The pressure varies as \\(1/r^2\\) with distance from the Sun but is essentially constant for Earth-orbiting satellites due to the comparatively small variation in distance around the orbit compared to the Earth-Sun distance.</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#computing-srp-acceleration","title":"Computing SRP Acceleration","text":"<p>Calculate the solar radiation pressure acceleration on a satellite, accounting for Earth's shadow.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create an epoch (summer solstice for interesting Sun geometry)\nepoch = bh.Epoch.from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define satellite position (GEO satellite)\na = bh.R_EARTH + 35786e3  # Semi-major axis (m) - geostationary\ne = 0.0001  # Near-circular\ni = np.radians(0.1)  # Near-equatorial\nraan = np.radians(0.0)  # RAAN (rad)\nargp = np.radians(0.0)  # Argument of perigee (rad)\nnu = np.radians(0.0)  # True anomaly (rad)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nr_sat = state[0:3]  # Position vector (m)\n\nprint(\"Satellite position (ECI, m):\")\nprint(f\"  x = {r_sat[0] / 1e3:.1f} km\")\nprint(f\"  y = {r_sat[1] / 1e3:.1f} km\")\nprint(f\"  z = {r_sat[2] / 1e3:.1f} km\")\nprint(f\"  Altitude: {(np.linalg.norm(r_sat) - bh.R_EARTH) / 1e3:.1f} km\")\n\n# Get Sun position\nr_sun = bh.sun_position(epoch)\n\nprint(\"\\nSun position (ECI, AU):\")\nprint(f\"  x = {r_sun[0] / 1.496e11:.6f} AU\")\nprint(f\"  y = {r_sun[1] / 1.496e11:.6f} AU\")\nprint(f\"  z = {r_sun[2] / 1.496e11:.6f} AU\")\n\n# Eclipse condition - check shadow using both models\nnu_conical = bh.eclipse_conical(r_sat, r_sun)\nnu_cylindrical = bh.eclipse_cylindrical(r_sat, r_sun)\n\nprint(\"\\nEclipse status:\")\nprint(f\"  Conical model: {nu_conical:.6f}\")\nprint(f\"  Cylindrical model: {nu_cylindrical:.6f}\")\n\nif nu_conical == 0.0:\n    print(\"  Status: Full shadow (umbra)\")\nelif nu_conical == 1.0:\n    print(\"  Status: Full sunlight\")\nelse:\n    print(f\"  Status: Penumbra ({nu_conical * 100:.1f}% illuminated)\")\n\n# Define satellite SRP properties\nmass = 1500.0  # kg (typical GEO satellite)\ncr = 1.3  # Radiation pressure coefficient\narea = 20.0  # m\u00b2 (effective area - solar panels + body)\np0 = 4.56e-6  # Solar radiation pressure at 1 AU (N/m\u00b2)\n\nprint(\"\\nSatellite SRP properties:\")\nprint(f\"  Mass: {mass:.1f} kg\")\nprint(f\"  Area: {area:.1f} m\u00b2\")\nprint(f\"  Cr coefficient: {cr:.1f}\")\nprint(f\"  Area/mass ratio: {area / mass:.6f} m\u00b2/kg\")\n\n# Compute solar radiation pressure acceleration\naccel_srp = bh.accel_solar_radiation_pressure(r_sat, r_sun, mass, cr, area, p0)\n\nprint(\"\\nSolar radiation pressure acceleration (ECI, m/s\u00b2):\")\nprint(f\"  ax = {accel_srp[0]:.12f}\")\nprint(f\"  ay = {accel_srp[1]:.12f}\")\nprint(f\"  az = {accel_srp[2]:.12f}\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_srp):.12f} m/s\u00b2\")\n\n# Theoretical maximum (no eclipse)\naccel_max = p0 * cr * area / mass\nprint(f\"\\nTheoretical maximum (full sun): {accel_max:.12f} m/s\u00b2\")\nprint(f\"Actual/Maximum ratio: {np.linalg.norm(accel_srp) / accel_max:.6f}\")\n\n# Compare to other forces at GEO\nr_mag = np.linalg.norm(r_sat)\naccel_gravity = bh.GM_EARTH / r_mag**2\nprint(\"\\nFor comparison at GEO altitude:\")\nprint(f\"  Point-mass gravity: {accel_gravity:.9f} m/s\u00b2\")\nprint(f\"  SRP/Gravity ratio: {np.linalg.norm(accel_srp) / accel_gravity:.2e}\")\n\n# Expected output:\n# Satellite position (ECI, m):\n#   x = 42159.9 km\n#   y = 0.0 km\n#   z = 0.0 km\n#   Altitude: 35781.8 km\n\n# Sun position (ECI, AU):\n#   x = -0.003352 AU\n#   y = 0.932401 AU\n#   z = 0.404245 AU\n\n# Eclipse status:\n#   Conical model: 1.000000\n#   Cylindrical model: 1.000000\n#   Status: Full sunlight\n\n# Satellite SRP properties:\n#   Mass: 1500.0 kg\n#   Area: 20.0 m\u00b2\n#   Cr coefficient: 1.3\n#   Area/mass ratio: 0.013333 m\u00b2/kg\n\n# Solar radiation pressure acceleration (ECI, m/s\u00b2):\n#   ax = 0.000000000274\n#   ay = -0.000000070212\n#   az = -0.000000030441\n#   Magnitude: 0.000000076528 m/s\u00b2\n\n# Theoretical maximum (full sun): 0.000000079040 m/s\u00b2\n# Actual/Maximum ratio: 0.968216\n\n# For comparison at GEO altitude:\n#   Point-mass gravity: 0.224252979 m/s\u00b2\n#   SRP/Gravity ratio: 3.41e-07\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute solar radiation pressure acceleration with Earth shadow\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch (summer solstice for interesting Sun geometry)\n    let epoch = bh::Epoch::from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define satellite position (GEO satellite)\n    let a = bh::constants::R_EARTH + 35786e3; // Semi-major axis (m) - geostationary\n    let e = 0.0001;                           // Near-circular\n    let i = 0.1_f64.to_radians();             // Near-equatorial\n    let raan = 0.0_f64.to_radians();          // RAAN (rad)\n    let argp = 0.0_f64.to_radians();          // Argument of perigee (rad)\n    let nu = 0.0_f64.to_radians();            // True anomaly (rad)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Radians);\n    let r_sat = na::Vector3::new(state[0], state[1], state[2]); // Position vector (m)\n\n    println!(\"Satellite position (ECI, m):\");\n    println!(\"  x = {:.1} km\", r_sat[0] / 1e3);\n    println!(\"  y = {:.1} km\", r_sat[1] / 1e3);\n    println!(\"  z = {:.1} km\", r_sat[2] / 1e3);\n    println!(\"  Altitude: {:.1} km\", (r_sat.norm() - bh::constants::R_EARTH) / 1e3);\n\n    // Get Sun position\n    let r_sun = bh::orbit_dynamics::sun_position(epoch);\n\n    println!(\"\\nSun position (ECI, AU):\");\n    println!(\"  x = {:.6} AU\", r_sun[0] / 1.496e11);\n    println!(\"  y = {:.6} AU\", r_sun[1] / 1.496e11);\n    println!(\"  z = {:.6} AU\", r_sun[2] / 1.496e11);\n\n    // Eclipse condition\n    // For this example, assume full sunlight (no eclipse)\n    // In practice, eclipse_conical() function would be used to check shadow status\n    let nu_eclipse = 1.0;\n\n    println!(\"\\nEclipse factor: {:.6}\", nu_eclipse);\n    println!(\"  Status: Full sunlight (no eclipse)\");\n\n    // Define satellite SRP properties\n    let mass = 1500.0;  // kg (typical GEO satellite)\n    let cr = 1.3;       // Radiation pressure coefficient\n    let area = 20.0;    // m\u00b2 (effective area - solar panels + body)\n    let p0 = 4.56e-6;   // Solar radiation pressure at 1 AU (N/m\u00b2)\n\n    println!(\"\\nSatellite SRP properties:\");\n    println!(\"  Mass: {:.1} kg\", mass);\n    println!(\"  Area: {:.1} m\u00b2\", area);\n    println!(\"  Cr coefficient: {:.1}\", cr);\n    println!(\"  Area/mass ratio: {:.6} m\u00b2/kg\", area / mass);\n\n    // Compute solar radiation pressure acceleration\n    let accel_srp = bh::orbit_dynamics::accel_solar_radiation_pressure(\n        r_sat, r_sun, mass, cr, area, p0\n    );\n\n    println!(\"\\nSolar radiation pressure acceleration (ECI, m/s\u00b2):\");\n    println!(\"  ax = {:.12}\", accel_srp[0]);\n    println!(\"  ay = {:.12}\", accel_srp[1]);\n    println!(\"  az = {:.12}\", accel_srp[2]);\n    println!(\"  Magnitude: {:.12} m/s\u00b2\", accel_srp.norm());\n\n    // Theoretical maximum (no eclipse)\n    let accel_max = p0 * cr * area / mass;\n    println!(\"\\nTheoretical maximum (full sun): {:.12} m/s\u00b2\", accel_max);\n    println!(\"Actual/Maximum ratio: {:.6}\", accel_srp.norm() / accel_max);\n\n    // Compare to other forces at GEO\n    let r_mag = r_sat.norm();\n    let accel_gravity = bh::constants::GM_EARTH / (r_mag * r_mag);\n    println!(\"\\nFor comparison at GEO altitude:\");\n    println!(\"  Point-mass gravity: {:.9} m/s\u00b2\", accel_gravity);\n    println!(\"  SRP/Gravity ratio: {:.2e}\", accel_srp.norm() / accel_gravity);\n\n    // Expected output:\n    // Satellite position (ECI, m):\n    //   x = 42159.9 km\n    //   y = 0.0 km\n    //   z = 0.0 km\n    //   Altitude: 35781.8 km\n\n    // Sun position (ECI, AU):\n    //   x = -0.003352 AU\n    //   y = 0.932401 AU\n    //   z = 0.404245 AU\n\n    // Eclipse status:\n    //   Conical model: 1.000000\n    //   Cylindrical model: 1.000000\n    //   Status: Full sunlight\n\n    // Satellite SRP properties:\n    //   Mass: 1500.0 kg\n    //   Area: 20.0 m\u00b2\n    //   Cr coefficient: 1.3\n    //   Area/mass ratio: 0.013333 m\u00b2/kg\n\n    // Solar radiation pressure acceleration (ECI, m/s\u00b2):\n    //   ax = 0.000000000274\n    //   ay = -0.000000070212\n    //   az = -0.000000030441\n    //   Magnitude: 0.000000076528 m/s\u00b2\n\n    // Theoretical maximum (full sun): 0.000000079040 m/s\u00b2\n    // Actual/Maximum ratio: 0.968216\n\n    // For comparison at GEO altitude:\n    //   Point-mass gravity: 0.224252979 m/s\u00b2\n    //   SRP/Gravity ratio: 3.41e-07\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#earth-eclipse-earth-shadowing","title":"Earth Eclipse (Earth Shadowing)","text":"<p>Satellites in Earth orbit periodically pass through Earth's shadow, where SRP is absent. The amount of light reaching the satellite is modeled using a shadow function \\(\\nu\\) that varies between 0 (full shadow) and 1 (full sunlight). This function accounts for:</p> <ul> <li>Earth's finite size (not a point)</li> <li>Sun's finite angular diameter (not a point source)</li> <li>Atmospheric refraction and absorption</li> </ul> <p>Brahe provides two shadow models with different fidelity levels:</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#conical-penumbral-model","title":"Conical (Penumbral) Model","text":"<p>The conical shadow model accounts for the finite size of both Earth and Sun, modeling the penumbra region. It defines:</p> <ul> <li>Umbra \\(\\left(\\nu = 0\\right)\\): Region of total shadow (Sun completely blocked)</li> <li>Penumbra \\(\\left(0 &lt; \\nu &lt; 1\\right)\\): Region of partial shadow (Sun partially blocked)</li> <li>Sunlight \\(\\left(\\nu = 1\\right)\\): No shadow</li> </ul> <p>This model provides accurate illumination fractions and is implemented in <code>eclipse_conical()</code>.</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#cylindrical-model","title":"Cylindrical Model","text":"<p>The cylindrical shadow model assumes Earth casts a cylindrical shadow parallel to the Sun-Earth line. This is computationally efficient and provides a binary output of \\(\\nu \\in \\{0, 1\\}\\). It does not model the penumbra region. The model is efficient but less accurate for satellites near the shadow boundary.</p> <p>This model is implemented in <code>eclipse_cylindrical()</code>.</p> <p>For many applications, the penumbra region is small enough that the cylindrical model provides sufficient accuracy with improved computational performance.</p>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#eclipse-detection","title":"Eclipse Detection","text":"<p>Determine if a satellite is in Earth's shadow using either the conical or cylindrical model:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define satellite position and get Sun position\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nr_sat = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\n\n# Check eclipse using conical model (accounts for penumbra)\nnu_conical = bh.eclipse_conical(r_sat, r_sun)\nprint(f\"Conical illumination fraction: {nu_conical:.4f}\")\n\n# Check eclipse using cylindrical model (binary: 0 or 1)\nnu_cyl = bh.eclipse_cylindrical(r_sat, r_sun)\nprint(f\"Cylindrical illumination: {nu_cyl:.1f}\")\n\nif nu_conical == 0.0:\n    print(\"Satellite in full shadow (umbra)\")\nelif nu_conical == 1.0:\n    print(\"Satellite in full sunlight\")\nelse:\n    print(f\"Satellite in penumbra ({nu_conical * 100:.1f}% illuminated)\")\n\n# Expected output:\n# Conical illumination fraction: 1.0000\n# Cylindrical illumination: 1.0\n# Satellite in full sunlight\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define satellite position and get Sun position\n    let epc = bh::Epoch::from_date(2024, 1, 1, bh::TimeSystem::UTC);\n    let r_sat = na::Vector3::new(bh::R_EARTH + 400e3, 0.0, 0.0);\n    let r_sun = bh::sun_position(epc);\n\n    // Check eclipse using conical model\n    let nu_conical = bh::eclipse_conical(r_sat, r_sun);\n    println!(\"Conical illumination fraction: {:.4}\", nu_conical);\n\n    // Check eclipse using cylindrical model\n    let nu_cyl = bh::eclipse_cylindrical(r_sat, r_sun);\n    println!(\"Cylindrical illumination: {:.1}\", nu_cyl);\n\n    if nu_conical == 0.0 {\n        println!(\"Satellite in full shadow (umbra)\");\n    } else if nu_conical == 1.0 {\n        println!(\"Satellite in full sunlight\");\n    } else {\n        println!(\"Satellite in penumbra ({:.1}% illuminated)\", nu_conical * 100.0);\n    }\n}\n\n// Expected output:\n// Conical illumination fraction: 1.0000\n// Cylindrical illumination: 1.0\n// Satellite in full sunlight\n</code></pre>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#see-also","title":"See Also","text":"<ul> <li>Library API Reference: Solar Radiation Pressure</li> <li>Third-Body Perturbations - For Sun position calculation</li> <li>Orbital Dynamics Overview</li> </ul>"},{"location":"learn/orbital_dynamics/solar_radiation_pressure.html#references","title":"References","text":"<p>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Section 3.5: Solar Radiation Pressure.</p>"},{"location":"learn/orbital_dynamics/third_body.html","title":"Third-Body Perturbations","text":"<p>Third-body perturbations are gravitational effects caused by celestial bodies other than the primary (Earth). The most significant third bodies affecting Earth satellites are the Sun and Moon, but planetary perturbations can also be important for high-precision applications or long-term orbit evolution.</p>"},{"location":"learn/orbital_dynamics/third_body.html#physical-principle","title":"Physical Principle","text":"<p>The third-body perturbation is not the direct gravitational attraction of the perturbing body on the satellite, but rather the differential acceleration - the difference between the gravitational pull on the satellite and on Earth's center.</p> <p>For a satellite at position \\(\\mathbf{r}\\) and a third body at position \\(\\mathbf{r}_b\\):</p> \\[ \\mathbf{a}_{3} = GM_{b} \\left(\\frac{\\mathbf{r}_b - \\mathbf{r}}{|\\mathbf{r}_b - \\mathbf{r}|^3} - \\frac{\\mathbf{r}_b}{|\\mathbf{r}_b|^3}\\right) \\] <p>where \\(GM_b\\) is the gravitational parameter of the third body.</p>"},{"location":"learn/orbital_dynamics/third_body.html#key-third-bodies","title":"Key Third Bodies","text":""},{"location":"learn/orbital_dynamics/third_body.html#sun","title":"Sun","text":"<p>The Sun is the most massive third body, but its large distance reduces its effect. Solar perturbations are particularly important for:</p> <ul> <li>Geostationary satellites (resonance effects)</li> <li>High eccentricity orbits</li> <li>Long-term orbit evolution</li> </ul> <p>Typical acceleration magnitude: ~10\u207b\u2077 m/s\u00b2 for LEO, increasing with altitude.</p>"},{"location":"learn/orbital_dynamics/third_body.html#moon","title":"Moon","text":"<p>Despite being less massive than the Sun, the Moon's proximity makes it a significant perturber. Lunar perturbations affect:</p> <ul> <li>Medium Earth orbit satellites (especially GPS-like orbits)</li> <li>Geostationary satellites</li> <li>Frozen orbit design</li> </ul> <p>The Moon's acceleration on satellites is comparable to or larger than the Sun's at most altitudes.</p>"},{"location":"learn/orbital_dynamics/third_body.html#planets","title":"Planets","text":"<p>Planetary perturbations (Venus, Jupiter, Mars, etc.) are generally small but can accumulate over long time scales. They become relevant for:</p> <ul> <li>Long-term orbit propagation (years to decades)</li> <li>Precise orbit determination</li> <li>Special resonance conditions</li> </ul>"},{"location":"learn/orbital_dynamics/third_body.html#modeling-approaches","title":"Modeling Approaches","text":"<p>Brahe provides two methods for computing third-body positions and perturbations:</p>"},{"location":"learn/orbital_dynamics/third_body.html#analytical-models","title":"Analytical Models","text":"<p>Simplified analytical expressions provide approximate positions of the Sun and Moon based on time. These models are computationally efficient and suitable for many applications. They also don't require external data files.</p>"},{"location":"learn/orbital_dynamics/third_body.html#de440s-ephemerides","title":"DE440s Ephemerides","text":"<p>For high-precision applications, Brahe supports using JPL's DE440s ephemerides with data provided by NASA JPL's Naviation and Ancillary Information Facility and computations implemented using the excellent Anise library.</p> <p>The Development Ephemeris 440s (DE440s) provides high-precision positions of all major solar system bodies using numerical integration over the time span of 1849 to 2150. They provide meter-level accuracy or better for planetary positions, but require downloading and managing SPICE kernel data files. Brahe generally will download and cache these files automatically on first use.</p>"},{"location":"learn/orbital_dynamics/third_body.html#usage-examples","title":"Usage Examples","text":""},{"location":"learn/orbital_dynamics/third_body.html#sun-and-moon-perturbations","title":"Sun and Moon Perturbations","text":"<p>Compute the combined gravitational acceleration from the Sun and Moon on a satellite.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create an epoch\nepoch = bh.Epoch.from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Define satellite position (GPS-like MEO satellite at ~20,000 km altitude)\na = bh.R_EARTH + 20180e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\ni = 55.0  # Inclination (deg)\nraan = 120.0  # RAAN (deg)\nargp = 45.0  # Argument of perigee (deg)\nnu = 90.0  # True anomaly (deg)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nr_sat = state[0:3]  # Position vector (m)\n\nprint(\"Satellite position (ECI, m):\")\nprint(f\"  x = {r_sat[0] / 1e3:.1f} km\")\nprint(f\"  y = {r_sat[1] / 1e3:.1f} km\")\nprint(f\"  z = {r_sat[2] / 1e3:.1f} km\")\nprint(f\"  Altitude: {(np.linalg.norm(r_sat) - bh.R_EARTH) / 1e3:.1f} km\")\n\n# Compute Sun perturbation using analytical model\naccel_sun = bh.accel_third_body_sun(epoch, r_sat)\n\nprint(\"\\nSun third-body acceleration (analytical):\")\nprint(f\"  ax = {accel_sun[0]:.12f} m/s\u00b2\")\nprint(f\"  ay = {accel_sun[1]:.12f} m/s\u00b2\")\nprint(f\"  az = {accel_sun[2]:.12f} m/s\u00b2\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_sun):.12f} m/s\u00b2\")\n\n# Compute Moon perturbation using analytical model\naccel_moon = bh.accel_third_body_moon(epoch, r_sat)\n\nprint(\"\\nMoon third-body acceleration (analytical):\")\nprint(f\"  ax = {accel_moon[0]:.12f} m/s\u00b2\")\nprint(f\"  ay = {accel_moon[1]:.12f} m/s\u00b2\")\nprint(f\"  az = {accel_moon[2]:.12f} m/s\u00b2\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_moon):.12f} m/s\u00b2\")\n\n# Compute combined Sun + Moon acceleration\naccel_combined = accel_sun + accel_moon\n\nprint(\"\\nCombined Sun + Moon acceleration:\")\nprint(f\"  ax = {accel_combined[0]:.12f} m/s\u00b2\")\nprint(f\"  ay = {accel_combined[1]:.12f} m/s\u00b2\")\nprint(f\"  az = {accel_combined[2]:.12f} m/s\u00b2\")\nprint(f\"  Magnitude: {np.linalg.norm(accel_combined):.12f} m/s\u00b2\")\n\n# Compare Sun vs Moon relative magnitude\nratio = np.linalg.norm(accel_sun) / np.linalg.norm(accel_moon)\nprint(f\"\\nSun/Moon acceleration ratio: {ratio:.3f}\")\n\n# Expected output:\n# Satellite position (ECI, m):\n#   x = 435.7 km\n#   y = -21864.6 km\n#   z = 15074.0 km\n#   Altitude: 20182.7 km\n\n# Sun third-body acceleration (analytical):\n#   ax = -0.000000011195 m/s\u00b2\n#   ay = -0.000000636482 m/s\u00b2\n#   az = -0.000001202965 m/s\u00b2\n#   Magnitude: 0.000001361014 m/s\u00b2\n\n# Moon third-body acceleration (analytical):\n#   ax = -0.000000403111 m/s\u00b2\n#   ay = -0.000000652316 m/s\u00b2\n#   az = -0.000002920304 m/s\u00b2\n#   Magnitude: 0.000003019303 m/s\u00b2\n\n# Combined Sun + Moon acceleration:\n#   ax = -0.000000414306 m/s\u00b2\n#   ay = -0.000001288798 m/s\u00b2\n#   az = -0.000004123269 m/s\u00b2\n#   Magnitude: 0.000004339815 m/s\u00b2\n\n# Sun/Moon acceleration ratio: 0.451\n</code></pre> <pre><code>//! nalgebra = \"0.33\"\n//! ```\n\n//! Compute third-body gravitational perturbations from Sun and Moon\n\n#[allow(unused_imports)]\nuse brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epoch = bh::Epoch::from_datetime(2024, 6, 21, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Define satellite position (GPS-like MEO satellite at ~20,000 km altitude)\n    let a = bh::constants::R_EARTH + 20180e3; // Semi-major axis (m)\n    let e = 0.01;                             // Eccentricity\n    let i = 55.0;                             // Inclination (deg)\n    let raan = 120.0;                         // RAAN (deg)\n    let argp = 45.0;                          // Argument of perigee (deg)\n    let nu = 90.0;                            // True anomaly (deg)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n    let r_sat = na::Vector3::new(state[0], state[1], state[2]); // Position vector (m)\n\n    println!(\"Satellite position (ECI, m):\");\n    println!(\"  x = {:.1} km\", r_sat[0] / 1e3);\n    println!(\"  y = {:.1} km\", r_sat[1] / 1e3);\n    println!(\"  z = {:.1} km\", r_sat[2] / 1e3);\n    println!(\"  Altitude: {:.1} km\", (r_sat.norm() - bh::constants::R_EARTH) / 1e3);\n\n    // Compute Sun perturbation using analytical model\n    let accel_sun = bh::orbit_dynamics::accel_third_body_sun(epoch, r_sat);\n\n    println!(\"\\nSun third-body acceleration (analytical):\");\n    println!(\"  ax = {:.12} m/s\u00b2\", accel_sun[0]);\n    println!(\"  ay = {:.12} m/s\u00b2\", accel_sun[1]);\n    println!(\"  az = {:.12} m/s\u00b2\", accel_sun[2]);\n    println!(\"  Magnitude: {:.12} m/s\u00b2\", accel_sun.norm());\n\n    // Compute Moon perturbation using analytical model\n    let accel_moon = bh::orbit_dynamics::accel_third_body_moon(epoch, r_sat);\n\n    println!(\"\\nMoon third-body acceleration (analytical):\");\n    println!(\"  ax = {:.12} m/s\u00b2\", accel_moon[0]);\n    println!(\"  ay = {:.12} m/s\u00b2\", accel_moon[1]);\n    println!(\"  az = {:.12} m/s\u00b2\", accel_moon[2]);\n    println!(\"  Magnitude: {:.12} m/s\u00b2\", accel_moon.norm());\n\n    // Compute combined Sun + Moon acceleration\n    let accel_combined = accel_sun + accel_moon;\n\n    println!(\"\\nCombined Sun + Moon acceleration:\");\n    println!(\"  ax = {:.12} m/s\u00b2\", accel_combined[0]);\n    println!(\"  ay = {:.12} m/s\u00b2\", accel_combined[1]);\n    println!(\"  az = {:.12} m/s\u00b2\", accel_combined[2]);\n    println!(\"  Magnitude: {:.12} m/s\u00b2\", accel_combined.norm());\n\n    // Compare Sun vs Moon relative magnitude\n    let ratio = accel_sun.norm() / accel_moon.norm();\n    println!(\"\\nSun/Moon acceleration ratio: {:.3}\", ratio);\n\n    // Expected output:\n    // Satellite position (ECI, m):\n    //   x = 435.7 km\n    //   y = -21864.6 km\n    //   z = 15074.0 km\n    //   Altitude: 20182.7 km\n\n    // Sun third-body acceleration (analytical):\n    //   ax = -0.000000011195 m/s\u00b2\n    //   ay = -0.000000636482 m/s\u00b2\n    //   az = -0.000001202965 m/s\u00b2\n    //   Magnitude: 0.000001361014 m/s\u00b2\n\n    // Moon third-body acceleration (analytical):\n    //   ax = -0.000000403111 m/s\u00b2\n    //   ay = -0.000000652316 m/s\u00b2\n    //   az = -0.000002920304 m/s\u00b2\n    //   Magnitude: 0.000003019303 m/s\u00b2\n\n    // Combined Sun + Moon acceleration:\n    //   ax = -0.000000414306 m/s\u00b2\n    //   ay = -0.000001288798 m/s\u00b2\n    //   az = -0.000004123269 m/s\u00b2\n    //   Magnitude: 0.000004339815 m/s\u00b2\n\n    // Sun/Moon acceleration ratio: 0.451\n}\n</code></pre>"},{"location":"learn/orbital_dynamics/third_body.html#see-also","title":"See Also","text":"<ul> <li>Library API Reference: Third-Body</li> <li>Datasets: NAIF - DE440s ephemeris data</li> <li>Orbital Dynamics Overview</li> </ul>"},{"location":"learn/orbital_dynamics/third_body.html#references","title":"References","text":"<p>Montenbruck, O., &amp; Gill, E. (2000). Satellite Orbits: Models, Methods, and Applications. Springer. Section 3.3: Gravitational Perturbations.</p>"},{"location":"learn/orbits/index.html","title":"Orbital Elements","text":"<p>In orbital mechanics, describing the motion of a satellite requires representing its position and velocity at any given time. There are two primary ways to represent an orbit:</p> <ol> <li>Cartesian state vectors - Position and velocity in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code></li> <li>Keplerian orbital elements - Six parameters that describe the orbit's shape, orientation, and the satellite's position within it: <code>[a, e, i, \u03a9, \u03c9, \u03bd]</code></li> </ol> <p>Both representations contain the same information, but each has advantages for different applications. Cartesian states are ideal for numerical propagation and reference frame transformations, while Keplerian elements provide intuitive understanding of orbital characteristics like size, shape, and orientation.</p> <p>The <code>brahe.orbits</code> module provides tools for working with Keplerian orbital elements, computing orbital properties, and handling the Two-Line Element (TLE) format used for distributing satellite orbit information.</p>"},{"location":"learn/orbits/index.html#orbital-representations","title":"Orbital Representations","text":""},{"location":"learn/orbits/index.html#keplerian-elements","title":"Keplerian Elements","text":"<p>Keplerian orbital elements describe an orbit using six parameters:</p> <ul> <li>Semi-major axis (a) - Defines the size of the orbit [meters]</li> <li>Eccentricity (e) - Defines the shape (0 = circular, 0 &lt; e &lt; 1 = elliptical) [dimensionless]</li> <li>Inclination (i) - Angle between orbital plane and equator [radians or degrees]</li> <li>Right Ascension of Ascending Node (\u03a9) - Orientation of the orbital plane [radians or degrees]</li> <li>Argument of Periapsis (\u03c9) - Orientation of the orbit within its plane [radians or degrees]</li> <li>Anomaly - Satellite's position along the orbit [radians or degrees]</li> </ul> <p>In Brahe, Keplerian elements are represented as arrays: <code>[a, e, i, \u03a9, \u03c9, anomaly]</code> where the semi-major axis is in meters and angles are in radians (unless using the <code>AngleFormat</code> enum to specify degrees).</p> <p>The anomaly can be expressed in three forms - true, eccentric, or mean anomaly - each useful for different calculations. See Anomaly Conversions for details.</p> <p>Tip</p> <p>For all functions in the <code>brahe.orbits</code> module, the anomaly is assumed to be the mean anomaly unless otherwise specified.</p>"},{"location":"learn/orbits/index.html#cartesian-states","title":"Cartesian States","text":"<p>Cartesian state vectors represent position and velocity in three-dimensional space: <code>[x, y, z, vx, vy, vz]</code>. In Brahe, position components are in meters and velocity components are in meters per second.</p> <p>Brahe provides functions to convert between Keplerian elements and Cartesian states:</p> <ul> <li><code>state_koe_to_eci()</code> - Convert orbital elements to Cartesian state</li> <li><code>state_eci_to_koe()</code> - Convert Cartesian state to orbital elements</li> </ul> <p>These functions are found in the coordinates module but are essential for working with orbits.</p>"},{"location":"learn/orbits/index.html#topics-in-this-section","title":"Topics in This Section","text":""},{"location":"learn/orbits/index.html#orbital-properties","title":"Orbital Properties","text":"<p>Learn about computing fundamental orbital properties including:</p> <ul> <li>Orbital period and mean motion</li> <li>Semi-major axis from period or mean motion</li> <li>Periapsis and apoapsis distances, altitudes, and velocities</li> <li>Sun-synchronous orbit inclination</li> </ul>"},{"location":"learn/orbits/index.html#anomaly-conversions","title":"Anomaly Conversions","text":"<p>Understand the three types of orbital anomaly and how to convert between them:</p> <ul> <li>True anomaly - Actual angular position from periapsis</li> <li>Eccentric anomaly - Auxiliary angle used in elliptical orbit calculations</li> <li>Mean anomaly - Linearly increasing angle representing average motion</li> </ul>"},{"location":"learn/orbits/index.html#two-line-elements","title":"Two-Line Elements","text":"<p>Work with the TLE format for distributing satellite orbital information:</p> <ul> <li>TLE structure and parsing</li> <li>TLE validation and checksums</li> <li>Extracting orbital elements from TLEs</li> <li>Creating TLEs from Keplerian elements</li> <li>NORAD satellite catalog number conversions</li> </ul>"},{"location":"learn/orbits/index.html#walker-constellations","title":"Walker Constellations","text":"<p>Generate and analyze Walker constellation patterns:</p> <ul> <li>Walker Delta and Walker Star patterns</li> <li>T:P:F notation for constellation design</li> <li>Generating Keplerian, SGP, and numerical propagators</li> <li>Real-world examples (GPS, Galileo, Iridium)</li> </ul>"},{"location":"learn/orbits/index.html#see-also","title":"See Also","text":"<ul> <li>Orbits API Reference - Complete orbital functions documentation</li> <li>Coordinates - Cartesian and Keplerian conversions</li> <li>Orbit Propagation - Propagating orbits over time</li> <li>Physical Constants - Gravitational parameters and radii</li> </ul>"},{"location":"learn/orbits/anomalies.html","title":"True, Eccentric, and Mean Anomaly","text":"<p>This section deals with the conversion between true, eccentric, and mean  anomaly. </p> <p>True anomaly, frequently denoted \\(\\nu\\), is the angular parameter that defines  the position of an object moving along a Keplerian orbit. It is the angle  between the eccentricity vector (vector pointing from the main pericenter to  the periapsis) and the current position of the body in the orbital plane itself.</p> <p>The eccentric anomaly, \\(E\\), is another angular parameter that defines the position  of an object moving along a Keplerian orbit if viewed from the center of the  ellipse. </p> <p>Finally, the mean anomaly, \\(M\\), defines the fraction of an orbital period that has  elapsed since the orbiting object has passed its periapsis. It is the angle  from the pericenter an object moving on a fictitious circular orbit with the  same semi-major axis would have progressed through in the same time as the  body on the true elliptical orbit.</p> <p>Conversion between all types of angular anomaly is possible. However, there is  no known direct conversion between true and mean anomaly. Conversion between the two is  accomplished by transformation through eccentric anomaly.</p>"},{"location":"learn/orbits/anomalies.html#true-and-eccentric-anomaly-conversions","title":"True and Eccentric Anomaly Conversions","text":"<p>To convert from true anomaly to eccentric anomaly, you can use the function  <code>anomaly_eccentric_to_true</code>. To perform the reverse conversion use  <code>anomaly_true_to_eccentric</code>.</p> <p>Eccentric anomaly can be converted to true anomaly by using equations derived using equations  from Vallado<sup>1</sup>. Starting from Equation (2-12) $$ \\sin{\\nu} = \\frac{\\sin{E}\\sqrt{1-e^2}}{1 - e\\cos{E}} $$ can be divided by $$ \\cos{\\nu} =  \\frac{\\cos{E}-e}{1 - e\\cos{E}} $$ and rearrange to get $$ \\nu = \\arctan{\\frac{\\sin{E}\\sqrt{1-e^2}}{\\cos{E}-e}} $$</p> <p>This conversion is what is implemented by <code>anomaly_eccentric_to_true</code>. Similarly, we can derive $$ E = \\arctan{\\frac{\\sin{\\nu}\\sqrt{1-e^2}}{\\cos{\\nu}+e}} $$ which allows for conversion from true anomaly to eccentric anomaly and is implemented in  <code>anomaly_true_to_eccentric</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nnu = 45.0  # Starting true anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to eccentric anomaly\necc_anomaly = bh.anomaly_true_to_eccentric(nu, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"True anomaly:      {nu:.3f} deg\")\nprint(f\"Eccentric anomaly: {ecc_anomaly:.3f} deg\")\n\n# Convert back from eccentric to true anomaly\nnu_2 = bh.anomaly_eccentric_to_true(ecc_anomaly, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Round-trip result: {nu_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(nu - nu_2):.2e} deg\")\n\n# Expected output:\n# True anomaly:      45.000 deg\n# Eccentric anomaly: 44.596 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let nu = 45.0; // Starting true anomaly (degrees)\n    let e = 0.01;  // Eccentricity\n\n    // Convert to eccentric anomaly\n    let ecc_anomaly = bh::orbits::anomaly_true_to_eccentric(nu, e, bh::constants::AngleFormat::Degrees);\n    println!(\"True anomaly:      {:.3} deg\", nu);\n    println!(\"Eccentric anomaly: {:.3} deg\", ecc_anomaly);\n\n    // Convert back from eccentric to true anomaly\n    let nu_2 = bh::orbits::anomaly_eccentric_to_true(ecc_anomaly, e, bh::constants::AngleFormat::Degrees);\n    println!(\"Round-trip result: {:.3} deg\", nu_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (nu - nu_2).abs());\n\n    // Expected output:\n    // True anomaly:      45.000 deg\n    // Eccentric anomaly: 44.596 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_true_eccentric.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of true anomalies (degrees)\nnu = [x for x in range(0, 360)]\n\n# Compute eccentric anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\necc_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    ecc_data[e] = [\n        bh.anomaly_true_to_eccentric(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in nu\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=nu,\n                y=ecc_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"True Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Eccentric Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/anomalies.html#eccentric-and-mean-anomaly-conversions","title":"Eccentric and Mean Anomaly Conversions","text":"<p>To convert from true anomaly to eccentric anomaly, you can use the function <code>anomaly_eccentric_to_mean</code>. To perform the reverse conversion use <code>anomaly_mean_to_eccentric</code>. </p> <p>Conversion from eccentric anomaly to mean anomaly is accomplished by application of Kepler's  equation $$ M = E - e\\sin{E} $$ which is implemented in <code>anomaly_eccentric_to_mean</code>.</p> <p>Converting back from mean anomaly to eccentric anomaly is more challenging. There is no known closed-form solution to convert from mean anomaly to eccentric anomaly.  Instead, we introduce the auxiliary equation $$ f(E) = E - e\\sin(E) - M $$ And treat the problem as numerically solving for the root of \\(f\\) for a given \\(M\\). This iteration  can be accomplished using Newton's method. Starting from an initial guess \\(E_0\\) the value of  \\(E_*\\) can be iteratively updated using $$ E_{i+1} = \\frac{f(E_i)}{f^\\prime(E_i)}= E_i - \\frac{E_i - e\\sin{E_i} - M}{1 - e\\cos{E_i}} $$ This update is performed until a coverage value of $$ |E_{i+1} - E_i| \\leq \\Delta_{\\text{tol}} $$ is reached. The value set as 100 times floating-point machine precision <code>100 * f64::epsilon</code>. This conversion is provided by <code>anomaly_mean_to_eccentric</code>.</p> <p>Warning</p> <p>Because this is a numerical method, convergence is not guaranteed. There is an upper  limit of 10 iterations to reach convergence. Since convergence may not occur the output of  the function is a <code>Result</code>, forcing the user to explicitly handle the case where the algorithm  does not converage.</p> <p>Since Python lacks Rust's same error handling mechanisms, non-convergence will result in a  runtime error.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\necc = 45.0  # Starting eccentric anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to mean anomaly\nmean_anomaly = bh.anomaly_eccentric_to_mean(ecc, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Eccentric anomaly: {ecc:.3f} deg\")\nprint(f\"Mean anomaly:      {mean_anomaly:.3f} deg\")\n\n# Convert back from mean to eccentric anomaly\necc_2 = bh.anomaly_mean_to_eccentric(\n    mean_anomaly, e, angle_format=bh.AngleFormat.DEGREES\n)\nprint(f\"Round-trip result: {ecc_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(ecc - ecc_2):.2e} deg\")\n\n# Expected output:\n# Eccentric anomaly: 45.000 deg\n# Mean anomaly:      44.595 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let ecc = 45.0; // Starting eccentric anomaly (degrees)\n    let e = 0.01;   // Eccentricity\n\n    // Convert to mean anomaly\n    let mean_anomaly = bh::orbits::anomaly_eccentric_to_mean(ecc, e, bh::constants::AngleFormat::Degrees);\n    println!(\"Eccentric anomaly: {:.3} deg\", ecc);\n    println!(\"Mean anomaly:      {:.3} deg\", mean_anomaly);\n\n    // Convert back from mean to eccentric anomaly\n    let ecc_2 = bh::orbits::anomaly_mean_to_eccentric(mean_anomaly, e, bh::constants::AngleFormat::Degrees).unwrap();\n    println!(\"Round-trip result: {:.3} deg\", ecc_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (ecc - ecc_2).abs());\n\n    // Expected output:\n    // Eccentric anomaly: 45.000 deg\n    // Mean anomaly:      44.595 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_eccentric_mean.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of eccentric anomalies (degrees)\necc = [x for x in range(0, 360)]\n\n# Compute mean anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\nmean_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    mean_data[e] = [\n        bh.anomaly_eccentric_to_mean(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in ecc\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=ecc,\n                y=mean_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Eccentric Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Mean Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/anomalies.html#true-and-mean-anomaly-conversions","title":"True and Mean Anomaly Conversions","text":"<p>Methods to convert from true anomaly to mean anomaly are  provided for convenience. These methods simply wrap successive calls to two  <code>anomaly_true_to_mean</code>. To perform the reverse conversion use <code>anomaly_mean_to_true</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nnu = 45.0  # Starting true anomaly (degrees)\ne = 0.01  # Eccentricity\n\n# Convert to mean anomaly\nmean_anomaly = bh.anomaly_true_to_mean(nu, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"True anomaly:      {nu:.3f} deg\")\nprint(f\"Mean anomaly:      {mean_anomaly:.3f} deg\")\n\n# Convert back from mean to true anomaly\nnu_2 = bh.anomaly_mean_to_true(mean_anomaly, e, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Round-trip result: {nu_2:.3f} deg\")\n\n# Verify round-trip accuracy\nprint(f\"Difference:        {abs(nu - nu_2):.2e} deg\")\n\n# Expected output:\n# True anomaly:      45.000 deg\n# Mean anomaly:      44.194 deg\n# Round-trip result: 45.000 deg\n# Difference:        0.00e0 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let nu = 45.0; // Starting true anomaly (degrees)\n    let e = 0.01;  // Eccentricity\n\n    // Convert to mean anomaly\n    let mean_anomaly = bh::orbits::anomaly_true_to_mean(nu, e, bh::constants::AngleFormat::Degrees);\n    println!(\"True anomaly:      {:.3} deg\", nu);\n    println!(\"Mean anomaly:      {:.3} deg\", mean_anomaly);\n\n    // Convert back from mean to true anomaly\n    let nu_2 = bh::orbits::anomaly_mean_to_true(mean_anomaly, e, bh::constants::AngleFormat::Degrees).unwrap();\n    println!(\"Round-trip result: {:.3} deg\", nu_2);\n\n    // Verify round-trip accuracy\n    println!(\"Difference:        {:.2e} deg\", (nu - nu_2).abs());\n\n    // Expected output:\n    // True anomaly:      45.000 deg\n    // Mean anomaly:      44.194 deg\n    // Round-trip result: 45.000 deg\n    // Difference:        0.00e0 deg\n}\n</code></pre> Plot Source fig_anomaly_true_mean.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of true anomalies (degrees)\nnu = [x for x in range(0, 360)]\n\n# Compute mean anomaly for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5, 0.7, 0.9]\nmean_data = {}\nfor e in eccentricities:\n    # Take output mod 360 to wrap from 0 to 360 degrees\n    mean_data[e] = [\n        bh.anomaly_true_to_mean(x, e, angle_format=bh.AngleFormat.DEGREES) % 360\n        for x in nu\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n        colors[\"primary\"],\n        colors[\"secondary\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=nu,\n                y=mean_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"True Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=30,\n        title_text=\"Mean Anomaly (deg)\",\n        range=[0, 360],\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <ol> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010 https://celestrak.com/software/vallado-sw.php \u21a9</p> </li> </ol>"},{"location":"learn/orbits/properties.html","title":"Orbital Properties","text":"<p>The <code>orbits</code> module provides functions to compute essential properties of satellite orbits, including orbital period, mean motion, periapsis/apoapsis characteristics, and specialized orbits like sun-synchronous configurations. These properties are fundamental for mission design, orbit determination, and trajectory analysis.</p> <p>For complete API documentation, see Orbits API Reference.</p>"},{"location":"learn/orbits/properties.html#orbital-period","title":"Orbital Period","text":"<p>The orbital period \\(T\\) of a satellite is the time it takes to complete one full revolution around the central body. It is related to the semi-major axis \\(a\\) and gravitational parameter \\(\\mu\\) by:</p> \\[ T = 2\\pi\\sqrt{\\frac{a^3}{\\mu}} \\] <p>The <code>orbital_period</code> function computes the period for Earth-orbiting objects, while <code>orbital_period_general</code> accepts an explicit gravitational parameter for any celestial body.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m) - LEO orbit at 500 km altitude\n\n# Compute orbital period for Earth orbit (uses GM_EARTH internally)\nperiod_earth = bh.orbital_period(a)\nprint(f\"Orbital period (Earth): {period_earth:.3f} s\")\nprint(f\"Orbital period (Earth): {period_earth / 60:.3f} min\")\n\n# Compute orbital period for general body (explicit GM)\nperiod_general = bh.orbital_period_general(a, bh.GM_EARTH)\nprint(f\"Orbital period (general): {period_general:.3f} s\")\n\n# Verify they match\nprint(f\"Difference: {abs(period_earth - period_general):.2e} s\")\n\n# Example with approximate GEO altitude\na_geo = bh.R_EARTH + 35786e3\nperiod_geo = bh.orbital_period(a_geo)\nprint(f\"\\nGEO orbital period: {period_geo / 3600:.3f} hours\")\n\n# Expected output:\n# Orbital period (Earth): 5676.977 s\n# Orbital period (Earth): 94.616 min\n# Orbital period (general): 5676.977 s\n# Difference: 0.00e0 s\n\n# GEO orbital period: 23.934 hours\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m) - LEO orbit at 500 km altitude\n\n    // Compute orbital period for Earth orbit (uses GM_EARTH internally)\n    let period_earth = bh::orbits::orbital_period(a);\n    println!(\"Orbital period (Earth): {:.3} s\", period_earth);\n    println!(\"Orbital period (Earth): {:.3} min\", period_earth / 60.0);\n\n    // Compute orbital period for general body (explicit GM)\n    let period_general = bh::orbits::orbital_period_general(a, bh::constants::GM_EARTH);\n    println!(\"Orbital period (general): {:.3} s\", period_general);\n\n    // Verify they match\n    println!(\"Difference: {:.2e} s\", (period_earth - period_general).abs());\n\n    // Example with approximate GEO altitude\n    let a_geo = bh::constants::R_EARTH + 35786e3;\n    let period_geo = bh::orbits::orbital_period(a_geo);\n    println!(\"\\nGEO orbital period: {:.3} hours\", period_geo / 3600.0);\n\n    // Expected output:\n    // Orbital period (Earth): 5676.977 s\n    // Orbital period (Earth): 94.616 min\n    // Orbital period (general): 5676.977 s\n    // Difference: 0.00e0 s\n\n    // GEO orbital period: 23.934 hours\n}\n</code></pre> <p>The plot below shows how orbital period and velocity vary with altitude for circular Earth orbits:</p> Plot Source fig_orbital_period.py<pre><code>import os\nimport pathlib\nimport sys\nimport numpy as np\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of altitudes from 0 to 40,000 km in 500 km increments\nalt = np.arange(0, 41000 * 1e3, 500 * 1e3)\n\n# Compute velocity over altitude (km/s)\nvp = [bh.perigee_velocity(bh.R_EARTH + a, 0.0) / 1e3 for a in alt]\n\n# Compute orbital period over altitude (hours)\nperiod = [bh.orbital_period(bh.R_EARTH + a) / 3600 for a in alt]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    # Create subplot with secondary y-axis\n    fig = make_subplots(specs=[[{\"secondary_y\": True}]])\n\n    # Add velocity trace (primary y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=alt / 1e6,\n            y=vp,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n            name=\"Velocity\",\n            showlegend=True,\n        ),\n        secondary_y=False,\n    )\n\n    # Add orbital period trace (secondary y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=alt / 1e6,\n            y=period,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=2),\n            name=\"Orbital Period\",\n            showlegend=True,\n        ),\n        secondary_y=True,\n    )\n\n    # Configure primary x-axis\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=5,\n        title_text=\"Satellite Altitude [1000 km]\",\n        range=[0, 40],\n        showgrid=False,\n    )\n\n    # Configure primary y-axis (velocity)\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=1,\n        title_text=\"Velocity [km/s]\",\n        range=[0, 10],\n        showgrid=False,\n        secondary_y=False,\n    )\n\n    # Configure secondary y-axis (period)\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        tick0=0,\n        dtick=5,\n        title_text=\"Orbital Period [hours]\",\n        range=[0, 30],\n        showgrid=False,\n        secondary_y=True,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/properties.html#from-state-vector","title":"From State Vector","text":"<p>When orbital elements are unknown but you have a Cartesian state vector, <code>orbital_period_from_state</code> computes the period directly from position and velocity:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements for a LEO satellite\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\ni = 97.8  # Inclination (degrees)\nraan = 15.0  # Right ascension of ascending node (degrees)\nargp = 30.0  # Argument of periapsis (degrees)\nnu = 45.0  # True anomaly (degrees)\n\n# Convert to Cartesian state\noe = np.array([a, e, i, raan, argp, nu])\nstate_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\nprint(\"ECI State (position in km, velocity in km/s):\")\nprint(\n    f\"  r = [{state_eci[0] / 1e3:.3f}, {state_eci[1] / 1e3:.3f}, {state_eci[2] / 1e3:.3f}] km\"\n)\nprint(\n    f\"  v = [{state_eci[3] / 1e3:.3f}, {state_eci[4] / 1e3:.3f}, {state_eci[5] / 1e3:.3f}] km/s\"\n)\n\n# Compute orbital period from state vector\nperiod = bh.orbital_period_from_state(state_eci, bh.GM_EARTH)\nprint(f\"\\nOrbital period from state: {period:.3f} s\")\nprint(f\"Orbital period from state: {period / 60:.3f} min\")\n\n# Verify against period computed from semi-major axis\nperiod_from_sma = bh.orbital_period(a)\nprint(f\"\\nOrbital period from SMA: {period_from_sma:.3f} s\")\nprint(f\"Difference: {abs(period - period_from_sma):.2e} s\")\n\n# Expected output:\n# ECI State (position in km, velocity in km/s):\n#   r = [1848.964, -434.937, 6560.411] km\n#   v = [-7.098, -2.173, 1.913] km/s\n\n# Orbital period from state: 5676.977 s\n# Orbital period from state: 94.616 min\n\n# Orbital period from SMA: 5676.977 s\n# Difference: 3.64e-12 s\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements for a LEO satellite\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n    let i = 97.8; // Inclination (degrees)\n    let raan = 15.0; // Right ascension of ascending node (degrees)\n    let argp = 30.0; // Argument of periapsis (degrees)\n    let nu = 45.0; // True anomaly (degrees)\n\n    // Convert to Cartesian state\n    let oe = na::SVector::&lt;f64, 6&gt;::new(a, e, i, raan, argp, nu);\n    let state_eci = bh::state_koe_to_eci(oe, bh::constants::AngleFormat::Degrees);\n\n    println!(\"ECI State (position in km, velocity in km/s):\");\n    println!(\"  r = [{:.3}, {:.3}, {:.3}] km\", state_eci[0]/1e3, state_eci[1]/1e3, state_eci[2]/1e3);\n    println!(\"  v = [{:.3}, {:.3}, {:.3}] km/s\", state_eci[3]/1e3, state_eci[4]/1e3, state_eci[5]/1e3);\n\n    // Compute orbital period from state vector\n    let period = bh::orbits::orbital_period_from_state(&amp;state_eci, bh::constants::GM_EARTH);\n    println!(\"\\nOrbital period from state: {:.3} s\", period);\n    println!(\"Orbital period from state: {:.3} min\", period / 60.0);\n\n    // Verify against period computed from semi-major axis\n    let period_from_sma = bh::orbits::orbital_period(a);\n    println!(\"\\nOrbital period from SMA: {:.3} s\", period_from_sma);\n    println!(\"Difference: {:.2e} s\", (period - period_from_sma).abs());\n\n    // Expected output:\n    // ECI State (position in km, velocity in km/s):\n    // r = [1848.964, -434.937, 6560.411] km\n    // v = [-7.098, -2.173, 1.913] km/s\n\n    // Orbital period from state: 5676.977 s\n    // Orbital period from state: 94.616 min\n\n    // Orbital period from SMA: 5676.977 s\n    // Difference: 3.64e-12 s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#semi-major-axis-from-period","title":"Semi-major Axis from Period","text":"<p>The inverse relationship allows computing semi-major axis when orbital period is known (useful for mission design):</p> \\[ a = \\sqrt[3]{\\frac{\\mu T^2}{4\\pi^2}} \\] PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: LEO satellite with 98-minute period\nperiod_leo = 98 * 60  # 98 minutes in seconds\na_leo = bh.semimajor_axis_from_orbital_period(period_leo)\naltitude_leo = a_leo - bh.R_EARTH\n\nprint(\"LEO Satellite (98 min period):\")\nprint(f\"  Semi-major axis: {a_leo:.3f} m\")\nprint(f\"  Altitude: {altitude_leo / 1e3:.3f} km\")\n\n# Example 2: Geosynchronous orbit (24-hour period)\nperiod_geo = 24 * 3600  # 24 hours in seconds\na_geo = bh.semimajor_axis_from_orbital_period(period_geo)\naltitude_geo = a_geo - bh.R_EARTH\n\nprint(\"\\nGeosynchronous Orbit (24 hour period):\")\nprint(f\"  Semi-major axis: {a_geo:.3f} m\")\nprint(f\"  Altitude: {altitude_geo / 1e3:.3f} km\")\n\n# Example 3: Using general function for Moon orbit\nperiod_moon = 27.3 * 24 * 3600  # 27.3 days in seconds\na_moon = bh.semimajor_axis_from_orbital_period_general(period_moon, bh.GM_EARTH)\n\nprint(\"\\nMoon's orbit (27.3 day period):\")\nprint(f\"  Semi-major axis: {a_moon / 1e3:.3f} km\")\n\n# Verify round-trip conversion\nperiod_verify = bh.orbital_period(a_leo)\nprint(\"\\nRound-trip verification:\")\nprint(f\"  Original period: {period_leo:.3f} s\")\nprint(f\"  Computed period: {period_verify:.3f} s\")\nprint(f\"  Difference: {abs(period_leo - period_verify):.2e} s\")\n\n# Expected output:\n# LEO Satellite (98 min period):\n#   Semi-major axis: 7041160.278 m\n#   Altitude: 663.024 km\n\n# Geosynchronous Orbit (24 hour period):\n#   Semi-major axis: 42241095.664 m\n#   Altitude: 35862.959 km\n\n# Moon's orbit (27.3 day period):\n#   Semi-major axis: 382980.745 km\n\n# Round-trip verification:\n#   Original period: 5880.000 s\n#   Computed period: 5880.000 s\n#   Difference: 8.19e-12 s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: LEO satellite with 98-minute period\n    let period_leo = 98.0 * 60.0; // 98 minutes in seconds\n    let a_leo = bh::orbits::semimajor_axis_from_orbital_period(period_leo);\n    let altitude_leo = a_leo - bh::constants::R_EARTH;\n\n    println!(\"LEO Satellite (98 min period):\");\n    println!(\"  Semi-major axis: {:.3} m\", a_leo);\n    println!(\"  Altitude: {:.3} km\", altitude_leo / 1e3);\n\n    // Example 2: Geosynchronous orbit (24-hour period)\n    let period_geo = 24.0 * 3600.0; // 24 hours in seconds\n    let a_geo = bh::orbits::semimajor_axis_from_orbital_period(period_geo);\n    let altitude_geo = a_geo - bh::constants::R_EARTH;\n\n    println!(\"\\nGeosynchronous Orbit (24 hour period):\");\n    println!(\"  Semi-major axis: {:.3} m\", a_geo);\n    println!(\"  Altitude: {:.3} km\", altitude_geo / 1e3);\n\n    // Example 3: Using general function for Moon orbit\n    let period_moon = 27.3 * 24.0 * 3600.0; // 27.3 days in seconds\n    let a_moon = bh::orbits::semimajor_axis_from_orbital_period_general(period_moon, bh::constants::GM_EARTH);\n\n    println!(\"\\nMoon's orbit (27.3 day period):\");\n    println!(\"  Semi-major axis: {:.3} km\", a_moon / 1e3);\n\n    // Verify round-trip conversion\n    let period_verify = bh::orbits::orbital_period(a_leo);\n    println!(\"\\nRound-trip verification:\");\n    println!(\"  Original period: {:.3} s\", period_leo);\n    println!(\"  Computed period: {:.3} s\", period_verify);\n    println!(\"  Difference: {:.2e} s\", (period_leo - period_verify).abs());\n\n    // Expected output:\n    // LEO Satellite (98 min period):\n    //   Semi-major axis: 7041160.278 m\n    //   Altitude: 663.024 km\n\n    // Geosynchronous Orbit (24 hour period):\n    //   Semi-major axis: 42241095.664 m\n    //   Altitude: 35862.959 km\n\n    // Moon's orbit (27.3 day period):\n    //   Semi-major axis: 382980.745 km\n\n    // Round-trip verification:\n    //   Original period: 5880.000 s\n    //   Computed period: 5880.000 s\n    //   Difference: 8.19e-12 s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#mean-motion","title":"Mean Motion","text":"<p>A satellite's average angular rate over one orbit is its mean motion \\(n\\), calculated from the semi-major axis and gravitational parameter:</p> \\[ n = \\sqrt{\\frac{\\mu}{a^3}} \\] <p>The <code>mean_motion</code> function computes this for Earth-orbiting objects, while <code>mean_motion_general</code> works for any celestial body. Both functions support output in radians or degrees per second via the <code>angle_format</code> parameter.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na_leo = bh.R_EARTH + 500.0e3  # LEO satellite at 500 km altitude\na_geo = bh.R_EARTH + 35786e3  # GEO satellite\n\n# Compute mean motion in radians/s (Earth-specific)\nn_leo_rad = bh.mean_motion(a_leo, bh.AngleFormat.RADIANS)\nn_geo_rad = bh.mean_motion(a_geo, bh.AngleFormat.RADIANS)\n\nprint(\"Mean Motion in radians/second:\")\nprint(f\"  LEO (500 km): {n_leo_rad:.6f} rad/s\")\nprint(f\"  GEO:          {n_geo_rad:.6f} rad/s\")\n\n# Compute mean motion in degrees/s\nn_leo_deg = bh.mean_motion(a_leo, bh.AngleFormat.DEGREES)\nn_geo_deg = bh.mean_motion(a_geo, bh.AngleFormat.DEGREES)\n\nprint(\"\\nMean Motion in degrees/second:\")\nprint(f\"  LEO (500 km): {n_leo_deg:.6f} deg/s\")\nprint(f\"  GEO:          {n_geo_deg:.6f} deg/s\")\n\n# Convert to degrees/day (common unit for TLEs)\nprint(\"\\nMean Motion in degrees/day:\")\nprint(f\"  LEO (500 km): {n_leo_deg * 86400:.3f} deg/day\")\nprint(f\"  GEO:          {n_geo_deg * 86400:.3f} deg/day\")\n\n# Verify using general function\nn_leo_general = bh.mean_motion_general(a_leo, bh.GM_EARTH, bh.AngleFormat.RADIANS)\nprint(f\"\\nVerification (general function): {n_leo_general:.6f} rad/s\")\nprint(f\"Difference: {abs(n_leo_rad - n_leo_general):.2e} rad/s\")\n\n# Expected output:\n# Mean Motion in radians/second:\n#   LEO (500 km): 0.001107 rad/s\n#   GEO:          0.000073 rad/s\n\n# Mean Motion in degrees/second:\n#   LEO (500 km): 0.063414 deg/s\n#   GEO:          0.004178 deg/s\n\n# Mean Motion in degrees/day:\n#   LEO (500 km): 5478.972 deg/day\n#   GEO:          360.986 deg/day\n\n# Verification (general function): 0.001107 rad/s\n# Difference: 0.00e+00 rad/s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a_leo = bh::constants::R_EARTH + 500.0e3; // LEO satellite at 500 km altitude\n    let a_geo = bh::constants::R_EARTH + 35786e3; // GEO satellite\n\n    // Compute mean motion in radians/s (Earth-specific)\n    let n_leo_rad = bh::orbits::mean_motion(a_leo, bh::constants::AngleFormat::Radians);\n    let n_geo_rad = bh::orbits::mean_motion(a_geo, bh::constants::AngleFormat::Radians);\n\n    println!(\"Mean Motion in radians/second:\");\n    println!(\"  LEO (500 km): {:.6} rad/s\", n_leo_rad);\n    println!(\"  GEO:          {:.6} rad/s\", n_geo_rad);\n\n    // Compute mean motion in degrees/s\n    let n_leo_deg = bh::orbits::mean_motion(a_leo, bh::constants::AngleFormat::Degrees);\n    let n_geo_deg = bh::orbits::mean_motion(a_geo, bh::constants::AngleFormat::Degrees);\n\n    println!(\"\\nMean Motion in degrees/second:\");\n    println!(\"  LEO (500 km): {:.6} deg/s\", n_leo_deg);\n    println!(\"  GEO:          {:.6} deg/s\", n_geo_deg);\n\n    // Convert to degrees/day (common unit for TLEs)\n    println!(\"\\nMean Motion in degrees/day:\");\n    println!(\"  LEO (500 km): {:.3} deg/day\", n_leo_deg * 86400.0);\n    println!(\"  GEO:          {:.3} deg/day\", n_geo_deg * 86400.0);\n\n    // Verify using general function\n    let n_leo_general = bh::orbits::mean_motion_general(a_leo, bh::constants::GM_EARTH, bh::constants::AngleFormat::Radians);\n    println!(\"\\nVerification (general function): {:.6} rad/s\", n_leo_general);\n    println!(\"Difference: {:.2e} rad/s\", (n_leo_rad - n_leo_general).abs());\n\n    // Expected output:\n    // Mean Motion in radians/second:\n    //   LEO (500 km): 0.001107 rad/s\n    //   GEO:          0.000073 rad/s\n\n    // Mean Motion in degrees/second:\n    //   LEO (500 km): 0.063414 deg/s\n    //   GEO:          0.004178 deg/s\n\n    // Mean Motion in degrees/day:\n    //   LEO (500 km): 5478.972 deg/day\n    //   GEO:          360.986 deg/day\n\n    // Verification (general function): 0.001107 rad/s\n    // Difference: 0.00e+00 rad/s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#semi-major-axis-from-mean-motion","title":"Semi-major Axis from Mean Motion","text":"<p>Since orbital data formats like TLEs specify mean motion instead of semi-major axis, the inverse computation is essential:</p> \\[ a = \\sqrt[3]{\\frac{\\mu}{n^2}} \\] PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: ISS-like orbit with ~15.5 revolutions per day\nn_iss = 15.5 * 360.0 / 86400.0  # Convert revs/day to deg/s\na_iss = bh.semimajor_axis(n_iss, bh.AngleFormat.DEGREES)\naltitude_iss = a_iss - bh.R_EARTH\n\nprint(\"ISS-like Orbit (15.5 revs/day):\")\nprint(f\"  Mean motion: {n_iss:.6f} deg/s\")\nprint(f\"  Semi-major axis: {a_iss:.3f} m\")\nprint(f\"  Altitude: {altitude_iss / 1e3:.3f} km\")\n\n# Example 2: Geosynchronous orbit (1 revolution per day)\nn_geo = 1.0 * 360.0 / 86400.0  # 1 rev/day in deg/s\na_geo = bh.semimajor_axis(n_geo, bh.AngleFormat.DEGREES)\naltitude_geo = a_geo - bh.R_EARTH\n\nprint(\"\\nGeosynchronous Orbit (1 rev/day):\")\nprint(f\"  Mean motion: {n_geo:.6f} deg/s\")\nprint(f\"  Semi-major axis: {a_geo:.3f} m\")\nprint(f\"  Altitude: {altitude_geo / 1e3:.3f} km\")\n\n# Example 3: Using radians\nn_leo_rad = 0.001  # rad/s\na_leo = bh.semimajor_axis(n_leo_rad, bh.AngleFormat.RADIANS)\n\nprint(\"\\nLEO from radians/s:\")\nprint(f\"  Mean motion: {n_leo_rad:.6f} rad/s\")\nprint(f\"  Semi-major axis: {a_leo:.3f} m\")\nprint(f\"  Altitude: {(a_leo - bh.R_EARTH) / 1e3:.3f} km\")\n\n# Verify round-trip conversion\nn_verify = bh.mean_motion(a_iss, bh.AngleFormat.DEGREES)\nprint(\"\\nRound-trip verification:\")\nprint(f\"  Original mean motion: {n_iss:.6f} deg/s\")\nprint(f\"  Computed mean motion: {n_verify:.6f} deg/s\")\nprint(f\"  Difference: {abs(n_iss - n_verify):.2e} deg/s\")\n\n# Expected output:\n# ISS-like Orbit (15.5 revs/day):\n#   Mean motion: 0.064583 deg/s\n#   Semi-major axis: 6794863.068 m\n#   Altitude: 416.727 km\n\n# Geosynchronous Orbit (1 rev/day):\n#   Mean motion: 0.004167 deg/s\n#   Semi-major axis: 42241095.664 m\n#   Altitude: 35862.959 km\n\n# LEO from radians/s:\n#   Mean motion: 0.001000 rad/s\n#   Semi-major axis: 7359459.593 m\n#   Altitude: 981.323 km\n\n# Round-trip verification:\n#   Original mean motion: 0.064583 deg/s\n#   Computed mean motion: 0.064583 deg/s\n#   Difference: 9.71e-17 deg/s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: ISS-like orbit with ~15.5 revolutions per day\n    let n_iss = 15.5 * 360.0 / 86400.0; // Convert revs/day to deg/s\n    let a_iss = bh::orbits::semimajor_axis(n_iss, bh::constants::AngleFormat::Degrees);\n    let altitude_iss = a_iss - bh::constants::R_EARTH;\n\n    println!(\"ISS-like Orbit (15.5 revs/day):\");\n    println!(\"  Mean motion: {:.6} deg/s\", n_iss);\n    println!(\"  Semi-major axis: {:.3} m\", a_iss);\n    println!(\"  Altitude: {:.3} km\", altitude_iss / 1e3);\n\n    // Example 2: Geosynchronous orbit (1 revolution per day)\n    let n_geo = 1.0 * 360.0 / 86400.0; // 1 rev/day in deg/s\n    let a_geo = bh::orbits::semimajor_axis(n_geo, bh::constants::AngleFormat::Degrees);\n    let altitude_geo = a_geo - bh::constants::R_EARTH;\n\n    println!(\"\\nGeosynchronous Orbit (1 rev/day):\");\n    println!(\"  Mean motion: {:.6} deg/s\", n_geo);\n    println!(\"  Semi-major axis: {:.3} m\", a_geo);\n    println!(\"  Altitude: {:.3} km\", altitude_geo / 1e3);\n\n    // Example 3: Using radians\n    let n_leo_rad = 0.001; // rad/s\n    let a_leo = bh::orbits::semimajor_axis(n_leo_rad, bh::constants::AngleFormat::Radians);\n\n    println!(\"\\nLEO from radians/s:\");\n    println!(\"  Mean motion: {:.6} rad/s\", n_leo_rad);\n    println!(\"  Semi-major axis: {:.3} m\", a_leo);\n    println!(\"  Altitude: {:.3} km\", (a_leo - bh::constants::R_EARTH) / 1e3);\n\n    // Verify round-trip conversion\n    let n_verify = bh::orbits::mean_motion(a_iss, bh::constants::AngleFormat::Degrees);\n    println!(\"\\nRound-trip verification:\");\n    println!(\"  Original mean motion: {:.6} deg/s\", n_iss);\n    println!(\"  Computed mean motion: {:.6} deg/s\", n_verify);\n    println!(\"  Difference: {:.2e} deg/s\", (n_iss - n_verify).abs());\n\n    // Expected output:\n    // ISS-like Orbit (15.5 revs/day):\n    //   Mean motion: 0.064583 deg/s\n    //   Semi-major axis: 6794863.068 m\n    //   Altitude: 416.727 km\n\n    // Geosynchronous Orbit (1 rev/day):\n    //   Mean motion: 0.004167 deg/s\n    //   Semi-major axis: 42241095.664 m\n    //   Altitude: 35862.959 km\n\n    // LEO from radians/s:\n    //   Mean motion: 0.001000 rad/s\n    //   Semi-major axis: 7359459.593 m\n    //   Altitude: 981.323 km\n\n    // Round-trip verification:\n    //   Original mean motion: 0.064583 deg/s\n    //   Computed mean motion: 0.064583 deg/s\n    //   Difference: 9.71e-17 deg/s\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#periapsis-properties","title":"Periapsis Properties","text":"<p>The periapsis is the point of closest approach to the central body, where orbital velocity is greatest.</p> Info <p>The word periapsis is formed by combination of the Greek words \"peri-\" (meaning around, about) and \"apsis\" (meaning \"arch or vault\"). An apsis is the farthest or nearest point in the orbit of a planetary body about its primary body.</p> <p>Therefore periapsis is the point of closest approach of the orbiting body with respect to its central body. The suffix can be modified to indicate the closest approach to a specific celestial body: perigee for Earth, perihelion for the Sun.</p> <p>Brahe provides functions to compute periapsis velocity, distance, and altitude based on orbital elements.</p>"},{"location":"learn/orbits/properties.html#velocity","title":"Velocity","text":"<p>The periapsis velocity is given by:</p> \\[ v_{p} = \\sqrt{\\frac{\\mu}{a}}\\sqrt{\\frac{1+e}{1-e}} \\] <p>where \\(\\mu\\) is the gravitational parameter, \\(a\\) is the semi-major axis, and \\(e\\) is the eccentricity.</p>"},{"location":"learn/orbits/properties.html#distance","title":"Distance","text":"<p>The periapsis distance from the center of the central body is (from Vallado<sup>1</sup> Equation 2-75):</p> \\[ r_p = \\frac{a(1-e^2)}{1+e} = a(1-e) \\]"},{"location":"learn/orbits/properties.html#altitude","title":"Altitude","text":"<p>The periapsis altitude is the height above the surface of the central body:</p> \\[ h_p = r_p - R_{body} = a(1-e) - R_{body} \\] <p>where \\(R_{body}\\) is the radius of the central body. For Earth orbits, the <code>perigee_altitude</code> function provides a convenient wrapper using \\(R_{\\oplus}\\).</p>"},{"location":"learn/orbits/properties.html#code-example","title":"Code Example","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\n\n# Compute periapsis velocity (generic)\nperiapsis_velocity = bh.periapsis_velocity(a, e, gm=bh.GM_EARTH)\nprint(f\"Periapsis velocity: {periapsis_velocity:.3f} m/s\")\n\n# Compute as a perigee velocity (Earth-specific)\nperigee_velocity = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity:   {perigee_velocity:.3f} m/s\")\n\n# Compute periapsis distance\nperiapsis_distance = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {periapsis_distance / 1e3:.3f} km\")\n\n# Compute periapsis altitude (generic)\nperiapsis_altitude = bh.periapsis_altitude(a, e, r_body=bh.R_EARTH)\nprint(f\"Periapsis altitude: {periapsis_altitude / 1e3:.3f} km\")\n\n# Compute as a perigee altitude (Earth-specific)\nperigee_altitude = bh.perigee_altitude(a, e)\nprint(f\"Perigee altitude:   {perigee_altitude / 1e3:.3f} km\")\n\n# Expected output:\n# Periapsis velocity: 7689.119 m/s\n# Perigee velocity:   7689.119 m/s\n# Periapsis distance: 6809.355 km\n# Periapsis altitude: 431.219 km\n# Perigee altitude:   431.219 km\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n\n    // Compute periapsis velocity (generic)\n    let periapsis_velocity = bh::orbits::periapsis_velocity(a, e, bh::constants::GM_EARTH);\n    println!(\"Periapsis velocity: {:.3} m/s\", periapsis_velocity);\n\n    // Compute as a perigee velocity (Earth-specific)\n    let perigee_velocity = bh::orbits::perigee_velocity(a, e);\n    println!(\"Perigee velocity:   {:.3} m/s\", perigee_velocity);\n\n    // Compute periapsis distance\n    let periapsis_distance = bh::orbits::periapsis_distance(a, e);\n    println!(\"Periapsis distance: {:.3} km\", periapsis_distance / 1e3);\n\n    // Compute periapsis altitude (generic)\n    let periapsis_altitude = bh::orbits::periapsis_altitude(a, e, bh::constants::R_EARTH);\n    println!(\"Periapsis altitude: {:.3} km\", periapsis_altitude / 1e3);\n\n    // Compute as a perigee altitude (Earth-specific)\n    let perigee_altitude = bh::orbits::perigee_altitude(a, e);\n    println!(\"Perigee altitude:   {:.3} km\", perigee_altitude / 1e3);\n\n    // Expected output:\n    // Periapsis velocity: 7689.119 m/s\n    // Perigee velocity:   7689.119 m/s\n    // Periapsis distance: 6809.355 km\n    // Periapsis altitude: 431.219 km\n    // Perigee altitude:   431.219 km\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#apoapsis-properties","title":"Apoapsis Properties","text":"<p>The apoapsis is the farthest point from the central body, where orbital velocity is lowest.</p> Info <p>The word apoapsis is formed by combination of the Greek words \"apo-\" (meaning away from, separate, or apart from) and \"apsis\".</p> <p>Therefore apoapsis is the farthest point of an orbiting body with respect to its central body. The suffix can be modified to indicate the farthest point from a specific celestial body: apogee for Earth, aphelion for the Sun.</p> <p>Brahe provides functions to compute apoapsis velocity, distance, and altitude based on orbital elements.</p> <p>Warning</p> <p>Apoapsis position, velocity, and altitude are only defined for elliptic and circular orbits. For parabolic and hyperbolic orbits, these quantities are undefined.</p>"},{"location":"learn/orbits/properties.html#velocity_1","title":"Velocity","text":"<p>The apoapsis velocity is given by:</p> \\[ v_{a} = \\sqrt{\\frac{\\mu}{a}}\\sqrt{\\frac{1-e}{1+e}} \\]"},{"location":"learn/orbits/properties.html#distance_1","title":"Distance","text":"<p>The apoapsis distance from the center of the central body is:</p> \\[ r_a = \\frac{a(1-e^2)}{1-e} = a(1+e) \\]"},{"location":"learn/orbits/properties.html#altitude_1","title":"Altitude","text":"<p>The apoapsis altitude is the height above the surface of the central body:</p> \\[ h_a = r_a - R_{body} = a(1+e) - R_{body} \\] <p>where \\(R_{body}\\) is the radius of the central body. For Earth orbits, the <code>apogee_altitude</code> function provides a convenient wrapper using \\(R_{\\oplus}\\).</p>"},{"location":"learn/orbits/properties.html#code-example_1","title":"Code Example","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Define orbit parameters\na = bh.R_EARTH + 500.0e3  # Semi-major axis (m)\ne = 0.01  # Eccentricity\n\n# Compute apoapsis velocity (generic)\napoapsis_velocity = bh.apoapsis_velocity(a, e, gm=bh.GM_EARTH)\nprint(f\"Apoapsis velocity: {apoapsis_velocity:.3f} m/s\")\n\n# Compute as an apogee velocity (Earth-specific)\napogee_velocity = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity:   {apogee_velocity:.3f} m/s\")\n\n# Compute apoapsis distance\napoapsis_distance = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {apoapsis_distance / 1e3:.3f} km\")\n\n# Compute apoapsis altitude (generic)\napoapsis_altitude = bh.apoapsis_altitude(a, e, r_body=bh.R_EARTH)\nprint(f\"Apoapsis altitude: {apoapsis_altitude / 1e3:.3f} km\")\n\n# Compute as an apogee altitude (Earth-specific)\napogee_altitude = bh.apogee_altitude(a, e)\nprint(f\"Apogee altitude:   {apogee_altitude / 1e3:.3f} km\")\n\n# Expected output:\n# Apoapsis velocity: 7536.859 m/s\n# Apogee velocity:   7536.859 m/s\n# Apoapsis distance: 6946.918 km\n# Apoapsis altitude: 568.781 km\n# Apogee altitude:   568.781 km\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbit parameters\n    let a = bh::constants::R_EARTH + 500.0e3; // Semi-major axis (m)\n    let e = 0.01; // Eccentricity\n\n    // Compute apoapsis velocity (generic)\n    let apoapsis_velocity = bh::orbits::apoapsis_velocity(a, e, bh::constants::GM_EARTH);\n    println!(\"Apoapsis velocity: {:.3} m/s\", apoapsis_velocity);\n\n    // Compute as an apogee velocity (Earth-specific)\n    let apogee_velocity = bh::orbits::apogee_velocity(a, e);\n    println!(\"Apogee velocity:   {:.3} m/s\", apogee_velocity);\n\n    // Compute apoapsis distance\n    let apoapsis_distance = bh::orbits::apoapsis_distance(a, e);\n    println!(\"Apoapsis distance: {:.3} km\", apoapsis_distance / 1e3);\n\n    // Compute apoapsis altitude (generic)\n    let apoapsis_altitude = bh::orbits::apoapsis_altitude(a, e, bh::constants::R_EARTH);\n    println!(\"Apoapsis altitude: {:.3} km\", apoapsis_altitude / 1e3);\n\n    // Compute as an apogee altitude (Earth-specific)\n    let apogee_altitude = bh::orbits::apogee_altitude(a, e);\n    println!(\"Apogee altitude:   {:.3} km\", apogee_altitude / 1e3);\n\n    // Expected output:\n    // Apoapsis velocity: 7536.859 m/s\n    // Apogee velocity:   7536.859 m/s\n    // Apoapsis distance: 6946.918 km\n    // Apoapsis altitude: 568.781 km\n    // Apogee altitude:   568.781 km\n}\n</code></pre>"},{"location":"learn/orbits/properties.html#sun-synchronous-inclination","title":"Sun-Synchronous Inclination","text":"<p>A sun-synchronous orbit maintains a constant angle relative to the Sun by matching its nodal precession rate to Earth's annual revolution. The right ascension of the ascending node (\\(\\Omega\\)) advances at the same rate as the Sun's apparent motion: approximately 0.9856\u00b0/day. This configuration is highly valuable for Earth observation satellites requiring consistent illumination conditions\u2014a sun-synchronous satellite crosses the equator at the same local time on each pass (e.g., always at 2 PM).</p> <p>Earth's oblateness, characterized by the \\(J_2\\) zonal harmonic, causes secular drift in \\(\\Omega\\):</p> \\[ \\dot{\\Omega} = -\\frac{3nR^2_EJ_2}{2a^2(1-e^2)^2}\\cos{i} \\] <p>For sun-synchronicity, this must equal:</p> \\[ \\dot{\\Omega}_{ss} = \\frac{360\u00b0}{1 \\text{ year}} = 0.9856473598\u00b0/\\text{day} \\] <p>Solving for inclination as a function of semi-major axis and eccentricity:</p> \\[ i = \\arccos{\\left(-\\frac{2a^{7/2}\\dot{\\Omega}_{ss}(1-e^2)^2}{3R^2_EJ_2\\sqrt{\\mu}}\\right)} \\] <p>The <code>sun_synchronous_inclination</code> function computes this required inclination:</p> PythonRust <pre><code>\"\"\"\n\nimport brahe as bh\n\nbh.initialize_eop()\n\n# Example 1: Typical sun-synchronous LEO at 800 km altitude\na_leo = bh.R_EARTH + 800e3  # Semi-major axis\ne_leo = 0.0  # Circular orbit\n\ninc_leo_deg = bh.sun_synchronous_inclination(\n    a_leo, e_leo, angle_format=bh.AngleFormat.DEGREES\n)\ninc_leo_rad = bh.sun_synchronous_inclination(\n    a_leo, e_leo, angle_format=bh.AngleFormat.RADIANS\n)\n\nprint(\"Sun-synchronous LEO (800 km, circular):\")\nprint(f\"  Inclination: {inc_leo_deg:.3f} degrees\")\nprint(f\"  Inclination: {inc_leo_rad:.6f} radians\")\n\n# Example 2: Different altitudes\naltitudes = [500, 600, 700, 800, 900, 1000]  # km\nprint(\"\\nSun-synchronous inclination vs altitude (circular orbits):\")\nfor alt_km in altitudes:\n    a = bh.R_EARTH + alt_km * 1e3\n    inc = bh.sun_synchronous_inclination(a, 0.0, angle_format=bh.AngleFormat.DEGREES)\n    print(f\"  {alt_km:4d} km: {inc:.3f} deg\")\n\n# Example 3: Effect of eccentricity\na_fixed = bh.R_EARTH + 700e3\neccentricities = [0.0, 0.001, 0.005, 0.01, 0.02]\n\nprint(\"\\nSun-synchronous inclination vs eccentricity (700 km orbit):\")\nfor e in eccentricities:\n    inc = bh.sun_synchronous_inclination(\n        a_fixed, e, angle_format=bh.AngleFormat.DEGREES\n    )\n    print(f\"  e = {e:.3f}: {inc:.3f} deg\")\n\n# Example 4: Practical mission example (Landsat-like)\na_landsat = bh.R_EARTH + 705e3\ne_landsat = 0.0001\ninc_landsat = bh.sun_synchronous_inclination(\n    a_landsat, e_landsat, angle_format=bh.AngleFormat.DEGREES\n)\n\nprint(\"\\nLandsat-like orbit (705 km, nearly circular):\")\nprint(f\"  Inclination: {inc_landsat:.3f} deg\")\nprint(f\"  Period: {bh.orbital_period(a_landsat) / 60:.3f} min\")\n\n# Expected output:\n# Sun-synchronous LEO (800 km, circular):\n#   Inclination: 98.603 degrees\n#   Inclination: 1.720948 radians\n\n# Sun-synchronous inclination vs altitude (circular orbits):\n#    500 km: 97.402 deg\n#    600 km: 97.788 deg\n#    700 km: 98.188 deg\n#    800 km: 98.603 deg\n#    900 km: 99.033 deg\n#   1000 km: 99.479 deg\n\n# Sun-synchronous inclination vs eccentricity (700 km orbit):\n#   e = 0.000: 98.188 deg\n#   e = 0.001: 98.188 deg\n#   e = 0.005: 98.187 deg\n#   e = 0.010: 98.186 deg\n#   e = 0.020: 98.181 deg\n\n# Landsat-like orbit (705 km, nearly circular):\n#   Inclination: 98.208 deg\n#   Period: 98.878 min\n</code></pre> <pre><code>#[allow(unused_imports)]\nuse brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Example 1: Typical sun-synchronous LEO at 800 km altitude\n    let a_leo = bh::constants::R_EARTH + 800e3; // Semi-major axis\n    let e_leo = 0.0; // Circular orbit\n\n    let inc_leo_deg = bh::orbits::sun_synchronous_inclination(a_leo, e_leo, bh::constants::AngleFormat::Degrees);\n    let inc_leo_rad = bh::orbits::sun_synchronous_inclination(a_leo, e_leo, bh::constants::AngleFormat::Radians);\n\n    println!(\"Sun-synchronous LEO (800 km, circular):\");\n    println!(\"  Inclination: {:.3} degrees\", inc_leo_deg);\n    println!(\"  Inclination: {:.6} radians\", inc_leo_rad);\n\n    // Example 2: Different altitudes\n    let altitudes = [500.0, 600.0, 700.0, 800.0, 900.0, 1000.0]; // km\n    println!(\"\\nSun-synchronous inclination vs altitude (circular orbits):\");\n    for alt_km in altitudes.iter() {\n        let a = bh::constants::R_EARTH + alt_km * 1e3;\n        let inc = bh::orbits::sun_synchronous_inclination(a, 0.0, bh::constants::AngleFormat::Degrees);\n        println!(\"  {:4} km: {:.3} deg\", *alt_km as i32, inc);\n    }\n\n    // Example 3: Effect of eccentricity\n    let a_fixed = bh::constants::R_EARTH + 700e3;\n    let eccentricities = [0.0, 0.001, 0.005, 0.01, 0.02];\n\n    println!(\"\\nSun-synchronous inclination vs eccentricity (700 km orbit):\");\n    for e in eccentricities.iter() {\n        let inc = bh::orbits::sun_synchronous_inclination(a_fixed, *e, bh::constants::AngleFormat::Degrees);\n        println!(\"  e = {:.3}: {:.3} deg\", e, inc);\n    }\n\n    // Example 4: Practical mission example (Landsat-like)\n    let a_landsat = bh::constants::R_EARTH + 705e3;\n    let e_landsat = 0.0001;\n    let inc_landsat = bh::orbits::sun_synchronous_inclination(a_landsat, e_landsat, bh::constants::AngleFormat::Degrees);\n\n    println!(\"\\nLandsat-like orbit (705 km, nearly circular):\");\n    println!(\"  Inclination: {:.3} deg\", inc_landsat);\n    println!(\"  Period: {:.3} min\", bh::orbits::orbital_period(a_landsat) / 60.0);\n\n    // Expected output:\n    // Sun-synchronous LEO (800 km, circular):\n    //   Inclination: 98.603 degrees\n    //   Inclination: 1.720948 radians\n\n    // Sun-synchronous inclination vs altitude (circular orbits):\n    //    500 km: 97.402 deg\n    //    600 km: 97.788 deg\n    //    700 km: 98.188 deg\n    //    800 km: 98.603 deg\n    //    900 km: 99.033 deg\n    //   1000 km: 99.479 deg\n\n    // Sun-synchronous inclination vs eccentricity (700 km orbit):\n    //   e = 0.000: 98.188 deg\n    //   e = 0.001: 98.188 deg\n    //   e = 0.005: 98.187 deg\n    //   e = 0.010: 98.186 deg\n    //   e = 0.020: 98.181 deg\n\n    // Landsat-like orbit (705 km, nearly circular):\n    //   Inclination: 98.208 deg\n    //   Period: 98.878 min\n}\n</code></pre> <p>The plot below shows how the required inclination varies with altitude for sun-synchronous orbits:</p> Plot Source fig_sun_synchronous_inclination.py<pre><code>import os\nimport pathlib\nimport sys\nimport numpy as np\nimport plotly.graph_objects as go\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\n\n# Generate range of altitudes from 300 to 1000 km in 1 km increments\nalt = np.arange(300e3, 1000e3, 1e3)\n\n# Compute sun-synchronous inclination for range of eccentricities\neccentricities = [0.0, 0.1, 0.3, 0.5]\nssi_data = {}\nfor e in eccentricities:\n    ssi_data[e] = [\n        bh.sun_synchronous_inclination(\n            bh.R_EARTH + a, e, angle_format=bh.AngleFormat.DEGREES\n        )\n        for a in alt\n    ]\n\n# Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Color palette for different eccentricities\n    color_palette = [\n        colors[\"primary\"],\n        colors[\"secondary\"],\n        colors[\"accent\"],\n        colors[\"error\"],\n    ]\n\n    # Add traces for each eccentricity\n    for i, e in enumerate(eccentricities):\n        fig.add_trace(\n            go.Scatter(\n                x=alt / 1e3,\n                y=ssi_data[e],\n                mode=\"lines\",\n                line=dict(color=color_palette[i % len(color_palette)], width=2),\n                name=f\"e = {e:.1f}\",\n                showlegend=True,\n            )\n        )\n\n    # Configure axes\n    fig.update_xaxes(\n        tickmode=\"linear\",\n        tick0=300,\n        dtick=100,\n        title_text=\"Satellite Altitude [km]\",\n        range=[300, 1000],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"linear\",\n        title_text=\"Inclination [deg]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>Most sun-synchronous Earth observation missions operate at altitudes between 500-1000 km with near-zero eccentricity. The launch provider selects the precise inclination based on the above equation to achieve the desired sun-synchronous behavior.</p>"},{"location":"learn/orbits/properties.html#see-also","title":"See Also","text":"<ul> <li>Orbits API Reference - Complete Python API documentation</li> <li>Anomaly Conversions - Converting between true, eccentric, and mean anomaly</li> </ul> <ol> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/orbits/two_line_elements.html","title":"Two-Line Elements (TLE)","text":"<p>Two-Line Element sets (TLEs) are a standardized format for representing satellite orbital data. Originally developed by NORAD (North American Aerospace Defense Command), TLEs encode an epoch, Keplerian orbital elements, and additional parameters needed for SGP4/SDP4 propagation into two 69-character ASCII lines.</p> <p>An example of a TLE set for the International Space Station (ISS) is:</p> <pre><code>1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\n2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\n</code></pre> <p>TLEs are still widely used for satellite tracking and orbit prediction, distributed by organizations like CelesTrak and Space-Track.</p> <p>For additional information on the TLE format and field definitions, see the CelesTrak TLE documentation or the Wikipedia TLE article.</p> <p>For complete API documentation, see the TLE reference.</p> <p>TLE Accuracy Limitations</p> <p>TLEs are designed for near-Earth satellites and have limited accuracy due to simplifications in the SGP4/SDP4 models. They ARE NOT suitable for high-precision orbit determination or long-term predictions.</p> <p>NORAID ID Exhaustion</p> <p>TLEs were originally designed for a maximum of 99,999 cataloged objects. However with the rise of mega-constellations and recent anti-satellite tests by Russia and China, the number of tracked objects is rapidly approaching this limit. </p> <p>The Alpha-5 NORAD ID format extends the range by using letters A-Z (excluding I and O) as the leading character, allowing for up to 339,999 objects. This is a temporary solution however, and generally organizations should plan to transition to using formats like General Perturbations (GP) elements, CCSDS Orbit Ephemeris Messages (OEM), or other modern representations.</p> <p>A common variant of TLEs is the Three-Line Element set (3LE), which adds a title line above the standard two lines for the object name. Brahe's TLE functions work with both TLE and 3LE formats interchangeably.</p> <p>The same TLE data in 3LE format would be:</p> <pre><code>ISS (ZARYA)             \n1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\n2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#validating-tles","title":"Validating TLEs","text":"<p>Before parsing TLE data, you can validate the format and checksums to ensure data integrity.</p>"},{"location":"learn/orbits/two_line_elements.html#validating-a-tle-set","title":"Validating a TLE Set","text":"PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Validate the complete TLE set (both lines must have matching NORAD IDs)\nis_valid = bh.validate_tle_lines(line1, line2)\nprint(f\"TLE set valid: {is_valid}\")\n\n# Validate individual lines\nline1_valid = bh.validate_tle_line(line1)\nline2_valid = bh.validate_tle_line(line2)\nprint(f\"Line 1 valid: {line1_valid}\")\nprint(f\"Line 2 valid: {line2_valid}\")\n\n# Expected output:\n# TLE set valid: True\n# Line 1 valid: True\n# Line 2 valid: True\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Validate the complete TLE set (both lines must have matching NORAD IDs)\n    let is_valid = bh::validate_tle_lines(line1, line2);\n    println!(\"TLE set valid: {}\", is_valid);\n\n    // Validate individual lines\n    let line1_valid = bh::validate_tle_line(line1);\n    let line2_valid = bh::validate_tle_line(line2);\n    println!(\"Line 1 valid: {}\", line1_valid);\n    println!(\"Line 2 valid: {}\", line2_valid);\n\n    // Expected output:\n    // TLE set valid: true\n    // Line 1 valid: true\n    // Line 2 valid: true\n}\n</code></pre> <p>The <code>validate_tle_lines</code> function checks that both lines have the correct format, valid checksums, and matching NORAD catalog numbers.</p>"},{"location":"learn/orbits/two_line_elements.html#calculating-checksums","title":"Calculating Checksums","text":"<p>Each TLE line ends with a modulo-10 checksum. You can calculate this checksum to verify data integrity or when creating custom TLEs:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Calculate checksums for each line\nchecksum1 = bh.calculate_tle_line_checksum(line1)\nchecksum2 = bh.calculate_tle_line_checksum(line2)\nprint(f\"Line 1 checksum: {checksum1}\")\nprint(f\"Line 2 checksum: {checksum2}\")\n\n# Example with corrupted TLE (wrong checksum)\ncorrupted_line1 = (\n    \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9990\"\n)\nis_corrupted_valid = bh.validate_tle_line(corrupted_line1)\nprint(f\"\\nCorrupted line valid: {is_corrupted_valid}\")\n\n# Expected output:\n# Line 1 checksum: 5\n# Line 2 checksum: 9\n#\n# Corrupted line valid: False\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Calculate checksums for each line\n    let checksum1 = bh::calculate_tle_line_checksum(line1);\n    let checksum2 = bh::calculate_tle_line_checksum(line2);\n    println!(\"Line 1 checksum: {}\", checksum1);\n    println!(\"Line 2 checksum: {}\", checksum2);\n\n    // Example with corrupted TLE (wrong checksum)\n    let corrupted_line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9990\";\n    let is_corrupted_valid = bh::validate_tle_line(corrupted_line1);\n    println!(\"\\nCorrupted line valid: {}\", is_corrupted_valid);\n\n    // Expected output:\n    // Line 1 checksum: 5\n    // Line 2 checksum: 9\n    //\n    // Corrupted line valid: false\n}\n</code></pre> <p>Checksum Algorithm</p> <p>The checksum is calculated by summing all digits in the line (treating minus signs as 1) and taking the result modulo 10. All other characters (letters, spaces, periods) are ignored in the checksum calculation.</p>"},{"location":"learn/orbits/two_line_elements.html#parsing-tles","title":"Parsing TLEs","text":""},{"location":"learn/orbits/two_line_elements.html#extracting-orbital-elements","title":"Extracting Orbital Elements","text":"<p>The most common operation is parsing a TLE to extract the epoch and orbital elements:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\nline2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\"\n\n# Parse TLE to extract epoch and orbital elements\nepoch, elements = bh.keplerian_elements_from_tle(line1, line2)\n\n# Extract individual orbital elements\n# Note: Angles are returned in degrees (exception to library convention)\na = elements[0]  # Semi-major axis (m)\ne = elements[1]  # Eccentricity\ni = elements[2]  # Inclination (deg)\nraan = elements[3]  # Right Ascension of Ascending Node (deg)\nargp = elements[4]  # Argument of Periapsis (deg)\nM = elements[5]  # Mean Anomaly (deg)\n\nprint(f\"ISS Orbital Elements (Epoch: {epoch})\")\nprint(f\"  Semi-major axis: {a / 1000:.3f} km\")\nprint(f\"  Eccentricity: {e:.6f}\")\nprint(f\"  Inclination: {i:.4f} deg\")\nprint(f\"  RAAN: {raan:.4f} deg\")\nprint(f\"  Arg of Perigee: {argp:.4f} deg\")\nprint(f\"  Mean Anomaly: {M:.4f} deg\")\n\n# Expected output:\n# ISS Orbital Elements (Epoch: 2025-10-29 11:44:55.862 UTC)\n#   Semi-major axis: 6796.092 km\n#   Eccentricity: 0.000481\n#   Inclination: 51.6347 deg\n#   RAAN: 1.5519 deg\n#   Arg of Perigee: 353.3325 deg\n#   Mean Anomaly: 6.7599 deg\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n    let line2 = \"2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49579513535999\";\n\n    // Parse TLE to extract epoch and orbital elements\n    let (epoch, elements) = bh::keplerian_elements_from_tle(line1, line2).unwrap();\n\n    // Extract individual orbital elements\n    let a = elements[0];  // Semi-major axis (m)\n    let e = elements[1];  // Eccentricity\n    let i = elements[2];  // Inclination (deg)\n    let raan = elements[3];  // Right Ascension of Ascending Node (deg)\n    let argp = elements[4];  // Argument of Periapsis (deg)\n    let mean_anom = elements[5];  // Mean Anomaly (deg)\n\n    println!(\"ISS Orbital Elements (Epoch: {})\", epoch);\n    println!(\"  Semi-major axis: {:.3} km\", a / 1000.0);\n    println!(\"  Eccentricity: {:.6}\", e);\n    println!(\"  Inclination: {:.4} deg\", i);\n    println!(\"  RAAN: {:.4} deg\", raan);\n    println!(\"  Arg of Perigee: {:.4} deg\", argp);\n    println!(\"  Mean Anomaly: {:.4} deg\", mean_anom);\n\n    // Expected output:\n    // ISS Orbital Elements (Epoch: 2025-10-29 11:44:55.862 UTC)\n    //   Semi-major axis: 6796.092 km\n    //   Eccentricity: 0.000481\n    //   Inclination: 51.6347 deg\n    //   RAAN: 1.5519 deg\n    //   Arg of Perigee: 353.3325 deg\n    //   Mean Anomaly: 6.7599 deg\n}\n</code></pre> <p>The returned elements follow the standard Brahe order: <code>[a, e, i, \u03a9, \u03c9, M]</code> where:</p> <ul> <li>\\(a\\) - Semi-major axis (meters)</li> <li>\\(e\\) - Eccentricity (dimensionless)</li> <li>\\(i\\) - Inclination (degrees)</li> <li>\\(\\Omega\\) - Right Ascension of Ascending Node (degrees)</li> <li>\\(\\omega\\) - Argument of Periapsis (degrees)</li> <li>\\(M\\) - Mean Anomaly (degrees)</li> </ul> <p>Angle Units Convention</p> <p>TLE functions use degrees for all angles. This matches the TLE format standard and makes it easier to work with TLE data directly.</p>"},{"location":"learn/orbits/two_line_elements.html#extracting-just-the-epoch","title":"Extracting Just the Epoch","text":"<p>If you only need the epoch timestamp without the full orbital elements:</p> PythonRust <pre><code>import brahe as bh\n\n# ISS TLE (NORAD ID 25544)\nline1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\"\n\n# Extract epoch from line 1 (epoch is encoded in line 1 only)\nepoch = bh.epoch_from_tle(line1)\n\nprint(f\"TLE Epoch: {epoch}\")\nprint(f\"Time System: {epoch.time_system}\")\n\n# Expected output:\n# TLE Epoch: 2025-10-29 11:44:55.862 UTC\n# Time System: UTC\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // ISS TLE (NORAD ID 25544)\n    let line1 = \"1 25544U 98067A   25302.48953544  .00013618  00000-0  24977-3 0  9995\";\n\n    // Extract epoch from line 1 (epoch is encoded in line 1 only)\n    let epoch = bh::epoch_from_tle(line1).unwrap();\n\n    println!(\"TLE Epoch: {}\", epoch);\n    println!(\"Time System: {:?}\", epoch.time_system);\n\n    // Expected output:\n    // TLE Epoch: 2025-10-29 11:44:55.862 UTC\n    // Time System: UTC\n}\n</code></pre> <p>The epoch is always returned in the UTC time system.</p>"},{"location":"learn/orbits/two_line_elements.html#creating-tles","title":"Creating TLEs","text":""},{"location":"learn/orbits/two_line_elements.html#from-keplerian-elements","title":"From Keplerian Elements","text":"<p>You can generate TLE lines from an epoch and mean orbital elements:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\n# Define orbital epoch\nepoch = bh.Epoch.from_datetime(2025, 10, 29, 11, 44, 55.766182, 0, bh.TimeSystem.UTC)\n\n# Define ISS orbital elements\n# Order: [a, e, i, raan, argp, M]\n# Note: Angles must be in DEGREES for TLE creation (exception to library convention)\nelements = np.array(\n    [\n        6795445.0,  # Semi-major axis (m)\n        0.0004808,  # Eccentricity\n        51.6347,  # Inclination (deg)\n        1.5519,  # Right Ascension of Ascending Node (deg)\n        353.3325,  # Argument of Periapsis (deg)\n        6.7599,  # Mean Anomaly (deg)\n    ]\n)\n\n# Create TLE lines with NORAD ID\nnorad_id = \"25544\"\nline1, line2 = bh.keplerian_elements_to_tle(epoch, elements, norad_id)\n\nprint(\"Generated TLE:\")\nprint(line1)\nprint(line2)\n\n# Expected output:\n# Generated TLE:\n# 1 25544U          25302.48953433  .00000000  00000+0  00000+0 0 00002\n# 2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49800901000006\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital epoch\n    let epoch = bh::Epoch::from_datetime(\n        2025, 10, 29, 11, 44, 55.766182, 0.0, bh::TimeSystem::UTC\n    );\n\n    // Define ISS orbital elements\n    // Order: [a, e, i, raan, argp, M]\n    // Note: Angles must be in DEGREES for TLE creation (exception to library convention)\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        6795445.0,      // Semi-major axis (m)\n        0.0004808,      // Eccentricity\n        51.6347,        // Inclination (deg)\n        1.5519,         // Right Ascension of Ascending Node (deg)\n        353.3325,       // Argument of Periapsis (deg)\n        6.7599          // Mean Anomaly (deg)\n    );\n\n    // Create TLE lines with NORAD ID\n    let norad_id = \"25544\";\n    let (line1, line2) = bh::keplerian_elements_to_tle(&amp;epoch, &amp;elements, norad_id).unwrap();\n\n    println!(\"Generated TLE:\");\n    println!(\"{}\", line1);\n    println!(\"{}\", line2);\n\n    // Expected output:\n    // Generated TLE:\n    // 1 25544U          25302.48953433  .00000000  00000+0  00000+0 0 00002\n    // 2 25544  51.6347   1.5519 0004808 353.3325   6.7599 15.49800901000006\n}\n</code></pre> <p>Default Values</p> <p>The <code>keplerian_elements_to_tle</code> function uses zero for fields like drag terms and derivatives. For complete control over all TLE fields, use the <code>create_tle_lines</code> function with its full parameter set.</p> <p>Mean Element Representation</p> <p>The TLE format encodes the orbital state as mean orbital elements estimated from orbit propgation using the SGP4/SDP4 models.</p> <p>While the package allows for direclty creating TLEs from arbitrary Keplerian elements, the resulting TLEs WILL NOT accurate propagation results with the SGP4/SDP4 models unless the input elements are already mean elements derived from those models.</p> <p>If you need to create TLEs for real satellites it's best to estimate the mean elements from observed data using orbit determination techniques using the SGP4/SDP4 models.</p> <p>You can verify generated TLEs by parsing them back:</p> PythonRust <pre><code># Define orbital epoch\nepoch = bh.Epoch.from_datetime(2025, 10, 29, 11, 44, 55.766182, 0, bh.TimeSystem.UTC)\n\n# Define ISS orbital elements (angles in degrees)\nelements = np.array(\n    [\n        6795445.0,  # Semi-major axis (m)\n        0.0004808,  # Eccentricity\n        51.6347,  # Inclination (deg)\n        1.5519,  # RAAN (deg)\n        353.3325,  # Argument of Periapsis (deg)\n        6.7599,  # Mean Anomaly (deg)\n    ]\n)\n\n# Create TLE\n</code></pre> <pre><code>    // Define orbital epoch\n    let epoch = bh::Epoch::from_datetime(\n        2025, 10, 29, 11, 44, 55.766182, 0.0, bh::TimeSystem::UTC\n    );\n\n    // Define ISS orbital elements (angles in degrees)\n    let elements = na::SVector::&lt;f64, 6&gt;::new(\n        6795445.0,      // Semi-major axis (m)\n        0.0004808,      // Eccentricity\n        51.6347,        // Inclination (deg)\n        1.5519,         // RAAN (deg)\n        353.3325,       // Argument of Periapsis (deg)\n        6.7599          // Mean Anomaly (deg)\n    );\n\n    // Create TLE\n    let norad_id = \"25544\";\n    let (line1, line2) = bh::keplerian_elements_to_tle(&amp;epoch, &amp;elements, norad_id).unwrap();\n\n    // Verify by parsing the generated TLE back\n    let (parsed_epoch, parsed_elements) = bh::keplerian_elements_from_tle(&amp;line1, &amp;line2).unwrap();\n\n    println!(\"Verification:\");\n    println!(\"Epoch matches: {}\", (epoch.jd() - parsed_epoch.jd()).abs() &lt; 1e-9);\n\n    let elements_match = elements.iter()\n        .zip(parsed_elements.iter())\n        .all(|(a, b)| (a - b).abs() / a.abs().max(1e-10) &lt; 1e-5);\n    println!(\"Elements match: {}\", elements_match);\n\n    // Expected output:\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#norad-id-formats","title":"NORAD ID Formats","text":"<p>TLEs support two formats for NORAD catalog numbers:</p> <ul> <li>Numeric: 5-digit numbers (00001-99999)</li> <li>Alpha-5: 5-character alphanumeric (A0000-Z9999)</li> </ul> <p>The Alpha-5 format extends the catalog beyond 99,999 satellites by using letters A-Z (excluding I and O to avoid confusion with 1 and 0).</p>"},{"location":"learn/orbits/two_line_elements.html#converting-between-formats","title":"Converting Between Formats","text":"PythonRust <pre><code>import brahe as bh\n\nprint(\"NORAD ID Format Conversions\\n\")\n\n# Convert numeric to Alpha-5 (only works for IDs &gt;= 100000)\nprint(\"Numeric to Alpha-5:\")\nalpha5_low = bh.norad_id_numeric_to_alpha5(25544)\nprint(f\"  25544 -&gt; {alpha5_low}\")\n\nalpha5_high = bh.norad_id_numeric_to_alpha5(100000)\nprint(f\"  100000 -&gt; {alpha5_high}\")\n\nalpha5_higher = bh.norad_id_numeric_to_alpha5(123456)\nprint(f\"  123456 -&gt; {alpha5_higher}\")\n\n# Convert Alpha-5 to numeric\nprint(\"\\nAlpha-5 to Numeric:\")\nnumeric_1 = bh.norad_id_alpha5_to_numeric(\"A0001\")\nprint(f\"  'A0001' -&gt; {numeric_1}\")\n\nnumeric_2 = bh.norad_id_alpha5_to_numeric(\"L0000\")\nprint(f\"  'L0000' -&gt; {numeric_2}\")\n\n# Round-trip conversion\nprint(\"\\nRound-trip Conversion:\")\noriginal = 200000\nalpha5 = bh.norad_id_numeric_to_alpha5(original)\nback_to_numeric = bh.norad_id_alpha5_to_numeric(alpha5)\nprint(f\"  {original} -&gt; '{alpha5}' -&gt; {back_to_numeric}\")\nprint(f\"  Match: {original == back_to_numeric}\")\n\n# Expected output:\n# NORAD ID Format Conversions\n#\n</code></pre> <pre><code>    bh::initialize_eop().unwrap();\n\n    println!(\"NORAD ID Format Conversions\\n\");\n\n    // Convert numeric to Alpha-5 (only works for IDs &gt;= 100000)\n    println!(\"Numeric to Alpha-5:\");\n    let alpha5_low = bh::norad_id_numeric_to_alpha5(25544).unwrap();\n    println!(\"  25544 -&gt; {}\", alpha5_low);\n\n    let alpha5_high = bh::norad_id_numeric_to_alpha5(100000).unwrap();\n    println!(\"  100000 -&gt; {}\", alpha5_high);\n\n    let alpha5_higher = bh::norad_id_numeric_to_alpha5(123456).unwrap();\n    println!(\"  123456 -&gt; {}\", alpha5_higher);\n\n    // Convert Alpha-5 to numeric\n    println!(\"\\nAlpha-5 to Numeric:\");\n    let numeric_1 = bh::norad_id_alpha5_to_numeric(\"A0001\").unwrap();\n    println!(\"  'A0001' -&gt; {}\", numeric_1);\n\n    let numeric_2 = bh::norad_id_alpha5_to_numeric(\"L0000\").unwrap();\n    println!(\"  'L0000' -&gt; {}\", numeric_2);\n\n    // Round-trip conversion\n    println!(\"\\nRound-trip Conversion:\");\n    let original = 200000;\n    let alpha5 = bh::norad_id_numeric_to_alpha5(original).unwrap();\n    let back_to_numeric = bh::norad_id_alpha5_to_numeric(&amp;alpha5).unwrap();\n    println!(\"  {} -&gt; '{}' -&gt; {}\", original, alpha5, back_to_numeric);\n    println!(\"  Match: {}\", original == back_to_numeric);\n\n    // Expected output:\n    // NORAD ID Format Conversions\n    //\n    // Numeric to Alpha-5:\n    //   25544 -&gt; 25544\n    //   100000 -&gt; A0000\n</code></pre> <p>Alpha-5 Range</p> <p>Alpha-5 format is only valid for NORAD IDs &gt;= 100,000. The range is 100,000 (A0000) to 339,999 (Z9999).</p>"},{"location":"learn/orbits/two_line_elements.html#parsing-mixed-formats","title":"Parsing Mixed Formats","text":"<p>The <code>parse_norad_id</code> function automatically detects whether a NORAD ID is in numeric or Alpha-5 format:</p> PythonRust <pre><code>import brahe as bh\n\n# Parse NORAD IDs in different formats\nprint(\"Parsing NORAD IDs:\")\n\n# Numeric format (standard)\nnorad_numeric = bh.parse_norad_id(\"25544\")\nprint(f\"  '25544' -&gt; {norad_numeric}\")\n</code></pre> <pre><code>    bh::initialize_eop().unwrap();\n\n    // Parse NORAD IDs in different formats\n    println!(\"Parsing NORAD IDs:\");\n\n    // Numeric format (standard)\n    let norad_numeric = bh::parse_norad_id(\"25544\").unwrap();\n    println!(\"  '25544' -&gt; {}\", norad_numeric);\n\n    // Alpha-5 format (for IDs &gt;= 100000)\n    let norad_alpha5 = bh::parse_norad_id(\"A0001\").unwrap();\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#see-also","title":"See Also","text":"<ul> <li>SGP Propagator - Use TLEs with SGP4/SDP4 propagation</li> <li>Keplerian Elements - Working with orbital elements</li> <li>Downloading TLE Data - How to fetch current TLEs from online sources</li> <li>Epoch - Understanding time representation in Brahe</li> </ul>"},{"location":"learn/orbits/walker.html","title":"Walker Constellations","text":"<p>Walker constellations are satellite constellations designed for optimal coverage using symmetric orbital plane distributions. Named after John Walker, who formalized the notation in 1984, these patterns are fundamental to modern satellite system design.</p>"},{"location":"learn/orbits/walker.html#walker-notation-itpf","title":"Walker Notation i:T/P/F","text":"<p>Walker constellations use i:T/P/F notation where:</p> <ul> <li>i (Inclination) - Orbital inclination in degrees</li> <li>T (Total) - Total number of satellites in the constellation</li> <li>P (Planes) - Number of equally-spaced orbital planes</li> <li>F (Phasing) - Relative phase difference between adjacent planes (0 to P-1)</li> </ul> <p>All satellites share identical:</p> <ul> <li>Semi-major axis (altitude)</li> <li>Eccentricity (typically circular, e \u2248 0)</li> <li>Inclination</li> </ul>"},{"location":"learn/orbits/walker.html#mathematical-formulation","title":"Mathematical Formulation","text":""},{"location":"learn/orbits/walker.html#raan-distribution","title":"RAAN Distribution","text":"<p>For P orbital planes, the Right Ascension of Ascending Node (RAAN) for plane k is:</p> \\[\\Omega_k = \\Omega_0 + k \\cdot \\frac{\\Delta\\Omega_\\text{spread}}{P}\\] <p>where:</p> <ul> <li>\\(\\Omega_0\\) is the reference RAAN</li> <li>\\(\\Delta\\Omega_\\text{spread}\\) is 360\u00b0 for Walker Delta, 180\u00b0 for Walker Star</li> <li>\\(k\\) is the plane index (0 to \\(P-1\\))</li> </ul>"},{"location":"learn/orbits/walker.html#mean-anomaly-distribution","title":"Mean Anomaly Distribution","text":"<p>For S = T/P satellites per plane, the mean anomaly for satellite j in plane k is:</p> \\[M_{k,j} = M_0 + j \\cdot \\frac{360\u00b0}{S} + k \\cdot F \\cdot \\frac{360\u00b0}{T}\\] <p>where:</p> <ul> <li>\\(M_0\\) is the reference mean anomaly</li> <li>\\(j\\) is the satellite index within the plane (0 to \\(S-1\\))</li> <li>\\(F\\) is the phasing factor</li> </ul>"},{"location":"learn/orbits/walker.html#constraints","title":"Constraints","text":"<ul> <li>\\(T\\) must be evenly divisible by \\(P\\)</li> <li>\\(F\\) must be in the range \\([0, P-1]\\)</li> </ul>"},{"location":"learn/orbits/walker.html#walker-delta-vs-walker-star","title":"Walker Delta vs Walker Star","text":"<p>Brahe supports two Walker patterns:</p> Pattern RAAN Spread Plane Spacing Coverage Walker Delta 360\u00b0 \\(\\Delta\\Omega = \\frac{360\u00b0}{P}\\) Global Walker Star 180\u00b0 \\(\\Delta\\Omega = \\frac{180\u00b0}{P}\\) Polar <p>Walker Delta distributes planes around the full 360\u00b0 of RAAN, providing global coverage. This is the pattern used by GPS, Galileo, and GLONASS.</p> <p>Walker Star distributes planes across only 180\u00b0 of RAAN, concentrating coverage at polar regions. This pattern is used by Iridium for its polar LEO constellation.</p>"},{"location":"learn/orbits/walker.html#generating-walker-constellations","title":"Generating Walker Constellations","text":""},{"location":"learn/orbits/walker.html#basic-walker-delta-gps-like","title":"Basic Walker Delta (GPS-like)","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch for constellation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create a GPS-like 24:6:2 Walker Delta constellation\n# T:P:F = 24:6:2 means:\n#   - T = 24 total satellites\n#   - P = 6 orbital planes\n#   - F = 2 phasing factor\nwalker = bh.WalkerConstellationGenerator(\n    t=24,\n    p=6,\n    f=2,\n    semi_major_axis=bh.R_EARTH + 20200e3,  # GPS altitude\n    eccentricity=0.0,\n    inclination=55.0,  # GPS inclination\n    argument_of_perigee=0.0,\n    reference_raan=0.0,\n    reference_mean_anomaly=0.0,\n    epoch=epoch,\n    angle_format=bh.AngleFormat.DEGREES,\n    pattern=bh.WalkerPattern.DELTA,\n).with_base_name(\"GPS\")\n\n# Print constellation properties\nprint(f\"Total satellites: {walker.total_satellites}\")\nprint(f\"Number of planes: {walker.num_planes}\")\nprint(f\"Satellites per plane: {walker.satellites_per_plane}\")\nprint(f\"Phasing factor: {walker.phasing}\")\nprint(f\"Pattern: {walker.pattern}\")\n\n# Get orbital elements for the first satellite in each plane\nprint(\"\\nFirst satellite in each plane:\")\nfor plane in range(walker.num_planes):\n    elements = walker.satellite_elements(plane, 0, bh.AngleFormat.DEGREES)\n    print(f\"  Plane {plane}: RAAN = {elements[3]:.1f} deg, MA = {elements[5]:.1f} deg\")\n\n# Generate Keplerian propagators for all satellites\npropagators = walker.as_keplerian_propagators(60.0)  # 60 second step size\nprint(f\"\\nGenerated {len(propagators)} Keplerian propagators\")\nprint(f\"First propagator name: {propagators[0].get_name()}\")\nprint(f\"Last propagator name: {propagators[-1].get_name()}\")\n\n# Expected output:\n# Total satellites: 24\n# Number of planes: 6\n# Satellites per plane: 4\n# Phasing factor: 2\n# Pattern: DELTA\n#\n# First satellite in each plane:\n#   Plane 0: RAAN = 0.0 deg, MA = 0.0 deg\n#   Plane 1: RAAN = 60.0 deg, MA = 30.0 deg\n#   Plane 2: RAAN = 120.0 deg, MA = 60.0 deg\n#   Plane 3: RAAN = 180.0 deg, MA = 90.0 deg\n#   Plane 4: RAAN = 240.0 deg, MA = 120.0 deg\n#   Plane 5: RAAN = 300.0 deg, MA = 150.0 deg\n#\n# Generated 24 Keplerian propagators\n# First propagator name: GPS-P0-S0\n# Last propagator name: GPS-P5-S3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::utils::Identifiable;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch for constellation\n    let epoch = bh::time::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Create a GPS-like 24:6:2 Walker Delta constellation\n    // T:P:F = 24:6:2 means:\n    //   - T = 24 total satellites\n    //   - P = 6 orbital planes\n    //   - F = 2 phasing factor\n    let walker = bh::orbits::WalkerConstellationGenerator::new(\n        24,   // T = 24 total satellites\n        6,    // P = 6 orbital planes\n        2,    // F = 2 phasing factor\n        bh::constants::R_EARTH + 20200e3, // GPS altitude\n        0.0,  // eccentricity\n        55.0, // inclination (degrees)\n        0.0,  // argument of perigee\n        0.0,  // reference RAAN\n        0.0,  // reference mean anomaly\n        epoch,\n        bh::constants::AngleFormat::Degrees,\n        bh::orbits::WalkerPattern::Delta,\n    )\n    .with_base_name(\"GPS\");\n\n    // Print constellation properties\n    println!(\"Total satellites: {}\", walker.total_satellites);\n    println!(\"Number of planes: {}\", walker.num_planes);\n    println!(\"Satellites per plane: {}\", walker.satellites_per_plane());\n    println!(\"Phasing factor: {}\", walker.phasing);\n    println!(\"Pattern: {:?}\", walker.pattern);\n\n    // Get orbital elements for the first satellite in each plane\n    println!(\"\\nFirst satellite in each plane:\");\n    for plane in 0..walker.num_planes {\n        let elements = walker.satellite_elements(plane, 0);\n        let raan_deg = elements[3] * bh::constants::RAD2DEG;\n        let ma_deg = elements[5] * bh::constants::RAD2DEG;\n        println!(\"  Plane {}: RAAN = {:.1} deg, MA = {:.1} deg\", plane, raan_deg, ma_deg);\n    }\n\n    // Generate Keplerian propagators for all satellites\n    let propagators = walker.as_keplerian_propagators(60.0); // 60 second step size\n    println!(\"\\nGenerated {} Keplerian propagators\", propagators.len());\n    println!(\"First propagator name: {}\", propagators[0].get_name().unwrap_or_default());\n    println!(\"Last propagator name: {}\", propagators.last().unwrap().get_name().unwrap_or_default());\n\n    // Expected output:\n    // Total satellites: 24\n    // Number of planes: 6\n    // Satellites per plane: 4\n    // Phasing factor: 2\n    // Pattern: Delta\n    //\n    // First satellite in each plane:\n    //   Plane 0: RAAN = 0.0 deg, MA = 0.0 deg\n    //   Plane 1: RAAN = 60.0 deg, MA = 30.0 deg\n    //   Plane 2: RAAN = 120.0 deg, MA = 60.0 deg\n    //   Plane 3: RAAN = 180.0 deg, MA = 90.0 deg\n    //   Plane 4: RAAN = 240.0 deg, MA = 120.0 deg\n    //   Plane 5: RAAN = 300.0 deg, MA = 150.0 deg\n    //\n    // Generated 24 Keplerian propagators\n    // First propagator name: GPS-P0-S0\n    // Last propagator name: GPS-P5-S3\n}\n</code></pre>"},{"location":"learn/orbits/walker.html#walker-star-iridium-like","title":"Walker Star (Iridium-like)","text":"PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch for constellation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create an Iridium-like 66:6:2 Walker Star constellation\n# Walker Star uses 180 degree RAAN spread (vs 360 for Delta)\nwalker = bh.WalkerConstellationGenerator(\n    t=66,\n    p=6,\n    f=2,\n    semi_major_axis=bh.R_EARTH + 780e3,  # Iridium altitude (~780 km)\n    eccentricity=0.0,\n    inclination=86.4,  # Near-polar inclination\n    argument_of_perigee=0.0,\n    reference_raan=0.0,\n    reference_mean_anomaly=0.0,\n    epoch=epoch,\n    angle_format=bh.AngleFormat.DEGREES,\n    pattern=bh.WalkerPattern.STAR,  # Star pattern uses 180 deg RAAN spread\n).with_base_name(\"IRIDIUM\")\n\n# Print constellation properties\nprint(f\"Total satellites: {walker.total_satellites}\")\nprint(f\"Number of planes: {walker.num_planes}\")\nprint(f\"Satellites per plane: {walker.satellites_per_plane}\")\nprint(f\"Phasing factor: {walker.phasing}\")\nprint(f\"Pattern: {walker.pattern}\")\n\n# Show RAAN spacing difference from Walker Delta\n# Walker Star: 180 / P = 180 / 6 = 30 degree spacing\n# Walker Delta: 360 / P = 360 / 6 = 60 degree spacing\nprint(\"\\nFirst satellite in each plane (Walker Star):\")\nfor plane in range(walker.num_planes):\n    elements = walker.satellite_elements(plane, 0, bh.AngleFormat.DEGREES)\n    print(f\"  Plane {plane}: RAAN = {elements[3]:.1f} deg\")\n\n# Compare with what Walker Delta would give\nprint(\"\\nRemark: Walker Delta with same P=6 would have 60 deg RAAN spacing\")\nprint(\"Walker Star spreads planes over 180 deg (0-150 deg)\")\nprint(\"Walker Delta spreads planes over 360 deg (0-300 deg)\")\n\n# Generate Keplerian propagators\npropagators = walker.as_keplerian_propagators(60.0)\nprint(f\"\\nGenerated {len(propagators)} Keplerian propagators\")\n\n# Expected output:\n# Total satellites: 66\n# Number of planes: 6\n# Satellites per plane: 11\n# Phasing factor: 2\n# Pattern: STAR\n#\n# First satellite in each plane (Walker Star):\n#   Plane 0: RAAN = 0.0 deg\n#   Plane 1: RAAN = 30.0 deg\n#   Plane 2: RAAN = 60.0 deg\n#   Plane 3: RAAN = 90.0 deg\n#   Plane 4: RAAN = 120.0 deg\n#   Plane 5: RAAN = 150.0 deg\n#\n# Remark: Walker Delta with same P=6 would have 60 deg RAAN spacing\n# Walker Star spreads planes over 180 deg (0-150 deg)\n# Walker Delta spreads planes over 360 deg (0-300 deg)\n#\n# Generated 66 Keplerian propagators\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch for constellation\n    let epoch = bh::time::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // Create an Iridium-like 66:6:2 Walker Star constellation\n    // Walker Star uses 180 degree RAAN spread (vs 360 for Delta)\n    let walker = bh::orbits::WalkerConstellationGenerator::new(\n        66,   // T = 66 total satellites\n        6,    // P = 6 orbital planes\n        2,    // F = 2 phasing factor\n        bh::constants::R_EARTH + 780e3, // Iridium altitude (~780 km)\n        0.0,  // eccentricity\n        86.4, // near-polar inclination (degrees)\n        0.0,  // argument of perigee\n        0.0,  // reference RAAN\n        0.0,  // reference mean anomaly\n        epoch,\n        bh::constants::AngleFormat::Degrees,\n        bh::orbits::WalkerPattern::Star, // Star pattern uses 180 deg RAAN spread\n    )\n    .with_base_name(\"IRIDIUM\");\n\n    // Print constellation properties\n    println!(\"Total satellites: {}\", walker.total_satellites);\n    println!(\"Number of planes: {}\", walker.num_planes);\n    println!(\"Satellites per plane: {}\", walker.satellites_per_plane());\n    println!(\"Phasing factor: {}\", walker.phasing);\n    println!(\"Pattern: {:?}\", walker.pattern);\n\n    // Show RAAN spacing difference from Walker Delta\n    // Walker Star: 180 / P = 180 / 6 = 30 degree spacing\n    // Walker Delta: 360 / P = 360 / 6 = 60 degree spacing\n    println!(\"\\nFirst satellite in each plane (Walker Star):\");\n    for plane in 0..walker.num_planes {\n        let elements = walker.satellite_elements(plane, 0);\n        let raan_deg = elements[3] * bh::constants::RAD2DEG;\n        println!(\"  Plane {}: RAAN = {:.1} deg\", plane, raan_deg);\n    }\n\n    // Compare with what Walker Delta would give\n    println!(\"\\nRemark: Walker Delta with same P=6 would have 60 deg RAAN spacing\");\n    println!(\"Walker Star spreads planes over 180 deg (0-150 deg)\");\n    println!(\"Walker Delta spreads planes over 360 deg (0-300 deg)\");\n\n    // Generate Keplerian propagators\n    let propagators = walker.as_keplerian_propagators(60.0);\n    println!(\"\\nGenerated {} Keplerian propagators\", propagators.len());\n\n    // Expected output:\n    // Total satellites: 66\n    // Number of planes: 6\n    // Satellites per plane: 11\n    // Phasing factor: 2\n    // Pattern: Star\n    //\n    // First satellite in each plane (Walker Star):\n    //   Plane 0: RAAN = 0.0 deg\n    //   Plane 1: RAAN = 30.0 deg\n    //   Plane 2: RAAN = 60.0 deg\n    //   Plane 3: RAAN = 90.0 deg\n    //   Plane 4: RAAN = 120.0 deg\n    //   Plane 5: RAAN = 150.0 deg\n    //\n    // Remark: Walker Delta with same P=6 would have 60 deg RAAN spacing\n    // Walker Star spreads planes over 180 deg (0-150 deg)\n    // Walker Delta spreads planes over 360 deg (0-300 deg)\n    //\n    // Generated 66 Keplerian propagators\n}\n</code></pre>"},{"location":"learn/orbits/walker.html#using-different-propagators","title":"Using Different Propagators","text":"<p>The <code>WalkerConstellationGenerator</code> can create propagators using different propagation methods:</p>"},{"location":"learn/orbits/walker.html#keplerian-propagators","title":"Keplerian Propagators","text":"<p>For analytical two-body propagation:</p> <pre><code>propagators = walker.as_keplerian_propagators(step_size=60.0)  # 60 second steps\n</code></pre>"},{"location":"learn/orbits/walker.html#sgp4-propagators","title":"SGP4 Propagators","text":"<p>For TLE-based propagation with perturbations:</p> <pre><code>propagators = walker.as_sgp_propagators(\n    step_size=60.0,\n    bstar=0.0,      # Drag coefficient\n    ndt2=0.0,       # Mean motion derivative / 2\n    nddt6=0.0,      # Mean motion 2nd derivative / 6\n)\n</code></pre>"},{"location":"learn/orbits/walker.html#numerical-propagators","title":"Numerical Propagators","text":"<p>For high-fidelity force-model propagation:</p> <pre><code>prop_config = bh.NumericalPropagationConfig.default()\nforce_config = bh.ForceModelConfig.earth_gravity()\n\npropagators = walker.as_numerical_propagators(prop_config, force_config)\n</code></pre>"},{"location":"learn/orbits/walker.html#visualizing-constellations","title":"Visualizing Constellations","text":""},{"location":"learn/orbits/walker.html#walker-delta-visualization","title":"Walker Delta Visualization","text":"<p>The Walker Delta pattern distributes orbital planes evenly around 360\u00b0 of RAAN:</p> Plot Source visualizing_walker_delta.py<pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch for constellation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create a GPS-like 24:6:2 Walker Delta constellation\nwalker = bh.WalkerConstellationGenerator(\n    t=24,\n    p=6,\n    f=2,\n    semi_major_axis=bh.R_EARTH + 20200e3,  # GPS altitude\n    eccentricity=0.0,\n    inclination=55.0,  # GPS inclination\n    argument_of_perigee=0.0,\n    reference_raan=0.0,\n    reference_mean_anomaly=0.0,\n    epoch=epoch,\n    angle_format=bh.AngleFormat.DEGREES,\n    pattern=bh.WalkerPattern.DELTA,\n).with_base_name(\"GPS\")\n\nprint(f\"Created {walker.total_satellites} satellite Walker Delta constellation\")\nprint(f\"Orbital planes: {walker.num_planes}\")\nprint(f\"RAAN spacing: 360/{walker.num_planes} = {360 / walker.num_planes:.0f} degrees\")\n\n# Generate Keplerian propagators and propagate for one orbit\npropagators = walker.as_keplerian_propagators(60.0)\n\n# Propagate each satellite for one complete orbit\nfor prop in propagators:\n    # Get semi-major axis from Keplerian elements [a, e, i, raan, argp, M]\n    koe = prop.state_koe_osc(prop.initial_epoch, bh.AngleFormat.RADIANS)\n    orbital_period = bh.orbital_period(koe[0])\n    prop.propagate_to(prop.initial_epoch + orbital_period)\n\nprint(f\"\\nPropagated all {len(propagators)} satellites for one orbital period\")\n\n# Create interactive 3D plot with Earth texture\nfig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n\n# ============================================================================\n# Plot Output Section (for documentation generation)\n# ============================================================================\n\n# ruff: noqa: E402\nimport os\nimport pathlib\nimport sys\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent / \"plots\"))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Save the figure as themed HTML\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\\n\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/walker.html#walker-star-visualization","title":"Walker Star Visualization","text":"<p>The Walker Star pattern concentrates planes over 180\u00b0 of RAAN for polar coverage:</p> Plot Source visualizing_walker_star.py<pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch for constellation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create an Iridium-like 66:6:2 Walker Star constellation\nwalker = bh.WalkerConstellationGenerator(\n    t=66,\n    p=6,\n    f=2,\n    semi_major_axis=bh.R_EARTH + 780e3,  # Iridium altitude\n    eccentricity=0.0,\n    inclination=86.4,  # Near-polar inclination\n    argument_of_perigee=0.0,\n    reference_raan=0.0,\n    reference_mean_anomaly=0.0,\n    epoch=epoch,\n    angle_format=bh.AngleFormat.DEGREES,\n    pattern=bh.WalkerPattern.STAR,  # 180 deg RAAN spread\n).with_base_name(\"IRIDIUM\")\n\nprint(f\"Created {walker.total_satellites} satellite Walker Star constellation\")\nprint(f\"Orbital planes: {walker.num_planes}\")\nprint(f\"RAAN spacing: 180/{walker.num_planes} = {180 / walker.num_planes:.0f} degrees\")\n\n# Generate Keplerian propagators and propagate for one orbit\npropagators = walker.as_keplerian_propagators(60.0)\n\n# Propagate each satellite for one complete orbit\nfor prop in propagators:\n    # Get semi-major axis from Keplerian elements [a, e, i, raan, argp, M]\n    koe = prop.state_koe_osc(prop.initial_epoch, bh.AngleFormat.RADIANS)\n    orbital_period = bh.orbital_period(koe[0])\n    prop.propagate_to(prop.initial_epoch + orbital_period)\n\nprint(f\"\\nPropagated all {len(propagators)} satellites for one orbital period\")\n\n# Create interactive 3D plot with Earth texture\nfig = bh.plot_trajectory_3d(\n    [\n        {\n            \"trajectory\": prop.trajectory,\n            \"mode\": \"markers\",\n            \"size\": 2,\n            \"label\": prop.get_name(),\n        }\n        for prop in propagators\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n    view_azimuth=45.0,\n    view_elevation=30.0,\n    view_distance=2.0,\n)\n\n# ============================================================================\n# Plot Output Section (for documentation generation)\n# ============================================================================\n\n# ruff: noqa: E402\nimport os\nimport pathlib\nimport sys\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent / \"plots\"))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Save the figure as themed HTML\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\\n\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/orbits/walker.html#see-also","title":"See Also","text":"<ul> <li>Walker Constellations API Reference - Complete API documentation</li> <li>Keplerian Elements - Orbital element fundamentals</li> <li>SGP4 Propagation - TLE-based propagation</li> <li>Numerical Propagation - High-fidelity propagation</li> <li>3D Trajectory Plotting - Trajectory visualization</li> </ul>"},{"location":"learn/plots/index.html","title":"Plotting &amp; Visualization","text":"<p>Brahe provides quick and convenient plotting functions for visualizing orbital trajectories, ground tracks, access windows, and other astrodynamics data. The plotting module is designed to make it easy to generate publication-quality figures with minimal code while offering flexibility for customization.</p> <p>Experimental API</p> <p>The plotting API in brahe is currently experimental and may undergo significant changes in future releases. While we strive to maintain backward compatibility, functions, parameters, or behaviors may change as we refine the plotting capabilities based on user feedback and evolving best practices in data visualization. These changes may occur in minor or patch releases.</p>"},{"location":"learn/plots/index.html#dual-backend-system","title":"Dual Backend System","text":"<p>All plotting functions in brahe support two rendering backends, allowing you to choose the best tool for your workflow:</p>"},{"location":"learn/plots/index.html#matplotlib-backend","title":"Matplotlib Backend","text":"<p>The matplotlib backend generates static, publication-ready figures. This is the default backend and is ideal for academic papers and technical reports.</p> <pre><code>import brahe as bh\n\n# Use matplotlib backend (default)\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    backend=\"matplotlib\"\n)\nfig.savefig(\"groundtrack.png\", dpi=300)\n</code></pre>"},{"location":"learn/plots/index.html#science-plots-styling","title":"Science Plots Styling","text":"<p>Brahe integrates with the <code>scienceplots</code> package to provide publication-quality matplotlib styling. When <code>scienceplots</code> is installed, brahe automatically applies clean, professional styling to matplotlib plots.</p> <p>To enable science plots styling either install brahe with all optional dependencies:</p> <pre><code>pip install brahe[all]\n</code></pre> <p>Or install <code>scienceplots</code> separately:</p> <pre><code>pip install scienceplots\n</code></pre> <p>To take full advantage of science plots styling, you can need a \\(\\LaTeX\\) installation on your system, as <code>scienceplots</code> uses LaTeX for rendering text in plots. See the scienceplots documentation for guidance on setting up LaTeX.</p> <p>If <code>scienceplots</code> is not installed, brahe falls back to standard matplotlib styling.</p>"},{"location":"learn/plots/index.html#plotly-backend","title":"Plotly Backend","text":"<p>The plotly backend creates interactive HTML figures that can be explored in a web browser. This backend is perfect for interactive exploration of data or sharing results via web pages or notebooks.</p> <pre><code>import brahe as bh\n\n# Use plotly backend for interactive plots\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    backend=\"plotly\"\n)\nfig.write_html(\"groundtrack.html\")\nfig.show()  # Opens in browser\n</code></pre> <p>Both backends use the same function signatures and parameters, making it trivial to switch between static and interactive outputs.</p>"},{"location":"learn/plots/index.html#available-plot-types","title":"Available Plot Types","text":"<p>Brahe provides specialized plotting functions for common astrodynamics visualization tasks:</p>"},{"location":"learn/plots/index.html#ground-track-plots","title":"Ground Track Plots","text":"<p>Visualize satellite ground tracks on a world map with ground stations and communication coverage zones.</p> <pre><code>fig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": orbit_traj}],\n    ground_stations=[{\"stations\": [station1, station2]}]\n)\n</code></pre>"},{"location":"learn/plots/index.html#3d-trajectory-plots","title":"3D Trajectory Plots","text":"<p>Visualize orbital trajectories in 3D space with an optional Earth sphere.</p> <pre><code>fig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    show_earth=True\n)\n</code></pre>"},{"location":"learn/plots/index.html#access-geometry-plots","title":"Access Geometry Plots","text":"<p>Visualize satellite visibility from ground stations using polar plots (azimuth/elevation) or elevation profiles over time.</p> <pre><code># Polar plot showing satellite path in sky\nfig = bh.plot_access_polar(access_window)\n\n# Elevation angle over time\nfig = bh.plot_access_elevation(access_window)\n</code></pre>"},{"location":"learn/plots/index.html#orbital-element-plots","title":"Orbital Element Plots","text":"<p>Track how orbital elements evolve over time in both Cartesian and Keplerian representations.</p> <pre><code># Plot position and velocity components\nfig = bh.plot_cartesian_trajectory([{\"trajectory\": traj}])\n\n# Plot Keplerian elements (a, e, i, \u03a9, \u03c9, \u03bd)\nfig = bh.plot_keplerian_trajectory([{\"trajectory\": traj}])\n</code></pre>"},{"location":"learn/plots/index.html#gabbard-diagrams","title":"Gabbard Diagrams","text":"<p>Analyze debris clouds or satellite constellations by plotting orbital period versus apogee/perigee altitude.</p> <pre><code>fig = bh.plot_gabbard_diagram(\n    propagators=[prop1, prop2, prop3],\n    epoch=epoch\n)\n</code></pre>"},{"location":"learn/plots/index.html#common-features","title":"Common Features","text":"<p>All plotting functions share consistent design patterns:</p> <ul> <li>Grouped plotting: Plot multiple trajectories, stations, or objects with different colors and labels</li> <li>Flexible inputs: Accept propagators, trajectories, or raw numpy arrays</li> <li>Unit conversion: Automatic handling of meters/kilometers, radians/degrees, etc.</li> <li>Time filtering: Optional time range filtering for all trajectory plots</li> <li>Customization: Control colors, line widths, markers, and other visual properties</li> </ul>"},{"location":"learn/plots/index.html#quick-start-example","title":"Quick Start Example","text":"<p>This example shows how to create a simple LEO orbit and visualize it in 3D. It demonstrates the core plotting workflow: define an orbit, propagate it, and visualize the results. Both plotly and matplotlib backends are shown.</p> <p>Matplotlib 3D Visualization Limitations</p> <p>The matplotlib 3D backend does not have a true 3D perspective camera model. Instead is uses a 2D layering system where entire objects (e.g., the entire orbit line, the entire sphere surface) are drawn one on top of the other based on a single, fixed <code>zorder</code> value. </p> <p>This can lead to visual artifacts where parts of objects that should be behind other objects are incorrectly drawn in front. For example, the far side of an orbit may appear in front of the Earth sphere.</p>"},{"location":"learn/plots/index.html#interactive-plot-plotly","title":"Interactive Plot (Plotly)","text":"Plot Source quickstart_example_plotly.py<pre><code>OUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create a simple LEO orbit\nepoch = bh.Epoch.from_datetime(2025, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\n\n# Create propagator and generate trajectory\nprop = bh.KeplerianPropagator.from_keplerian(epoch, oe, bh.AngleFormat.DEGREES, 5.0)\nprop.propagate_to(epoch + bh.orbital_period(oe[0]))\ntraj = prop.trajectory\n\n# Create an interactive 3D plot\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n    show_earth=True,\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/index.html#static-plot-matplotlib","title":"Static Plot (Matplotlib)","text":"Plot Source quickstart_example_matplotlib.py<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Create a simple LEO orbit\nepoch = bh.Epoch.from_datetime(2025, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Create propagator and generate trajectory\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\nprop.propagate_to(epoch + bh.orbital_period(oe[0]))\ntraj = prop.trajectory\n\n# Create a 3D plot in light mode\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n    show_earth=True,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_quickstart_example_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Quick start example plot (matplotlib, light mode) saved to: docs/figures/plot_quickstart_example_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create a 3D plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_trajectory_3d(\n        [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO\"}],\n        show_earth=True,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_quickstart_example_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Quick start example plot (matplotlib, dark mode) saved to: docs/figures/plot_quickstart_example_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n</code></pre>"},{"location":"learn/plots/index.html#see-also","title":"See Also","text":"<ul> <li>Ground Track Plotting - Satellite ground tracks and coverage</li> <li>Gabbard Diagrams - Debris cloud analysis</li> <li>3D Trajectories - Orbital paths in 3D space</li> <li>Access Geometry - Ground station visibility</li> <li>Orbital Elements - Element evolution over time</li> <li>API Reference - Complete function documentation</li> </ul>"},{"location":"learn/plots/3d_trajectory.html","title":"3D Trajectory Visualization","text":"<p>Three-dimensional trajectory plots display orbital paths in Earth-Centered Inertial (ECI) coordinates, providing intuitive spatial understanding of satellite motion. The <code>plot_trajectory_3d</code> function renders trajectories with optional Earth sphere visualization, camera controls, and support for multiple orbits with different colors and labels.</p>"},{"location":"learn/plots/3d_trajectory.html#interactive-3d-trajectory-plotly","title":"Interactive 3D Trajectory (Plotly)","text":"<p>The plotly backend creates fully interactive 3D plots. Click and drag to rotate, scroll to zoom, and double-click to reset the view.</p>"},{"location":"learn/plots/3d_trajectory.html#simple-texture-interactive","title":"Simple Texture (Interactive)","text":""},{"location":"learn/plots/3d_trajectory.html#blue-marble-texture","title":"Blue Marble Texture","text":"<p>Note</p> <p>Textues are provided as image-only in documentation to reduce page load times. Interactive versions can be generated using the provided code.</p>"},{"location":"learn/plots/3d_trajectory.html#natural-earth-texture","title":"Natural Earth Texture","text":"Plot Source trajectory_3d_plotly.py<pre><code>#!/usr/bin/env python\n# /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# TIMEOUT = 600\n# ///\n\"\"\"\n3D Trajectory Plotting Example - Plotly Backend\n\nThis script demonstrates how to create an interactive 3D trajectory plot in the ECI frame\nusing the plotly backend. Shows the ISS orbit around Earth with different texture options.\n\"\"\"\n\nimport numpy as np\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html, save_themed_static_image\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ISS-like orbit (LEO, 51.6\u00b0 inclination, ~400 km altitude)\noe_iss = np.array(\n    [\n        bh.R_EARTH + 420e3,  # Semi-major axis (m)\n        0.0005,  # Eccentricity\n        51.6,  # Inclination\n        45.0,  # RAAN\n        30.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_iss = bh.state_koe_to_eci(oe_iss, bh.AngleFormat.DEGREES)\nprop_iss = bh.KeplerianPropagator.from_eci(epoch, state_iss, 60.0)\n\n# Polar orbit (Sun-synchronous-like, ~550 km altitude)\noe_polar = np.array(\n    [\n        bh.R_EARTH + 550e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (near-polar)\n        180.0,  # RAAN\n        60.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_polar = bh.state_koe_to_eci(oe_polar, bh.AngleFormat.DEGREES)\nprop_polar = bh.KeplerianPropagator.from_eci(epoch, state_polar, 60.0)\n\n# Generate trajectories\nprop_iss.propagate_to(epoch + bh.orbital_period(oe_iss[0]))\ntraj_iss = prop_iss.trajectory\n\nprop_polar.propagate_to(epoch + bh.orbital_period(oe_polar[0]))\ntraj_polar = prop_polar.trajectory\n\n# Create 3D trajectory plot with Blue Marble texture (default for plotly)\nfig = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"blue_marble\",\n    backend=\"plotly\",\n)\n\n# Save as static images (SVG) - large texture, save as static to reduce file size\nlight_path, dark_path = save_themed_static_image(\n    fig, OUTDIR / SCRIPT_NAME, format=\"svg\", width=1400, height=900\n)\nprint(f\"\u2713 Generated {light_path} (Blue Marble texture - static SVG)\")\nprint(f\"\u2713 Generated {dark_path} (Blue Marble texture - static SVG)\")\n\n# Create 3D trajectory plot with simple texture\nfig_simple = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"simple\",\n    backend=\"plotly\",\n)\n\n# Save simple texture version as interactive HTML (small file size)\nlight_path, dark_path = save_themed_html(fig_simple, OUTDIR / f\"{SCRIPT_NAME}_simple\")\nprint(f\"\u2713 Generated {light_path} (Simple texture - interactive HTML)\")\nprint(f\"\u2713 Generated {dark_path} (Simple texture - interactive HTML)\")\n\nfig_ne = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    earth_texture=\"natural_earth_50m\",\n    backend=\"plotly\",\n)\n\n# Save Natural Earth texture version as static images (SVG)\nlight_path, dark_path = save_themed_static_image(\n    fig_ne,\n    OUTDIR / f\"{SCRIPT_NAME}_natural_earth\",\n    format=\"svg\",\n    width=1400,\n    height=900,\n)\nprint(f\"\u2713 Generated {light_path} (Natural Earth texture - static SVG)\")\nprint(f\"\u2713 Generated {dark_path} (Natural Earth texture - static SVG)\")\n\nprint(\"\\nAll plotly figures generated successfully!\")\n</code></pre> <p>The interactive visualization shows the ISS orbit in 3D space with Earth at the origin. You can:</p> <ul> <li>Rotate: Click and drag to change viewing angle</li> <li>Zoom: Scroll or pinch to zoom in/out</li> <li>Pan: Right-click and drag to pan</li> <li>Reset: Double-click to return to default view</li> </ul>"},{"location":"learn/plots/3d_trajectory.html#static-3d-trajectory-matplotlib","title":"Static 3D Trajectory (Matplotlib)","text":"<p>Matplotlib 3D Visualization Limitations</p> <p>The matplotlib 3D backend does not have a true 3D perspective camera model. Instead is uses a 2D layering system where entire objects (e.g., the entire orbit line, the entire sphere surface) are drawn one on top of the other based on a single, fixed <code>zorder</code> value. </p> <p>This can lead to visual artifacts where parts of objects that should be behind other objects are incorrectly drawn in front. For example, the far side of an orbit may appear in front of the Earth sphere.</p> <p>The matplotlib backend produces publication-ready 3D figures with customizable viewing angles.</p> Plot Source trajectory_3d_matplotlib.py<pre><code>#!/usr/bin/env python\n# /// script\n# dependencies = [\"brahe\", \"matplotlib\", \"numpy\"]\n# TIMEOUT = 600\n# ///\n\"\"\"\n3D Trajectory Plotting Example - Matplotlib Backend\n\nThis script demonstrates how to create a 3D trajectory plot in the ECI frame\nusing the matplotlib backend. Shows the ISS orbit around Earth with different\ntexture options for Earth visualization.\n\"\"\"\n\nimport numpy as np\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ISS-like orbit (LEO, 51.6\u00b0 inclination, ~400 km altitude)\noe_iss = np.array(\n    [\n        bh.R_EARTH + 420e3,  # Semi-major axis (m)\n        0.0005,  # Eccentricity\n        51.6,  # Inclination\n        45.0,  # RAAN\n        30.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_iss = bh.state_koe_to_eci(oe_iss, bh.AngleFormat.DEGREES)\nprop_iss = bh.KeplerianPropagator.from_eci(epoch, state_iss, 60.0)\n\n# Polar orbit (Sun-synchronous-like, ~550 km altitude)\noe_polar = np.array(\n    [\n        bh.R_EARTH + 550e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (near-polar)\n        180.0,  # RAAN\n        60.0,  # Argument of perigee\n        0.0,  # Mean anomaly\n    ]\n)\nstate_polar = bh.state_koe_to_eci(oe_polar, bh.AngleFormat.DEGREES)\nprop_polar = bh.KeplerianPropagator.from_eci(epoch, state_polar, 60.0)\n\n# Define time range - one orbital period of the lower orbit\n# Generate trajectories\nprop_iss.propagate_to(epoch + bh.orbital_period(oe_iss[0]))\ntraj_iss = prop_iss.trajectory\n\nprop_polar.propagate_to(epoch + bh.orbital_period(oe_polar[0]))\ntraj_polar = prop_polar.trajectory\n\n# Create 3D trajectory plot in light mode with matplotlib\nfig = bh.plot_trajectory_3d(\n    [\n        {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n        {\"trajectory\": traj_polar, \"color\": \"cyan\", \"label\": \"Polar 97.8\u00b0 (~550 km)\"},\n    ],\n    units=\"km\",\n    show_earth=True,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_trajectory_3d_matplotlib_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(\n    \"3D trajectory plot (matplotlib) saved to: docs/figures/plot_trajectory_3d_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create 3D trajectory plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_trajectory_3d(\n        [\n            {\"trajectory\": traj_iss, \"color\": \"red\", \"label\": \"LEO 51.6\u00b0 (~420 km)\"},\n            {\n                \"trajectory\": traj_polar,\n                \"color\": \"cyan\",\n                \"label\": \"Polar 97.8\u00b0 (~550 km)\",\n            },\n        ],\n        units=\"km\",\n        show_earth=True,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_trajectory_3d_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"3D trajectory plot (matplotlib, dark mode, Blue Marble) saved to: docs/figures/plot_trajectory_3d_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n\nprint(\"\\nAll matplotlib figures generated successfully!\")\n</code></pre>"},{"location":"learn/plots/3d_trajectory.html#see-also","title":"See Also","text":"<ul> <li>plot_trajectory_3d API Reference</li> <li>Ground Tracks - 2D projection on Earth's surface</li> <li>Orbital Elements - Element evolution over time</li> <li>Coordinate Systems - Understanding ECI frames</li> </ul>"},{"location":"learn/plots/access_geometry.html","title":"Access Geometry","text":"<p>Access geometry plots visualize satellite visibility from ground stations, showing where satellites appear in the sky and how their elevation changes over time. Brahe provides three complementary views: polar plots showing azimuth and elevation, elevation vs azimuth plots showing the observed horizon, and time-series plots tracking elevation angle during passes.</p> <p>All plot types support optional elevation masks to visualize terrain obstructions, antenna constraints, or other azimuth-dependent visibility limits.</p>"},{"location":"learn/plots/access_geometry.html#polar-access-plot-azimuthelevation","title":"Polar Access Plot (Azimuth/Elevation)","text":"<p>Polar plots display the satellite's path across the sky in azimuth-elevation coordinates, providing an intuitive \"looking up\" view from the ground station.</p>"},{"location":"learn/plots/access_geometry.html#interactive-polar-plot-plotly","title":"Interactive Polar Plot (Plotly)","text":"Plot Source access_polar_plotly.py<pre><code>\"\"\"\nAccess Polar Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive polar access plot using the plotly backend.\nShows satellite azimuth and elevation during ground station passes.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create polar access plot\nif len(accesses) &gt; 0:\n    # Use first 3 access windows\n    num_windows = min(3, len(accesses))\n    windows_to_plot = [\n        {\"access_window\": accesses[i], \"label\": f\"Access {i + 1}\"}\n        for i in range(num_windows)\n    ]\n\n    fig = bh.plot_access_polar(\n        windows_to_plot,\n        prop,  # Propagator for interpolation\n        min_elevation=10.0,\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-polar-plot-matplotlib","title":"Static Polar Plot (Matplotlib)","text":"Plot Source access_polar_matplotlib.py<pre><code>\"\"\"\nAccess Polar Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create a polar access plot using the matplotlib backend.\nShows satellite azimuth and elevation during ground station passes.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create polar access plots (light and dark mode)\nif len(accesses) &gt; 0:\n    # Use first 3 access windows\n    num_windows = min(3, len(accesses))\n    windows_to_plot = [\n        {\"access_window\": accesses[i], \"label\": f\"Access {i + 1}\"}\n        for i in range(num_windows)\n    ]\n\n    # Light mode\n    fig = bh.plot_access_polar(\n        windows_to_plot,\n        prop,  # Propagator for interpolation\n        min_elevation=10.0,\n        backend=\"matplotlib\",\n    )\n\n    # Save light mode figure\n    fig.savefig(\n        \"docs/figures/plot_access_polar_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access polar plot (matplotlib, light mode) saved to: docs/figures/plot_access_polar_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_polar(\n            windows_to_plot,\n            prop,  # Propagator for interpolation\n            min_elevation=10.0,\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        # Save dark mode figure\n        fig.savefig(\n            \"docs/figures/plot_access_polar_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access polar plot (matplotlib, dark mode) saved to: docs/figures/plot_access_polar_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre> <p>The polar plot shows:</p> <ul> <li>Radial axis: Elevation angle (0\u00b0 at edge, 90\u00b0 at center)</li> <li>Angular axis: Azimuth (0\u00b0 = North, 90\u00b0 = East, 180\u00b0 = South, 270\u00b0 = West)</li> <li>Satellite path: Track showing where the satellite appears in the sky</li> </ul>"},{"location":"learn/plots/access_geometry.html#elevation-vs-azimuth-plot-observed-horizon","title":"Elevation vs Azimuth Plot (Observed Horizon)","text":"<p>Elevation vs azimuth plots show satellite paths across the observed horizon, with azimuth on the X-axis and elevation on the Y-axis. This view is particularly useful for visualizing terrain obstructions and azimuth-dependent visibility constraints using elevation masks.</p>"},{"location":"learn/plots/access_geometry.html#interactive-elevation-vs-azimuth-plot-plotly","title":"Interactive Elevation vs Azimuth Plot (Plotly)","text":"Plot Source access_elevation_azimuth_plotly.py<pre><code>\"\"\"\nAccess Elevation vs Azimuth Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive elevation vs azimuth plot using the plotly backend.\nShows the satellite's trajectory across the observed horizon with a sinusoidal elevation mask.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = 28.4740  # Latitude in degrees\nlon = -80.5772  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 7.0 * 24.0 * 3600.0  # 24 hours in seconds\n\n\n# Define sinusoidal elevation mask: 15\u00b0 + 10\u00b0 * sin(2*azimuth)\n# This varies between 5\u00b0 and 25\u00b0 around the horizon\ndef elevation_mask(az):\n    return 15.0 + 10.0 * np.sin(np.radians(2 * az)) + 5.0 * np.sin(np.radians(3 * az))\n\n\n# Create ElevationMaskConstraint from the sinusoidal mask function\n# Sample the mask at 36 points around the horizon (every 10 degrees)\nmask_azimuths = np.arange(0, 360, 10)\nmask_points = [(az, elevation_mask(az)) for az in mask_azimuths]\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\n# Compute access windows using the elevation mask constraint\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\nprint(f\"Computed {len(accesses)} access windows\")\n\n# Filter for passes longer than 5 minutes (300 seconds) to show complete passes\nmin_duration = 300.0  # seconds\nlong_passes = [acc for acc in accesses if acc.duration &gt; min_duration]\nprint(f\"Filtered to {len(long_passes)} long passes (&gt; {min_duration} seconds)\")\n\n# Create elevation vs azimuth plot\nif len(long_passes) &gt; 0:\n    # Use first 3 long passes for better visualization\n    passes = long_passes[: min(3, len(long_passes))]\n    window_configs = [\n        {\"access_window\": passes[i], \"label\": f\"Pass {i + 1}\"}\n        for i in range(len(passes))\n    ]\n\n    fig = bh.plot_access_elevation_azimuth(\n        window_configs,\n        prop,  # Propagator for interpolation\n        elevation_mask=elevation_mask,\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-elevation-vs-azimuth-plot-matplotlib","title":"Static Elevation vs Azimuth Plot (Matplotlib)","text":"Plot Source access_elevation_azimuth_matplotlib.py<pre><code>\"\"\"\nAccess Elevation vs Azimuth Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create an elevation vs azimuth plot using the matplotlib backend.\nShows the satellite's trajectory across the observed horizon with a sinusoidal elevation mask.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = 28.4740  # Latitude in degrees\nlon = -80.5772  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 7.0 * 24.0 * 3600.0  # 24 hours in seconds\n\n\n# Define sinusoidal elevation mask: 15\u00b0 + 10\u00b0 * sin(2*azimuth)\n# This varies between 5\u00b0 and 25\u00b0 around the horizon\ndef elevation_mask(az):\n    return 15.0 + 10.0 * np.sin(np.radians(2 * az)) + 5.0 * np.sin(np.radians(3 * az))\n\n\n# Create ElevationMaskConstraint from the sinusoidal mask function\n# Sample the mask at 36 points around the horizon (every 10 degrees)\nmask_azimuths = np.arange(0, 360, 10)\nmask_points = [(az, elevation_mask(az)) for az in mask_azimuths]\nconstraint = bh.ElevationMaskConstraint(mask_points)\n\n# Compute access windows using the elevation mask constraint\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\nprint(f\"Computed {len(accesses)} access windows\")\n\n# Filter for passes longer than 5 minutes (300 seconds) to show complete passes\nmin_duration = 300.0  # seconds\nlong_passes = [acc for acc in accesses if acc.duration &gt; min_duration]\nprint(f\"Filtered to {len(long_passes)} long passes (&gt; {min_duration} seconds)\")\n\n# Create elevation vs azimuth plots (light and dark mode)\nif len(long_passes) &gt; 0:\n    # Use first 3 long passes for better visualization\n    passes = long_passes[: min(3, len(long_passes))]\n    window_configs = [\n        {\"access_window\": passes[i], \"label\": f\"Pass {i + 1}\"}\n        for i in range(len(passes))\n    ]\n\n    # Light mode\n    fig = bh.plot_access_elevation_azimuth(\n        window_configs,\n        prop,  # Propagator for interpolation\n        elevation_mask=elevation_mask,\n        backend=\"matplotlib\",\n    )\n\n    fig.savefig(\n        \"docs/figures/plot_access_elevation_azimuth_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access elevation vs azimuth plot (matplotlib, light mode) saved to: \"\n        \"docs/figures/plot_access_elevation_azimuth_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_elevation_azimuth(\n            window_configs,\n            prop,  # Propagator for interpolation\n            elevation_mask=elevation_mask,\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        fig.savefig(\n            \"docs/figures/plot_access_elevation_azimuth_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access elevation vs azimuth plot (matplotlib, dark mode) saved to: \"\n            \"docs/figures/plot_access_elevation_azimuth_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre> <p>The elevation vs azimuth plot shows:</p> <ul> <li>X-axis: Azimuth angle (0\u00b0 to 360\u00b0, North = 0\u00b0/360\u00b0)</li> <li>Y-axis: Elevation angle (0\u00b0 to 90\u00b0)</li> <li>Satellite trajectory: Path across the sky from observer's perspective</li> <li>Elevation mask (shaded region): Visibility constraints varying with azimuth</li> <li>Discontinuity handling: Trajectories crossing 0\u00b0/360\u00b0 azimuth are split to avoid artifacts</li> </ul>"},{"location":"learn/plots/access_geometry.html#elevation-masks","title":"Elevation Masks","text":"<p>Elevation masks define azimuth-dependent minimum elevation constraints. They can represent:</p> <ul> <li>Terrain obstructions: Mountains, buildings, trees</li> <li>Antenna constraints: Dish beamwidth, gimbal limits</li> <li>Operational requirements: RF interference avoidance zones</li> </ul> <p>The example above uses a sinusoidal mask: 15\u00b0 + 10\u00b0 sin(2\u00d7azimuth), varying between 5\u00b0 and 25\u00b0 around the horizon.</p>"},{"location":"learn/plots/access_geometry.html#using-elevation-masks","title":"Using Elevation Masks","text":"<p>Elevation masks can be specified in three ways:</p> <pre><code># Constant elevation (simple value)\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=10.0,  # 10\u00b0 everywhere\n    backend=\"matplotlib\"\n)\n\n# Function of azimuth (variable constraint)\nmask_fn = lambda az: 15.0 + 10.0 * np.sin(np.radians(2 * az))\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=mask_fn,\n    backend=\"matplotlib\"\n)\n\n# Array of values (measured terrain profile)\nazimuths = np.linspace(0, 360, 361)\nelevations = [measured_elevation(az) for az in azimuths]\nfig = bh.plot_access_elevation_azimuth(\n    windows, prop,\n    elevation_mask=elevations,  # Must match azimuth sampling\n    backend=\"matplotlib\"\n)\n</code></pre> <p>Elevation masks are also supported in polar plots (<code>plot_access_polar</code>) where they appear as shaded regions around the plot edge.</p>"},{"location":"learn/plots/access_geometry.html#elevation-vs-time-plot","title":"Elevation vs Time Plot","text":"<p>Time-series plots show how elevation angle changes throughout a satellite pass, useful for link budget analysis and antenna pointing.</p>"},{"location":"learn/plots/access_geometry.html#interactive-elevation-plot-plotly","title":"Interactive Elevation Plot (Plotly)","text":"Plot Source access_elevation_plotly.py<pre><code>\"\"\"\nAccess Elevation Plot Example - Plotly Backend\n\nThis script demonstrates how to create an interactive elevation vs time plot using the plotly backend.\nShows satellite elevation angle during a ground station pass.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create elevation plot\nif len(accesses) &gt; 0:\n    fig = bh.plot_access_elevation(\n        [{\"access_window\": accesses[0]}],  # Use first access window\n        prop,  # Propagator for interpolation\n        backend=\"plotly\",\n    )\n\n    # Save themed HTML files\n    light_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\n    print(f\"\u2713 Generated {light_path}\")\n    print(f\"\u2713 Generated {dark_path}\")\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#static-elevation-plot-matplotlib","title":"Static Elevation Plot (Matplotlib)","text":"Plot Source access_elevation_matplotlib.py<pre><code>\"\"\"\nAccess Elevation Plot Example - Matplotlib Backend\n\nThis script demonstrates how to create an elevation vs time plot using the matplotlib backend.\nShows satellite elevation angle during a ground station pass.\n\"\"\"\n\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range (one day to capture multiple passes)\nepoch = prop.epoch\nduration = 24.0 * 3600.0  # 24 hours in seconds\n\n# Compute access windows\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses([station], [prop], epoch, epoch + duration, constraint)\n\n# Create elevation plots (light and dark mode)\nif len(accesses) &gt; 0:\n    # Light mode\n    fig = bh.plot_access_elevation(\n        [{\"access_window\": accesses[0]}],  # Use first access window\n        prop,  # Propagator for interpolation\n        backend=\"matplotlib\",\n    )\n\n    # Save light mode figure\n    fig.savefig(\n        \"docs/figures/plot_access_elevation_matplotlib_light.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Access elevation plot (matplotlib, light mode) saved to: docs/figures/plot_access_elevation_matplotlib_light.svg\"\n    )\n    plt.close(fig)\n\n    # Dark mode\n    with plt.style.context(\"dark_background\"):\n        fig = bh.plot_access_elevation(\n            [{\"access_window\": accesses[0]}],  # Use first access window\n            prop,  # Propagator for interpolation\n            backend=\"matplotlib\",\n        )\n\n        # Set background color to match Plotly dark theme\n        fig.patch.set_facecolor(\"#1c1e24\")\n        for ax in fig.get_axes():\n            ax.set_facecolor(\"#1c1e24\")\n\n        # Save dark mode figure\n        fig.savefig(\n            \"docs/figures/plot_access_elevation_matplotlib_dark.svg\",\n            dpi=300,\n            bbox_inches=\"tight\",\n        )\n        print(\n            \"Access elevation plot (matplotlib, dark mode) saved to: docs/figures/plot_access_elevation_matplotlib_dark.svg\"\n        )\n        plt.close(fig)\nelse:\n    print(\"No access windows found in the specified time range\")\n</code></pre>"},{"location":"learn/plots/access_geometry.html#see-also","title":"See Also","text":"<ul> <li>plot_access_polar API Reference</li> <li>plot_access_elevation_azimuth API Reference</li> <li>plot_access_elevation API Reference</li> <li>location_accesses - Computing access windows</li> <li>Ground Tracks - Visualizing coverage on maps</li> <li>Access Constraints - Defining visibility rules</li> </ul>"},{"location":"learn/plots/gabbard_plot.html","title":"Gabbard Diagrams","text":"<p>A Gabbard diagram plots orbital period versus apogee and perigee altitude, providing a unique visualization for analyzing debris clouds, satellite breakups, and orbital constellations. Each object appears as two points: one for apogee altitude and one for perigee altitude, both at the same orbital period. This creates a characteristic pattern that reveals the distribution and evolution of orbital populations.</p>"},{"location":"learn/plots/gabbard_plot.html#interactive-gabbard-diagram-plotly","title":"Interactive Gabbard Diagram (Plotly)","text":"<p>The plotly backend allows you to zoom into specific regions and hover over points to see exact values.</p> Plot Source gabbard_plotly.py<pre><code>\"\"\"\nGabbard Diagram Example - Plotly Backend\n\nThis script demonstrates how to create an interactive Gabbard diagram using the plotly backend.\nA Gabbard diagram plots orbital period vs apogee/perigee altitude, useful for analyzing\ndebris clouds or satellite constellations.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get Ephmeris and debris for major events:\ncosmos_1408_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-1408-debris\", 60.0)\nfengyun_debris = bh.celestrak.get_tles_as_propagators(\"fengyun-1c-debris\", 60.0)\niridium_debris = bh.celestrak.get_tles_as_propagators(\"iridium-33-debris\", 60.0)\ncosmos_2251_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-2251-debris\", 60.0)\nall_debris = cosmos_1408_debris + fengyun_debris + iridium_debris + cosmos_2251_debris\n\nprint(f\"Cosmos 1408 debris objects: {len(cosmos_1408_debris)}\")\nprint(f\"Fengyun-1C debris objects: {len(fengyun_debris)}\")\nprint(f\"Iridium 33 debris objects: {len(iridium_debris)}\")\nprint(f\"Cosmos 2251 debris objects: {len(cosmos_2251_debris)}\")\nprint(f\"Total debris objects loaded: {len(all_debris)}\")\n\n# Get epoch of first debris object\nepoch = all_debris[0].epoch\n\n# Get ISS ephemeris for reference altitude line\niss = bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\")\niss_state = iss.state_eci(epoch)\niss_oe = bh.state_eci_to_koe(iss_state, bh.AngleFormat.RADIANS)\niss_altitude_km = (iss_oe[0] - bh.R_EARTH) / 1e3  # Convert to km\n\nprint(f\"ISS altitude at epoch: {iss_altitude_km:.1f} km\")\n\n# Create Gabbard diagram\nfig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"plotly\")\n\n# Add ISS altitude reference line\nfig.add_hline(\n    y=iss_altitude_km,\n    line_dash=\"dash\",\n    line_color=\"orange\",\n    line_width=2,\n    annotation_text=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n    annotation_position=\"right\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/gabbard_plot.html#static-gabbard-diagram-matplotlib","title":"Static Gabbard Diagram (Matplotlib)","text":"<p>The matplotlib backend produces publication-quality figures for research papers and technical reports.</p> Plot Source gabbard_matplotlib.py<pre><code>\"\"\"\nGabbard Diagram Example - Matplotlib Backend\n\nThis script demonstrates how to create a Gabbard diagram using the matplotlib backend.\nA Gabbard diagram plots orbital period vs apogee/perigee altitude, useful for analyzing\ndebris clouds or satellite constellations.\n\"\"\"\n\nimport os\nimport pathlib\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Get Ephmeris and debris for major events:\ncosmos_1408_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-1408-debris\", 60.0)\nfengyun_debris = bh.celestrak.get_tles_as_propagators(\"fengyun-1c-debris\", 60.0)\niridium_debris = bh.celestrak.get_tles_as_propagators(\"iridium-33-debris\", 60.0)\ncosmos_2251_debris = bh.celestrak.get_tles_as_propagators(\"cosmos-2251-debris\", 60.0)\nall_debris = cosmos_1408_debris + fengyun_debris + iridium_debris + cosmos_2251_debris\n\nprint(f\"Cosmos 1408 debris objects: {len(cosmos_1408_debris)}\")\nprint(f\"Fengyun-1C debris objects: {len(fengyun_debris)}\")\nprint(f\"Iridium 33 debris objects: {len(iridium_debris)}\")\nprint(f\"Cosmos 2251 debris objects: {len(cosmos_2251_debris)}\")\nprint(f\"Total debris objects loaded: {len(all_debris)}\")\n\n# Get epoch of first debris object\nepoch = all_debris[0].epoch\n\n# Get ISS ephemeris for reference altitude line\niss = bh.celestrak.get_tle_by_id_as_propagator(25544, 60.0, \"active\")\niss_state = iss.state_eci(epoch)\niss_oe = bh.state_eci_to_koe(iss_state, bh.AngleFormat.RADIANS)\niss_altitude_km = (iss_oe[0] - bh.R_EARTH) / 1e3  # Convert to km\n\nprint(f\"ISS altitude at epoch: {iss_altitude_km:.1f} km\")\n\n# Create Gabbard diagram in light mode\nfig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"matplotlib\")\n\n# Add ISS altitude reference line\nax = fig.get_axes()[0]\nax.axhline(\n    y=iss_altitude_km,\n    color=\"green\",\n    linestyle=\"--\",\n    linewidth=2,\n    label=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n)\nax.legend()\n\n# Save light mode figure\nlight_path = OUTDIR / f\"{SCRIPT_NAME}_light.svg\"\nfig.savefig(light_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"\u2713 Generated {light_path}\")\nplt.close(fig)\n\n# Create Gabbard diagram in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_gabbard_diagram(all_debris, epoch, backend=\"matplotlib\")\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Add ISS altitude reference line\n    ax = fig.get_axes()[0]\n    ax.axhline(\n        y=iss_altitude_km,\n        color=\"orange\",\n        linestyle=\"--\",\n        linewidth=2,\n        label=f\"ISS Altitude ({iss_altitude_km:.1f} km)\",\n    )\n    ax.legend()\n\n    # Save dark mode figure\n    dark_path = OUTDIR / f\"{SCRIPT_NAME}_dark.svg\"\n    fig.savefig(dark_path, dpi=300, bbox_inches=\"tight\")\n    print(f\"\u2713 Generated {dark_path}\")\n    plt.close(fig)\n</code></pre>"},{"location":"learn/plots/gabbard_plot.html#understanding-the-diagram","title":"Understanding the Diagram","text":""},{"location":"learn/plots/gabbard_plot.html#reading-the-plot","title":"Reading the Plot","text":"<ul> <li>X-axis: Orbital period (minutes or hours)</li> <li>Y-axis: Altitude (km)</li> <li>Each object creates TWO points:<ul> <li>Upper point: Apogee altitude</li> <li>Lower point: Perigee altitude</li> </ul> </li> </ul>"},{"location":"learn/plots/gabbard_plot.html#interpreting-patterns","title":"Interpreting Patterns","text":"<p>Tight vertical pairs: Low eccentricity (near-circular orbits)</p> <p>Wide vertical separation: High eccentricity (elliptical orbits)</p>"},{"location":"learn/plots/gabbard_plot.html#tips","title":"Tips","text":"<ul> <li>Use <code>backend=\"plotly\"</code> to identify outliers and explore specific objects interactively</li> <li>Add reference lines for altitude constraints (e.g., ISS orbit, debris-heavy regions)</li> </ul>"},{"location":"learn/plots/gabbard_plot.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Elements - Understanding orbital parameters</li> <li>Propagators - Creating propagators from TLEs</li> </ul>"},{"location":"learn/plots/ground_tracks.html","title":"Ground Tracks","text":"<p>Ground track plotting visualizes the path a satellite traces over Earth's surface. This is essential for mission planning, coverage analysis, and understanding when and where a satellite can communicate with ground stations. Brahe's <code>plot_groundtrack</code> function renders satellite trajectories on a world map with optional ground station markers and communication coverage cones.</p>"},{"location":"learn/plots/ground_tracks.html#interactive-ground-track-plotly","title":"Interactive Ground Track (Plotly)","text":"<p>The plotly backend creates interactive maps that you can pan, zoom, and explore. Hover over the satellite track to see precise coordinates.</p> Plot Source groundtrack_plotly.py<pre><code>\"\"\"\nGround Track Plotting Example - Plotly Backend\n\nThis script demonstrates how to create an interactive ground track plot using the plotly backend.\nIt shows the ISS ground track with a ground station communication cone.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (Cape Canaveral)\nlat = np.radians(28.3922)  # Latitude in radians\nlon = np.radians(-80.6077)  # Longitude in radians\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lat, lon, alt).with_name(\"Cape Canaveral\")\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create ground track plot\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n    ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n    gs_cone_altitude=420e3,  # ISS altitude\n    gs_min_elevation=10.0,\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example shows:</p> <ul> <li>ISS ground track over one orbital period (red line)</li> <li>Cape Canaveral ground station (blue marker)</li> <li>Communication cone showing the region where the ISS is visible above 10\u00b0 elevation</li> </ul> <p>The interactive plot allows you to:</p> <ul> <li>Zoom into specific regions</li> <li>Pan across the map</li> <li>Hover to see exact coordinates</li> <li>Toggle layers on/off</li> </ul>"},{"location":"learn/plots/ground_tracks.html#static-ground-track-matplotlib","title":"Static Ground Track (Matplotlib)","text":"<p>The matplotlib backend produces publication-ready static figures ideal for reports and papers.</p> Plot Source groundtrack_matplotlib.py<pre><code>\"\"\"\nGround Track Plotting Example - Matplotlib Backend\n\nThis script demonstrates how to create a ground track plot using the matplotlib backend.\nIt shows the ISS ground track with a ground station communication cone.\n\"\"\"\n\nimport brahe as bh\nimport matplotlib.pyplot as plt\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define ground station (San Francisco)\nlat = 37.7749  # Latitude in degrees\nlon = -122.4194  # Longitude in degrees\nalt = 0.0  # Altitude in meters\nstation = bh.PointLocation(lon, lat, alt).with_name(\"Cape Canaveral\")\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create ground track plot in light mode\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n    ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n    gs_cone_altitude=420e3,  # ISS altitude\n    gs_min_elevation=10.0,\n    backend=\"matplotlib\",\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_groundtrack_matplotlib_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(\n    \"Ground track plot (matplotlib, light mode) saved to: docs/figures/plot_groundtrack_matplotlib_light.svg\"\n)\nplt.close(fig)\n\n# Create ground track plot in dark mode\nwith plt.style.context(\"dark_background\"):\n    fig = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\"}],\n        ground_stations=[{\"stations\": [station], \"color\": \"blue\", \"alpha\": 0.3}],\n        gs_cone_altitude=420e3,  # ISS altitude\n        gs_min_elevation=10.0,\n        backend=\"matplotlib\",\n    )\n\n    # Set background color to match Plotly dark theme\n    fig.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    # Save dark mode figure\n    fig.savefig(\n        \"docs/figures/plot_groundtrack_matplotlib_dark.svg\",\n        dpi=300,\n        bbox_inches=\"tight\",\n    )\n    print(\n        \"Ground track plot (matplotlib, dark mode) saved to: docs/figures/plot_groundtrack_matplotlib_dark.svg\"\n    )\n    plt.close(fig)\n</code></pre> <p>The static plot shows the same information in a clean, professional format suitable for:</p> <ul> <li>Academic publications</li> <li>Technical reports</li> <li>Batch figure generation</li> <li>Custom post-processing with matplotlib</li> </ul>"},{"location":"learn/plots/ground_tracks.html#configuration-and-customization","title":"Configuration and Customization","text":""},{"location":"learn/plots/ground_tracks.html#multiple-spacecraft","title":"Multiple Spacecraft","text":"<p>Plot multiple satellites simultaneously to compare orbits or analyze constellations:</p> Plot Source groundtrack_multiple_spacecraft.py<pre><code>\"\"\"\nGround Track Multiple Spacecraft Example\n\nThis script demonstrates how to plot ground tracks for multiple satellites simultaneously\nwith different colors and line styles.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Define epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create three different LEO satellites with different orbits\n\n# Satellite 1: Sun-synchronous orbit (polar, high inclination)\noe1 = np.array([bh.R_EARTH + 700e3, 0.001, 98.0, 0.0, 0.0, 0.0])\nstate1 = bh.state_koe_to_eci(oe1, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator.from_eci(epoch, state1, 60.0).with_name(\"Sun-Sync\")\n\n# Satellite 2: Medium inclination orbit\noe2 = np.array(\n    [\n        bh.R_EARTH + 600e3,\n        0.001,\n        55.0,\n        45.0,\n        0.0,\n        90.0,\n    ]\n)\nstate2 = bh.state_koe_to_eci(oe2, bh.AngleFormat.DEGREES)\nprop2 = bh.KeplerianPropagator.from_eci(epoch, state2, 60.0).with_name(\"Mid-Inc\")\n\n# Satellite 3: Equatorial orbit\noe3 = np.array(\n    [\n        bh.R_EARTH + 800e3,\n        0.001,\n        5.0,\n        90.0,\n        0.0,\n        180.0,\n    ]\n)\nstate3 = bh.state_koe_to_eci(oe3, bh.AngleFormat.DEGREES)\nprop3 = bh.KeplerianPropagator.from_eci(epoch, state3, 60.0).with_name(\"Equatorial\")\n\n# Propagate all satellites for 2 orbits\nduration = 2 * bh.orbital_period(oe1[0])\n\nprop1.propagate_to(epoch + duration)\nprop2.propagate_to(epoch + duration)\nprop3.propagate_to(epoch + duration)\n\n# Create ground track plot with all three satellites\nfig = bh.plot_groundtrack(\n    trajectories=[\n        {\"trajectory\": prop1.trajectory, \"color\": \"red\", \"line_width\": 2},\n        {\"trajectory\": prop2.trajectory, \"color\": \"blue\", \"line_width\": 2},\n        {\"trajectory\": prop3.trajectory, \"color\": \"green\", \"line_width\": 2},\n    ],\n    basemap=\"natural_earth\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example shows three different LEO orbits: - Red: Sun-synchronous orbit (98\u00b0 inclination, 700km altitude) - Blue: Medium inclination (55\u00b0, 600km altitude) - Green: Equatorial orbit (5\u00b0 inclination, 800km altitude)</p>"},{"location":"learn/plots/ground_tracks.html#ground-station-networks","title":"Ground Station Networks","text":"<p>Visualize satellite visibility over ground station networks with geodetic coverage zones:</p> Plot Source groundtrack_nasa_nen.py<pre><code>\"\"\"\nGround Track with NASA NEN Ground Stations Example\n\nThis script demonstrates plotting ground tracks with the NASA Near Earth Network (NEN)\nground stations, showing communication coverage at 550km altitude with 10\u00b0 minimum elevation.\nThe coverage cones are displayed as geodetic polygons showing actual ground footprints.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load NASA NEN ground stations\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nprint(f\"Loaded {len(nen_stations)} NASA NEN stations\")\n\n# Create a LEO satellite at 550km altitude\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 550e3, 0.001, 51.6, 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"LEO Sat\")\n\n# Propagate for 2 orbits\nduration = 2 * bh.orbital_period(oe[0])\nprop.propagate_to(epoch + duration)\n\n# Create ground track plot with NASA NEN stations and communication cones\n# The coverage cones are automatically computed using proper geodesic geometry,\n# which correctly handles high latitudes and antimeridian crossings\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": prop.trajectory, \"color\": \"red\", \"line_width\": 2}],\n    ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.15}],\n    gs_cone_altitude=550e3,  # Satellite altitude for cone calculation\n    gs_min_elevation=10.0,  # Minimum elevation angle in degrees\n    basemap=\"natural_earth\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>This example demonstrates: - Loading the NASA Near Earth Network (NEN) ground stations from built-in datasets - Computing geodetic coverage zones for each station at 10\u00b0 minimum elevation - Displaying coverage as semi-transparent filled polygons on the map - Visualizing actual ground footprints for a 550km altitude LEO satellite</p> <p>The coverage zones are computed as properly transformed geodetic shapes, showing the actual region on Earth's surface where the satellite is visible above the minimum elevation angle.</p> <p>Available ground station networks include: <code>\"atlas\"</code>, <code>\"aws\"</code>, <code>\"ksat\"</code>, <code>\"leaf\"</code>, <code>\"nasa dsn\"</code>, <code>\"nasa nen\"</code>, <code>\"ssc\"</code>, and <code>\"viasat\"</code>.</p>"},{"location":"learn/plots/ground_tracks.html#map-styles","title":"Map Styles","text":"<p>Choose from different basemap styles to suit your presentation needs:</p>"},{"location":"learn/plots/ground_tracks.html#natural-earth-high-quality-vector","title":"Natural Earth (High-Quality Vector)","text":""},{"location":"learn/plots/ground_tracks.html#stock-cartopy-built-in-minimal","title":"Stock (Cartopy Built-in, Minimal)","text":""},{"location":"learn/plots/ground_tracks.html#blue-marble-satellite-imagery","title":"Blue Marble (Satellite Imagery)","text":"Plot Source groundtrack_basemaps.py<pre><code>\"\"\"\nGround Track Basemap Styles Example\n\nThis script demonstrates different basemap styles available for ground track plots:\n- natural_earth: High-quality vector basemap from Natural Earth Data\n- stock: Cartopy's built-in coastlines only\n- blue_marble: NASA Blue Marble satellite imagery background\n\"\"\"\n\nimport os\nimport pathlib\nimport brahe as bh\nimport matplotlib.pyplot as plt\nfrom brahe.plots.texture_utils import get_blue_marble_texture_path\nfrom PIL import Image\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop.epoch\n\n# Propagate for one orbital period\nduration = 92.0 * 60.0  # ~92 minutes for ISS\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create three versions with different basemaps\n\n# 1. Natural Earth - High-quality vector basemap\nfig_ne = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=\"natural_earth\",\n    backend=\"matplotlib\",\n)\nfig_ne.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_natural_earth_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_natural_earth_light.svg\")\nplt.close(fig_ne)\n\n# 2. Stock - Cartopy built-in features (no outlines)\nfig_stock = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=\"stock\",\n    show_borders=False,  # Remove country borders\n    show_coastlines=False,  # Remove coastlines\n    backend=\"matplotlib\",\n)\nfig_stock.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_stock_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_stock_light.svg\")\nplt.close(fig_stock)\n\n# 3. Blue Marble - NASA satellite imagery\n# Load Blue Marble texture\nblue_marble_path = get_blue_marble_texture_path()\nblue_marble_img = Image.open(blue_marble_path)\n\nfig_bluemarble = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n    basemap=None,  # No basemap, we'll add the image manually\n    show_borders=False,  # Remove country borders\n    show_coastlines=False,  # Remove coastlines\n    backend=\"matplotlib\",\n)\nax_bm = fig_bluemarble.get_axes()[0]\n# Display Blue Marble as background\nax_bm.imshow(\n    blue_marble_img,\n    origin=\"upper\",\n    extent=[-180, 180, -90, 90],\n    transform=ax_bm.projection,\n    zorder=0,\n)\nfig_bluemarble.savefig(\n    OUTDIR / f\"{SCRIPT_NAME}_blue_marble_light.svg\", dpi=300, bbox_inches=\"tight\"\n)\nprint(f\"\u2713 Generated {SCRIPT_NAME}_blue_marble_light.svg\")\nplt.close(fig_bluemarble)\n\n# Generate dark mode versions\nwith plt.style.context(\"dark_background\"):\n    # Natural Earth (dark)\n    fig_ne_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=\"natural_earth\",\n        backend=\"matplotlib\",\n    )\n    fig_ne_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_ne_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_ne_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_natural_earth_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_natural_earth_dark.svg\")\n    plt.close(fig_ne_dark)\n\n    # Stock (dark)\n    fig_stock_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=\"stock\",\n        show_borders=False,  # Remove country borders\n        show_coastlines=False,  # Remove coastlines\n        backend=\"matplotlib\",\n    )\n    fig_stock_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_stock_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_stock_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_stock_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_stock_dark.svg\")\n    plt.close(fig_stock_dark)\n\n    # Blue Marble (dark)\n    fig_bluemarble_dark = bh.plot_groundtrack(\n        trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"line_width\": 2}],\n        basemap=None,  # No basemap, we'll add the image manually\n        show_borders=False,  # Remove country borders\n        show_coastlines=False,  # Remove coastlines\n        backend=\"matplotlib\",\n    )\n    ax_bm_dark = fig_bluemarble_dark.get_axes()[0]\n    ax_bm_dark.imshow(\n        blue_marble_img,\n        origin=\"upper\",\n        extent=[-180, 180, -90, 90],\n        transform=ax_bm_dark.projection,\n        zorder=0,\n    )\n    fig_bluemarble_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_bluemarble_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n    fig_bluemarble_dark.savefig(\n        OUTDIR / f\"{SCRIPT_NAME}_blue_marble_dark.svg\", dpi=300, bbox_inches=\"tight\"\n    )\n    print(f\"\u2713 Generated {SCRIPT_NAME}_blue_marble_dark.svg\")\n    plt.close(fig_bluemarble_dark)\n</code></pre> <p>The basemap styles offer different visualization approaches: - Natural Earth: High-quality vector map with political boundaries and natural features (default) - Stock: Minimal Cartopy background without geographic features, ideal for clean presentations - Blue Marble: NASA satellite imagery texture provides photorealistic Earth background</p> <p>Set the <code>basemap</code> parameter to <code>\"natural_earth\"</code> (default), <code>\"stock\"</code>, or <code>None</code> to control the map style. For Blue Marble, use <code>basemap=None</code> and manually overlay the texture image.</p> <p>Backend Capabilities</p> <p>Matplotlib backend supports all basemap styles including Natural Earth shapefiles and Blue Marble textures.</p> <p>Plotly backend uses Scattergeo which only supports outline-based maps with solid colors. Custom textures (Natural Earth shapefiles, Blue Marble imagery) are not available in the plotly backend. Use <code>basemap=\"natural_earth\"</code> for a light gray landmass color or <code>basemap=\"stock\"</code> for tan.</p>"},{"location":"learn/plots/ground_tracks.html#advanced-examples","title":"Advanced Examples","text":""},{"location":"learn/plots/ground_tracks.html#maximum-coverage-gap-analysis","title":"Maximum Coverage Gap Analysis","text":"<p>This advanced example identifies the longest period without ground station contact and visualizes only that critical gap segment:</p> <p>This demonstrates how to: - Compute access windows between a satellite and ground network - Find the longest gap between consecutive contacts - Extract and plot only the gap segment (without the full 24-hour ground track) - Handle antimeridian wraparound with custom plotting</p> Plot Source groundtrack_max_gap.py<pre><code>\"\"\"\nGround Track Maximum Coverage Gap Analysis\n\nThis advanced example demonstrates how to:\n1. Compute access windows between a satellite and ground station network\n2. Find the maximum gap between consecutive accesses\n3. Extract and plot the ground track segment during that gap\n4. Handle antimeridian wraparound in custom plotting\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# Load NASA NEN ground stations\nnen_stations = bh.datasets.groundstations.load(\"nasa nen\")\nprint(f\"Loaded {len(nen_stations)} NASA NEN stations\")\n\n# Create ISS propagator using TLE\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop.epoch\n\n# Define 24-hour analysis period\nduration = 24.0 * 3600.0  # 24 hours in seconds\nsearch_end = epoch + duration\n\n# Compute access windows with 10\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\naccesses = bh.location_accesses(nen_stations, [prop], epoch, search_end, constraint)\n\nprint(f\"Found {len(accesses)} access windows over 24 hours\")\n\n# Find the longest gap between consecutive accesses\nmax_gap_duration = 0.0\nmax_gap_start = None\nmax_gap_end = None\n\nif len(accesses) &gt; 1:\n    # Sort accesses by start time\n    sorted_accesses = sorted(accesses, key=lambda a: a.start.jd())\n\n    for i in range(len(sorted_accesses) - 1):\n        gap_start = sorted_accesses[i].end\n        gap_end = sorted_accesses[i + 1].start\n        gap_duration = gap_end - gap_start  # Difference in seconds\n\n        if gap_duration &gt; max_gap_duration:\n            max_gap_duration = gap_duration\n            max_gap_start = gap_start\n            max_gap_end = gap_end\n\n# Check gap from last access to end of period\nif len(sorted_accesses) &gt; 0:\n    final_gap_start = sorted_accesses[-1].end\n    final_gap_end = search_end\n    final_gap_duration = final_gap_end - final_gap_start\n\n    if final_gap_duration &gt; max_gap_duration:\n        max_gap_duration = final_gap_duration\n        max_gap_start = final_gap_start\n        max_gap_end = final_gap_end\n\nprint(\"\\nMaximum coverage gap:\")\nprint(f\"  Duration: {max_gap_duration / 60.0:.2f} minutes\")\nstart_dt = max_gap_start.to_datetime()\nend_dt = max_gap_end.to_datetime()\nprint(\n    f\"  Start: {start_dt[0]}-{start_dt[1]:02d}-{start_dt[2]:02d} {start_dt[3]:02d}:{start_dt[4]:02d}:{start_dt[5]:02.0f}\"\n)\nprint(\n    f\"  End: {end_dt[0]}-{end_dt[1]:02d}-{end_dt[2]:02d} {end_dt[3]:02d}:{end_dt[4]:02d}:{end_dt[5]:02.0f}\"\n)\n\n# Propagate satellite for full 24 hours to get complete trajectory\nprop.propagate_to(search_end)\nfull_traj = prop.trajectory\n\n# Extract ground track segment during maximum gap\n# Get states and epochs from trajectory\nstates = full_traj.to_matrix()\nepochs = full_traj.epochs()\n\n# Find indices corresponding to gap period\ngap_states = []\ngap_epochs = []\ngap_lons = []\ngap_lats = []\n\nfor i, ep in enumerate(epochs):\n    if max_gap_start &lt;= ep &lt;= max_gap_end:\n        gap_epochs.append(ep)\n        gap_states.append(states[i])\n\n        # Convert to geodetic coordinates\n        ecef_state = bh.state_eci_to_ecef(ep, states[i])\n        lon, lat, alt = bh.position_ecef_to_geodetic(\n            ecef_state[:3], bh.AngleFormat.RADIANS\n        )\n        gap_lons.append(np.degrees(lon))\n        gap_lats.append(np.degrees(lat))\n\nprint(f\"  Points in gap segment: {len(gap_lons)}\")\n\n# Split ground track at antimeridian crossings for proper plotting\nsegments = bh.split_ground_track_at_antimeridian(gap_lons, gap_lats)\nprint(f\"  Track segments (after wraparound split): {len(segments)}\")\n\n# Create base plot with stations only (no full trajectory)\nfig = bh.plot_groundtrack(\n    ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n    gs_cone_altitude=420e3,\n    gs_min_elevation=10.0,\n    basemap=\"stock\",\n    show_borders=False,\n    show_coastlines=False,\n    backend=\"matplotlib\",\n)\n\n# Plot only the maximum gap segment in red using custom plotting\nax = fig.get_axes()[0]\nfor i, (lon_seg, lat_seg) in enumerate(segments):\n    ax.plot(\n        lon_seg,\n        lat_seg,\n        color=\"red\",\n        linewidth=3,\n        transform=ccrs.Geodetic(),\n        zorder=10,\n        label=\"Max Gap\" if i == 0 else \"\",\n    )\n\n# Add legend\nax.legend(loc=\"lower left\")\n\n# Add title with gap duration\nax.set_title(\n    f\"ISS Maximum Coverage Gap: {max_gap_duration / 60.0:.1f} minutes\\n\"\n    f\"NASA NEN Network (10\u00b0 elevation)\",\n    fontsize=12,\n)\n\n# Save light mode\nfig.savefig(OUTDIR / f\"{SCRIPT_NAME}_light.svg\", dpi=300, bbox_inches=\"tight\")\nprint(f\"\\n\u2713 Generated {SCRIPT_NAME}_light.svg\")\nplt.close(fig)\n\n# Create dark mode version\nwith plt.style.context(\"dark_background\"):\n    fig_dark = bh.plot_groundtrack(\n        ground_stations=[{\"stations\": nen_stations, \"color\": \"blue\", \"alpha\": 0.2}],\n        gs_cone_altitude=420e3,\n        gs_min_elevation=10.0,\n        basemap=\"stock\",\n        show_borders=False,\n        show_coastlines=False,\n        backend=\"matplotlib\",\n    )\n\n    # Plot only the maximum gap segment\n    ax_dark = fig_dark.get_axes()[0]\n    for i, (lon_seg, lat_seg) in enumerate(segments):\n        ax_dark.plot(\n            lon_seg,\n            lat_seg,\n            color=\"red\",\n            linewidth=3,\n            transform=ccrs.Geodetic(),\n            zorder=10,\n            label=\"Max Gap\" if i == 0 else \"\",\n        )\n\n    ax_dark.legend(loc=\"lower left\")\n    ax_dark.set_title(\n        f\"ISS Maximum Coverage Gap: {max_gap_duration / 60.0:.1f} minutes\\n\"\n        f\"NASA NEN Network (10\u00b0 elevation)\",\n        fontsize=12,\n    )\n\n    # Set dark background\n    fig_dark.patch.set_facecolor(\"#1c1e24\")\n    for ax in fig_dark.get_axes():\n        ax.set_facecolor(\"#1c1e24\")\n\n    fig_dark.savefig(OUTDIR / f\"{SCRIPT_NAME}_dark.svg\", dpi=300, bbox_inches=\"tight\")\n    print(f\"\u2713 Generated {SCRIPT_NAME}_dark.svg\")\n    plt.close(fig_dark)\n</code></pre> <p>This example uses the <code>split_ground_track_at_antimeridian()</code> helper function to properly handle longitude wraparound when plotting custom ground track segments. The helper function detects jumps across the \u00b1180\u00b0 boundary and splits the track into separate segments for correct rendering.</p>"},{"location":"learn/plots/ground_tracks.html#additional-features","title":"Additional Features","text":""},{"location":"learn/plots/ground_tracks.html#coverage-zones","title":"Coverage Zones","text":"<p>Add polygon zones for restricted areas, target regions, or sensor footprints:</p> <pre><code>import numpy as np\n\n# Define a restricted zone\nvertices = [\n    (np.radians(30.0), np.radians(-100.0)),  # lat, lon\n    (np.radians(35.0), np.radians(-100.0)),\n    (np.radians(35.0), np.radians(-95.0)),\n    (np.radians(30.0), np.radians(-95.0))\n]\nzone = bh.PolygonLocation(vertices)\n\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    zones=[{\n        \"zone\": zone,\n        \"fill\": True,\n        \"fill_color\": \"red\",\n        \"fill_alpha\": 0.2,\n        \"edge\": True,\n        \"edge_color\": \"red\"\n    }]\n)\n</code></pre>"},{"location":"learn/plots/ground_tracks.html#map-extent","title":"Map Extent","text":"<p>Zoom into specific regions using the <code>extent</code> parameter:</p> <pre><code># Focus on North America\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj}],\n    extent=[-130, -60, 20, 50],  # [lon_min, lon_max, lat_min, lat_max]\n    backend=\"matplotlib\"\n)\n</code></pre>"},{"location":"learn/plots/ground_tracks.html#tips","title":"Tips","text":"<ul> <li>Use <code>backend=\"plotly\"</code> for interactive exploration and presentations</li> <li>Use <code>backend=\"matplotlib\"</code> for publication-quality static figures</li> <li>Set <code>gs_cone_altitude</code> to your satellite's altitude for accurate coverage visualization</li> <li>Adjust <code>gs_min_elevation</code> based on antenna pointing constraints (typically 5-15\u00b0)</li> <li>Use <code>extent</code> parameter to zoom into specific regions of interest</li> <li>Control displayed track length with <code>track_length</code> and <code>track_units</code> parameters</li> <li>Use <code>split_ground_track_at_antimeridian()</code> when creating custom ground track overlays to handle longitude wraparound</li> <li>Choose basemap style based on your audience: <code>\"natural_earth\"</code> for presentations, <code>\"stock\"</code> for quick analysis, <code>None</code> for minimal distraction</li> </ul>"},{"location":"learn/plots/ground_tracks.html#see-also","title":"See Also","text":"<ul> <li>plot_groundtrack API Reference - Complete function documentation</li> <li>split_ground_track_at_antimeridian API Reference - Wraparound handling</li> <li>Access Geometry - Detailed visibility analysis</li> <li>PointLocation - Ground station definitions</li> <li>PolygonLocation - Zone definitions</li> </ul>"},{"location":"learn/plots/orbital_trajectories.html","title":"Orbital Element Trajectories","text":"<p>Orbital element trajectory plots track how position, velocity, and orbital parameters evolve over time. Brahe provides two complementary views: Cartesian plots showing state vectors (x, y, z, vx, vy, vz) and Keplerian plots showing classical elements (a, e, i, \u03a9, \u03c9, \u03bd). These visualizations are essential for analyzing perturbations, verifying propagators, and understanding orbital dynamics.</p>"},{"location":"learn/plots/orbital_trajectories.html#cartesian-state-vector-plots","title":"Cartesian State Vector Plots","text":"<p>Cartesian plots display position and velocity components in ECI coordinates, useful for debugging propagators and analyzing state evolution.</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-cartesian-plot-plotly","title":"Interactive Cartesian Plot (Plotly)","text":"Plot Source cartesian_trajectory_plotly.py<pre><code>\"\"\"\nCartesian Trajectory Plot Example - Plotly Backend\n\nThis script demonstrates how to plot Cartesian state elements (x, y, z, vx, vy, vz) vs time\nusing the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period\nepoch = prop.epoch\nduration = bh.orbital_period(prop.semi_major_axis)\nprint(f\"Propagating from {epoch} for {duration} seconds.\")\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Cartesian trajectory plot\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-cartesian-plot-matplotlib","title":"Static Cartesian Plot (Matplotlib)","text":"Plot Source cartesian_trajectory_matplotlib.py<pre><code>\"\"\"\nCartesian Trajectory Plot Example - Matplotlib Backend\n\nThis script demonstrates how to plot Cartesian state elements (x, y, z, vx, vy, vz) vs time\nusing the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = bh.orbital_period(prop.semi_major_axis)\nprint(f\"Propagating from {epoch} for {duration} seconds.\")\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Cartesian trajectory plot in light mode\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_cartesian_trajectory_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Cartesian trajectory plot (matplotlib, light mode) saved to: docs/figures/plot_cartesian_trajectory_matplotlib_light.svg\"\n)\n\n# Create Cartesian trajectory plot in dark mode\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"blue\", \"label\": \"ISS\"}],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/plot_cartesian_trajectory_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Cartesian trajectory plot (matplotlib, dark mode) saved to: docs/figures/plot_cartesian_trajectory_matplotlib_dark.svg\"\n)\n</code></pre> <p>The 2\u00d73 subplot layout shows:</p> <ul> <li>Top row: x, y, z position components (km)</li> <li>Bottom row: vx, vy, vz velocity components (km/s)</li> </ul> <p>For circular orbits, you'll see sinusoidal patterns. Elliptical orbits show variations in velocity magnitude.</p>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-orbital-element-plots","title":"Keplerian Orbital Element Plots","text":"<p>Keplerian plots display classical orbital elements, ideal for understanding long-term evolution and perturbation effects.</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-keplerian-plot-plotly","title":"Interactive Keplerian Plot (Plotly)","text":"Plot Source keplerian_trajectory_plotly.py<pre><code>\"\"\"\nKeplerian Trajectory Plot Example - Plotly Backend\n\nThis script demonstrates how to plot Keplerian orbital elements (a, e, i, \u03a9, \u03c9, \u03bd) vs time\nusing the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Keplerian trajectory plot\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"plotly\",\n    plotly_config={\"set_angle_ylim\": True},\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-keplerian-plot-matplotlib","title":"Static Keplerian Plot (Matplotlib)","text":"Plot Source keplerian_trajectory_matplotlib.py<pre><code>\"\"\"\nKeplerian Trajectory Plot Example - Matplotlib Backend\n\nThis script demonstrates how to plot Keplerian orbital elements (a, e, i, \u03a9, \u03c9, \u03bd) vs time\nusing the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\n\n# Define time range for one orbital period (~92 minutes for ISS)\nepoch = prop.epoch\nduration = 92.0 * 60.0  # seconds\n\n# Generate trajectory by propagating\nprop.propagate_to(epoch + duration)\ntraj = prop.trajectory\n\n# Create Keplerian trajectory plot in light mode\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False, \"set_angle_ylim\": True},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/plot_keplerian_trajectory_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Keplerian trajectory plot (matplotlib, light mode) saved to: docs/figures/plot_keplerian_trajectory_matplotlib_light.svg\"\n)\n\n# Create Keplerian trajectory plot in dark mode\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"color\": \"green\", \"label\": \"ISS\"}],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True, \"set_angle_ylim\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/plot_keplerian_trajectory_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Keplerian trajectory plot (matplotlib, dark mode) saved to: docs/figures/plot_keplerian_trajectory_matplotlib_dark.svg\"\n)\n</code></pre> <p>The 2\u00d73 subplot layout shows:</p> <ul> <li>Semi-major axis (a): Average orbital radius</li> <li>Eccentricity (e): Orbit shape (0 = circular, &gt;0 = elliptical)</li> <li>Inclination (i): Orbital plane tilt</li> <li>RAAN (\u03a9): Right ascension of ascending node</li> <li>Argument of periapsis (\u03c9): Orbit orientation in plane</li> <li>Mean anomaly (M): Position along orbit</li> </ul>"},{"location":"learn/plots/orbital_trajectories.html#comparing-different-propagators","title":"Comparing Different Propagators","text":"<p>Compare different propagators to verify agreement or identify perturbation effects. These examples show how Keplerian (two-body) and SGP4 propagators diverge over time due to atmospheric drag and other perturbations.</p> <p>The plots show how the two propagation methods diverge:</p> <ul> <li>Keplerian (blue): Assumes pure two-body dynamics with no perturbations</li> <li>SGP4 (red): Includes atmospheric drag and other perturbations</li> </ul> <p>For near-circular LEO orbits, we notice there is significant variation in the argument of perigee (\u03c9) and mean anomaly (M) over time due to numerical instability and ill-conditioning of these elements for near-circular orbits.</p>"},{"location":"learn/plots/orbital_trajectories.html#cartesian-state-comparison","title":"Cartesian State Comparison","text":"<p>Comparing propagators in Cartesian space shows position and velocity component differences:</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-cartesian-comparison-plotly","title":"Interactive Cartesian Comparison (Plotly)","text":"Plot Source comparing_propagators_cartesian_plotly.py<pre><code>\"\"\"\nComparing Propagators (Cartesian) Example - Plotly Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Cartesian state trajectories side-by-side using the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial state\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\nprint(\n    f\"Propagating from {epoch} for {duration:.0f} seconds ({duration / 3600:.1f} hours).\"\n)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"plotly\",\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-cartesian-comparison-matplotlib","title":"Static Cartesian Comparison (Matplotlib)","text":"Plot Source comparing_propagators_cartesian_matplotlib.py<pre><code>\"\"\"\nComparing Propagators (Cartesian) Example - Matplotlib Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Cartesian state trajectories side-by-side using the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial state\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\nprint(\n    f\"Propagating from {epoch} for {duration:.0f} seconds ({duration / 3600:.1f} hours).\"\n)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\nprint(f\"Keplerian trajectory: {len(traj_kep)} states\")\nprint(f\"SGP4 trajectory: {len(traj_sgp)} states\")\n\n# Create comparison plot in light mode\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": False},\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_cartesian_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Cartesian) plot (matplotlib, light mode) saved to: docs/figures/comparing_propagators_cartesian_matplotlib_light.svg\"\n)\n\n# Create comparison plot in dark mode\nfig = bh.plot_cartesian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    position_units=\"km\",\n    velocity_units=\"km/s\",\n    backend=\"matplotlib\",\n    matplotlib_config={\"dark_mode\": True},\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_cartesian_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Cartesian) plot (matplotlib, dark mode) saved to: docs/figures/comparing_propagators_cartesian_matplotlib_dark.svg\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-element-comparison","title":"Keplerian Element Comparison","text":"<p>Comparing propagators using Keplerian elements reveals how orbital parameters evolve differently:</p>"},{"location":"learn/plots/orbital_trajectories.html#interactive-keplerian-comparison-plotly","title":"Interactive Keplerian Comparison (Plotly)","text":"Plot Source comparing_propagators_keplerian_plotly.py<pre><code>\"\"\"\nComparing Propagators (Keplerian) Example - Plotly Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Keplerian element trajectories side-by-side using the plotly backend for interactive visualization.\n\"\"\"\n\nimport os\nimport pathlib\nimport sys\nimport brahe as bh\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent.parent.parent))\nfrom brahe_theme import save_themed_html\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Create Keplerian propagator with same initial Cartesian state as SGP4\n# This ensures both propagators store states in the same representation (Cartesian)\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, prop_sgp.state_eci(epoch), 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot using Keplerian elements with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": prop_kep.trajectory, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": prop_sgp.trajectory, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"plotly\",\n    plotly_config={\"set_angle_ylim\": True, \"set_eccentricity_ylim\": True},\n)\n\n# Save themed HTML files\nlight_path, dark_path = save_themed_html(fig, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#static-keplerian-comparison-matplotlib","title":"Static Keplerian Comparison (Matplotlib)","text":"Plot Source comparing_propagators_keplerian_matplotlib.py<pre><code>\"\"\"\nComparing Propagators (Keplerian) Example - Matplotlib Backend\n\nThis script demonstrates how to compare different propagators (Keplerian vs SGP4)\nby plotting their Keplerian element trajectories side-by-side using the matplotlib backend.\n\"\"\"\n\nimport brahe as bh\n\n# Initialize EOP data\nbh.initialize_eop()\n\n# ISS TLE for November 3, 2025\ntle_line0 = \"ISS (ZARYA)\"\ntle_line1 = \"1 25544U 98067A   25306.42331346  .00010070  00000-0  18610-3 0  9999\"\ntle_line2 = \"2 25544  51.6344 342.0717 0004969   8.9436 351.1640 15.49700017536601\"\n\n# Create SGP4 propagator\nprop_sgp = bh.SGPPropagator.from_3le(tle_line0, tle_line1, tle_line2, 60.0)\nepoch = prop_sgp.epoch\n\n# Get initial Cartesian state from SGP4 propagator for Keplerian propagator\n# Using state_eci() to ensure we get Cartesian coordinates\ninitial_state = prop_sgp.state_eci(epoch)\n\n# Create Keplerian propagator with same initial Cartesian state\n# This ensures both propagators store states in the same representation (Cartesian)\nprop_kep = bh.KeplerianPropagator.from_eci(epoch, initial_state, 60.0)\n\n# Propagate both for 4 orbital periods to see differences\nduration = 4 * bh.orbital_period(prop_sgp.semi_major_axis)\n\n# Propagate both propagators\nprop_kep.propagate_to(epoch + duration)\nprop_sgp.propagate_to(epoch + duration)\n\n# Get trajectories\ntraj_kep = prop_kep.trajectory\ntraj_sgp = prop_sgp.trajectory\n\n# Create comparison plot using Keplerian elements in light mode with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\n        \"dark_mode\": False,\n        \"set_angle_ylim\": True,\n        \"set_eccentricity_ylim\": True,\n    },\n)\n\n# Save light mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_keplerian_matplotlib_light.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Keplerian) plot (matplotlib, light mode) saved to: docs/figures/comparing_propagators_keplerian_matplotlib_light.svg\"\n)\n\n# Create comparison plot using Keplerian elements in dark mode with fixed angle and eccentricity limits\nfig = bh.plot_keplerian_trajectory(\n    [\n        {\"trajectory\": traj_kep, \"color\": \"blue\", \"label\": \"Keplerian\"},\n        {\"trajectory\": traj_sgp, \"color\": \"red\", \"label\": \"SGP4\"},\n    ],\n    sma_units=\"km\",\n    angle_units=\"deg\",\n    backend=\"matplotlib\",\n    matplotlib_config={\n        \"dark_mode\": True,\n        \"set_angle_ylim\": True,\n        \"set_eccentricity_ylim\": True,\n    },\n)\n\n# Set background color to match Plotly dark theme\nfig.patch.set_facecolor(\"#1c1e24\")\nfor ax in fig.get_axes():\n    ax.set_facecolor(\"#1c1e24\")\n\n# Save dark mode figure\nfig.savefig(\n    \"docs/figures/comparing_propagators_keplerian_matplotlib_dark.svg\",\n    dpi=300,\n    bbox_inches=\"tight\",\n)\nprint(\n    \"Comparing propagators (Keplerian) plot (matplotlib, dark mode) saved to: docs/figures/comparing_propagators_keplerian_matplotlib_dark.svg\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#unit-customization","title":"Unit Customization","text":""},{"location":"learn/plots/orbital_trajectories.html#cartesian-plots","title":"Cartesian Plots","text":"<pre><code># Meters and m/s\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj}],\n    position_units=\"m\",\n    velocity_units=\"m/s\"\n)\n\n# Kilometers and km/s (default)\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj}],\n    position_units=\"km\",\n    velocity_units=\"km/s\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#keplerian-plots","title":"Keplerian Plots","text":"<pre><code># Degrees (default)\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj}],\n    sma_units=\"km\",\n    angle_units=\"deg\"\n)\n\n# Radians\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj}],\n    sma_units=\"km\",\n    angle_units=\"rad\"\n)\n</code></pre>"},{"location":"learn/plots/orbital_trajectories.html#see-also","title":"See Also","text":"<ul> <li>plot_cartesian_trajectory API Reference</li> <li>plot_keplerian_trajectory API Reference</li> <li>3D Trajectories - Spatial visualization</li> <li>Orbital Anomalies - Understanding orbital parameters</li> <li>Propagators - Orbit propagation</li> </ul>"},{"location":"learn/relative_motion/index.html","title":"Relative Motion","text":"<p>The relative motion module provides tools for working with satellite state representations, relative motion frames, and relative dynamics models. </p>"},{"location":"learn/relative_motion/index.html#see-also","title":"See Also","text":"<ul> <li>RTN Transformations API Reference - Detailed API documentation</li> </ul>"},{"location":"learn/relative_motion/roe_transformations.html","title":"Relative Orbital Elements (ROE) Transformations","text":"<p>Relative Orbital Elements (ROE) provide a quasi-nonsingular mean description of the relative motion between two satellites in close proximity. ROE are particularly useful for formation flying and proximity operations, where maintaining specific relative geometries is important.</p> <p>Unlike instantaneous Cartesian relative states (like RTN coordinates), ROE describe the relative orbit using orbital elements, meaning that only a single element, the relative longitude \\(d\\lambda\\), is quickly changing over time. This makes ROE ideal for long-term formation design and control.</p>"},{"location":"learn/relative_motion/roe_transformations.html#roe-definition","title":"ROE Definition","text":"<p>The ROE vector contains six dimensionless or angular elements that are constructed from the classical orbital elements of the chief and deputy satellites:</p> \\[ \\begin{align*} \\delta a &amp; = \\frac{a_d - a_c}{a_c} \\\\ \\delta \\lambda &amp; = (M_d + \\omega_d) - (M_c + \\omega_c) + (\\Omega_d - \\Omega_c) \\cos i_c \\\\ \\delta e_x &amp; = e_d \\cos \\omega_d - e_c \\cos \\omega_c \\\\ \\delta e_y &amp; = e_d \\sin \\omega_d - e_c \\sin \\omega_c \\\\ \\delta i_x &amp; = i_d - i_c \\\\ \\delta i_y &amp; = (\\Omega_d - \\Omega_c) \\sin i_c \\end{align*} \\] <p>The elements are: - \\(\\delta a\\) - relative semi-major axis (dimensionless) - \\(\\delta \\lambda\\) - relative mean longitude (radians) - \\(\\delta e_x\\), \\(\\delta e_y\\) - components of the relative eccentricity vector (dimensionless) - \\(\\delta i_x\\), \\(\\delta i_y\\) - components of the relative inclination vector (radians)</p>"},{"location":"learn/relative_motion/roe_transformations.html#key-properties","title":"Key Properties","text":"<p>Nonsingularity: ROE remain well-defined for circular and near-circular orbits, unlike classical orbital elements which become singular as eccentricity approaches zero.</p> <p>Periodic Orbits: Specific ROE configurations produce periodic or quasi-periodic relative orbits:</p> <ul> <li>Setting \\(\\delta a = 0\\) prevents along-track drift</li> <li>The eccentricity vector components (\\(\\delta e_x\\), \\(\\delta e_y\\)) control in-plane motion</li> <li>The inclination vector components (\\(\\delta i_x\\), \\(\\delta i_y\\)) control cross-track motion</li> </ul>"},{"location":"learn/relative_motion/roe_transformations.html#converting-orbital-elements-to-roe","title":"Converting Orbital Elements to ROE","text":"<p>The <code>state_oe_to_roe</code> function converts the classical orbital elements of a chief and deputy satellite into ROE. This is useful when you have two satellite orbits and want to analyze their relative motion characteristics.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Define deputy satellite with small orbital element differences\n# This creates a quasi-periodic relative orbit\noe_deputy = np.array(\n    [\n        bh.R_EARTH + 701e3,  # 1 km higher semi-major axis\n        0.0015,  # Slightly higher eccentricity\n        97.85,  # 0.05\u00b0 higher inclination\n        15.05,  # Small RAAN difference\n        30.05,  # Small argument of perigee difference\n        45.05,  # Small mean anomaly difference\n    ]\n)\n\n# Convert to Relative Orbital Elements (ROE)\nroe = bh.state_oe_to_roe(oe_chief, oe_deputy, bh.AngleFormat.DEGREES)\n\nprint(\"Relative Orbital Elements (ROE):\")\nprint(f\"da (relative SMA):        {roe[0]:.6e}\")\nprint(f\"d\u03bb (relative mean long):  {roe[1]:.6f}\u00b0\")\nprint(f\"dex (rel ecc x-comp):     {roe[2]:.6e}\")\nprint(f\"dey (rel ecc y-comp):     {roe[3]:.6e}\")\nprint(f\"dix (rel inc x-comp):     {roe[4]:.6f}\u00b0\")\nprint(f\"diy (rel inc y-comp):     {roe[5]:.6f}\u00b0\")\n# Relative Orbital Elements (ROE):\n# da (relative SMA):        1.412801e-4\n# d\u03bb (relative mean long):  0.093214\u00b0\n# dex (rel ecc x-comp):     4.323577e-4\n# dey (rel ecc y-comp):     2.511333e-4\n# dix (rel inc x-comp):     0.050000\u00b0\n# diy (rel inc y-comp):     0.049537\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of perigee (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Define deputy satellite with small orbital element differences\n    // This creates a quasi-periodic relative orbit\n    let oe_deputy = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 701e3,  // 1 km higher semi-major axis\n        0.0015,               // Slightly higher eccentricity\n        97.85,                // 0.05\u00b0 higher inclination\n        15.05,                // Small RAAN difference\n        30.05,                // Small argument of perigee difference\n        45.05                 // Small mean anomaly difference\n    );\n\n    // Convert to Relative Orbital Elements (ROE)\n    let roe = bh::state_oe_to_roe(oe_chief, oe_deputy, bh::AngleFormat::Degrees);\n\n    println!(\"Relative Orbital Elements (ROE):\");\n    println!(\"da (relative SMA):        {:.6e}\", roe[0]);\n    println!(\"d\u03bb (relative mean long):  {:.6}\u00b0\", roe[1]);\n    println!(\"dex (rel ecc x-comp):     {:.6e}\", roe[2]);\n    println!(\"dey (rel ecc y-comp):     {:.6e}\", roe[3]);\n    println!(\"dix (rel inc x-comp):     {:.6}\u00b0\", roe[4]);\n    println!(\"diy (rel inc y-comp):     {:.6}\u00b0\", roe[5]);\n    // Relative Orbital Elements (ROE):\n    // da (relative SMA):        1.412801e-4\n    // d\u03bb (relative mean long):  0.093214\u00b0\n    // dex (rel ecc x-comp):     4.323577e-4\n    // dey (rel ecc y-comp):     2.511333e-4\n    // dix (rel inc x-comp):     0.050000\u00b0\n    // diy (rel inc y-comp):     0.049537\u00b0\n}\n</code></pre>"},{"location":"learn/relative_motion/roe_transformations.html#converting-roe-to-deputy-orbital-elements","title":"Converting ROE to Deputy Orbital Elements","text":"<p>The <code>state_roe_to_oe</code> function performs the inverse operation: given the chief's orbital elements and the desired ROE, it computes the deputy's orbital elements. This is essential for:</p> <ul> <li>Initializing formation flying missions with desired relative geometries</li> <li>Retargeting maneuvers to achieve new relative configurations</li> <li>Propagating relative orbits using element-based propagators</li> </ul> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Define Relative Orbital Elements (ROE)\n# These describe a quasi-periodic relative orbit\nroe = np.array(\n    [\n        1.412801e-4,  # da: Relative semi-major axis\n        0.093214,  # d\u03bb: Relative mean longitude (deg)\n        4.323577e-4,  # dex: x-component of relative eccentricity vector\n        2.511333e-4,  # dey: y-component of relative eccentricity vector\n        0.050000,  # dix: x-component of relative inclination vector (deg)\n        0.049537,  # diy: y-component of relative inclination vector (deg)\n    ]\n)\n\n# Convert to deputy satellite orbital elements\noe_deputy = bh.state_roe_to_oe(oe_chief, roe, bh.AngleFormat.DEGREES)\n\nprint(\"Deputy Satellite Orbital Elements:\")\nprint(\n    f\"Semi-major axis: {oe_deputy[0]:.3f} m ({(oe_deputy[0] - bh.R_EARTH) / 1000:.1f} km alt)\"\n)\nprint(f\"Eccentricity:    {oe_deputy[1]:.6f}\")\nprint(f\"Inclination:     {oe_deputy[2]:.4f}\u00b0\")\nprint(f\"RAAN:            {oe_deputy[3]:.4f}\u00b0\")\nprint(f\"Arg of perigee:  {oe_deputy[4]:.4f}\u00b0\")\nprint(f\"Mean anomaly:    {oe_deputy[5]:.4f}\u00b0\")\n# Deputy Satellite Orbital Elements:\n# Semi-major axis: 7079136.300 m (701.0 km alt)\n# Eccentricity:    0.001500\n# Inclination:     97.8500\u00b0\n# RAAN:            15.0500\u00b0\n# Arg of perigee:  30.0500\u00b0\n# Mean anomaly:    45.0500\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of perigee (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Define Relative Orbital Elements (ROE)\n    // These describe a quasi-periodic relative orbit\n    let roe = na::SVector::&lt;f64, 6&gt;::new(\n        1.412801e-4,   // da: Relative semi-major axis\n        0.093214,      // d\u03bb: Relative mean longitude (deg)\n        4.323577e-4,   // dex: x-component of relative eccentricity vector\n        2.511333e-4,   // dey: y-component of relative eccentricity vector\n        0.050000,      // dix: x-component of relative inclination vector (deg)\n        0.049537       // diy: y-component of relative inclination vector (deg)\n    );\n\n    // Convert to deputy satellite orbital elements\n    let oe_deputy = bh::state_roe_to_oe(oe_chief, roe, bh::AngleFormat::Degrees);\n\n    println!(\"Deputy Satellite Orbital Elements:\");\n    println!(\"Semi-major axis: {:.3} m ({:.1} km alt)\", oe_deputy[0], (oe_deputy[0] - bh::R_EARTH)/1000.0);\n    println!(\"Eccentricity:    {:.6}\", oe_deputy[1]);\n    println!(\"Inclination:     {:.4}\u00b0\", oe_deputy[2]);\n    println!(\"RAAN:            {:.4}\u00b0\", oe_deputy[3]);\n    println!(\"Arg of perigee:  {:.4}\u00b0\", oe_deputy[4]);\n    println!(\"Mean anomaly:    {:.4}\u00b0\", oe_deputy[5]);\n    // Deputy Satellite Orbital Elements:\n    // Semi-major axis: 7079136.300 m (701.0 km alt)\n    // Eccentricity:    0.001500\n    // Inclination:     97.8500\u00b0\n    // RAAN:            15.0500\u00b0\n    // Arg of perigee:  30.0500\u00b0\n    // Mean anomaly:    45.0500\u00b0\n}\n</code></pre>"},{"location":"learn/relative_motion/roe_transformations.html#direct-eci-state-to-roe-conversion","title":"Direct ECI State to ROE Conversion","text":"<p>In many practical applications, satellite states are available as Cartesian ECI vectors rather than orbital elements. The <code>state_eci_to_roe</code> function provides a convenient way to compute ROE directly from the ECI states of the chief and deputy satellites, internally handling the conversion to orbital elements.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Define deputy satellite with small orbital element differences\n# This creates a quasi-periodic relative orbit\noe_deputy = np.array(\n    [\n        bh.R_EARTH + 701e3,  # 1 km higher semi-major axis\n        0.0015,  # Slightly higher eccentricity\n        97.85,  # 0.05 deg higher inclination\n        15.05,  # Small RAAN difference\n        30.05,  # Small argument of perigee difference\n        45.05,  # Small mean anomaly difference\n    ]\n)\n\n# Convert orbital elements to ECI state vectors\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\nx_deputy = bh.state_koe_to_eci(oe_deputy, bh.AngleFormat.DEGREES)\n\nprint(\"Chief ECI State:\")\nprint(f\"  Position: [{x_chief[0]:.3f}, {x_chief[1]:.3f}, {x_chief[2]:.3f}] m\")\nprint(f\"  Velocity: [{x_chief[3]:.3f}, {x_chief[4]:.3f}, {x_chief[5]:.3f}] m/s\")\n\nprint(\"\\nDeputy ECI State:\")\nprint(f\"  Position: [{x_deputy[0]:.3f}, {x_deputy[1]:.3f}, {x_deputy[2]:.3f}] m\")\nprint(f\"  Velocity: [{x_deputy[3]:.3f}, {x_deputy[4]:.3f}, {x_deputy[5]:.3f}] m/s\")\n\n# Convert ECI states directly to Relative Orbital Elements (ROE)\nroe = bh.state_eci_to_roe(x_chief, x_deputy, bh.AngleFormat.DEGREES)\n\nprint(\"\\nRelative Orbital Elements (ROE):\")\nprint(f\"  da (relative SMA):        {roe[0]:.6e}\")\nprint(f\"  d_lambda (relative mean long):  {roe[1]:.6f} deg\")\nprint(f\"  dex (rel ecc x-comp):     {roe[2]:.6e}\")\nprint(f\"  dey (rel ecc y-comp):     {roe[3]:.6e}\")\nprint(f\"  dix (rel inc x-comp):     {roe[4]:.6f} deg\")\nprint(f\"  diy (rel inc y-comp):     {roe[5]:.6f} deg\")\n# Chief ECI State:\n#   Position: [4652982.458, 1200261.918, 5093905.755] m\n#   Velocity: [-5189.098, 3310.839, 4550.927] m/s\n#\n# Deputy ECI State:\n#   Position: [4654145.691, 1200531.587, 5095024.654] m\n#   Velocity: [-5189.999, 3311.448, 4550.982] m/s\n#\n# Relative Orbital Elements (ROE):\n#   da (relative SMA):        1.412801e-04\n#   d_lambda (relative mean long):  0.093214 deg\n#   dex (rel ecc x-comp):     4.323577e-04\n#   dey (rel ecc y-comp):     2.511333e-04\n#   dix (rel inc x-comp):     0.050000 deg\n#   diy (rel inc y-comp):     0.049537 deg\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3, // Semi-major axis (m)\n        0.001,               // Eccentricity\n        97.8,                // Inclination (deg)\n        15.0,                // Right ascension of ascending node (deg)\n        30.0,                // Argument of perigee (deg)\n        45.0,                // Mean anomaly (deg)\n    );\n\n    // Define deputy satellite with small orbital element differences\n    // This creates a quasi-periodic relative orbit\n    let oe_deputy = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 701e3, // 1 km higher semi-major axis\n        0.0015,              // Slightly higher eccentricity\n        97.85,               // 0.05 deg higher inclination\n        15.05,               // Small RAAN difference\n        30.05,               // Small argument of perigee difference\n        45.05,               // Small mean anomaly difference\n    );\n\n    // Convert orbital elements to ECI state vectors\n    let x_chief = bh::coordinates::state_koe_to_eci(oe_chief, bh::AngleFormat::Degrees);\n    let x_deputy = bh::coordinates::state_koe_to_eci(oe_deputy, bh::AngleFormat::Degrees);\n\n    println!(\"Chief ECI State:\");\n    println!(\n        \"  Position: [{:.3}, {:.3}, {:.3}] m\",\n        x_chief[0], x_chief[1], x_chief[2]\n    );\n    println!(\n        \"  Velocity: [{:.3}, {:.3}, {:.3}] m/s\",\n        x_chief[3], x_chief[4], x_chief[5]\n    );\n\n    println!(\"\\nDeputy ECI State:\");\n    println!(\n        \"  Position: [{:.3}, {:.3}, {:.3}] m\",\n        x_deputy[0], x_deputy[1], x_deputy[2]\n    );\n    println!(\n        \"  Velocity: [{:.3}, {:.3}, {:.3}] m/s\",\n        x_deputy[3], x_deputy[4], x_deputy[5]\n    );\n\n    // Convert ECI states directly to Relative Orbital Elements (ROE)\n    let roe = bh::relative_motion::state_eci_to_roe(x_chief, x_deputy, bh::AngleFormat::Degrees);\n\n    println!(\"\\nRelative Orbital Elements (ROE):\");\n    println!(\"  da (relative SMA):        {:.6e}\", roe[0]);\n    println!(\"  d_lambda (relative mean long):  {:.6} deg\", roe[1]);\n    println!(\"  dex (rel ecc x-comp):     {:.6e}\", roe[2]);\n    println!(\"  dey (rel ecc y-comp):     {:.6e}\", roe[3]);\n    println!(\"  dix (rel inc x-comp):     {:.6} deg\", roe[4]);\n    println!(\"  diy (rel inc y-comp):     {:.6} deg\", roe[5]);\n\n    // Expected output:\n    // Chief ECI State:\n    //   Position: [4652982.458, 1200261.918, 5093905.755] m\n    //   Velocity: [-5189.098, 3310.839, 4550.927] m/s\n    //\n    // Deputy ECI State:\n    //   Position: [4654145.691, 1200531.587, 5095024.654] m\n    //   Velocity: [-5189.999, 3311.448, 4550.982] m/s\n    //\n    // Relative Orbital Elements (ROE):\n    //   da (relative SMA):        1.412801e-04\n    //   d_lambda (relative mean long):  0.093214 deg\n    //   dex (rel ecc x-comp):     4.323577e-04\n    //   dey (rel ecc y-comp):     2.511333e-04\n    //   dix (rel inc x-comp):     0.050000 deg\n    //   diy (rel inc y-comp):     0.049537 deg\n}\n</code></pre>"},{"location":"learn/relative_motion/roe_transformations.html#converting-roe-to-deputy-eci-state","title":"Converting ROE to Deputy ECI State","text":"<p>The inverse operation, <code>state_roe_to_eci</code>, computes the deputy satellite's ECI state from the chief's ECI state and the ROE.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert chief orbital elements to ECI state\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\n\nprint(\"Chief ECI State:\")\nprint(f\"  Position: [{x_chief[0]:.3f}, {x_chief[1]:.3f}, {x_chief[2]:.3f}] m\")\nprint(f\"  Velocity: [{x_chief[3]:.3f}, {x_chief[4]:.3f}, {x_chief[5]:.3f}] m/s\")\n\n# Define Relative Orbital Elements (ROE)\n# This defines a small relative orbit around the chief\nroe = np.array(\n    [\n        1.413e-4,  # da: relative semi-major axis (dimensionless)\n        0.093,  # d_lambda: relative mean longitude (deg)\n        4.324e-4,  # dex: relative eccentricity x-component\n        2.511e-4,  # dey: relative eccentricity y-component\n        0.05,  # dix: relative inclination x-component (deg)\n        0.05,  # diy: relative inclination y-component (deg)\n    ]\n)\n\nprint(\"\\nRelative Orbital Elements (ROE):\")\nprint(f\"  da (relative SMA):        {roe[0]:.6e}\")\nprint(f\"  d_lambda (relative mean long):  {roe[1]:.6f} deg\")\nprint(f\"  dex (rel ecc x-comp):     {roe[2]:.6e}\")\nprint(f\"  dey (rel ecc y-comp):     {roe[3]:.6e}\")\nprint(f\"  dix (rel inc x-comp):     {roe[4]:.6f} deg\")\nprint(f\"  diy (rel inc y-comp):     {roe[5]:.6f} deg\")\n\n# Convert chief ECI state and ROE to deputy ECI state\nx_deputy = bh.state_roe_to_eci(x_chief, roe, bh.AngleFormat.DEGREES)\n\nprint(\"\\nDeputy ECI State (computed from ROE):\")\nprint(f\"  Position: [{x_deputy[0]:.3f}, {x_deputy[1]:.3f}, {x_deputy[2]:.3f}] m\")\nprint(f\"  Velocity: [{x_deputy[3]:.3f}, {x_deputy[4]:.3f}, {x_deputy[5]:.3f}] m/s\")\n\n# Compute relative distance\nrel_pos = x_deputy[:3] - x_chief[:3]\nrel_dist = np.linalg.norm(rel_pos)\nprint(f\"\\nRelative distance: {rel_dist:.1f} m\")\n# Chief ECI State:\n#   Position: [4652982.458, 1200261.918, 5093905.755] m\n#   Velocity: [-5189.098, 3310.839, 4550.927] m/s\n#\n# Relative Orbital Elements (ROE):\n#   da (relative SMA):        1.413000e-04\n#   d_lambda (relative mean long):  0.093000 deg\n#   dex (rel ecc x-comp):     4.324000e-04\n#   dey (rel ecc y-comp):     2.511000e-04\n#   dix (rel inc x-comp):     0.050000 deg\n#   diy (rel inc y-comp):     0.050000 deg\n#\n# Deputy ECI State (computed from ROE):\n#   Position: [4654145.325, 1200531.447, 5095024.258] m\n#   Velocity: [-5189.999, 3311.448, 4550.982] m/s\n#\n# Relative distance: 1617.7 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3, // Semi-major axis (m)\n        0.001,               // Eccentricity\n        97.8,                // Inclination (deg)\n        15.0,                // Right ascension of ascending node (deg)\n        30.0,                // Argument of perigee (deg)\n        45.0,                // Mean anomaly (deg)\n    );\n\n    // Convert chief orbital elements to ECI state\n    let x_chief = bh::coordinates::state_koe_to_eci(oe_chief, bh::AngleFormat::Degrees);\n\n    println!(\"Chief ECI State:\");\n    println!(\n        \"  Position: [{:.3}, {:.3}, {:.3}] m\",\n        x_chief[0], x_chief[1], x_chief[2]\n    );\n    println!(\n        \"  Velocity: [{:.3}, {:.3}, {:.3}] m/s\",\n        x_chief[3], x_chief[4], x_chief[5]\n    );\n\n    // Define Relative Orbital Elements (ROE)\n    // This defines a small relative orbit around the chief\n    let roe = na::SVector::&lt;f64, 6&gt;::new(\n        1.413e-4, // da: relative semi-major axis (dimensionless)\n        0.093,    // d_lambda: relative mean longitude (deg)\n        4.324e-4, // dex: relative eccentricity x-component\n        2.511e-4, // dey: relative eccentricity y-component\n        0.05,     // dix: relative inclination x-component (deg)\n        0.05,     // diy: relative inclination y-component (deg)\n    );\n\n    println!(\"\\nRelative Orbital Elements (ROE):\");\n    println!(\"  da (relative SMA):        {:.6e}\", roe[0]);\n    println!(\"  d_lambda (relative mean long):  {:.6} deg\", roe[1]);\n    println!(\"  dex (rel ecc x-comp):     {:.6e}\", roe[2]);\n    println!(\"  dey (rel ecc y-comp):     {:.6e}\", roe[3]);\n    println!(\"  dix (rel inc x-comp):     {:.6} deg\", roe[4]);\n    println!(\"  diy (rel inc y-comp):     {:.6} deg\", roe[5]);\n\n    // Convert chief ECI state and ROE to deputy ECI state\n    let x_deputy = bh::relative_motion::state_roe_to_eci(x_chief, roe, bh::AngleFormat::Degrees);\n\n    println!(\"\\nDeputy ECI State (computed from ROE):\");\n    println!(\n        \"  Position: [{:.3}, {:.3}, {:.3}] m\",\n        x_deputy[0], x_deputy[1], x_deputy[2]\n    );\n    println!(\n        \"  Velocity: [{:.3}, {:.3}, {:.3}] m/s\",\n        x_deputy[3], x_deputy[4], x_deputy[5]\n    );\n\n    // Compute relative distance\n    let rel_pos = na::Vector3::new(\n        x_deputy[0] - x_chief[0],\n        x_deputy[1] - x_chief[1],\n        x_deputy[2] - x_chief[2],\n    );\n    let rel_dist = rel_pos.norm();\n    println!(\"\\nRelative distance: {:.1} m\", rel_dist);\n\n    // Expected output:\n    // Chief ECI State:\n    //   Position: [4652982.458, 1200261.918, 5093905.755] m\n    //   Velocity: [-5189.098, 3310.839, 4550.927] m/s\n    //\n    // Relative Orbital Elements (ROE):\n    //   da (relative SMA):        1.413000e-04\n    //   d_lambda (relative mean long):  0.093000 deg\n    //   dex (rel ecc x-comp):     4.324000e-04\n    //   dey (rel ecc y-comp):     2.511000e-04\n    //   dix (rel inc x-comp):     0.050000 deg\n    //   diy (rel inc y-comp):     0.050000 deg\n    //\n    // Deputy ECI State (computed from ROE):\n    //   Position: [4654145.325, 1200531.447, 5095024.258] m\n    //   Velocity: [-5189.999, 3311.448, 4550.982] m/s\n    //\n    // Relative distance: 1617.7 m\n}\n</code></pre>"},{"location":"learn/relative_motion/roe_transformations.html#references","title":"References","text":"<ol> <li>Sullivan, J. (2020). \"Nonlinear Angles-Only Orbit Estimation for Autonomous Distributed Space Systems\"</li> </ol>"},{"location":"learn/relative_motion/rtn_transformations.html","title":"RTN Transformations","text":"<p>The RTN (Radial-Tangential-Normal) frame is an orbital reference frame that moves with the satellite. It is commonly used for relative motion analysis and formation flying applications.</p> <p>The RTN frame is defined as:</p> <ul> <li>R (Radial): Points from the Earth's center to the satellite's position</li> <li>T (Tangential): Along-track direction, perpendicular to R in the orbital plane</li> <li>N (Normal): Cross-track direction, perpendicular to the orbital plane (angular momentum direction)</li> </ul>"},{"location":"learn/relative_motion/rtn_transformations.html#coordinate-system-definition","title":"Coordinate System Definition","text":"<p>The RTN frame is a right-handed coordinate system where:</p> <ul> <li>The R axis points from the center of the Earth to the satellite's position vector</li> <li>The N axis is parallel to the angular momentum vector (cross product of position and velocity)</li> <li>The T axis completes the right-handed system (it is the cross product of N and R)</li> </ul> <p>This frame is useful for:</p> <ul> <li>Describing relative positions between satellites in close proximity</li> <li>Designing proximity operations and rendezvous maneuvers</li> <li>Expressing thrust directions for orbital maneuvers</li> </ul>"},{"location":"learn/relative_motion/rtn_transformations.html#rotation-matrices","title":"Rotation Matrices","text":"<p>Brahe provides functions to compute rotation matrices between the ECI (Earth-Centered Inertial) frame and the RTN frame. These rotation matrices transform can transform vectors between the two frames.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define a satellite in LEO orbit\n# 700 km altitude, nearly circular, sun-synchronous inclination\noe = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to Cartesian ECI state\nx_eci = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Compute rotation matrices\nR_rtn_to_eci = bh.rotation_rtn_to_eci(x_eci)\nR_eci_to_rtn = bh.rotation_eci_to_rtn(x_eci)\n\nprint(\"RTN-to-ECI rotation matrix:\")\nprint(\n    f\"  [{R_rtn_to_eci[0, 0]:8.5f}, {R_rtn_to_eci[0, 1]:8.5f}, {R_rtn_to_eci[0, 2]:8.5f}]\"\n)\nprint(\n    f\"  [{R_rtn_to_eci[1, 0]:8.5f}, {R_rtn_to_eci[1, 1]:8.5f}, {R_rtn_to_eci[1, 2]:8.5f}]\"\n)\nprint(\n    f\"  [{R_rtn_to_eci[2, 0]:8.5f}, {R_rtn_to_eci[2, 1]:8.5f}, {R_rtn_to_eci[2, 2]:8.5f}]\\n\"\n)\n#   [ 0.28262, -0.92432,  0.25642]\n#   [-0.06004, -0.28384, -0.95699]\n#   [ 0.95735,  0.25507, -0.13572]\n\n# Verify orthogonality: R^T \u00d7 R = I\nidentity = R_rtn_to_eci.T @ R_rtn_to_eci\nprint(\"Orthogonality check (R^T \u00d7 R):\")\nprint(f\"  [{identity[0, 0]:8.5f}, {identity[0, 1]:8.5f}, {identity[0, 2]:8.5f}]\")\nprint(f\"  [{identity[1, 0]:8.5f}, {identity[1, 1]:8.5f}, {identity[1, 2]:8.5f}]\")\nprint(f\"  [{identity[2, 0]:8.5f}, {identity[2, 1]:8.5f}, {identity[2, 2]:8.5f}]\")\nprint(f\"Difference from identity: {np.linalg.norm(identity - np.eye(3)):.15f}\\n\")\n#   [ 1.00000,  0.00000,  0.00000]\n#   [ 0.00000,  1.00000,  0.00000]\n#   [ 0.00000,  0.00000,  1.00000]\n# Difference from identity: 0.000000000000000\n\n# Verify determinant = +1 (proper rotation matrix)\ndet = np.linalg.det(R_rtn_to_eci)\nprint(f\"Determinant (should be +1): {det:.15f}\\n\")\n# Determinant (should be +1): 1.000000000000000\n\n# Verify ECI-to-RTN is the transpose of RTN-to-ECI\nprint(\"Transpose relationship check:\")\nprint(\n    f\"||R_eci_to_rtn - R_rtn_to_eci^T||: {np.linalg.norm(R_eci_to_rtn - R_rtn_to_eci.T):.15f}\\n\"\n)\n# ||R_eci_to_rtn - R_rtn_to_eci^T||: 0.000000000000000\n\n# Example: Transform a vector from RTN to ECI\nv_rtn = np.array([1.0, 0.0, 0.0])  # Radial unit vector in RTN frame\nv_eci = R_rtn_to_eci @ v_rtn\n\nprint(\"Example transformation:\")\nprint(f\"Vector in RTN frame: [{v_rtn[0]:.3f}, {v_rtn[1]:.3f}, {v_rtn[2]:.3f}]\")\nprint(f\"Vector in ECI frame: [{v_eci[0]:.5f}, {v_eci[1]:.5f}, {v_eci[2]:.5f}]\")\nprint(f\"ECI vector magnitude: {np.linalg.norm(v_eci):.15f}\")\n# Vector in RTN frame: [1.000, 0.000, 0.000]\n# Vector in ECI frame: [0.28262, -0.06004, 0.95735]\n# ECI vector magnitude: 1.000000000000000\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define a satellite in LEO orbit\n    // 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of perigee (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Convert to Cartesian ECI state\n    let x_eci = bh::state_koe_to_eci(oe, bh::AngleFormat::Degrees);\n\n    // Compute rotation matrices\n    let r_rtn_to_eci = bh::rotation_rtn_to_eci(x_eci);\n    let r_eci_to_rtn = bh::rotation_eci_to_rtn(x_eci);\n\n    println!(\"RTN-to-ECI rotation matrix:\");\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\", r_rtn_to_eci[(0,0)], r_rtn_to_eci[(0,1)], r_rtn_to_eci[(0,2)]);\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\", r_rtn_to_eci[(1,0)], r_rtn_to_eci[(1,1)], r_rtn_to_eci[(1,2)]);\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\\n\", r_rtn_to_eci[(2,0)], r_rtn_to_eci[(2,1)], r_rtn_to_eci[(2,2)]);\n    // Expected output:\n    //   [ 0.28262, -0.92432,  0.25642]\n    //   [-0.06004, -0.28384, -0.95699]\n    //   [ 0.95735,  0.25507, -0.13572]\n\n    // Verify orthogonality: R^T \u00d7 R = I\n    let identity = r_rtn_to_eci.transpose() * r_rtn_to_eci;\n    println!(\"Orthogonality check (R^T \u00d7 R):\");\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\", identity[(0,0)], identity[(0,1)], identity[(0,2)]);\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\", identity[(1,0)], identity[(1,1)], identity[(1,2)]);\n    println!(\"  [{:8.5}, {:8.5}, {:8.5}]\", identity[(2,0)], identity[(2,1)], identity[(2,2)]);\n    let diff_from_identity = (identity - na::Matrix3::identity()).norm();\n    println!(\"Difference from identity: {:.15}\\n\", diff_from_identity);\n    // Expected output:\n    //   [ 1.00000,  0.00000,  0.00000]\n    //   [ 0.00000,  1.00000,  0.00000]\n    //   [ 0.00000,  0.00000,  1.00000]\n    // Difference from identity: 0.000000000000000\n\n    // Verify determinant = +1 (proper rotation matrix)\n    let det = r_rtn_to_eci.determinant();\n    println!(\"Determinant (should be +1): {:.15}\\n\", det);\n    // Expected output:\n    // Determinant (should be +1): 1.000000000000000\n\n    // Verify ECI-to-RTN is the transpose of RTN-to-ECI\n    let transpose_diff = (r_eci_to_rtn - r_rtn_to_eci.transpose()).norm();\n    println!(\"Transpose relationship check:\");\n    println!(\"||R_eci_to_rtn - R_rtn_to_eci^T||: {:.15}\\n\", transpose_diff);\n    // Expected output:\n    // ||R_eci_to_rtn - R_rtn_to_eci^T||: 0.000000000000000\n\n    // Example: Transform a vector from RTN to ECI\n    let v_rtn = na::Vector3::new(1.0, 0.0, 0.0);  // Radial unit vector in RTN frame\n    let v_eci = r_rtn_to_eci * v_rtn;\n\n    println!(\"Example transformation:\");\n    println!(\"Vector in RTN frame: [{:.3}, {:.3}, {:.3}]\", v_rtn[0], v_rtn[1], v_rtn[2]);\n    println!(\"Vector in ECI frame: [{:.5}, {:.5}, {:.5}]\", v_eci[0], v_eci[1], v_eci[2]);\n    println!(\"ECI vector magnitude: {:.15}\", v_eci.norm());\n    // Expected output:\n    // Vector in RTN frame: [1.000, 0.000, 0.000]\n    // Vector in ECI frame: [0.28262, -0.06004, 0.95735]\n    // ECI vector magnitude: 1.000000000000000\n}\n</code></pre>"},{"location":"learn/relative_motion/rtn_transformations.html#state-transformations","title":"State Transformations","text":"<p>For relative motion analysis between two satellites (often called \"chief\" and \"deputy\"), Brahe provides functions to transform between absolute ECI states and relative RTN states.</p>"},{"location":"learn/relative_motion/rtn_transformations.html#eci-to-rtn-absolute-to-relative","title":"ECI to RTN (Absolute to Relative)","text":"<p>The <code>state_eci_to_rtn</code> function transforms the absolute states of two satellites from the ECI frame to the relative state of the deputy with respect to the chief in the RTN frame. This accounts for the rotating nature of the RTN frame.</p> <p>The resulting relative state vector contains six components:</p> <ul> <li>Position: \\([\\rho_R, \\rho_T, \\rho_N]\\) - relative position in RTN frame (m)</li> <li>Velocity: \\([\\dot{\\rho}_R, \\dot{\\rho}_T, \\dot{\\rho}_N]\\) - relative velocity in RTN frame (m/s)</li> </ul> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Define deputy satellite with small orbital element differences\noe_deputy = np.array(\n    [\n        bh.R_EARTH + 701e3,  # 1 km higher semi-major axis\n        0.0015,  # Slightly higher eccentricity\n        97.85,  # 0.05\u00b0 higher inclination\n        15.05,  # Small RAAN difference\n        30.05,  # Small argument of perigee difference\n        45.00,  # Same mean anomaly\n    ]\n)\n\n# Convert to Cartesian ECI states\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\nx_deputy = bh.state_koe_to_eci(oe_deputy, bh.AngleFormat.DEGREES)\n\n# Transform to relative RTN state\nx_rel_rtn = bh.state_eci_to_rtn(x_chief, x_deputy)\n\nprint(\"Relative state in RTN frame:\")\nprint(f\"Radial (R):      {x_rel_rtn[0]:.3f} m\")\nprint(f\"Along-track (T): {x_rel_rtn[1]:.3f} m\")\nprint(f\"Cross-track (N): {x_rel_rtn[2]:.3f} m\")\nprint(f\"Velocity R:      {x_rel_rtn[3]:.6f} m/s\")\nprint(f\"Velocity T:      {x_rel_rtn[4]:.6f} m/s\")\nprint(f\"Velocity N:      {x_rel_rtn[5]:.6f} m/s\\n\")\n# Radial (R):      -1508.659 m\n# Along-track (T): 11576.951 m\n# Cross-track (N): 4401.874 m\n# Velocity R:      -17.504100 m/s\n# Velocity T:      12.730654 m/s\n# Velocity N:      7.959939 m/s\n\n# Calculate total relative distance\nrelative_distance = np.linalg.norm(x_rel_rtn[:3])\nprint(f\"Total relative distance: {relative_distance:.3f} m\")\n# Total relative distance: 12477.113 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of perigee (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Define deputy satellite with small orbital element differences\n    let oe_deputy = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 701e3,  // 1 km higher semi-major axis\n        0.0015,               // Slightly higher eccentricity\n        97.85,                // 0.05\u00b0 higher inclination\n        15.05,                // Small RAAN difference\n        30.05,                // Small argument of perigee difference\n        45.01                 // Same mean anomaly\n    );\n\n    // Convert to Cartesian ECI states\n    let x_chief = bh::state_koe_to_eci(oe_chief, bh::AngleFormat::Degrees);\n    let x_deputy = bh::state_koe_to_eci(oe_deputy, bh::AngleFormat::Degrees);\n\n    // Transform to relative RTN state\n    let x_rel_rtn = bh::state_eci_to_rtn(x_chief, x_deputy);\n\n    println!(\"Relative state in RTN frame:\");\n    println!(\"Radial (R):      {:.3} m\", x_rel_rtn[0]);\n    println!(\"Along-track (T): {:.3} m\", x_rel_rtn[1]);\n    println!(\"Cross-track (N): {:.3} m\", x_rel_rtn[2]);\n    println!(\"Velocity R:      {:.6} m/s\", x_rel_rtn[3]);\n    println!(\"Velocity T:      {:.6} m/s\", x_rel_rtn[4]);\n    println!(\"Velocity N:      {:.6} m/s\\n\", x_rel_rtn[5]);\n    // Expected output:\n    // Radial (R):      -1508.659 m\n    // Along-track (T): 11576.951 m\n    // Cross-track (N): 4401.874 m\n    // Velocity R:      -17.504100 m/s\n    // Velocity T:      12.730654 m/s\n    // Velocity N:      7.959939 m/s\n\n    // Calculate total relative distance\n    let relative_distance = x_rel_rtn.fixed_rows::&lt;3&gt;(0).norm();\n    println!(\"Total relative distance: {:.3} m\", relative_distance);\n    // Expected output:\n    // Total relative distance: 12477.113 m\n}\n</code></pre>"},{"location":"learn/relative_motion/rtn_transformations.html#rtn-to-eci-relative-to-absolute","title":"RTN to ECI (Relative to Absolute)","text":"<p>The <code>state_rtn_to_eci</code> function performs the inverse operation: it transforms the relative state of a deputy satellite (in the RTN frame of the chief) back to the absolute ECI state of the deputy. This is useful for propagating relative states or computing deputy trajectories from relative motion plans.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief satellite orbital elements\n# LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\noe_chief = np.array(\n    [\n        bh.R_EARTH + 700e3,  # Semi-major axis (m)\n        0.001,  # Eccentricity\n        97.8,  # Inclination (deg)\n        15.0,  # Right ascension of ascending node (deg)\n        30.0,  # Argument of perigee (deg)\n        45.0,  # Mean anomaly (deg)\n    ]\n)\n\n# Convert to Cartesian ECI state\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\n\nprint(\"Chief ECI state:\")\nprint(\n    f\"Position:  [{x_chief[0] / 1e3:.3f}, {x_chief[1] / 1e3:.3f}, {x_chief[2] / 1e3:.3f}] km\"\n)\nprint(\n    f\"Velocity:  [{x_chief[3] / 1e3:.6f}, {x_chief[4] / 1e3:.6f}, {x_chief[5] / 1e3:.6f}] km/s\\n\"\n)\n# Position:  [1999.015, -424.663, 6771.472] km\n# Velocity:  [-6.939780, -2.131872, 1.920555] km/s\n\n# Define relative state in RTN frame\n# Deputy is 1 km radial, 500 m along-track, -300 m cross-track\n# with small relative velocity\nx_rel_rtn = np.array(\n    [\n        1000.0,  # Radial offset (m)\n        500.0,  # Along-track offset (m)\n        -300.0,  # Cross-track offset (m)\n        0.1,  # Radial velocity (m/s)\n        -0.05,  # Along-track velocity (m/s)\n        0.02,  # Cross-track velocity (m/s)\n    ]\n)\n\nprint(\"Relative state in RTN frame:\")\nprint(f\"Radial (R):      {x_rel_rtn[0]:.3f} m\")\nprint(f\"Along-track (T): {x_rel_rtn[1]:.3f} m\")\nprint(f\"Cross-track (N): {x_rel_rtn[2]:.3f} m\")\nprint(f\"Velocity R:      {x_rel_rtn[3]:.3f} m/s\")\nprint(f\"Velocity T:      {x_rel_rtn[4]:.3f} m/s\")\nprint(f\"Velocity N:      {x_rel_rtn[5]:.3f} m/s\\n\")\n# Radial (R):      1000.000 m\n# Along-track (T): 500.000 m\n# Cross-track (N): -300.000 m\n# Velocity R:      0.100 m/s\n# Velocity T:      -0.050 m/s\n# Velocity N:      0.020 m/s\n\n# Transform to absolute deputy ECI state\nx_deputy = bh.state_rtn_to_eci(x_chief, x_rel_rtn)\n\nprint(\"Deputy ECI state:\")\nprint(\n    f\"Position:  [{x_deputy[0] / 1e3:.3f}, {x_deputy[1] / 1e3:.3f}, {x_deputy[2] / 1e3:.3f}] km\"\n)\nprint(\n    f\"Velocity:  [{x_deputy[3] / 1e3:.6f}, {x_deputy[4] / 1e3:.6f}, {x_deputy[5] / 1e3:.6f}] km/s\\n\"\n)\n# Position:  [1998.759, -424.578, 6772.598] km\n# Velocity:  [-6.940832, -2.132153, 1.920398] km/s\n\n# Verify by transforming back to RTN\nx_rel_rtn_verify = bh.state_eci_to_rtn(x_chief, x_deputy)\n\nprint(\"Round-trip verification (RTN -&gt; ECI -&gt; RTN):\")\nprint(f\"Original RTN:  [{x_rel_rtn[0]:.3f}, {x_rel_rtn[1]:.3f}, {x_rel_rtn[2]:.3f}] m\")\nprint(\n    f\"Recovered RTN: [{x_rel_rtn_verify[0]:.3f}, {x_rel_rtn_verify[1]:.3f}, {x_rel_rtn_verify[2]:.3f}] m\"\n)\nprint(f\"Difference:    {np.linalg.norm(x_rel_rtn - x_rel_rtn_verify):.9f} m\")\n# Original RTN:  [1000.000, 500.000, -300.000] m\n# Recovered RTN: [1000.000, 500.000, -300.000] m\n# Difference:    0.000000000 m\n</code></pre> <pre><code>use brahe as bh;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define chief satellite orbital elements\n    // LEO orbit: 700 km altitude, nearly circular, sun-synchronous inclination\n    let oe_chief = na::SVector::&lt;f64, 6&gt;::new(\n        bh::R_EARTH + 700e3,  // Semi-major axis (m)\n        0.001,                // Eccentricity\n        97.8,                 // Inclination (deg)\n        15.0,                 // Right ascension of ascending node (deg)\n        30.0,                 // Argument of perigee (deg)\n        45.0                  // Mean anomaly (deg)\n    );\n\n    // Convert to Cartesian ECI state\n    let x_chief = bh::state_koe_to_eci(oe_chief, bh::AngleFormat::Degrees);\n\n    println!(\"Chief ECI state:\");\n    println!(\"Position:  [{:.3}, {:.3}, {:.3}] km\",\n        x_chief[0]/1e3, x_chief[1]/1e3, x_chief[2]/1e3);\n    println!(\"Velocity:  [{:.6}, {:.6}, {:.6}] km/s\\n\",\n        x_chief[3]/1e3, x_chief[4]/1e3, x_chief[5]/1e3);\n    // Expected output:\n    // Position:  [1999.015, -424.663, 6771.472] km\n    // Velocity:  [-6.939780, -2.131872, 1.920555] km/s\n\n    // Define relative state in RTN frame\n    // Deputy is 1 km radial, 500 m along-track, -300 m cross-track\n    // with small relative velocity\n    let x_rel_rtn = na::SVector::&lt;f64, 6&gt;::new(\n        1000.0,   // Radial offset (m)\n        500.0,    // Along-track offset (m)\n        -300.0,   // Cross-track offset (m)\n        0.1,      // Radial velocity (m/s)\n        -0.05,    // Along-track velocity (m/s)\n        0.02      // Cross-track velocity (m/s)\n    );\n\n    println!(\"Relative state in RTN frame:\");\n    println!(\"Radial (R):      {:.3} m\", x_rel_rtn[0]);\n    println!(\"Along-track (T): {:.3} m\", x_rel_rtn[1]);\n    println!(\"Cross-track (N): {:.3} m\", x_rel_rtn[2]);\n    println!(\"Velocity R:      {:.3} m/s\", x_rel_rtn[3]);\n    println!(\"Velocity T:      {:.3} m/s\", x_rel_rtn[4]);\n    println!(\"Velocity N:      {:.3} m/s\\n\", x_rel_rtn[5]);\n    // Expected output:\n    // Radial (R):      1000.000 m\n    // Along-track (T): 500.000 m\n    // Cross-track (N): -300.000 m\n    // Velocity R:      0.100 m/s\n    // Velocity T:      -0.050 m/s\n    // Velocity N:      0.020 m/s\n\n    // Transform to absolute deputy ECI state\n    let x_deputy = bh::state_rtn_to_eci(x_chief, x_rel_rtn);\n\n    println!(\"Deputy ECI state:\");\n    println!(\"Position:  [{:.3}, {:.3}, {:.3}] km\",\n        x_deputy[0]/1e3, x_deputy[1]/1e3, x_deputy[2]/1e3);\n    println!(\"Velocity:  [{:.6}, {:.6}, {:.6}] km/s\\n\",\n        x_deputy[3]/1e3, x_deputy[4]/1e3, x_deputy[5]/1e3);\n    // Expected output:\n    // Position:  [1998.759, -424.578, 6772.598] km\n    // Velocity:  [-6.940832, -2.132153, 1.920398] km/s\n\n    // Verify by transforming back to RTN\n    let x_rel_rtn_verify = bh::state_eci_to_rtn(x_chief, x_deputy);\n\n    println!(\"Round-trip verification (RTN -&gt; ECI -&gt; RTN):\");\n    println!(\"Original RTN:  [{:.3}, {:.3}, {:.3}] m\",\n        x_rel_rtn[0], x_rel_rtn[1], x_rel_rtn[2]);\n    println!(\"Recovered RTN: [{:.3}, {:.3}, {:.3}] m\",\n        x_rel_rtn_verify[0], x_rel_rtn_verify[1], x_rel_rtn_verify[2]);\n    let diff = (x_rel_rtn - x_rel_rtn_verify).norm();\n    println!(\"Difference:    {:.9} m\", diff);\n    // Expected output:\n    // Original RTN:  [1000.000, 500.000, -300.000] m\n    // Recovered RTN: [1000.000, 500.000, -300.000] m\n    // Difference:    0.000000000 m\n}\n</code></pre>"},{"location":"learn/space_weather/index.html","title":"Space Weather Data","text":"<p>Space weather data provides geomagnetic indices and solar flux measurements that are essential for atmospheric density models used in satellite drag calculations. These parameters capture solar activity and geomagnetic disturbances that directly affect upper atmosphere density and satellite orbital decay.</p> <p>Experimental API</p> <p>The space weather module is currently experimental. While the core functionality should be stable, the API may change in future MINOR releases as we refine the design and add features.</p>"},{"location":"learn/space_weather/index.html#overview","title":"Overview","text":"<p>The primary space weather parameters used in astrodynamics are:</p> Parameter Description Range Units Kp Planetary geomagnetic index 0-9 dimensionless Ap Daily amplitude geomagnetic index 0-400 nT (nanotesla) F10.7 10.7 cm solar radio flux 60-400 sfu (solar flux units) ISN International Sunspot Number 0-400 count"},{"location":"learn/space_weather/index.html#f107-solar-radio-flux","title":"F10.7 Solar Radio Flux","text":"<p>The F10.7 index measures solar radio emissions at 10.7 cm wavelength and serves as a proxy for solar radiation that heats the upper atmosphere. Higher F10.7 values indicate increased solar activity and higher atmospheric density.</p> <p>The plot below shows the historical F10.7 observed flux from 1957 to present, with future predicted values shown in red.</p> Plot Source fig_f107_history.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# ------------------------------\n# Configuration\n# ------------------------------\n\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# ------------------------------\n\n# Initialize space weather data\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nbh.set_global_space_weather_provider(sw)\n\n## Generate plot data\n\n# Get range of dates stored in space weather data\nmjd_min = bh.get_global_sw_mjd_min()\nmjd_max = bh.get_global_sw_mjd_max()\nmjd_last_obs = bh.get_global_sw_mjd_last_observed()\nmjd_last_daily = bh.get_global_sw_mjd_last_daily_predicted()\n\nprint(\"Space Weather MJD Range:\", mjd_min, \"to\", mjd_max)\nprint(\"Last Observed MJD:\", mjd_last_obs)\nprint(\"Last Daily Predicted MJD:\", mjd_last_daily)\n\n# Split data into three regions: observed, daily predicted, monthly predicted\ndays_observed = np.arange(mjd_min, mjd_last_obs + 1, 1)\ndays_daily_predicted = np.arange(mjd_last_obs, mjd_last_daily + 1, 1)\ndays_monthly_predicted = np.arange(mjd_last_daily, mjd_max + 1, 1)\n\n# Get F10.7 observed flux values for each region\nf107_observed = [bh.get_global_f107_observed(mjd) for mjd in days_observed]\nf107_daily_predicted = [\n    bh.get_global_f107_observed(mjd) for mjd in days_daily_predicted\n]\nf107_monthly_predicted = [\n    bh.get_global_f107_observed(mjd) for mjd in days_monthly_predicted\n]\n\n\n# Create hover text with year-month-day format\ndef mjd_to_date_str(mjd):\n    \"\"\"Convert MJD to YYYY-MM-DD string.\"\"\"\n    epoch = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\n    dt = epoch.to_datetime()\n    return f\"{int(dt[0]):04d}-{int(dt[1]):02d}-{int(dt[2]):02d}\"\n\n\nhover_observed = [mjd_to_date_str(mjd) for mjd in days_observed]\nhover_daily_predicted = [mjd_to_date_str(mjd) for mjd in days_daily_predicted]\nhover_monthly_predicted = [mjd_to_date_str(mjd) for mjd in days_monthly_predicted]\n\n# Get year range for x-axis tick labels\nepoch_min = bh.Epoch.from_mjd(mjd_min, bh.TimeSystem.UTC)\nepoch_max = bh.Epoch.from_mjd(mjd_max, bh.TimeSystem.UTC)\nyear_min = epoch_min.to_datetime()[0]\nyear_max = epoch_max.to_datetime()[0]\n\n\n## Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Plot observed data (solid line) - use primary color\n    fig.add_trace(\n        go.Scatter(\n            x=days_observed,\n            y=f107_observed,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=1),\n            name=\"Observed\",\n            showlegend=True,\n            text=hover_observed,\n            hovertemplate=\"%{text}&lt;br&gt;F10.7: %{y:.1f} sfu&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Plot daily predicted data (dashed line) - use error color\n    fig.add_trace(\n        go.Scatter(\n            x=days_daily_predicted,\n            y=f107_daily_predicted,\n            mode=\"lines\",\n            line=dict(color=colors[\"error\"], width=1, dash=\"dash\"),\n            name=\"Daily Predicted\",\n            showlegend=True,\n            text=hover_daily_predicted,\n            hovertemplate=\"%{text}&lt;br&gt;F10.7: %{y:.1f} sfu&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Plot monthly predicted data (dotted line) - use secondary color\n    fig.add_trace(\n        go.Scatter(\n            x=days_monthly_predicted,\n            y=f107_monthly_predicted,\n            mode=\"lines\",\n            line=dict(color=colors[\"secondary\"], width=1, dash=\"dot\"),\n            name=\"Monthly Predicted\",\n            showlegend=True,\n            text=hover_monthly_predicted,\n            hovertemplate=\"%{text}&lt;br&gt;F10.7: %{y:.1f} sfu&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    # Create custom tick values and labels for x-axis (years)\n    # Generate tick positions every 10 years\n    tick_mjds = []\n    tick_labels = []\n    for year in range(1960, year_max + 1, 10):\n        if year &gt;= year_min:\n            epoch = bh.Epoch.from_datetime(\n                year, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC\n            )\n            tick_mjds.append(epoch.mjd())\n            tick_labels.append(str(year))\n\n    # Configure axes (theme-agnostic settings)\n    fig.update_xaxes(\n        tickmode=\"array\",\n        tickvals=tick_mjds,\n        ticktext=tick_labels,\n        title_text=\"Year\",\n        range=[mjd_min, mjd_max],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        title_text=\"F10.7 Solar Flux [sfu]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre> <p>The approximately 11-year solar cycle is clearly visible in the data, with peaks corresponding to solar maximum periods.</p>"},{"location":"learn/space_weather/index.html#geomagnetic-indices","title":"Geomagnetic Indices","text":"<p>Kp and Ap indices measure geomagnetic activity caused by solar wind interactions with Earth's magnetosphere.</p>"},{"location":"learn/space_weather/index.html#data-source","title":"Data Source","text":"<p>Brahe uses CSSI space weather data files provided by CelesTrak. The data includes:</p> <ul> <li>Historical observations from October 1957 to present</li> <li>Daily predictions for the near term</li> <li>Monthly predictions extending further into the future</li> </ul>"},{"location":"learn/space_weather/index.html#managing-space-weather-in-brahe","title":"Managing Space Weather in Brahe","text":"<p>Brahe provides three provider types for space weather data:</p> <ul> <li>CachingSpaceWeatherProvider: Auto-downloads and caches latest data (recommended)</li> <li>FileSpaceWeatherProvider: Loads from CSSI format files</li> <li>StaticSpaceWeatherProvider: Uses fixed values for testing</li> </ul> <p>See: Managing Space Weather Data</p>"},{"location":"learn/space_weather/index.html#see-also","title":"See Also","text":"<ul> <li>Managing Space Weather Data - Practical guide to providers</li> <li>Space Weather API Reference - Complete API documentation</li> </ul>"},{"location":"learn/space_weather/managing_space_weather_data.html","title":"Managing Space Weather Data","text":"<p>Brahe provides a global space weather provider that supplies geomagnetic indices and solar flux data when needed. If you want to skip the details for now, initialize the global provider with defaults:</p> PythonRust <pre><code>import brahe as bh\n\n# Initialize with default caching provider (will download data as needed)\nbh.initialize_sw()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Initialize with default caching provider (will download data as needed)\n    bh::space_weather::initialize_sw().unwrap();\n}\n</code></pre> <p>Warning</p> <p>Space weather data MUST be initialized before using any functionality that requires it. If no data is initialized, brahe will panic and terminate the program.</p> <p>The data is used by atmospheric drag models to compute density variations.</p>"},{"location":"learn/space_weather/managing_space_weather_data.html#space-weather-providers","title":"Space Weather Providers","text":"<p>Brahe defines three provider types with different use cases.</p>"},{"location":"learn/space_weather/managing_space_weather_data.html#staticspaceweatherprovider","title":"StaticSpaceWeatherProvider","text":"<p>A static provider uses fixed values for all space weather parameters. This is useful for testing or when you want reproducible results with known conditions.</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Static Space Weather Provider - All Zeros\nsw_static_zeros = bh.StaticSpaceWeatherProvider.from_zero()\nbh.set_global_space_weather_provider(sw_static_zeros)\n\n# Method 2: Static Space Weather Provider - Custom Constant Values\n# Parameters: kp, ap, f107_obs, f107_adj, sunspot_number\nsw_static_values = bh.StaticSpaceWeatherProvider.from_values(\n    3.0, 15.0, 150.0, 150.0, 100\n)\nbh.set_global_space_weather_provider(sw_static_values)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Static Space Weather Provider - All Zeros\n    let sw_static_zeros = bh::space_weather::StaticSpaceWeatherProvider::from_zero();\n    bh::space_weather::set_global_space_weather_provider(sw_static_zeros);\n\n    // Method 2: Static Space Weather Provider - Custom Constant Values\n    // Parameters: kp, ap, f107_obs, f107_adj, sunspot_number\n    let sw_static_values =\n        bh::space_weather::StaticSpaceWeatherProvider::from_values(3.0, 15.0, 150.0, 150.0, 100);\n    bh::space_weather::set_global_space_weather_provider(sw_static_values);\n}\n</code></pre>"},{"location":"learn/space_weather/managing_space_weather_data.html#filespaceweatherprovider","title":"FileSpaceWeatherProvider","text":"<p>Load space weather data from CSSI format files. Brahe includes a default data file that is updated with each release.</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Default Provider -&gt; Uses packaged data file within Brahe\nsw_file_default = bh.FileSpaceWeatherProvider.from_default_file()\nbh.set_global_space_weather_provider(sw_file_default)\n\n# Method 2: Custom File Path -&gt; Replace with actual file path\nif False:  # Change to True to enable custom file example\n    sw_file_custom = bh.FileSpaceWeatherProvider.from_file(\n        \"/path/to/sw19571001.txt\",  # Replace with actual file path\n        \"Hold\",  # Extrapolation: \"Zero\", \"Hold\", or \"Error\"\n    )\n    bh.set_global_space_weather_provider(sw_file_custom)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::space_weather::SpaceWeatherExtrapolation;\nuse std::path::Path;\n\nfn main() {\n    // Method 1: Default Provider -&gt; Uses packaged data file within Brahe\n    let sw_file_default =\n        bh::space_weather::FileSpaceWeatherProvider::from_default_file().unwrap();\n    bh::space_weather::set_global_space_weather_provider(sw_file_default);\n\n    // Method 2: Custom File Path -&gt; Replace with actual file path\n    if false {\n        // Change to true to enable custom file example\n        let sw_file_custom = bh::space_weather::FileSpaceWeatherProvider::from_file(\n            Path::new(\"/path/to/sw19571001.txt\"), // Replace with actual file path\n            SpaceWeatherExtrapolation::Hold,\n        )\n        .unwrap();\n        bh::space_weather::set_global_space_weather_provider(sw_file_custom);\n    }\n}\n</code></pre>"},{"location":"learn/space_weather/managing_space_weather_data.html#cachingspaceweatherprovider","title":"CachingSpaceWeatherProvider","text":"<p>The caching provider automatically downloads and manages space weather data files from CelesTrak. It checks file age and updates when the cache becomes stale.</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Create with custom settings\n# - Downloads to ~/.cache/brahe/\n# - Refreshes if file is older than 24 hours\nsw_caching = bh.CachingSpaceWeatherProvider(\n    max_age_seconds=86400,  # max_age: seconds (86400 = 24 hours)\n    auto_refresh=False,  # check on each query\n    extrapolate=\"Hold\",  # extrapolation\n)\nbh.set_global_space_weather_provider(sw_caching)\n\n# Method 2: Use initialize_sw() which creates a caching provider\nbh.initialize_sw()\n</code></pre> <pre><code>use brahe as bh;\nuse bh::space_weather::SpaceWeatherExtrapolation;\n\nfn main() {\n    // Method 1: Create with custom settings\n    // - Downloads to ~/.cache/brahe/\n    // - Refreshes if file is older than 24 hours\n    let sw_caching = bh::space_weather::CachingSpaceWeatherProvider::new(\n        None,                              // cache_dir: None for default\n        86400,                             // max_age: seconds (86400 = 24 hours)\n        false,                             // auto_refresh: check on each query\n        SpaceWeatherExtrapolation::Hold,   // extrapolation\n    )\n    .unwrap();\n    bh::space_weather::set_global_space_weather_provider(sw_caching);\n\n    // Method 2: Use initialize_sw() which creates a caching provider\n    bh::space_weather::initialize_sw().unwrap();\n}\n</code></pre>"},{"location":"learn/space_weather/managing_space_weather_data.html#extrapolation-options","title":"Extrapolation Options","text":"<p>When querying dates outside the available data range, the provider behavior depends on the extrapolation setting:</p> <ul> <li><code>\"Zero\"</code>: Return zero values for all parameters</li> <li><code>\"Hold\"</code>: Return the last (or first) available value</li> <li><code>\"Error\"</code>: Panic and terminate the program</li> </ul>"},{"location":"learn/space_weather/managing_space_weather_data.html#accessing-space-weather-data","title":"Accessing Space Weather Data","text":"<p>Query space weather data using the global functions:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_sw()\n\n# Get data for a specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\n# Kp/Ap for specific 3-hour interval\nkp = bh.get_global_kp(mjd)\nap = bh.get_global_ap(mjd)\n\n# Daily averages\nkp_daily = bh.get_global_kp_daily(mjd)\nap_daily = bh.get_global_ap_daily(mjd)\n\n# All 8 values for the day\nkp_all = bh.get_global_kp_all(mjd)  # [Kp_00-03, Kp_03-06, ..., Kp_21-24]\nap_all = bh.get_global_ap_all(mjd)\n\n# F10.7 solar flux\nf107 = bh.get_global_f107_observed(mjd)\nf107_adj = bh.get_global_f107_adjusted(mjd)\nf107_avg = bh.get_global_f107_obs_avg81(mjd)  # 81-day centered average\n\n# Sunspot number\nisn = bh.get_global_sunspot_number(mjd)\n\nprint(f\"Kp: {kp}, Ap: {ap}, F10.7: {f107} sfu, ISN: {isn}\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::TimeSystem;\n\nfn main() {\n    bh::space_weather::initialize_sw().unwrap();\n\n    // Get data for a specific epoch\n    let epoch = bh::time::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n    let mjd = epoch.mjd();\n\n    // Kp/Ap for specific 3-hour interval\n    let kp = bh::space_weather::get_global_kp(mjd).unwrap();\n    let ap = bh::space_weather::get_global_ap(mjd).unwrap();\n\n    // Daily averages\n    let kp_daily = bh::space_weather::get_global_kp_daily(mjd).unwrap();\n    let ap_daily = bh::space_weather::get_global_ap_daily(mjd).unwrap();\n\n    // All 8 values for the day\n    let kp_all = bh::space_weather::get_global_kp_all(mjd).unwrap(); // [Kp_00-03, Kp_03-06, ..., Kp_21-24]\n    let ap_all = bh::space_weather::get_global_ap_all(mjd).unwrap();\n\n    // F10.7 solar flux\n    let f107 = bh::space_weather::get_global_f107_observed(mjd).unwrap();\n    let f107_adj = bh::space_weather::get_global_f107_adjusted(mjd).unwrap();\n    let f107_avg = bh::space_weather::get_global_f107_obs_avg81(mjd).unwrap(); // 81-day centered average\n\n    // Sunspot number\n    let isn = bh::space_weather::get_global_sunspot_number(mjd).unwrap();\n\n    println!(\"Kp: {}, Ap: {}, F10.7: {} sfu, ISN: {}\", kp, ap, f107, isn);\n\n    // Suppress unused variable warnings\n    let _ = (kp_daily, ap_daily, kp_all, ap_all, f107_adj, f107_avg);\n}\n</code></pre>"},{"location":"learn/space_weather/managing_space_weather_data.html#range-data-access","title":"Range Data Access","text":"<p>The space weather providers also support querying data over a date range, returning a vector of values from before the specific time. This is useful to providing the weather history for drag models.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_sw()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\n# Get last 30 days of F10.7 data\nf107_history = bh.get_global_last_f107(mjd, 30)\n\n# Get last 7 days of daily Ap\nap_history = bh.get_global_last_daily_ap(mjd, 7)\n\n# Get epochs for the data points\nepochs = bh.get_global_last_daily_epochs(mjd, 7)\n\nprint(f\"Last 7 daily Ap values: {ap_history}\")\nprint(f\"Last 7 epochs: {[str(e) for e in epochs]}\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::TimeSystem;\n\nfn main() {\n    bh::space_weather::initialize_sw().unwrap();\n\n    let epoch = bh::time::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, TimeSystem::UTC);\n    let mjd = epoch.mjd();\n\n    // Get last 30 days of F10.7 data\n    let f107_history = bh::space_weather::get_global_last_f107(mjd, 30).unwrap();\n\n    // Get last 7 days of daily Ap\n    let ap_history = bh::space_weather::get_global_last_daily_ap(mjd, 7).unwrap();\n\n    // Get epochs for the data points\n    let epochs = bh::space_weather::get_global_last_daily_epochs(mjd, 7).unwrap();\n\n    println!(\"Last 7 daily Ap values: {:?}\", ap_history);\n    println!(\n        \"Last 7 epochs: {:?}\",\n        epochs.iter().map(|e| e.to_string()).collect::&lt;Vec&lt;_&gt;&gt;()\n    );\n\n    // Suppress unused variable warnings\n    let _ = f107_history;\n}\n</code></pre>"},{"location":"learn/space_weather/managing_space_weather_data.html#see-also","title":"See Also","text":"<ul> <li>StaticSpaceWeatherProvider API Reference</li> <li>FileSpaceWeatherProvider API Reference</li> <li>CachingSpaceWeatherProvider API Reference</li> <li>Space Weather Functions</li> </ul>"},{"location":"learn/time/index.html","title":"Time Systems and Representations","text":"<p>In the beginning the Universe was created. This has made a lot of people very angry and has been widely regarded as a bad move</p> <ul> <li>Douglas Adams</li> </ul> <p>Astrodynamics is the study of motion in space, which is inextricably linked with the concept of time. You cannot have motion without time. The trajectory of an object is defined by how it's state (location) changes between different points in time. As one might therefore expect, accurate timekeeping and the ability to convert between different representations of time are crucial for calculations in orbital mechanics.</p> <p>The <code>time</code> module provides functions for the handling of time. The package makes the distinction between the representation of a specific time and the conversion between different time scales. Precise specification of an instant in time requires the specification of both a time representation and time scale.</p>"},{"location":"learn/time/index.html#time-representation","title":"Time Representation","text":"<p>A single instance in time can be represented in multiple different formats. For examples The J2000 Epoch can be represented as a calendar date in terms of years, months, days, hours, minutes, and seconds as <code>2000-01-01T12:00:00</code>. The same instant can also be represented in terms of Modified Julian Days as <code>51544.5</code>. Both of these representations refer to the same instant in time.</p>"},{"location":"learn/time/index.html#time-scales","title":"Time Scales","text":"<p>In addition to representing time in different manners, there are also different time scales. A time scale is a standard to reckoning and resolving instances in time. Multimple time scales have been introduced due to the criticality of being able to correctly measure and understand when specific events occur in science and engineering.  </p> <p>Within a time scale it is possible to compare different instances in time to determine if one is before, after, or at the same time as another instant. It is also possible to compare between time scales, however you must know how to properly convert between them. It is assumed that all time scales use the same definition of the SI second, and therefore advance at the same rate.</p> <p>Athough the calendar date representations of time <code>2000-01-01T12:00:00 UTC</code> and <code>2000-01-01T12:00:00 GPS</code> have the same values, they are actually  different instances in time!. This is because while the calendar date representations are the same there are actually offsets between the different time scales.</p> <p>The time scales currently supported by brahe are</p> Time Scale Description <code>GPS</code> <code>GPS</code> stands for Global Positioning System time. It is specifically, the time scale used by the US GPS satellites. It is different from TAI and TT by constant, fixed offsets. <code>TAI</code> <code>TAI</code> is a French acronym for temps atomique international. It is an atomic time scale meant to track the proper time on the Earth's surface. <code>UTC</code> <code>UTC</code> stands for Universal Coordinated Time. <code>UTC</code> tracks the solar day, accounting for long term variations due to changes in Earth's rotation to within +/- 1 second. Tracking the solar day in this manner introduces an offset between <code>TAI</code> and <code>UTC</code> of a fixed number of leap seconds. <code>UT1</code> <code>UT1</code> stands for Universal Time 1. <code>UT1</code> represents the time as determined by the true solar day. Due to Earth's rotation rate constantly changing UT1 itself is constantly changing. The difference between <code>UT1</code> and <code>UTC</code> is empirically estimated on a daily basis as an Earth orientation parameter. <code>TT</code> <code>TT</code> is Terrestrial Time, a time scale used historically to model the motion of planets and other solar system bodies. These models are still in wide use."},{"location":"learn/time/index.html#epoch","title":"Epoch","text":"<p>The <code>Epoch</code> type represents a specific instant in time, defined by both a time representation and a time scale. The <code>Epoch</code> type provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>It is the core type used throughout the brahe package to represent time and provides many advandages as </p>"},{"location":"learn/time/index.html#see-also","title":"See Also","text":"<ul> <li>Epoch - Complete guide to the Epoch type</li> <li>Time API Reference - Complete time function documentation</li> <li>Time Constants - Important time-related constants</li> </ul>"},{"location":"learn/time/epoch.html","title":"Epoch","text":"<p>The Epoch class is the fundamental time representation in Brahe. It encapsulates a specific instant in time, defined by both a time representation and a time scale. The Epoch class provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>There are even more capabilities and features of the Epoch class beyond what is covered in this guide. For a complete reference of all available methods and properties, please refer to the Epoch API Reference.</p>"},{"location":"learn/time/epoch.html#initialization","title":"Initialization","text":"<p>There are all sorts of ways you can initialize an Epoch instance. The most common methods are described below.</p>"},{"location":"learn/time/epoch.html#date-time","title":"Date Time","text":"<p>The most common way to create an Epoch is from date and time components. You can specify just a date (which defaults to midnight), or provide the full date and time including fractional seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from date only (midnight)\nepc1 = bh.Epoch(2024, 1, 1)\nprint(f\"Date only: {epc1}\")\n# Date only: 2024-01-01 00:00:00.000 UTC\n\n# Create epoch from full datetime components\nepc2 = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Full datetime: {epc2}\")\n# Full datetime: 2024-06-15 14:30:45.500 UTC\n\n# Create epoch with different time system\nepc3 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TimeSystem.GPS)\nprint(f\"GPS time system: {epc3}\")\n# GPS time system: 2024-12-25 18:00:00.000 GPS\n\n# In Python you can also use the direct datetime constant\nepc4 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TAI)\nprint(f\"GPS time system: {epc4}\")\n# GPS time system: 2024-12-25 18:00:00.000 TAI\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from date only (midnight)\n    let epc1 = bh::Epoch::from_date(2024, 1, 1, bh::TimeSystem::UTC);\n    println!(\"Date only: {}\", epc1);\n\n    // Create epoch from full datetime components\n    let epc2 = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Full datetime: {}\", epc2);\n\n    // Create epoch with different time system\n    let epc3 = bh::Epoch::from_datetime(2024, 12, 25, 18, 0, 0.0, 0.0, bh::TimeSystem::GPS);\n    println!(\"GPS time system: {}\", epc3);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#mjd","title":"MJD","text":"<p>Modified Julian Date (MJD) is a commonly used time representation in astronomy and astrodynamics. MJD is defined as JD - 2400000.5, which makes it more convenient for modern dates.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from MJD\nmjd = 61041.5\nepc2 = bh.Epoch.from_mjd(mjd, bh.UTC)\nprint(f\"MJD {mjd}: {epc2}\")\n# MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n# Verify round-trip conversion\nmjd_out = epc2.mjd()\nprint(f\"Round-trip MJD: {mjd_out:.6f}\")\n# Round-trip MJD: 61041.500000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from MJD\n    let mjd = 61041.5; // 2024-01-01 12:00:00 UTC\n    let epc2 = bh::Epoch::from_mjd(mjd, bh::TimeSystem::UTC);\n    println!(\"MJD {}: {}\", mjd, epc2);\n    // MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let mjd_out = epc2.mjd();\n    println!(\"Round-trip MJD: {:.6}\", mjd_out);\n    // Round-trip MJD: 61041.500000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#jd","title":"JD","text":"<p>Julian Date (JD) is a continuous count of days since the beginning of the Julian Period. It's widely used in astronomy for precise time calculations.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from JD\njd = 2460310.5\nepc = bh.Epoch.from_jd(jd, bh.UTC)\nprint(f\"JD {jd}: {epc}\")\n# JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"Round-trip JD: {jd_out:.10f}\")\n# Round-trip JD: 2460310.5000000000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from JD\n    let jd = 2460310.5;\n    let epc = bh::Epoch::from_jd(jd, bh::TimeSystem::UTC);\n    println!(\"JD {}: {}\", jd, epc);\n    // JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let jd_out = epc.jd();\n    println!(\"Round-trip JD: {:.10}\", jd_out);\n    // Round-trip JD: 2460310.5000000000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string","title":"String","text":"<p>Epoch instances can be created from ISO 8601 formatted strings or simple date-time strings. The time system can be specified in the string.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# The string can be an ISO 8601 format\nepc1 = bh.Epoch.from_string(\"2025-01-02T04:56:54.123Z\")\nprint(f\"ISO 8601: {epc1}\")\n\n# It can be a simple space-separated format with a time system\nepc2 = bh.Epoch.from_string(\"2024-06-15 14:30:45.500 GPS\")\nprint(f\"Simple format: {epc2}\")\n\n# It can be a datetime without a time system (defaults to UTC)\nepc3 = bh.Epoch.from_string(\"2023-12-31 23:59:59\")\nprint(f\"Datetime without time system: {epc3}\")\n\n# Or it can just be a date\nepc4 = bh.Epoch.from_string(\"2022-07-04\")\nprint(f\"Date only: {epc4}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // The string can be an ISO 8601 format\n    let epc1 = bh::Epoch::from_string(\"2025-01-02T04:56:54.123Z\").unwrap();\n    println!(\"ISO 8601: {}\", epc1);\n\n    // It can be a simple space-separated format with a time system\n    let epc2 = bh::Epoch::from_string(\"2024-06-15 14:30:45.500 GPS\").unwrap();\n    println!(\"Simple format: {}\", epc2);\n\n    // It can be a datetime without a time system (defaults to UTC)\n    let epc3 = bh::Epoch::from_string(\"2023-12-31 23:59:59\").unwrap();\n    println!(\"Datetime without time system: {}\", epc3);\n\n    // Or it can just be a date\n    let epc4 = bh::Epoch::from_string(\"2022-07-04\").unwrap();\n    println!(\"Date only: {}\", epc4);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#gps-week-and-seconds","title":"GPS Week and Seconds","text":"<p>For GPS applications, you can create epochs from GPS week number and seconds into the week, or from GPS seconds since the GPS epoch (January 6, 1980).</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from GPS week and seconds\n# Week 2390, day 2 (October 28, 2025)\nweek = 2390\nseconds = 2 * 86400.0\nepc1 = bh.Epoch.from_gps_date(week, seconds)\nprint(f\"GPS Week {week}, Seconds {seconds}: {epc1}\")\n# GPS Week 2390, Seconds 172800.0: 2025-10-28 00:00:00.000 GPS\n\n# Verify round-trip conversion\nweek_out, sec_out = epc1.gps_date()\nprint(f\"Round-trip: Week {week_out}, Seconds {sec_out:.1f}\")\n# Round-trip: Week 2390, Seconds 172800.0\n\n# Create from GPS seconds since GPS epoch\ngps_seconds = week * 7 * 86400.0 + seconds\nepc2 = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"GPS Seconds {gps_seconds}: {epc2}\")\n# GPS Seconds 1445644800.0: 2025-10-28 00:00:00.000 GPS\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from GPS week and seconds\n    // Week 2390, day 2 (October 28, 2025)\n    let week = 2390;\n    let seconds = 2.0 * 86400.0; // 3 days + 12 hours\n    let epc1 = bh::Epoch::from_gps_date(week, seconds);\n    println!(\"GPS Week {}, Seconds {}: {}\", week, seconds, epc1);\n    // GPS Week 2390, Seconds 172800: 2025-10-28 00:00:00.000 GPS\n\n    // Verify round-trip conversion\n    let (week_out, sec_out) = epc1.gps_date();\n    println!(\"Round-trip: Week {}, Seconds {:.1}\", week_out, sec_out);\n    // Round-trip: Week 2390, Seconds 172800.0\n\n    // Create from GPS seconds since GPS epoch\n    let gps_seconds = week as f64 * 7.0 * 86400.0 + seconds;\n    let epc2 = bh::Epoch::from_gps_seconds(gps_seconds);\n    println!(\"GPS Seconds {}: {}\", gps_seconds, epc2);\n    // 1445644800: 2025-10-28 00:00:00.000 GPS\n}\n</code></pre>"},{"location":"learn/time/epoch.html#operations","title":"Operations","text":"<p>Once you have an epoch class instance you can add and subtract time as you would expect.</p> <p>Info</p> <p>When performing arithmetic the other operand is always interpreted as a time duration in seconds.</p>"},{"location":"learn/time/epoch.html#addition","title":"Addition","text":"<p>You can add a time duration (in seconds) to an Epoch to get a new Epoch at a later time.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2025, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"Original epoch: {epc}\")\n# Original epoch: 2025-01-01 12:00:00.000 UTC\n\n# You can add time in seconds to an Epoch and get a new Epoch back\n\n# Add 1 hour (3600 seconds)\nepc_plus_hour = epc + 3600.0\nprint(f\"Plus 1 hour: {epc_plus_hour}\")\n# Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n# Add 1 day (86400 seconds)\nepc_plus_day = epc + 86400.0\nprint(f\"Plus 1 day: {epc_plus_day}\")\n# Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n# You can also do in-place addition\n\n# Add 1 second in-place\nepc += 1.0\nprint(f\"In-place plus 1 second: {epc}\")\n# In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n# Add 1 milisecond in-place\nepc += 0.001\nprint(f\"In-place plus 1 millisecond: {epc}\")\n# In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2025, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Original epoch: {}\", epc);\n    // Original epoch: 2025-01-01 12:00:00.000 UTC\n\n    // You can add time in seconds to an Epoch and get a new Epoch back\n\n    // Add 1 hour (3600 seconds)\n    let epc_plus_hour = epc + 3600.0;\n    println!(\"Plus 1 hour: {}\", epc_plus_hour);\n    // Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n    // Add 1 day (86400 seconds)\n    let epc_plus_day = epc + 86400.0;\n    println!(\"Plus 1 day: {}\", epc_plus_day);\n    // Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n    // You can also do in-place addition\n\n    // Add 1 second in-place\n    let mut epc = epc;\n    epc += 1.0;\n    println!(\"In-place plus 1 second: {}\", epc);\n    // In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n    // Add 1 millisecond in-place\n    epc += 0.001;\n    println!(\"In-place plus 1 millisecond: {}\", epc);\n    // In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#subtraction","title":"Subtraction","text":"<p>Subtracting two Epoch instances returns the time difference between them in seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# You can subtract two Epoch instances to get the time difference in seconds\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(2024, 1, 2, 12, 1, 1.0, 0.0)\n\ndt = epc2 - epc1\nprint(f\"Time difference: {dt:.1f} seconds\")\n\n\n# You can also subtract a float (in seconds) from an Epoch to get a new Epoch\nepc = bh.Epoch(2024, 6, 15, 10, 30, 0.0, 0.0)\n\n# Subtract 1 hour (3600 seconds)\nepc_minus_hour = epc - 3600.0\nprint(f\"Minus 1 hour: {epc_minus_hour}\")\n\n# You can also update an Epoch in-place by subtracting seconds\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, 0.0)\nepc -= 61.0  # Subtract 61 seconds\nprint(f\"In-place minus 61 seconds: {epc}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create two epochs\n    let epc1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc2 = bh::Epoch::from_datetime(2024, 1, 2, 13, 1, 1.0, 0.0, bh::TimeSystem::UTC);\n\n    // Compute time difference in seconds\n    let dt = epc2 - epc1;\n    println!(\"Time difference: {:.1} seconds\", dt);\n    // Time difference: 90061.0 seconds\n\n    // You can also subtract a float (in seconds) from an Epoch to get a new Epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 10, 30, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_minus_hour = epc - 3600.0;\n    println!(\"Minus 1 hour: {}\", epc_minus_hour);\n    // Minus 1 hour: 2024-06-15 09:30:00.000 UTC\n\n    // You can also update an Epoch in-place by subtracting seconds\n    let mut epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    epc -= 61.0; // Subtract 61 seconds\n    println!(\"In-place minus 61 seconds: {}\", epc);\n    // In-place minus 61 seconds: 2023-12-31 23:58:59.000 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#other-operations","title":"Other Operations","text":"<p>The Epoch class also supports comparison operations (e.g., equality, less than, greater than) to compare different time instances. It also supports methods for getting string representations using language-specific formatting options.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc_1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc_2 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 1.0)\nepc_3 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\n\n# You can compare two Epoch instances for equality\nprint(f\"epc_1 == epc_2: {epc_1 == epc_2}\")\n# epc_1 == epc_2: False\nprint(f\"epc_1 == epc_3: {epc_1 == epc_3}\")\n# epc_1 == epc_3: True\n\n# You can also use inequality and comparison operators\nprint(f\"epc_1 != epc_2: {epc_1 != epc_2}\")\n# epc_1 != epc_2: True\nprint(f\"epc_1 &lt; epc_2: {epc_1 &lt; epc_2}\")\n# epc_1 &lt; epc_2: True\nprint(f\"epc_2 &lt; epc_1: {epc_2 &lt; epc_1}\")\n# epc_2 &gt; epc_1: False\nprint(f\"epc_2 &gt; epc_1: {epc_2 &gt; epc_1}\")\n# epc_2 &gt; epc_1: True\nprint(f\"epc_1 &lt;= epc_3: {epc_1 &lt;= epc_3}\")\n# epc_1 &lt;= epc_3: True\nprint(f\"epc_2 &gt;= epc_1: {epc_2 &gt;= epc_1}\")\n# epc_2 &gt;= epc_1: True\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc_1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_2 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 1.0, bh::TimeSystem::UTC);\n    let epc_3 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // You can compare two Epoch instances for equality\n    println!(\"epc_1 == epc_2: {}\", epc_1 == epc_2);\n    // epc_1 == epc_2: false\n    println!(\"epc_1 == epc_3: {}\", epc_1 == epc_3);\n    // epc_1 == epc_3: true\n\n    // You can also use inequality and comparison operators\n    println!(\"epc_1 != epc_2: {}\", epc_1 != epc_2);\n    // epc_1 != epc_2: true\n    println!(\"epc_1 &lt; epc_2: {}\", epc_1 &lt; epc_2);\n    // epc_1 &lt; epc_2: true\n    println!(\"epc_2 &lt; epc_1: {}\", epc_2 &lt; epc_1);\n    // epc_2 &gt; epc_1: false\n    println!(\"epc_2 &gt; epc_1: {}\", epc_2 &gt; epc_1);\n    // epc_2 &gt; epc_1: true\n    println!(\"epc_1 &lt;= epc_3: {}\", epc_1 &lt;= epc_3);\n    // epc_1 &lt;= epc_3: true\n    println!(\"epc_2 &gt;= epc_1: {}\", epc_2 &gt;= epc_1);\n    // epc_2 &gt;= epc_1: true\n}\n</code></pre>"},{"location":"learn/time/epoch.html#output-and-formatting","title":"Output and Formatting","text":"<p>Finally, you can take any Epoch instance and then output it in different representations.</p>"},{"location":"learn/time/epoch.html#date-time_1","title":"Date Time","text":"<p>You can extract the date and time components from an Epoch, optionally converting to a different time system.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-06-15 14:30:45.500 UTC\n\n# Output the equivalent Julian Date\njd = epc.jd()\nprint(f\"Julian Date: {jd:.6f}\")\n# Julian Date: 2460477.104693\n\n# Get the Julian Date in a different time system (e.g., TT)\njd_tt = epc.jd_as_time_system(time_system=bh.TT)\nprint(f\"Julian Date (TT): {jd_tt:.6f}\")\n# Julian Date (TT): 2460477.105494\n\n# Output the equivalent Modified Julian Date\nmjd = epc.mjd()\nprint(f\"Modified Julian Date: {mjd:.6f}\")\n# Modified Julian Date: 60476.604693\n\n# Get the Modified Julian Date in a different time system (e.g., GPS)\nmjd_gps = epc.mjd_as_time_system(time_system=bh.GPS)\nprint(f\"Modified Julian Date (GPS): {mjd_gps:.6f}\")\n# Modified Julian Date (GPS): 60476.604902\n\n# Get the GPS Week and Seconds of Week\ngps_week, gps_sow = epc.gps_date()\nprint(f\"GPS Week: {gps_week}, Seconds of Week: {gps_sow:.3f}\")\n# GPS Week: 2318, Seconds of Week: 570663.500\n\n# The Epoch as GPS seconds since the GPS epoch\ngps_seconds = epc.gps_seconds()\nprint(f\"GPS Seconds since epoch: {gps_seconds:.3f}\")\n# GPS Seconds since epoch: 1402497063.500\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-06-15 14:30:45.500 UTC\n\n    // Output the equivalent Julian Date\n    let jd = epc.jd();\n    println!(\"Julian Date: {:.6}\", jd);\n    // Julian Date: 2460477.104693\n\n    // Get the Julian Date in a different time system (e.g., TT)\n    let jd_tt = epc.jd_as_time_system(bh::TimeSystem::TT);\n    println!(\"Julian Date (TT): {:.6}\", jd_tt);\n    // Julian Date (TT): 2460477.105494\n\n    // Output the equivalent Modified Julian Date\n    let mjd = epc.mjd();\n    println!(\"Modified Julian Date: {:.6}\", mjd);\n    // Modified Julian Date: 60476.604693\n\n    // Get the Modified Julian Date in a different time system (e.g., GPS)\n    let mjd_gps = epc.mjd_as_time_system(bh::TimeSystem::GPS);\n    println!(\"Modified Julian Date (GPS): {:.6}\", mjd_gps);\n    // Modified Julian Date (GPS): 60476.604902\n\n    // Get the GPS Week and Seconds of Week\n    let (gps_week, gps_sow) = epc.gps_date();\n    println!(\"GPS Week: {}, Seconds of Week: {:.3}\", gps_week, gps_sow);\n    // GPS Week: 2318, Seconds of Week: 570663.500\n\n    // The Epoch as GPS seconds since the GPS epoch\n    let gps_seconds = epc.gps_seconds();\n    println!(\"GPS Seconds since epoch: {:.3}\", gps_seconds);\n    // GPS Seconds since epoch: 1402497063.500\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string-representation","title":"String Representation","text":"<p>Epochs can be converted to human-readable strings in various formats and time systems.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.123456789, 0.0)\n\n# Default string representation\nprint(f\"Default: {epc}\")\n# Default: 2024-06-15 14:30:45.123 UTC\n\n# Explicit string conversion\nprint(f\"String: {str(epc)}\")\n# String: 2024-06-15 14:30:45.123 UTC\n\n# Debug representation\nprint(f\"Debug: {repr(epc)}\")\n# Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n# Get string in a different time system\nprint(f\"TT: {epc.to_string_as_time_system(bh.TimeSystem.TT)}\")\n# TT: 2024-06-15 14:31:54.307 TT\n\n# Get as ISO 8601 formatted string\nprint(f\"ISO 8601: {epc.isostring()}\")\n# ISO 8601: 2024-06-15T14:30:45Z\n\n# Get as ISO 8601 with different number of decimal places\nprint(f\"ISO 8601 (0 decimal places): {epc.isostring_with_decimals(0)}\")\nprint(f\"ISO 8601 (3 decimal places): {epc.isostring_with_decimals(3)}\")\nprint(f\"ISO 8601 (6 decimal places): {epc.isostring_with_decimals(6)}\")\n# ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n# ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n# ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.123456789, 0.0, bh::TimeSystem::UTC);\n\n    // Default string representation\n    println!(\"Default: {}\", epc);\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Explicit string conversion (same as default in Rust)\n    println!(\"String: {}\", epc.to_string());\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Debug representation\n    println!(\"Debug: {:?}\", epc);\n    // Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n    // Get string in a different time system\n    println!(\"TT: {}\", epc.to_string_as_time_system(bh::TimeSystem::TT));\n    // TT: 2024-06-15 14:31:54.307 TT\n\n    // Get as ISO 8601 formatted string\n    println!(\"ISO 8601: {}\", epc.isostring());\n    // ISO 8601: 2024-06-15T14:30:45Z\n\n    // Get as ISO 8601 with different number of decimal places\n    println!(\"ISO 8601 (0 decimal places): {}\", epc.isostring_with_decimals(0));\n    println!(\"ISO 8601 (3 decimal places): {}\", epc.isostring_with_decimals(3));\n    println!(\"ISO 8601 (6 decimal places): {}\", epc.isostring_with_decimals(6));\n    // ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n    // ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n    // ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n}\n</code></pre>"},{"location":"learn/time/epoch.html#see-also","title":"See Also","text":"<ul> <li>Epoch API Reference</li> </ul>"},{"location":"learn/time/time_range.html","title":"Time Range","text":"<p>The <code>TimeRange</code> class provides an easy way to iterate over a range of time instances. You can specify a start and end <code>Epoch</code>, along with a time step in seconds, and the <code>TimeRange</code> will generate all the <code>Epoch</code> instances within that range at the specified intervals.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nfor epc in bh.TimeRange(\n    bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC),\n    bh.Epoch(2024, 1, 2, 0, 0, 0.0, time_system=bh.UTC),\n    3600.0,\n):\n    print(epc)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    for epc in bh::TimeRange::new(\n        bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        bh::Epoch::from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        3600.0\n    ) {\n        println!(\"{}\", epc);\n    }\n}\n</code></pre>"},{"location":"learn/trajectories/index.html","title":"Trajectories","text":"<p>Brahe provides trajectory containers for storing and managing time-series state data. A trajectory is a sequence of state vectors (positions, velocities, or other multi-dimensional data) indexed by time epochs. Trajectories store the dynamic state evolution and provide a number of convenience methods for accessing, querying, and manipulating the data.</p>"},{"location":"learn/trajectories/index.html#trajectory-traits","title":"Trajectory Traits","text":"<p>Brahe's trajectory system is built on a set of Rust traits that define common functionality. This design allows for common access patterns across different trajectory implementations, while enabling specialized behavior for specific use cases.</p> <p>Generally, a \"state\" is a vector of floating-point numbers representing some dynamic quantity. For most applications in Brahe, states are 6-dimensional vectors representing the satellite position and velocity in 3D space. However, the trajectory system is flexible enough to handle arbitrary state definitions.</p>"},{"location":"learn/trajectories/index.html#trajectory-trait","title":"<code>Trajectory</code> Trait","text":"<p>The <code>Trajectory</code> trait is the foundation of all trajectory implementations. It defines the core interface for storing, accessing, and managing time-series state data. Any Trajectory implementation must implement this trait which requires the implementation of the following methods:</p> <p>Creation:</p> <ul> <li><code>from_data(epochs, states)</code> - Create trajectory from vectors of epochs and states</li> <li><code>add(epoch, state)</code> - Add a single state at a specific epoch</li> </ul> <p>Access:</p> <ul> <li><code>epoch_at_idx(index)</code> - Get epoch at a specific index</li> <li><code>state_at_idx(index)</code> - Get state at a specific index</li> <li><code>get(epoch)</code> - Get exact state if epoch exists</li> <li><code>nearest_state(epoch)</code> - Get state at nearest epoch to query time</li> </ul> <p>Querying:</p> <ul> <li><code>len()</code> - Number of states in trajectory</li> <li><code>is_empty()</code> - Check if trajectory contains no states</li> <li><code>start_epoch()</code> - First epoch in trajectory</li> <li><code>end_epoch()</code> - Last epoch in trajectory</li> <li><code>timespan()</code> - Duration between first and last epochs (seconds)</li> <li><code>first()</code> - Get first epoch-state pair</li> <li><code>last()</code> - Get last epoch-state pair</li> </ul> <p>Modification:</p> <ul> <li><code>clear()</code> - Remove all states</li> <li><code>remove_epoch(epoch)</code> - Remove state at specific epoch</li> <li><code>remove(index)</code> - Remove state at specific index</li> </ul> <p>Temporal Indexing:</p> <ul> <li><code>index_before_epoch(epoch)</code> - Find index of state before query epoch</li> <li><code>index_after_epoch(epoch)</code> - Find index of state after query epoch</li> <li><code>state_before_epoch(epoch)</code> - Get state before query epoch</li> <li><code>state_after_epoch(epoch)</code> - Get state after query epoch</li> </ul> <p>Memory Management:</p> <ul> <li><code>set_eviction_policy_max_size(size)</code> - Limit trajectory to N most recent states</li> <li><code>set_eviction_policy_max_age(duration_seconds)</code> - Keep only states within time window</li> <li><code>get_eviction_policy()</code> - Get current eviction policy</li> </ul>"},{"location":"learn/trajectories/index.html#interpolatable-trait","title":"<code>Interpolatable</code> Trait","text":"<p>Since trajectories often store states at discrete epochs, the <code>Interpolatable</code> trait provides methods for interpolating states at arbitrary times between stored data points. This is useful for applications that require continuous state estimates.</p> <p>Methods:</p> <ul> <li><code>interpolate(epoch)</code> - Get interpolated state at arbitrary epoch</li> <li><code>set_interpolation_method(method)</code> - Configure interpolation algorithm</li> <li><code>get_interpolation_method()</code> - Get current interpolation method</li> </ul> <p>Supported Interpolation Methods (via <code>InterpolationMethod</code> enum):</p> <ul> <li><code>Linear</code> - Linear interpolation between adjacent states (default)</li> </ul>"},{"location":"learn/trajectories/index.html#orbitaltrajectory-trait","title":"<code>OrbitalTrajectory</code> Trait","text":"<p>The <code>OrbitalTrajectory</code> trait specializes trajectories for orbital mechanics applications. It adds awareness of reference frames (ECI/ECEF) and orbital representations (Cartesian/Keplerian), enabling automatic conversions of the stored states to different frames or representations.</p> <p>Creation:</p> <ul> <li><code>from_orbital_data(epochs, states, frame, representation, angle_format)</code> - Create from orbital data with frame/representation metadata</li> </ul> <p>Frame Conversions:</p> <ul> <li><code>to_eci()</code> - Convert all states to Earth-Centered Inertial frame</li> <li><code>to_ecef()</code> - Convert all states to Earth-Centered Earth-Fixed frame</li> </ul> <p>Representation Conversions:</p> <ul> <li><code>to_keplerian(angle_format)</code> - Convert Cartesian states to Keplerian orbital elements</li> </ul>"},{"location":"learn/trajectories/index.html#supporting-types","title":"Supporting Types","text":""},{"location":"learn/trajectories/index.html#interpolationmethod","title":"InterpolationMethod","text":"<p>Defines interpolation algorithms available for computing states at arbitrary epochs:</p> <ul> <li><code>Linear</code> - Linear interpolation between adjacent state vectors (default)</li> </ul>"},{"location":"learn/trajectories/index.html#trajectoryevictionpolicy","title":"TrajectoryEvictionPolicy","text":"<p>Controls automatic memory management for long-running applications:</p> <ul> <li><code>None</code> - Keep all states indefinitely (default)</li> <li><code>KeepCount(n)</code> - Keep only the N most recent states, removing older ones</li> <li><code>KeepWithinDuration(seconds)</code> - Keep only states within time window from most recent epoch</li> </ul> <p>Eviction policies are useful for real-time applications where memory must be bounded, such as satellite ground station passes or long-term simulations.</p>"},{"location":"learn/trajectories/index.html#orbitframe","title":"OrbitFrame","text":"<p>Specifies the reference frame for orbital states:</p> <ul> <li><code>ECI</code> - Earth-Centered Inertial frame (GCRF/J2000)</li> <li><code>ECEF</code> - Earth-Centered Earth-Fixed frame</li> </ul>"},{"location":"learn/trajectories/index.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies how orbital states are represented:</p> <ul> <li><code>Cartesian</code> - Position and velocity vectors \\(\\[p_x, p_y, p_z, v_x, v_y, v_z\\]\\) in meters and m/s</li> <li><code>Keplerian</code> - Classical orbital elements \\(\\[a, e, i, \\Omega, \\omega, M\\]\\) where:<ul> <li>\\(a\\) - Semi-major axis (meters)</li> <li>\\(e\\) - Eccentricity (dimensionless)</li> <li>\\(i\\) - Inclination (radians or degrees)</li> <li>\\(\\Omega\\) - Right ascension of ascending node (radians or degrees)</li> <li>\\(\\omega\\) - Argument of periapsis (radians or degrees)</li> <li>\\(M\\) - Mean anomaly (radians or degrees)</li> </ul> </li> </ul>"},{"location":"learn/trajectories/index.html#choosing-a-trajectory-implementation","title":"Choosing a Trajectory Implementation","text":"<p>Brahe provides three trajectory implementations, each optimized for different use cases:</p>"},{"location":"learn/trajectories/index.html#dtrajectory-dynamic-dimensions","title":"DTrajectory - Dynamic Dimensions","text":"<p>The <code>DTrajectory</code> implementation supports runtime-sized state vectors, allowing for arbitrary state dimensions. This makes it able to accomodate applications where users may want to augment the state vector with additional parameters beyond standard position/velocity.</p> <p>Features:</p> <ul> <li>Runtime-sized state vectors (any dimension)</li> <li>Frame-agnostic storage</li> <li>Flexible for arbitrary state data</li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code></li> </ul>"},{"location":"learn/trajectories/index.html#strajectory-static-dimensions","title":"STrajectory - Static Dimensions <p>The <code>STrajectory&lt;R&gt;</code> implementation uses compile-time sized state vectors, providing maximum performance for applications where the state dimension is known ahead of time. The generic parameter <code>R</code> specifies the number of state dimensions.</p> <p>Features:</p> <ul> <li>Compile-time sized state vectors (maximum performance)</li> <li>Type-safe dimensions</li> <li>Common type aliases: <code>STrajectory3</code>, <code>STrajectory4</code>, <code>STrajectory6</code></li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code></li> </ul>  <p>Tip</p> <p>Because <code>STrajectory</code> uses compile-time dimensions python bindings are only provided for common sizes of <code>STrajectory3</code>, <code>STrajectory4</code>, and <code>STrajectory6</code>.</p> <p>Rust users can create <code>STrajectory</code> instances with any dimension using the generic type.</p>","text":""},{"location":"learn/trajectories/index.html#sorbittrajectory-orbital-mechanics","title":"SOrbitTrajectory - Orbital Mechanics <p>The <code>SOrbitTrajectory</code> implementation is specialized for orbital mechanics applications. It always 6-dimensional state vectors (position + velocity or orbital elements) and tracks the reference frame (ECI/ECEF) and representation (Cartesian/Keplerian). It provides built-in methods for converting between frames and representations. The <code>SOrbitTrajectory</code> is ideal for satellite orbit propagation and analysis where you expect to need frame conversions.</p> <p>Features:</p> <ul> <li>Always 6-dimensional (position + velocity)</li> <li>Tracks reference frame (ECI/ECEF)</li> <li>Tracks representation (Cartesian/Keplerian)</li> <li>Frame conversions: ECI \u2194 ECEF</li> <li>Representation conversions: Cartesian \u2194 Keplerian</li> <li>Implements traits: <code>Trajectory</code>, <code>Interpolatable</code>, <code>OrbitalTrajectory</code></li> </ul>","text":""},{"location":"learn/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>Trajectory - Dynamic-dimension trajectory implementation</li> <li>OrbitTrajectory - Orbital mechanics trajectory with frame conversions</li> <li>API Reference</li> </ul>"},{"location":"learn/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that tracks reference frames (ECI/ECEF) and orbital representations (Cartesian/Keplerian). Unlike <code>Trajectory</code> which store frame-agnostic data, <code>OrbitTrajectory</code> understands orbital mechanics and enables automatic conversions between reference frames and representations.</p> <p>Use <code>OrbitTrajectory</code> when:</p> <ul> <li>Working with orbital mechanics applications</li> <li>Need to convert between ECI and ECEF frames</li> <li>Need to convert between Cartesian and Keplerian representations</li> <li>Want frame/representation metadata tracked automatically</li> <li>Working with propagators that output orbital trajectories</li> </ul> <p><code>OrbitTrajectory</code> implements the <code>OrbitalTrajectory</code> trait in addition to <code>Trajectory</code> and <code>Interpolatable</code>, providing orbital-specific functionality on top of the standard trajectory interface.</p>"},{"location":"learn/trajectories/orbit_trajectory.html#initialization","title":"Initialization","text":""},{"location":"learn/trajectories/orbit_trajectory.html#empty-trajectory-cartesian-representation","title":"Empty Trajectory - Cartesian Representation","text":"<p>For cartesian representation, the frame can be <code>ECI</code> or <code>ECEF</code>. The <code>AngleFormat</code> must be <code>None</code> for Cartesian representations</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame, Cartesian representation\ntraj_eci = bh.OrbitTrajectory(\n    6,  # State dimension (position + velocity)\n    bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    None,  # No angle format for Cartesian\n)\nprint(f\"Frame (str): {traj_eci.frame}\")  # Output: ECI\nprint(\n    f\"Frame (repr): {repr(traj_eci.frame)}\"\n)  # Output: OrbitFrame(Earth-Centered Inertial)\nprint(f\"Representation (str): {traj_eci.representation}\")  # Output: Cartesian\nprint(\n    f\"Representation (repr): {repr(traj_eci.representation)}\"\n)  # Output: OrbitRepresentation(Cartesian)\n\n# Create trajectory in ECEF frame, Cartesian representation\ntraj_ecef = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None\n)\nprint(f\"Frame (str): {traj_ecef.frame}\")  # Output: ECEF\nprint(\n    f\"Frame (repr): {repr(traj_ecef.frame)}\"\n)  # Output: OrbitFrame(Earth-Centered Earth-Fixed)\n\n# Output:\n# Frame (str): ECI\n# Frame (repr): OrbitFrame(Earth-Centered Inertial)\n# Representation (str): Cartesian\n# Representation (repr): OrbitRepresentation(Cartesian)\n# Frame (str): ECEF\n# Frame (repr): OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame, Cartesian representation\n    let traj_eci = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n    println!(\"Frame (Display): {}\", traj_eci.frame);\n    println!(\"Frame (Debug): {:?}\", traj_eci.frame);\n    println!(\"Representation (Display): {}\", traj_eci.representation);\n    println!(\"Representation (Debug): {:?}\", traj_eci.representation);\n\n    // Create trajectory in ECEF frame, Cartesian representation\n    let traj_ecef = SOrbitTrajectory::new(\n        OrbitFrame::ECEF,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n    println!(\"Frame (Display): {}\", traj_ecef.frame);\n    println!(\"Frame (Debug): {:?}\", traj_ecef.frame);\n}\n\n// Output:\n// Frame (Display): ECI\n// Frame (Debug): OrbitFrame(Earth-Centered Inertial)\n// Representation (Display): OrbitRepresentation(Cartesian)\n// Representation (Debug): Cartesian\n// Frame (Display): ECEF\n// Frame (Debug): OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#empty-trajectory-keplerian-elements","title":"Empty Trajectory - Keplerian Elements","text":"<p>To create an empty trajectory in Keplerian representation you must specify the frame as <code>ECI</code> and provide an <code>AngleFormat</code>.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame, Keplerian representation with radians\ntraj_kep_rad = bh.OrbitTrajectory(\n    6,  # State dimension (6 orbital elements)\n    bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.KEPLERIAN,\n    bh.AngleFormat.RADIANS,  # Required for Keplerian\n)\n\n# Create trajectory in ECI frame, Keplerian representation with degrees\ntraj_kep_deg = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES\n)\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\nuse bh::AngleFormat;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame, Keplerian representation with radians\n    let _traj_kep_rad = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Keplerian,\n        Some(AngleFormat::Radians)\n    );\n\n    // Create trajectory in ECI frame, Keplerian representation with degrees\n    let _traj_kep_deg = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Keplerian,\n        Some(AngleFormat::Degrees)\n    );\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#from-existing-data","title":"From Existing Data","text":"<p>You can also initialize an <code>OrbitTrajectory</code> from existing epoch and state data:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create epochs\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch1 = epoch0 + 60.0\nepoch2 = epoch0 + 120.0\n\n# Create Cartesian states in ECI\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\nstate2 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\n\n# Create trajectory from data\nepochs = [epoch0, epoch1, epoch2]\nstates = np.array([state0, state1, state2])  # Flattened array\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    epochs, states, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epochs\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let epoch1 = epoch0 + 60.0;\n    let epoch2 = epoch0 + 120.0;\n\n    // Create Cartesian states\n    let state0 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    let state1 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    );\n    let state2 = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    );\n\n    // Create trajectory from data\n    let epochs = vec![epoch0, epoch1, epoch2];\n    let states = vec![state0, state1, state2];\n    let traj = SOrbitTrajectory::from_orbital_data(\n        epochs,\n        states,\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None, // Angle Format\n        None  // No covariances\n    );\n\n    println!(\"Trajectory length: {}\", traj.len());  \n    // Trajectory length: 3\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#from-propagator","title":"From Propagator","text":"<p>The most common way to get an <code>OrbitTrajectory</code> from a propagator. All orbit propagators in Brahe have a <code>*.trajectory</code> attribute which is an <code>OrbitTrajectory</code>.</p> <p>See the Propagators section for more details on propagators.</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define orbital elements for a 500 km circular orbit\na = bh.R_EARTH + 500e3\ne = 0.001\ni = 97.8  # Sun-synchronous\nraan = 15.0\nargp = 30.0\nM = 0.0\noe = np.array([a, e, i, raan, argp, M])\n\n# Create epoch and propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, oe, bh.AngleFormat.DEGREES, 60.0\n)\n\n# Propagate for several steps\npropagator.propagate_steps(10)\n\n# Access the trajectory\ntraj = propagator.trajectory\nprint(f\"Trajectory length: {len(traj)}\")  # Output: 11 (initial + 10 steps)\nprint(f\"Frame: {traj.frame}\")  # Output: OrbitFrame.ECI\nprint(f\"Representation: {traj.representation}\")  # Output: Keplerian\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::traits::{Trajectory, SStatePropagator};\nuse bh::{KeplerianPropagator, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 97.8_f64.to_radians(),\n        15.0_f64.to_radians(), 30.0_f64.to_radians(), 0.0\n    );\n\n    // Create epoch and propagator\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch, oe, AngleFormat::Radians, 60.0\n    );\n\n    // Propagate for several steps\n    propagator.propagate_steps(10);\n\n    // Access the trajectory\n    let traj = &amp;propagator.trajectory;\n    println!(\"Trajectory length: {}\", traj.len());  // Output: 11\n    println!(\"Frame: {}\", traj.frame);  // Output: ECI\n    println!(\"Representation: {}\", traj.representation);  // Output: Keplerian\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#frame-conversions","title":"Frame Conversions","text":"<p>The key feature of <code>OrbitTrajectory</code> is automatic frame conversions of the trajectory data to different reference frames and representations. In particular, with a single method call you can convert between ECI and ECEF frames, and between Cartesian and Keplerian representations.</p>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-eci-to-ecef","title":"Converting ECI to ECEF","text":"<p>Convert a trajectory from Earth-Centered Inertial (ECI) to Earth-Centered Earth-Fixed (ECEF):</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI frame\ntraj_eci = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add states in ECI\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    # Define state at epoch\n    state_eci = np.array([bh.R_EARTH + 500e3, i * 100e3, 0.0, 0.0, 7600.0, 0.0])\n    traj_eci.add(epoch, state_eci)\n\nprint(f\"Original frame: {traj_eci.frame}\")\nprint(f\"Original representation: {traj_eci.representation}\")\n\n# Convert all states in trajectory to ECEF\ntraj_ecef = traj_eci.to_ecef()\n\nprint(f\"\\nConverted frame: {traj_ecef.frame}\")\nprint(f\"Converted representation: {traj_ecef.representation}\")\nprint(f\"Same number of states: {len(traj_ecef)}\")\n\n# Compare first states\n_, state_eci = traj_eci.first()\n_, state_ecef = traj_ecef.first()\nprint(\n    f\"\\nFirst ECI state: [{state_eci[0]:.2f}, {state_eci[1]:.2f}, {state_eci[2]:.2f}] m\"\n)\nprint(\n    f\"First ECEF state: [{state_ecef[0]:.2f}, {state_ecef[1]:.2f}, {state_ecef[2]:.2f}] m\"\n)\n\n# Output:\n# Original frame: ECI\n# Original representation: Cartesian\n\n# Converted frame: ECEF\n# Converted representation: Cartesian\n# Same number of states: 5\n\n# First ECI state: [6878136.30, 0.00, 0.00] m\n# First ECEF state: [-1176064.06, -6776826.51, 15961.82] m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI frame\n    let mut traj_eci = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states in ECI\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state_eci = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, (i as f64) * 100e3, 0.0, 0.0, 7600.0, 0.0\n        );\n        traj_eci.add(epoch, state_eci);\n    }\n\n    println!(\"Original frame: {:?}\", traj_eci.frame);\n    println!(\"Original representation: {:?}\", traj_eci.representation);\n\n    // Convert all states in trajectory to ECEF\n    let traj_ecef = traj_eci.to_ecef();\n\n    println!(\"\\nConverted frame: {:?}\", traj_ecef.frame);\n    println!(\"Converted representation: {:?}\", traj_ecef.representation);\n    println!(\"Same number of states: {}\", traj_ecef.len());\n\n    // Compare first states\n    let state_eci_first = traj_eci.state_at_idx(0).unwrap();\n    let state_ecef_first = traj_ecef.state_at_idx(0).unwrap();\n    println!(\"\\nFirst state ECI: [{}, {}, {}] m\",\n        state_eci_first[0], state_eci_first[1], state_eci_first[2]\n    );\n    println!(\"First state ECEF: [{}, {}, {}] m\",\n        state_ecef_first[0], state_ecef_first[1], state_ecef_first[2]\n    );\n}\n\n// Output:\n// Original frame: OrbitFrame(Earth-Centered Inertial)\n// Original representation: OrbitRepresentation(Cartesian)\n\n// Converted frame: OrbitFrame(Earth-Centered Earth-Fixed)\n// Converted representation: OrbitRepresentation(Cartesian)\n// Same number of states: 5\n\n// First state ECI: [6878136.3, 0, 0] m\n// First state ECEF: [-1176064.0596141217, -6776826.507241379, 15961.82358860613] m\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-ecef-to-eci","title":"Converting ECEF to ECI","text":"<p>Convert from ECEF back to ECI:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECEF frame\ntraj_ecef = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add dummy states in ECEF\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    # Define state at epoch\n    state_ecef = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 7600.0])\n    traj_ecef.add(epoch, state_ecef)\n\nprint(f\"Original frame: {traj_ecef.frame}\")  # Output: OrbitFrame.ECEF\n\n# Convert to ECI\ntraj_eci = traj_ecef.to_eci()\n\nprint(f\"Converted frame: {traj_eci.frame}\")  # Output: OrbitFrame.ECI\nprint(f\"Trajectory length: {len(traj_eci)}\")  # Output: 3\n\n# Iterate over converted states\nfor epoch, state_eci in traj_eci:\n    pos_mag = np.linalg.norm(state_eci[0:3])\n    vel_mag = np.linalg.norm(state_eci[3:6])\n    print(f\"Epoch: {epoch}\")\n    print(f\"  Position magnitude: {pos_mag / 1e3:.2f} km\")\n    print(f\"  Velocity magnitude: {vel_mag:.2f} m/s\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECEF frame\n    let mut traj_ecef = SOrbitTrajectory::new(\n        OrbitFrame::ECEF,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add dummy states in ECEF\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state_ecef = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 7600.0\n        );\n        traj_ecef.add(epoch, state_ecef);\n    }\n\n    println!(\"Original frame: {:?}\", traj_ecef.frame);\n\n    // Convert to ECI\n    let traj_eci = traj_ecef.to_eci();\n\n    println!(\"Converted frame: {:?}\", traj_eci.frame);\n    println!(\"Trajectory length: {}\", traj_eci.len());\n\n    // Iterate over converted states\n    for (epoch, state_eci) in &amp;traj_eci {\n        let pos_mag = state_eci.fixed_rows::&lt;3&gt;(0).norm();\n        let vel_mag = state_eci.fixed_rows::&lt;3&gt;(3).norm();\n        println!(\"Epoch: {}\", epoch);\n        println!(\"  Position magnitude: {:.2} km\", pos_mag / 1e3);\n        println!(\"  Velocity magnitude: {:.2} m/s\", vel_mag);\n    }\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#round-trip-frame-conversion","title":"Round-Trip Frame Conversion","text":"<p>Convert from ECI to ECEF and back to verify consistency:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI\ntraj_eci_original = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add a state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_original = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj_eci_original.add(epoch, state_original)\n\n# Convert to ECEF and back to ECI\ntraj_ecef = traj_eci_original.to_ecef()\ntraj_eci_roundtrip = traj_ecef.to_eci()\n\n# Compare original and round-trip states\n_, state_roundtrip = traj_eci_roundtrip.first()\ndiff = np.abs(state_original - state_roundtrip)\n\nprint(f\"Position difference: {np.linalg.norm(diff[0:3]):.6e} m\")\nprint(f\"Velocity difference: {np.linalg.norm(diff[3:6]):.6e} m/s\")\n# Expected: Very small differences (numerical precision)\n\n# Output:\n# Position difference: 2.499882e-10 m\n# Velocity difference: 1.829382e-12 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI\n    let mut traj_eci_original = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add a state\n    let epoch = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state_original = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    );\n    traj_eci_original.add(epoch, state_original);\n\n    // Convert to ECEF and back to ECI\n    let traj_ecef = traj_eci_original.to_ecef();\n    let traj_eci_roundtrip = traj_ecef.to_eci();\n\n    // Compare original and round-trip states\n    let (_, state_roundtrip) = traj_eci_roundtrip.first().unwrap();\n    let diff = state_original - state_roundtrip;\n\n    println!(\"Position difference: {:.6e} m\",\n        diff.fixed_rows::&lt;3&gt;(0).norm());\n    println!(\"Velocity difference: {:.6e} m/s\",\n        diff.fixed_rows::&lt;3&gt;(3).norm());\n    // Expected: Very small differences (numerical precision)\n}\n\n// Output:\n// Position difference: 2.499882e-10 m\n// Velocity difference: 1.829382e-12 m/s\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-cartesian-to-keplerian","title":"Converting Cartesian to Keplerian","text":"<p>Convert from Cartesian position/velocity to Keplerian orbital elements:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI Cartesian\ntraj_cart = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add Cartesian states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(3):\n    epoch = epoch0 + i * 300.0  # 5-minute intervals\n    # Use orbital elements to create realistic Cartesian states\n    oe = np.array([bh.R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, i * 10.0])\n    state_cart = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n    traj_cart.add(epoch, state_cart)\n\nprint(f\"Original representation: {traj_cart.representation}\")\n# Output: OrbitRepresentation.CARTESIAN\n\n# Convert to Keplerian with degrees\ntraj_kep = traj_cart.to_keplerian(bh.AngleFormat.DEGREES)\n\nprint(f\"Converted representation: {traj_kep.representation}\")\n# Output: OrbitRepresentation.KEPLERIAN\nprint(f\"Angle format: {traj_kep.angle_format}\")\n# Output: AngleFormat.DEGREES\n\n# Examine Keplerian elements\nfor epoch, oe in traj_kep:\n    print(f\"\\nEpoch: {epoch}\")\n    print(f\"  Semi-major axis: {oe[0] / 1e3:.2f} km\")\n    print(f\"  Eccentricity: {oe[1]:.6f}\")\n    print(f\"  Inclination: {oe[2]:.2f}\u00b0\")\n    print(f\"  RAAN: {oe[3]:.2f}\u00b0\")\n    print(f\"  Argument of perigee: {oe[4]:.2f}\u00b0\")\n    print(f\"  Mean anomaly: {oe[5]:.2f}\u00b0\")\n\n# Output:\n# Original representation: Cartesian\n# Converted representation: Keplerian\n# Angle format: Degrees\n\n# Epoch: 2024-01-01 00:00:00.000 UTC\n#   Semi-major axis: 6878.14 km\n#   Eccentricity: 0.001000\n#   Inclination: 97.80\u00b0\n#   RAAN: 15.00\u00b0\n#   Argument of perigee: 30.00\u00b0\n#   True anomaly: 0.00\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_koe_to_eci, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI Cartesian\n    let mut traj_cart = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add Cartesian states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 300.0;\n        let oe = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.001, 97.8, 15.0, 30.0, (i as f64) * 10.0\n        );\n        let state_cart = state_koe_to_eci(oe, AngleFormat::Degrees);\n        traj_cart.add(epoch, state_cart);\n    }\n\n    println!(\"Original representation: {:?}\", traj_cart.representation);\n\n    // Convert to Keplerian with radians\n    let traj_kep = traj_cart.to_keplerian(AngleFormat::Degrees);\n\n    println!(\"Converted representation: {:?}\", traj_kep.representation);\n    println!(\"Angle format: {:?}\", traj_kep.angle_format);\n\n    // Examine Keplerian elements\n    for (epoch, oe) in &amp;traj_kep {\n        println!(\"\\nEpoch: {}\", epoch);\n        println!(\"  Semi-major axis: {:.2} km\", oe[0] / 1e3);\n        println!(\"  Eccentricity: {:.6}\", oe[1]);\n        println!(\"  Inclination: {:.2}\u00b0\", oe[2]);\n        println!(\"  RAAN: {:.2}\u00b0\", oe[3]);\n        println!(\"  Argument of perigee: {:.2}\u00b0\", oe[4]);\n        println!(\"  Mean Anomaly: {:.2}\u00b0\", oe[5]);\n    }\n}\n\n// Output:\n// Original representation: OrbitRepresentation(Cartesian)\n// Converted representation: OrbitRepresentation(Keplerian)\n// Angle format: Some(Degrees)\n\n// Epoch: 2024-01-01 00:00:00.000 UTC\n//   Semi-major axis: 6878.14 km\n//   Eccentricity: 0.001000\n//   Inclination: 97.80\u00b0\n//   RAAN: 15.00\u00b0\n//   Argument of perigee: 30.00\u00b0\n//   Mean Anomaly: 0.00\u00b0\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#converting-with-different-angle-formats","title":"Converting with Different Angle Formats","text":"<p>Convert to Keplerian with different angle formats:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory in ECI Cartesian\ntraj_cart = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add a state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0])\nstate_cart = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\ntraj_cart.add(epoch, state_cart)\n\n# Convert to Keplerian with radians\ntraj_kep_rad = traj_cart.to_keplerian(bh.AngleFormat.RADIANS)\n_, oe_rad = traj_kep_rad.first()\n\n# Convert to Keplerian with degrees\ntraj_kep_deg = traj_cart.to_keplerian(bh.AngleFormat.DEGREES)\n_, oe_deg = traj_kep_deg.first()\n\nprint(\"Radians version:\")\nprint(f\"  Inclination: {oe_rad[2]:.6f} rad = {np.degrees(oe_rad[2]):.2f}\u00b0\")\n\nprint(\"\\nDegrees version:\")\nprint(f\"  Inclination: {oe_deg[2]:.2f}\u00b0\")\n\n# Output:\n# Radians version:\n#   Inclination: 0.900000 rad = 51.57\u00b0\n\n# Degrees version:\n#   Inclination: 51.57\u00b0\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_koe_to_eci, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory in ECI Cartesian\n    let mut traj_cart = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add a state\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0\n    );\n    let state_cart = state_koe_to_eci(oe, AngleFormat::Radians);\n    traj_cart.add(epoch, state_cart);\n\n    // Convert to Keplerian with radians\n    let traj_kep_rad = traj_cart.to_keplerian(AngleFormat::Radians);\n    let (_, oe_rad) = traj_kep_rad.first().unwrap();\n\n    // Convert to Keplerian with degrees\n    let traj_kep_deg = traj_cart.to_keplerian(AngleFormat::Degrees);\n    let (_, oe_deg) = traj_kep_deg.first().unwrap();\n\n    println!(\"Radians version:\");\n    println!(\"  Inclination: {:.6} rad = {:.2}\u00b0\", oe_rad[2], oe_rad[2].to_degrees());\n\n    println!(\"\\nDegrees version:\");\n    println!(\"  Inclination: {:.2}\u00b0\", oe_deg[2]);\n}\n\n// Output:\n// Radians version:\n//   Inclination: 0.900000 rad = 51.57\u00b0\n\n// Degrees version:\n//   Inclination: 51.57\u00b0\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#combined-frame-and-representation-conversions","title":"Combined Frame and Representation Conversions","text":"<p>Every conversion method returns a new <code>OrbitTrajectory</code> instance, so you can chain conversions together if desired:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Start with ECI Cartesian trajectory\ntraj_eci_cart = bh.OrbitTrajectory(\n    6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None\n)\n\n# Add states\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0])\nstate_cart = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\ntraj_eci_cart.add(epoch, state_cart)\n\nprint(\"Original:\")\nprint(f\"  Frame: {traj_eci_cart.frame}\")\nprint(f\"  Representation: {traj_eci_cart.representation}\")\n\n# Convert to ECEF frame (stays Cartesian)\ntraj_ecef_cart = traj_eci_cart.to_ecef()\nprint(\"\\nAfter to_ecef():\")\nprint(f\"  Frame: {traj_ecef_cart.frame}\")\nprint(f\"  Representation: {traj_ecef_cart.representation}\")\n\n# Convert back to ECI\ntraj_eci_cart2 = traj_ecef_cart.to_eci()\nprint(\"\\nAfter to_eci():\")\nprint(f\"  Frame: {traj_eci_cart2.frame}\")\nprint(f\"  Representation: {traj_eci_cart2.representation}\")\n\n# Convert to Keplerian (in ECI frame)\ntraj_eci_kep = traj_eci_cart2.to_keplerian(bh.AngleFormat.DEGREES)\nprint(\"\\nAfter to_keplerian():\")\nprint(f\"  Frame: {traj_eci_kep.frame}\")\nprint(f\"  Representation: {traj_eci_kep.representation}\")\nprint(f\"  Angle format: {traj_eci_kep.angle_format}\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation, OrbitalTrajectory};\nuse bh::traits::Trajectory;\nuse bh::{state_koe_to_eci, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Start with ECI Cartesian trajectory\n    let mut traj_eci_cart = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, 0.0\n    );\n    let state_cart = state_koe_to_eci(oe, AngleFormat::Radians);\n    traj_eci_cart.add(epoch, state_cart);\n\n    println!(\"Original:\");\n    println!(\"  Frame: {:?}\", traj_eci_cart.frame);\n    println!(\"  Representation: {:?}\", traj_eci_cart.representation);\n\n    // Convert to ECEF frame (stays Cartesian)\n    let traj_ecef_cart = traj_eci_cart.to_ecef();\n    println!(\"\\nAfter to_ecef():\");\n    println!(\"  Frame: {:?}\", traj_ecef_cart.frame);\n    println!(\"  Representation: {:?}\", traj_ecef_cart.representation);\n\n    // Convert back to ECI\n    let traj_eci_cart2 = traj_ecef_cart.to_eci();\n    println!(\"\\nAfter to_eci():\");\n    println!(\"  Frame: {:?}\", traj_eci_cart2.frame);\n    println!(\"  Representation: {:?}\", traj_eci_cart2.representation);\n\n    // Convert to Keplerian (in ECI frame)\n    let traj_eci_kep = traj_eci_cart2.to_keplerian(AngleFormat::Radians);\n    println!(\"\\nAfter to_keplerian():\");\n    println!(\"  Frame: {:?}\", traj_eci_kep.frame);\n    println!(\"  Representation: {:?}\", traj_eci_kep.representation);\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#standard-trajectory-operations","title":"Standard Trajectory Operations","text":"<p><code>OrbitTrajectory</code> supports all standard trajectory operations since it implements the <code>Trajectory</code> and <code>Interpolatable</code> traits:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\n\n# Add states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nfor i in range(10):\n    epoch = epoch0 + i * 60.0\n    oe = np.array([bh.R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, i * 0.1])\n    state = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n    traj.add(epoch, state)\n\n# Query properties\nprint(f\"Length: {len(traj)}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"End epoch: {traj.end_epoch()}\")\n\n# Interpolate at intermediate time\ninterp_epoch = epoch0 + 45.0\ninterp_state = traj.interpolate(interp_epoch)\nprint(f\"\\nInterpolated state at {interp_epoch}:\")\nprint(f\"  Position (km): {interp_state[0:3] / 1e3}\")\nprint(f\"  Velocity (m/s): {interp_state[3:6]}\")\n\n# Iterate over states\nfor i, (epoch, state) in enumerate(traj):\n    if i &lt; 2:  # Just show first two\n        print(\n            f\"State {i}: Epoch={epoch}, Position magnitude={np.linalg.norm(state[0:3]) / 1e3:.2f} km\"\n        )\n\n# Output:\n# Length: 10\n# Timespan: 540.0 seconds\n# Start epoch: 2024-01-01 00:00:00.000 UTC\n# End epoch: 2024-01-01 00:09:00.000 UTC\n\n# Interpolated state at 2024-01-01 00:00:45.000 UTC:\n#   Position (km): [1159.01597302 6101.29789026 2925.16369358]\n#   Velocity (m/s): [-5578.86734152 -1338.77483001  5004.22925364]\n# State 0: Epoch=2024-01-01 00:00:00.000 UTC, Position magnitude=6871.26 km\n# State 1: Epoch=2024-01-01 00:01:00.000 UTC, Position magnitude=6871.29 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::SOrbitTrajectory;\nuse bh::trajectories::traits::{OrbitFrame, OrbitRepresentation};\nuse bh::traits::{Trajectory, InterpolatableTrajectory};\nuse bh::{state_koe_to_eci, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory\n    let mut traj = SOrbitTrajectory::new(\n        OrbitFrame::ECI,\n        OrbitRepresentation::Cartesian,\n        None\n    );\n\n    // Add states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    for i in 0..10 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let oe = na::SVector::&lt;f64, 6&gt;::new(\n            R_EARTH + 500e3, 0.001, 0.9, 1.0, 0.5, (i as f64) * 0.1\n        );\n        let state = state_koe_to_eci(oe, AngleFormat::Radians);\n        traj.add(epoch, state);\n    }\n\n    // Query properties\n    println!(\"Length: {}\", traj.len());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"End epoch: {}\", traj.end_epoch().unwrap());\n\n    // Interpolate at intermediate time\n    let interp_epoch = epoch0 + 45.0;\n    let interp_state = traj.interpolate(&amp;interp_epoch).unwrap();\n    println!(\"\\nInterpolated state at {}:\", interp_epoch);\n    println!(\"  Position (km): [{}, {}, {}] km\",\n        interp_state[0] / 1e3, interp_state[1] / 1e3, interp_state[2] / 1e3\n    );\n    println!(\"  Velocity (m/s): [{}, {}, {}] m/s\",\n        interp_state[3], interp_state[4], interp_state[5]\n    );\n\n    // Iterate over states\n    for (i, (epoch, state)) in traj.into_iter().enumerate().take(2) {\n        let pos_mag = state.fixed_rows::&lt;3&gt;(0).norm();\n        println!(\"State {}: Epoch={}, Position magnitude={:.2} km\",\n            i, epoch, pos_mag / 1e3);\n    }\n}\n\n// Output:\n// Length: 10\n// Timespan: 540.0 seconds\n// Start epoch: 2024-01-01 00:00:00.000 UTC\n// End epoch: 2024-01-01 00:09:00.000 UTC\n\n// Interpolated state at 2024-01-01 00:00:45.000 UTC:\n//   Position (km): [1159.0159730226278, 6101.297890257402, 2925.16369357997] km\n//   Velocity (m/s): [-5578.867341523014, -1338.7748300095711, 5004.22925363932] m/s\n// State 0: Epoch=2024-01-01 00:00:00.000 UTC, Position magnitude=6871.26 km\n// State 1: Epoch=2024-01-01 00:01:00.000 UTC, Position magnitude=6871.29 km\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#practical-workflow-example","title":"Practical Workflow Example","text":"<p>A complete example showing propagation, frame conversion, and analysis:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# 1. Define orbit and create propagator\na = bh.R_EARTH + 500e3  # 500 km altitude\ne = 0.001  # Nearly circular\ni = 97.8  # Sun-synchronous\nraan = 15.0\nargp = 30.0\nM = 0.0\noe = np.array([a, e, i, raan, argp, M])\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, oe, bh.AngleFormat.DEGREES, 60.0\n)\n\n# 2. Propagate for one orbit period\nperiod = bh.orbital_period(a)\nend_epoch = epoch + period\npropagator.propagate_to(end_epoch)\n\n# 3. Get trajectory in ECI Cartesian\ntraj_eci = propagator.trajectory\nprint(f\"Propagated {len(traj_eci)} states over {traj_eci.timespan() / 60:.1f} minutes\")\n\n# 4. Convert to ECEF to analyze ground track\ntraj_ecef = traj_eci.to_ecef()\nprint(\"\\nGround track in ECEF frame:\")\nfor i, (epoch, state_ecef) in enumerate(traj_ecef):\n    if i % 10 == 0:  # Sample every 10 states\n        # Convert ECEF to geodetic for latitude/longitude\n        lat, lon, alt = bh.position_ecef_to_geodetic(\n            state_ecef[0:3], bh.AngleFormat.DEGREES\n        )\n        print(f\"  {epoch}: Lat={lat:6.2f}\u00b0, Lon={lon:7.2f}\u00b0, Alt={alt / 1e3:6.2f} km\")\n\n# 5. Convert to Keplerian to analyze orbital evolution\ntraj_kep = traj_eci.to_keplerian(bh.AngleFormat.DEGREES)\nfirst_oe = traj_kep.state_at_idx(0)\nlast_oe = traj_kep.state_at_idx(len(traj_kep) - 1)\n\nprint(\"\\nOrbital element evolution:\")\nprint(f\"  Semi-major axis: {first_oe[0] / 1e3:.2f} km \u2192 {last_oe[0] / 1e3:.2f} km\")\nprint(f\"  Eccentricity: {first_oe[1]:.6f} \u2192 {last_oe[1]:.6f}\")\nprint(f\"  Inclination: {first_oe[2]:.2f}\u00b0 \u2192 {last_oe[2]:.2f}\u00b0\")\nprint(f\"  True anomaly: {first_oe[5]:.2f}\u00b0 \u2192 {last_oe[5]:.2f}\u00b0\")\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::traits::{Trajectory, SStatePropagator};\nuse bh::{KeplerianPropagator, orbital_period, position_ecef_to_geodetic, R_EARTH, AngleFormat};\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // 1. Define orbit and create propagator\n    let oe = na::SVector::&lt;f64, 6&gt;::new(\n        R_EARTH + 500e3, 0.001, 97.8_f64.to_radians(),\n        15.0_f64.to_radians(), 30.0_f64.to_radians(), 0.0\n    );\n\n    let epoch = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch, oe, AngleFormat::Radians, 60.0\n    );\n\n    // 2. Propagate for one orbit period\n    let period = orbital_period(R_EARTH + 500e3);\n    let end_epoch = epoch + period;\n    propagator.propagate_to(end_epoch);\n\n    // 3. Get trajectory in ECI Cartesian\n    let traj_eci = &amp;propagator.trajectory;\n    println!(\"Propagated {} states over {:.1} minutes\",\n        traj_eci.len(), traj_eci.timespan().unwrap() / 60.0);\n\n    // 4. Convert to ECEF\n    let traj_ecef = traj_eci.to_ecef();\n    println!(\"\\nGround track in ECEF frame:\");\n    for (i, (epoch, state_ecef)) in traj_ecef.into_iter().enumerate() {\n        if i % 10 == 0 {\n            let pos_ecef: na::Vector3&lt;f64&gt; = state_ecef.fixed_rows::&lt;3&gt;(0).into();\n            let lla = position_ecef_to_geodetic(pos_ecef, AngleFormat::Degrees);\n            println!(\"  {}: Lat={:6.2}\u00b0, Lon={:7.2}\u00b0, Alt={:6.2} km\",\n                epoch, lla[0], lla[1], lla[2] / 1e3);\n        }\n    }\n\n    // 5. Convert to Keplerian\n    let traj_kep = traj_eci.to_keplerian(AngleFormat::Radians);\n    let first_oe = traj_kep.state_at_idx(0).unwrap();\n    let last_oe = traj_kep.state_at_idx(traj_kep.len() - 1).unwrap();\n\n    println!(\"\\nOrbital element evolution:\");\n    println!(\"  Semi-major axis: {:.2} km \u2192 {:.2} km\",\n        first_oe[0] / 1e3, last_oe[0] / 1e3);\n    println!(\"  Eccentricity: {:.6} \u2192 {:.6}\",\n        first_oe[1], last_oe[1]);\n    println!(\"  Inclination: {:.2}\u00b0 \u2192 {:.2}\u00b0\",\n        first_oe[2].to_degrees(), last_oe[2].to_degrees());\n}\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>Trajectories Overview - Trait hierarchy and implementation guide</li> <li>Trajectory - Dynamic-dimension trajectory</li> <li>OrbitTrajectory API Reference</li> </ul>"},{"location":"learn/trajectories/trajectory.html","title":"Trajectory","text":"<p><code>Trajectory</code> is a dynamically sized trajectory container that stores time-series state data with runtime-determined dimensions. Unlike static trajectory types, <code>Trajectory</code> allows you to specify the state vector dimension at creation time, making it ideal for applications where the dimension varies or is not known at compile time.</p> <p>Use <code>Trajectory</code> when:</p> <ul> <li>State dimension is determined at runtime</li> <li>You need flexibility to work with different dimensions in the same codebase</li> <li>State vectors are non-standard (not 3D or 6D)</li> <li>Flexibility is prioritized over maximum performance</li> </ul>"},{"location":"learn/trajectories/trajectory.html#initialization","title":"Initialization","text":""},{"location":"learn/trajectories/trajectory.html#empty-trajectory","title":"Empty Trajectory","text":"<p>Create an empty trajectory by specifying the state dimension. The default dimension is 6 (suitable for position + velocity states):</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create 6D trajectory (default)\ntraj = bh.Trajectory()\nprint(f\"Dimension: {traj.dimension()}\")\n# Dimension: 6\n\n# Create 3D trajectory (position only)\ntraj_3d = bh.Trajectory(3)\nprint(f\"Dimension: {traj_3d.dimension()}\")\n# Dimension: 3\n\n# Create 12D trajectory (custom)\ntraj_12d = bh.Trajectory(12)\nprint(f\"Dimension: {traj_12d.dimension()}\")\n# Dimension: 12\n</code></pre> <pre><code>use brahe as bh;\nuse bh::trajectories::DTrajectory;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create 6D trajectory (default)\n    let traj = DTrajectory::default();\n    println!(\"Dimension: {}\", traj.dimension());\n    // Output: 6\n\n    // Create 3D trajectory\n    let traj_3d = DTrajectory::new(3);\n    println!(\"Dimension: {}\", traj_3d.dimension());\n    // Output: 3\n\n    // Create 12D trajectory\n    let traj_12d = DTrajectory::new(12);\n    println!(\"Dimension: {}\", traj_12d.dimension());\n    // Output: 12\n}\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#from-existing-data","title":"From Existing Data","text":"<p>Create a trajectory from existing epochs and states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create epochs\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepoch1 = epoch0 + 60.0  # 1 minute later\nepoch2 = epoch0 + 120.0  # 2 minutes later\n\n# Create states (6D: position + velocity)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\nstate2 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\n\n# Create trajectory from data\nepochs = [epoch0, epoch1, epoch2]\nstates = np.array([state0, state1, state2])\ntraj = bh.Trajectory.from_data(epochs, states)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 3\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epochs\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let epoch1 = epoch0 + 60.0;  // 1 minute later\n    let epoch2 = epoch0 + 120.0;  // 2 minutes later\n\n    // Create states\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    let state2 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    ]);\n\n    // Create trajectory from data\n    let epochs = vec![epoch0, epoch1, epoch2];\n    let states = vec![state0, state1, state2];\n    let traj = DTrajectory::from_data(epochs, states).unwrap();\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Output: 3\n}\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#adding-and-accessing-states","title":"Adding and Accessing States","text":""},{"location":"learn/trajectories/trajectory.html#adding-states","title":"Adding States","text":"<p>Add states to a trajectory one at a time:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create empty trajectory\ntraj = bh.Trajectory(6)\n\n# Add states\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 1\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nprint(f\"Trajectory length: {len(traj)}\")\n# Trajectory length: 2\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create empty trajectory\n    let mut traj = DTrajectory::new(6);\n\n    // Add states\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    traj.add(epoch0, state0);\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 1\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    traj.add(epoch1, state1);\n\n    println!(\"Trajectory length: {}\", traj.len());\n    // Trajectory length: 2\n}\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#accessing-by-index","title":"Accessing by Index","text":"<p>Retrieve states and epochs by their index:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate0 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epoch0, state0)\n\nepoch1 = epoch0 + 60.0\nstate1 = np.array([bh.R_EARTH + 600e3, 456000.0, 0.0, -7600.0, 0.0, 0.0])\ntraj.add(epoch1, state1)\n\nepoch2 = epoch0 + 120.0\nstate2 = np.array([bh.R_EARTH + 700e3, 0.0, 0.0, 0.0, -7600.0, 0.0])\ntraj.add(epoch2, state2)\n\n# Access by index\nretrieved_epoch = traj.epoch_at_idx(1)\nretrieved_state = traj.state_at_idx(1)\n\nprint(f\"Epoch: {retrieved_epoch}\")\nprint(f\"Altitude: {retrieved_state[0] - bh.R_EARTH:.2f} m\")\n\n# Output:\n# Epoch: 2024-01-01 00:01:00.000 UTC\n# Altitude: 600000.00 m\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n    let state0 = na::DVector::from_vec(vec![\n        R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n    ]);\n    traj.add(epoch0, state0);\n\n    let epoch1 = epoch0 + 60.0;\n    let state1 = na::DVector::from_vec(vec![\n        R_EARTH + 600e3, 456000.0, 0.0, -7600.0, 0.0, 0.0\n    ]);\n    traj.add(epoch1, state1);\n\n    let epoch2 = epoch0 + 120.0;\n    let state2 = na::DVector::from_vec(vec![\n        R_EARTH + 700e3, 0.0, 0.0, 0.0, -7600.0, 0.0\n    ]);\n    traj.add(epoch2, state2);\n\n    // Access by index\n    let retrieved_epoch = traj.epoch_at_idx(1).unwrap();\n    let retrieved_state = traj.state_at_idx(1).unwrap();\n\n    println!(\"Epoch: {}\", retrieved_epoch);\n    println!(\"Altitude: {:.2} m\", retrieved_state[0] - R_EARTH);\n}\n\n// Output:\n// Epoch: 2024-01-01 00:01:00.000 UTC\n// Altitude: 600000.00 m\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#accessing-by-epoch","title":"Accessing by Epoch","text":"<p>Get states at or near specific epochs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with multiple states\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Get nearest state to a specific epoch\nquery_epoch = epoch0 + 120.0  # 2 minutes after start\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(\n    f\"Nearest state at t+120s altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\"\n)\n\n# Get nearest state between stored epochs\nquery_epoch = epoch0 + 125.0  # Between stored epochs\nnearest_epoch, nearest_state = traj.nearest_state(query_epoch)\nprint(\n    f\"Nearest state at t+125s altitude: {(nearest_state[0] - bh.R_EARTH) / 1e3:.2f} km\"\n)\n\n# Output:\n# Nearest state at t+120s altitude: 502.00 km\n# Nearest state at t+125s altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with multiple states\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Get nearest state to a specific epoch\n    let query_epoch1 = epoch0 + 120.0;  // 2 minutes after start\n    let (_, nearest_state) = traj.nearest_state(&amp;query_epoch1).unwrap();\n    println!(\"Nearest state at t+120s altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n\n    // Get nearest state between stored epochs\n    let query_epoch2 = epoch0 + 125.0;  // Between stored epochs\n    let (_, nearest_state) = traj.nearest_state(&amp;query_epoch2).unwrap();\n    println!(\"Nearest state at t+125s altitude: {:.2} km\",\n        (nearest_state[0] - R_EARTH) / 1e3);\n}\n\n// Output:\n// Nearest state at t+120s altitude: 502.00 km\n// Nearest state at t+125s altitude: 502.00 km\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#querying-trajectory-properties","title":"Querying Trajectory Properties","text":""},{"location":"learn/trajectories/trajectory.html#time-span-and-bounds","title":"Time Span and Bounds","text":"<p>Query the temporal extent of a trajectory:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory spanning 5 minutes\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(6):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Query properties\nprint(f\"Number of states: {len(traj)}\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"End epoch: {traj.end_epoch()}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\nprint(f\"Is empty: {traj.is_empty()}\")\n\n# Access first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\nprint(f\"First epoch: {first_epoch}\")\nprint(f\"Last epoch: {last_epoch}\")\n\n# Output:\n# Number of states: 6\n# Start epoch: 2024-01-01 00:00:00.000 UTC\n# End epoch: 2024-01-01 00:05:00.000 UTC\n# Timespan: 300.0 seconds\n# Is empty: False\n# First epoch: 2024-01-01 00:00:00.000 UTC\n# Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory spanning 5 minutes\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..6 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Query properties\n    println!(\"Number of states: {}\", traj.len());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"End epoch: {}\", traj.end_epoch().unwrap());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n    println!(\"Is empty: {}\", traj.is_empty());\n\n    // Access first and last states\n    let (first_epoch, _first_state) = traj.first().unwrap();\n    let (last_epoch, _last_state) = traj.last().unwrap();\n    println!(\"First epoch: {}\", first_epoch);\n    println!(\"Last epoch: {}\", last_epoch);\n}\n\n// Output:\n// Number of states: 6\n// Start epoch: 2024-01-01 00:00:00.000 UTC\n// End epoch: 2024-01-01 00:05:00.000 UTC\n// Timespan: 300.0 seconds\n// Is empty: false\n// First epoch: 2024-01-01 00:00:00.000 UTC\n// Last epoch: 2024-01-01 00:05:00.000 UTC\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#interpolation","title":"Interpolation","text":"<p>Trajectory supports linear interpolation to estimate states at arbitrary epochs between stored data points:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with sparse data\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states every 60 seconds\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    # Simplified motion: position changes linearly with time\n    state = np.array([bh.R_EARTH + 500e3 + i * 10000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Interpolate state at intermediate time\nquery_epoch = epoch0 + 30.0  # Halfway between first two states\ninterpolated_state = traj.interpolate(query_epoch)\n\nprint(f\"Interpolated altitude: {(interpolated_state[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Expected: approximately 505 km (halfway between 500 and 510 km)\n\n# Output:\n# Interpolated altitude: 505.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::{Trajectory, InterpolatableTrajectory};\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with sparse data\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add states every 60 seconds\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 10000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Interpolate state at intermediate time\n    let query_epoch = epoch0 + 30.0;  // Halfway between first two states\n    let interpolated_state = traj.interpolate(&amp;query_epoch).unwrap();\n\n    println!(\"Interpolated altitude: {:.2} km\",\n        (interpolated_state[0] - R_EARTH) / 1e3);\n    // Expected: approximately 505 km (halfway between 500 and 510 km)\n}\n\n// Output:\n// Interpolated altitude: 505.00 km\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#memory-management","title":"Memory Management","text":"<p>Trajectory supports eviction policies to automatically manage memory in long-running applications:</p>"},{"location":"learn/trajectories/trajectory.html#maximum-size-policy","title":"Maximum Size Policy","text":"<p>Keep only the N most recent states:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory with max size limit\ntraj = bh.Trajectory(6).with_eviction_policy_max_size(3)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add 5 states\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only the 3 most recent states are kept\nprint(f\"Trajectory length: {len(traj)}\")\nprint(f\"Start epoch: {traj.start_epoch()}\")\nprint(f\"Start altitude: {(traj.state_at_idx(0)[0] - bh.R_EARTH) / 1e3:.2f} km\")\n# Output: ~502 km (states 0 and 1 were evicted)\n\n# Output\n# Trajectory length: 3\n# Start epoch: 2024-01-01 00:02:00.000 UTC\n# Start altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory with max size limit\n    let mut traj = DTrajectory::new(6)\n        .with_eviction_policy_max_size(3);\n\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add 5 states\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Only the 3 most recent states are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    println!(\"Start epoch: {}\", traj.start_epoch().unwrap());\n    println!(\"Start altitude: {:.2} km\",\n        (traj.state_at_idx(0).unwrap()[0] - R_EARTH) / 1e3);\n    // Output: ~502 km (states 0 and 1 were evicted)\n}\n\n// Output\n// Trajectory length: 3\n// Start epoch: 2024-01-01 00:02:00.000 UTC\n// Start altitude: 502.00 km\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#maximum-age-policy","title":"Maximum Age Policy","text":"<p>Keep only states within a time window:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Keep only states within last 2 minutes (120 seconds)\ntraj = bh.Trajectory(6).with_eviction_policy_max_age(120.0)\n\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Add states spanning 4 minutes\nfor i in range(5):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Only states within 120 seconds of the most recent are kept\nprint(f\"Trajectory length: {len(traj)}\")\nprint(f\"Timespan: {traj.timespan():.1f} seconds\")\n\n# Output:\n# Trajectory length: 3\n# Timespan: 120.0 seconds\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Keep only states within last 2 minutes (120 seconds)\n    let mut traj = DTrajectory::new(6)\n        .with_eviction_policy_max_age(120.0);\n\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    // Add states spanning 4 minutes\n    for i in 0..5 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Only states within 120 seconds of the most recent are kept\n    println!(\"Trajectory length: {}\", traj.len());\n    println!(\"Timespan: {:.1} seconds\", traj.timespan().unwrap());\n}\n\n// Output:\n// Trajectory length: 3\n// Timespan: 120.0 seconds\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#iteration","title":"Iteration","text":"<p>Trajectories can be iterated to process all epoch-state pairs:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create and populate trajectory\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3 + i * 1000, 0.0, 0.0, 0.0, 7600.0, 0.0])\n    traj.add(epoch, state)\n\n# Iterate over all states\nfor epoch, state in traj:\n    altitude = (state[0] - bh.R_EARTH) / 1e3\n    print(f\"Epoch: {epoch}, Altitude: {altitude:.2f} km\")\n\n# Output:\n# Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km\n# Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km\n# Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create and populate trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3 + (i as f64) * 1000.0, 0.0, 0.0, 0.0, 7600.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Iterate over all states\n    for (epoch, state) in &amp;traj {\n        let altitude = (state[0] - R_EARTH) / 1e3;\n        println!(\"Epoch: {}, Altitude: {:.2} km\", epoch, altitude);\n    }\n\n    // Output:\n    // Epoch: 2024-01-01 00:00:00.000 UTC, Altitude: 500.00 km\n    // Epoch: 2024-01-01 00:01:00.000 UTC, Altitude: 501.00 km\n    // Epoch: 2024-01-01 00:02:00.000 UTC, Altitude: 502.00 km\n}\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#matrix-export","title":"Matrix Export","text":"<p>Convert trajectory data to matrix format for analysis or export:</p> PythonRust <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create trajectory\ntraj = bh.Trajectory(6)\nepoch0 = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\nfor i in range(3):\n    epoch = epoch0 + i * 60.0\n    state = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + i * 10, 0.0])\n    traj.add(epoch, state)\n\n# Convert to matrix (rows are states, columns are dimensions)\nmatrix = traj.to_matrix()\nprint(f\"Matrix type: {type(matrix)}\")\nprint(f\"Matrix shape: {matrix.shape}\")\nprint(f\"First state velocity: {matrix[0, 4]:.1f} m/s\")\n\n# Output:\n# Matrix type: &lt;class 'numpy.ndarray'&gt;\n# Matrix shape: (3, 6)\n# First state velocity: 7600.0 m/s\n</code></pre> <pre><code>use brahe as bh;\nuse bh::time::Epoch;\nuse bh::trajectories::DTrajectory;\nuse bh::traits::Trajectory;\nuse bh::constants::R_EARTH;\nuse nalgebra as na;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create trajectory\n    let mut traj = DTrajectory::new(6);\n    let epoch0 = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0,\n        bh::time::TimeSystem::UTC);\n\n    for i in 0..3 {\n        let epoch = epoch0 + (i as f64) * 60.0;\n        let state = na::DVector::from_vec(vec![\n            R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0 + (i as f64) * 10.0, 0.0\n        ]);\n        traj.add(epoch, state);\n    }\n\n    // Convert to matrix (rows are states, columns are dimensions)\n    let matrix = traj.to_matrix().unwrap();\n    println!(\"Matrix shape: ({}, {})\", matrix.nrows(), matrix.ncols());\n    println!(\"First state velocity: {:.1} m/s\", matrix[(0, 4)]);\n}\n\n// Output:\n// Matrix shape: (3, 6)\n// First state velocity: 7600.0 m/s\n</code></pre>"},{"location":"learn/trajectories/trajectory.html#see-also","title":"See Also","text":"<ul> <li>Trajectories Overview - Trait hierarchy and implementation guide</li> <li>OrbitTrajectory - Orbital trajectory with frame conversions</li> <li>Trajectory API Reference</li> </ul>"},{"location":"learn/utilities/index.html","title":"Utilities","text":"<p>The <code>utils</code> module provides utility functions that support core functionality of the Brahe library. While most users won't need to interact with these functions directly, they offer control over caching, parallel computation, and output formatting.</p>"},{"location":"learn/utilities/index.html#caching","title":"Caching","text":"<p>Brahe automatically manages a local cache directory to store downloaded data such as Earth Orientation Parameters (EOP) and TLE data. Caching both minimizes the load and impact that brahe-related requests have on host servers as well as improve performance for users by eliminating unneeded network requests. The caching utilities provide functions to locate and manage these cache directories.</p> <p>By default, cache data is stored in <code>~/.cache/brahe</code> on Unix systems or the equivalent on other platforms. The location can be customized using the <code>BRAHE_CACHE</code> environment variable. Cache directories are automatically created on first access and organized into subdirectories for different data types (e.g., <code>eop/</code>, <code>celestrak/</code>).</p> <p>See Caching for complete details.</p>"},{"location":"learn/utilities/index.html#threading","title":"Threading","text":"<p>Brahe uses a global thread pool to parallelize computationally intensive operations, such as computing access windows between satellites and ground locations. The threading utilities allow you to configure the number of threads used by the thread pool.</p> <p>By default, Brahe uses 90% of available CPU cores, but you can manually set the thread count to optimize performance based on your workload and system resources. The thread pool can be reconfigured at any time during program execution.</p> <p>See Multithreading for complete details.</p>"},{"location":"learn/utilities/index.html#string-formatting","title":"String Formatting","text":"<p>The string formatting utilities provide functions for converting numerical values into human-readable strings. Currently, this includes formatting time durations (in seconds) into strings like \"2 hours and 30.5 minutes\" or \"2h 30m\" (short form).</p> <p>These utilities are useful for displaying results to users in a more intuitive format than raw numerical values.</p> <p>See String Formatting for complete details.</p>"},{"location":"learn/utilities/index.html#see-also","title":"See Also","text":"<ul> <li>Caching - Cache directory management</li> <li>Multithreading - Thread pool configuration</li> <li>String Formatting - Human-readable output formatting</li> <li>Utilities API Reference - Complete utilities function documentation</li> </ul>"},{"location":"learn/utilities/caching.html","title":"Caching","text":"<p>Brahe automatically manages a local cache directory to store downloaded data such as Earth Orientation Parameters (EOP) and TLE data. The caching utilities provide functions to locate and manage these cache directories.</p> <p>For complete API details, see the Caching API Reference.</p>"},{"location":"learn/utilities/caching.html#default-cache-location","title":"Default Cache Location","text":"<p>By default, Brahe stores cache data in a platform-specific location:</p> <ul> <li>Unix/Linux/macOS: <code>~/.cache/brahe</code></li> <li>Windows: <code>%LOCALAPPDATA%\\brahe\\cache</code></li> </ul> <p>All cache directories are automatically created on first access, so you don't need to manually create them.</p>"},{"location":"learn/utilities/caching.html#environment-variable-override","title":"Environment Variable Override","text":"<p>You can customize the cache location by setting the <code>BRAHE_CACHE</code> environment variable:</p> <pre><code>export BRAHE_CACHE=/custom/path/to/cache\n</code></pre> <p>This is useful for:</p> <ul> <li>Using a different storage location with more space</li> <li>Sharing cache data across multiple users</li> <li>Testing with isolated cache directories</li> </ul>"},{"location":"learn/utilities/caching.html#getting-cache-directories","title":"Getting Cache Directories","text":""},{"location":"learn/utilities/caching.html#main-cache-directory","title":"Main Cache Directory","text":"<p>The main cache directory is the root location for all Brahe cache data:</p> PythonRust <pre><code># Get main cache directory\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Main cache directory: {cache_dir}\")\n</code></pre> <pre><code>    // Get main cache directory\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    println!(\"Main cache directory: {}\", cache_dir);\n</code></pre>"},{"location":"learn/utilities/caching.html#eop-cache-directory","title":"EOP Cache Directory","text":"<p>Earth Orientation Parameters are stored in a dedicated subdirectory:</p> PythonRust <pre><code># Get cache subdirectory for EOP data\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache directory: {eop_cache}\")\n</code></pre> <pre><code>    // Get cache subdirectory for EOP data\n    let eop_cache = bh::utils::get_eop_cache_dir().unwrap();\n    println!(\"EOP cache directory: {}\", eop_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#celestrak-cache-directory","title":"CelesTrak Cache Directory","text":"<p>Satellite TLE data downloaded from CelesTrak is stored in its own subdirectory:</p> PythonRust <pre><code># Get cache subdirectory for CelesTrak data\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache directory: {celestrak_cache}\")\n</code></pre> <pre><code>    // Get cache subdirectory for CelesTrak data\n    let celestrak_cache = bh::utils::get_celestrak_cache_dir().unwrap();\n    println!(\"CelesTrak cache directory: {}\", celestrak_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#custom-subdirectories","title":"Custom Subdirectories","text":"<p>You can create custom subdirectories within the cache for your own data:</p> PythonRust <pre><code># Get a custom subdirectory within the cache\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"custom_data\")\nprint(f\"Custom cache subdirectory: {custom_cache}\")\n</code></pre> <pre><code>    // Get a custom subdirectory within the cache\n    let custom_cache = bh::utils::get_brahe_cache_dir_with_subdir(Some(\"custom_data\")).unwrap();\n    println!(\"Custom cache subdirectory: {}\", custom_cache);\n</code></pre>"},{"location":"learn/utilities/caching.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating all cache directory functions:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Get main cache directory\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Main cache directory: {cache_dir}\")\n\n# Get cache subdirectory for EOP data\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache directory: {eop_cache}\")\n\n# Get cache subdirectory for CelesTrak data\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache directory: {celestrak_cache}\")\n\n# Get a custom subdirectory within the cache\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"custom_data\")\nprint(f\"Custom cache subdirectory: {custom_cache}\")\n\n# Note: All directories are automatically created if they don't exist\n# You can override the default location by setting the BRAHE_CACHE\n# environment variable\n\n# Expected output (paths will vary by system):\n# Main cache directory: /home/USER/.cache/brahe\n# EOP cache directory: /home/USER/.cache/brahe/eop\n# CelesTrak cache directory: /home/USER/.cache/brahe/celestrak\n# Custom cache subdirectory: /home/USER/.cache/brahe/custom_data\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Get main cache directory\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    println!(\"Main cache directory: {}\", cache_dir);\n\n    // Get cache subdirectory for EOP data\n    let eop_cache = bh::utils::get_eop_cache_dir().unwrap();\n    println!(\"EOP cache directory: {}\", eop_cache);\n\n    // Get cache subdirectory for CelesTrak data\n    let celestrak_cache = bh::utils::get_celestrak_cache_dir().unwrap();\n    println!(\"CelesTrak cache directory: {}\", celestrak_cache);\n\n    // Get a custom subdirectory within the cache\n    let custom_cache = bh::utils::get_brahe_cache_dir_with_subdir(Some(\"custom_data\")).unwrap();\n    println!(\"Custom cache subdirectory: {}\", custom_cache);\n\n    // Note: All directories are automatically created if they don't exist\n    // You can override the default location by setting the BRAHE_CACHE\n    // environment variable\n\n    // Expected output (paths will vary by system):\n    // Main cache directory: /home/USER/.cache/brahe\n    // EOP cache directory: /home/USER/.cache/brahe/eop\n    // CelesTrak cache directory: /home/USER/.cache/brahe/celestrak\n    // Custom cache subdirectory: /home/USER/.cache/brahe/custom_data\n}\n</code></pre>"},{"location":"learn/utilities/caching.html#cache-management","title":"Cache Management","text":"<p>Automatic Cleanup</p> <p>Brahe does not automatically clean up old cache files. If you need to free up disk space, you can manually delete files from the cache directory. Brahe will re-download any needed data on the next request.</p> <p>Sharing Cache Between Users</p> <p>If you're working on server with multiple users using Brahe, you can share the same cache directory by setting the <code>BRAHE_CACHE</code> environment variable to a common location. This avoids duplicate downloads of EOP and TLE data.</p>"},{"location":"learn/utilities/caching.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>Caching API Reference - Complete caching function documentation</li> </ul>"},{"location":"learn/utilities/string_formatting.html","title":"String Formatting","text":"<p>The string formatting utilities provide functions for converting numerical values into human-readable strings. This makes it easier to display results to users in an intuitive format.</p> <p>For complete API details, see the String Formatting API Reference.</p>"},{"location":"learn/utilities/string_formatting.html#time-duration-formatting","title":"Time Duration Formatting","text":"<p>The primary formatting utility is <code>format_time_string()</code>, which converts a time duration in seconds into a human-readable string.</p>"},{"location":"learn/utilities/string_formatting.html#long-format-default","title":"Long Format (Default)","text":"<p>The long format provides a full description with proper units and grammar:</p> PythonRust <pre><code># Format various time durations in long format (default)\nprint(\"Long format (default):\")\nprint(f\"  30 seconds: {bh.format_time_string(30)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000)}\")\n</code></pre> <pre><code>    // Format various time durations in long format (default)\n    println!(\"Long format (default):\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, false));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, false));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, false));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, false));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, false));\n</code></pre> <p>The long format uses proper grammar and includes fractional seconds:</p> <ul> <li><code>30.00 seconds</code></li> <li><code>1 minute and 30.00 seconds</code></li> <li><code>6 minutes and 2.00 seconds</code></li> <li><code>1 hour, 1 minute and 5.00 seconds</code></li> <li><code>1 day, 1 hour and 0.00 seconds</code></li> </ul>"},{"location":"learn/utilities/string_formatting.html#short-format","title":"Short Format","text":"<p>The short format provides a more compact representation suitable for tables or limited space:</p> PythonRust <pre><code># Format the same durations in short format\nprint(\"\\nShort format:\")\nprint(f\"  30 seconds: {bh.format_time_string(30, short=True)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90, short=True)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362, short=True)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665, short=True)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000, short=True)}\")\n</code></pre> <pre><code>    // Format the same durations in short format\n    println!(\"\\nShort format:\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, true));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, true));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, true));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, true));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, true));\n</code></pre> <p>The short format uses abbreviations without fractional seconds:</p> <ul> <li><code>30s</code></li> <li><code>1m 30s</code></li> <li><code>6m 2s</code></li> <li><code>1h 1m 5s</code></li> <li><code>1d 1h 0m</code></li> </ul>"},{"location":"learn/utilities/string_formatting.html#practical-example","title":"Practical Example","text":"<p>Here's a practical example formatting an orbital period:</p> PythonRust <pre><code># Practical use case: format orbital period\norbital_period = bh.orbital_period(bh.R_EARTH + 500e3)\nprint(f\"\\nLEO orbital period: {bh.format_time_string(orbital_period)}\")\nprint(\n</code></pre> <pre><code>    // Practical use case: format orbital period\n    let orbital_period = bh::orbits::orbital_period(bh::constants::R_EARTH + 500e3);\n    println!(\"\\nLEO orbital period: {}\", bh::utils::format_time_string(orbital_period, false));\n    println!(\"LEO orbital period (short): {}\", bh::utils::format_time_string(orbital_period, true));\n</code></pre> <p>This produces:</p> <pre><code>LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\nLEO orbital period (short): 1h 34m 38s\n</code></pre>"},{"location":"learn/utilities/string_formatting.html#supported-time-units","title":"Supported Time Units","text":"<p>The function automatically selects the appropriate units based on the duration:</p> Duration Range Units Used &lt; 60 seconds seconds only 60s - 1 hour minutes and seconds 1 hour - 1 day hours, minutes, and seconds &gt; 1 day days, hours, minutes (short format) or days, hours, minutes, and seconds (long format) <p>Precision</p> <ul> <li>Long format: Displays seconds with 2 decimal places</li> <li>Short format: Displays only whole seconds (fractional part truncated)</li> </ul>"},{"location":"learn/utilities/string_formatting.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating both formats with various durations:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Format various time durations in long format (default)\nprint(\"Long format (default):\")\nprint(f\"  30 seconds: {bh.format_time_string(30)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000)}\")\n\n# Format the same durations in short format\nprint(\"\\nShort format:\")\nprint(f\"  30 seconds: {bh.format_time_string(30, short=True)}\")\nprint(f\"  90 seconds: {bh.format_time_string(90, short=True)}\")\nprint(f\"  362 seconds: {bh.format_time_string(362, short=True)}\")\nprint(f\"  3665 seconds: {bh.format_time_string(3665, short=True)}\")\nprint(f\"  90000 seconds: {bh.format_time_string(90000, short=True)}\")\n\n# Practical use case: format orbital period\norbital_period = bh.orbital_period(bh.R_EARTH + 500e3)\nprint(f\"\\nLEO orbital period: {bh.format_time_string(orbital_period)}\")\nprint(\n    f\"LEO orbital period (short): {bh.format_time_string(orbital_period, short=True)}\"\n)\n\n# Expected output:\n# Long format (default):\n#   30 seconds: 30.00 seconds\n#   90 seconds: 1 minute and 30.00 seconds\n#   362 seconds: 6 minutes and 2.00 seconds\n#   3665 seconds: 1 hour, 1 minute and 5.00 seconds\n#   90000 seconds: 1 day, 1 hour and 0.00 seconds\n#\n# Short format:\n#   30 seconds: 30s\n#   90 seconds: 1m 30s\n#   362 seconds: 6m 2s\n#   3665 seconds: 1h 1m 5s\n#   90000 seconds: 1d 1h 0m\n#\n# LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\n# LEO orbital period (short): 1h 34m 38s\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Format various time durations in long format (default)\n    println!(\"Long format (default):\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, false));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, false));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, false));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, false));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, false));\n\n    // Format the same durations in short format\n    println!(\"\\nShort format:\");\n    println!(\"  30 seconds: {}\", bh::utils::format_time_string(30.0, true));\n    println!(\"  90 seconds: {}\", bh::utils::format_time_string(90.0, true));\n    println!(\"  362 seconds: {}\", bh::utils::format_time_string(362.0, true));\n    println!(\"  3665 seconds: {}\", bh::utils::format_time_string(3665.0, true));\n    println!(\"  90000 seconds: {}\", bh::utils::format_time_string(90000.0, true));\n\n    // Practical use case: format orbital period\n    let orbital_period = bh::orbits::orbital_period(bh::constants::R_EARTH + 500e3);\n    println!(\"\\nLEO orbital period: {}\", bh::utils::format_time_string(orbital_period, false));\n    println!(\"LEO orbital period (short): {}\", bh::utils::format_time_string(orbital_period, true));\n\n    // Expected output:\n    // Long format (default):\n    //   30 seconds: 30.00 seconds\n    //   90 seconds: 1 minute and 30.00 seconds\n    //   362 seconds: 6 minutes and 2.00 seconds\n    //   3665 seconds: 1 hour, 1 minute and 5.00 seconds\n    //   90000 seconds: 1 day, 1 hour and 0.00 seconds\n    //\n    // Short format:\n    //   30 seconds: 30s\n    //   90 seconds: 1m 30s\n    //   362 seconds: 6m 2s\n    //   3665 seconds: 1h 1m 5s\n    //   90000 seconds: 1d 1h 0m\n    //\n    // LEO orbital period: 1 hour, 34 minutes and 38.34 seconds\n    // LEO orbital period (short): 1h 34m 38s\n}\n</code></pre>"},{"location":"learn/utilities/string_formatting.html#common-use-cases","title":"Common Use Cases","text":"<p>Time formatting is useful for:</p> <ul> <li>Access window durations: Display how long a satellite is visible from a ground station</li> <li>Orbital periods: Show the time for one complete orbit in readable form</li> <li>Propagation times: Display simulation duration or time steps</li> <li>Reports and output: Present timing information to users</li> </ul> <p>Choosing a Format</p> <ul> <li>Use long format for reports, documentation, and user-facing output where clarity is important</li> <li>Use short format for tables, logs, and situations where space is limited</li> </ul>"},{"location":"learn/utilities/string_formatting.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>String Formatting API Reference - Complete formatting function documentation</li> </ul>"},{"location":"learn/utilities/threading.html","title":"Multithreading","text":"<p>Brahe uses a global thread pool to parallelize computationally intensive operations, such as computing access windows between satellites and ground locations. The threading utilities allow you to configure the number of threads used by the thread pool.</p> <p>For complete API details, see the Threading API Reference.</p>"},{"location":"learn/utilities/threading.html#default-behavior","title":"Default Behavior","text":"<p>By default, Brahe automatically configures the thread pool to use 90% of available CPU cores on first use. This greatly accelerates computations while leaving some resources for other processes to avoid resource-starving other processes on the machine.</p> <p>For example, on a system with 8 CPU cores, Brahe will use 7 threads by default.</p> <p>Lazy Initialization</p> <p>The thread pool is initialized on first use, not when you import Brahe. This means the default thread count is determined when you first call a function that uses the thread pool.</p> <p>You can configure the thread pool before first use to override the default behavior by calling <code>set_num_threads()</code> or <code>set_max_threads()</code> as shown below.</p> <p>Thread Safety</p> <p>All Brahe functions are thread-safe. You can safely call Brahe functions from multiple threads simultaneously.</p>"},{"location":"learn/utilities/threading.html#setting-thread-count","title":"Setting Thread Count","text":""},{"location":"learn/utilities/threading.html#set-specific-number","title":"Set Specific Number","text":"<p>You can set the thread pool to use a specific number of threads:</p> PythonRust <pre><code># Set a specific number of threads\nbh.set_num_threads(4)\nthreads_after_set = bh.get_max_threads()\nprint(f\"Thread count after setting to 4: {threads_after_set}\")\n</code></pre> <pre><code>    // Set a specific number of threads\n    bh::utils::set_num_threads(4);\n    let threads_after_set = bh::utils::get_max_threads();\n    println!(\"Thread count after setting to 4: {}\", threads_after_set);\n</code></pre>"},{"location":"learn/utilities/threading.html#set-maximum-threads","title":"Set Maximum Threads","text":"<p>To use all available CPU cores (100%), use <code>set_max_threads()</code>:</p> PythonRust <pre><code># Set to maximum available (100% of CPU cores)\nbh.set_max_threads()\nmax_threads = bh.get_max_threads()\nprint(f\"Maximum thread count: {max_threads}\")\n</code></pre> <pre><code>    // Set to maximum available (100% of CPU cores)\n    bh::utils::set_max_threads();\n    let max_threads = bh::utils::get_max_threads();\n    println!(\"Maximum thread count: {}\", max_threads);\n</code></pre> <p>When to Use Maximum Threads</p> <p>Use <code>set_max_threads()</code> when Brahe is the sole computational task running on a server and you want to maximize throughput.</p>"},{"location":"learn/utilities/threading.html#ludicrous-speed","title":"Ludicrous Speed!","text":"<p>For a bit of fun, there's an alias for <code>set_max_threads()</code>:</p> PythonRust <pre><code># Alternative: use the fun alias!\nbh.set_ludicrous_speed()\nludicrous_threads = bh.get_max_threads()\nprint(f\"Ludicrous speed thread count: {ludicrous_threads}\")\n</code></pre> <pre><code>    // Alternative: use the fun alias!\n    bh::utils::set_ludicrous_speed();\n    let ludicrous_threads = bh::utils::get_max_threads();\n    println!(\"Ludicrous speed thread count: {}\", ludicrous_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#querying-thread-count","title":"Querying Thread Count","text":"<p>You can check the current thread pool configuration at any time:</p> PythonRust <pre><code># Query the default number of threads\n# By default, Brahe uses 90% of available CPU cores\ndefault_threads = bh.get_max_threads()\nprint(f\"Default thread count: {default_threads}\")\n</code></pre> <pre><code>    // Query the default number of threads\n    // By default, Brahe uses 90% of available CPU cores\n    let default_threads = bh::utils::get_max_threads();\n    println!(\"Default thread count: {}\", default_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#reconfiguring-the-thread-pool","title":"Reconfiguring the Thread Pool","text":"<p>The thread pool can be reconfigured at any time during program execution. Simply call <code>set_num_threads()</code> or <code>set_max_threads()</code> again with the new desired configuration:</p> PythonRust <pre><code># The thread pool can be reconfigured at any time\nbh.set_num_threads(2)\nfinal_threads = bh.get_max_threads()\nprint(f\"Final thread count: {final_threads}\")\n</code></pre> <pre><code>    // The thread pool can be reconfigured at any time\n    bh::utils::set_num_threads(2);\n    let final_threads = bh::utils::get_max_threads();\n    println!(\"Final thread count: {}\", final_threads);\n</code></pre>"},{"location":"learn/utilities/threading.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example demonstrating all threading configuration functions:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Query the default number of threads\n# By default, Brahe uses 90% of available CPU cores\ndefault_threads = bh.get_max_threads()\nprint(f\"Default thread count: {default_threads}\")\n\n# Set a specific number of threads\nbh.set_num_threads(4)\nthreads_after_set = bh.get_max_threads()\nprint(f\"Thread count after setting to 4: {threads_after_set}\")\n\n# Set to maximum available (100% of CPU cores)\nbh.set_max_threads()\nmax_threads = bh.get_max_threads()\nprint(f\"Maximum thread count: {max_threads}\")\n\n# Alternative: use the fun alias!\nbh.set_ludicrous_speed()\nludicrous_threads = bh.get_max_threads()\nprint(f\"Ludicrous speed thread count: {ludicrous_threads}\")\n\n# The thread pool can be reconfigured at any time\nbh.set_num_threads(2)\nfinal_threads = bh.get_max_threads()\nprint(f\"Final thread count: {final_threads}\")\n\n# Note: Thread pool is used for parallelizable operations like:\n# - Computing access windows between satellites and ground locations\n# - Processing large batches of orbital calculations\n\n# Expected output (actual numbers vary by system):\n# Default thread count: 7\n# Thread count after setting to 4: 4\n# Maximum thread count: 8\n# Ludicrous speed thread count: 8\n# Final thread count: 2\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Query the default number of threads\n    // By default, Brahe uses 90% of available CPU cores\n    let default_threads = bh::utils::get_max_threads();\n    println!(\"Default thread count: {}\", default_threads);\n\n    // Set a specific number of threads\n    bh::utils::set_num_threads(4);\n    let threads_after_set = bh::utils::get_max_threads();\n    println!(\"Thread count after setting to 4: {}\", threads_after_set);\n\n    // Set to maximum available (100% of CPU cores)\n    bh::utils::set_max_threads();\n    let max_threads = bh::utils::get_max_threads();\n    println!(\"Maximum thread count: {}\", max_threads);\n\n    // Alternative: use the fun alias!\n    bh::utils::set_ludicrous_speed();\n    let ludicrous_threads = bh::utils::get_max_threads();\n    println!(\"Ludicrous speed thread count: {}\", ludicrous_threads);\n\n    // The thread pool can be reconfigured at any time\n    bh::utils::set_num_threads(2);\n    let final_threads = bh::utils::get_max_threads();\n    println!(\"Final thread count: {}\", final_threads);\n\n    // Note: Thread pool is used for parallelizable operations like:\n    // - Computing access windows between satellites and ground locations\n    // - Processing large batches of orbital calculations\n\n    // Expected output (actual numbers vary by system):\n    // Default thread count: 7\n    // Thread count after setting to 4: 4\n    // Maximum thread count: 8\n    // Ludicrous speed thread count: 8\n    // Final thread count: 2\n}\n</code></pre>"},{"location":"learn/utilities/threading.html#see-also","title":"See Also","text":"<ul> <li>Utilities Overview - Overview of all utilities</li> <li>Threading API Reference - Complete threading function documentation</li> </ul>"},{"location":"library_api/index.html","title":"Python API Reference","text":"<p>This section provides comprehensive documentation for the Brahe Python API. All classes, functions, and modules are documented with detailed descriptions, parameters, return values, and usage examples.</p>"},{"location":"library_api/index.html#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the detailed API documentation for each module. Each page includes:</p> <ul> <li>Complete class and function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value specifications</li> <li>Usage examples</li> </ul> <p>All documentation is automatically generated from the source code docstrings to ensure accuracy and consistency.</p>"},{"location":"library_api/access/index.html","title":"Access Computation API","text":"<p>The access computation module provides comprehensive tools for determining when satellites can observe or communicate with ground locations.</p>"},{"location":"library_api/access/index.html#core-functions","title":"Core Functions","text":""},{"location":"library_api/access/index.html#brahe.location_accesses","title":"location_accesses  <code>builtin</code>","text":"<pre><code>location_accesses(locations: PointLocation | PolygonLocation | List[PointLocation | PolygonLocation], propagators: SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator], search_start: Epoch, search_end: Epoch, constraint: Union[ElevationConstraint, OffNadirConstraint, LocalTimeConstraint, LookDirectionConstraint, AscDscConstraint, ElevationMaskConstraint, ConstraintAll, ConstraintAny, ConstraintNot], property_computers: [List[AccessPropertyComputer]] = None, config: [AccessSearchConfig] = None, time_tolerance: [float] = None) -&gt; List[AccessWindow]\n</code></pre> <p>Compute access windows for locations and satellites.</p> <p>This function accepts either single items or lists for both locations and propagators, automatically handling all combinations. All location-satellite pairs are computed and results are returned sorted by window start time.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>PointLocation | PolygonLocation | List[PointLocation | PolygonLocation]</code> <p>Single location or list of locations</p> required <code>propagators</code> <code>SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator]</code> <p>Single propagator or list of propagators</p> required <code>search_start</code> <code>Epoch</code> <p>Start of search window</p> required <code>search_end</code> <code>Epoch</code> <p>End of search window</p> required <code>constraint</code> <code>AccessConstraint</code> <p>Access constraints to evaluate</p> required <code>property_computers</code> <code>Optional[List[AccessPropertyComputer]]</code> <p>Optional property computers</p> <code>None</code> <code>config</code> <code>Optional[AccessSearchConfig]</code> <p>Search configuration (default: 60s fixed grid, no adaptation)</p> <code>None</code> <code>time_tolerance</code> <code>Optional[float]</code> <p>Bisection search tolerance in seconds (default: 0.01)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AccessWindow]</code> <p>List[AccessWindow]: List of access windows sorted by start time</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a ground station\nstation = bh.PointLocation(-75.0, 40.0, 0.0)  # Philadelphia\n\n# Create satellite propagators\nepoch = bh.Epoch(2024, 1, 1, 0, 0, 0.0)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator(epoch, state)\n\n# Define access constraints\nconstraint = bh.ElevationConstraint(10.0)  # 10 degree minimum elevation\n\n# Single location, single propagator\nsearch_end = epoch + 86400.0  # 1 day\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint)\n\n# Single location, multiple propagators\nprop2 = bh.KeplerianPropagator(epoch, state)  # Different satellite\nwindows = bh.location_accesses(station, [prop1, prop2], epoch, search_end, constraint)\n\n# Multiple locations, single propagator\nstation2 = bh.PointLocation(-122.0, 37.0, 0.0)  # San Francisco\nwindows = bh.location_accesses([station, station2], prop1, epoch, search_end, constraint)\n\n# Multiple locations, multiple propagators\nwindows = bh.location_accesses([station, station2], [prop1, prop2], epoch, search_end, constraint)\n\n# Custom search configuration\nconfig = bh.AccessSearchConfig(initial_time_step=30.0, adaptive_step=True)\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint, config=config)\n</code></pre>"},{"location":"library_api/access/index.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/index.html#brahe.AccessSearchConfig","title":"AccessSearchConfig","text":"<pre><code>AccessSearchConfig(initial_time_step: float = 60.0, adaptive_step: bool = False, adaptive_fraction: float = 0.75, parallel: Any = True, num_threads: Any = None)\n</code></pre> <p>Configuration for access search grid parameters.</p> <p>Controls the time step and adaptive stepping behavior for access window finding.</p> <p>Parameters:</p> Name Type Description Default <code>initial_time_step</code> <code>float</code> <p>Initial time step in seconds for grid search (default: 60.0)</p> <code>60.0</code> <code>adaptive_step</code> <code>bool</code> <p>Enable adaptive stepping after first access (default: False)</p> <code>False</code> <code>adaptive_fraction</code> <code>float</code> <p>Fraction of orbital period to use for adaptive step (default: 0.75)</p> <code>0.75</code> Example <pre><code>import brahe as bh\n\n# Create a config with custom parameters\nconfig = bh.AccessSearchConfig(\n    initial_time_step=30.0,\n    adaptive_step=True,\n    adaptive_fraction=0.5\n)\n\n# Use config with location_accesses\nwindows = bh.location_accesses(\n    station, prop, search_start, search_end,\n    constraint, config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_fraction","title":"adaptive_fraction  <code>property</code>","text":"<pre><code>adaptive_fraction: float\n</code></pre> <p>Get the adaptive fraction (fraction of orbital period).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adaptive fraction</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_step","title":"adaptive_step  <code>property</code>","text":"<pre><code>adaptive_step: bool\n</code></pre> <p>Get whether adaptive stepping is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Adaptive stepping flag</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.initial_time_step","title":"initial_time_step  <code>property</code>","text":"<pre><code>initial_time_step: float\n</code></pre> <p>Get the initial time step in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Initial time step</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.num_threads","title":"num_threads  <code>property</code>","text":"<pre><code>num_threads: Optional[int]\n</code></pre> <p>Get the number of threads for parallel computation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Number of threads, or None to use global setting</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.parallel","title":"parallel  <code>property</code>","text":"<pre><code>parallel: bool\n</code></pre> <p>Get whether parallel computation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Parallel computation flag (default: True)</p>"},{"location":"library_api/access/index.html#threading-control","title":"Threading Control","text":""},{"location":"library_api/access/index.html#brahe.set_num_threads","title":"set_num_threads  <code>builtin</code>","text":"<pre><code>set_num_threads(n: int) -&gt; Any\n</code></pre> <p>Set the number of threads for parallel computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations such as access computations. This function can be called multiple times to dynamically change the thread pool configuration - each call will reinitialize the pool with the new thread count.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If n &lt; 1.</p> <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Set to 4 threads initially\nbh.set_num_threads(4)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 4\n\n# Reinitialize with 8 threads - no error!\nbh.set_num_threads(8)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 8\n\n# All parallel operations (e.g., location_accesses) will now use\n# 8 threads unless overridden with AccessSearchConfig.num_threads\n</code></pre> Note <p>Unlike earlier versions, this function no longer raises an error if the thread pool has already been initialized. You can safely call it at any time to reconfigure the thread pool.</p>"},{"location":"library_api/access/index.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads() -&gt; Any\n</code></pre> <p>Set the thread pool to use all available CPU cores.</p> <p>This is a convenience function that sets the number of threads to 100% of available CPU cores. Can be called multiple times to reinitialize the thread pool dynamically.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Use all available CPU cores\nbh.set_max_threads()\nprint(f\"Using all {bh.get_max_threads()} cores\")\n\n# Switch to 2 threads\nbh.set_num_threads(2)\n\n# Switch back to max - no error!\nbh.set_max_threads()\nprint(f\"Back to {bh.get_max_threads()} cores\")\n</code></pre> Note <p>This function can be called at any time, even after the thread pool has been initialized with a different configuration.</p>"},{"location":"library_api/access/index.html#brahe.set_ludicrous_speed","title":"set_ludicrous_speed  <code>builtin</code>","text":"<pre><code>set_ludicrous_speed() -&gt; Any\n</code></pre> <p>LUDICROUS SPEED! GO!</p> <p>Set the thread pool to use all available CPU cores (alias for <code>set_max_threads</code>).</p> <p>This is a fun alias for <code>set_max_threads()</code> that sets the number of threads to 100% of available CPU cores for maximum performance. Can be called multiple times to dynamically reinitialize the thread pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# MAXIMUM POWER! Use all available CPU cores\nbh.set_ludicrous_speed()\nprint(f\"Going ludicrous with {bh.get_max_threads()} threads!\")\n\n# Throttle down for testing\nbh.set_num_threads(1)\n\n# ENGAGE LUDICROUS SPEED again - no error!\nbh.set_ludicrous_speed()\n</code></pre> Note <p>This function can be called at any time to reconfigure the thread pool to use maximum available cores, regardless of previous configuration.</p>"},{"location":"library_api/access/index.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores, initialized on first call)\nthreads = bh.get_max_threads()\nprint(f\"Default: {threads} threads\")\n\n# Set to specific value and verify\nbh.set_num_threads(4)\nassert bh.get_max_threads() == 4\n\n# Reconfigure and verify again\nbh.set_num_threads(8)\nassert bh.get_max_threads() == 8\n\n# Switch to max cores\nbh.set_max_threads()\nprint(f\"Max cores: {bh.get_max_threads()}\")\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings (90% of cores) if it hasn't been configured yet. After initialization, you can still reconfigure it using set_num_threads() or set_max_threads().</p>"},{"location":"library_api/access/constraint_computer.html","title":"Custom Constraint Computer","text":"<p>The <code>AccessConstraintComputer</code> base class allows you to create custom constraint logic for access computation. Subclass this class and implement the <code>evaluate</code> and <code>name</code> methods to define custom constraints that can be combined with built-in constraints using logical operators.</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer","title":"AccessConstraintComputer","text":"<pre><code>AccessConstraintComputer()\n</code></pre> <p>Base class for custom access constraint computers.</p> <p>Subclass this class and implement the <code>evaluate</code> and <code>name</code> methods to create custom constraint logic that can be applied to access computation.</p> <p>The evaluate method is called at each time step during access search to determine if the constraint is satisfied. Return True if the constraint is satisfied (access is allowed), False otherwise.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass NorthernHemisphereConstraint(bh.AccessConstraintComputer):\n    '''Only allows access when satellite is in northern hemisphere.'''\n\n    def evaluate(self, epoch: bh.Epoch, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; bool:\n        '''\n        Args:\n            epoch (Epoch): Current evaluation time\n            satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef (ndarray or list): Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            bool: True if constraint is satisfied, False otherwise\n        '''\n        # Check if satellite Z-coordinate (ECEF) is positive (northern hemisphere)\n        return satellite_state_ecef[2] &gt;= 0.0\n\n    def name(self) -&gt; str:\n        '''Return name of this constraint.'''\n        return \"NorthernHemisphereConstraint\"\n\n# Use with access computation\ncustom_constraint = NorthernHemisphereConstraint()\n# Then combine with other constraints using ConstraintAll or ConstraintAny\n</code></pre> Notes <ul> <li>The <code>evaluate</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Return True to allow access, False to reject</li> <li>The constraint is checked at each time step during access search</li> <li>Custom constraints can be combined with built-in constraints using ConstraintAll/ConstraintAny</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, satellite_state_ecef: ndarray, location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Override this method in your subclass to implement custom constraint logic.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Current evaluation time</p> required <code>satellite_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied (access allowed), False otherwise</p>"},{"location":"library_api/access/constraint_computer.html#brahe._brahe.AccessConstraintComputer.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Return name of this constraint computer.</p> <p>Override this method to return a descriptive name for your constraint.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Constraint name</p>"},{"location":"library_api/access/constraints.html","title":"Constraints","text":"<p>Constraints define criteria that must be satisfied for satellite access.</p>"},{"location":"library_api/access/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"library_api/access/constraints.html#elevationconstraint","title":"ElevationConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint","title":"ElevationConstraint","text":"<pre><code>ElevationConstraint(min_elevation_deg: float | None = None, max_elevation_deg: float | None = None)\n</code></pre> <p>Elevation angle constraint for satellite visibility.</p> <p>Constrains access based on the elevation angle of the satellite above the local horizon at the ground location.</p> <p>Parameters:</p> Name Type Description Default <code>min_elevation_deg</code> <code>float | None</code> <p>Minimum elevation angle in degrees, or None for no minimum</p> <code>None</code> <code>max_elevation_deg</code> <code>float | None</code> <p>Maximum elevation angle in degrees, or None for no maximum</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None (unbounded constraint is meaningless)</p> Example <pre><code>import brahe as bh\n\n# Typical ground station constraint: 5\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\n\n# Both bounds specified\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\n\n# Only maximum (e.g., avoid zenith)\nconstraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint","title":"ElevationMaskConstraint","text":"<pre><code>ElevationMaskConstraint(mask: list[tuple[float, float]])\n</code></pre> <p>Azimuth-dependent elevation mask constraint.</p> <p>Constrains access based on azimuth-dependent elevation masks. Useful for ground stations with terrain obstructions or antenna limitations.</p> <p>The mask is defined as a list of (azimuth, elevation) pairs in degrees. Linear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>list[tuple[float, float]]</code> <p>List of (azimuth_deg, min_elevation_deg) pairs</p> required Example <pre><code>import brahe as bh\n\n# Ground station with terrain obstruction to the north\nmask = [\n    (0.0, 15.0),     # North: 15\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 5.0),    # South: 5\u00b0 minimum\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n]\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint","title":"OffNadirConstraint","text":"<pre><code>OffNadirConstraint(min_off_nadir_deg: float | None = None, max_off_nadir_deg: float | None = None)\n</code></pre> <p>Off-nadir angle constraint for satellite imaging.</p> <p>Constrains access based on the off-nadir angle (angle between the satellite's nadir vector and the line-of-sight to the location).</p> <p>Parameters:</p> Name Type Description Default <code>min_off_nadir_deg</code> <code>float | None</code> <p>Minimum off-nadir angle in degrees, or None for no minimum</p> <code>None</code> <code>max_off_nadir_deg</code> <code>float | None</code> <p>Maximum off-nadir angle in degrees, or None for no maximum</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None, or if any angle is negative</p> Example <pre><code>import brahe as bh\n\n# Imaging satellite with 45\u00b0 maximum slew angle\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\n\n# Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint","title":"LookDirectionConstraint","text":"<pre><code>LookDirectionConstraint(allowed: LookDirection)\n</code></pre> <p>Look direction constraint (left/right relative to velocity).</p> <p>Constrains access based on the look direction of the satellite relative to its velocity vector.</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>LookDirection</code> <p>Required look direction (LEFT, RIGHT, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Satellite can only look right\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Either direction is acceptable\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint","title":"LocalTimeConstraint","text":"<pre><code>LocalTimeConstraint(time_windows: list[tuple[int, int]])\n</code></pre> <p>Local solar time constraint.</p> <p>Constrains access based on the local solar time at the ground location. Useful for sun-synchronous orbits or daytime-only imaging.</p> <p>Time windows are specified in military time format (HHMM). Wrap-around windows (e.g., 2200-0200) are supported.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[int, int]]</code> <p>List of (start_military, end_military) tuples (0-2400)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any military time is invalid (&gt;2400 or minutes &gt;=60)</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\n\n# Two windows: morning (6-9 AM) and evening (4-7 PM)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\n\n# Overnight window (10 PM to 2 AM) - handles wrap-around\nconstraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.from_hours","title":"from_hours  <code>builtin</code>","text":"<pre><code>from_hours(time_windows: list[tuple[float, float]]) -&gt; LocalTimeConstraint\n</code></pre> <p>Create from decimal hour windows instead of military time.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[float, float]]</code> <p>List of (start_hour, end_hour) tuples [0, 24)</p> required <p>Returns:</p> Name Type Description <code>LocalTimeConstraint</code> <code>LocalTimeConstraint</code> <p>The constraint instance</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint.from_hours([(6.0, 18.0)])\n\n# Overnight window (10 PM to 2 AM)\nconstraint = bh.LocalTimeConstraint.from_hours([(22.0, 2.0)])\n</code></pre>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#ascdscconstraint","title":"AscDscConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint","title":"AscDscConstraint","text":"<pre><code>AscDscConstraint(allowed: AscDsc)\n</code></pre> <p>Ascending/descending pass constraint.</p> <p>Constrains access based on whether the satellite is on an ascending or descending pass (moving north or south).</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>AscDsc</code> <p>Required pass type (ASCENDING, DESCENDING, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Either type is acceptable\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#logical-composition","title":"Logical Composition","text":""},{"location":"library_api/access/constraints.html#constraintall","title":"ConstraintAll","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAll","title":"ConstraintAll","text":"<pre><code>ConstraintAll(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with AND logic.</p> <p>All constraints must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with AND logic</p> required Example <pre><code>import brahe as bh\n\n# Ground station with multiple requirements\nelev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\ncombined = bh.ConstraintAll(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ALL constraints are satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintany","title":"ConstraintAny","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAny","title":"ConstraintAny","text":"<pre><code>ConstraintAny(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with OR logic.</p> <p>At least one constraint must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with OR logic</p> required Example <pre><code>import brahe as bh\n\n# Accept either high elevation or specific time window\nelev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\ncombined = bh.ConstraintAny(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if AT LEAST ONE constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintnot","title":"ConstraintNot","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintNot","title":"ConstraintNot","text":"<pre><code>ConstraintNot(constraint: object)\n</code></pre> <p>Composite constraint negating another constraint with NOT logic.</p> <p>The negated constraint must NOT be satisfied for this to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>object</code> <p>Constraint object to negate</p> required Example <pre><code>import brahe as bh\n\n# Avoid low elevation angles (i.e., require high elevation)\nlow_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\nhigh_elev = bh.ConstraintNot(constraint=low_elev)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: Union[ndarray, List], location_ecef: Union[ndarray, List]) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray or list</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the negated constraint is NOT satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/enums.html","title":"Access Enumerations","text":"<p>Enumeration types used in access computation.</p>"},{"location":"library_api/access/enums.html#lookdirection","title":"LookDirection","text":""},{"location":"library_api/access/enums.html#brahe.LookDirection","title":"LookDirection","text":"<pre><code>LookDirection()\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <code>Any</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <code>Any</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <code>Any</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = LookDirection.Either\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.LEFT","title":"LEFT  <code>class-attribute</code>","text":"<pre><code>LEFT: Any = LookDirection.Left\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.RIGHT","title":"RIGHT  <code>class-attribute</code>","text":"<pre><code>RIGHT: Any = LookDirection.Right\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#ascdsc","title":"AscDsc","text":""},{"location":"library_api/access/enums.html#brahe.AscDsc","title":"AscDsc","text":"<pre><code>AscDsc()\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>Any</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <code>Any</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <code>Any</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.ASCENDING","title":"ASCENDING  <code>class-attribute</code>","text":"<pre><code>ASCENDING: Any = AscDsc.Ascending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.DESCENDING","title":"DESCENDING  <code>class-attribute</code>","text":"<pre><code>DESCENDING: Any = AscDsc.Descending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = AscDsc.Either\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/locations.html","title":"Locations","text":"<p>Location types represent ground positions or areas that satellites can access.</p>"},{"location":"library_api/access/locations.html#pointlocation","title":"PointLocation","text":""},{"location":"library_api/access/locations.html#brahe.PointLocation","title":"PointLocation","text":"<pre><code>PointLocation(lon: float, lat: float, alt: float = 0.0)\n</code></pre> <p>A single point location on Earth's surface.</p> <p>Represents a discrete point with geodetic coordinates (longitude, latitude, altitude). Commonly used for ground stations, imaging targets, or tessellated polygon tiles.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude in degrees (-180 to 180)</p> required <code>lat</code> <code>float</code> <p>Latitude in degrees (-90 to 90)</p> required <code>alt</code> <code>float</code> <p>Altitude above ellipsoid in meters (default: 0.0)</p> <code>0.0</code> Example <pre><code>import brahe as bh\n\n# Create a ground station in Svalbard\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\n\n# With identity\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard Ground Station\") \\\\\n    .with_id(1)\n\n# With custom properties\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"min_elevation_deg\", 5.0)\n\n# Access coordinates as properties\nlon = svalbard.lon  # Property (always degrees)\nlat = svalbard.lat  # Property (always degrees)\nlat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nprint(loc.properties[\"climate\"])  # \"Arctic\"\n\n# Dict methods\nif \"country\" in loc.properties:\n    del loc.properties[\"country\"]\n\n# Iteration\nfor key in loc.properties.keys():\n    print(key, loc.properties[key])\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation._get_properties_dict","title":"_get_properties_dict  <code>method descriptor</code>","text":"<pre><code>_get_properties_dict()\n</code></pre> <p>Internal method: Get properties as a plain Python dict.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation._remove_property","title":"_remove_property  <code>method descriptor</code>","text":"<pre><code>_remove_property(key)\n</code></pre> <p>Internal method: Remove a property.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation._set_property","title":"_set_property  <code>method descriptor</code>","text":"<pre><code>_set_property(key, json_str)\n</code></pre> <p>Internal method: Set a property value.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value: Any) -&gt; PointLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <code>Any</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"elevation_mask_deg\", 5.0)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PointLocation\n</code></pre> <p>Create from GeoJSON Point Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Point geometry</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>New location instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Point Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 0.0]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\"\n    }\n}\n\nlocation = bh.PointLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard\")\n\ngeojson = location.to_geojson()\n# Returns:\n# {\n#     \"type\": \"Feature\",\n#     \"geometry\": {\n#         \"type\": \"Point\",\n#         \"coordinates\": [15.4, 78.2, 0.0]\n#     },\n#     \"properties\": {\n#         \"name\": \"Svalbard\"\n#     }\n# }\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PointLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PointLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PointLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PointLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/locations.html#polygonlocation","title":"PolygonLocation","text":""},{"location":"library_api/access/locations.html#brahe.PolygonLocation","title":"PolygonLocation","text":"<pre><code>PolygonLocation(vertices: list[list[float]])\n</code></pre> <p>A polygonal area on Earth's surface.</p> <p>Represents a closed polygon with multiple vertices. Commonly used for areas of interest, no-fly zones, or imaging footprints.</p> <p>The polygon is automatically closed if the first and last vertices don't match.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[list[float]]</code> <p>List of [lon, lat, alt] vertices in degrees and meters</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If polygon has fewer than 4 vertices or has validation errors</p> Example <pre><code>import brahe as bh\n\n# Define a rectangular area\nvertices = [\n    [10.0, 50.0, 0.0],  # lon, lat, alt\n    [11.0, 50.0, 0.0],\n    [11.0, 51.0, 0.0],\n    [10.0, 51.0, 0.0],\n    [10.0, 50.0, 0.0],  # Closed (first == last)\n]\npolygon = bh.PolygonLocation(vertices)\n\n# With identity\npolygon = bh.PolygonLocation(vertices) \\\\\n    .with_name(\"AOI-1\") \\\\\n    .add_property(\"region\", \"Europe\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get center latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get center longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.num_vertices","title":"num_vertices  <code>property</code>","text":"<pre><code>num_vertices: int\n</code></pre> <p>Get number of unique vertices (excluding closure).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of unique vertices</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nverts = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]\npoly = bh.PolygonLocation(verts)\n\n# Dict-style assignment\npoly.properties[\"region\"] = \"Test Area\"\npoly.properties[\"area_km2\"] = 123.45\n\n# Dict-style access\nprint(poly.properties[\"region\"])  # \"Test Area\"\n\n# Dict methods\nif \"area_km2\" in poly.properties:\n    del poly.properties[\"area_km2\"]\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.vertices","title":"vertices  <code>property</code>","text":"<pre><code>vertices: ndarray\n</code></pre> <p>Get polygon vertices.</p> <p>Returns all vertices including the closure vertex (first == last).</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Vertices as Nx3 array [[lon, lat, alt], ...]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._get_properties_dict","title":"_get_properties_dict  <code>method descriptor</code>","text":"<pre><code>_get_properties_dict()\n</code></pre> <p>Internal method: Get properties as a plain Python dict.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._remove_property","title":"_remove_property  <code>method descriptor</code>","text":"<pre><code>_remove_property(key)\n</code></pre> <p>Internal method: Remove a property.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation._set_property","title":"_set_property  <code>method descriptor</code>","text":"<pre><code>_set_property(key, json_str)\n</code></pre> <p>Internal method: Set a property value.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value: Any) -&gt; PolygonLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <code>Any</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PolygonLocation\n</code></pre> <p>Create from GeoJSON Polygon Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Polygon geometry</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>New polygon instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Polygon Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\"\n    }\n}\n\npolygon = bh.PolygonLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PolygonLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PolygonLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PolygonLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PolygonLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/properties.html","title":"Property Computers","text":"<p>Property computers calculate additional measurements for access windows beyond basic visibility timing.</p>"},{"location":"library_api/access/properties.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/properties.html#samplingconfig","title":"SamplingConfig","text":""},{"location":"library_api/access/properties.html#brahe.SamplingConfig","title":"SamplingConfig","text":"<pre><code>SamplingConfig(relative_times: list[float] = None, interval: float = None, offset: float = None, count: int = None)\n</code></pre> <p>Sampling configuration for access property computation.</p> <p>Determines how many times and when to sample satellite states during an access window for property calculations.</p> <p>Parameters:</p> Name Type Description Default <code>relative_times</code> <code>list[float]</code> <p>Relative times from 0.0 (start) to 1.0 (end). If provided, uses relative points sampling.</p> <code>None</code> <code>interval</code> <code>float</code> <p>Time between samples (seconds). If provided with offset, uses fixed interval sampling.</p> <code>None</code> <code>offset</code> <code>float</code> <p>Time offset from window start (seconds). Used with interval.</p> <code>None</code> <code>count</code> <code>int</code> <p>Number of evenly-spaced sample points. If provided, uses fixed count sampling.</p> <code>None</code> Note <p>If no parameters are provided, defaults to midpoint sampling. Parameters are checked in priority order: relative_times, interval+offset, count.</p> Example <pre><code>import brahe as bh\n\n# Midpoint (default)\nconfig = bh.SamplingConfig()\n\n# Relative points\nconfig = bh.SamplingConfig(relative_times=[0.0, 0.5, 1.0])\n\n# Fixed interval\nconfig = bh.SamplingConfig(interval=0.1, offset=0.0)\n\n# Fixed count\nconfig = bh.SamplingConfig(count=10)\n\n# Or use convenience static methods\nconfig = bh.SamplingConfig.midpoint()\nconfig = bh.SamplingConfig.relative_points([0.0, 0.5, 1.0])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.fixed_count","title":"fixed_count  <code>staticmethod</code>","text":"<pre><code>fixed_count(count: int) -&gt; SamplingConfig\n</code></pre> <p>Create a fixed count sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>count</code> <code>int</code> <p>Number of evenly-spaced sample points (including endpoints)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Fixed count sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample at 10 evenly-spaced points\nconfig = bh.SamplingConfig.fixed_count(10)\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.fixed_interval","title":"fixed_interval  <code>staticmethod</code>","text":"<pre><code>fixed_interval(interval: float, offset: float) -&gt; SamplingConfig\n</code></pre> <p>Create a fixed interval sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>Time between samples (seconds)</p> required <code>offset</code> <code>float</code> <p>Time offset from window start (seconds)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Fixed interval sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample every 0.1 seconds, starting at window open\nconfig = bh.SamplingConfig.fixed_interval(0.1, 0.0)\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.midpoint","title":"midpoint  <code>staticmethod</code>","text":"<pre><code>midpoint() -&gt; SamplingConfig\n</code></pre> <p>Create a midpoint sampling configuration (single sample at window center).</p> <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Midpoint sampling configuration</p> Example <pre><code>import brahe as bh\nconfig = bh.SamplingConfig.midpoint()\n</code></pre>"},{"location":"library_api/access/properties.html#brahe.SamplingConfig.relative_points","title":"relative_points  <code>staticmethod</code>","text":"<pre><code>relative_points(relative_times: list[float]) -&gt; SamplingConfig\n</code></pre> <p>Create a relative points sampling configuration.</p> <p>Parameters:</p> Name Type Description Default <code>relative_times</code> <code>list[float]</code> <p>Relative times from 0.0 (window start) to 1.0 (window end)</p> required <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>Relative points sampling configuration</p> Example <pre><code>import brahe as bh\n# Sample at start, quarter, middle, three-quarters, and end\nconfig = bh.SamplingConfig.relative_points([0.0, 0.25, 0.5, 0.75, 1.0])\n</code></pre>"},{"location":"library_api/access/properties.html#built-in-computers","title":"Built-in Computers","text":""},{"location":"library_api/access/properties.html#dopplercomputer","title":"DopplerComputer","text":""},{"location":"library_api/access/properties.html#brahe.DopplerComputer","title":"DopplerComputer","text":"<pre><code>DopplerComputer(uplink_frequency: Any, downlink_frequency: Any, sampling_config: Any)\n</code></pre> <p>Computes Doppler shift during access windows.</p> <p>Calculates uplink and/or downlink Doppler shifts based on satellite velocity and line-of-sight geometry.</p> Example <pre><code>import brahe as bh\n\n# Doppler for GPS L1 downlink\nconfig = bh.SamplingConfig.midpoint()\ncomputer = bh.DopplerComputer(\n    uplink_frequency=None,\n    downlink_frequency=1.57542e9,  # Hz\n    sampling_config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#rangecomputer","title":"RangeComputer","text":""},{"location":"library_api/access/properties.html#brahe.RangeComputer","title":"RangeComputer","text":"<pre><code>RangeComputer(sampling_config: Any)\n</code></pre> <p>Computes range (distance) during access windows.</p> <p>Calculates the distance between satellite and ground location.</p> Example <pre><code>import brahe as bh\n\nconfig = bh.SamplingConfig.fixed_interval(0.1 / 86400.0, 0.0)\ncomputer = bh.RangeComputer(config)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#rangeratecomputer","title":"RangeRateComputer","text":""},{"location":"library_api/access/properties.html#brahe.RangeRateComputer","title":"RangeRateComputer","text":"<pre><code>RangeRateComputer(sampling_config: Any)\n</code></pre> <p>Computes range rate (radial velocity) during access windows.</p> <p>Calculates the rate of change of distance between satellite and ground location.</p> Example <pre><code>import brahe as bh\n\nconfig = bh.SamplingConfig.fixed_interval(0.1 / 86400.0, 0.0)\ncomputer = bh.RangeRateComputer(config)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#custom-property-computers","title":"Custom Property Computers","text":""},{"location":"library_api/access/properties.html#accesspropertycomputer","title":"AccessPropertyComputer","text":""},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer","title":"AccessPropertyComputer","text":"<pre><code>AccessPropertyComputer()\n</code></pre> <p>Base class for custom access property computers.</p> <p>Subclass this class and implement the <code>compute</code> and <code>property_names</code> methods to create custom property calculations that can be applied to access windows.</p> <p>The compute method is called for each access window and should return a dictionary of property names to values. Properties can be scalars, vectors, time series, booleans, strings, or any JSON-serializable value.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    '''Computes Doppler shift time series during access windows.'''\n\n    def sampling_config(self) -&gt; bh.SamplingConfig:\n        '''Configure sampling at 1 Hz during access windows.'''\n        return bh.SamplingConfig.fixed_interval(1.0, 0.0)\n\n    def compute(\n        self,\n        window: bh.AccessWindow,\n        sample_epochs: np.ndarray,\n        sample_states_ecef: np.ndarray,\n        location_ecef: np.ndarray,\n        location_geodetic: np.ndarray\n    ) -&gt; dict:\n        '''\n        Args:\n            window (AccessWindow): AccessWindow with timing information\n            sample_epochs (ndarray): Sample epochs in MJD [N]\n            sample_states_ecef (ndarray): Satellite states [N x 6] in ECEF (m, m/s)\n            location_ecef (ndarray or list): Location position [x,y,z] in ECEF (m)\n            location_geodetic (ndarray or list): Location geodetic [lon,lat,alt] (deg, deg, m)\n\n        Returns:\n            dict: Property name -&gt; value (scalar, list, or dict for time series)\n        '''\n        # Compute Doppler shift at each sample\n        doppler_values = []\n        for state in sample_states_ecef:\n            sat_pos = state[:3]\n            sat_vel = state[3:6]\n\n            # Line-of-sight vector\n            los = sat_pos - location_ecef\n            los_unit = los / np.linalg.norm(los)\n\n            # Radial velocity\n            radial_velocity = np.dot(sat_vel, los_unit)\n\n            # Doppler shift (L-band)\n            freq_hz = 1.57542e9  # GPS L1\n            doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\n            doppler_values.append(doppler_hz)\n\n        # Return time series\n        return {\n            \"doppler_shift\": {\n                \"times\": sample_epochs.tolist(),\n                \"values\": doppler_values\n            }\n        }\n\n    def property_names(self) -&gt; list:\n        '''Return list of property names this computer produces.'''\n        return [\"doppler_shift\"]\n\n# Use with access computation (future)\ncomputer = DopplerComputer()\n# accesses = bh.compute_accesses(..., property_computers=[computer])\n</code></pre> Notes <ul> <li>The <code>compute</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Property values are automatically converted to appropriate Rust types</li> <li>The window parameter provides access to timing via:</li> <li><code>window.window_open</code>: Start epoch</li> <li><code>window.window_close</code>: End epoch</li> <li><code>window.midtime()</code>: Midpoint epoch</li> <li><code>window.duration()</code>: Duration in seconds</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(window: AccessWindow, sample_epochs: ndarray, sample_states_ecef: ndarray, location_ecef: Union[ndarray, List], location_geodetic: Union[ndarray, List]) -&gt; dict\n</code></pre> <p>Compute custom properties for an access window.</p> <p>Override this method in your subclass to implement custom property calculations.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>AccessWindow</code> <p>Access window with timing information</p> required <code>sample_epochs</code> <code>ndarray</code> <p>Sample epochs in MJD (Modified Julian Date)</p> required <code>sample_states_ecef</code> <code>ndarray</code> <p>Satellite states in ECEF (N x 6) [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray or list</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <code>location_geodetic</code> <code>ndarray or list</code> <p>Location geodetic coordinates [lon,lat,alt] (radians, meters)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping property names (str) to values (scalar, list, dict, etc.)</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.property_names","title":"property_names  <code>method descriptor</code>","text":"<pre><code>property_names() -&gt; list[str]\n</code></pre> <p>Return list of property names this computer will produce.</p> <p>Override this method to return the list of property names that your compute() method will include in its returned dictionary.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of property names</p>"},{"location":"library_api/access/properties.html#brahe.AccessPropertyComputer.sampling_config","title":"sampling_config  <code>method descriptor</code>","text":"<pre><code>sampling_config() -&gt; SamplingConfig\n</code></pre> <p>Return sampling configuration for this property computer.</p> <p>Override this method to specify how you want the satellite states to be sampled during the access window.</p> <p>Returns:</p> Name Type Description <code>SamplingConfig</code> <code>SamplingConfig</code> <p>The sampling configuration</p> Example <pre><code>import brahe as bh\n\nclass MyComputer(bh.AccessPropertyComputer):\n    def sampling_config(self) -&gt; bh.SamplingConfig:\n        return bh.SamplingConfig.midpoint()\n</code></pre>"},{"location":"library_api/access/properties.html#property-storage","title":"Property Storage","text":""},{"location":"library_api/access/properties.html#propertiesdict","title":"PropertiesDict","text":""},{"location":"library_api/access/properties.html#brahe.PropertiesDict","title":"PropertiesDict","text":"<pre><code>PropertiesDict()\n</code></pre> <p>A dictionary-like wrapper for Location properties that supports dict-style assignment.</p> <p>This class provides a Pythonic dict interface for accessing and modifying location properties. Changes are automatically synchronized with the underlying Location object.</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nclimate = loc.properties[\"climate\"]\n\n# Dict methods work\nif \"country\" in loc.properties:\n    print(loc.properties[\"country\"])\n\n# Iteration\nfor key in loc.properties:\n    print(key, loc.properties[key])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all properties.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get property value with optional default.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>default</code> <code>optional</code> <p>Value to return if key not found</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Property value if key exists, otherwise default value</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.items","title":"items  <code>method descriptor</code>","text":"<pre><code>items() -&gt; List\n</code></pre> <p>Return a list of (key, value) tuples.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of (key, value) tuples</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.keys","title":"keys  <code>method descriptor</code>","text":"<pre><code>keys() -&gt; List\n</code></pre> <p>Return a list of property keys.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of property key strings</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.update","title":"update  <code>method descriptor</code>","text":"<pre><code>update(other: dict) -&gt; None\n</code></pre> <p>Update properties from another dict.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>dict</code> <p>Dictionary to merge into properties</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"library_api/access/properties.html#brahe.PropertiesDict.values","title":"values  <code>method descriptor</code>","text":"<pre><code>values() -&gt; List\n</code></pre> <p>Return a list of property values.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of property values</p>"},{"location":"library_api/access/windows.html","title":"Access Windows","text":"<p>Access windows represent time periods when satellites can access ground locations.</p>"},{"location":"library_api/access/windows.html#accesswindow","title":"AccessWindow","text":""},{"location":"library_api/access/windows.html#brahe.AccessWindow","title":"AccessWindow","text":"<pre><code>AccessWindow(window_open: Epoch, window_close: Epoch)\n</code></pre> <p>An access window representing a period of time when access constraints are satisfied.</p> <p>AccessWindow stores the opening and closing times of an access period, along with computed properties for that window.</p> <p>Parameters:</p> Name Type Description Default <code>window_open</code> <code>Epoch</code> <p>Opening time of the access window</p> required <code>window_close</code> <code>Epoch</code> <p>Closing time of the access window</p> required Example <pre><code>import brahe as bh\n\n# Create an access window\nt_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\nt_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\nwindow = bh.AccessWindow(t_open, t_close)\n\n# Access window properties\nprint(f\"Duration: {window.duration()} seconds\")\nprint(f\"Midpoint: {window.midtime()}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: AscDsc\n</code></pre> <p>Get ascending/descending pass type.</p> <p>Returns:</p> Name Type Description <code>AscDsc</code> <code>AscDsc</code> <p>Pass type enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: float\n</code></pre> <p>Get azimuth angle at window closing (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: float\n</code></pre> <p>Get azimuth angle at window opening (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_alt","title":"center_alt  <code>property</code>","text":"<pre><code>center_alt: float\n</code></pre> <p>Get location center altitude (meters).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_ecef","title":"center_ecef  <code>property</code>","text":"<pre><code>center_ecef: list[float]\n</code></pre> <p>Get location center ECEF coordinates (meters).</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: ECEF coordinates [x, y, z] in meters</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_lat","title":"center_lat  <code>property</code>","text":"<pre><code>center_lat: float\n</code></pre> <p>Get location center latitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.center_lon","title":"center_lon  <code>property</code>","text":"<pre><code>center_lon: float\n</code></pre> <p>Get location center longitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Get the duration of the access window in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Duration in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_close","title":"elevation_close  <code>property</code>","text":"<pre><code>elevation_close: float\n</code></pre> <p>Get elevation angle at window closing (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Elevation at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: float\n</code></pre> <p>Get maximum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: float\n</code></pre> <p>Get minimum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_open","title":"elevation_open  <code>property</code>","text":"<pre><code>elevation_open: float\n</code></pre> <p>Get elevation angle at window opening (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Elevation at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.end","title":"end  <code>property</code>","text":"<pre><code>end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[int]\n</code></pre> <p>Get the access window numeric ID.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Window ID, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: float\n</code></pre> <p>Get local solar time at window midpoint (seconds since midnight, 0-86400).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Local time in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_id","title":"location_id  <code>property</code>","text":"<pre><code>location_id: Optional[int]\n</code></pre> <p>Get the location ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_name","title":"location_name  <code>property</code>","text":"<pre><code>location_name: Optional[str]\n</code></pre> <p>Get the location name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_uuid","title":"location_uuid  <code>property</code>","text":"<pre><code>location_uuid: Optional[str]\n</code></pre> <p>Get the location UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the location as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: LookDirection\n</code></pre> <p>Get look direction (Left or Right).</p> <p>Returns:</p> Name Type Description <code>LookDirection</code> <code>LookDirection</code> <p>Look direction enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.midtime","title":"midtime  <code>property</code>","text":"<pre><code>midtime: Epoch\n</code></pre> <p>Get the midpoint time of the access window.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Midpoint time (average of start and end)</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>Get the access window name (auto-generated or user-set).</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Window name, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: float\n</code></pre> <p>Get maximum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: float\n</code></pre> <p>Get minimum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: AccessProperties\n</code></pre> <p>Get the access properties object.</p> <p>Returns:</p> Name Type Description <code>AccessProperties</code> <code>AccessProperties</code> <p>Computed properties for this access window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_id","title":"satellite_id  <code>property</code>","text":"<pre><code>satellite_id: Optional[int]\n</code></pre> <p>Get the satellite/object ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: Optional[str]\n</code></pre> <p>Get the satellite/object name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_uuid","title":"satellite_uuid  <code>property</code>","text":"<pre><code>satellite_uuid: Optional[str]\n</code></pre> <p>Get the satellite UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the satellite as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.start","title":"start  <code>property</code>","text":"<pre><code>start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.t_end","title":"t_end  <code>property</code>","text":"<pre><code>t_end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close/end).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.t_start","title":"t_start  <code>property</code>","text":"<pre><code>t_start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open/start).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: Optional[str]\n</code></pre> <p>Get the access window UUID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_close","title":"window_close  <code>property</code>","text":"<pre><code>window_close: Epoch\n</code></pre> <p>Get the window closing time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window closing time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_open","title":"window_open  <code>property</code>","text":"<pre><code>window_open: Epoch\n</code></pre> <p>Get the window opening time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window opening time</p>"},{"location":"library_api/access/windows.html#accessproperties","title":"AccessProperties","text":""},{"location":"library_api/access/windows.html#brahe.AccessProperties","title":"AccessProperties","text":"<pre><code>AccessProperties(azimuth_open: Any, azimuth_close: Any, elevation_min: Any, elevation_max: Any, elevation_open: Any, elevation_close: Any, off_nadir_min: Any, off_nadir_max: Any, local_time: Any, look_direction: Any, asc_dsc: Any, center_lon: Any, center_lat: Any, center_alt: Any, center_ecef: Any)\n</code></pre> <p>Properties computed for an access window.</p> <p>AccessProperties contains geometric properties (azimuth, elevation, off-nadir angles, local time, look direction, ascending/descending) computed over an access window, plus location coordinates, plus a dictionary of additional custom properties.</p> <p>Attributes:</p> Name Type Description <code>azimuth_open</code> <code>float</code> <p>Azimuth angle at window opening (degrees, 0-360)</p> <code>azimuth_close</code> <code>float</code> <p>Azimuth angle at window closing (degrees, 0-360)</p> <code>elevation_min</code> <code>float</code> <p>Minimum elevation angle (degrees)</p> <code>elevation_max</code> <code>float</code> <p>Maximum elevation angle (degrees)</p> <code>elevation_open</code> <code>float</code> <p>Elevation angle at window opening (degrees)</p> <code>elevation_close</code> <code>float</code> <p>Elevation angle at window closing (degrees)</p> <code>off_nadir_min</code> <code>float</code> <p>Minimum off-nadir angle (degrees)</p> <code>off_nadir_max</code> <code>float</code> <p>Maximum off-nadir angle (degrees)</p> <code>local_time</code> <code>float</code> <p>Local solar time (seconds since midnight, 0-86400)</p> <code>look_direction</code> <code>LookDirection</code> <p>Required look direction (Left or Right)</p> <code>asc_dsc</code> <code>AscDsc</code> <p>Pass type (Ascending or Descending)</p> <code>center_lon</code> <code>float</code> <p>Location center longitude (degrees)</p> <code>center_lat</code> <code>float</code> <p>Location center latitude (degrees)</p> <code>center_alt</code> <code>float</code> <p>Location center altitude (meters)</p> <code>center_ecef</code> <code>list[float]</code> <p>Location center ECEF coordinates [x, y, z] (meters)</p> Example <pre><code>import brahe as bh\n\n# Access properties are typically computed by the access computation system\n# This example shows accessing the properties\nprops = ...  # From access computation\n\nprint(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\nprint(f\"Max elevation: {props.elevation_max}\u00b0\")\nprint(f\"Look direction: {props.look_direction}\")\n\n# Access additional custom properties\nif \"signal_strength\" in props.additional:\n    print(f\"Signal: {props.additional['signal_strength']}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.additional","title":"additional  <code>property</code>","text":"<pre><code>additional: AdditionalPropertiesDict\n</code></pre> <p>Get additional properties as a dict-like wrapper.</p> <p>Returns a dictionary-like object that automatically converts between Python types and internal PropertyValue representation.</p> <p>Supported Python types: - float -&gt; Scalar - list[float] -&gt; Vector - bool -&gt; Boolean - str -&gt; String - dict -&gt; Json</p> <p>Returns:</p> Name Type Description <code>AdditionalPropertiesDict</code> <code>AdditionalPropertiesDict</code> <p>Dict-like wrapper for additional properties</p> Example <pre><code># Dict-style assignment\nprops.additional[\"doppler_shift\"] = 2500.0\nprops.additional[\"snr_values\"] = [10.5, 12.3, 15.1]\nprops.additional[\"has_eclipse\"] = False\n\n# Dict-style access\nprint(props.additional[\"doppler_shift\"])  # 2500.0\n\n# Dict methods\nif \"doppler_shift\" in props.additional:\n    del props.additional[\"doppler_shift\"]\n\n# Iteration\nfor key in props.additional.keys():\n    print(key, props.additional[key])\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_alt","title":"center_alt  <code>property</code>","text":"<pre><code>center_alt: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_ecef","title":"center_ecef  <code>property</code>","text":"<pre><code>center_ecef: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_lat","title":"center_lat  <code>property</code>","text":"<pre><code>center_lat: float\n</code></pre> <p>Get location center latitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.center_lon","title":"center_lon  <code>property</code>","text":"<pre><code>center_lon: float\n</code></pre> <p>Get location center longitude (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_close","title":"elevation_close  <code>property</code>","text":"<pre><code>elevation_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_open","title":"elevation_open  <code>property</code>","text":"<pre><code>elevation_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: Any\n</code></pre>"},{"location":"library_api/attitude/index.html","title":"Attitude","text":"<p>Module: <code>brahe.attitude</code></p> <p>Classes for representing and converting between different attitude representations.</p>"},{"location":"library_api/attitude/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Quaternion - Quaternion representation</li> <li>Rotation Matrix - Direction Cosine Matrix (DCM) representation</li> <li>Euler Angles - Euler angle sequences</li> <li>Euler Axis - Euler axis-angle representation</li> </ul>"},{"location":"library_api/attitude/euler_angle_order.html","title":"EulerAngleOrder Enum","text":"<p>The <code>EulerAngleOrder</code> enumeration specifies the rotation sequence for Euler angle representations. There are 12 possible sequences: 6 symmetric sequences where the first and third rotations are about the same axis, and 6 asymmetric sequences where all rotations are about different axes.</p>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder","title":"EulerAngleOrder","text":"<pre><code>EulerAngleOrder()\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <code>Any</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <code>Any</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <code>Any</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <code>Any</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <code>Any</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <code>Any</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <code>Any</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <code>Any</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <code>Any</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <code>Any</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <code>Any</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <code>Any</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XYX","title":"XYX  <code>class-attribute</code>","text":"<pre><code>XYX: Any = EulerAngleOrder.XYX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XYZ","title":"XYZ  <code>class-attribute</code>","text":"<pre><code>XYZ: Any = EulerAngleOrder.XYZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XZX","title":"XZX  <code>class-attribute</code>","text":"<pre><code>XZX: Any = EulerAngleOrder.XZX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.XZY","title":"XZY  <code>class-attribute</code>","text":"<pre><code>XZY: Any = EulerAngleOrder.XZY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YXY","title":"YXY  <code>class-attribute</code>","text":"<pre><code>YXY: Any = EulerAngleOrder.YXY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YXZ","title":"YXZ  <code>class-attribute</code>","text":"<pre><code>YXZ: Any = EulerAngleOrder.YXZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YZX","title":"YZX  <code>class-attribute</code>","text":"<pre><code>YZX: Any = EulerAngleOrder.YZX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.YZY","title":"YZY  <code>class-attribute</code>","text":"<pre><code>YZY: Any = EulerAngleOrder.YZY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZXY","title":"ZXY  <code>class-attribute</code>","text":"<pre><code>ZXY: Any = EulerAngleOrder.ZXY\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZXZ","title":"ZXZ  <code>class-attribute</code>","text":"<pre><code>ZXZ: Any = EulerAngleOrder.ZXZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZYX","title":"ZYX  <code>class-attribute</code>","text":"<pre><code>ZYX: Any = EulerAngleOrder.ZYX\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angle_order.html#brahe._brahe.EulerAngleOrder.ZYZ","title":"ZYZ  <code>class-attribute</code>","text":"<pre><code>ZYZ: Any = EulerAngleOrder.ZYZ\n</code></pre> <p>Enumeration of Euler angle rotation sequences.</p> <p>Specifies the order of rotations for Euler angle representations. Each sequence represents three consecutive rotations about specified axes. There are 12 possible sequences: 6 symmetric (XYX, XZX, YXY, YZY, ZXZ, ZYZ) and 6 asymmetric (XYZ, XZY, YXZ, YZX, ZXY, ZYX).</p> <p>The sequence determines how Euler angles are applied: the first rotation is about the first axis, the second about the second axis, and the third about the third axis. For example, <code>XYZ</code> means rotate about X, then Y, then Z.</p> <p>Attributes:</p> Name Type Description <code>XYX</code> <p>X-Y-X sequence (symmetric). Numerical value: 121</p> <code>XYZ</code> <p>X-Y-Z sequence (Roll-Pitch-Yaw in aerospace). Numerical value: 123</p> <code>XZX</code> <p>X-Z-X sequence (symmetric). Numerical value: 131</p> <code>XZY</code> <p>X-Z-Y sequence. Numerical value: 132</p> <code>YXY</code> <p>Y-X-Y sequence (symmetric). Numerical value: 212</p> <code>YXZ</code> <p>Y-X-Z sequence. Numerical value: 213</p> <code>YZX</code> <p>Y-Z-X sequence. Numerical value: 231</p> <code>YZY</code> <p>Y-Z-Y sequence (symmetric). Numerical value: 232</p> <code>ZXY</code> <p>Z-X-Y sequence. Numerical value: 312</p> <code>ZXZ</code> <p>Z-X-Z sequence (symmetric). Numerical value: 313</p> <code>ZYX</code> <p>Z-Y-X sequence (Yaw-Pitch-Roll in aerospace). Numerical value: 321</p> <code>ZYZ</code> <p>Z-Y-Z sequence (classical Euler angles in physics). Numerical value: 323</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Euler angles using XYZ sequence (Roll-Pitch-Yaw)\neuler_rpy = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 10.0, 20.0, 30.0, bh.AngleFormat.DEGREES)\nprint(f\"Order: {euler_rpy.order}\")  # EulerAngleOrder.XYZ\n\n# Create Euler angles using ZYZ sequence (classical)\neuler_zyz = bh.EulerAngle(bh.EulerAngleOrder.ZYZ, 45.0, 60.0, 90.0, bh.AngleFormat.DEGREES)\n\n# Convert quaternion to Euler angles with specific sequence\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = bh.EulerAngle.from_quaternion(q, bh.EulerAngleOrder.ZYX)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html","title":"EulerAngle Class","text":"<p>The <code>EulerAngle</code> class represents attitude using Euler angle sequences for intuitive spacecraft orientation specification.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle","title":"EulerAngle","text":"<pre><code>EulerAngle(order: str, phi: float, theta: float, psi: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler angles.</p> <p>Euler angles describe rotations as a sequence of three rotations about specified axes. The rotation sequence is specified by the order parameter (e.g., \"XYZ\", \"ZYX\").</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")</p> required <code>phi</code> <code>float</code> <p>First rotation angle in radians or degrees</p> required <code>theta</code> <code>float</code> <p>Second rotation angle in radians or degrees</p> required <code>psi</code> <code>float</code> <p>Third rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\n\n# Create Euler angle rotation (roll, pitch, yaw in ZYX order)\ne = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n\n# Convert to rotation matrix\ndcm = e.to_rotation_matrix()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.order","title":"order  <code>property</code>","text":"<pre><code>order: EulerAngleOrder\n</code></pre> <p>Get the rotation sequence order.</p> <p>Returns:</p> Name Type Description <code>EulerAngleOrder</code> <code>EulerAngleOrder</code> <p>Rotation sequence enum value</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(bh.EulerAngleOrder.XYZ, 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Order: {e.order}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.phi","title":"phi  <code>property</code>","text":"<pre><code>phi: float\n</code></pre> <p>Get the first rotation angle (phi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Phi: {e.phi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.psi","title":"psi  <code>property</code>","text":"<pre><code>psi: float\n</code></pre> <p>Get the third rotation angle (psi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Third rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Psi: {e.psi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.theta","title":"theta  <code>property</code>","text":"<pre><code>theta: float\n</code></pre> <p>Get the second rotation angle (theta) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Theta: {e.theta}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from another Euler angle with different order.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Source Euler angles</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAngle.from_euler_angle(e1, \"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = bh.EulerAngle.from_euler_axis(ea, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAngle.from_quaternion(q, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAngle.from_rotation_matrix(r, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, order: str, angle_format: AngleFormat) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>3-element array [phi, theta, psi]</p> required <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>New Euler angle instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.1, 0.2, 0.3])\neuler = bh.EulerAngle.from_vector(v, \"XYZ\", bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angles with different rotation sequence.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_angle(\"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nea = e.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html","title":"EulerAxis Class","text":"<p>The <code>EulerAxis</code> class represents attitude using axis-angle representation (Euler's rotation theorem).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis","title":"EulerAxis","text":"<pre><code>EulerAxis(axis: ndarray, angle: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler axis-angle representation.</p> <p>The Euler axis-angle representation describes a rotation as a single rotation about a specified axis by a given angle. This is also known as the axis-angle or rotation vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>3-element unit vector specifying rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Rotation of 90 degrees about z-axis\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle} rad\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.angle","title":"angle  <code>property</code>","text":"<pre><code>angle: float\n</code></pre> <p>Get the rotation angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rotation angle in radians</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.axis","title":"axis  <code>property</code>","text":"<pre><code>axis: ndarray\n</code></pre> <p>Get the rotation axis as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3-element unit vector specifying rotation axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Axis: {e.axis}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne = bh.EulerAxis.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from another Euler axis (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Source Euler axis</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAxis.from_euler_axis(e1)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAxis.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAxis.from_rotation_matrix(r)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(x: float, y: float, z: float, angle: float, angle_format: AngleFormat) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from individual axis components and angle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X component of rotation axis</p> required <code>y</code> <code>float</code> <p>Y component of rotation axis</p> required <code>z</code> <code>float</code> <p>Z component of rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAxis.from_values(0.0, 0.0, 1.0, 1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, angle_format: AngleFormat, vector_first: bool) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing axis and angle</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, array is [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.0, 0.0, 1.0, 1.5708])\ne = bh.EulerAxis.from_vector(v, bh.AngleFormat.RADIANS, True)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = ea.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation (returns self).</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>This Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(angle_format: AngleFormat, vector_first: bool) -&gt; ndarray\n</code></pre> <p>Convert Euler axis to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Units for output angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, returns [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing axis and angle</p>"},{"location":"library_api/attitude/quaternion.html","title":"Quaternion Class","text":"<p>The <code>Quaternion</code> class provides a compact, singularity-free representation of 3D rotations for spacecraft attitude determination and control.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(w: float, x: float, y: float, z: float)\n</code></pre> <p>Represents a quaternion for 3D rotations.</p> <p>Quaternions provide a compact, singularity-free representation of rotations. The quaternion is stored as [w, x, y, z] where w is the scalar part and [x, y, z] is the vector part.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Scalar component</p> required <code>x</code> <code>float</code> <p>X component of vector part</p> required <code>y</code> <code>float</code> <p>Y component of vector part</p> required <code>z</code> <code>float</code> <p>Z component of vector part</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity quaternion\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nprint(f\"Norm: {q.norm()}\")\n\n# Create from array\nq_vec = np.array([1.0, 0.0, 0.0, 0.0])\nq2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\n\n# Convert to rotation matrix\ndcm = q.to_rotation_matrix()\n\n# Quaternion multiplication\nq3 = q * q2\n\n# Normalize\nq3.normalize()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the quaternion components as a numpy array [w, x, y, z].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.w","title":"w  <code>property</code>","text":"<pre><code>w: float\n</code></pre> <p>Get the scalar (w) component of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Scalar component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.x","title":"x  <code>property</code>","text":"<pre><code>x: float\n</code></pre> <p>Get the x component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>X component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.y","title":"y  <code>property</code>","text":"<pre><code>y: float\n</code></pre> <p>Get the y component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Y component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.z","title":"z  <code>property</code>","text":"<pre><code>z: float\n</code></pre> <p>Get the z component of the quaternion's vector part.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Z component</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.conjugate","title":"conjugate  <code>method descriptor</code>","text":"<pre><code>conjugate() -&gt; Quaternion\n</code></pre> <p>Compute the conjugate of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Conjugate quaternion with negated vector part</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_conj = q.conjugate()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from another quaternion (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion.from_quaternion(q1)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nrm = bh.RotationMatrix.from_matrix(mat)\nq = bh.Quaternion.from_rotation_matrix(rm)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, scalar_first: bool) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing quaternion components</p> required <code>scalar_first</code> <code>bool</code> <p>If True, array is [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([1.0, 0.0, 0.0, 0.0])\nq = bh.Quaternion.from_vector(v, scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.inverse","title":"inverse  <code>method descriptor</code>","text":"<pre><code>inverse() -&gt; Quaternion\n</code></pre> <p>Compute the inverse of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Inverse quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_inv = q.inverse()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.norm","title":"norm  <code>method descriptor</code>","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Calculate the norm (magnitude) of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean norm of the quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nnorm = q.norm()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.normalize","title":"normalize  <code>method descriptor</code>","text":"<pre><code>normalize() -&gt; Any\n</code></pre> <p>Normalize the quaternion in-place to unit length.</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(2.0, 0.0, 0.0, 0.0)\nq.normalize()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.slerp","title":"slerp  <code>method descriptor</code>","text":"<pre><code>slerp(other: Quaternion, t: float) -&gt; Quaternion\n</code></pre> <p>Perform spherical linear interpolation (SLERP) between two quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Quaternion</code> <p>Target quaternion</p> required <code>t</code> <code>float</code> <p>Interpolation parameter in [0, 1]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Interpolated quaternion</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion(0.707, 0.707, 0.0, 0.0)\nq_mid = q1.slerp(q2, 0.5)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = q.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation (returns self).</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>This quaternion</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(scalar_first: bool) -&gt; ndarray\n</code></pre> <p>Convert quaternion to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_first</code> <code>bool</code> <p>If True, returns [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nv = q.to_vector(scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html","title":"RotationMatrix Class","text":"<p>The <code>RotationMatrix</code> class represents attitude using Direction Cosine Matrices (DCM) for spacecraft orientation and coordinate transformations.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix","title":"RotationMatrix","text":"<pre><code>RotationMatrix(r11: float, r12: float, r13: float, r21: float, r22: float, r23: float, r31: float, r32: float, r33: float)\n</code></pre> <p>Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).</p> <p>A rotation matrix is an orthogonal 3x3 matrix with determinant +1 that represents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>r11</code> <code>float</code> <p>Element at row 1, column 1</p> required <code>r12</code> <code>float</code> <p>Element at row 1, column 2</p> required <code>r13</code> <code>float</code> <p>Element at row 1, column 3</p> required <code>r21</code> <code>float</code> <p>Element at row 2, column 1</p> required <code>r22</code> <code>float</code> <p>Element at row 2, column 2</p> required <code>r23</code> <code>float</code> <p>Element at row 2, column 3</p> required <code>r31</code> <code>float</code> <p>Element at row 3, column 1</p> required <code>r32</code> <code>float</code> <p>Element at row 3, column 2</p> required <code>r33</code> <code>float</code> <p>Element at row 3, column 3</p> required <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity rotation\ndcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n\n# Create from numpy array\nR = np.eye(3)\ndcm2 = bh.RotationMatrix.from_matrix(R)\n\n# Convert to quaternion\nq = dcm.to_quaternion()\n\n# Rotate a vector\nv = np.array([1.0, 0.0, 0.0])\nv_rot = dcm.rotate_vector(v)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r11","title":"r11  <code>property</code>","text":"<pre><code>r11: float\n</code></pre> <p>Get element (1,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r12","title":"r12  <code>property</code>","text":"<pre><code>r12: float\n</code></pre> <p>Get element (1,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r13","title":"r13  <code>property</code>","text":"<pre><code>r13: float\n</code></pre> <p>Get element (1,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 1, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r21","title":"r21  <code>property</code>","text":"<pre><code>r21: float\n</code></pre> <p>Get element (2,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r22","title":"r22  <code>property</code>","text":"<pre><code>r22: float\n</code></pre> <p>Get element (2,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r23","title":"r23  <code>property</code>","text":"<pre><code>r23: float\n</code></pre> <p>Get element (2,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 2, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r31","title":"r31  <code>property</code>","text":"<pre><code>r31: float\n</code></pre> <p>Get element (3,1) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 1</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r32","title":"r32  <code>property</code>","text":"<pre><code>r32: float\n</code></pre> <p>Get element (3,2) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 2</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.r33","title":"r33  <code>property</code>","text":"<pre><code>r33: float\n</code></pre> <p>Get element (3,3) of the rotation matrix.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Matrix element at row 3, column 3</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rx","title":"Rx  <code>builtin</code>","text":"<pre><code>Rx(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for X-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Ry","title":"Ry  <code>builtin</code>","text":"<pre><code>Ry(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Y-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rz","title":"Rz  <code>builtin</code>","text":"<pre><code>Rz(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Z-axis rotation</p> Example <pre><code>import brahe as bh\n\nr = bh.RotationMatrix.Rz(1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from an Euler axis.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_matrix","title":"from_matrix  <code>builtin</code>","text":"<pre><code>from_matrix(m: ndarray) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a 3x3 numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nr = bh.RotationMatrix.from_matrix(mat)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nr = bh.RotationMatrix.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from another rotation matrix (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Source rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = bh.RotationMatrix.from_rotation_matrix(r1)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\neuler = r.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = r.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert rotation matrix to a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\nq = r.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation (returns self).</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>This rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = r1.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/constants/index.html","title":"Constants","text":"<p>Mathematical, physical, and astronomical constants used throughout the brahe library.</p>"},{"location":"library_api/constants/index.html#categories","title":"Categories","text":""},{"location":"library_api/constants/index.html#units","title":"Units","text":"<p>Angle format enumerations and time system constants for specifying units and reference frames.</p>"},{"location":"library_api/constants/index.html#mathematical-constants","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/index.html#time-constants","title":"Time Constants","text":"<p>Julian date references and time system offset values.</p>"},{"location":"library_api/constants/index.html#physical-constants","title":"Physical Constants","text":"<p>Physical properties of Earth, celestial bodies, and universal constants.</p>"},{"location":"library_api/constants/index.html#quick-reference","title":"Quick Reference","text":"<p>All constants use SI base units unless otherwise noted:</p> <ul> <li>Distance: meters (m)</li> <li>Time: seconds (s)</li> <li>Angles: radians (rad)</li> <li>Gravitational Parameter: m\u00b3/s\u00b2</li> </ul> <p>Constants are accessible directly from the <code>brahe</code> module:</p> <pre><code>import brahe as bh\n\n# Mathematical constants\nangle_rad = 45.0 * bh.DEG2RAD  # Convert degrees to radians\n\n# Physical constants\nmu_earth = bh.GM_EARTH  # Earth's gravitational parameter\nc = bh.C_LIGHT          # Speed of light\n\n# Time system\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n</code></pre>"},{"location":"library_api/constants/math.html","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/math.html#angle-conversions","title":"Angle Conversions","text":""},{"location":"library_api/constants/math.html#deg2rad","title":"DEG2RAD","text":"<p>Value: <code>0.017453292519943295</code> rad/deg</p> <p>Converts degrees to radians. Equivalent to \u03c0/180.</p>"},{"location":"library_api/constants/math.html#brahe.DEG2RAD","title":"DEG2RAD  <code>module-attribute</code>","text":"<pre><code>DEG2RAD: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2deg","title":"RAD2DEG","text":"<p>Value: <code>57.29577951308232</code> deg/rad</p> <p>Converts radians to degrees. Equivalent to 180/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2DEG","title":"RAD2DEG  <code>module-attribute</code>","text":"<pre><code>RAD2DEG: float = 57.29577951308232\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#as2rad","title":"AS2RAD","text":"<p>Value: <code>4.84813681109536e-06</code> rad/arcsec</p> <p>Converts arc seconds to radians. Equivalent to \u03c0/(180 \u00d7 3600).</p>"},{"location":"library_api/constants/math.html#brahe.AS2RAD","title":"AS2RAD  <code>module-attribute</code>","text":"<pre><code>AS2RAD: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2as","title":"RAD2AS","text":"<p>Value: <code>206264.80624709636</code> arcsec/rad</p> <p>Converts radians to arc seconds. Equivalent to (180 \u00d7 3600)/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2AS","title":"RAD2AS  <code>module-attribute</code>","text":"<pre><code>RAD2AS: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html","title":"Physical Constants","text":"<p>Physical properties of celestial bodies and universal constants. All values use SI base units.</p>"},{"location":"library_api/constants/physical.html#universal-constants","title":"Universal Constants","text":""},{"location":"library_api/constants/physical.html#c_light","title":"C_LIGHT","text":"<p>Value: <code>299792458.0</code> m/s</p> <p>Speed of light in vacuum.</p>"},{"location":"library_api/constants/physical.html#brahe.C_LIGHT","title":"C_LIGHT  <code>module-attribute</code>","text":"<pre><code>C_LIGHT: float = 299792458.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#au","title":"AU","text":"<p>Value: <code>1.495978707e11</code> m</p> <p>Astronomical Unit - mean distance of Earth from the Sun. TDB-compatible value.</p>"},{"location":"library_api/constants/physical.html#brahe.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870700.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#p_sun","title":"P_SUN","text":"<p>Value: <code>4.56e-6</code> N/m\u00b2</p> <p>Solar radiation pressure at 1 AU.</p>"},{"location":"library_api/constants/physical.html#brahe.P_SUN","title":"P_SUN  <code>module-attribute</code>","text":"<pre><code>P_SUN: float = 4.56e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#earth-constants","title":"Earth Constants","text":""},{"location":"library_api/constants/physical.html#geometry","title":"Geometry","text":""},{"location":"library_api/constants/physical.html#r_earth","title":"R_EARTH","text":"<p>Value: <code>6378136.3</code> m</p> <p>Earth's equatorial radius (GGM05 gravity model).</p>"},{"location":"library_api/constants/physical.html#brahe.R_EARTH","title":"R_EARTH  <code>module-attribute</code>","text":"<pre><code>R_EARTH: float = 6378136.3\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_a","title":"WGS84_A","text":"<p>Value: <code>6378137.0</code> m</p> <p>Earth's semi-major axis as defined by WGS84 geodetic system.</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_A","title":"WGS84_A  <code>module-attribute</code>","text":"<pre><code>WGS84_A: float = 6378137.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_f","title":"WGS84_F","text":"<p>Value: <code>0.0033528106647474805</code> (dimensionless)</p> <p>Earth's ellipsoidal flattening. WGS84 value: 1/298.257223563</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_F","title":"WGS84_F  <code>module-attribute</code>","text":"<pre><code>WGS84_F: float = 0.0033528106647474805\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#ecc_earth","title":"ECC_EARTH","text":"<p>Value: <code>0.081819190842622</code> (dimensionless)</p> <p>Earth's first eccentricity (WGS84 value).</p>"},{"location":"library_api/constants/physical.html#brahe.ECC_EARTH","title":"ECC_EARTH  <code>module-attribute</code>","text":"<pre><code>ECC_EARTH: float = 0.081819190842622\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gravitational-properties","title":"Gravitational Properties","text":""},{"location":"library_api/constants/physical.html#gm_earth","title":"GM_EARTH","text":"<p>Value: <code>3.986004415e14</code> m\u00b3/s\u00b2</p> <p>Earth's gravitational parameter (\u03bc = G \u00d7 M).</p>"},{"location":"library_api/constants/physical.html#brahe.GM_EARTH","title":"GM_EARTH  <code>module-attribute</code>","text":"<pre><code>GM_EARTH: float = 398600441500000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#j2_earth","title":"J2_EARTH","text":"<p>Value: <code>0.0010826358191967</code> (dimensionless)</p> <p>Earth's J2 zonal harmonic coefficient (GGM05s gravity model). Represents Earth's oblateness.</p>"},{"location":"library_api/constants/physical.html#brahe.J2_EARTH","title":"J2_EARTH  <code>module-attribute</code>","text":"<pre><code>J2_EARTH: float = 0.0010826358191967\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#omega_earth","title":"OMEGA_EARTH","text":"<p>Value: <code>7.292115146706979e-05</code> rad/s</p> <p>Earth's axial rotation rate.</p>"},{"location":"library_api/constants/physical.html#brahe.OMEGA_EARTH","title":"OMEGA_EARTH  <code>module-attribute</code>","text":"<pre><code>OMEGA_EARTH: float = 7.292115146706979e-05\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#celestial-body-gravitational-parameters","title":"Celestial Body Gravitational Parameters","text":"<p>Gravitational parameters (\u03bc = G \u00d7 M) for major solar system bodies in m\u00b3/s\u00b2.</p>"},{"location":"library_api/constants/physical.html#sun","title":"Sun","text":""},{"location":"library_api/constants/physical.html#gm_sun","title":"GM_SUN","text":"<p>Value: <code>1.32712440041939e20</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SUN","title":"GM_SUN  <code>module-attribute</code>","text":"<pre><code>GM_SUN: float = 1.327124400419394e+20\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_sun","title":"R_SUN","text":"<p>Value: <code>6.9634e8</code> m</p> <p>Solar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_SUN","title":"R_SUN  <code>module-attribute</code>","text":"<pre><code>R_SUN: float = 695700000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#moon","title":"Moon","text":""},{"location":"library_api/constants/physical.html#gm_moon","title":"GM_MOON","text":"<p>Value: <code>4.9028e12</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MOON","title":"GM_MOON  <code>module-attribute</code>","text":"<pre><code>GM_MOON: float = 4902800066000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_moon","title":"R_MOON","text":"<p>Value: <code>1.738e6</code> m</p> <p>Lunar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_MOON","title":"R_MOON  <code>module-attribute</code>","text":"<pre><code>R_MOON: float = 1738000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#inner-planets","title":"Inner Planets","text":""},{"location":"library_api/constants/physical.html#gm_mercury","title":"GM_MERCURY","text":"<p>Value: <code>2.2031868551e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MERCURY","title":"GM_MERCURY  <code>module-attribute</code>","text":"<pre><code>GM_MERCURY: float = 22031780000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_venus","title":"GM_VENUS","text":"<p>Value: <code>3.257e14</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_VENUS","title":"GM_VENUS  <code>module-attribute</code>","text":"<pre><code>GM_VENUS: float = 324858592000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_mars","title":"GM_MARS","text":"<p>Value: <code>4.305e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MARS","title":"GM_MARS  <code>module-attribute</code>","text":"<pre><code>GM_MARS: float = 42828375210000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#outer-planets","title":"Outer Planets","text":""},{"location":"library_api/constants/physical.html#gm_jupiter","title":"GM_JUPITER","text":"<p>Value: <code>1.268e17</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_JUPITER","title":"GM_JUPITER  <code>module-attribute</code>","text":"<pre><code>GM_JUPITER: float = 1.267127648e+17\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_saturn","title":"GM_SATURN","text":"<p>Value: <code>3.794e16</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SATURN","title":"GM_SATURN  <code>module-attribute</code>","text":"<pre><code>GM_SATURN: float = 3.79405852e+16\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_uranus","title":"GM_URANUS","text":"<p>Value: <code>5.794e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_URANUS","title":"GM_URANUS  <code>module-attribute</code>","text":"<pre><code>GM_URANUS: float = 5794548600000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_neptune","title":"GM_NEPTUNE","text":"<p>Value: <code>6.837e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_NEPTUNE","title":"GM_NEPTUNE  <code>module-attribute</code>","text":"<pre><code>GM_NEPTUNE: float = 6836527100580000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#dwarf-planets","title":"Dwarf Planets","text":""},{"location":"library_api/constants/physical.html#gm_pluto","title":"GM_PLUTO","text":"<p>Value: <code>9.77e11</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_PLUTO","title":"GM_PLUTO  <code>module-attribute</code>","text":"<pre><code>GM_PLUTO: float = 977000000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html","title":"Time Constants","text":"<p>Constants related to time systems, epochs, and time conversions.</p>"},{"location":"library_api/constants/time.html#julian-date-references","title":"Julian Date References","text":""},{"location":"library_api/constants/time.html#mjd_zero","title":"MJD_ZERO","text":"<p>Value: <code>2400000.5</code> days</p> <p>Offset of Modified Julian Date (MJD) with respect to Julian Date (JD). For any time t: <pre><code>MJD_ZERO = JD - MJD\n</code></pre></p>"},{"location":"library_api/constants/time.html#brahe.MJD_ZERO","title":"MJD_ZERO  <code>module-attribute</code>","text":"<pre><code>MJD_ZERO: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#mjd2000","title":"MJD2000","text":"<p>Value: <code>51544.5</code> days</p> <p>Modified Julian Date of January 1, 2000 12:00:00 (J2000.0 epoch). Value is independent of time system.</p>"},{"location":"library_api/constants/time.html#brahe.MJD2000","title":"MJD2000  <code>module-attribute</code>","text":"<pre><code>MJD2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps_zero","title":"GPS_ZERO","text":"<p>Value: <code>44244.0</code> days</p> <p>Modified Julian Date of the start of GPS time (January 6, 1980 00:00:00 UTC).</p>"},{"location":"library_api/constants/time.html#brahe.GPS_ZERO","title":"GPS_ZERO  <code>module-attribute</code>","text":"<pre><code>GPS_ZERO: float = 44244.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#time-system-offsets","title":"Time System Offsets","text":"<p>All offset values are in seconds.</p>"},{"location":"library_api/constants/time.html#gps-tai","title":"GPS \u2194 TAI","text":""},{"location":"library_api/constants/time.html#gps_tai","title":"GPS_TAI","text":"<p>Value: <code>-19.0</code> seconds</p> <p>Offset of GPS time with respect to TAI: <code>GPS = TAI + GPS_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TAI","title":"GPS_TAI  <code>module-attribute</code>","text":"<pre><code>GPS_TAI: float = -19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_gps","title":"TAI_GPS","text":"<p>Value: <code>19.0</code> seconds</p> <p>Offset of TAI time with respect to GPS: <code>TAI = GPS + TAI_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_GPS","title":"TAI_GPS  <code>module-attribute</code>","text":"<pre><code>TAI_GPS: float = 19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt-tai","title":"TT \u2194 TAI","text":""},{"location":"library_api/constants/time.html#tt_tai","title":"TT_TAI","text":"<p>Value: <code>32.184</code> seconds</p> <p>Offset of Terrestrial Time with respect to TAI: <code>TT = TAI + TT_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_TAI","title":"TT_TAI  <code>module-attribute</code>","text":"<pre><code>TT_TAI: float = 32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_tt","title":"TAI_TT","text":"<p>Value: <code>-32.184</code> seconds</p> <p>Offset of TAI with respect to Terrestrial Time: <code>TAI = TT + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_TT","title":"TAI_TT  <code>module-attribute</code>","text":"<pre><code>TAI_TT: float = -32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps-tt","title":"GPS \u2194 TT","text":""},{"location":"library_api/constants/time.html#gps_tt","title":"GPS_TT","text":"<p>Value: <code>13.184</code> seconds</p> <p>Offset of GPS time with respect to TT: <code>GPS = TT + GPS_TT</code></p> <p>Computed as: <code>GPS_TAI + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TT","title":"GPS_TT  <code>module-attribute</code>","text":"<pre><code>GPS_TT: float = -51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt_gps","title":"TT_GPS","text":"<p>Value: <code>-13.184</code> seconds</p> <p>Offset of TT with respect to GPS time: <code>TT = GPS + TT_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_GPS","title":"TT_GPS  <code>module-attribute</code>","text":"<pre><code>TT_GPS: float = 51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/units.html","title":"Units","text":"<p>Enumerations for specifying angle formats and time systems.</p>"},{"location":"library_api/constants/units.html#angle-format","title":"Angle Format","text":"<p>The <code>AngleFormat</code> enumeration specifies whether angles are in radians or degrees.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create rotation with angle in degrees\nq = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=90.0,\n    angle_format=bh.AngleFormat.DEGREES\n)\n\n# Create rotation with angle in radians\nq2 = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=np.pi/2,\n    angle_format=bh.AngleFormat.RADIANS\n)\n</code></pre>"},{"location":"library_api/constants/units.html#time-system","title":"Time System","text":"<p>The <code>TimeSystem</code> enumeration specifies the time reference system for epochs.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem","title":"TimeSystem","text":"<pre><code>TimeSystem()\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UTC","title":"UTC  <code>class-attribute</code>","text":"<pre><code>UTC: Any = TimeSystem.UTC\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TAI","title":"TAI  <code>class-attribute</code>","text":"<pre><code>TAI: Any = TimeSystem.TAI\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TT","title":"TT  <code>class-attribute</code>","text":"<pre><code>TT: Any = TimeSystem.TT\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.GPS","title":"GPS  <code>class-attribute</code>","text":"<pre><code>GPS: Any = TimeSystem.GPS\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UT1","title":"UT1  <code>class-attribute</code>","text":"<pre><code>UT1: Any = TimeSystem.UT1\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#time-system-descriptions","title":"Time System Descriptions","text":"<ul> <li>UTC (Coordinated Universal Time): Civil time standard used worldwide. Includes leap seconds to keep within 0.9 seconds of UT1.</li> <li>TAI (International Atomic Time): Continuous time scale based on atomic clocks. Currently 37 seconds ahead of UTC (as of 2024).</li> <li>TT (Terrestrial Time): Theoretical time scale for solar system calculations. TT = TAI + 32.184 seconds.</li> <li>GPS (Global Positioning System): Continuous time starting from GPS epoch (January 6, 1980). Does not include leap seconds.</li> <li>UT1 (Universal Time 1): Based on Earth's rotation. Computed from UTC using Earth Orientation Parameters (EOP).</li> </ul>"},{"location":"library_api/constants/units.html#usage-example_1","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Create epoch in different time systems\nutc_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ntai_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.TAI)\ngps_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\n\n# Time system is preserved in the epoch\nprint(utc_epoch.time_system)  # Output: UTC\nprint(tai_epoch.time_system)  # Output: TAI\n</code></pre>"},{"location":"library_api/coordinates/index.html","title":"Coordinates","text":"<p>Module: <code>brahe.coordinates</code></p> <p>Comprehensive coordinate system transformations for satellite dynamics.</p>"},{"location":"library_api/coordinates/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Enumerations - Coordinate type enumerations (EllipsoidalConversionType, AngleFormat)</li> <li>Cartesian Coordinates - Cartesian state vectors and orbital element conversions</li> <li>Geodetic &amp; Geocentric - WGS84 geodetic and geocentric coordinate conversions</li> <li>Topocentric Coordinates - Local topocentric frames (ENZ, SEZ, AzElRange)</li> </ul>"},{"location":"library_api/coordinates/cartesian.html","title":"Cartesian Coordinates","text":"<p>Functions for working with Cartesian state vectors and conversions.</p>"},{"location":"library_api/coordinates/cartesian.html#state-conversions","title":"State Conversions","text":""},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_koe_to_eci","title":"state_koe_to_eci  <code>builtin</code>","text":"<pre><code>state_koe_to_eci(x_oe: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert osculating orbital elements to Cartesian state.</p> <p>Transforms a state vector from osculating Keplerian orbital elements to Cartesian position and velocity coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_oe</code> <code>ndarray or list</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Orbital elements for a circular orbit\noe = np.array([7000000.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\nx_cart = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprint(f\"Cartesian state: {x_cart}\")\n</code></pre>"},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_eci_to_koe","title":"state_eci_to_koe  <code>builtin</code>","text":"<pre><code>state_eci_to_koe(x_cart: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert Cartesian state to osculating orbital elements.</p> <p>Transforms a state vector from Cartesian position and velocity coordinates to osculating Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>x_cart</code> <code>ndarray or list</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Cartesian state vector\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])  # [x, y, z, vx, vy, vz]\noe = bh.state_eci_to_koe(x_cart, bh.AngleFormat.RADIANS)\nprint(f\"Orbital elements: a={oe[0]:.0f}m, e={oe[1]:.6f}, i={oe[2]:.6f} rad\")\n</code></pre>"},{"location":"library_api/coordinates/enums.html","title":"Coordinate Enumerations","text":"<p>Enumerations for specifying coordinate transformation types.</p>"},{"location":"library_api/coordinates/enums.html#ellipsoidalconversiontype","title":"EllipsoidalConversionType","text":"<p>Specifies the type of ellipsoidal conversion used in topocentric coordinate transformations.</p> <p>Values: - <code>GEOCENTRIC</code> - Uses geocentric latitude where the angle is measured from the center of the Earth - <code>GEODETIC</code> - Uses geodetic latitude where the angle is measured perpendicular to the WGS84 ellipsoid</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType","title":"EllipsoidalConversionType","text":"<pre><code>EllipsoidalConversionType()\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEOCENTRIC","title":"GEOCENTRIC  <code>class-attribute</code>","text":"<pre><code>GEOCENTRIC: Any = EllipsoidalConversionType.Geocentric\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEODETIC","title":"GEODETIC  <code>class-attribute</code>","text":"<pre><code>GEODETIC: Any = EllipsoidalConversionType.Geodetic\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#angleformat","title":"AngleFormat","text":"<p>Specifies whether angles are in radians or degrees.</p> <p>Values: - <code>RADIANS</code> - Angles are in radians - <code>DEGREES</code> - Angles are in degrees</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates</li> <li>Geodetic &amp; Geocentric</li> </ul>"},{"location":"library_api/coordinates/geodetic.html","title":"Geodetic and Geocentric Coordinates","text":"<p>Functions for converting between geodetic, geocentric, and ECEF coordinates.</p>"},{"location":"library_api/coordinates/geodetic.html#geodetic-conversions","title":"Geodetic Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geodetic_to_ecef","title":"position_geodetic_to_ecef  <code>builtin</code>","text":"<pre><code>position_geodetic_to_ecef(x_geod: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert geodetic position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geodetic coordinates (longitude, latitude, altitude) using the <code>WGS84</code> ellipsoid model to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geod</code> <code>ndarray or list</code> <p>Geodetic position <code>[longitude, latitude, altitude]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: <code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (GPS-like) to ECEF\nlon, lat, alt = -105.0, 40.0, 1655.0  # Boulder, CO (degrees, meters)\nx_geod = np.array([lon, lat, alt])\nx_ecef = bh.position_geodetic_to_ecef(x_geod, bh.AngleFormat.DEGREES)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geodetic","title":"position_ecef_to_geodetic  <code>builtin</code>","text":"<pre><code>position_ecef_to_geodetic(x_ecef: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geodetic coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geodetic coordinates (longitude, latitude, altitude) using the <code>WGS84</code> ellipsoid model.</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray or list</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Geodetic position <code>[longitude, latitude, altitude]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geodetic coordinates (GPS-like)\nx_ecef = np.array([-1275936.0, -4797210.0, 4020109.0])  # Example location\nx_geod = bh.position_ecef_to_geodetic(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geodetic: lon={x_geod[0]:.4f}\u00b0, lat={x_geod[1]:.4f}\u00b0, alt={x_geod[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#geocentric-conversions","title":"Geocentric Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geocentric_to_ecef","title":"position_geocentric_to_ecef  <code>builtin</code>","text":"<pre><code>position_geocentric_to_ecef(x_geoc: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert geocentric position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geocentric spherical coordinates (longitude, latitude, radius) to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geoc</code> <code>ndarray or list</code> <p>Geocentric position <code>[longitude, latitude, radius]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and radius is in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: <code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geocentric coordinates to ECEF\nlon, lat, r = 0.0, 0.0, 6378137.0  # Equator, prime meridian, Earth's radius\nx_geoc = np.array([lon, lat, r])\nx_ecef = bh.position_geocentric_to_ecef(x_geoc, bh.AngleFormat.RADIANS)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geocentric","title":"position_ecef_to_geocentric  <code>builtin</code>","text":"<pre><code>position_ecef_to_geocentric(x_ecef: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geocentric coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geocentric spherical coordinates (longitude, latitude, radius).</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray or list</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Geocentric position <code>[longitude, latitude, radius]</code> where longitude is in radians or degrees, latitude is in radians or degrees, and radius is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geocentric coordinates\nx_ecef = np.array([6378137.0, 0.0, 0.0])  # Point on equator, prime meridian\nx_geoc = bh.position_ecef_to_geocentric(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geocentric: lon={x_geoc[0]:.2f}\u00b0, lat={x_geoc[1]:.2f}\u00b0, r={x_geoc[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html","title":"Topocentric Coordinates","text":"<p>Functions for working with local topocentric coordinate frames including East-North-Up (ENZ), South-East-Zenith (SEZ), and Azimuth-Elevation-Range.</p>"},{"location":"library_api/coordinates/topocentric.html#enz-east-north-up-frame","title":"ENZ (East-North-Up) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_enz","title":"rotation_ellipsoid_to_enz  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_enz(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to East-North-Up (<code>ENZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from ellipsoidal frame to <code>ENZ</code> frame.</p>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_enz_to_ellipsoid","title":"rotation_enz_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_enz_to_ellipsoid(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from East-North-Up (<code>ENZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local East-North-Up (<code>ENZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from <code>ENZ</code> frame to ellipsoidal frame.</p>"},{"location":"library_api/coordinates/topocentric.html#position-conversions","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_enz","title":"relative_position_ecef_to_enz  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_enz(location_ecef: Union[ndarray, List], r_ecef: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from <code>ECEF</code> to East-North-Up (<code>ENZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nenz = bh.relative_position_ecef_to_enz(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"ENZ: East={enz[0]/1000:.1f}km, North={enz[1]/1000:.1f}km, Up={enz[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_enz_to_ecef","title":"relative_position_enz_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_enz_to_ecef(location_ecef: Union[ndarray, List], r_enz: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from East-North-Up (<code>ENZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local East-North-Up (<code>ENZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_enz</code> <code>ndarray or list</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nenz_offset = np.array([50000.0, 30000.0, 100000.0])  # 50km east, 30km north, 100km up\ntarget_ecef = bh.relative_position_enz_to_ecef(station_ecef, enz_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_enz_to_azel","title":"position_enz_to_azel  <code>builtin</code>","text":"<pre><code>position_enz_to_azel(x_enz: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert position from East-North-Up (<code>ENZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local East-North-Up (<code>ENZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_enz</code> <code>ndarray or list</code> <p>Position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ to azimuth-elevation for satellite tracking\nenz = np.array([50000.0, 100000.0, 200000.0])  # East, North, Up (meters)\nazel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#sez-south-east-zenith-frame","title":"SEZ (South-East-Zenith) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices_1","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_sez","title":"rotation_ellipsoid_to_sez  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_sez(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from ellipsoidal frame to <code>SEZ</code> frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix for ground station in SEZ frame\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_sez = bh.rotation_ellipsoid_to_sez(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_sez.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_sez_to_ellipsoid","title":"rotation_sez_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_sez_to_ellipsoid(x_ellipsoid: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute rotation matrix from South-East-Zenith (<code>SEZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray or list</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix from <code>SEZ</code> frame to ellipsoidal frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get inverse rotation matrix from SEZ to ellipsoidal\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_ellipsoid = bh.rotation_sez_to_ellipsoid(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_ellipsoid.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#position-conversions_1","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_sez","title":"relative_position_ecef_to_sez  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_sez(location_ecef: Union[ndarray, List], r_ecef: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from <code>ECEF</code> to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nsez = bh.relative_position_ecef_to_sez(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"SEZ: South={sez[0]/1000:.1f}km, East={sez[1]/1000:.1f}km, Zenith={sez[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_sez_to_ecef","title":"relative_position_sez_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_sez_to_ecef(location_ecef: Union[ndarray, List], x_sez: Union[ndarray, List], conversion_type: EllipsoidalConversionType) -&gt; ndarray\n</code></pre> <p>Convert relative position from South-East-Zenith (<code>SEZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray or list</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>x_sez</code> <code>ndarray or list</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsez_offset = np.array([30000.0, 50000.0, 100000.0])  # 30km south, 50km east, 100km up\ntarget_ecef = bh.relative_position_sez_to_ecef(station_ecef, sez_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_sez_to_azel","title":"position_sez_to_azel  <code>builtin</code>","text":"<pre><code>position_sez_to_azel(x_sez: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert position from South-East-Zenith (<code>SEZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_sez</code> <code>ndarray or list</code> <p>Position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ to azimuth-elevation for satellite tracking\nsez = np.array([30000.0, 50000.0, 100000.0])  # South, East, Zenith (meters)\nazel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/datasets/index.html","title":"Datasets Module","text":"<p>The datasets module provides convenient access to satellite ephemeris data and groundstation locations from multiple sources. It handles downloading, parsing, and format conversion automatically.</p>"},{"location":"library_api/datasets/index.html#module-overview","title":"Module Overview","text":"<p>The module is organized by data source, with each source providing a consistent API:</p> <ul> <li><code>brahe.datasets.celestrak</code>: CelesTrak satellite ephemeris data</li> <li><code>brahe.datasets.groundstations</code>: Curated groundstation location datasets</li> <li><code>brahe.datasets.naif</code>: NASA JPL NAIF planetary ephemeris kernels</li> </ul>"},{"location":"library_api/datasets/index.html#submodules","title":"Submodules","text":"<ul> <li>CelesTrak Functions - Satellite ephemeris from CelesTrak</li> <li>Groundstation Functions - Groundstation location datasets</li> <li>NAIF Functions - Planetary ephemeris kernels from NASA JPL</li> </ul>"},{"location":"library_api/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets module</li> <li>CelesTrak Details - CelesTrak data source specifics</li> </ul>"},{"location":"library_api/datasets/celestrak.html","title":"CelesTrak Functions","text":"<p>Functions for accessing satellite ephemeris data from CelesTrak.</p> <p>All functions are available via <code>brahe.datasets.celestrak.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/celestrak.html#download_tles","title":"download_tles","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_download_tles","title":"celestrak_download_tles  <code>builtin</code>","text":"<pre><code>celestrak_download_tles(group: str, filepath: str, content_format: str, file_format: str) -&gt; Any\n</code></pre> <p>Download satellite ephemeris from CelesTrak and save to file</p> <p>Downloads 3LE data from CelesTrak and serializes to the specified file format. The file can contain either 2-line elements (TLE, without names) or 3-line elements (3LE, with satellite names), and can be saved as plain text, CSV, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>filepath</code> <code>str</code> <p>Output file path. Parent directories will be created if needed.</p> required <code>content_format</code> <code>str</code> <p>Content format - \"tle\" (2-line without names) or \"3le\" (3-line with names).</p> required <code>file_format</code> <code>str</code> <p>File format - \"txt\" (plain text), \"csv\" (comma-separated), or \"json\" (JSON array).</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, format is invalid, or file cannot be written.</p> Example <pre><code>import brahe as bh\n\n# Download GNSS satellites as 3LE in JSON format\nbh.datasets.celestrak.download_tles(\"gnss\", \"gnss_sats.json\", \"3le\", \"json\")\n\n# Download active satellites as 2LE in plain text\nbh.datasets.celestrak.download_tles(\"active\", \"active.txt\", \"tle\", \"txt\")\n\n# Download stations as 3LE in CSV format\nbh.datasets.celestrak.download_tles(\"stations\", \"stations.csv\", \"3le\", \"csv\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_id","title":"get_tle_by_id","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_id","title":"celestrak_get_tle_by_id  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_id(norad_id: int, group: str = None) -&gt; tuple[str, str, str]\n</code></pre> <p>Get TLE data for a specific satellite by NORAD catalog number</p> <p>Downloads 3LE data from CelesTrak for a single satellite identified by its NORAD catalog number. Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>NORAD catalog number (1-9 digits).</p> required <code>group</code> <code>str</code> <p>Satellite group for fallback search if direct ID lookup fails. Available groups can be found at https://celestrak.org/NORAD/elements/</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple[str, str, str]: Tuple of (name, line1, line2) containing satellite name and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or satellite not found.</p> Example <pre><code>import brahe as bh\n\n# Get ISS TLE by NORAD ID (25544)\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_id(25544)\nprint(f\"Satellite: {name}\")\nprint(f\"Line 1: {line1}\")\nprint(f\"Line 2: {line2}\")\n\n# With group fallback\ntle = bh.datasets.celestrak.get_tle_by_id(25544, group=\"stations\")\n</code></pre> Note <p>You can find which group contains a specific NORAD ID at: https://celestrak.org/NORAD/elements/master-gp-index.php</p> <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_id_as_propagator","title":"get_tle_by_id_as_propagator","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_id_as_propagator","title":"celestrak_get_tle_by_id_as_propagator  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_id_as_propagator(norad_id: int, step_size: float, group: str = None) -&gt; SGPPropagator\n</code></pre> <p>Get TLE data for a specific satellite as an SGP propagator</p> <p>Downloads TLE data from CelesTrak for a single satellite and creates an SGP4/SDP4 propagator. Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>NORAD catalog number (1-9 digits).</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagator in seconds.</p> required <code>group</code> <code>str</code> <p>Satellite group for fallback search if direct ID lookup fails.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Configured SGP propagator (PySGPPropagator) ready to use.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, satellite not found, or TLE is invalid.</p> Example <pre><code>import brahe as bh\n\n# Get ISS as propagator with 60-second step size\npropagator = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n\n# Propagate to current epoch\nepoch = bh.Epoch.now()\nstate = propagator.propagate(epoch)\nprint(f\"ISS position: {state[:3]}\")\n\n# With group fallback\nprop = bh.datasets.celestrak.get_tle_by_id_as_propagator(\n    25544, 60.0, group=\"stations\"\n)\n</code></pre> Note <p>You can find which group contains a specific NORAD ID at: https://celestrak.org/NORAD/elements/master-gp-index.php</p> <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_name","title":"get_tle_by_name","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_name","title":"celestrak_get_tle_by_name  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_name(name: str, group: str = None) -&gt; tuple[str, str, str]\n</code></pre> <p>Get TLE data for a specific satellite by name</p> <p>Searches for a satellite by name using a cascading search strategy: 1. If a group is provided, search within that group first 2. Fall back to searching the \"active\" group 3. Fall back to using CelesTrak's NAME API</p> <p>Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (case-insensitive, partial matches supported).</p> required <code>group</code> <code>str</code> <p>Satellite group to search first. Available groups can be found at https://celestrak.org/NORAD/elements/</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple[str, str, str]: Tuple of (name, line1, line2) containing satellite name and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or satellite not found.</p> Example <pre><code>import brahe as bh\n\n# Search for ISS with group hint\nname, line1, line2 = bh.datasets.celestrak.get_tle_by_name(\"ISS\", group=\"stations\")\nprint(f\"Found: {name}\")\n\n# Search without group (uses cascading search)\ntle = bh.datasets.celestrak.get_tle_by_name(\"STARLINK-1234\")\n</code></pre> Note <ul> <li>Name matching is case-insensitive</li> <li>Partial names are supported (e.g., \"ISS\" will match \"ISS (ZARYA)\")</li> <li>If multiple satellites match, returns the first match</li> <li>Search order: specified group \u2192 \"active\" \u2192 NAME API</li> <li>Data is cached for 6 hours to reduce server load</li> </ul>"},{"location":"library_api/datasets/celestrak.html#get_tle_by_name_as_propagator","title":"get_tle_by_name_as_propagator","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tle_by_name_as_propagator","title":"celestrak_get_tle_by_name_as_propagator  <code>builtin</code>","text":"<pre><code>celestrak_get_tle_by_name_as_propagator(name: str, step_size: float, group: str = None) -&gt; SGPPropagator\n</code></pre> <p>Get TLE data for a specific satellite by name as an SGP propagator</p> <p>Searches for a satellite by name and creates an SGP4/SDP4 propagator. Uses cascading search strategy (specified group \u2192 active \u2192 NAME API). Uses cached data if available and less than 6 hours old.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (case-insensitive, partial matches supported).</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagator in seconds.</p> required <code>group</code> <code>str</code> <p>Satellite group to search first.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Configured SGP propagator (PySGPPropagator) ready to use.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, satellite not found, or TLE is invalid.</p> Example <pre><code>import brahe as bh\n\n# Get ISS as propagator with 60-second step size\npropagator = bh.datasets.celestrak.get_tle_by_name_as_propagator(\"ISS\", 60.0, group=\"stations\")\n\n# Propagate to current epoch\nepoch = bh.Epoch.now()\nstate = propagator.propagate(epoch)\nprint(f\"Position: {state[:3]}\")\n</code></pre> Note <p>Data is cached for 6 hours to reduce server load and improve performance.</p>"},{"location":"library_api/datasets/celestrak.html#get_tles","title":"get_tles","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tles","title":"celestrak_get_tles  <code>builtin</code>","text":"<pre><code>celestrak_get_tles(group: str) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Get satellite ephemeris data from CelesTrak</p> <p>Downloads and parses 3LE (three-line element) data for the specified satellite group from CelesTrak (https://celestrak.org).</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\"). See https://celestrak.org/NORAD/elements/ for available groups.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>list[tuple[str, str, str]]: List of (name, line1, line2) tuples containing satellite names and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or data cannot be parsed.</p> Example <pre><code>import brahe as bh\n\n# Download ephemeris for ground stations\nephemeris = bh.datasets.celestrak.get_tles(\"stations\")\n\n# Print first 5 satellites\nfor name, line1, line2 in ephemeris[:5]:\n    print(f\"Satellite: {name}\")\n    print(f\"  Line 1: {line1[:20]}...\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_tles_as_propagators","title":"get_tles_as_propagators","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_tles_as_propagators","title":"celestrak_get_tles_as_propagators  <code>builtin</code>","text":"<pre><code>celestrak_get_tles_as_propagators(group: str, step_size: float) -&gt; list[SGPPropagator]\n</code></pre> <p>Get satellite ephemeris as SGP propagators from CelesTrak</p> <p>Downloads and parses 3LE data from CelesTrak, then creates SGP4/SDP4 propagators for each satellite. This is a convenient way to get ready-to-use propagators.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagators in seconds.</p> required <p>Returns:</p> Type Description <code>list[SGPPropagator]</code> <p>list[SGPPropagator]: List of configured SGP propagators (PySGPPropagator), one per satellite.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or no valid propagators can be created.</p> Note <p>Satellites with invalid TLE data will be skipped with a warning printed to stderr. The function will only raise an error if NO valid propagators can be created.</p> Example <pre><code>import brahe as bh\n\n# Get propagators for GNSS satellites with 60-second step size\npropagators = bh.datasets.celestrak.get_tles_as_propagators(\"gnss\", 60.0)\nprint(f\"Loaded {len(propagators)} GNSS satellites\")\n\n# Propagate first satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0, tsys=\"UTC\")\nstate = propagators[0].propagate(epoch)\n</code></pre>"},{"location":"library_api/datasets/groundstations.html","title":"Groundstation Functions","text":"<p>Functions for accessing curated groundstation location datasets.</p> <p>All functions are available via <code>brahe.datasets.groundstations.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/groundstations.html#load","title":"load","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load","title":"groundstations_load  <code>builtin</code>","text":"<pre><code>groundstations_load(provider: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstation locations for a specific provider</p> <p>Loads groundstation locations from embedded data. The data is compiled into the binary and does not require external files or internet connection.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name (case-insensitive). Available providers: - \"atlas\": Atlas Space Operations - \"aws\": Amazon Web Services Ground Station - \"ksat\": Kongsberg Satellite Services - \"leaf\": Leaf Space - \"ssc\": Swedish Space Corporation - \"viasat\": Viasat</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects with properties: - name: Groundstation name - provider: Provider name - frequency_bands: List of supported frequency bands</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If provider is unknown or data cannot be loaded.</p> Example <pre><code>import brahe as bh\n\n# Load KSAT groundstations\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\n\nfor station in ksat_stations:\n    print(f\"{station.name}: ({station.lon():.2f}, {station.lat():.2f})\")\n\n# Check properties\nprops = ksat_stations[0].properties()\nprint(f\"Frequency bands: {props['frequency_bands']}\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_from_file","title":"load_from_file","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_from_file","title":"groundstations_load_from_file  <code>builtin</code>","text":"<pre><code>groundstations_load_from_file(filepath: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstations from a custom GeoJSON file</p> <p>Loads groundstation locations from a user-provided GeoJSON file. The file must be a FeatureCollection with Point geometries.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to GeoJSON file.</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file cannot be read or parsed.</p> Example <pre><code>import brahe as bh\n\n# Load custom groundstations\nstations = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_all","title":"load_all","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_all","title":"groundstations_load_all  <code>builtin</code>","text":"<pre><code>groundstations_load_all() -&gt; list[PointLocation]\n</code></pre> <p>Load all groundstations from all providers</p> <p>Convenience function to load groundstations from all available providers.</p> <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: Combined list of all groundstations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no groundstations can be loaded.</p> Example <pre><code>import brahe as bh\n\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Loaded {len(all_stations)} total groundstations\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#list_providers","title":"list_providers","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_list_providers","title":"groundstations_list_providers  <code>builtin</code>","text":"<pre><code>groundstations_list_providers() -&gt; list[str]\n</code></pre> <p>Get list of available groundstation providers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of provider names that can be used with load().</p> Example <pre><code>import brahe as bh\n\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"Available: {', '.join(providers)}\")\n</code></pre>"},{"location":"library_api/datasets/naif.html","title":"NAIF Functions","text":"<p>Functions for downloading planetary ephemeris kernels from NASA JPL's NAIF archive.</p> <p>All functions are available via <code>brahe.datasets.naif.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/naif.html#download_de_kernel","title":"download_de_kernel","text":""},{"location":"library_api/datasets/naif.html#brahe._brahe.naif_download_de_kernel","title":"naif_download_de_kernel  <code>builtin</code>","text":"<pre><code>naif_download_de_kernel(name: str, output_path: str = None) -&gt; str\n</code></pre> <p>Download a DE kernel from NAIF with caching support</p> <p>Downloads the specified DE (Development Ephemeris) kernel file from NASA JPL's NAIF archive and caches it locally. If the kernel is already cached, returns the cached path without re-downloading. Optionally copies the kernel to a user-specified location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Kernel name. Supported kernels: \"de430\", \"de432s\", \"de435\", \"de438\", \"de440\", \"de440s\", \"de442\", \"de442s\".</p> required <code>output_path</code> <code>str</code> <p>Optional path to copy the kernel to after download/cache retrieval. If not specified, returns the cache location.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the kernel file (cache location or output_path if specified).</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If kernel name is unsupported, download fails, or file operations fail.</p> Example <pre><code>import brahe as bh\n\n# Download and cache de440s kernel\nkernel_path = bh.datasets.naif.download_de_kernel(\"de440s\")\nprint(f\"Kernel cached at: {kernel_path}\")\n\n# Download and copy to specific location\nkernel_path = bh.datasets.naif.download_de_kernel(\"de440s\", \"/path/to/my_kernel.bsp\")\nprint(f\"Kernel saved to: {kernel_path}\")\n</code></pre> Note <ul> <li>DE kernels are long-term stable products and are not refreshed once cached</li> <li>Files are cached to ~/.cache/brahe/naif/ (or $BRAHE_CACHE/naif/ if set)</li> <li>Kernel files are large (de440s: ~17MB, de440: ~114MB)</li> <li>Available at: https://naif.jpl.nasa.gov/pub/naif/generic_kernels/spk/planets/</li> </ul>"},{"location":"library_api/datasets/naif.html#see-also","title":"See Also","text":"<ul> <li>About NAIF and SPICE Kernels - Learn more about NAIF ephemeris data (coming soon)</li> <li>NASA NAIF Website - Official NAIF data archive</li> </ul>"},{"location":"library_api/earth_models/index.html","title":"Earth Models","text":"<p>Module: <code>brahe.earth_models</code></p> <p>Earth models provide atmospheric density and other environmental data required for accurate orbit propagation and satellite operations.</p>"},{"location":"library_api/earth_models/index.html#atmospheric-density-models","title":"Atmospheric Density Models","text":"<p>Atmospheric density models compute the density of the Earth's atmosphere at a given location and time, which is essential for drag calculations in low Earth orbit.</p>"},{"location":"library_api/earth_models/index.html#harris-priester","title":"Harris-Priester","text":"<p>Simple empirical atmospheric density model that accounts for altitude and diurnal variations.</p>"},{"location":"library_api/earth_models/index.html#nrlmsise-00","title":"NRLMSISE-00","text":"<p>Empirical atmospheric model providing temperature and density profiles using space weather data.</p>"},{"location":"library_api/earth_models/index.html#see-also","title":"See Also","text":"<ul> <li>Atmospheric Drag (Learn) - Conceptual explanation of drag modeling</li> <li>Space Weather Data - Required for NRLMSISE-00</li> <li>Orbital Dynamics Module - Drag acceleration calculations</li> </ul>"},{"location":"library_api/earth_models/harris_priester.html","title":"Harris-Priester","text":"<p>Simple empirical atmospheric density model for drag calculations.</p> <p>Note</p> <p>For conceptual explanations, see Atmospheric Drag in the Learn section.</p>"},{"location":"library_api/earth_models/harris_priester.html#brahe.density_harris_priester","title":"density_harris_priester  <code>builtin</code>","text":"<pre><code>density_harris_priester(r_tod: ndarray, r_sun: ndarray) -&gt; float\n</code></pre> <p>Computes atmospheric density using the Harris-Priester model.</p> <p>The Harris-Priester model accounts for diurnal density variations caused by solar heating. Valid for altitudes between 100 km and 1000 km. Returns 0.0 outside this range.</p> <p>Parameters:</p> Name Type Description Default <code>r_tod</code> <code>ndarray</code> <p>Satellite position in true-of-date frame. Units: (m)</p> required <code>r_sun</code> <code>ndarray</code> <p>Sun position in true-of-date frame. Units: (m)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Atmospheric density at the satellite position. Units: (kg/m\u00b3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nr_sat = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\n\ndensity = bh.density_harris_priester(r_sat, r_sun)\nprint(f\"Density: {density:.2e} kg/m\u00b3\")\n</code></pre>"},{"location":"library_api/earth_models/harris_priester.html#see-also","title":"See Also","text":"<ul> <li>NRLMSISE-00 - Advanced empirical density model</li> <li>Earth Models Module - Complete API reference for earth models</li> </ul>"},{"location":"library_api/earth_models/nrlmsise00.html","title":"NRLMSISE-00","text":"<p>NRLMSISE-00 (Naval Research Laboratory Mass Spectrometer and Incoherent Scatter Radar Exosphere) atmospheric density model.</p> <p>Note</p> <p>For conceptual explanations, see Atmospheric Drag in the Learn section.</p>"},{"location":"library_api/earth_models/nrlmsise00.html#brahe.density_nrlmsise00","title":"density_nrlmsise00  <code>builtin</code>","text":"<pre><code>density_nrlmsise00(epc: Epoch, x_ecef: ndarray) -&gt; float\n</code></pre> <p>Compute atmospheric density using the NRLMSISE-00 model from ECEF coordinates.</p> <p>This function computes atmospheric density using the NRLMSISE-00 empirical model, automatically retrieving space weather data for the given epoch. The ECEF position is converted to geodetic coordinates internally.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch of computation (used to lookup space weather data)</p> required <code>x_ecef</code> <code>ndarray</code> <p>Position in ECEF frame. Units: (m)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Atmospheric density. Units: (kg/m\u00b3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP and space weather data\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Define epoch and ECEF position (400 km altitude over equator)\nepc = bh.Epoch.from_date(2020, 6, 1, bh.TimeSystem.UTC)\nx_ecef = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\n\n# Compute density\ndensity = bh.density_nrlmsise00(epc, x_ecef)\nprint(f\"Density: {density:.2e} kg/m\u00b3\")\n</code></pre>"},{"location":"library_api/earth_models/nrlmsise00.html#brahe.density_nrlmsise00_geod","title":"density_nrlmsise00_geod  <code>builtin</code>","text":"<pre><code>density_nrlmsise00_geod(epc: Epoch, geod: ndarray) -&gt; float\n</code></pre> <p>Compute atmospheric density using the NRLMSISE-00 model from geodetic coordinates.</p> <p>This function computes atmospheric density using the NRLMSISE-00 empirical model, automatically retrieving space weather data for the given epoch. Takes geodetic coordinates directly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch of computation (used to lookup space weather data)</p> required <code>geod</code> <code>ndarray</code> <p>Geodetic position as [longitude, latitude, altitude] where longitude and latitude are in degrees, and altitude is in meters</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Atmospheric density. Units: (kg/m\u00b3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP and space weather data\nbh.initialize_eop()\nbh.initialize_sw()\n\n# Define epoch and geodetic position\nepc = bh.Epoch.from_date(2020, 6, 1, bh.TimeSystem.UTC)\ngeod = np.array([-74.0, 40.7, 400e3])  # NYC area, 400 km altitude\n\n# Compute density\ndensity = bh.density_nrlmsise00_geod(epc, geod)\nprint(f\"Density: {density:.2e} kg/m\u00b3\")\n</code></pre>"},{"location":"library_api/earth_models/nrlmsise00.html#see-also","title":"See Also","text":"<ul> <li>Harris-Priester - Simple empirical density model</li> <li>Earth Models Module - Complete API reference for earth models</li> <li>Space Weather Data - Required for NRLMSISE-00</li> </ul>"},{"location":"library_api/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Module: <code>brahe.eop</code></p> <p>Earth Orientation Parameters provide corrections for the irregular rotation and orientation of the Earth, essential for accurate coordinate frame transformations between ECI and ECEF systems.</p>"},{"location":"library_api/eop/index.html#overview","title":"Overview","text":"<p>EOP data includes: - UT1-UTC: Difference between UT1 (Earth rotation time) and UTC - Polar Motion (x, y): Movement of Earth's rotation axis relative to the crust - dX, dY: Celestial pole offsets - LOD: Length of day variations</p>"},{"location":"library_api/eop/index.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports three types of EOP providers:</p>"},{"location":"library_api/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manage EOP file freshness with cache management and automatic updates.</p>"},{"location":"library_api/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Load EOP data from files (Standard or C04 format) for production applications with current data.</p>"},{"location":"library_api/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Use user-defined fixed data, ideal for testing, offline use, or applications not requiring the most precise transformations.</p>"},{"location":"library_api/eop/index.html#global-eop-management","title":"Global EOP Management","text":"<p>EOP data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/eop/index.html#functions","title":"Functions","text":"<ul> <li>Setting global EOP providers</li> <li>Querying global EOP data</li> <li>Downloading latest EOP files</li> </ul>"},{"location":"library_api/eop/index.html#quick-start","title":"Quick Start","text":"<pre><code>import brahe as bh\n\n# Option 1: Use file-based EOP (recommended for production)\nbh.set_global_eop_provider(\n    bh.FileEOPProvider.from_default_standard()\n)\n\n# Option 2: Use static EOP (for testing/offline use)\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Now frame transformations will use the global EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]  # meters\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/index.html#see-also","title":"See Also","text":"<ul> <li>Frames - Coordinate frame transformations that use EOP</li> <li>Epoch - Time representation</li> </ul>"},{"location":"library_api/eop/caching_provider.html","title":"CachingEOPProvider","text":""},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider","title":"CachingEOPProvider","text":"<pre><code>CachingEOPProvider(eop_type: str, max_age_seconds: int, auto_refresh: bool, interpolate: bool, extrapolate: str, filepath: str = None)\n</code></pre> <p>Caching EOP provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileEOPProvider and adds automatic cache management. It checks the age of the EOP file and downloads updated versions when the file exceeds the maximum age value. If the file doesn't exist, it will be downloaded on initialization.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>Type of EOP file - \"C04\" for IERS C04 format or \"StandardBulletinA\" for IERS finals2000A.all format</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh. Common values: 86400 (1 day), 604800 (7 days)</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access. If False, only checks on initialization and manual refresh() calls</p> required <code>interpolate</code> <code>bool</code> <p>Enable linear interpolation between tabulated EOP values. Recommended: True for smoother data</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside EOP data range: \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)</p> required <code>filepath</code> <code>str</code> <p>Path to the EOP file (will be created if it doesn't exist). If None, uses default cache location: - StandardBulletinA: ~/.cache/brahe/finals.all.iau2000.txt - C04: ~/.cache/brahe/EOP_20_C04_one_file_1962-now.txt</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file download fails or file is invalid</p> Example <pre><code>import brahe as bh\n\n# Using default cache location (recommended)\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n\n# Check and refresh as needed\nprovider.refresh()\n\n# With explicit filepath\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\",\n    filepath=\"./eop_data/finals.all.iau2000.txt\"\n)\n\n# Auto-refresh mode (convenience)\nauto_provider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,  # Checks on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP file type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type (\"C04\", \"StandardBulletinA\", etc.)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded EOP file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nage = provider.file_age()\nprint(f\"EOP file age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the EOP file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; Tuple\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(pm_x, pm_y, ut1_utc, dx, dy, lod)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last MJD with valid celestial pole offset data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dX/dY data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last MJD with valid LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with length of day data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached EOP data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Later, manually force a refresh check\nprovider.refresh()\n</code></pre>"},{"location":"library_api/eop/file_provider.html","title":"FileEOPProvider","text":"<p>Load Earth Orientation Parameters from IERS data files.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider","title":"FileEOPProvider","text":"<pre><code>FileEOPProvider()\n</code></pre> <p>File-based Earth Orientation Parameter provider.</p> <p>Loads EOP data from files in standard IERS formats and provides interpolation and extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from C04 file with interpolation\neop = bh.FileEOPProvider.from_c04_file(\n    \"./eop_data/finals2000A.all.csv\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Create from standard file\neop = bh.FileEOPProvider.from_standard_file(\n    \"./eop_data/finals.all\",\n    interpolate=True,\n    extrapolate=\"Zero\"\n)\n\n# Use default file location\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(eop)\n\n# Get EOP data for a specific MJD\nmjd = 60310.0\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Extrapolation: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_c04_file","title":"from_c04_file  <code>builtin</code>","text":"<pre><code>from_c04_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a C04 format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to C04 EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with C04 file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_c04_file(\"./eop_data/finals2000A.all.csv\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_c04","title":"from_default_c04  <code>builtin</code>","text":"<pre><code>from_default_c04(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default C04 EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default C04 file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file(eop_type: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from default EOP file location with specified type.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>EOP file type (\"C04\" or \"StandardBulletinA\")</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default file of specified type</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_file(\"C04\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_standard","title":"from_default_standard  <code>builtin</code>","text":"<pre><code>from_default_standard(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default standard IERS EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default standard file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from an EOP file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_file(\"./eop_data/eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_standard_file","title":"from_standard_file  <code>builtin</code>","text":"<pre><code>from_standard_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a standard IERS format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to standard IERS EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with standard file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_standard_file(\"./eop_data/standard_eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"interpolation: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"is_initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_last_dxdy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_max: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#overview","title":"Overview","text":"<p><code>FileEOPProvider</code> loads EOP data from files in either Standard or C04 format provided by the International Earth Rotation and Reference Systems Service (IERS).</p> <p>Module: <code>brahe.eop</code></p> <p>Data Sources: - Standard Format: finals2000A.all - Combined rapid + predicted data - C04 Format: eopc04_IAU2000.XX - Long-term historical data</p>"},{"location":"library_api/eop/file_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/file_provider.html#from-default-files","title":"From Default Files","text":"<pre><code>import brahe as bh\n\n# Use default standard format file\nprovider = bh.FileEOPProvider.from_default_standard()\n\n# Use default C04 format file\nprovider = bh.FileEOPProvider.from_default_c04()\n</code></pre>"},{"location":"library_api/eop/file_provider.html#from-custom-files","title":"From Custom Files","text":"<pre><code>import brahe as bh\n\n# Load from custom standard file\nprovider = bh.FileEOPProvider.from_standard_file(\n    \"/path/to/finals2000A.all\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Load from custom C04 file\nprovider = bh.FileEOPProvider.from_c04_file(\n    \"/path/to/eopc04.XX\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#configuration-options","title":"Configuration Options","text":""},{"location":"library_api/eop/file_provider.html#interpolation","title":"Interpolation","text":"<p><code>interpolate: bool</code> - Enable/disable interpolation between data points</p> <ul> <li><code>True</code>: Linear interpolation for dates between data points (recommended)</li> <li><code>False</code>: Use nearest data point (step function)</li> </ul>"},{"location":"library_api/eop/file_provider.html#extrapolation","title":"Extrapolation","text":"<p><code>extrapolate: str</code> - Behavior when querying dates outside data range</p> <ul> <li><code>\"Hold\"</code>: Use first/last values for dates before/after data range</li> <li><code>\"Zero\"</code>: Return zero for all EOP values outside range</li> <li><code>\"Error\"</code>: Raise an error if date is outside range</li> </ul>"},{"location":"library_api/eop/file_provider.html#usage-with-global-eop","title":"Usage with Global EOP","text":"<pre><code>import brahe as bh\n\n# Create provider from file\nprovider = bh.FileEOPProvider.from_default_standard(\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n\n# Now all frame transformations use this EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#downloading-eop-files","title":"Downloading EOP Files","text":"<pre><code>import brahe as bh\n\n# Download latest standard EOP file\nfilepath = bh.download_standard_eop_file(\"./data\")\n\n# Download latest C04 EOP file\nfilepath = bh.download_c04_eop_file(\"./data\")\n\n# Use downloaded file\nprovider = bh.FileEOPProvider.from_standard_file(filepath)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider - Built-in historical EOP data</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations using EOP</li> </ul>"},{"location":"library_api/eop/functions.html","title":"EOP Functions","text":"<p>Global EOP management and query functions.</p> <p>Module: <code>brahe.eop</code></p>"},{"location":"library_api/eop/functions.html#setting-global-eop-provider","title":"Setting Global EOP Provider","text":""},{"location":"library_api/eop/functions.html#initialize_eop","title":"initialize_eop","text":"<p>Recommended: Initialize the global EOP provider with sensible defaults. This is the easiest way to get started with EOP data for most applications.</p>"},{"location":"library_api/eop/functions.html#brahe.initialize_eop","title":"initialize_eop  <code>builtin</code>","text":"<pre><code>initialize_eop() -&gt; Any\n</code></pre> <p>Initialize the global EOP provider with recommended default settings.</p> <p>This convenience function creates a CachingEOPProvider with sensible defaults and sets it as the global provider. The provider will:</p> <ul> <li>Use StandardBulletinA EOP data format</li> <li>Automatically download/update EOP files when older than 7 days</li> <li>Use the default cache location (~/.cache/brahe/finals.all.iau2000.txt)</li> <li>Enable interpolation for smooth EOP data transitions</li> <li>Hold the last known EOP value when extrapolating beyond available data</li> <li>NOT auto-refresh on every access (manual refresh required)</li> </ul> <p>This is the recommended way to initialize EOP data for most applications, balancing accuracy, performance, and ease of use.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file download or loading failed</p> Example <pre><code>import brahe as bh\n\n# Initialize with recommended defaults\nbh.initialize_eop()\n\n# Now you can perform frame transformations that require EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [bh.R_EARTH + 500e3, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre> Example <pre><code>import brahe as bh\n\n# This is equivalent to:\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider","title":"set_global_eop_provider","text":"<p>Set the global EOP provider using any supported provider type (StaticEOPProvider, FileEOPProvider, or CachingEOPProvider).</p>"},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider","title":"set_global_eop_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider(provider: StaticEOPProvider | FileEOPProvider | CachingEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using any supported provider type.</p> <p>This function accepts any of the three EOP provider types: StaticEOPProvider, FileEOPProvider, or CachingEOPProvider. This is the recommended way to set the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticEOPProvider | FileEOPProvider | CachingEOPProvider</code> <p>EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\n# Use with StaticEOPProvider\nprovider = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(provider)\n\n# Use with FileEOPProvider\nprovider = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(provider)\n\n# Use with CachingEOPProvider\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#querying-global-eop-data","title":"Querying Global EOP Data","text":""},{"location":"library_api/eop/functions.html#get_global_eop","title":"get_global_eop","text":"<p>Get all EOP values for a specific Modified Julian Date.</p> <p>Returns: Tuple of (ut1_utc, pm_x, pm_y, dx, dy, lod)</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop","title":"get_global_eop  <code>builtin</code>","text":"<pre><code>get_global_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p>"},{"location":"library_api/eop/functions.html#get_global_ut1_utc","title":"get_global_ut1_utc","text":"<p>Get UT1-UTC offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_ut1_utc","title":"get_global_ut1_utc  <code>builtin</code>","text":"<pre><code>get_global_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/functions.html#get_global_pm","title":"get_global_pm","text":"<p>Get polar motion (x, y) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_pm","title":"get_global_pm  <code>builtin</code>","text":"<pre><code>get_global_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/functions.html#get_global_dxdy","title":"get_global_dxdy","text":"<p>Get celestial pole offsets (dx, dy) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_dxdy","title":"get_global_dxdy  <code>builtin</code>","text":"<pre><code>get_global_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/functions.html#get_global_lod","title":"get_global_lod","text":"<p>Get length of day offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_lod","title":"get_global_lod  <code>builtin</code>","text":"<pre><code>get_global_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/functions.html#eop-metadata","title":"EOP Metadata","text":""},{"location":"library_api/eop/functions.html#get_global_eop_type","title":"get_global_eop_type","text":"<p>Get the type of global EOP provider (\"file\" or \"static\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_type","title":"get_global_eop_type  <code>builtin</code>","text":"<pre><code>get_global_eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_initialization","title":"get_global_eop_initialization","text":"<p>Check if global EOP provider has been initialized.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_initialization","title":"get_global_eop_initialization  <code>builtin</code>","text":"<pre><code>get_global_eop_initialization() -&gt; bool\n</code></pre> <p>Check if the global EOP provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if global EOP provider is initialized</p>"},{"location":"library_api/eop/functions.html#get_global_eop_interpolation","title":"get_global_eop_interpolation","text":"<p>Check if interpolation is enabled.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_interpolation","title":"get_global_eop_interpolation  <code>builtin</code>","text":"<pre><code>get_global_eop_interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled in the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/functions.html#get_global_eop_extrapolation","title":"get_global_eop_extrapolation","text":"<p>Get extrapolation method (\"Hold\", \"Zero\", or \"Error\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_extrapolation","title":"get_global_eop_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_eop_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_len","title":"get_global_eop_len","text":"<p>Get number of EOP data points in provider.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_len","title":"get_global_eop_len  <code>builtin</code>","text":"<pre><code>get_global_eop_len() -&gt; int\n</code></pre> <p>Get the number of EOP data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_min","title":"get_global_eop_mjd_min","text":"<p>Get minimum (earliest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_min","title":"get_global_eop_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_max","title":"get_global_eop_mjd_max","text":"<p>Get maximum (latest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_max","title":"get_global_eop_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod","text":"<p>Get MJD of last LOD (Length of Day) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy","text":"<p>Get MJD of last dX/dY (celestial pole offset) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p>"},{"location":"library_api/eop/functions.html#downloading-eop-files","title":"Downloading EOP Files","text":""},{"location":"library_api/eop/functions.html#download_standard_eop_file","title":"download_standard_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_standard_eop_file","title":"download_standard_eop_file  <code>builtin</code>","text":"<pre><code>download_standard_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest standard Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre>"},{"location":"library_api/eop/functions.html#download_c04_eop_file","title":"download_c04_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_c04_eop_file","title":"download_c04_eop_file  <code>builtin</code>","text":"<pre><code>download_c04_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest C04 Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"library_api/eop/functions.html#usage-examples","title":"Usage Examples","text":""},{"location":"library_api/eop/functions.html#quick-start-recommended","title":"Quick Start (Recommended)","text":"<pre><code>import brahe as bh\n\n# Initialize EOP with recommended defaults - easiest way to get started!\nbh.initialize_eop()\n\n# Query EOP for specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\nut1_utc, pm_x, pm_y, dx, dy, lod = bh.get_global_eop(mjd)\nprint(f\"EOP for MJD {mjd}:\")\nprint(f\"  UT1-UTC: {ut1_utc:.6f} s\")\nprint(f\"  Polar Motion: ({pm_x*1e6:.3f}, {pm_y*1e6:.3f}) \u03bcrad\")\nprint(f\"  dX, dY: ({dx*1e6:.3f}, {dy*1e6:.3f}) \u03bcrad\")\nprint(f\"  LOD: {lod*1e3:.6f} ms\")\n</code></pre>"},{"location":"library_api/eop/functions.html#custom-provider-setup","title":"Custom Provider Setup","text":"<pre><code>import brahe as bh\n\n# Download and set up file-based EOP with custom settings\neop_file = bh.download_standard_eop_file(\"./data\")\nprovider = bh.FileEOPProvider.from_standard_file(\n    eop_file,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n\n# Check provider status\nprint(f\"EOP Type: {bh.get_global_eop_type()}\")\nprint(f\"Data points: {bh.get_global_eop_len()}\")\nprint(f\"Date range: MJD {bh.get_global_eop_mjd_min():.1f} to {bh.get_global_eop_mjd_max():.1f}\")\nprint(f\"Interpolation: {bh.get_global_eop_interpolation()}\")\nprint(f\"Extrapolation: {bh.get_global_eop_extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/functions.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider</li> <li>StaticEOPProvider</li> <li>Frames - Frame transformations that use EOP</li> </ul>"},{"location":"library_api/eop/static_provider.html","title":"StaticEOPProvider","text":"<p>Built-in Earth Orientation Parameters for testing and offline use.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider","title":"StaticEOPProvider","text":"<pre><code>StaticEOPProvider()\n</code></pre> <p>Static Earth Orientation Parameter provider with constant values.</p> <p>Provides EOP data using fixed values that don't change with time. Useful for testing or scenarios where time-varying EOP data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static EOP provider with default values\neop = bh.StaticEOPProvider()\n\n# Create static EOP provider with zero values\neop_zero = bh.StaticEOPProvider.from_zero()\n\n# Create with custom values\neop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(eop_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Extrapolation method: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(ut1_utc: float, pm_x: float, pm_y: float, dx: float, dy: float, lod: float) -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ut1_utc</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> required <code>pm_x</code> <code>float</code> <p>Polar motion x-component in radians</p> required <code>pm_y</code> <code>float</code> <p>Polar motion y-component in radians</p> required <code>dx</code> <code>float</code> <p>Celestial pole offset dx in radians</p> required <code>dy</code> <code>float</code> <p>Celestial pole offset dy in radians</p> required <code>lod</code> <code>float</code> <p>Length of day offset in seconds</p> required <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with specified EOP values</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with custom values\neop = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,\n    pm_x=1e-6,\n    pm_y=2e-6,\n    dx=1e-7,\n    dy=1e-7,\n    lod=0.001\n)\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with all EOP values set to zero</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with all zeros (no corrections)\neop = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider()\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Interpolation enabled: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Is initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with dx/dy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Maximum MJD: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#overview","title":"Overview","text":"<p><code>StaticEOPProvider</code> provides built-in historical EOP data that doesn't require external files. Useful for testing, examples, or when internet access is unavailable.</p> <p>Module: <code>brahe.eop</code></p> <p>Use Cases: - Unit testing - Examples and tutorials - Offline applications - Quick prototyping</p> <p>Limitations: - Fixed historical data (not updated) - Less accurate than file-based providers - Not suitable for production applications requiring current data</p>"},{"location":"library_api/eop/static_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/static_provider.html#zero-values","title":"Zero Values","text":"<pre><code>import brahe as bh\n\n# All EOP values set to zero\nprovider = bh.StaticEOPProvider.from_zero()\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#custom-values","title":"Custom Values","text":"<pre><code>import brahe as bh\n\n# Specify custom EOP values\nprovider = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,      # UT1-UTC offset (seconds)\n    pm_x=0.0001,      # Polar motion X (radians)\n    pm_y=0.0001,      # Polar motion Y (radians)\n    dx=0.00001,       # Celestial pole offset dX (radians)\n    dy=0.00001,       # Celestial pole offset dY (radians)\n    lod=0.001         # Length of day offset (seconds)\n)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#default-values","title":"Default Values","text":"<pre><code>import brahe as bh\n\n# Use built-in default values\nprovider = bh.StaticEOPProvider()\n</code></pre>"},{"location":"library_api/eop/static_provider.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Set up static EOP for testing\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Perform frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ECI to ECEF transformation\npos_eci = [7000000.0, 0.0, 0.0]  # meters in ECI\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n\n# ECEF to ECI transformation\nvel_ecef = [0.0, 7500.0, 0.0]  # m/s in ECEF\nvel_eci = bh.position_ecef_to_eci(epoch, vel_ecef)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#when-to-use","title":"When to Use","text":"<p>\u2705 Use StaticEOPProvider for: - Unit tests - Documentation examples - Learning and prototyping - Applications where high accuracy isn't critical</p> <p>\u274c Don't use StaticEOPProvider for: - Production orbit determination - Precise tracking applications - Applications requiring current EOP data - High-accuracy simulations</p>"},{"location":"library_api/eop/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider - File-based EOP for production use</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations</li> </ul>"},{"location":"library_api/events/index.html","title":"Event Detection","text":"<p>Event detection system for numerical propagators. Events allow detection of specific conditions during propagation, such as reaching a target time, crossing an altitude value, or triggering on custom conditions.</p> <p>Note</p> <p>For conceptual explanations and usage examples, see Event Detection in the User Guide.</p>"},{"location":"library_api/events/index.html#module-structure","title":"Module Structure","text":"<p>The event detection system is organized into the following components:</p> <ul> <li>Event Detectors - Core event detector classes (TimeEvent, ValueEvent, BinaryEvent)</li> <li>Pre-made Events - Convenience event detectors for common scenarios (AltitudeEvent)</li> <li>Event Results - DetectedEvent and EventQuery for accessing event information</li> <li>Enumerations - EventDirection, EventAction, EventType, EdgeType</li> </ul>"},{"location":"library_api/events/index.html#see-also","title":"See Also","text":"<ul> <li>NumericalOrbitPropagator - Propagator with event detection</li> <li>NumericalPropagator - Generic propagator with event detection</li> <li>Event Detection Guide - User guide</li> </ul>"},{"location":"library_api/events/detectors.html","title":"Event Detectors","text":"<p>Core event detector classes for detecting specific conditions during numerical propagation.</p>"},{"location":"library_api/events/detectors.html#brahe.TimeEvent","title":"TimeEvent","text":"<pre><code>TimeEvent(target_epoch: Epoch, name: str)\n</code></pre> <p>Time-based event detector.</p> <p>Triggers when simulation time reaches a target epoch. Useful for scheduled maneuvers or discrete events at known times.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>Target time for event detection</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required Example <pre><code>import brahe as bh\n\ntarget = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nevent = bh.TimeEvent(target, \"Maneuver Start\")\nevent = event.set_terminal()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/detectors.html#brahe.TimeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; TimeEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>TimeEvent</code> <code>TimeEvent</code> <p>Self for method chaining</p> Example <pre><code>import brahe as bh\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nevent = bh.TimeEvent(epoch, \"End Condition\").set_terminal()\n# Propagation will stop when this event is detected\n</code></pre>"},{"location":"library_api/events/detectors.html#brahe.TimeEvent.with_callback","title":"with_callback  <code>method descriptor</code>","text":"<pre><code>with_callback(callback: callable) -&gt; TimeEvent\n</code></pre> <p>Set event callback.</p> <p>The callback is called when the event is detected and can modify the state and override the terminal action.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>Function (epoch, state) -&gt; (Optional[state], EventAction)</p> required <p>Returns:</p> Name Type Description <code>TimeEvent</code> <code>TimeEvent</code> <p>Self for method chaining</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef apply_delta_v(epoch, state):\n    '''Apply 10 m/s delta-v in x direction'''\n    new_state = state.copy()\n    new_state[3] += 10.0  # vx += 10 m/s\n    return (new_state, bh.EventAction.CONTINUE)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nevent = bh.TimeEvent(epoch + 1800, \"Maneuver\").with_callback(apply_delta_v)\n</code></pre>"},{"location":"library_api/events/detectors.html#brahe.TimeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; TimeEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Appends instance number to the base name (e.g., \"Maneuver\" \u2192 \"Maneuver 1\").</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>TimeEvent</code> <code>TimeEvent</code> <p>Self for method chaining</p> Example <pre><code>import brahe as bh\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nevent = bh.TimeEvent(epoch, \"Burn\").with_instance(2)\n# Event name is now \"Burn 2\"\n</code></pre>"},{"location":"library_api/events/detectors.html#brahe.TimeEvent.with_time_tolerance","title":"with_time_tolerance  <code>method descriptor</code>","text":"<pre><code>with_time_tolerance(time_tol: float) -&gt; TimeEvent\n</code></pre> <p>Set custom time tolerance for event detection.</p> <p>Controls the precision of the bisection search algorithm. Smaller values result in more precise event time detection at the cost of more iterations.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds (default: 1e-6)</p> required <p>Returns:</p> Name Type Description <code>TimeEvent</code> <code>TimeEvent</code> <p>Self for method chaining</p> Example <pre><code>import brahe as bh\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Use tighter tolerance for precise timing\nevent = bh.TimeEvent(epoch, \"Precise Maneuver\").with_time_tolerance(1e-9)\n\n# Chain multiple builder methods\nevent = (bh.TimeEvent(epoch, \"Complex\")\n         .with_time_tolerance(1e-3)\n         .with_instance(1)\n         .set_terminal())\n</code></pre>"},{"location":"library_api/events/detectors.html#brahe.ValueEvent","title":"ValueEvent","text":"<pre><code>ValueEvent(name: str, value_fn: callable, target_value: float, direction: EventDirection)\n</code></pre> <p>Value event detector with custom value function.</p> <p>Monitors a custom value computed by a Python function and detects when it crosses a specified target value. The value function receives the current epoch and state, and returns a float value to monitor.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>value_fn</code> <code>callable</code> <p>Function (epoch, state) -&gt; float that computes monitored value</p> required <code>target_value</code> <code>float</code> <p>Target value for crossing detection</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction (INCREASING, DECREASING, or ANY)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef radial_distance(epoch, state):\n    return np.linalg.norm(state[:3])\n\nevent = bh.ValueEvent(\n    \"Altitude Check\",\n    radial_distance,\n    bh.R_EARTH + 500e3,\n    bh.EventDirection.DECREASING\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/detectors.html#brahe.ValueEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; ValueEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>ValueEvent</code> <code>ValueEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.ValueEvent.with_callback","title":"with_callback  <code>method descriptor</code>","text":"<pre><code>with_callback(callback: callable) -&gt; ValueEvent\n</code></pre> <p>Set event callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>Function (epoch, state) -&gt; (Optional[state], EventAction)</p> required <p>Returns:</p> Name Type Description <code>ValueEvent</code> <code>ValueEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.ValueEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; ValueEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>ValueEvent</code> <code>ValueEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.ValueEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol: float, value_tol: float) -&gt; ValueEvent\n</code></pre> <p>Set custom tolerances for event detection.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds (default: 1e-6)</p> required <code>value_tol</code> <code>float</code> <p>Value tolerance (default: 1e-9)</p> required <p>Returns:</p> Name Type Description <code>ValueEvent</code> <code>ValueEvent</code> <p>Self for method chaining</p> Example <pre><code>import brahe as bh\n\ndef value_fn(epoch, state):\n    return state[0]  # Monitor x position\n\nevent = (bh.ValueEvent(\"X Crossing\", value_fn, 0.0, bh.EventDirection.ANY)\n         .with_tolerances(1e-3, 1e-6))  # Looser tolerances\n</code></pre>"},{"location":"library_api/events/detectors.html#brahe.BinaryEvent","title":"BinaryEvent","text":"<pre><code>BinaryEvent(name: str, condition_fn: callable, edge: EdgeType)\n</code></pre> <p>Binary event detector with custom condition function.</p> <p>Detects boolean condition transitions (edges). The condition function receives the current epoch and state, and returns a boolean. The event fires when the condition transitions according to the specified edge type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>condition_fn</code> <code>callable</code> <p>Function (epoch, state) -&gt; bool that returns the condition</p> required <code>edge</code> <code>EdgeType</code> <p>Which edge to detect (RISING_EDGE, FALLING_EDGE, or ANY_EDGE)</p> required Example <pre><code>import brahe as bh\n\ndef is_sunlit(epoch, state):\n    pos = state[:3]\n    return pos[0] &gt; 0\n\nevent = bh.BinaryEvent(\n    \"Eclipse Entry\",\n    is_sunlit,\n    bh.EdgeType.FALLING_EDGE\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/detectors.html#brahe.BinaryEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; BinaryEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>BinaryEvent</code> <code>BinaryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.BinaryEvent.with_callback","title":"with_callback  <code>method descriptor</code>","text":"<pre><code>with_callback(callback: callable) -&gt; BinaryEvent\n</code></pre> <p>Set event callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>Function (epoch, state) -&gt; (Optional[state], EventAction)</p> required <p>Returns:</p> Name Type Description <code>BinaryEvent</code> <code>BinaryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.BinaryEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; BinaryEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>BinaryEvent</code> <code>BinaryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#brahe.BinaryEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol: float, value_tol: float) -&gt; BinaryEvent\n</code></pre> <p>Set custom tolerances for event detection.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds (default: 1e-6)</p> required <code>value_tol</code> <code>float</code> <p>Value tolerance (default: 1e-9)</p> required <p>Returns:</p> Name Type Description <code>BinaryEvent</code> <code>BinaryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/detectors.html#see-also","title":"See Also","text":"<ul> <li>Pre-made Events - Convenience event detectors</li> <li>Event Results - DetectedEvent and EventQuery</li> <li>Enumerations - EventDirection, EdgeType, etc.</li> </ul>"},{"location":"library_api/events/enums.html","title":"Enumerations","text":"<p>Enumerations used by the event detection system.</p>"},{"location":"library_api/events/enums.html#brahe.EventDirection","title":"EventDirection","text":"<pre><code>EventDirection()\n</code></pre> <p>Event detection direction.</p> <p>Specifies which type of zero-crossing to detect: increasing (negative to positive), decreasing (positive to negative), or any crossing.</p> Example <pre><code>import brahe as bh\n\n# Detect decreasing crossings only\ndirection = bh.EventDirection.DECREASING\n\n# Compare directions\nif direction == bh.EventDirection.DECREASING:\n    print(\"Decreasing\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/enums.html#brahe.EventDirection.ANY","title":"ANY  <code>class-attribute</code>","text":"<pre><code>ANY: Any = EventDirection.Any\n</code></pre> <p>Event detection direction.</p> <p>Specifies which type of zero-crossing to detect: increasing (negative to positive), decreasing (positive to negative), or any crossing.</p> Example <pre><code>import brahe as bh\n\n# Detect decreasing crossings only\ndirection = bh.EventDirection.DECREASING\n\n# Compare directions\nif direction == bh.EventDirection.DECREASING:\n    print(\"Decreasing\")\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventDirection.DECREASING","title":"DECREASING  <code>class-attribute</code>","text":"<pre><code>DECREASING: Any = EventDirection.Decreasing\n</code></pre> <p>Event detection direction.</p> <p>Specifies which type of zero-crossing to detect: increasing (negative to positive), decreasing (positive to negative), or any crossing.</p> Example <pre><code>import brahe as bh\n\n# Detect decreasing crossings only\ndirection = bh.EventDirection.DECREASING\n\n# Compare directions\nif direction == bh.EventDirection.DECREASING:\n    print(\"Decreasing\")\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventDirection.INCREASING","title":"INCREASING  <code>class-attribute</code>","text":"<pre><code>INCREASING: Any = EventDirection.Increasing\n</code></pre> <p>Event detection direction.</p> <p>Specifies which type of zero-crossing to detect: increasing (negative to positive), decreasing (positive to negative), or any crossing.</p> Example <pre><code>import brahe as bh\n\n# Detect decreasing crossings only\ndirection = bh.EventDirection.DECREASING\n\n# Compare directions\nif direction == bh.EventDirection.DECREASING:\n    print(\"Decreasing\")\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventAction","title":"EventAction","text":"<pre><code>EventAction()\n</code></pre> <p>Action to take when an event is detected.</p> <p>Determines whether propagation should stop or continue after an event is detected. Can be set as the default action via <code>.set_terminal()</code> or returned from a callback to override the default.</p> Example <pre><code>import brahe as bh\n\n# Terminal event (stops propagation)\nevent = bh.TimeEvent(target_epoch, \"Maneuver\").set_terminal()\n\n# Callback can override the action\ndef callback(epoch, state):\n    return (None, bh.EventAction.STOP)  # Override to stop\n\nevent = bh.TimeEvent(epoch, \"Check\").with_callback(callback)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/enums.html#brahe.EventAction.CONTINUE","title":"CONTINUE  <code>class-attribute</code>","text":"<pre><code>CONTINUE: Any = EventAction.Continue\n</code></pre> <p>Action to take when an event is detected.</p> <p>Determines whether propagation should stop or continue after an event is detected. Can be set as the default action via <code>.set_terminal()</code> or returned from a callback to override the default.</p> Example <pre><code>import brahe as bh\n\n# Terminal event (stops propagation)\nevent = bh.TimeEvent(target_epoch, \"Maneuver\").set_terminal()\n\n# Callback can override the action\ndef callback(epoch, state):\n    return (None, bh.EventAction.STOP)  # Override to stop\n\nevent = bh.TimeEvent(epoch, \"Check\").with_callback(callback)\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventAction.STOP","title":"STOP  <code>class-attribute</code>","text":"<pre><code>STOP: Any = EventAction.Stop\n</code></pre> <p>Action to take when an event is detected.</p> <p>Determines whether propagation should stop or continue after an event is detected. Can be set as the default action via <code>.set_terminal()</code> or returned from a callback to override the default.</p> Example <pre><code>import brahe as bh\n\n# Terminal event (stops propagation)\nevent = bh.TimeEvent(target_epoch, \"Maneuver\").set_terminal()\n\n# Callback can override the action\ndef callback(epoch, state):\n    return (None, bh.EventAction.STOP)  # Override to stop\n\nevent = bh.TimeEvent(epoch, \"Check\").with_callback(callback)\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventType","title":"EventType","text":"<pre><code>EventType()\n</code></pre> <p>Type of event: instantaneous or period.</p> <p>Instantaneous events occur at a single point in time (e.g., apoapsis crossing). Period events maintain a condition over an interval (e.g., time within eclipse).</p> Example <pre><code>import brahe as bh\n\n# Check event type from a detected event\nif detected_event.event_type == bh.EventType.INSTANTANEOUS:\n    print(f\"Event at {detected_event.window_open}\")\nelse:\n    print(f\"Period from {detected_event.window_open} to {detected_event.window_close}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/enums.html#brahe.EventType.INSTANTANEOUS","title":"INSTANTANEOUS  <code>class-attribute</code>","text":"<pre><code>INSTANTANEOUS: Any = EventType.Instantaneous\n</code></pre> <p>Type of event: instantaneous or period.</p> <p>Instantaneous events occur at a single point in time (e.g., apoapsis crossing). Period events maintain a condition over an interval (e.g., time within eclipse).</p> Example <pre><code>import brahe as bh\n\n# Check event type from a detected event\nif detected_event.event_type == bh.EventType.INSTANTANEOUS:\n    print(f\"Event at {detected_event.window_open}\")\nelse:\n    print(f\"Period from {detected_event.window_open} to {detected_event.window_close}\")\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EventType.WINDOW","title":"WINDOW  <code>class-attribute</code>","text":"<pre><code>WINDOW: Any = EventType.Window\n</code></pre> <p>Type of event: instantaneous or period.</p> <p>Instantaneous events occur at a single point in time (e.g., apoapsis crossing). Period events maintain a condition over an interval (e.g., time within eclipse).</p> Example <pre><code>import brahe as bh\n\n# Check event type from a detected event\nif detected_event.event_type == bh.EventType.INSTANTANEOUS:\n    print(f\"Event at {detected_event.window_open}\")\nelse:\n    print(f\"Period from {detected_event.window_open} to {detected_event.window_close}\")\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EdgeType","title":"EdgeType","text":"<pre><code>EdgeType()\n</code></pre> <p>Edge type for binary event detection.</p> <p>Specifies which boolean transition to detect: rising edge (false \u2192 true), falling edge (true \u2192 false), or any edge.</p> Example <pre><code>import brahe as bh\n\n# Detect falling edge (true \u2192 false, e.g., eclipse entry)\nedge = bh.EdgeType.FALLING_EDGE\n\ndef is_sunlit(epoch, state):\n    return state[0] &gt; 0  # Simple check\n\nevent = bh.BinaryEvent(\"Eclipse Entry\", is_sunlit, edge)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/enums.html#brahe.EdgeType.ANY_EDGE","title":"ANY_EDGE  <code>class-attribute</code>","text":"<pre><code>ANY_EDGE: Any = EdgeType.AnyEdge\n</code></pre> <p>Edge type for binary event detection.</p> <p>Specifies which boolean transition to detect: rising edge (false \u2192 true), falling edge (true \u2192 false), or any edge.</p> Example <pre><code>import brahe as bh\n\n# Detect falling edge (true \u2192 false, e.g., eclipse entry)\nedge = bh.EdgeType.FALLING_EDGE\n\ndef is_sunlit(epoch, state):\n    return state[0] &gt; 0  # Simple check\n\nevent = bh.BinaryEvent(\"Eclipse Entry\", is_sunlit, edge)\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EdgeType.FALLING_EDGE","title":"FALLING_EDGE  <code>class-attribute</code>","text":"<pre><code>FALLING_EDGE: Any = EdgeType.FallingEdge\n</code></pre> <p>Edge type for binary event detection.</p> <p>Specifies which boolean transition to detect: rising edge (false \u2192 true), falling edge (true \u2192 false), or any edge.</p> Example <pre><code>import brahe as bh\n\n# Detect falling edge (true \u2192 false, e.g., eclipse entry)\nedge = bh.EdgeType.FALLING_EDGE\n\ndef is_sunlit(epoch, state):\n    return state[0] &gt; 0  # Simple check\n\nevent = bh.BinaryEvent(\"Eclipse Entry\", is_sunlit, edge)\n</code></pre>"},{"location":"library_api/events/enums.html#brahe.EdgeType.RISING_EDGE","title":"RISING_EDGE  <code>class-attribute</code>","text":"<pre><code>RISING_EDGE: Any = EdgeType.RisingEdge\n</code></pre> <p>Edge type for binary event detection.</p> <p>Specifies which boolean transition to detect: rising edge (false \u2192 true), falling edge (true \u2192 false), or any edge.</p> Example <pre><code>import brahe as bh\n\n# Detect falling edge (true \u2192 false, e.g., eclipse entry)\nedge = bh.EdgeType.FALLING_EDGE\n\ndef is_sunlit(epoch, state):\n    return state[0] &gt; 0  # Simple check\n\nevent = bh.BinaryEvent(\"Eclipse Entry\", is_sunlit, edge)\n</code></pre>"},{"location":"library_api/events/enums.html#see-also","title":"See Also","text":"<ul> <li>Event Detectors - Core event detector classes</li> <li>Pre-made Events - Convenience event detectors</li> <li>Event Results - DetectedEvent and EventQuery</li> </ul>"},{"location":"library_api/events/premade.html","title":"Pre-made Events","text":"<p>Convenience event detectors for common scenarios. These provide ready-to-use event detection for frequently needed conditions.</p>"},{"location":"library_api/events/premade.html#overview","title":"Overview","text":"Category Events State-Derived <code>AltitudeEvent</code>, <code>SpeedEvent</code>, <code>LongitudeEvent</code>, <code>LatitudeEvent</code> Orbital Elements <code>SemiMajorAxisEvent</code>, <code>EccentricityEvent</code>, <code>InclinationEvent</code>, <code>ArgumentOfPerigeeEvent</code>, <code>MeanAnomalyEvent</code>, <code>EccentricAnomalyEvent</code>, <code>TrueAnomalyEvent</code>, <code>ArgumentOfLatitudeEvent</code> Node Crossings <code>AscendingNodeEvent</code>, <code>DescendingNodeEvent</code> Eclipse/Shadow <code>UmbraEvent</code>, <code>PenumbraEvent</code>, <code>EclipseEvent</code>, <code>SunlitEvent</code> Area of Interest <code>AOIEntryEvent</code>, <code>AOIExitEvent</code>"},{"location":"library_api/events/premade.html#state-derived-events","title":"State-Derived Events","text":""},{"location":"library_api/events/premade.html#brahe.AltitudeEvent","title":"AltitudeEvent","text":"<pre><code>AltitudeEvent(value_altitude: float, name: str, direction: EventDirection)\n</code></pre> <p>Altitude-based event detector (convenience wrapper).</p> <p>Detects when geodetic altitude crosses a value. This is a convenience wrapper that automatically handles ECI \u2192 ECEF \u2192 geodetic transformations to compute altitude above the WGS84 ellipsoid.</p> <p>Parameters:</p> Name Type Description Default <code>value_altitude</code> <code>float</code> <p>Geodetic altitude value in meters above WGS84</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction (INCREASING, DECREASING, or ANY)</p> required Note <p>Requires EOP (Earth Orientation Parameters) to be initialized for accurate transformations. Use <code>bh.initialize_eop()</code> or set a custom provider.</p> Example <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nevent = bh.AltitudeEvent(\n    300e3,\n    \"Low Altitude Warning\",\n    bh.EventDirection.DECREASING\n)\nevent = event.set_terminal()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.AltitudeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; AltitudeEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>AltitudeEvent</code> <code>AltitudeEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AltitudeEvent.with_callback","title":"with_callback  <code>method descriptor</code>","text":"<pre><code>with_callback(callback: callable) -&gt; AltitudeEvent\n</code></pre> <p>Set event callback.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>callable</code> <p>Function (epoch, state) -&gt; (Optional[state], EventAction)</p> required <p>Returns:</p> Name Type Description <code>AltitudeEvent</code> <code>AltitudeEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AltitudeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; AltitudeEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>AltitudeEvent</code> <code>AltitudeEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AltitudeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol: float, value_tol: float) -&gt; AltitudeEvent\n</code></pre> <p>Set custom tolerances for event detection.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds (default: 1e-6)</p> required <code>value_tol</code> <code>float</code> <p>Value tolerance (default: 1e-9)</p> required <p>Returns:</p> Name Type Description <code>AltitudeEvent</code> <code>AltitudeEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.SpeedEvent","title":"SpeedEvent","text":"<pre><code>SpeedEvent(value: float, name: str, direction: EventDirection)\n</code></pre> <p>Speed event detector.</p> <p>Detects when velocity magnitude crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Speed value in m/s</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required Example <pre><code>import brahe as bh\n\n# Detect when speed exceeds 8 km/s\nevent = bh.SpeedEvent(\n    8000.0,\n    \"High Speed\",\n    bh.EventDirection.INCREASING\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.SpeedEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.SpeedEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.SpeedEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.LongitudeEvent","title":"LongitudeEvent","text":"<pre><code>LongitudeEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Longitude event detector.</p> <p>Detects when geodetic longitude crosses a value value. Requires EOP initialization for ECI-&gt;ECEF transformation.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Longitude value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required Example <pre><code>import brahe as bh\n\n# Detect when crossing prime meridian\nevent = bh.LongitudeEvent(\n    0.0,\n    \"Prime Meridian\",\n    bh.EventDirection.ANY,\n    bh.AngleFormat.DEGREES\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.LongitudeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.LongitudeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.LongitudeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.LatitudeEvent","title":"LatitudeEvent","text":"<pre><code>LatitudeEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Latitude event detector.</p> <p>Detects when geodetic latitude crosses a value value. Requires EOP initialization for ECI-&gt;ECEF transformation.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Latitude value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required Example <pre><code>import brahe as bh\n\n# Detect when crossing the equator\nevent = bh.LatitudeEvent(\n    0.0,\n    \"Equator Crossing\",\n    bh.EventDirection.ANY,\n    bh.AngleFormat.DEGREES\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.LatitudeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.LatitudeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.LatitudeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#orbital-element-events","title":"Orbital Element Events","text":""},{"location":"library_api/events/premade.html#brahe.SemiMajorAxisEvent","title":"SemiMajorAxisEvent","text":"<pre><code>SemiMajorAxisEvent(value: float, name: str, direction: EventDirection)\n</code></pre> <p>Semi-major axis event detector.</p> <p>Detects when orbital semi-major axis crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Semi-major axis value in meters</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required Example <pre><code>import brahe as bh\n\n# Detect when semi-major axis drops below GEO altitude\nevent = bh.SemiMajorAxisEvent(\n    bh.R_EARTH + 35786e3,\n    \"GEO value\",\n    bh.EventDirection.DECREASING\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.SemiMajorAxisEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.SemiMajorAxisEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.SemiMajorAxisEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricityEvent","title":"EccentricityEvent","text":"<pre><code>EccentricityEvent(value: float, name: str, direction: EventDirection)\n</code></pre> <p>Eccentricity event detector.</p> <p>Detects when orbital eccentricity crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Eccentricity value (dimensionless)</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required Example <pre><code>import brahe as bh\n\n# Detect when orbit becomes nearly circular\nevent = bh.EccentricityEvent(\n    0.001,\n    \"Near circular\",\n    bh.EventDirection.DECREASING\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricityEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.EccentricityEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricityEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.InclinationEvent","title":"InclinationEvent","text":"<pre><code>InclinationEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Inclination event detector.</p> <p>Detects when orbital inclination crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Inclination value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required Example <pre><code>import brahe as bh\n\n# Detect when inclination crosses 90 degrees (polar orbit value)\nevent = bh.InclinationEvent(\n    90.0,\n    \"Polar value\",\n    bh.EventDirection.ANY,\n    bh.AngleFormat.DEGREES\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.InclinationEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.InclinationEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.InclinationEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfPerigeeEvent","title":"ArgumentOfPerigeeEvent","text":"<pre><code>ArgumentOfPerigeeEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Argument of perigee event detector.</p> <p>Detects when argument of perigee crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Argument of perigee value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfPerigeeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfPerigeeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfPerigeeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.MeanAnomalyEvent","title":"MeanAnomalyEvent","text":"<pre><code>MeanAnomalyEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Mean anomaly event detector.</p> <p>Detects when mean anomaly crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Mean anomaly value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.MeanAnomalyEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.MeanAnomalyEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.MeanAnomalyEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricAnomalyEvent","title":"EccentricAnomalyEvent","text":"<pre><code>EccentricAnomalyEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Eccentric anomaly event detector.</p> <p>Detects when eccentric anomaly crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Eccentric anomaly value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricAnomalyEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.EccentricAnomalyEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.EccentricAnomalyEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.TrueAnomalyEvent","title":"TrueAnomalyEvent","text":"<pre><code>TrueAnomalyEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>True anomaly event detector.</p> <p>Detects when true anomaly crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>True anomaly value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.TrueAnomalyEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.TrueAnomalyEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.TrueAnomalyEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfLatitudeEvent","title":"ArgumentOfLatitudeEvent","text":"<pre><code>ArgumentOfLatitudeEvent(value: float, name: str, direction: EventDirection, angle_format: AngleFormat)\n</code></pre> <p>Argument of latitude event detector.</p> <p>Detects when argument of latitude (omega + true anomaly) crosses a value value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>Argument of latitude value</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>direction</code> <code>EventDirection</code> <p>Detection direction</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether value is in degrees or radians</p> required <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfLatitudeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfLatitudeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.ArgumentOfLatitudeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#node-crossing-events","title":"Node Crossing Events","text":""},{"location":"library_api/events/premade.html#brahe.AscendingNodeEvent","title":"AscendingNodeEvent","text":"<pre><code>AscendingNodeEvent(name: str)\n</code></pre> <p>Ascending node event detector.</p> <p>Detects when spacecraft crosses the ascending node (equator from south to north).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required Example <pre><code>import brahe as bh\n\n# Detect ascending node crossings\nevent = bh.AscendingNodeEvent(\"Ascending Node\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.AscendingNodeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.AscendingNodeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.AscendingNodeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.DescendingNodeEvent","title":"DescendingNodeEvent","text":"<pre><code>DescendingNodeEvent(name: str)\n</code></pre> <p>Descending node event detector.</p> <p>Detects when spacecraft crosses the descending node (equator from north to south).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required Example <pre><code>import brahe as bh\n\n# Detect descending node crossings\nevent = bh.DescendingNodeEvent(\"Descending Node\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.DescendingNodeEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.DescendingNodeEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.DescendingNodeEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#eclipseshadow-events","title":"Eclipse/Shadow Events","text":""},{"location":"library_api/events/premade.html#brahe.UmbraEvent","title":"UmbraEvent","text":"<pre><code>UmbraEvent(name: str, edge: EdgeType, ephemeris_source: EphemerisSource | None)\n</code></pre> <p>Umbra event detector.</p> <p>Detects when spacecraft enters/exits Earth's umbra (full shadow). Uses the conical shadow model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>edge</code> <code>EdgeType</code> <p>Edge type (RISING_EDGE = entering, FALLING_EDGE = exiting)</p> required <code>ephemeris_source</code> <code>EphemerisSource | None</code> <p>Source for sun position (None for low-precision)</p> required Example <pre><code>import brahe as bh\n\n# Detect umbra entry with low-precision ephemeris\nevent = bh.UmbraEvent(\"Umbra Entry\", bh.EdgeType.RISING_EDGE, None)\n\n# Detect umbra exit with high-precision DE440s ephemeris\nevent = bh.UmbraEvent(\"Umbra Exit\", bh.EdgeType.FALLING_EDGE, bh.EphemerisSource.DE440s)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.UmbraEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.UmbraEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.UmbraEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.PenumbraEvent","title":"PenumbraEvent","text":"<pre><code>PenumbraEvent(name: str, edge: EdgeType, ephemeris_source: EphemerisSource | None)\n</code></pre> <p>Penumbra event detector.</p> <p>Detects when spacecraft enters/exits Earth's penumbra (partial shadow). Uses the conical shadow model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>edge</code> <code>EdgeType</code> <p>Edge type (RISING_EDGE = entering, FALLING_EDGE = exiting)</p> required <code>ephemeris_source</code> <code>EphemerisSource | None</code> <p>Source for sun position (None for low-precision)</p> required Example <pre><code>import brahe as bh\n\n# Detect penumbra entry\nevent = bh.PenumbraEvent(\"Penumbra Entry\", bh.EdgeType.RISING_EDGE, None)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.PenumbraEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.PenumbraEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.PenumbraEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.EclipseEvent","title":"EclipseEvent","text":"<pre><code>EclipseEvent(name: str, edge: EdgeType, ephemeris_source: EphemerisSource | None)\n</code></pre> <p>Eclipse event detector.</p> <p>Detects when spacecraft enters/exits eclipse (either umbra or penumbra). Uses the conical shadow model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>edge</code> <code>EdgeType</code> <p>Edge type (RISING_EDGE = entering, FALLING_EDGE = exiting)</p> required <code>ephemeris_source</code> <code>EphemerisSource | None</code> <p>Source for sun position (None for low-precision)</p> required Example <pre><code>import brahe as bh\n\n# Detect any eclipse entry\nevent = bh.EclipseEvent(\"Eclipse Entry\", bh.EdgeType.RISING_EDGE, None)\n\n# Detect eclipse exit with high-precision ephemeris\nevent = bh.EclipseEvent(\"Eclipse Exit\", bh.EdgeType.FALLING_EDGE, bh.EphemerisSource.DE440s)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.EclipseEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.EclipseEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.EclipseEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#brahe.SunlitEvent","title":"SunlitEvent","text":"<pre><code>SunlitEvent(name: str, edge: EdgeType, ephemeris_source: EphemerisSource | None)\n</code></pre> <p>Sunlit event detector.</p> <p>Detects when spacecraft enters/exits sunlight (fully illuminated). Uses the conical shadow model.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>edge</code> <code>EdgeType</code> <p>Edge type (RISING_EDGE = entering, FALLING_EDGE = leaving)</p> required <code>ephemeris_source</code> <code>EphemerisSource | None</code> <p>Source for sun position (None for low-precision)</p> required Example <pre><code>import brahe as bh\n\n# Detect entering sunlight\nevent = bh.SunlitEvent(\"Enter Sunlight\", bh.EdgeType.RISING_EDGE, None)\n\n# Detect leaving sunlight with high-precision ephemeris\nevent = bh.SunlitEvent(\"Leave Sunlight\", bh.EdgeType.FALLING_EDGE, bh.EphemerisSource.DE440s)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.SunlitEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; Any\n</code></pre> <p>Mark this event as terminal (stops propagation).</p>"},{"location":"library_api/events/premade.html#brahe.SunlitEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance) -&gt; Any\n</code></pre> <p>Set instance number for display name.</p>"},{"location":"library_api/events/premade.html#brahe.SunlitEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol, value_tol) -&gt; Any\n</code></pre> <p>Set custom tolerances for event detection.</p>"},{"location":"library_api/events/premade.html#area-of-interest-events","title":"Area of Interest Events","text":""},{"location":"library_api/events/premade.html#brahe.AOIEntryEvent","title":"AOIEntryEvent","text":"<pre><code>AOIEntryEvent(polygon: PolygonLocation, name: str)\n</code></pre> <p>AOI Entry event detector.</p> <p>Detects when a satellite's sub-satellite point enters a polygonal Area of Interest. The sub-satellite point is computed by transforming the ECI position to geodetic coordinates (longitude, latitude).</p> <p>The polygon can be defined either from a PolygonLocation object or from raw (longitude, latitude) coordinate pairs.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>PolygonLocation</code> <p>Polygon defining the Area of Interest</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required Example <pre><code>import brahe as bh\n\n# Create from PolygonLocation\nvertices = [\n    [10.0, 50.0, 0.0],  # [lon, lat, alt] in degrees\n    [20.0, 50.0, 0.0],\n    [20.0, 55.0, 0.0],\n    [10.0, 55.0, 0.0],\n    [10.0, 50.0, 0.0],\n]\npolygon = bh.PolygonLocation(vertices)\nentry_event = bh.AOIEntryEvent(polygon, \"Europe Entry\")\n\n# Create from coordinates with angle format\ncoords = [\n    (10.0, 50.0),  # (lon, lat) in degrees\n    (20.0, 50.0),\n    (20.0, 55.0),\n    (10.0, 55.0),\n    (10.0, 50.0),\n]\nentry_event = bh.AOIEntryEvent.from_coordinates(coords, \"Europe Entry\", bh.AngleFormat.DEGREES)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.AOIEntryEvent.from_coordinates","title":"from_coordinates  <code>staticmethod</code>","text":"<pre><code>from_coordinates(vertices: list[tuple[float, float]], name: str, angle_format: AngleFormat) -&gt; AOIEntryEvent\n</code></pre> <p>Create an AOI entry event from raw coordinate pairs.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[tuple[float, float]]</code> <p>AOI vertices as (longitude, latitude) pairs</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether coordinates are in DEGREES or RADIANS</p> required <p>Returns:</p> Name Type Description <code>AOIEntryEvent</code> <code>AOIEntryEvent</code> <p>New AOI entry event detector</p> Example <pre><code>import brahe as bh\n\ncoords = [(10.0, 50.0), (20.0, 50.0), (20.0, 55.0), (10.0, 55.0), (10.0, 50.0)]\nevent = bh.AOIEntryEvent.from_coordinates(coords, \"AOI Entry\", bh.AngleFormat.DEGREES)\n</code></pre>"},{"location":"library_api/events/premade.html#brahe.AOIEntryEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; AOIEntryEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>AOIEntryEvent</code> <code>AOIEntryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AOIEntryEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; AOIEntryEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>AOIEntryEvent</code> <code>AOIEntryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AOIEntryEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol: float, value_tol: float) -&gt; AOIEntryEvent\n</code></pre> <p>Set custom tolerances for event detection.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds</p> required <code>value_tol</code> <code>float</code> <p>Value tolerance</p> required <p>Returns:</p> Name Type Description <code>AOIEntryEvent</code> <code>AOIEntryEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AOIExitEvent","title":"AOIExitEvent","text":"<pre><code>AOIExitEvent(polygon: PolygonLocation, name: str)\n</code></pre> <p>AOI Exit event detector.</p> <p>Detects when a satellite's sub-satellite point exits a polygonal Area of Interest. The sub-satellite point is computed by transforming the ECI position to geodetic coordinates (longitude, latitude).</p> <p>The polygon can be defined either from a PolygonLocation object or from raw (longitude, latitude) coordinate pairs.</p> <p>Parameters:</p> Name Type Description Default <code>polygon</code> <code>PolygonLocation</code> <p>Polygon defining the Area of Interest</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required Example <pre><code>import brahe as bh\n\n# Create from PolygonLocation\nvertices = [\n    [10.0, 50.0, 0.0],  # [lon, lat, alt] in degrees\n    [20.0, 50.0, 0.0],\n    [20.0, 55.0, 0.0],\n    [10.0, 55.0, 0.0],\n    [10.0, 50.0, 0.0],\n]\npolygon = bh.PolygonLocation(vertices)\nexit_event = bh.AOIExitEvent(polygon, \"Europe Exit\")\n\n# Create from coordinates with angle format\ncoords = [\n    (10.0, 50.0),  # (lon, lat) in degrees\n    (20.0, 50.0),\n    (20.0, 55.0),\n    (10.0, 55.0),\n    (10.0, 50.0),\n]\nexit_event = bh.AOIExitEvent.from_coordinates(coords, \"Europe Exit\", bh.AngleFormat.DEGREES)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/premade.html#brahe.AOIExitEvent.from_coordinates","title":"from_coordinates  <code>staticmethod</code>","text":"<pre><code>from_coordinates(vertices: list[tuple[float, float]], name: str, angle_format: AngleFormat) -&gt; AOIExitEvent\n</code></pre> <p>Create an AOI exit event from raw coordinate pairs.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[tuple[float, float]]</code> <p>AOI vertices as (longitude, latitude) pairs</p> required <code>name</code> <code>str</code> <p>Event name for identification</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Whether coordinates are in DEGREES or RADIANS</p> required <p>Returns:</p> Name Type Description <code>AOIExitEvent</code> <code>AOIExitEvent</code> <p>New AOI exit event detector</p> Example <pre><code>import brahe as bh\n\ncoords = [(10.0, 50.0), (20.0, 50.0), (20.0, 55.0), (10.0, 55.0), (10.0, 50.0)]\nevent = bh.AOIExitEvent.from_coordinates(coords, \"AOI Exit\", bh.AngleFormat.DEGREES)\n</code></pre>"},{"location":"library_api/events/premade.html#brahe.AOIExitEvent.set_terminal","title":"set_terminal  <code>method descriptor</code>","text":"<pre><code>set_terminal() -&gt; AOIExitEvent\n</code></pre> <p>Mark this event as terminal (stops propagation).</p> <p>Returns:</p> Name Type Description <code>AOIExitEvent</code> <code>AOIExitEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AOIExitEvent.with_instance","title":"with_instance  <code>method descriptor</code>","text":"<pre><code>with_instance(instance: int) -&gt; AOIExitEvent\n</code></pre> <p>Set instance number for display name.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>int</code> <p>Instance number to append</p> required <p>Returns:</p> Name Type Description <code>AOIExitEvent</code> <code>AOIExitEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#brahe.AOIExitEvent.with_tolerances","title":"with_tolerances  <code>method descriptor</code>","text":"<pre><code>with_tolerances(time_tol: float, value_tol: float) -&gt; AOIExitEvent\n</code></pre> <p>Set custom tolerances for event detection.</p> <p>Parameters:</p> Name Type Description Default <code>time_tol</code> <code>float</code> <p>Time tolerance in seconds</p> required <code>value_tol</code> <code>float</code> <p>Value tolerance</p> required <p>Returns:</p> Name Type Description <code>AOIExitEvent</code> <code>AOIExitEvent</code> <p>Self for method chaining</p>"},{"location":"library_api/events/premade.html#see-also","title":"See Also","text":"<ul> <li>Premade Events (Learn) - Conceptual guide and usage examples</li> <li>Event Detectors - Core event detector classes</li> <li>Event Results - DetectedEvent and EventQuery</li> <li>Enumerations - EventDirection, EventAction, etc.</li> </ul>"},{"location":"library_api/events/results.html","title":"Event Results","text":"<p>Classes for accessing and querying detected events after propagation.</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent","title":"DetectedEvent","text":"<pre><code>DetectedEvent()\n</code></pre> <p>Information about a detected event.</p> <p>Contains all information about an event that was detected during propagation, including timing, state, and event metadata.</p> <p>Attributes:</p> Name Type Description <code>window_open</code> <code>Epoch</code> <p>Start time (entry for periods, event time for instantaneous)</p> <code>window_close</code> <code>Epoch</code> <p>End time (exit for periods, same as window_open for instantaneous)</p> <code>entry_state</code> <code>ndarray</code> <p>State vector at window_open</p> <code>exit_state</code> <code>ndarray</code> <p>State vector at window_close</p> <code>value</code> <code>float</code> <p>Event function value at detection</p> <code>name</code> <code>str</code> <p>Event detector name</p> <code>action</code> <code>EventAction</code> <p>Action taken (STOP or CONTINUE)</p> <code>event_type</code> <code>EventType</code> <p>Event type (INSTANTANEOUS or PERIOD)</p> Example <pre><code>import brahe as bh\n\n# After propagation with events (requires numerical propagator binding)\n# events_detected = propagator.event_log()\n# for event in events_detected:\n#     print(f\"Event '{event.name}' at {event.window_open}\")\n#     print(f\"State: {event.entry_state}\")\n#     if event.event_type == bh.EventType.WINDOW:\n#         print(f\"Duration: {event.window_close - event.window_open} seconds\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.action","title":"action  <code>property</code>","text":"<pre><code>action: EventAction\n</code></pre> <p>Action taken (STOP or CONTINUE).</p> <p>Returns:</p> Name Type Description <code>EventAction</code> <code>EventAction</code> <p>Action taken after event detection</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.entry_state","title":"entry_state  <code>property</code>","text":"<pre><code>entry_state: ndarray\n</code></pre> <p>State vector at window_open.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>State at event entry</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.event_type","title":"event_type  <code>property</code>","text":"<pre><code>event_type: EventType\n</code></pre> <p>Event type (INSTANTANEOUS or PERIOD).</p> <p>Returns:</p> Name Type Description <code>EventType</code> <code>EventType</code> <p>Type of event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.exit_state","title":"exit_state  <code>property</code>","text":"<pre><code>exit_state: ndarray\n</code></pre> <p>State vector at window_close.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>State at event exit</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Event detector name.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Name of the event detector</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.value","title":"value  <code>property</code>","text":"<pre><code>value: float\n</code></pre> <p>Event function value at detection.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Event function value</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.window_close","title":"window_close  <code>property</code>","text":"<pre><code>window_close: Epoch\n</code></pre> <p>Window close time (exit for periods, same as window_open for instantaneous).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>End time of the event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.window_open","title":"window_open  <code>property</code>","text":"<pre><code>window_open: Epoch\n</code></pre> <p>Window open time (entry for periods, event time for instantaneous).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Start time of the event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.end_time","title":"end_time  <code>method descriptor</code>","text":"<pre><code>end_time() -&gt; Epoch\n</code></pre> <p>Alias for window_close.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>End time of the event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.start_time","title":"start_time  <code>method descriptor</code>","text":"<pre><code>start_time() -&gt; Epoch\n</code></pre> <p>Alias for window_open.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Start time of the event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.t_end","title":"t_end  <code>method descriptor</code>","text":"<pre><code>t_end() -&gt; Epoch\n</code></pre> <p>Alias for window_close.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>End time of the event</p>"},{"location":"library_api/events/results.html#brahe.DetectedEvent.t_start","title":"t_start  <code>method descriptor</code>","text":"<pre><code>t_start() -&gt; Epoch\n</code></pre> <p>Alias for window_open.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Start time of the event</p>"},{"location":"library_api/events/results.html#brahe.EventQuery","title":"EventQuery","text":"<pre><code>EventQuery()\n</code></pre> <p>Event query builder for filtering detected events.</p> <p>Provides chainable filter methods for querying events with an idiomatic Python interface. Filters are applied lazily and can be combined in any order.</p> Example <pre><code>import brahe as bh\n\n# After propagation with events\n# Get events from detector 0 within a time range\nevents = prop.query_events() \\\n    .by_detector_index(0) \\\n    .in_time_range(start, end) \\\n    .collect()\n\n# Count events by name pattern\ncount = prop.query_events() \\\n    .by_name_contains(\"Altitude\") \\\n    .count()\n\n# Get first terminal event\nevent = prop.query_events() \\\n    .by_action(bh.EventAction.STOP) \\\n    .first()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/events/results.html#brahe.EventQuery.after","title":"after  <code>method descriptor</code>","text":"<pre><code>after(epoch: Epoch) -&gt; EventQuery\n</code></pre> <p>Filter events after epoch (inclusive).</p> <p>Returns events that occurred at or after the specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch value (inclusive)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().after(cutoff_epoch).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.any","title":"any  <code>method descriptor</code>","text":"<pre><code>any() -&gt; bool\n</code></pre> <p>Check if any events match the filters.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if at least one event matches all applied filters</p> Example <pre><code>if prop.query_events().by_action(bh.EventAction.STOP).any():\n    print(\"Found terminal events\")\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.before","title":"before  <code>method descriptor</code>","text":"<pre><code>before(epoch: Epoch) -&gt; EventQuery\n</code></pre> <p>Filter events before epoch (inclusive).</p> <p>Returns events that occurred at or before the specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch value (inclusive)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().before(cutoff_epoch).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.by_action","title":"by_action  <code>method descriptor</code>","text":"<pre><code>by_action(action: EventAction) -&gt; EventQuery\n</code></pre> <p>Filter by event action.</p> <p>Returns events with the specified action.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>EventAction</code> <p>Event action to filter by (STOP or CONTINUE)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().by_action(bh.EventAction.STOP).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.by_detector_index","title":"by_detector_index  <code>method descriptor</code>","text":"<pre><code>by_detector_index(index: int) -&gt; EventQuery\n</code></pre> <p>Filter by detector index.</p> <p>Returns events detected by the specified detector.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Detector index (0-based, corresponding to add order)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().by_detector_index(0).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.by_event_type","title":"by_event_type  <code>method descriptor</code>","text":"<pre><code>by_event_type(event_type: EventType) -&gt; EventQuery\n</code></pre> <p>Filter by event type.</p> <p>Returns events of the specified type.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>EventType</code> <p>Event type to filter by (INSTANTANEOUS or PERIOD)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().by_event_type(bh.EventType.WINDOW).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.by_name_contains","title":"by_name_contains  <code>method descriptor</code>","text":"<pre><code>by_name_contains(substring: str) -&gt; EventQuery\n</code></pre> <p>Filter by detector name substring.</p> <p>Returns events where the detector name contains the given substring.</p> <p>Parameters:</p> Name Type Description Default <code>substring</code> <code>str</code> <p>Substring to search for in event names</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().by_name_contains(\"Altitude\").collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.by_name_exact","title":"by_name_exact  <code>method descriptor</code>","text":"<pre><code>by_name_exact(name: str) -&gt; EventQuery\n</code></pre> <p>Filter by exact detector name.</p> <p>Returns events where the detector name exactly matches the given string.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Exact name to match</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().by_name_exact(\"Altitude Event\").collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.collect","title":"collect  <code>method descriptor</code>","text":"<pre><code>collect() -&gt; list[DetectedEvent]\n</code></pre> <p>Collect filtered events into a list.</p> <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: List of events matching all applied filters</p> Example <pre><code>events = prop.query_events().by_detector_index(0).collect()\nfor event in events:\n    print(f\"Event: {event.name}\")\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.count","title":"count  <code>method descriptor</code>","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Count filtered events.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of events matching all applied filters</p> Example <pre><code>count = prop.query_events().by_name_contains(\"Altitude\").count()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; DetectedEvent\n</code></pre> <p>Get the first matching event, if any.</p> <p>Returns:</p> Type Description <code>DetectedEvent</code> <p>DetectedEvent or None: First event matching all filters, or None if empty</p> Example <pre><code>event = prop.query_events().by_action(bh.EventAction.STOP).first()\nif event:\n    print(f\"First terminal event: {event.name}\")\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.in_time_range","title":"in_time_range  <code>method descriptor</code>","text":"<pre><code>in_time_range(start: Epoch, end: Epoch) -&gt; EventQuery\n</code></pre> <p>Filter by time range (inclusive).</p> <p>Returns events that occurred within the specified time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Epoch</code> <p>Start of time range (inclusive)</p> required <code>end</code> <code>Epoch</code> <p>End of time range (inclusive)</p> required <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>New query with filter applied (for chaining)</p> Example <pre><code>events = prop.query_events().in_time_range(start_epoch, end_epoch).collect()\n</code></pre>"},{"location":"library_api/events/results.html#brahe.EventQuery.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if the query is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if no events match all applied filters</p>"},{"location":"library_api/events/results.html#brahe.EventQuery.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; DetectedEvent\n</code></pre> <p>Get the last matching event, if any.</p> <p>Returns:</p> Type Description <code>DetectedEvent</code> <p>DetectedEvent or None: Last event matching all filters, or None if empty</p> Example <pre><code>event = prop.query_events().by_detector_index(0).last()\n</code></pre>"},{"location":"library_api/events/results.html#see-also","title":"See Also","text":"<ul> <li>Event Detectors - Core event detector classes</li> <li>Pre-made Events - Convenience event detectors</li> <li>Enumerations - EventType, EventAction, etc.</li> </ul>"},{"location":"library_api/frames/index.html","title":"Reference Frames Module","text":"<p>Reference frame transformations between inertial (ECI) and Earth-fixed (ECEF) coordinate systems.</p>"},{"location":"library_api/frames/index.html#transformation-categories","title":"Transformation Categories","text":"<p>Brahe provides three categories of reference frame transformations:</p>"},{"location":"library_api/frames/index.html#eci-ecef","title":"ECI \u2194 ECEF","text":"<p>Generic transformations using common \"Earth-Centered Inertial\" and \"Earth-Centered Earth-Fixed\" naming convention. Currently maps to GCRF \u2194 ITRF transformations.</p>"},{"location":"library_api/frames/index.html#gcrf-itrf","title":"GCRF \u2194 ITRF","text":"<p>Explicit transformations between Geocentric Celestial Reference Frame (inertial) and International Terrestrial Reference Frame (Earth-fixed). Uses IAU 2006/2000A CIO-based theory with classical angles.</p>"},{"location":"library_api/frames/index.html#eme2000-gcrf","title":"EME2000 \u2194 GCRF","text":"<p>Constant frame bias transformations between Earth Mean Equator and Equinox of J2000.0 (classical inertial) and GCRF (modern inertial).</p>"},{"location":"library_api/frames/eci_ecef.html","title":"ECI \u2194 ECEF Transformations","text":"<p>Generic transformations using common \"Earth-Centered Inertial\" and \"Earth-Centered Earth-Fixed\" naming convention. Currently maps to GCRF \u2194 ITRF transformations.</p> <p>Note</p> <p>For conceptual explanations and examples, see ECI \u2194 ECEF Transformations in the Learn section.</p>"},{"location":"library_api/frames/eci_ecef.html#eci-to-ecef","title":"ECI to ECEF","text":""},{"location":"library_api/frames/eci_ecef.html#brahe.state_eci_to_ecef","title":"state_eci_to_ecef  <code>builtin</code>","text":"<pre><code>state_eci_to_ecef(epc: Epoch, x_eci: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>This function is an alias for state_gcrf_to_itrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_eci</code> <code>ndarray or list</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECI [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eci = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\nprint(f\"ECEF state: {state_ecef}\")\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#brahe.rotation_eci_to_ecef","title":"rotation_eci_to_ecef  <code>builtin</code>","text":"<pre><code>rotation_eci_to_ecef(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>This function is an alias for rotation_gcrf_to_itrf. <code>ECI</code> refers to the <code>GCRF</code> (Geocentric Celestial Reference Frame) implementation, and <code>ECEF</code> refers to the <code>ITRF</code> (International Terrestrial Reference Frame) implementation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ECI</code> (<code>GCRF</code>) -&gt; <code>ECEF</code> (<code>ITRF</code>)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix\nR = bh.rotation_eci_to_ecef(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#brahe.position_eci_to_ecef","title":"position_eci_to_ecef  <code>builtin</code>","text":"<pre><code>position_eci_to_ecef(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>This function is an alias for position_gcrf_to_itrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in ECI (meters)\nr_eci = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ECEF\nr_ecef = bh.position_eci_to_ecef(epc, r_eci)\nprint(f\"ECEF position: {r_ecef}\")\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#ecef-to-eci","title":"ECEF to ECI","text":""},{"location":"library_api/frames/eci_ecef.html#brahe.state_ecef_to_eci","title":"state_ecef_to_eci  <code>builtin</code>","text":"<pre><code>state_ecef_to_eci(epc: Epoch, x_ecef: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>This function is an alias for state_itrf_to_gcrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_ecef</code> <code>ndarray or list</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_ecef = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to ECI\nstate_eci = bh.state_ecef_to_eci(epc, state_ecef)\nprint(f\"ECI state: {state_eci}\")\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#brahe.rotation_ecef_to_eci","title":"rotation_ecef_to_eci  <code>builtin</code>","text":"<pre><code>rotation_ecef_to_eci(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>This function is an alias for rotation_itrf_to_gcrf. <code>ECEF</code> refers to the <code>ITRF</code> (International Terrestrial Reference Frame) implementation, and <code>ECI</code> refers to the <code>GCRF</code> (Geocentric Celestial Reference Frame) implementation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ECEF</code> (<code>ITRF</code>) -&gt; <code>ECI</code> (<code>GCRF</code>)</p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR = bh.rotation_ecef_to_eci(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#brahe.position_ecef_to_eci","title":"position_ecef_to_eci  <code>builtin</code>","text":"<pre><code>position_ecef_to_eci(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>This function is an alias for position_itrf_to_gcrf. Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ECEF (ground station)\nr_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to ECI\nr_eci = bh.position_ecef_to_eci(epc, r_ecef)\nprint(f\"ECI position: {r_eci}\")\n</code></pre>"},{"location":"library_api/frames/eci_ecef.html#see-also","title":"See Also","text":"<ul> <li>GCRF \u2194 ITRF Transformations - Detailed API for underlying reference frames</li> <li>Reference Frames Module - Complete API reference for frames module</li> </ul>"},{"location":"library_api/frames/eme2000_gcrf.html","title":"EME2000 \u2194 GCRF Transformations","text":"<p>Constant frame bias transformations between Earth Mean Equator and Equinox of J2000.0 (EME2000, classical inertial) and Geocentric Celestial Reference Frame (GCRF, modern inertial).</p> <p>Note</p> <p>For conceptual explanations and examples, see EME2000 \u2194 GCRF Transformations in the Learn section.</p>"},{"location":"library_api/frames/eme2000_gcrf.html#eme2000-to-gcrf","title":"EME2000 to GCRF","text":""},{"location":"library_api/frames/eme2000_gcrf.html#brahe.state_eme2000_to_gcrf","title":"state_eme2000_to_gcrf  <code>builtin</code>","text":"<pre><code>state_eme2000_to_gcrf(x_eme2000: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from EME2000 (Earth Mean Equator and Equinox of J2000.0) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the inverse frame bias correction to both position and velocity. Because the transformation does not vary with time, the velocity is directly rotated without additional correction terms.</p> <p>Parameters:</p> Name Type Description Default <code>x_eme2000</code> <code>ndarray or list</code> <p>State vector in <code>EME2000</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# State vector in EME2000 [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eme2000 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to GCRF\nstate_gcrf = bh.state_eme2000_to_gcrf(state_eme2000)\nprint(f\"GCRF state: {state_gcrf}\")\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#brahe.position_eme2000_to_gcrf","title":"position_eme2000_to_gcrf  <code>builtin</code>","text":"<pre><code>position_eme2000_to_gcrf(x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from EME2000 (Earth Mean Equator and Equinox of J2000.0) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the inverse frame bias correction to account for the small offset between the J2000.0 mean equator and equinox and GCRF. This is a constant transformation that does not vary with time.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>EME2000</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Position vector in EME2000 (meters)\nr_eme2000 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\n\n# Transform to GCRF\nr_gcrf = bh.position_eme2000_to_gcrf(r_eme2000)\nprint(f\"GCRF position: {r_gcrf}\")\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#brahe.rotation_eme2000_to_gcrf","title":"rotation_eme2000_to_gcrf  <code>builtin</code>","text":"<pre><code>rotation_eme2000_to_gcrf() -&gt; ndarray\n</code></pre> <p>Computes the rotation matrix from EME2000 (Earth Mean Equator and Equinox of J2000.0) to GCRF (Geocentric Celestial Reference Frame).</p> <p>This transformation applies the inverse frame bias correction to account for the difference between EME2000 (J2000.0 mean equator/equinox) and GCRF (ICRS-aligned). The transformation is constant and does not depend on time.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>EME2000</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Get rotation matrix\nR = bh.rotation_eme2000_to_gcrf()\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#gcrf-to-eme2000","title":"GCRF to EME2000","text":""},{"location":"library_api/frames/eme2000_gcrf.html#brahe.state_gcrf_to_eme2000","title":"state_gcrf_to_eme2000  <code>builtin</code>","text":"<pre><code>state_gcrf_to_eme2000(x_gcrf: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from GCRF (Geocentric Celestial Reference Frame) to EME2000 (Earth Mean Equator and Equinox of J2000.0).</p> <p>Applies the frame bias correction to both position and velocity. Because the transformation does not vary with time, the velocity is directly rotated without additional correction terms.</p> <p>Parameters:</p> Name Type Description Default <code>x_gcrf</code> <code>ndarray or list</code> <p>State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>EME2000</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# State vector in GCRF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_gcrf = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to EME2000\nstate_eme2000 = bh.state_gcrf_to_eme2000(state_gcrf)\nprint(f\"EME2000 state: {state_eme2000}\")\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#brahe.position_gcrf_to_eme2000","title":"position_gcrf_to_eme2000  <code>builtin</code>","text":"<pre><code>position_gcrf_to_eme2000(x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from GCRF (Geocentric Celestial Reference Frame) to EME2000 (Earth Mean Equator and Equinox of J2000.0).</p> <p>Applies the frame bias correction to account for the small offset between GCRF and the J2000.0 mean equator and equinox. This is a constant transformation that does not vary with time.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>EME2000</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Position vector in GCRF (meters)\nr_gcrf = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\n\n# Transform to EME2000\nr_eme2000 = bh.position_gcrf_to_eme2000(r_gcrf)\nprint(f\"EME2000 position: {r_eme2000}\")\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#brahe.rotation_gcrf_to_eme2000","title":"rotation_gcrf_to_eme2000  <code>builtin</code>","text":"<pre><code>rotation_gcrf_to_eme2000() -&gt; ndarray\n</code></pre> <p>Computes the rotation matrix from GCRF (Geocentric Celestial Reference Frame) to EME2000 (Earth Mean Equator and Equinox of J2000.0).</p> <p>This transformation applies the frame bias correction to account for the difference between GCRF (ICRS-aligned) and EME2000 (J2000.0 mean equator/equinox). The transformation is constant and does not depend on time.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>EME2000</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix\nR = bh.rotation_gcrf_to_eme2000()\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#frame-bias-matrix","title":"Frame Bias Matrix","text":""},{"location":"library_api/frames/eme2000_gcrf.html#brahe.bias_eme2000","title":"bias_eme2000  <code>builtin</code>","text":"<pre><code>bias_eme2000() -&gt; ndarray\n</code></pre> <p>Computes the frame bias matrix transforming GCRF (Geocentric Celestial Reference Frame) to EME2000 (Earth Mean Equator and Equinox of J2000.0).</p> <p>The bias matrix accounts for the small offset between the GCRF and the J2000.0 mean equator and equinox due to the difference in their definitions. This is a constant transformation that does not vary with time.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>EME2000</code></p> Example <pre><code>import brahe as bh\n\n# Get the bias matrix\nB = bh.bias_eme2000()\nprint(f\"Bias matrix shape: {B.shape}\")\n# Output: Bias matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames/eme2000_gcrf.html#see-also","title":"See Also","text":"<ul> <li>GCRF \u2194 ITRF Transformations - GCRF to Earth-fixed transformations</li> <li>Reference Frames Module - Complete API reference for frames module</li> </ul>"},{"location":"library_api/frames/gcrf_itrf.html","title":"GCRF \u2194 ITRF Transformations","text":"<p>Transformations between Geocentric Celestial Reference Frame (GCRF, inertial) and International Terrestrial Reference Frame (ITRF, Earth-fixed). Uses IAU 2006/2000A CIO-based theory with classical angles.</p> <p>Note</p> <p>For conceptual explanations and examples, see GCRF \u2194 ITRF Transformations in the Learn section.</p>"},{"location":"library_api/frames/gcrf_itrf.html#gcrf-to-itrf","title":"GCRF to ITRF","text":""},{"location":"library_api/frames/gcrf_itrf.html#brahe.state_gcrf_to_itrf","title":"state_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>state_gcrf_to_itrf(epc: Epoch, x_gcrf: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_gcrf</code> <code>ndarray or list</code> <p>State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>ITRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in GCRF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_gcrf = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ITRF\nstate_itrf = bh.state_gcrf_to_itrf(epc, state_gcrf)\nprint(f\"ITRF state: {state_itrf}\")\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.rotation_gcrf_to_itrf","title":"rotation_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>rotation_gcrf_to_itrf(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame). Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermediate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>ITRF</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from GCRF to ITRF\nR = bh.rotation_gcrf_to_itrf(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.position_gcrf_to_itrf","title":"position_gcrf_to_itrf  <code>builtin</code>","text":"<pre><code>position_gcrf_to_itrf(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from GCRF (Geocentric Celestial Reference Frame) to ITRF (International Terrestrial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>ITRF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in GCRF (meters)\nr_gcrf = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ITRF\nr_itrf = bh.position_gcrf_to_itrf(epc, r_gcrf)\nprint(f\"ITRF position: {r_itrf}\")\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#itrf-to-gcrf","title":"ITRF to GCRF","text":""},{"location":"library_api/frames/gcrf_itrf.html#brahe.state_itrf_to_gcrf","title":"state_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>state_itrf_to_gcrf(epc: Epoch, x_itrf: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_itrf</code> <code>ndarray or list</code> <p>State vector in <code>ITRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in <code>GCRF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ITRF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_itrf = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to GCRF\nstate_gcrf = bh.state_itrf_to_gcrf(epc, state_itrf)\nprint(f\"GCRF state: {state_gcrf}\")\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.rotation_itrf_to_gcrf","title":"rotation_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>rotation_itrf_to_gcrf(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Computes the combined rotation matrix from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame). Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermediate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming <code>ITRF</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ITRF to GCRF\nR = bh.rotation_itrf_to_gcrf(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.position_itrf_to_gcrf","title":"position_itrf_to_gcrf  <code>builtin</code>","text":"<pre><code>position_itrf_to_gcrf(epc: Epoch, x: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms a position vector from ITRF (International Terrestrial Reference Frame) to GCRF (Geocentric Celestial Reference Frame).</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray or list</code> <p>Position vector in <code>ITRF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Position vector in <code>GCRF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ITRF (ground station)\nr_itrf = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to GCRF\nr_gcrf = bh.position_itrf_to_gcrf(epc, r_itrf)\nprint(f\"GCRF position: {r_gcrf}\")\n</code></pre>"},{"location":"library_api/frames/gcrf_itrf.html#intermediate-matrices","title":"Intermediate Matrices","text":""},{"location":"library_api/frames/gcrf_itrf.html#brahe.bias_precession_nutation","title":"bias_precession_nutation  <code>builtin</code>","text":"<pre><code>bias_precession_nutation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Bias-Precession-Nutation matrix transforming the <code>GCRS</code> to the <code>CIRS</code> intermediate reference frame. This transformation corrects for the bias, precession, and nutation of Celestial Intermediate Origin (<code>CIO</code>) with respect to inertial space.</p> <p>This formulation computes the Bias-Precession-Nutation correction matrix according using a <code>CIO</code> based model using using the <code>IAU 2006</code> precession and <code>IAU 2000A</code> nutation models.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to the Celestial Intermediate Pole (<code>CIP</code>) derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRS</code> -&gt; <code>CIRS</code></p> References <p>IAU SOFA Tools For Earth Attitude, Example 5.5 http://www.iausofa.org/2021_0512_C/sofa/sofa_pn_c.pdf Software Version 18, 2021-04-18</p>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.earth_rotation","title":"earth_rotation  <code>builtin</code>","text":"<pre><code>earth_rotation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>CIRS</code> to the <code>TIRS</code> intermediate reference frame. This transformation corrects for the Earth rotation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>CIRS</code> -&gt; <code>TIRS</code></p>"},{"location":"library_api/frames/gcrf_itrf.html#brahe.polar_motion","title":"polar_motion  <code>builtin</code>","text":"<pre><code>polar_motion(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>TIRS</code> to the <code>ITRF</code> reference frame.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to compute the polar motion correction based on empirical observations of polar motion drift.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>TIRS</code> -&gt; <code>ITRF</code></p>"},{"location":"library_api/frames/gcrf_itrf.html#see-also","title":"See Also","text":"<ul> <li>ECI \u2194 ECEF Transformations - Generic naming convention API</li> <li>Reference Frames Module - Complete API reference for frames module</li> </ul>"},{"location":"library_api/integrators/index.html","title":"Integrators Module","text":"<p>Module: <code>brahe.integrators</code></p> <p>The integrators module provides numerical integration methods for solving ordinary differential equations (ODEs), with specialized support for orbital mechanics and variational equation propagation.</p>"},{"location":"library_api/integrators/index.html#module-contents","title":"Module Contents","text":"<ul> <li>Configuration - Integrator configuration and adaptive step control</li> <li>RK4 Integrator - Classical 4th-order Runge-Kutta method</li> <li>RKF45 Integrator - Runge-Kutta-Fehlberg 4(5) adaptive method</li> <li>DP54 Integrator - Dormand-Prince 5(4) adaptive method</li> <li>RKN1210 Integrator - Runge-Kutta-Nystr\u00f6m 12(10) high-precision method</li> </ul>"},{"location":"library_api/integrators/index.html#common-interface","title":"Common Interface","text":"<p>All integrators implement one of these trait interfaces:</p> <ul> <li><code>FixedStepIntegrator</code>: Fixed time-step integration</li> <li><code>AdaptiveStepIntegrator</code>: Adaptive time-step integration with error control</li> </ul> <p>Borth of which provide common methods:</p> <ul> <li><code>step()</code>: Advance the state by one time step</li> <li><code>step_with_varmat()</code>: Advance state and state transition matrix together</li> </ul>"},{"location":"library_api/integrators/index.html#see-also","title":"See Also","text":"<ul> <li>Numerical Integration User Guide - Conceptual introduction and examples</li> <li>Choosing Integrators - Guide to selecting the right integrator</li> <li>Configuration Guide - Tuning integrator parameters</li> </ul>"},{"location":"library_api/integrators/config.html","title":"Integrator Configuration","text":"<p>Configuration classes and types for controlling integrator behavior.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig","title":"IntegratorConfig","text":"<pre><code>IntegratorConfig(abs_tol: float = 1e-06, rel_tol: float = 0.001, initial_step: float = None, min_step: float = Ellipsis, max_step: float = Ellipsis, step_safety_factor: float = Ellipsis, min_step_scale_factor: float = Ellipsis, max_step_scale_factor: float = Ellipsis, max_step_attempts: int = 10, fixed_step_size: float = None)\n</code></pre> <p>Configuration for numerical integrators.</p> <p>Controls error tolerances, step size limits, and other integration parameters.</p> <p>Parameters:</p> Name Type Description Default <code>abs_tol</code> <code>float</code> <p>Absolute error tolerance. Defaults to 1e-6.</p> <code>1e-06</code> <code>rel_tol</code> <code>float</code> <p>Relative error tolerance. Defaults to 1e-3.</p> <code>0.001</code> <code>initial_step</code> <code>float</code> <p>Initial step size. Defaults to None (auto).</p> <code>None</code> <code>min_step</code> <code>float</code> <p>Minimum step size. Defaults to 1e-12.</p> <code>Ellipsis</code> <code>max_step</code> <code>float</code> <p>Maximum step size. Defaults to 900.0.</p> <code>Ellipsis</code> <code>step_safety_factor</code> <code>float</code> <p>Safety factor for step control. Defaults to 0.9.</p> <code>Ellipsis</code> <code>min_step_scale_factor</code> <code>float</code> <p>Minimum step scaling. Defaults to 0.2.</p> <code>Ellipsis</code> <code>max_step_scale_factor</code> <code>float</code> <p>Maximum step scaling. Defaults to 10.0.</p> <code>Ellipsis</code> <code>max_step_attempts</code> <code>int</code> <p>Maximum step attempts. Defaults to 10.</p> <code>10</code> <code>fixed_step_size</code> <code>float</code> <p>Fixed step size for fixed-step integrators. Defaults to None.</p> <code>None</code> Example <pre><code>import brahe as bh\n\n# Create default configuration\nconfig = bh.IntegratorConfig()\n\n# Create fixed-step configuration\nconfig = bh.IntegratorConfig.fixed_step(1.0)\n\n# Create adaptive configuration with custom tolerances\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\n\n# Customize configuration\nconfig = bh.IntegratorConfig(\n    abs_tol=1e-8,\n    rel_tol=1e-6,\n    max_step=100.0,\n    min_step=0.001\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.abs_tol","title":"abs_tol  <code>property</code>","text":"<pre><code>abs_tol: Any\n</code></pre> <p>Get absolute error tolerance.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.initial_step","title":"initial_step  <code>property</code>","text":"<pre><code>initial_step: Any\n</code></pre> <p>Get initial step size.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.max_step","title":"max_step  <code>property</code>","text":"<pre><code>max_step: Any\n</code></pre> <p>Get maximum step size.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.max_step_attempts","title":"max_step_attempts  <code>property</code>","text":"<pre><code>max_step_attempts: Any\n</code></pre> <p>Get maximum step attempts.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.max_step_scale_factor","title":"max_step_scale_factor  <code>property</code>","text":"<pre><code>max_step_scale_factor: Any\n</code></pre> <p>Get maximum step scale factor.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.min_step","title":"min_step  <code>property</code>","text":"<pre><code>min_step: Any\n</code></pre> <p>Get minimum step size.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.min_step_scale_factor","title":"min_step_scale_factor  <code>property</code>","text":"<pre><code>min_step_scale_factor: Any\n</code></pre> <p>Get minimum step scale factor.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.rel_tol","title":"rel_tol  <code>property</code>","text":"<pre><code>rel_tol: Any\n</code></pre> <p>Get relative error tolerance.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.step_safety_factor","title":"step_safety_factor  <code>property</code>","text":"<pre><code>step_safety_factor: Any\n</code></pre> <p>Get step safety factor.</p>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.adaptive","title":"adaptive  <code>builtin</code>","text":"<pre><code>adaptive(abs_tol: float, rel_tol: float) -&gt; IntegratorConfig\n</code></pre> <p>Create a configuration for adaptive-step integration.</p> <p>Parameters:</p> Name Type Description Default <code>abs_tol</code> <code>float</code> <p>Absolute error tolerance</p> required <code>rel_tol</code> <code>float</code> <p>Relative error tolerance</p> required <p>Returns:</p> Name Type Description <code>IntegratorConfig</code> <code>IntegratorConfig</code> <p>Configuration for adaptive-step integration</p> Example <pre><code>import brahe as bh\nconfig = bh.IntegratorConfig.adaptive(1e-9, 1e-6)\n</code></pre>"},{"location":"library_api/integrators/config.html#brahe.IntegratorConfig.fixed_step","title":"fixed_step  <code>builtin</code>","text":"<pre><code>fixed_step(step_size: float) -&gt; IntegratorConfig\n</code></pre> <p>Create a configuration for fixed-step integration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Fixed timestep in seconds</p> required <p>Returns:</p> Name Type Description <code>IntegratorConfig</code> <code>IntegratorConfig</code> <p>Configuration for fixed-step integration</p> Example <pre><code>import brahe as bh\nconfig = bh.IntegratorConfig.fixed_step(1.0)\n</code></pre>"},{"location":"library_api/integrators/config.html#brahe.AdaptiveStepResult","title":"AdaptiveStepResult","text":"<pre><code>AdaptiveStepResult()\n</code></pre> <p>Result from an adaptive integration step.</p> <p>Contains the new state, actual timestep used, error estimate, and suggested next step.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\nintegrator = bh.RKF45Integrator(2, dynamics)\nstate = np.array([1.0, 0.0])\n\nresult = integrator.step(0.0, state, 0.1)\nprint(f\"New state: {result.state}\")\nprint(f\"Step used: {result.dt_used}\")\nprint(f\"Error: {result.error_estimate}\")\nprint(f\"Next step: {result.dt_next}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/config.html#brahe.AdaptiveStepResult.dt_next","title":"dt_next  <code>property</code>","text":"<pre><code>dt_next: float\n</code></pre> <p>Get the suggested next timestep.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Suggested timestep for next iteration</p>"},{"location":"library_api/integrators/config.html#brahe.AdaptiveStepResult.dt_used","title":"dt_used  <code>property</code>","text":"<pre><code>dt_used: float\n</code></pre> <p>Get the actual timestep used.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Timestep actually used (may be smaller than requested)</p>"},{"location":"library_api/integrators/config.html#brahe.AdaptiveStepResult.error_estimate","title":"error_estimate  <code>property</code>","text":"<pre><code>error_estimate: float\n</code></pre> <p>Get the estimated truncation error.</p> <p>Returns:</p> Type Description <code>float</code> <p>float | None: Estimated local truncation error (None for fixed-step integrators)</p>"},{"location":"library_api/integrators/config.html#brahe.AdaptiveStepResult.state","title":"state  <code>property</code>","text":"<pre><code>state: ndarray\n</code></pre> <p>Get the new state vector.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>State vector at time t + dt_used</p>"},{"location":"library_api/integrators/config.html#see-also","title":"See Also","text":"<ul> <li>Configuration Guide - Detailed guide to tuning parameters</li> <li>Adaptive Stepping - Theory behind adaptive step control</li> <li>Integrators Module - Integrators module overview</li> </ul>"},{"location":"library_api/integrators/dp54.html","title":"DP54 Integrator","text":"<p>Dormand-Prince 5(4) adaptive integrator with FSAL optimization.</p>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator","title":"DP54Integrator","text":"<pre><code>DP54Integrator(dimension: int, dynamics_fn: callable, jacobian: Union[DAnalyticJacobian, DNumericalJacobian] = None, sensitivity: Any = None, control_fn: Any = None, config: IntegratorConfig = None)\n</code></pre> <p>Dormand-Prince 5(4) adaptive integrator (MATLAB's ode45).</p> <p>More efficient than RKF45 due to FSAL (First Same As Last) property. This is the industry-standard general-purpose adaptive integrator.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>State vector dimension</p> required <code>dynamics_fn</code> <code>callable</code> <p>Dynamics function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <code>jacobian</code> <code>DAnalyticJacobian or DNumericalJacobian</code> <p>Jacobian provider for variational matrix propagation</p> <code>None</code> <code>config</code> <code>IntegratorConfig</code> <p>Integration configuration</p> <code>None</code> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef dynamics(t, state):\n    return -state\n\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.DP54Integrator(dimension=1, dynamics_fn=dynamics, config=config)\n\n# Adaptive step (tolerances from config)\nresult = integrator.step(0.0, np.array([1.0]), 0.1)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Any\n</code></pre>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step(t: float, state: ndarray, dt: float) -&gt; AdaptiveStepResult\n</code></pre> <p>Perform one adaptive integration step.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>AdaptiveStepResult</code> <code>AdaptiveStepResult</code> <p>Result containing new state, actual dt used, error estimate, and suggested next dt</p>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator.step_with_sensmat","title":"step_with_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_sensmat(t: float, state: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state and sensitivity matrix with adaptive step control.</p> <p>Propagates the sensitivity matrix S that maps parameter uncertainties to state uncertainties. The sensitivity evolves according to dS/dt = A*S + B.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.DP54Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_sens, dt_used, error, dt_next = integrator.step_with_sensmat(\n    0.0, state, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator.step_with_varmat","title":"step_with_varmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat(t: float, state: ndarray, phi: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Perform one adaptive integration step with variational matrix.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix (dimension x dimension)</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, dt_used, error_estimate, dt_next)</p>"},{"location":"library_api/integrators/dp54.html#brahe.DP54Integrator.step_with_varmat_sensmat","title":"step_with_varmat_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat_sensmat(t: float, state: ndarray, phi: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state, variational matrix (STM), and sensitivity matrix with adaptive step control.</p> <p>Propagates both matrices simultaneously for complete uncertainty quantification: - STM (Phi): Maps initial state uncertainties to current state uncertainties - Sensitivity (S): Maps parameter uncertainties to state uncertainties</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix at time t (state_dim x state_dim)</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.DP54Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nphi = np.eye(6)\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_phi, new_sens, dt_used, error, dt_next = integrator.step_with_varmat_sensmat(\n    0.0, state, phi, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/dp54.html#see-also","title":"See Also","text":"<ul> <li>Adaptive-Step Integrators - Guide to adaptive integration</li> <li>Configuration - Tuning tolerances and step size control</li> <li>RKF45 Integrator - Alternative adaptive method</li> <li>Integrators Module - Overview of all integrators</li> </ul>"},{"location":"library_api/integrators/rk4.html","title":"RK4 Integrator","text":"<p>Classical 4th-order Runge-Kutta integrator for fixed-step integration.</p>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator","title":"RK4Integrator","text":"<pre><code>RK4Integrator(dimension: int, dynamics_fn: callable, jacobian: Union[DAnalyticJacobian, DNumericalJacobian] = None, sensitivity: Any = None, control_fn: Any = None, config: IntegratorConfig = None)\n</code></pre> <p>4th-order Runge-Kutta fixed-step integrator.</p> <p>Classical RK4 method with fixed timesteps. Provides good accuracy for most problems with 4th-order error convergence.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>State vector dimension</p> required <code>dynamics_fn</code> <code>callable</code> <p>Dynamics function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <code>jacobian</code> <code>DAnalyticJacobian or DNumericalJacobian</code> <p>Jacobian provider for variational matrix propagation</p> <code>None</code> <code>config</code> <code>IntegratorConfig</code> <p>Integration configuration</p> <code>None</code> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define dynamics: simple harmonic oscillator\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\n# Create integrator for 2D system\nintegrator = bh.RK4Integrator(2, dynamics)\n\n# Integrate one step\nstate = np.array([1.0, 0.0])\nnew_state = integrator.step(0.0, state, 0.01)\n\n# With variational matrix (state transition matrix)\ndef jacobian_fn(t, state):\n    return np.array([[0.0, 1.0], [-1.0, 0.0]])\n\njacobian = bh.DAnalyticJacobian(jacobian_fn)\nintegrator_varmat = bh.RK4Integrator(2, dynamics, jacobian)\n\nphi = np.eye(2)\nnew_state, new_phi = integrator_varmat.step_with_varmat(0.0, state, phi, 0.01)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Any\n</code></pre> <p>Get state vector dimension.</p>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step(t: float, state: ndarray, dt: float = None) -&gt; ndarray\n</code></pre> <p>Perform one integration step.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>dt</code> <code>float</code> <p>Timestep. If None, uses the step size from configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>State vector at time t + dt</p> Example <pre><code># Using explicit dt\nnew_state = integrator.step(0.0, state, 0.01)\n\n# Using config-based dt\nconfig = bh.IntegratorConfig.fixed_step(0.01)\nintegrator = bh.RK4Integrator(2, dynamics, config=config)\nnew_state = integrator.step(0.0, state)\n</code></pre>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator.step_with_sensmat","title":"step_with_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_sensmat(t: float, state: ndarray, sens: ndarray, params: ndarray, dt: float = None) -&gt; Tuple\n</code></pre> <p>Advance state and sensitivity matrix by one timestep.</p> <p>Propagates the sensitivity matrix S that maps parameter uncertainties to state uncertainties. The sensitivity evolves according to dS/dt = A*S + B.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Integration timestep</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_sensitivity)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nintegrator = bh.RK4Integrator(6, dynamics, jacobian, sensitivity)\nstate = np.array([...])\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_sens = integrator.step_with_sensmat(0.0, state, sens, params, 1.0)\n</code></pre>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator.step_with_varmat","title":"step_with_varmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat(t: float, state: ndarray, phi: ndarray, dt: float = None) -&gt; Tuple\n</code></pre> <p>Perform one integration step with variational matrix propagation.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix at time t (dimension \u00d7 dimension)</p> required <code>dt</code> <code>float</code> <p>Timestep. If None, uses the step size from configuration.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi) - State vector and STM at time t + dt</p> Example <pre><code>phi = np.eye(2)\n# Using explicit dt\nnew_state, new_phi = integrator.step_with_varmat(0.0, state, phi, 0.01)\n\n# Using config-based dt\nnew_state, new_phi = integrator.step_with_varmat(0.0, state, phi)\n</code></pre>"},{"location":"library_api/integrators/rk4.html#brahe.RK4Integrator.step_with_varmat_sensmat","title":"step_with_varmat_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat_sensmat(t: float, state: ndarray, phi: ndarray, sens: ndarray, params: ndarray, dt: float = None) -&gt; Tuple\n</code></pre> <p>Advance state, variational matrix (STM), and sensitivity matrix by one timestep.</p> <p>Propagates both matrices simultaneously for complete uncertainty quantification: - STM (Phi): Maps initial state uncertainties to current state uncertainties - Sensitivity (S): Maps parameter uncertainties to state uncertainties</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix at time t (state_dim x state_dim)</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Integration timestep</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, new_sensitivity)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nintegrator = bh.RK4Integrator(6, dynamics, jacobian, sensitivity)\nstate = np.array([...])\nphi = np.eye(6)\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_phi, new_sens = integrator.step_with_varmat_sensmat(\n    0.0, state, phi, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/rk4.html#see-also","title":"See Also","text":"<ul> <li>Fixed-Step Integrators - Detailed guide on fixed-step integration</li> <li>Integrators Module - Overview of all integrators</li> <li>Configuration - Integrator configuration reference</li> </ul>"},{"location":"library_api/integrators/rkf45.html","title":"RKF45 Integrator","text":"<p>Runge-Kutta-Fehlberg 4(5) adaptive integrator with embedded error estimation.</p>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator","title":"RKF45Integrator","text":"<pre><code>RKF45Integrator(dimension: int, dynamics_fn: callable, jacobian: Union[DAnalyticJacobian, DNumericalJacobian] = None, sensitivity: Any = None, control_fn: Any = None, config: IntegratorConfig = None)\n</code></pre> <p>Runge-Kutta-Fehlberg 4(5) adaptive integrator.</p> <p>Embedded 5th/4th order method with automatic step size control. The integrator uses error estimation from the embedded solution to adapt the timestep for efficiency and accuracy.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>State vector dimension</p> required <code>dynamics_fn</code> <code>callable</code> <p>Dynamics function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <code>jacobian</code> <code>DAnalyticJacobian or DNumericalJacobian</code> <p>Jacobian provider for variational matrix propagation</p> <code>None</code> <code>config</code> <code>IntegratorConfig</code> <p>Integration configuration</p> <code>None</code> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef dynamics(t, state):\n    # dy/dt = -y\n    return -state\n\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKF45Integrator(dimension=1, dynamics_fn=dynamics, config=config)\n\n# Adaptive step (tolerances from config)\nresult = integrator.step(0.0, np.array([1.0]), 0.1)\nprint(f\"New state: {result.state}\")\nprint(f\"Step used: {result.dt_used}\")\nprint(f\"Next step suggestion: {result.dt_next}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Any\n</code></pre> <p>Get state vector dimension.</p>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step(t: float, state: ndarray, dt: float) -&gt; AdaptiveStepResult\n</code></pre> <p>Perform one adaptive integration step.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>AdaptiveStepResult</code> <code>AdaptiveStepResult</code> <p>Result containing new state, actual dt used, error estimate, and suggested next dt</p>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator.step_with_sensmat","title":"step_with_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_sensmat(t: float, state: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state and sensitivity matrix with adaptive step control.</p> <p>Propagates the sensitivity matrix S that maps parameter uncertainties to state uncertainties. The sensitivity evolves according to dS/dt = A*S + B.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKF45Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_sens, dt_used, error, dt_next = integrator.step_with_sensmat(\n    0.0, state, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator.step_with_varmat","title":"step_with_varmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat(t: float, state: ndarray, phi: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Perform one adaptive integration step with variational matrix.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix (dimension x dimension)</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, dt_used, error_estimate, dt_next)</p>"},{"location":"library_api/integrators/rkf45.html#brahe.RKF45Integrator.step_with_varmat_sensmat","title":"step_with_varmat_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat_sensmat(t: float, state: ndarray, phi: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state, variational matrix (STM), and sensitivity matrix with adaptive step control.</p> <p>Propagates both matrices simultaneously for complete uncertainty quantification: - STM (Phi): Maps initial state uncertainties to current state uncertainties - Sensitivity (S): Maps parameter uncertainties to state uncertainties</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix at time t (state_dim x state_dim)</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKF45Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nphi = np.eye(6)\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_phi, new_sens, dt_used, error, dt_next = integrator.step_with_varmat_sensmat(\n    0.0, state, phi, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/rkf45.html#see-also","title":"See Also","text":"<ul> <li>Adaptive-Step Integrators - Guide to adaptive integration</li> <li>Configuration - Tuning tolerances and step size control</li> <li>DP54 Integrator - More efficient alternative</li> <li>Integrators Module - Overview of all integrators</li> </ul>"},{"location":"library_api/integrators/rkn1210.html","title":"RKN1210 Integrator","text":"<p>Runge-Kutta-Nystr\u00f6m 12(10) high-precision integrator specialized for second-order ODEs.</p>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator","title":"RKN1210Integrator","text":"<pre><code>RKN1210Integrator(dimension: int, dynamics_fn: callable, jacobian: Union[DAnalyticJacobian, DNumericalJacobian] = None, sensitivity: Any = None, config: IntegratorConfig = None)\n</code></pre> <p>RKN12(10) Runge-Kutta-Nystr\u00f6m adaptive integrator (EXPERIMENTAL).</p> <p>High-order specialized integrator for second-order ODEs (like orbital mechanics). More efficient and accurate than general-purpose methods for position-velocity systems.</p> <p>WARNING: This integrator is experimental and may have stability issues.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>State vector dimension (must be even: position + velocity)</p> required <code>dynamics_fn</code> <code>callable</code> <p>Dynamics function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <code>jacobian</code> <code>DAnalyticJacobian or DNumericalJacobian</code> <p>Jacobian provider for variational matrix propagation</p> <code>None</code> <code>config</code> <code>IntegratorConfig</code> <p>Integration configuration</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dimension is not even</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef dynamics(t, state):\n    # Two-body dynamics: [r, v] -&gt; [v, a]\n    r = state[:3]\n    v = state[3:]\n    r_norm = np.linalg.norm(r)\n    a = -bh.GM_EARTH / (r_norm**3) * r\n    return np.concatenate([v, a])\n\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKN1210Integrator(dimension=6, dynamics_fn=dynamics, config=config)\n\n# Adaptive step (tolerances from config)\nresult = integrator.step(0.0, state, 1.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator.dimension","title":"dimension  <code>property</code>","text":"<pre><code>dimension: Any\n</code></pre>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step(t: float, state: ndarray, dt: float) -&gt; AdaptiveStepResult\n</code></pre> <p>Perform one adaptive integration step.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t [position, velocity]</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>AdaptiveStepResult</code> <code>AdaptiveStepResult</code> <p>Result containing new state, actual dt used, error estimate, and suggested next dt</p>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator.step_with_sensmat","title":"step_with_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_sensmat(t: float, state: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state and sensitivity matrix with adaptive step control.</p> <p>Propagates the sensitivity matrix S that maps parameter uncertainties to state uncertainties. The sensitivity evolves according to dS/dt = A*S + B.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKN1210Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_sens, dt_used, error, dt_next = integrator.step_with_sensmat(\n    0.0, state, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator.step_with_varmat","title":"step_with_varmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat(t: float, state: ndarray, phi: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Perform one adaptive integration step with variational matrix.</p> <p>Tolerances are read from the integrator's configuration.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix (dimension x dimension)</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, dt_used, error_estimate, dt_next)</p>"},{"location":"library_api/integrators/rkn1210.html#brahe.RKN1210Integrator.step_with_varmat_sensmat","title":"step_with_varmat_sensmat  <code>method descriptor</code>","text":"<pre><code>step_with_varmat_sensmat(t: float, state: ndarray, phi: ndarray, sens: ndarray, params: ndarray, dt: float) -&gt; Tuple\n</code></pre> <p>Advance state, variational matrix (STM), and sensitivity matrix with adaptive step control.</p> <p>Propagates both matrices simultaneously for complete uncertainty quantification: - STM (Phi): Maps initial state uncertainties to current state uncertainties - Sensitivity (S): Maps parameter uncertainties to state uncertainties</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>phi</code> <code>ndarray</code> <p>State transition matrix at time t (state_dim x state_dim)</p> required <code>sens</code> <code>ndarray</code> <p>Sensitivity matrix at time t (state_dim x param_dim)</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector</p> required <code>dt</code> <code>float</code> <p>Requested timestep</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(new_state, new_phi, new_sensitivity, dt_used, error_estimate, dt_next)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup integrator with Jacobian and sensitivity providers\nconfig = bh.IntegratorConfig.adaptive(abs_tol=1e-9, rel_tol=1e-6)\nintegrator = bh.RKN1210Integrator(6, dynamics, jacobian, sensitivity, config)\nstate = np.array([...])\nphi = np.eye(6)\nsens = np.zeros((6, 2))  # 6 state dims, 2 params\nparams = np.array([1.0, 2.0])\n\nnew_state, new_phi, new_sens, dt_used, error, dt_next = integrator.step_with_varmat_sensmat(\n    0.0, state, phi, sens, params, 1.0\n)\n</code></pre>"},{"location":"library_api/integrators/rkn1210.html#see-also","title":"See Also","text":"<ul> <li>Adaptive-Step Integrators - Guide to adaptive integration</li> <li>Configuration - Tuning tolerances for high precision</li> <li>DP54 Integrator - More efficient for moderate tolerances</li> <li>Integrators Module - Overview of all integrators</li> </ul>"},{"location":"library_api/mathematics/index.html","title":"Mathematics Module","text":"<p>Module: <code>brahe.math</code></p> <p>The mathematics module provides mathematical utilities for numerical computations in Brahe.</p>"},{"location":"library_api/mathematics/index.html#module-contents","title":"Module Contents","text":"<ul> <li>Jacobian Computation - Analytical and numerical Jacobian matrix computation</li> <li>Sensitivity Computation - Analytical and numerical sensitivity matrix computation</li> </ul>"},{"location":"library_api/mathematics/index.html#see-also","title":"See Also","text":"<ul> <li>Mathematics User Guide - Conceptual introduction and usage examples</li> <li>Jacobian Computation Guide - Detailed guide on Jacobian usage</li> <li>Sensitivity Matrix Guide - Detailed guide on sensitivity computation</li> </ul>"},{"location":"library_api/mathematics/jacobian.html","title":"Jacobian Computation","text":"<p>Jacobian matrix computation utilities for numerical integration and variational equations.</p>"},{"location":"library_api/mathematics/jacobian.html#overview","title":"Overview","text":"<p>Brahe provides both analytical and numerical Jacobian computation through a unified interface. Jacobian matrices describe how a function's output changes with respect to its inputs, which is essential for orbit determination, uncertainty propagation, and trajectory optimization.</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.DifferenceMethod","title":"DifferenceMethod","text":"<pre><code>DifferenceMethod()\n</code></pre> <p>Finite difference method for numerical Jacobian approximation.</p> <p>Different methods trade off accuracy vs computational cost: - Forward: O(h) error, dimension+1 function evaluations - Central: O(h\u00b2) error, 2dimension function evaluations (more accurate) - Backward*: O(h) error, dimension+1 function evaluations</p> Example <pre><code>import brahe as bh\n\n# Use central differences (most accurate)\njacobian = bh.NumericalJacobian.central(dynamics_fn)\n\n# Or explicitly set the method\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_method(bh.DifferenceMethod.CENTRAL)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.DifferenceMethod.BACKWARD","title":"BACKWARD  <code>class-attribute</code>","text":"<pre><code>BACKWARD: Any = DifferenceMethod.Backward\n</code></pre> <p>Finite difference method for numerical Jacobian approximation.</p> <p>Different methods trade off accuracy vs computational cost: - Forward: O(h) error, dimension+1 function evaluations - Central: O(h\u00b2) error, 2dimension function evaluations (more accurate) - Backward*: O(h) error, dimension+1 function evaluations</p> Example <pre><code>import brahe as bh\n\n# Use central differences (most accurate)\njacobian = bh.NumericalJacobian.central(dynamics_fn)\n\n# Or explicitly set the method\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_method(bh.DifferenceMethod.CENTRAL)\n</code></pre>"},{"location":"library_api/mathematics/jacobian.html#brahe.DifferenceMethod.CENTRAL","title":"CENTRAL  <code>class-attribute</code>","text":"<pre><code>CENTRAL: Any = DifferenceMethod.Central\n</code></pre> <p>Finite difference method for numerical Jacobian approximation.</p> <p>Different methods trade off accuracy vs computational cost: - Forward: O(h) error, dimension+1 function evaluations - Central: O(h\u00b2) error, 2dimension function evaluations (more accurate) - Backward*: O(h) error, dimension+1 function evaluations</p> Example <pre><code>import brahe as bh\n\n# Use central differences (most accurate)\njacobian = bh.NumericalJacobian.central(dynamics_fn)\n\n# Or explicitly set the method\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_method(bh.DifferenceMethod.CENTRAL)\n</code></pre>"},{"location":"library_api/mathematics/jacobian.html#brahe.DifferenceMethod.FORWARD","title":"FORWARD  <code>class-attribute</code>","text":"<pre><code>FORWARD: Any = DifferenceMethod.Forward\n</code></pre> <p>Finite difference method for numerical Jacobian approximation.</p> <p>Different methods trade off accuracy vs computational cost: - Forward: O(h) error, dimension+1 function evaluations - Central: O(h\u00b2) error, 2dimension function evaluations (more accurate) - Backward*: O(h) error, dimension+1 function evaluations</p> Example <pre><code>import brahe as bh\n\n# Use central differences (most accurate)\njacobian = bh.NumericalJacobian.central(dynamics_fn)\n\n# Or explicitly set the method\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_method(bh.DifferenceMethod.CENTRAL)\n</code></pre>"},{"location":"library_api/mathematics/jacobian.html#brahe.PerturbationStrategy","title":"PerturbationStrategy","text":"<pre><code>PerturbationStrategy()\n</code></pre> <p>Strategy for computing perturbation sizes in finite differences.</p> <p>The choice of perturbation size balances truncation error (wants large h) vs roundoff error (wants small h). Different strategies suit different problems.</p> Example <pre><code>import brahe as bh\n\n# Adaptive perturbation (recommended for most cases)\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_adaptive(1.0, 1.0)\n\n# Fixed absolute perturbation for all components\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_fixed_offset(1e-6)\n\n# Percentage-based perturbation\njacobian = bh.NumericalJacobian.new(dynamics_fn).with_percentage(1e-6)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.PerturbationStrategy.adaptive","title":"adaptive  <code>builtin</code>","text":"<pre><code>adaptive(scale_factor: float = 1.0, min_value: float = 1.0) -&gt; PerturbationStrategy\n</code></pre> <p>Create an adaptive perturbation strategy.</p> <p>Parameters:</p> Name Type Description Default <code>scale_factor</code> <code>float</code> <p>Multiplier on sqrt(\u03b5), typically 1.0</p> <code>1.0</code> <code>min_value</code> <code>float</code> <p>Minimum reference value (prevents tiny perturbations near zero)</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>PerturbationStrategy</code> <code>PerturbationStrategy</code> <p>Adaptive perturbation strategy</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.PerturbationStrategy.fixed","title":"fixed  <code>builtin</code>","text":"<pre><code>fixed(offset: float) -&gt; PerturbationStrategy\n</code></pre> <p>Create a fixed absolute perturbation strategy.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>float</code> <p>Fixed perturbation for all state components</p> required <p>Returns:</p> Name Type Description <code>PerturbationStrategy</code> <code>PerturbationStrategy</code> <p>Fixed perturbation strategy</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.PerturbationStrategy.percentage","title":"percentage  <code>builtin</code>","text":"<pre><code>percentage(percentage: float) -&gt; PerturbationStrategy\n</code></pre> <p>Create a percentage-based perturbation strategy.</p> <p>Parameters:</p> Name Type Description Default <code>percentage</code> <code>float</code> <p>Percentage of state value to use as perturbation</p> required <p>Returns:</p> Name Type Description <code>PerturbationStrategy</code> <code>PerturbationStrategy</code> <p>Percentage perturbation strategy</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian","title":"NumericalJacobian","text":"<pre><code>NumericalJacobian(dynamics_fn: Any)\n</code></pre> <p>Numerical Jacobian provider for dynamic-sized systems using finite differences.</p> <p>Computes the Jacobian numerically by perturbing the state and evaluating the dynamics. Supports forward, central, and backward finite difference methods with various perturbation strategies.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Simple harmonic oscillator dynamics\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\n# Default: central differences with adaptive perturbations\njacobian = bh.NumericalJacobian.new(dynamics)\n\n# Or with custom settings:\njacobian = bh.NumericalJacobian.forward(dynamics).with_fixed_offset(1e-6)\n\nstate = np.array([1.0, 0.0])\njac_matrix = jacobian.compute(0.0, state)\nprint(jac_matrix)  # [[0, 1], [-1, 0]] approximately\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.backward","title":"backward  <code>builtin</code>","text":"<pre><code>backward(dynamics_fn: callable) -&gt; NumericalJacobian\n</code></pre> <p>Create with backward finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Jacobian provider using backward differences</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.central","title":"central  <code>builtin</code>","text":"<pre><code>central(dynamics_fn: callable) -&gt; NumericalJacobian\n</code></pre> <p>Create with central finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Jacobian provider using central differences</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(t: float, state: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the Jacobian matrix at the given time and state.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Jacobian matrix \u2202f/\u2202x (dimension \u00d7 dimension)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef dynamics(t, state):\n    return np.array([state[1], -state[0]])\n\njacobian = bh.NumericalJacobian.new(dynamics)\nstate = np.array([1.0, 0.5])\njac = jacobian.compute(0.0, state)\n# Expected: [[0, 1], [-1, 0]] approximately\n</code></pre>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.forward","title":"forward  <code>builtin</code>","text":"<pre><code>forward(dynamics_fn: callable) -&gt; NumericalJacobian\n</code></pre> <p>Create with forward finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Jacobian provider using forward differences</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.with_adaptive","title":"with_adaptive  <code>method descriptor</code>","text":"<pre><code>with_adaptive(scale_factor: float, min_value: float) -&gt; NumericalJacobian\n</code></pre> <p>Set adaptive perturbation with custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>scale_factor</code> <code>float</code> <p>Multiplier on sqrt(\u03b5), typically 1.0</p> required <code>min_value</code> <code>float</code> <p>Minimum reference value</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.with_fixed_offset","title":"with_fixed_offset  <code>method descriptor</code>","text":"<pre><code>with_fixed_offset(offset: float) -&gt; NumericalJacobian\n</code></pre> <p>Set fixed absolute perturbation for all components.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>float</code> <p>Fixed perturbation size</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.with_method","title":"with_method  <code>method descriptor</code>","text":"<pre><code>with_method(method: DifferenceMethod) -&gt; NumericalJacobian\n</code></pre> <p>Set the difference method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>DifferenceMethod</code> <p>Finite difference method to use</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.NumericalJacobian.with_percentage","title":"with_percentage  <code>method descriptor</code>","text":"<pre><code>with_percentage(percentage: float) -&gt; NumericalJacobian\n</code></pre> <p>Set percentage-based perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>percentage</code> <code>float</code> <p>Percentage of state value (e.g., 1e-6 for 0.0001%)</p> required <p>Returns:</p> Name Type Description <code>NumericalJacobian</code> <code>NumericalJacobian</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.AnalyticJacobian","title":"AnalyticJacobian","text":"<pre><code>AnalyticJacobian(jacobian_fn: Any)\n</code></pre> <p>Analytical Jacobian provider for dynamic-sized systems.</p> <p>Uses a user-provided function that directly computes the analytical Jacobian. This is the most accurate and efficient method when the analytical Jacobian is known.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Simple harmonic oscillator: dx/dt = v, dv/dt = -x\n# Jacobian is [[0, 1], [-1, 0]]\ndef jacobian_fn(t, state):\n    return np.array([[0.0, 1.0], [-1.0, 0.0]])\n\njacobian = bh.AnalyticJacobian.new(jacobian_fn)\nstate = np.array([1.0, 0.0])\njac = jacobian.compute(0.0, state)\nprint(jac)  # [[0, 1], [-1, 0]]\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/jacobian.html#brahe.AnalyticJacobian.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(t: float, state: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the Jacobian matrix at the given time and state.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Jacobian matrix \u2202f/\u2202x (dimension \u00d7 dimension)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef jacobian_fn(t, state):\n    return np.array([[0.0, 1.0], [-1.0, 0.0]])\n\njacobian = bh.AnalyticJacobian.new(jacobian_fn)\nstate = np.array([1.0, 0.5])\njac = jacobian.compute(0.0, state)\n</code></pre>"},{"location":"library_api/mathematics/jacobian.html#see-also","title":"See Also","text":"<ul> <li>Jacobian Computation Guide - Detailed usage examples and theory</li> <li>Mathematics Module - Mathematics module overview</li> </ul>"},{"location":"library_api/mathematics/sensitivity.html","title":"Sensitivity Computation","text":"<p>Sensitivity matrix computation utilities for parameter estimation and consider covariance analysis.</p>"},{"location":"library_api/mathematics/sensitivity.html#overview","title":"Overview","text":"<p>Brahe provides both analytical and numerical sensitivity computation through a unified interface. Sensitivity matrices describe how a function's output changes with respect to consider parameters (\\(\\partial f/\\partial p\\)), which is essential for orbit determination with consider parameters and covariance analysis.</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity","title":"NumericalSensitivity","text":"<pre><code>NumericalSensitivity(dynamics_fn: Any)\n</code></pre> <p>Numerical sensitivity provider for dynamic-sized systems using finite differences.</p> <p>Computes the sensitivity matrix \u2202f/\u2202p numerically by perturbing the parameters and evaluating the dynamics function.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Dynamics with consider parameters\ndef dynamics(t, state, params):\n    cd_area_m = params[0]\n    # ... compute derivatives using cd_area_m\n    return np.array([...])\n\nsensitivity = bh.NumericalSensitivity(dynamics)\nstate = np.array([7000e3, 0, 0, 0, 7.5e3, 0])\nparams = np.array([0.044])  # cd*A/m\nsens_matrix = sensitivity.compute(0.0, state, params)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.backward","title":"backward  <code>builtin</code>","text":"<pre><code>backward(dynamics_fn: callable) -&gt; NumericalSensitivity\n</code></pre> <p>Create with backward finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray, params: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Sensitivity provider using backward differences</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.central","title":"central  <code>builtin</code>","text":"<pre><code>central(dynamics_fn: callable) -&gt; NumericalSensitivity\n</code></pre> <p>Create with central finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray, params: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Sensitivity provider using central differences</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(t: float, state: ndarray, params: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the sensitivity matrix at the given time, state, and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>params</code> <code>ndarray</code> <p>Consider parameters</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Sensitivity matrix \u2202f/\u2202p (state_dim \u00d7 param_dim)</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.forward","title":"forward  <code>builtin</code>","text":"<pre><code>forward(dynamics_fn: callable) -&gt; NumericalSensitivity\n</code></pre> <p>Create with forward finite differences.</p> <p>Parameters:</p> Name Type Description Default <code>dynamics_fn</code> <code>callable</code> <p>Function with signature (t: float, state: ndarray, params: ndarray) -&gt; ndarray</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Sensitivity provider using forward differences</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.with_adaptive","title":"with_adaptive  <code>method descriptor</code>","text":"<pre><code>with_adaptive(scale_factor: float, min_value: float) -&gt; NumericalSensitivity\n</code></pre> <p>Set adaptive perturbation with custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>scale_factor</code> <code>float</code> <p>Multiplier on sqrt(\u03b5), typically 1.0</p> required <code>min_value</code> <code>float</code> <p>Minimum reference value</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.with_fixed_offset","title":"with_fixed_offset  <code>method descriptor</code>","text":"<pre><code>with_fixed_offset(offset: float) -&gt; NumericalSensitivity\n</code></pre> <p>Set fixed absolute perturbation for all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>float</code> <p>Fixed perturbation size</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.with_method","title":"with_method  <code>method descriptor</code>","text":"<pre><code>with_method(method: DifferenceMethod) -&gt; NumericalSensitivity\n</code></pre> <p>Set the difference method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>DifferenceMethod</code> <p>Finite difference method to use</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.NumericalSensitivity.with_percentage","title":"with_percentage  <code>method descriptor</code>","text":"<pre><code>with_percentage(percentage: float) -&gt; NumericalSensitivity\n</code></pre> <p>Set percentage-based perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>percentage</code> <code>float</code> <p>Percentage of parameter value (e.g., 1e-6 for 0.0001%)</p> required <p>Returns:</p> Name Type Description <code>NumericalSensitivity</code> <code>NumericalSensitivity</code> <p>Self for method chaining</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.AnalyticSensitivity","title":"AnalyticSensitivity","text":"<pre><code>AnalyticSensitivity(sensitivity_fn: Any)\n</code></pre> <p>Analytical sensitivity provider for dynamic-sized systems.</p> <p>Uses a user-provided function that directly computes the analytical sensitivity matrix.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ndef sensitivity_fn(t, state, params):\n    # Return \u2202f/\u2202p matrix\n    sens = np.zeros((6, 1))\n    # ... compute analytical sensitivity\n    return sens\n\nsensitivity = bh.AnalyticSensitivity(sensitivity_fn)\nstate = np.array([7000e3, 0, 0, 0, 7.5e3, 0])\nparams = np.array([0.044])\nsens_matrix = sensitivity.compute(0.0, state, params)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/mathematics/sensitivity.html#brahe.AnalyticSensitivity.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(t: float, state: ndarray, params: ndarray) -&gt; ndarray\n</code></pre> <p>Compute the sensitivity matrix at the given time, state, and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>Current time</p> required <code>state</code> <code>ndarray</code> <p>State vector at time t</p> required <code>params</code> <code>ndarray</code> <p>Consider parameters</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Sensitivity matrix \u2202f/\u2202p (state_dim \u00d7 param_dim)</p>"},{"location":"library_api/mathematics/sensitivity.html#see-also","title":"See Also","text":"<ul> <li>Sensitivity Matrix Guide - Detailed usage examples and theory</li> <li>Jacobian Computation - Related Jacobian computation utilities</li> <li>Mathematics Module - Mathematics module overview</li> </ul>"},{"location":"library_api/orbit_dynamics/index.html","title":"Orbital Dynamics Module","text":"<p>The orbital dynamics module provides functions for computing perturbation accelerations affecting satellite motion.</p> <p>For conceptual explanations and usage examples, see Orbital Dynamics in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/index.html#submodules","title":"Submodules","text":"<ul> <li>Gravity Models - Point-mass and spherical harmonic gravity</li> <li>Third-Body Perturbations - Sun, Moon, and planetary effects</li> <li>Atmospheric Drag - Drag force calculations</li> <li>Atmospheric Density Models - Density model implementations</li> <li>Solar Radiation Pressure - SRP and eclipse modeling</li> <li>Relativistic Effects - General relativistic corrections</li> <li>Ephemerides - Celestial body position calculations</li> </ul>"},{"location":"library_api/orbit_dynamics/atmospheric_density_models.html","title":"Atmospheric Density Models","text":"<p>Atmospheric density model implementations for drag calculations.</p>"},{"location":"library_api/orbit_dynamics/atmospheric_density_models.html#brahe.density_harris_priester","title":"density_harris_priester  <code>builtin</code>","text":"<pre><code>density_harris_priester(r_tod: ndarray, r_sun: ndarray) -&gt; float\n</code></pre> <p>Computes atmospheric density using the Harris-Priester model.</p> <p>The Harris-Priester model accounts for diurnal density variations caused by solar heating. Valid for altitudes between 100 km and 1000 km. Returns 0.0 outside this range.</p> <p>Parameters:</p> Name Type Description Default <code>r_tod</code> <code>ndarray</code> <p>Satellite position in true-of-date frame. Units: (m)</p> required <code>r_sun</code> <code>ndarray</code> <p>Sun position in true-of-date frame. Units: (m)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Atmospheric density at the satellite position. Units: (kg/m\u00b3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nr_sat = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\n\ndensity = bh.density_harris_priester(r_sat, r_sun)\nprint(f\"Density: {density:.2e} kg/m\u00b3\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/atmospheric_density_models.html#see-also","title":"See Also","text":"<ul> <li>Atmospheric Drag (Learn) - Conceptual explanation and examples</li> <li>Drag - Drag acceleration calculations</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/drag.html","title":"Atmospheric Drag","text":"<p>Atmospheric drag acceleration calculations.</p> <p>Note</p> <p>For conceptual explanations and examples, see Atmospheric Drag in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/drag.html#drag-acceleration","title":"Drag Acceleration","text":""},{"location":"library_api/orbit_dynamics/drag.html#brahe.accel_drag","title":"accel_drag  <code>builtin</code>","text":"<pre><code>accel_drag(x_object: ndarray, density: float, mass: float, area: float, drag_coefficient: float, T: ndarray) -&gt; ndarray\n</code></pre> <p>Compute acceleration due to atmospheric drag.</p> <p>Parameters:</p> Name Type Description Default <code>x_object</code> <code>ndarray</code> <p>Satellite state vector in inertial frame. Units: [m; m/s]</p> required <code>density</code> <code>float</code> <p>Atmospheric density. Units: (kg/m\u00b3)</p> required <code>mass</code> <code>float</code> <p>Spacecraft mass. Units: (kg)</p> required <code>area</code> <code>float</code> <p>Wind-facing cross-sectional area. Units: (m\u00b2)</p> required <code>drag_coefficient</code> <code>float</code> <p>Coefficient of drag (dimensionless)</p> required <code>T</code> <code>ndarray</code> <p>Rotation matrix from inertial to true-of-date frame (3x3)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to drag. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nx_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7500.0, 0.0])\ndensity = 1.0e-12\na_drag = bh.accel_drag(x_object, density, 1000.0, 1.0, 2.3, np.eye(3))\n</code></pre>"},{"location":"library_api/orbit_dynamics/drag.html#see-also","title":"See Also","text":"<ul> <li>Atmospheric Drag (Learn) - Conceptual explanation and examples</li> <li>Atmospheric Density Models - Density calculation functions</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/ephemerides.html","title":"Ephemerides","text":"<p>Celestial body position calculations for Sun, Moon, and planets.</p>"},{"location":"library_api/orbit_dynamics/ephemerides.html#analytical-models","title":"Analytical Models","text":""},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.sun_position","title":"sun_position  <code>builtin</code>","text":"<pre><code>sun_position(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Calculate the position of the Sun in the GCRF inertial frame using low-precision analytical methods.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Sun's position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Sun in the GCRF frame. Units: (m)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_sun = bh.sun_position(epc)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.moon_position","title":"moon_position  <code>builtin</code>","text":"<pre><code>moon_position(epc: Epoch) -&gt; ndarray\n</code></pre> <p>Calculate the position of the Moon in the GCRF inertial frame using low-precision analytical methods.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Moon's position</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Moon in the GCRF frame. Units: (m)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_moon = bh.moon_position(epc)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#de440-ephemerides","title":"DE440 Ephemerides","text":""},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.initialize_ephemeris","title":"initialize_ephemeris  <code>builtin</code>","text":"<pre><code>initialize_ephemeris() -&gt; None\n</code></pre> <p>Initialize the global ephemeris provider with the default DE440s kernel.</p> <p>This function downloads (or uses a cached copy of) the NAIF DE440s ephemeris kernel and sets it as the global Almanac provider. This initialization is optional - if not called, the Almanac will be lazily initialized on the first call to <code>sun_position_de()</code> or <code>moon_position_de()</code>.</p> <p>Calling this function explicitly is recommended when you want to: - Control when the kernel download/loading occurs (avoid latency on first use) - Handle initialization errors explicitly - Pre-load the kernel during application startup</p> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Successfully initialized the ephemeris</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If kernel download or loading failed</p> Example <pre><code>import brahe as bh\n\n# Initialize at application startup\nbh.initialize_ephemeris()\n\n# Now use DE440s ephemeris functions\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_sun = bh.sun_position_de(epc)\nr_moon = bh.moon_position_de(epc)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.sun_position_de","title":"sun_position_de  <code>builtin</code>","text":"<pre><code>sun_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of the Sun in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for solar position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Sun's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Sun in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_sun = bh.sun_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.moon_position_de","title":"moon_position_de  <code>builtin</code>","text":"<pre><code>moon_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of the Moon in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for lunar position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Moon's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Moon in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_moon = bh.moon_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.jupiter_position_de","title":"jupiter_position_de  <code>builtin</code>","text":"<pre><code>jupiter_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Jupiter in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Jupiter position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Jupiter's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Jupiter in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_jupiter = bh.jupiter_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.saturn_position_de","title":"saturn_position_de  <code>builtin</code>","text":"<pre><code>saturn_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Saturn in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Saturn position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Saturn's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Saturn in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_saturn = bh.saturn_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.mars_position_de","title":"mars_position_de  <code>builtin</code>","text":"<pre><code>mars_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Mars in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Mars position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Mars's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Mars in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_mars = bh.mars_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.uranus_position_de","title":"uranus_position_de  <code>builtin</code>","text":"<pre><code>uranus_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Uranus in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Uranus position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Uranus's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Uranus in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_uranus = bh.uranus_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.neptune_position_de","title":"neptune_position_de  <code>builtin</code>","text":"<pre><code>neptune_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Neptune in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Neptune position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Neptune's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Neptune in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_neptune = bh.neptune_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.venus_position_de","title":"venus_position_de  <code>builtin</code>","text":"<pre><code>venus_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Venus in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Venus position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Venus's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Venus in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_venus = bh.venus_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.mercury_position_de","title":"mercury_position_de  <code>builtin</code>","text":"<pre><code>mercury_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of Mercury in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Mercury position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Mercury's position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of Mercury in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_mercury = bh.mercury_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.solar_system_barycenter_position_de","title":"solar_system_barycenter_position_de  <code>builtin</code>","text":"<pre><code>solar_system_barycenter_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the position of the Solar System Barycenter in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>This function uses the high-precision NAIF DE ephemeris kernel (DE440s or DE440) for Solar System Barycenter position computation. The kernel is loaded once and cached in a global thread-safe context, making subsequent calls very efficient.</p> <p>If the ephemeris has not been initialized, it will be automatically loaded on the first call. For more control over initialization and error handling, use <code>initialize_ephemeris()</code> explicitly.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Solar System Barycenter position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Solar System Barycenter in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_ssb = bh.solar_system_barycenter_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#brahe.ssb_position_de","title":"ssb_position_de  <code>builtin</code>","text":"<pre><code>ssb_position_de(epc: Epoch, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Convenience alias for <code>solar_system_barycenter_position_de</code>.</p> <p>Calculate the position of the Solar System Barycenter in the GCRF inertial frame using NAIF DE ephemeris.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Solar System Barycenter position</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Position of the Solar System Barycenter in the GCRF frame. Units: (m)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the DE kernel cannot be loaded or ephemeris query fails</p> Example <pre><code>import brahe as bh\n\n# Optional: Pre-initialize for better error handling\nbh.initialize_ephemeris()\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_ssb = bh.ssb_position_de(epc, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/ephemerides.html#see-also","title":"See Also","text":"<ul> <li>Third-Body Perturbations - Third-body acceleration calculations</li> <li>Datasets: NAIF - DE440s ephemeris data</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/gravity.html","title":"Gravity Models","text":"<p>Gravity acceleration functions including point-mass and spherical harmonic models.</p> <p>Note</p> <p>For conceptual explanations and examples, see Gravity Models in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#point-mass-gravity","title":"Point-Mass Gravity","text":""},{"location":"library_api/orbit_dynamics/gravity.html#brahe.accel_point_mass_gravity","title":"accel_point_mass_gravity  <code>builtin</code>","text":"<pre><code>accel_point_mass_gravity(r_object: ndarray, r_central_body: ndarray, gm: float) -&gt; ndarray\n</code></pre> <p>Compute acceleration due to point-mass gravity.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object. Units: (m)</p> required <code>r_central_body</code> <code>ndarray</code> <p>Position vector of the central body. Units: (m)</p> required <code>gm</code> <code>float</code> <p>Gravitational parameter. Units: (m\u00b3/s\u00b2)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to gravity. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr_object = np.array([bh.R_EARTH, 0.0, 0.0])\nr_central_body = np.array([0.0, 0.0, 0.0])\na_grav = bh.accel_point_mass_gravity(r_object, r_central_body, bh.GM_EARTH)\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#spherical-harmonic-gravity","title":"Spherical Harmonic Gravity","text":""},{"location":"library_api/orbit_dynamics/gravity.html#brahe.accel_gravity_spherical_harmonics","title":"accel_gravity_spherical_harmonics  <code>builtin</code>","text":"<pre><code>accel_gravity_spherical_harmonics(r_eci: ndarray, R_i2b: ndarray, gravity_model: GravityModel, n_max: int, m_max: int) -&gt; ndarray\n</code></pre> <p>Compute acceleration due to spherical harmonic gravity model.</p> <p>This function computes the gravitational acceleration on an object using a spherical harmonic expansion of Earth's gravity field. It transforms the position to body-fixed coordinates, evaluates the spherical harmonics, and transforms the acceleration back to the inertial frame.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_eci.</p> <p>Parameters:</p> Name Type Description Default <code>r_eci</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) in ECI frame. Units: (m)</p> required <code>R_i2b</code> <code>ndarray</code> <p>Rotation matrix from ECI to body-fixed frame (3x3)</p> required <code>gravity_model</code> <code>GravityModel</code> <p>Gravity model to use</p> required <code>n_max</code> <code>int</code> <p>Maximum degree to evaluate (n_max &lt;= model.n_max)</p> required <code>m_max</code> <code>int</code> <p>Maximum order to evaluate (m_max &lt;= min(n_max, model.m_max))</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration in ECI frame. Units: (m/s\u00b2)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If n_max or m_max exceed model limits or if m_max &gt; n_max</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP for frame transformations\nbh.initialize_eop()\n\n# Load gravity model\nmodel = bh.GravityModel.from_model_type(bh.GravityModelType.JGM3)\n\n# Create test position\nr_eci = np.array([6525.919e3, 1710.416e3, 2508.886e3])\n\n# Get rotation matrix (or use identity for simplified case)\nR = np.eye(3)\n\n# Compute acceleration\na_grav = bh.accel_gravity_spherical_harmonics(r_eci, R, model, 20, 20)\nprint(f\"Acceleration: {a_grav} m/s\u00b2\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#gravity-model-class","title":"Gravity Model Class","text":""},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel","title":"GravityModel","text":"<pre><code>GravityModel()\n</code></pre> <p>Spherical harmonic gravity model for high-fidelity gravitational acceleration computation.</p> <p>This class represents a spherical harmonic expansion of Earth's gravitational potential, allowing for accurate modeling of Earth's non-uniform gravity field.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.gm","title":"gm  <code>property</code>","text":"<pre><code>gm: Any\n</code></pre> <p>Gravitational parameter. Units: (m\u00b3/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.m_max","title":"m_max  <code>property</code>","text":"<pre><code>m_max: Any\n</code></pre> <p>Maximum order of spherical harmonic expansion.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.model_errors","title":"model_errors  <code>property</code>","text":"<pre><code>model_errors: Any\n</code></pre> <p>Error estimation type.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.model_name","title":"model_name  <code>property</code>","text":"<pre><code>model_name: Any\n</code></pre> <p>Name of the gravity model.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.n_max","title":"n_max  <code>property</code>","text":"<pre><code>n_max: Any\n</code></pre> <p>Maximum degree of spherical harmonic expansion.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.normalization","title":"normalization  <code>property</code>","text":"<pre><code>normalization: Any\n</code></pre> <p>Coefficient normalization convention.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.radius","title":"radius  <code>property</code>","text":"<pre><code>radius: Any\n</code></pre> <p>Reference radius. Units: (m)</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.tide_system","title":"tide_system  <code>property</code>","text":"<pre><code>tide_system: Any\n</code></pre> <p>Tide system convention.</p>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.compute_spherical_harmonics","title":"compute_spherical_harmonics  <code>method descriptor</code>","text":"<pre><code>compute_spherical_harmonics(r_body: ndarray, n_max: int, m_max: int) -&gt; ndarray\n</code></pre> <p>Compute gravitational acceleration in body-fixed frame using spherical harmonics.</p> <p>Parameters:</p> Name Type Description Default <code>r_body</code> <code>ndarray</code> <p>Position vector in body-fixed frame. Units: (m)</p> required <code>n_max</code> <code>int</code> <p>Maximum degree to evaluate (n_max &lt;= model.n_max)</p> required <code>m_max</code> <code>int</code> <p>Maximum order to evaluate (m_max &lt;= min(n_max, model.m_max))</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration in body-fixed frame. Units: (m/s\u00b2)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If n_max or m_max exceed model limits or if m_max &gt; n_max</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmodel = bh.GravityModel.from_model_type(bh.GravityModelType.JGM3)\nr_body = np.array([6525.919e3, 1710.416e3, 2508.886e3])\n\n# Compute using 20x20 expansion\na_body = model.compute_spherical_harmonics(r_body, 20, 20)\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str) -&gt; GravityModel\n</code></pre> <p>Load gravity model from a .gfc file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the .gfc gravity model file</p> required <p>Returns:</p> Name Type Description <code>GravityModel</code> <code>GravityModel</code> <p>Loaded gravity model</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file cannot be loaded or parsed</p> Example <pre><code>import brahe as bh\n\n# Load custom gravity model from file\nmodel = bh.GravityModel.from_file(\"path/to/model.gfc\")\nprint(f\"Model: {model.model_name}, {model.n_max}x{model.m_max}\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.from_model_type","title":"from_model_type  <code>builtin</code>","text":"<pre><code>from_model_type(model_type: GravityModelType) -&gt; GravityModel\n</code></pre> <p>Load a gravity model from a GravityModelType.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>GravityModelType</code> <p>Which model to load (packaged or from file)</p> required <p>Returns:</p> Name Type Description <code>GravityModel</code> <code>GravityModel</code> <p>Loaded gravity model</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file loading fails (for FromFile variant)</p> Example <pre><code>import brahe as bh\n\n# Load JGM3 70x70 model\nmodel = bh.GravityModel.from_model_type(bh.GravityModelType.JGM3)\nprint(f\"Loaded {model.model_name}\")\n\n# Load EGM2008 360x360 model\nmodel_hifi = bh.GravityModel.from_model_type(bh.GravityModelType.EGM2008_360)\n\n# Load from custom file\ncustom_type = bh.GravityModelType.from_file(\"/path/to/model.gfc\")\nmodel_custom = bh.GravityModel.from_model_type(custom_type)\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(n: int, m: int) -&gt; Tuple\n</code></pre> <p>Get spherical harmonic coefficients for a specific degree and order.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Degree (0 &lt;= n &lt;= n_max)</p> required <code>m</code> <code>int</code> <p>Order (0 &lt;= m &lt;= min(n, m_max))</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(C_nm, S_nm) coefficients</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If n or m are out of bounds</p> Example <pre><code>import brahe as bh\n\nmodel = bh.GravityModel.from_model_type(bh.GravityModelType.JGM3)\n\n# Get J2 coefficient (C20)\nc20, s20 = model.get(2, 0)\nprint(f\"J2 = {-c20}\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#brahe.GravityModel.set_max_degree_order","title":"set_max_degree_order  <code>method descriptor</code>","text":"<pre><code>set_max_degree_order(n: int, m: int) -&gt; Any\n</code></pre> <p>Truncate the gravity model to a smaller degree and order to save memory.</p> <p>This method resizes the internal coefficient matrix in-place, discarding coefficients beyond the specified limits. This is useful when loading a high-fidelity model but only needing a lower-degree expansion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>New maximum degree (must be &lt;= current n_max)</p> required <code>m</code> <code>int</code> <p>New maximum order (must be &lt;= min(n, current m_max))</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If m &gt; n or if n/m exceed current model limits</p> Example <pre><code>import brahe as bh\n\n# Load full EGM2008 360x360 model\nmodel = bh.GravityModel.from_model_type(bh.GravityModelType.EGM2008_360)\nprint(f\"Before: {model.n_max}x{model.m_max}\")  # 360x360\n\n# Truncate to 70x70 to save memory\nmodel.set_max_degree_order(70, 70)\nprint(f\"After: {model.n_max}x{model.m_max}\")  # 70x70\n</code></pre>"},{"location":"library_api/orbit_dynamics/gravity.html#see-also","title":"See Also","text":"<ul> <li>Gravity Models (Learn) - Conceptual explanation and examples</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/relativity.html","title":"Relativistic Effects","text":"<p>General relativistic corrections to satellite acceleration.</p> <p>Note</p> <p>For conceptual explanations and examples, see Relativistic Effects in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/relativity.html#relativistic-acceleration","title":"Relativistic Acceleration","text":""},{"location":"library_api/orbit_dynamics/relativity.html#brahe.accel_relativity","title":"accel_relativity  <code>builtin</code>","text":"<pre><code>accel_relativity(x_object: ndarray) -&gt; ndarray\n</code></pre> <p>Calculate acceleration due to special and general relativity.</p> <p>Parameters:</p> Name Type Description Default <code>x_object</code> <code>ndarray</code> <p>State vector of the object in ECI frame. Units: [m; m/s]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to relativistic effects. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nx_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7500.0, 0.0])\na_rel = bh.accel_relativity(x_object)\n</code></pre>"},{"location":"library_api/orbit_dynamics/relativity.html#see-also","title":"See Also","text":"<ul> <li>Relativistic Effects (Learn) - Conceptual explanation and examples</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html","title":"Solar Radiation Pressure","text":"<p>Solar radiation pressure acceleration and eclipse modeling.</p> <p>Note</p> <p>For conceptual explanations and examples, see Solar Radiation Pressure in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#srp-acceleration","title":"SRP Acceleration","text":""},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#brahe.accel_solar_radiation_pressure","title":"accel_solar_radiation_pressure  <code>builtin</code>","text":"<pre><code>accel_solar_radiation_pressure(r_object: ndarray, r_sun: ndarray, mass: float, cr: float, area: float, p0: float) -&gt; ndarray\n</code></pre> <p>Calculate acceleration due to solar radiation pressure.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object. Units: (m)</p> required <code>r_sun</code> <code>ndarray</code> <p>Position vector of the sun. Units: (m)</p> required <code>mass</code> <code>float</code> <p>Mass of the object. Units: (kg)</p> required <code>cr</code> <code>float</code> <p>Coefficient of reflectivity (dimensionless)</p> required <code>area</code> <code>float</code> <p>Cross-sectional area of the object. Units: (m\u00b2)</p> required <code>p0</code> <code>float</code> <p>Solar radiation pressure at 1 AU. Units: (N/m\u00b2)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to solar radiation pressure. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\na_srp = bh.accel_solar_radiation_pressure(r_object, r_sun, 1000.0, 1.8, 1.0, 4.56e-6)\n</code></pre>"},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#eclipse-modeling","title":"Eclipse Modeling","text":""},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#brahe.eclipse_conical","title":"eclipse_conical  <code>builtin</code>","text":"<pre><code>eclipse_conical(r_object: ndarray, r_sun: ndarray) -&gt; float\n</code></pre> <p>Calculate the fraction of the object illuminated by the sun using a conical (penumbral) shadow model.</p> <p>The conical shadow model accounts for the finite size of both the Sun and Earth, modeling the penumbra region where the satellite receives partial sunlight. This is more accurate than the cylindrical model but computationally more expensive.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in ECI frame. Units: (m)</p> required <code>r_sun</code> <code>ndarray</code> <p>Position vector of the sun in ECI frame. Units: (m)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Illumination fraction between 0.0 and 1.0. Values: 0.0 (full shadow/umbra),    0.0-1.0 (partial shadow/penumbra), 1.0 (full sunlight)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nr_sat = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\n\nnu = bh.eclipse_conical(r_sat, r_sun)\nprint(f\"Illumination fraction: {nu}\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#brahe.eclipse_cylindrical","title":"eclipse_cylindrical  <code>builtin</code>","text":"<pre><code>eclipse_cylindrical(r_object: ndarray, r_sun: ndarray) -&gt; float\n</code></pre> <p>Calculate the fraction of the object illuminated by the sun using a cylindrical shadow model.</p> <p>The cylindrical shadow model is a simplified approach that assumes Earth casts a cylindrical shadow parallel to the Sun-Earth line. This model is computationally efficient and provides binary shadow determination (fully lit or fully shadowed, no penumbra).</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in ECI frame. Units: (m)</p> required <code>r_sun</code> <code>ndarray</code> <p>Position vector of the sun in ECI frame. Units: (m)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Illumination fraction, either 0.0 (full shadow) or 1.0 (full sunlight).    No partial illumination is returned by this model.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nr_sat = np.array([bh.R_EARTH + 400e3, 0.0, 0.0])\nr_sun = bh.sun_position(epc)\n\nnu = bh.eclipse_cylindrical(r_sat, r_sun)\nif nu == 0.0:\n    print(\"Satellite is in Earth's shadow\")\nelse:\n    print(\"Satellite is in sunlight\")\n</code></pre>"},{"location":"library_api/orbit_dynamics/solar_radiation_pressure.html#see-also","title":"See Also","text":"<ul> <li>Solar Radiation Pressure (Learn) - Conceptual explanation and examples</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbit_dynamics/third_body.html","title":"Third-Body Perturbations","text":"<p>Third-body gravitational perturbation accelerations from the Sun, Moon, and planets.</p> <p>Note</p> <p>For conceptual explanations and examples, see Third-Body Perturbations in the Learn section.</p>"},{"location":"library_api/orbit_dynamics/third_body.html#analytical-models","title":"Analytical Models","text":""},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_sun","title":"accel_third_body_sun  <code>builtin</code>","text":"<pre><code>accel_third_body_sun(epc: Epoch, r_object: ndarray) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to the Sun on an object using low-precision analytical ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Sun's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to the Sun. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\n\n# Using position vector\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\na = bh.accel_third_body_sun(epc, r_object)\n\n# Or using state vector directly\nx_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7500.0, 0.0])\na = bh.accel_third_body_sun(epc, x_object)\n</code></pre>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_sun_de","title":"accel_third_body_sun_de  <code>builtin</code>","text":"<pre><code>accel_third_body_sun_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to the Sun on an object using DE high-precision ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Sun's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to the Sun. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_ephemeris()\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\na = bh.accel_third_body_sun_de(epc, r_object, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/third_body.html#moon-perturbations","title":"Moon Perturbations","text":""},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_moon","title":"accel_third_body_moon  <code>builtin</code>","text":"<pre><code>accel_third_body_moon(epc: Epoch, r_object: ndarray) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to the Moon on an object using low-precision analytical ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Moon's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to the Moon. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\na = bh.accel_third_body_moon(epc, r_object)\n</code></pre>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_moon_de","title":"accel_third_body_moon_de  <code>builtin</code>","text":"<pre><code>accel_third_body_moon_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to the Moon on an object using DE high-precision ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Moon's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to the Moon. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_ephemeris()\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\na = bh.accel_third_body_moon_de(epc, r_object, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_sun_de","title":"accel_third_body_sun_de  <code>builtin</code>","text":"<pre><code>accel_third_body_sun_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to the Sun on an object using DE high-precision ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate the Sun's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Ephemeris source to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to the Sun. Units: (m/s\u00b2)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_ephemeris()\nepc = bh.Epoch.from_date(2024, 2, 25, bh.TimeSystem.UTC)\nr_object = np.array([bh.R_EARTH + 500e3, 0.0, 0.0])\na = bh.accel_third_body_sun_de(epc, r_object, bh.EphemerisSource.DE440s)\n</code></pre>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_mercury_de","title":"accel_third_body_mercury_de  <code>builtin</code>","text":"<pre><code>accel_third_body_mercury_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Mercury on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Mercury's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Mercury. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_venus_de","title":"accel_third_body_venus_de  <code>builtin</code>","text":"<pre><code>accel_third_body_venus_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Venus on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Venus's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Venus. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_mars_de","title":"accel_third_body_mars_de  <code>builtin</code>","text":"<pre><code>accel_third_body_mars_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Mars on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Mars's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Mars. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_jupiter_de","title":"accel_third_body_jupiter_de  <code>builtin</code>","text":"<pre><code>accel_third_body_jupiter_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Jupiter on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Jupiter's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Jupiter. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_saturn_de","title":"accel_third_body_saturn_de  <code>builtin</code>","text":"<pre><code>accel_third_body_saturn_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Saturn on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Saturn's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Saturn. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_uranus_de","title":"accel_third_body_uranus_de  <code>builtin</code>","text":"<pre><code>accel_third_body_uranus_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Uranus on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Uranus's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Uranus. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#brahe.accel_third_body_neptune_de","title":"accel_third_body_neptune_de  <code>builtin</code>","text":"<pre><code>accel_third_body_neptune_de(epc: Epoch, r_object: ndarray, source: EphemerisSource) -&gt; ndarray\n</code></pre> <p>Calculate the acceleration due to Neptune on an object using DE ephemerides.</p> <p>Accepts either a 3D position vector or a 6D state vector for r_object.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch at which to calculate Neptune's position</p> required <code>r_object</code> <code>ndarray</code> <p>Position (length 3) or state (length 6) of the object in the GCRF frame. Units: (m)</p> required <code>source</code> <code>EphemerisSource</code> <p>Which ephemeris kernel to use (DE440s or DE440)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Acceleration due to Neptune. Units: (m/s\u00b2)</p>"},{"location":"library_api/orbit_dynamics/third_body.html#see-also","title":"See Also","text":"<ul> <li>Third-Body Perturbations (Learn) - Conceptual explanation and examples</li> <li>Ephemerides - Sun and Moon position functions</li> <li>Orbital Dynamics Module - Complete orbit dynamics API reference</li> </ul>"},{"location":"library_api/orbits/index.html","title":"Orbits","text":"<p>Module: <code>brahe.orbits</code></p> <p>Comprehensive tools for orbital mechanics computations and TLE handling.</p>"},{"location":"library_api/orbits/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Keplerian Elements - Functions for computing orbital properties and converting between anomaly types</li> <li>Mean Elements - Mean-osculating Keplerian element conversions</li> <li>Two-Line Elements (TLE) - TLE parsing, validation, and conversion utilities</li> <li>Walker Constellations - Generator for Walker Delta and Star constellation patterns</li> <li>Enumerations - Orbit-related enumerations (OrbitRepresentation, OrbitFrame, etc.)</li> </ul> <p>Note: Orbit propagators have been moved to the <code>brahe.propagators</code> module.</p>"},{"location":"library_api/orbits/altitude_functions.html","title":"Altitude and Period Functions","text":"<p>Functions for computing orbital altitudes and periods from orbital elements or state vectors.</p>"},{"location":"library_api/orbits/altitude_functions.html#orbital-period-from-state","title":"Orbital Period from State","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.orbital_period_from_state","title":"orbital_period_from_state  <code>builtin</code>","text":"<pre><code>orbital_period_from_state(state_eci: ndarray, gm: float) -&gt; float\n</code></pre> <p>Computes orbital period from an ECI state vector using the vis-viva equation.</p> <p>This function uses the vis-viva equation to compute the semi-major axis from the position and velocity, then calculates the orbital period.</p> <p>Parameters:</p> Name Type Description Default <code>state_eci</code> <code>ndarray</code> <p>ECI state vector [x, y, z, vx, vy, vz] in meters and meters/second.</p> required <code>gm</code> <code>float</code> <p>Gravitational parameter in m\u00b3/s\u00b2. Use GM_EARTH for Earth orbits.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Orbital period in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a circular orbit state at 500 km altitude\nr = bh.R_EARTH + 500e3\nv = np.sqrt(bh.GM_EARTH / r)\nstate_eci = np.array([r, 0, 0, 0, v, 0])\n\n# Compute orbital period from state\nperiod = bh.orbital_period_from_state(state_eci, bh.GM_EARTH)\nprint(f\"Period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#altitude-functions","title":"Altitude Functions","text":""},{"location":"library_api/orbits/altitude_functions.html#periapsis-and-apoapsis-general","title":"Periapsis and Apoapsis (General)","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.periapsis_altitude","title":"periapsis_altitude  <code>builtin</code>","text":"<pre><code>periapsis_altitude(a_or_oe: Union[float, array], e: float = None, *, r_body: float) -&gt; float\n</code></pre> <p>Calculate the altitude above a body's surface at periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>r_body</code> <code>float</code> <p>(keyword-only) The radius of the central body in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above the body's surface at periapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 500e3  # 500 km mean altitude\ne = 0.01  # slight eccentricity\nalt_peri = bh.periapsis_altitude(a, e, bh.R_EARTH)\nprint(f\"Periapsis altitude: {alt_peri/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 500e3, 0.01, np.radians(45), 0, 0, 0]\nalt_peri = bh.periapsis_altitude(oe, r_body=bh.R_EARTH)\nprint(f\"Periapsis altitude: {alt_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#brahe.apoapsis_altitude","title":"apoapsis_altitude  <code>builtin</code>","text":"<pre><code>apoapsis_altitude(a_or_oe: Union[float, array], e: float = None, *, r_body: float) -&gt; float\n</code></pre> <p>Calculate the altitude above a body's surface at apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>r_body</code> <code>float</code> <p>(keyword-only) The radius of the central body in meters.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above the body's surface at apoapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_MOON + 100e3  # 100 km mean altitude\ne = 0.05  # moderate eccentricity\nalt_apo = bh.apoapsis_altitude(a, e, bh.R_MOON)\nprint(f\"Apoapsis altitude: {alt_apo/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_MOON + 100e3, 0.05, np.radians(30), 0, 0, 0]\nalt_apo = bh.apoapsis_altitude(oe, r_body=bh.R_MOON)\nprint(f\"Apoapsis altitude: {alt_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#perigee-and-apogee-earth-specific","title":"Perigee and Apogee (Earth-Specific)","text":""},{"location":"library_api/orbits/altitude_functions.html#brahe.perigee_altitude","title":"perigee_altitude  <code>builtin</code>","text":"<pre><code>perigee_altitude(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the altitude above Earth's surface at perigee.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above Earth's surface at perigee in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 420e3  # 420 km mean altitude\ne = 0.0005  # very nearly circular\nalt = bh.perigee_altitude(a, e)\nprint(f\"Perigee altitude: {alt/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 420e3, 0.0005, np.radians(51.6), 0, 0, 0]\nalt = bh.perigee_altitude(oe)\nprint(f\"Perigee altitude: {alt/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/altitude_functions.html#brahe.apogee_altitude","title":"apogee_altitude  <code>builtin</code>","text":"<pre><code>apogee_altitude(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the altitude above Earth's surface at apogee.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The altitude above Earth's surface at apogee in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 26554000.0  # ~26554 km semi-major axis\ne = 0.7  # highly eccentric\nalt = bh.apogee_altitude(a, e)\nprint(f\"Apogee altitude: {alt/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [26554000.0, 0.7, np.radians(63.4), 0, 0, 0]\nalt = bh.apogee_altitude(oe)\nprint(f\"Apogee altitude: {alt/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/enums.html","title":"Orbit Enumerations","text":"<p>Enumerations for specifying orbit representation types and reference frames.</p>"},{"location":"library_api/orbits/enums.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies the type of orbital elements being used.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation","title":"OrbitRepresentation","text":"<pre><code>OrbitRepresentation()\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.CARTESIAN","title":"CARTESIAN  <code>class-attribute</code>","text":"<pre><code>CARTESIAN: Any = OrbitRepresentation(Cartesian)\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.KEPLERIAN","title":"KEPLERIAN  <code>class-attribute</code>","text":"<pre><code>KEPLERIAN: Any = OrbitRepresentation(Keplerian)\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#orbitframe","title":"OrbitFrame","text":""},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame","title":"OrbitFrame","text":"<pre><code>OrbitFrame()\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECEF","title":"ECEF  <code>class-attribute</code>","text":"<pre><code>ECEF: Any = OrbitFrame(Earth-Centered Earth-Fixed)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECI","title":"ECI  <code>class-attribute</code>","text":"<pre><code>ECI: Any = OrbitFrame(Earth-Centered Inertial)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.EME2000","title":"EME2000  <code>class-attribute</code>","text":"<pre><code>EME2000: Any = OrbitFrame(Earth Mean Equator and Equinox of J2000.0)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.GCRF","title":"GCRF  <code>class-attribute</code>","text":"<pre><code>GCRF: Any = OrbitFrame(Geocentric Celestial Reference Frame)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ITRF","title":"ITRF  <code>class-attribute</code>","text":"<pre><code>ITRF: Any = OrbitFrame(International Terrestrial Reference Frame)\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get the full name of the reference frame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable frame name</p>"},{"location":"library_api/orbits/enums.html#interpolationmethod","title":"InterpolationMethod","text":""},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod","title":"InterpolationMethod","text":"<pre><code>InterpolationMethod()\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.HERMITE_CUBIC","title":"HERMITE_CUBIC  <code>class-attribute</code>","text":"<pre><code>HERMITE_CUBIC: Any = InterpolationMethod.HERMITE_CUBIC\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.HERMITE_QUINTIC","title":"HERMITE_QUINTIC  <code>class-attribute</code>","text":"<pre><code>HERMITE_QUINTIC: Any = InterpolationMethod.HERMITE_QUINTIC\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.LINEAR","title":"LINEAR  <code>class-attribute</code>","text":"<pre><code>LINEAR: Any = InterpolationMethod.LINEAR\n</code></pre> <p>Python bindings for trajectory traits and orbital trajectory. Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.degree","title":"degree  <code>property</code>","text":"<pre><code>degree: int\n</code></pre> <p>Get the polynomial degree for Lagrange interpolation.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: The degree if this is a Lagrange method, None otherwise</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.min_points_required","title":"min_points_required  <code>property</code>","text":"<pre><code>min_points_required: int\n</code></pre> <p>Get the minimum number of data points required for this interpolation method.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Minimum number of points required</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.lagrange","title":"lagrange  <code>staticmethod</code>","text":"<pre><code>lagrange(degree: int) -&gt; InterpolationMethod\n</code></pre> <p>Create a Lagrange polynomial interpolation method.</p> <p>Lagrange interpolation requires <code>degree + 1</code> data points. Higher degrees provide more accuracy but can oscillate (Runge's phenomenon) for poorly distributed points.</p> <p>Parameters:</p> Name Type Description Default <code>degree</code> <code>int</code> <p>Polynomial degree for Lagrange interpolation (must be &gt;= 1)</p> required <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Lagrange interpolation method with specified degree</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If degree is less than 1</p> Example <pre><code>import brahe as bh\nmethod = bh.InterpolationMethod.lagrange(3)  # Cubic Lagrange\n</code></pre>"},{"location":"library_api/orbits/enums.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator</li> <li>Trajectories</li> </ul>"},{"location":"library_api/orbits/keplerian.html","title":"Keplerian Elements","text":"<p>Functions for working with Keplerian orbital elements and computing orbital properties.</p>"},{"location":"library_api/orbits/keplerian.html#orbital-properties","title":"Orbital Properties","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis","title":"semimajor_axis  <code>builtin</code>","text":"<pre><code>semimajor_axis(n: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from Earth given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis from mean motion (typical LEO satellite)\nn = 0.001027  # radians/second (~15 revolutions/day)\na = bh.semimajor_axis(n, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_general","title":"semimajor_axis_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_general(n: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from a general body given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for Jupiter orbiter\nn = 0.0001  # radians/second\na = bh.semimajor_axis_general(n, bh.GM_JUPITER, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period","title":"semimajor_axis_from_orbital_period  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period(period: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for a 90-minute orbit\nperiod = 90 * 60.0  # 90 minutes in seconds\na = bh.semimajor_axis_from_orbital_period(period)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period_general","title":"semimajor_axis_from_orbital_period_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period_general(period: float, gm: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period for a general body.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for 2-hour Venus orbit\nperiod = 2 * 3600.0  # 2 hours in seconds\na = bh.semimajor_axis_from_orbital_period_general(period, bh.GM_VENUS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion","title":"mean_motion  <code>builtin</code>","text":"<pre><code>mean_motion(a_or_oe: Union[float, array], angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = bh.R_EARTH + 35786e3\nn = bh.mean_motion(a, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 35786e3, 0.001, np.radians(0), 0, 0, 0]\nn = bh.mean_motion(oe, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion_general","title":"mean_motion_general  <code>builtin</code>","text":"<pre><code>mean_motion_general(a_or_oe: Union[float, array], gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around a general body given a semi-major axis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = 4000000.0  # 4000 km semi-major axis\nn = bh.mean_motion_general(a, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n\n# Using Keplerian elements vector\noe = [4000000.0, 0.01, np.radians(30), 0, 0, 0]\nn = bh.mean_motion_general(oe, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period","title":"orbital_period  <code>builtin</code>","text":"<pre><code>orbital_period(a_or_oe: Union[float, array]) -&gt; float\n</code></pre> <p>Computes the orbital period of an object around Earth.</p> <p>Uses rastro.constants.GM_EARTH as the standard gravitational parameter for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = bh.R_EARTH + 400e3\nperiod = bh.orbital_period(a)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 400e3, 0.001, np.radians(51.6), 0, 0, 0]\nperiod = bh.orbital_period(oe)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period_general","title":"orbital_period_general  <code>builtin</code>","text":"<pre><code>orbital_period_general(a_or_oe: Union[float, array], gm: float) -&gt; float\n</code></pre> <p>Computes the orbital period of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> will be extracted.</p> required <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar semi-major axis\na = 1900000.0  # 1900 km semi-major axis\nperiod = bh.orbital_period_general(a, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n\n# Using Keplerian elements vector\noe = [1900000.0, 0.01, np.radians(45), 0, 0, 0]\nperiod = bh.orbital_period_general(oe, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_distance","title":"periapsis_distance  <code>builtin</code>","text":"<pre><code>periapsis_distance(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at periapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_peri = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [8000000.0, 0.2, np.radians(45), 0, 0, 0]\nr_peri = bh.periapsis_distance(oe)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_distance","title":"apoapsis_distance  <code>builtin</code>","text":"<pre><code>apoapsis_distance(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at apoapsis in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_apo = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n\n# Using Keplerian elements vector\noe = [8000000.0, 0.2, np.radians(45), 0, 0, 0]\nr_apo = bh.apoapsis_distance(oe)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_velocity","title":"periapsis_velocity  <code>builtin</code>","text":"<pre><code>periapsis_velocity(a_or_oe: Union[float, array], e: float = None, *, gm: float) -&gt; float\n</code></pre> <p>Computes the periapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at periapsis in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 5e11  # 5 AU semi-major axis (meters)\ne = 0.95  # highly elliptical\nv_peri = bh.periapsis_velocity(a, e, bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n\n# Using Keplerian elements vector\noe = [5e11, 0.95, np.radians(10), 0, 0, 0]\nv_peri = bh.periapsis_velocity(oe, gm=bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_velocity","title":"apoapsis_velocity  <code>builtin</code>","text":"<pre><code>apoapsis_velocity(a_or_oe: Union[float, array], e: float = None, *, gm: float) -&gt; float\n</code></pre> <p>Computes the apoapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>gm</code> <code>float</code> <p>(keyword-only) The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apoapsis in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 10000000.0  # 10000 km semi-major axis\ne = 0.3\nv_apo = bh.apoapsis_velocity(a, e, bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n\n# Using Keplerian elements vector\noe = [10000000.0, 0.3, np.radians(30), 0, 0, 0]\nv_apo = bh.apoapsis_velocity(oe, gm=bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.perigee_velocity","title":"perigee_velocity  <code>builtin</code>","text":"<pre><code>perigee_velocity(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Computes the perigee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at perigee in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 26554000.0  # meters\ne = 0.72  # high eccentricity\nv_peri = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n\n# Using Keplerian elements vector\noe = [26554000.0, 0.72, np.radians(63.4), 0, 0, 0]\nv_peri = bh.perigee_velocity(oe)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apogee_velocity","title":"apogee_velocity  <code>builtin</code>","text":"<pre><code>apogee_velocity(a_or_oe: Union[float, array], e: float = None) -&gt; float\n</code></pre> <p>Computes the apogee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apogee in m/s.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = 24400000.0  # meters\ne = 0.73  # high eccentricity\nv_apo = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n\n# Using Keplerian elements vector\noe = [24400000.0, 0.73, np.radians(7), 0, 0, 0]\nv_apo = bh.apogee_velocity(oe)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.sun_synchronous_inclination","title":"sun_synchronous_inclination  <code>builtin</code>","text":"<pre><code>sun_synchronous_inclination(a_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the inclination for a Sun-synchronous orbit around Earth based on the J2 gravitational perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>a_or_oe</code> <code>float or array</code> <p>Either the semi-major axis in meters, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>a</code> and <code>e</code> will be extracted.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>a_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination for a Sun synchronous orbit in degrees or radians.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\na = bh.R_EARTH + 600e3\ne = 0.001  # nearly circular\ninc = bh.sun_synchronous_inclination(a, e, bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n\n# Using Keplerian elements vector\noe = [bh.R_EARTH + 600e3, 0.001, np.radians(97.8), 0, 0, 0]\ninc = bh.sun_synchronous_inclination(oe, angle_format=bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.geo_sma","title":"geo_sma  <code>builtin</code>","text":"<pre><code>geo_sma() -&gt; float\n</code></pre> <p>Returns the geostationary orbit semi-major axis around Earth.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\na_geo = bh.geo_sma()\nprint(f\"Geostationary semi-major axis: {a_geo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#anomaly-conversions","title":"Anomaly Conversions","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_mean","title":"anomaly_eccentric_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_mean(anm_ecc_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc_or_oe</code> <code>float or array</code> <p>Either the eccentric anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, E] from which <code>e</code> and <code>E</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_ecc_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nE = np.pi / 4  # 45 degrees eccentric anomaly\ne = 0.1  # eccentricity\nM = bh.anomaly_eccentric_to_mean(E, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n\n# Using Keplerian elements vector (with eccentric anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.1, np.radians(45), 0, 0, np.pi/4]\nM = bh.anomaly_eccentric_to_mean(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_true","title":"anomaly_eccentric_to_true  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_true(anm_ecc_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc_or_oe</code> <code>float or array</code> <p>Either the eccentric anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, E] from which <code>e</code> and <code>E</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_ecc_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nE = np.pi / 4  # 45 degrees eccentric anomaly\ne = 0.4  # eccentricity\nnu = bh.anomaly_eccentric_to_true(E, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n\n# Using Keplerian elements vector (with eccentric anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.4, np.radians(45), 0, 0, np.pi/4]\nnu = bh.anomaly_eccentric_to_true(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_eccentric","title":"anomaly_mean_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_eccentric(anm_mean_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean_or_oe</code> <code>float or array</code> <p>Either the mean anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, M] from which <code>e</code> and <code>M</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_mean_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nM = 1.5  # mean anomaly in radians\ne = 0.3  # eccentricity\nE = bh.anomaly_mean_to_eccentric(M, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n\n# Using Keplerian elements vector (with mean anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.3, np.radians(45), 0, 0, 1.5]\nE = bh.anomaly_mean_to_eccentric(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_true","title":"anomaly_mean_to_true  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_true(anm_mean_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean_or_oe</code> <code>float or array</code> <p>Either the mean anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, M] from which <code>e</code> and <code>M</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_mean_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nM = 2.0  # mean anomaly in radians\ne = 0.25  # eccentricity\nnu = bh.anomaly_mean_to_true(M, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n\n# Using Keplerian elements vector (with mean anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.25, np.radians(45), 0, 0, 2.0]\nnu = bh.anomaly_mean_to_true(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_eccentric","title":"anomaly_true_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_true_to_eccentric(anm_true_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true_or_oe</code> <code>float or array</code> <p>Either the true anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>e</code> and <code>\u03bd</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_true_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nnu = np.pi / 3  # 60 degrees true anomaly\ne = 0.2  # eccentricity\nE = bh.anomaly_true_to_eccentric(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n\n# Using Keplerian elements vector (with true anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.2, np.radians(45), 0, 0, np.pi/3]\nE = bh.anomaly_true_to_eccentric(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_mean","title":"anomaly_true_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_true_to_mean(anm_true_or_oe: Union[float, array], e: float = None, *, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true_or_oe</code> <code>float or array</code> <p>Either the true anomaly, or a 6-element Keplerian elements array [a, e, i, \u03a9, \u03c9, \u03bd] from which <code>e</code> and <code>\u03bd</code> will be extracted. The anomaly in the vector should match the <code>angle_format</code>.</p> required <code>e</code> <code>float</code> <p>The eccentricity. Required if <code>anm_true_or_oe</code> is a scalar, ignored if vector.</p> <code>None</code> <code>angle_format</code> <code>AngleFormat</code> <p>(keyword-only) Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Using scalar parameters\nnu = np.pi / 2  # 90 degrees true anomaly\ne = 0.15  # eccentricity\nM = bh.anomaly_true_to_mean(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n\n# Using Keplerian elements vector (with true anomaly at index 5)\noe = [bh.R_EARTH + 500e3, 0.15, np.radians(45), 0, 0, np.pi/2]\nM = bh.anomaly_true_to_mean(oe, angle_format=bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/mean_elements.html","title":"Mean Elements","text":"<p>Functions for converting between mean and osculating Keplerian orbital elements using first-order Brouwer-Lyddane theory.</p>"},{"location":"library_api/orbits/mean_elements.html#brahe.orbits.state_koe_osc_to_mean","title":"state_koe_osc_to_mean  <code>builtin</code>","text":"<pre><code>state_koe_osc_to_mean(osc: ndarray, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert osculating Keplerian elements to mean Keplerian elements.</p> <p>Applies the first-order Brouwer-Lyddane transformation to convert osculating (instantaneous) orbital elements to mean (orbit-averaged) elements. The transformation accounts for short-period and long-period J2 perturbations.</p> <p>Parameters:</p> Name Type Description Default <code>osc</code> <code>ndarray</code> <p>Osculating Keplerian elements as a 6-element array: [a, e, i, \u03a9, \u03c9, M] where: - a: Semi-major axis (meters) - e: Eccentricity (dimensionless) - i: Inclination (radians or degrees, per angle_format) - \u03a9: Right ascension of ascending node (radians or degrees, per angle_format) - \u03c9: Argument of perigee (radians or degrees, per angle_format) - M: Mean anomaly (radians or degrees, per angle_format)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements (Radians or Degrees)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Mean Keplerian elements in the same format as input.</p> Note <p>The forward and inverse transformations are not perfectly inverse due to first-order truncation of the infinite series. Small errors of order J2\u00b2 are expected.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define osculating elements for a LEO satellite (angles in degrees)\nosc = np.array([\n    bh.R_EARTH + 500e3,  # a = 6878 km\n    0.001,               # e = 0.001 (near-circular)\n    45.0,                # i = 45 degrees\n    0.0,                 # \u03a9 = 0\n    0.0,                 # \u03c9 = 0\n    0.0,                 # M = 0\n])\n\nmean = bh.state_koe_osc_to_mean(osc, bh.AngleFormat.DEGREES)\n</code></pre>"},{"location":"library_api/orbits/mean_elements.html#brahe.orbits.state_koe_mean_to_osc","title":"state_koe_mean_to_osc  <code>builtin</code>","text":"<pre><code>state_koe_mean_to_osc(mean: ndarray, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert mean Keplerian elements to osculating Keplerian elements.</p> <p>Applies the first-order Brouwer-Lyddane transformation to convert mean (orbit-averaged) orbital elements to osculating (instantaneous) elements. The transformation accounts for short-period and long-period J2 perturbations.</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>ndarray</code> <p>Mean Keplerian elements as a 6-element array: [a, e, i, \u03a9, \u03c9, M] where: - a: Semi-major axis (meters) - e: Eccentricity (dimensionless) - i: Inclination (radians or degrees, per angle_format) - \u03a9: Right ascension of ascending node (radians or degrees, per angle_format) - \u03c9: Argument of perigee (radians or degrees, per angle_format) - M: Mean anomaly (radians or degrees, per angle_format)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements (Radians or Degrees)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements in the same format as input.</p> Note <p>The forward and inverse transformations are not perfectly inverse due to first-order truncation of the infinite series. Small errors of order J2\u00b2 are expected.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define mean elements for a LEO satellite (angles in degrees)\nmean = np.array([\n    bh.R_EARTH + 500e3,  # a = 6878 km\n    0.001,               # e = 0.001 (near-circular)\n    45.0,                # i = 45 degrees\n    0.0,                 # \u03a9 = 0\n    0.0,                 # \u03c9 = 0\n    0.0,                 # M = 0\n])\n\nosc = bh.state_koe_mean_to_osc(mean, bh.AngleFormat.DEGREES)\n</code></pre>"},{"location":"library_api/orbits/tle.html","title":"Two-Line Element (TLE)","text":"<p>Functions for parsing, validating, and converting Two-Line Element sets.</p> <p>For propagating orbits from TLE data, use the <code>SGPPropagator</code> class.</p>"},{"location":"library_api/orbits/tle.html#tle-utility-functions","title":"TLE Utility Functions","text":""},{"location":"library_api/orbits/tle.html#brahe.orbits.epoch_from_tle","title":"epoch_from_tle  <code>builtin</code>","text":"<pre><code>epoch_from_tle(line1: str) -&gt; Epoch\n</code></pre> <p>Extract Epoch from TLE line 1</p> <p>Extracts and parses the epoch timestamp from the first line of TLE data. The epoch is returned in UTC time system.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Extracted epoch in UTC time system</p> <p>Examples:</p> <pre><code>line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\nepoch = epoch_from_tle(line1)\nepoch.year()\n</code></pre>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_from_tle","title":"keplerian_elements_from_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_from_tle(line1: str, line2: str) -&gt; Tuple\n</code></pre> <p>Extract Keplerian orbital elements from TLE lines.</p> <p>Extracts the standard six Keplerian orbital elements from Two-Line Element (TLE) data. Returns elements in standard order: [a, e, i, raan, argp, M] where angles are in radians.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing: - epoch (Epoch): Epoch of the TLE data. - elements (numpy.ndarray): Six Keplerian elements [a, e, i, raan, argp, M] where   a is semi-major axis in meters, e is eccentricity (dimensionless), and   i, raan, argp, M are in radians.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_to_tle","title":"keplerian_elements_to_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_to_tle(epoch: Epoch, elements: ndarray, norad_id: str) -&gt; Tuple\n</code></pre> <p>Convert Keplerian elements to TLE lines.</p> <p>Converts standard Keplerian orbital elements to Two-Line Element (TLE) format. Input angles should be in degrees for compatibility with TLE format.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>elements</code> <code>ndarray</code> <p>Keplerian elements [a (m), e, i (deg), raan (deg), argp (deg), M (deg)].</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.create_tle_lines","title":"create_tle_lines  <code>builtin</code>","text":"<pre><code>create_tle_lines(epoch: Epoch, inclination: float, raan: float, eccentricity: float, arg_perigee: float, mean_anomaly: float, mean_motion: float, norad_id: str, ephemeris_type: int, element_set_number: int, revolution_number: int, classification: str = None, intl_designator: str = None, first_derivative: float = None, second_derivative: float = None, bstar: float = None) -&gt; Tuple\n</code></pre> <p>Create complete TLE lines from all parameters.</p> <p>Creates Two-Line Element (TLE) lines from complete set of orbital and administrative parameters. Provides full control over all TLE fields including derivatives and drag terms.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless).</p> required <code>arg_perigee</code> <code>float</code> <p>Argument of periapsis in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <code>ephemeris_type</code> <code>int</code> <p>Ephemeris type (0-9).</p> required <code>element_set_number</code> <code>int</code> <p>Element set number.</p> required <code>revolution_number</code> <code>int</code> <p>Revolution number at epoch.</p> required <code>classification</code> <code>str</code> <p>Security classification. Defaults to ' '.</p> <code>None</code> <code>intl_designator</code> <code>str</code> <p>International designator. Defaults to ''.</p> <code>None</code> <code>first_derivative</code> <code>float</code> <p>First derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>second_derivative</code> <code>float</code> <p>Second derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>bstar</code> <code>float</code> <p>BSTAR drag term. Defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_line","title":"validate_tle_line  <code>builtin</code>","text":"<pre><code>validate_tle_line(line: str) -&gt; bool\n</code></pre> <p>Validate single TLE line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the line is valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_lines","title":"validate_tle_lines  <code>builtin</code>","text":"<pre><code>validate_tle_lines(line1: str, line2: str) -&gt; bool\n</code></pre> <p>Validate TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both lines are valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.calculate_tle_line_checksum","title":"calculate_tle_line_checksum  <code>builtin</code>","text":"<pre><code>calculate_tle_line_checksum(line: str) -&gt; int\n</code></pre> <p>Calculate TLE line checksum.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum value.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.parse_norad_id","title":"parse_norad_id  <code>builtin</code>","text":"<pre><code>parse_norad_id(norad_str: str) -&gt; int\n</code></pre> <p>Parse NORAD ID from string, handling both classic and Alpha-5 formats.</p> <p>Parameters:</p> Name Type Description Default <code>norad_str</code> <code>str</code> <p>NORAD ID string from TLE.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Parsed numeric NORAD ID.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_numeric_to_alpha5","title":"norad_id_numeric_to_alpha5  <code>builtin</code>","text":"<pre><code>norad_id_numeric_to_alpha5(norad_id: int) -&gt; str\n</code></pre> <p>Convert numeric NORAD ID to Alpha-5 format or pass through if in legacy range.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>Numeric NORAD ID (0-339999). IDs 0-99999 are passed through as numeric strings. IDs 100000-339999 are converted to Alpha-5 format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>For IDs 0-99999: numeric string (e.g., \"42\"). For IDs 100000-339999: Alpha-5 format ID (e.g., \"A0001\").</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_alpha5_to_numeric","title":"norad_id_alpha5_to_numeric  <code>builtin</code>","text":"<pre><code>norad_id_alpha5_to_numeric(alpha5_id: str) -&gt; int\n</code></pre> <p>Convert Alpha-5 NORAD ID to numeric format.</p> <p>Parameters:</p> Name Type Description Default <code>alpha5_id</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric NORAD ID.</p>"},{"location":"library_api/orbits/walker.html","title":"Walker Constellations","text":"<p>Generator for Walker constellation patterns (Delta and Star) using T:P:F notation.</p> <p>For understanding Walker constellation geometry and usage examples, see Walker Constellations.</p>"},{"location":"library_api/orbits/walker.html#walker-pattern","title":"Walker Pattern","text":""},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerPattern","title":"WalkerPattern","text":"<pre><code>WalkerPattern()\n</code></pre> <p>Walker constellation pattern type.</p> <p>Defines whether the constellation uses a Delta (360\u00b0) or Star (180\u00b0) RAAN spread.</p> <p>Attributes:</p> Name Type Description <code>DELTA</code> <code>Any</code> <p>Walker Delta pattern with 360\u00b0 RAAN spread (global coverage). Used by GPS, Galileo, and similar navigation constellations.</p> <code>STAR</code> <code>Any</code> <p>Walker Star pattern with 180\u00b0 RAAN spread (polar coverage). Used by Iridium and similar communications constellations.</p> Example <pre><code>import brahe as bh\n\ndelta = bh.WalkerPattern.DELTA  # 360\u00b0 RAAN spread\nstar = bh.WalkerPattern.STAR    # 180\u00b0 RAAN spread\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerPattern.DELTA","title":"DELTA  <code>class-attribute</code>","text":"<pre><code>DELTA: Any = WalkerPattern.DELTA\n</code></pre> <p>Walker constellation pattern type.</p> <p>Defines whether the constellation uses a Delta (360\u00b0) or Star (180\u00b0) RAAN spread.</p> <p>Attributes:</p> Name Type Description <code>DELTA</code> <p>Walker Delta pattern with 360\u00b0 RAAN spread (global coverage). Used by GPS, Galileo, and similar navigation constellations.</p> <code>STAR</code> <p>Walker Star pattern with 180\u00b0 RAAN spread (polar coverage). Used by Iridium and similar communications constellations.</p> Example <pre><code>import brahe as bh\n\ndelta = bh.WalkerPattern.DELTA  # 360\u00b0 RAAN spread\nstar = bh.WalkerPattern.STAR    # 180\u00b0 RAAN spread\n</code></pre>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerPattern.STAR","title":"STAR  <code>class-attribute</code>","text":"<pre><code>STAR: Any = WalkerPattern.STAR\n</code></pre> <p>Walker constellation pattern type.</p> <p>Defines whether the constellation uses a Delta (360\u00b0) or Star (180\u00b0) RAAN spread.</p> <p>Attributes:</p> Name Type Description <code>DELTA</code> <p>Walker Delta pattern with 360\u00b0 RAAN spread (global coverage). Used by GPS, Galileo, and similar navigation constellations.</p> <code>STAR</code> <p>Walker Star pattern with 180\u00b0 RAAN spread (polar coverage). Used by Iridium and similar communications constellations.</p> Example <pre><code>import brahe as bh\n\ndelta = bh.WalkerPattern.DELTA  # 360\u00b0 RAAN spread\nstar = bh.WalkerPattern.STAR    # 180\u00b0 RAAN spread\n</code></pre>"},{"location":"library_api/orbits/walker.html#walker-constellation-generator","title":"Walker Constellation Generator","text":""},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator","title":"WalkerConstellationGenerator","text":"<pre><code>WalkerConstellationGenerator(t: int, p: int, f: int, semi_major_axis: float, eccentricity: float, inclination: float, argument_of_perigee: float, reference_raan: float, reference_mean_anomaly: float, epoch: Epoch, angle_format: AngleFormat, pattern: WalkerPattern)\n</code></pre> <p>Generator for Walker constellation patterns using T:P:F notation.</p> <p>Walker constellations place satellites in circular or near-circular orbits with: - T total satellites distributed across P planes - Each plane inclined at the same angle - Planes evenly spaced in RAAN (spread depends on pattern type) - Satellites within each plane evenly spaced in mean anomaly - Phase offset F controls inter-plane phasing</p> <p>Two pattern types are supported via <code>pattern</code>: - <code>WalkerPattern.DELTA</code>: 360\u00b0 RAAN spread (global coverage, e.g., GPS, Galileo) - <code>WalkerPattern.STAR</code>: 180\u00b0 RAAN spread (polar coverage, e.g., Iridium)</p> <p>All satellites in the constellation share the same semi-major axis, eccentricity, inclination, and argument of perigee. They differ only in RAAN and mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>int</code> <p>Total number of satellites (must be divisible by p)</p> required <code>p</code> <code>int</code> <p>Number of orbital planes</p> required <code>f</code> <code>int</code> <p>Phasing factor (0 to p-1)</p> required <code>semi_major_axis</code> <code>float</code> <p>Semi-major axis in meters</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless)</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees or radians (based on angle_format)</p> required <code>argument_of_perigee</code> <code>float</code> <p>Argument of perigee</p> required <code>reference_raan</code> <code>float</code> <p>RAAN for plane 0</p> required <code>reference_mean_anomaly</code> <code>float</code> <p>Mean anomaly for first satellite</p> required <code>epoch</code> <code>Epoch</code> <p>Reference epoch for ephemeris generation</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular inputs</p> required <code>pattern</code> <code>WalkerPattern</code> <p>Pattern type (DELTA for 360\u00b0 RAAN, STAR for 180\u00b0 RAAN)</p> required Example <pre><code>import brahe as bh\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n# Walker Delta constellation (GPS-like)\ngen = bh.WalkerConstellationGenerator(\n    t=24,                       # 24 total satellites\n    p=3,                        # 3 orbital planes\n    f=1,                        # phasing factor 1\n    semi_major_axis=bh.R_EARTH + 20200e3,  # GPS altitude\n    eccentricity=0.0,\n    inclination=55.0,\n    argument_of_perigee=0.0,\n    reference_raan=0.0,\n    reference_mean_anomaly=0.0,\n    epoch=epoch,\n    angle_format=bh.AngleFormat.DEGREES,\n    pattern=bh.WalkerPattern.DELTA,  # 360\u00b0 RAAN spread\n)\n\n# Generate Keplerian propagators\npropagators = gen.as_keplerian_propagators(60.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.eccentricity","title":"eccentricity  <code>property</code>","text":"<pre><code>eccentricity: Any\n</code></pre> <p>Eccentricity.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Any\n</code></pre> <p>Reference epoch.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.num_planes","title":"num_planes  <code>property</code>","text":"<pre><code>num_planes: Any\n</code></pre> <p>Number of orbital planes.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.pattern","title":"pattern  <code>property</code>","text":"<pre><code>pattern: Any\n</code></pre> <p>Walker pattern (Delta or Star).</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.phasing","title":"phasing  <code>property</code>","text":"<pre><code>phasing: Any\n</code></pre> <p>Phasing factor.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.satellites_per_plane","title":"satellites_per_plane  <code>property</code>","text":"<pre><code>satellites_per_plane: Any\n</code></pre> <p>Number of satellites per plane (T/P).</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.semi_major_axis","title":"semi_major_axis  <code>property</code>","text":"<pre><code>semi_major_axis: ndarray\n</code></pre> <p>Semi-major axis in meters.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.total_satellites","title":"total_satellites  <code>property</code>","text":"<pre><code>total_satellites: Any\n</code></pre> <p>Total number of satellites in the constellation.</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.as_keplerian_propagators","title":"as_keplerian_propagators  <code>method descriptor</code>","text":"<pre><code>as_keplerian_propagators(step_size: float) -&gt; list[KeplerianPropagator]\n</code></pre> <p>Generate Keplerian propagators for all satellites in the constellation.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation</p> required <p>Returns:</p> Type Description <code>list[KeplerianPropagator]</code> <p>list[KeplerianPropagator]: List of propagators, one per satellite</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.as_numerical_propagators","title":"as_numerical_propagators  <code>method descriptor</code>","text":"<pre><code>as_numerical_propagators(propagation_config: NumericalPropagationConfig, force_config: ForceModelConfig, params: ndarray = None) -&gt; list[DNumericalOrbitPropagator]\n</code></pre> <p>Generate numerical orbit propagators for all satellites in the constellation.</p> <p>Parameters:</p> Name Type Description Default <code>propagation_config</code> <code>NumericalPropagationConfig</code> <p>Propagation configuration</p> required <code>force_config</code> <code>ForceModelConfig</code> <p>Force model configuration</p> required <code>params</code> <code>ndarray</code> <p>Parameter vector [mass, drag_area, Cd, srp_area, Cr]</p> <code>None</code> <p>Returns:</p> Type Description <code>list[DNumericalOrbitPropagator]</code> <p>list[DNumericalOrbitPropagator]: List of propagators, one per satellite</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.as_sgp_propagators","title":"as_sgp_propagators  <code>method descriptor</code>","text":"<pre><code>as_sgp_propagators(step_size: float, bstar: float, ndt2: float, nddt6: float) -&gt; list[SGPPropagator]\n</code></pre> <p>Generate SGP propagators for all satellites in the constellation.</p> <p>This method creates TLE data for each satellite using the provided drag and mean motion derivative parameters.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation</p> required <code>bstar</code> <code>float</code> <p>B* drag term (Earth radii^-1)</p> required <code>ndt2</code> <code>float</code> <p>First derivative of mean motion divided by 2 (rev/day\u00b2)</p> required <code>nddt6</code> <code>float</code> <p>Second derivative of mean motion divided by 6 (rev/day\u00b3)</p> required <p>Returns:</p> Type Description <code>list[SGPPropagator]</code> <p>list[SGPPropagator]: List of propagators, one per satellite</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.satellite_elements","title":"satellite_elements  <code>method descriptor</code>","text":"<pre><code>satellite_elements(plane_index: int, sat_index: int, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get Keplerian elements for a specific satellite.</p> <p>Parameters:</p> Name Type Description Default <code>plane_index</code> <code>int</code> <p>Plane index (0 to P-1)</p> required <code>sat_index</code> <code>int</code> <p>Satellite index within plane (0 to T/P - 1)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Output angle format</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Keplerian elements [a, e, i, raan, argp, M]</p>"},{"location":"library_api/orbits/walker.html#brahe.orbits.WalkerConstellationGenerator.with_base_name","title":"with_base_name  <code>method descriptor</code>","text":"<pre><code>with_base_name(name: str) -&gt; WalkerConstellationGenerator\n</code></pre> <p>Set a base name for satellite naming.</p> <p>When set, satellites will be named as \"{base_name}-P{plane}-S{sat}\" (e.g., \"GPS-P0-S0\", \"GPS-P0-S1\", \"GPS-P1-S0\", etc.)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Base name for the constellation satellites</p> required <p>Returns:</p> Name Type Description <code>WalkerConstellationGenerator</code> <code>WalkerConstellationGenerator</code> <p>Self with the base name set</p>"},{"location":"library_api/plots/index.html","title":"Plots","text":"<p>Module: <code>brahe.plots</code></p> <p>Visualization tools for astrodynamics data with support for matplotlib and plotly backends.</p>"},{"location":"library_api/plots/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Ground Track Plotting - Ground track visualization with communication cones and polygon zones</li> <li>Access Geometry Plotting - Polar plots and elevation profiles for access windows</li> <li>Orbital Trajectories - Time-series plots of orbital elements (Cartesian and Keplerian)</li> <li>3D Trajectory - 3D visualization of satellite trajectories in ECI frame</li> <li>Gabbard Diagram - Orbital period vs apogee/perigee altitude scatter plots</li> </ul>"},{"location":"library_api/plots/3d_trajectory.html","title":"3D Trajectory Visualization","text":""},{"location":"library_api/plots/3d_trajectory.html#brahe.plot_trajectory_3d","title":"plot_trajectory_3d","text":"<pre><code>plot_trajectory_3d(trajectories, time_range=None, units='km', normalize=False, view_azimuth=45.0, view_elevation=30.0, view_distance=None, show_earth=True, earth_texture=None, sphere_resolution_lon=1080, sphere_resolution_lat=540, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot 3D trajectory in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d73] or [N\u00d76] (positions in ECI) - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>normalize</code> <code>bool</code> <p>Normalize to Earth radii. Default: False</p> <code>False</code> <code>view_azimuth</code> <code>float</code> <p>Camera azimuth angle (degrees). Default: 45.0</p> <code>45.0</code> <code>view_elevation</code> <code>float</code> <p>Camera elevation angle (degrees). Default: 30.0</p> <code>30.0</code> <code>view_distance</code> <code>float</code> <p>Camera distance multiplier. Default: 2.5 (larger = further out)</p> <code>None</code> <code>show_earth</code> <code>bool</code> <p>Show Earth sphere at origin. Default: True</p> <code>True</code> <code>earth_texture</code> <code>str</code> <p>Texture to use for Earth sphere (plotly only). Options: - 'simple': Solid lightblue sphere (fast rendering) - 'blue_marble': NASA Blue Marble texture (packaged with brahe, default for plotly) - 'natural_earth_50m': Natural Earth 50m shaded relief (auto-downloads ~20MB) - 'natural_earth_10m': Natural Earth 10m shaded relief (auto-downloads ~180MB) Note: matplotlib always uses a simple solid sphere regardless of this setting. Default: 'blue_marble' for plotly</p> <code>None</code> <code>sphere_resolution_lon</code> <code>int</code> <p>Longitude resolution for textured sphere (plotly only). Higher values = better quality but slower rendering. Default: 1080</p> <code>1080</code> <code>sphere_resolution_lat</code> <code>int</code> <p>Latitude resolution for textured sphere (plotly only). Higher values = better quality but slower rendering. Default: 540</p> <code>540</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + bh.orbital_period(oe[0]), 60.0)\n\n# Plot 3D trajectory with matplotlib (simple sphere)\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    backend='matplotlib'\n)\n\n# Plot 3D trajectory with plotly (blue marble texture by default)\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    backend='plotly'\n)\n\n# Plot with explicit texture choice\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    earth_texture='natural_earth_50m',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html","title":"Access Geometry Plotting","text":""},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_polar","title":"plot_access_polar","text":"<pre><code>plot_access_polar(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], min_elevation=0.0, num_samples=None, time_step=5.0, elevation_mask=None, backend='matplotlib', width=None, height=None, radial_tick_values=None, radial_tick_labels=None, radial_range=None, radial_tick_offset=8) -&gt; object\n</code></pre> <p>Plot access window geometry in polar coordinates (azimuth/elevation).</p> <p>Polar coordinates: - Radius: 90\u00b0 - elevation (zenith at center, horizon at edge) - Theta: Azimuth (North at top, clockwise)</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>min_elevation</code> <code>float</code> <p>Minimum elevation for plot edge (degrees). Default: 0.0</p> <code>0.0</code> <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified.</p> <code>5.0</code> <code>elevation_mask</code> <code>float, callable, or array</code> <p>Elevation mask to visualize. Can be: - float: Constant elevation angle (degrees) - callable: Function taking azimuth (degrees) returning elevation (degrees) - array: Elevation values at each azimuth (evaluated at 360 points around horizon)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>radial_tick_values</code> <code>array - like</code> <p>Custom radial tick positions (in radius units: 90-elevation). Default: [15, 30, 45, 60, 75, 90] (corresponding to elevations 75\u00b0, 60\u00b0, 45\u00b0, 30\u00b0, 15\u00b0, 0\u00b0)</p> <code>None</code> <code>radial_tick_labels</code> <code>array - like</code> <p>Custom labels for radial ticks. Default: [\"75\u00b0\", \"60\u00b0\", \"45\u00b0\", \"30\u00b0\", \"15\u00b0\", \"0\u00b0\"]</p> <code>None</code> <code>radial_range</code> <code>tuple</code> <p>(min, max) range for radial axis. Default: (0, 90) for matplotlib, auto-calculated for plotly to accommodate offset ticks</p> <code>None</code> <code>radial_tick_offset</code> <code>float</code> <p>Offset for radial tick positions in plotly (to avoid overlapping with circle lines). Default: 3. Set to 0 for no offset. Only applies to plotly.</p> <code>8</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot first access window\nfig = bh.plot_access_polar(\n    [{\"access_window\": windows[0], \"propagator\": prop, \"label\": \"Pass 1\"}],\n    min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_elevation","title":"plot_access_elevation","text":"<pre><code>plot_access_elevation(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], num_samples=None, time_step=5.0, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot elevation angle vs time for access windows.</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified. - label (str, optional): Legend label</p> <code>5.0</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: 1400</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: 700</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup (same as polar plot example)\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot elevation profile\nfig = bh.plot_access_elevation(\n    [{\"access_window\": w, \"propagator\": prop, \"label\": f\"Pass {i+1}\"} for i, w in enumerate(windows[:3])],\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_elevation_azimuth","title":"plot_access_elevation_azimuth","text":"<pre><code>plot_access_elevation_azimuth(access_windows, propagator: Union[KeplerianPropagator, SGPPropagator], num_samples=None, time_step=5.0, elevation_mask=None, backend='matplotlib', width=None, height=None) -&gt; object\n</code></pre> <p>Plot elevation vs azimuth for access windows (observed horizon plot).</p> <p>Shows the satellite's path across the sky as elevation angle vs azimuth angle, providing a \"view from the ground\" perspective of the satellite's trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>propagator</code> <code>Union[KeplerianPropagator, SGPPropagator]</code> <p>Propagator object for computing interpolated trajectories</p> required <code>num_samples</code> <code>int</code> <p>Number of samples for interpolation. If None, uses time_step.</p> <code>None</code> <code>time_step</code> <code>float</code> <p>Time step for interpolation (seconds). Default: 5.0.                          Ignored if num_samples is specified.</p> <code>5.0</code> <code>elevation_mask</code> <code>float, callable, or array</code> <p>Elevation mask to visualize. Can be: - float: Constant elevation angle (degrees) - callable: Function taking azimuth (degrees) returning elevation (degrees) - array: Elevation values at each azimuth (evaluated at 360 points)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: 1400</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: 700</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Sinusoidal elevation mask\nmask_fn = lambda az: 15.0 + 10.0 * np.sin(np.radians(2 * az))\n\n# Plot elevation vs azimuth\nfig = bh.plot_access_elevation_azimuth(\n    [{\"access_window\": w, \"propagator\": prop, \"label\": f\"Pass {i+1}\"} for i, w in enumerate(windows[:3])],\n    elevation_mask=mask_fn,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/gabbard.html","title":"Gabbard Diagram","text":"<p>Gabbard diagrams visualize satellite populations and debris clouds by plotting orbital period versus apogee/perigee altitude. These plots are particularly useful for analyzing satellite breakup events and orbital debris distributions.</p>"},{"location":"library_api/plots/gabbard.html#brahe.plot_gabbard_diagram","title":"plot_gabbard_diagram","text":"<pre><code>plot_gabbard_diagram(objects, epoch=None, altitude_units: str = 'km', period_units: str = 'min', backend: str = 'matplotlib', width=None, height=None) -&gt; Union[Figure, Figure]\n</code></pre> <p>Plot Gabbard diagram showing orbital period vs apogee/perigee altitude.</p> <p>A Gabbard diagram is a scatter plot used to visualize satellite populations and debris clouds, plotting each object's apogee and perigee altitudes against its orbital period. This visualization is particularly useful for analyzing satellite breakup events and orbital debris distributions.</p> <p>Parameters:</p> Name Type Description Default <code>objects</code> <code>list</code> <p>List of objects to plot. Can be: - List of Propagator objects (SGPPropagator or KeplerianPropagator) - List of numpy arrays (state vectors or Keplerian elements) with format specified - List of dicts with keys:     - objects: List of propagators or states     - format (str, optional): 'ECI', 'ECEF', or 'Keplerian' (required for state arrays)     - color (str, optional): Marker color     - marker (str, optional): Marker style     - label (str, optional): Legend label</p> required <code>epoch</code> <code>Epoch</code> <p>Epoch to evaluate propagator states. If None, uses current state.</p> <code>None</code> <code>altitude_units</code> <code>str</code> <p>'km' or 'm'. Default: 'km'</p> <code>'km'</code> <code>period_units</code> <code>str</code> <p>'min' or 's'. Default: 'min'</p> <code>'min'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Figure, Figure]</code> <p>Union[matplotlib.figure.Figure, plotly.graph_objects.Figure]: Figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Set up EOP\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\n# Create propagators for debris cloud\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Parent orbit\noe_parent = np.array([bh.R_EARTH + 215e3, 0.1, np.radians(97.8), 0.0, 0.0, 0.0])\n\n# Simulate debris with various delta-v\ndebris = []\nfor dv in np.linspace(-100, 100, 50):  # m/s delta-v\n    oe = oe_parent.copy()\n    # Simplified: adjust semi-major axis based on delta-v\n    oe[0] += dv * 1000  # rough approximation\n    oe[1] = max(0.001, min(0.3, oe[1] + np.random.normal(0, 0.05)))\n    state = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\n    debris.append(prop)\n\n# Plot Gabbard diagram\nfig = bh.plot_gabbard_diagram(\n    debris,\n    epoch=epoch,\n    altitude_units='km',\n    period_units='min',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/ground_tracks.html","title":"Ground Track Plotting","text":""},{"location":"library_api/plots/ground_tracks.html#brahe.plot_groundtrack","title":"plot_groundtrack","text":"<pre><code>plot_groundtrack(trajectories=None, ground_stations=None, zones=None, gs_cone_altitude=500000.0, gs_min_elevation=10.0, basemap='natural_earth', show_borders=True, show_coastlines=True, border_width=0.5, show_grid=False, show_ticks=True, show_legend=False, extent=None, backend='matplotlib') -&gt; object\n</code></pre> <p>Plot ground tracks with optional ground stations and polygon zones.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array - color (str, optional): Line color - line_width (float, optional): Line width - track_length (float, optional): Length of track to display - track_units (str, optional): Units for track_length - \"orbits\" or \"seconds\". Default: \"orbits\"</p> <code>None</code> <code>ground_stations</code> <code>list of dict</code> <p>List of ground station groups, each with: - stations: List of PointLocation or (lat, lon) tuples - color (str, optional): Station and cone color - alpha (float, optional): Cone transparency - point_size (float, optional): Station marker size - show_ring (bool, optional): Show outer ring - ring_color (str, optional): Ring color - ring_width (float, optional): Ring line width</p> <code>None</code> <code>zones</code> <code>list of dict</code> <p>List of polygon zone groups, each with: - zone: PolygonLocation - fill (bool, optional): Fill interior - fill_alpha (float, optional): Fill transparency - fill_color (str, optional): Fill color - edge (bool, optional): Show edge - edge_color (str, optional): Edge color - points (bool, optional): Show vertices</p> <code>None</code> <code>gs_cone_altitude</code> <code>float</code> <p>Assumed satellite altitude for cone calculation (m). Default: 500e3</p> <code>500000.0</code> <code>gs_min_elevation</code> <code>float</code> <p>Minimum elevation angle (degrees). Default: 10.0</p> <code>10.0</code> <code>basemap</code> <code>str</code> <p>Basemap style - \"natural_earth\", \"stock\", or None. Default: \"natural_earth\"</p> <code>'natural_earth'</code> <code>show_borders</code> <code>bool</code> <p>Show country borders. Default: True</p> <code>True</code> <code>show_coastlines</code> <code>bool</code> <p>Show coastlines. Default: True</p> <code>True</code> <code>border_width</code> <code>float</code> <p>Border line width. Default: 0.5</p> <code>0.5</code> <code>show_grid</code> <code>bool</code> <p>Show lat/lon grid. Default: False</p> <code>False</code> <code>show_ticks</code> <code>bool</code> <p>Show lat/lon tick marks. Default: True</p> <code>True</code> <code>show_legend</code> <code>bool</code> <p>Show legend (plotly only). Default: False</p> <code>False</code> <code>extent</code> <code>list</code> <p>[lon_min, lon_max, lat_min, lat_max] to zoom. Default: None (global)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a simple LEO trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Define ground stations\nstations_aws = [\n    bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0),  # NYC\n    bh.PointLocation(np.radians(37.7749), np.radians(-122.4194), 0.0),  # SF\n]\n\nstations_ksat = [\n    bh.PointLocation(np.radians(78.2232), np.radians(15.6267), 0.0),  # Svalbard\n]\n\n# Plot with per-group configuration\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"track_length\": 2, \"track_units\": \"orbits\"}],\n    ground_stations=[\n        {\"stations\": stations_aws, \"color\": \"orange\", \"alpha\": 0.3},\n        {\"stations\": stations_ksat, \"color\": \"blue\", \"alpha\": 0.3},\n    ],\n    gs_cone_altitude=500e3,\n    gs_min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/ground_tracks.html#brahe.split_ground_track_at_antimeridian","title":"split_ground_track_at_antimeridian","text":"<pre><code>split_ground_track_at_antimeridian(lons, lats, value: float = 180.0) -&gt; List[Tuple]\n</code></pre> <p>Split a ground track into segments at antimeridian crossings.</p> <p>When a satellite ground track crosses the antimeridian (\u00b1180\u00b0 longitude), plotting libraries may draw an incorrect line across the entire map. This function detects such crossings and splits the track into separate segments that can be plotted individually.</p> <p>Parameters:</p> Name Type Description Default <code>lons</code> <code>list or ndarray</code> <p>Longitude values in degrees</p> required <code>lats</code> <code>list or ndarray</code> <p>Latitude values in degrees (same length as lons)</p> required <code>value</code> <code>float</code> <p>Longitude jump value in degrees to detect wraparound. Default: 180.0</p> <code>180.0</code> <p>Returns:</p> Type Description <code>List[Tuple]</code> <p>List[Tuple]: List of (lon_segment, lat_segment) tuples, where each tuple contains arrays for one continuous segment</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground track that crosses antimeridian\nlons = [170, 175, 180, -175, -170]\nlats = [10, 15, 20, 25, 30]\n\n# Split into segments\nsegments = bh.split_ground_track_at_antimeridian(lons, lats)\n\n# Plot each segment\nimport matplotlib.pyplot as plt\nfor lon_seg, lat_seg in segments:\n    plt.plot(lon_seg, lat_seg)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html","title":"Orbital Trajectory Plotting","text":""},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_cartesian_trajectory","title":"plot_cartesian_trajectory","text":"<pre><code>plot_cartesian_trajectory(trajectories, time_range=None, position_units='km', velocity_units='km/s', backend='matplotlib', show_title=False, show_grid=False, matplotlib_config=None, plotly_config=None, width=None, height=None) -&gt; object\n</code></pre> <p>Plot Cartesian orbital elements (position and velocity) vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: x, y, z positions - Row 2: vx, vy, vz velocities</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>position_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>velocity_units</code> <code>str</code> <p>'m/s' or 'km/s'. Default: 'km/s'</p> <code>'km/s'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>show_title</code> <code>bool</code> <p>Whether to display plot title. Default: False</p> <code>False</code> <code>show_grid</code> <code>bool</code> <p>Whether to display grid lines. Default: False</p> <code>False</code> <code>matplotlib_config</code> <code>dict</code> <p>Matplotlib-specific configuration: - legend_subplot (tuple): (row, col) of subplot for legend. Default: (0, 0) - legend_loc (str): Legend location. Default: 'best'   Options: 'best', 'upper right', 'upper left', 'lower left', 'lower right',            'right', 'center left', 'center right', 'lower center', 'upper center', 'center' - dark_mode (bool): Apply dark mode styling. Default: False - ylabel_pad (float): Padding for y-axis labels. Default: 10 - figsize (tuple): Figure size (width, height). Default: (15, 10)</p> <code>None</code> <code>plotly_config</code> <code>dict</code> <p>Plotly-specific configuration (reserved for future use)</p> <code>None</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Cartesian elements with legend in upper right of Z position subplot\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    position_units='km',\n    velocity_units='km/s',\n    backend='matplotlib',\n    matplotlib_config={'legend_subplot': (0, 2), 'legend_loc': 'upper right'}\n)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_keplerian_trajectory","title":"plot_keplerian_trajectory","text":"<pre><code>plot_keplerian_trajectory(trajectories, time_range=None, angle_units='deg', sma_units='km', normalize_angles=False, backend='matplotlib', show_title=False, show_grid=False, matplotlib_config=None, plotly_config=None, width=None, height=None) -&gt; object\n</code></pre> <p>Plot Keplerian orbital elements vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: a (semi-major axis), e (eccentricity), i (inclination) - Row 2: \u03a9 (RAAN), \u03c9 (argument of periapsis), M (mean anomaly)</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] as [a, e, i, \u03a9, \u03c9, M] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>angle_units</code> <code>str</code> <p>'rad' or 'deg'. Default: 'deg'</p> <code>'deg'</code> <code>sma_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>normalize_angles</code> <code>bool</code> <p>If True, wrap angles to [0, 2\u03c0) or [0, 360\u00b0). Default: False</p> <code>False</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <code>show_title</code> <code>bool</code> <p>Whether to display plot title. Default: False</p> <code>False</code> <code>show_grid</code> <code>bool</code> <p>Whether to display grid lines. Default: False</p> <code>False</code> <code>matplotlib_config</code> <code>dict</code> <p>Matplotlib-specific configuration: - legend_subplot (tuple): (row, col) of subplot for legend. Default: (0, 0) - legend_loc (str): Legend location. Default: 'best'   Options: 'best', 'upper right', 'upper left', 'lower left', 'lower right',            'right', 'center left', 'center right', 'lower center', 'upper center', 'center' - dark_mode (bool): Apply dark mode styling. Default: False - ylabel_pad (float): Padding for y-axis labels. Default: 10 - figsize (tuple): Figure size (width, height). Default: (15, 10) - set_angle_ylim (bool): Set y-axis limits to [0, 360\u00b0] or [0, 2\u03c0]. Default: False - set_eccentricity_ylim (bool): Set y-axis limits to [0, 1]. Default: False</p> <code>None</code> <code>plotly_config</code> <code>dict</code> <p>Plotly-specific configuration: - set_angle_ylim (bool): Set y-axis limits to [0, 360\u00b0] or [0, 2\u03c0]. Default: False - set_eccentricity_ylim (bool): Set y-axis limits to [0, 1]. Default: False</p> <code>None</code> <code>width</code> <code>int</code> <p>Figure width in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels (plotly only). Default: None (responsive)</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 0.0, 0.0, 0.0])\n\nprop = bh.KeplerianPropagator.from_eci(epoch, oe, bh.AngleFormat.DEGREES, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Keplerian elements\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    angle_units='deg',\n    sma_units='km',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/propagators/index.html","title":"Propagators","text":"<p>Module: <code>brahe.propagators</code></p> <p>Orbit propagators for predicting satellite positions over time.</p>"},{"location":"library_api/propagators/index.html#analytical-propagators","title":"Analytical Propagators","text":"<ul> <li>KeplerianPropagator - Analytical two-body orbit propagator</li> <li>SGPPropagator - SGP4/SDP4 orbit propagator for TLE data</li> </ul>"},{"location":"library_api/propagators/index.html#numerical-propagators","title":"Numerical Propagators","text":"<ul> <li>NumericalOrbitPropagator - High-fidelity numerical orbit propagator with force models</li> <li>NumericalPropagator - Generic numerical propagator for arbitrary dynamics</li> </ul>"},{"location":"library_api/propagators/index.html#configuration","title":"Configuration","text":"<ul> <li>NumericalPropagationConfig - Integration method and tolerance configuration</li> <li>ForceModelConfig - Force model configuration for numerical propagation</li> </ul>"},{"location":"library_api/propagators/index.html#see-also","title":"See Also","text":"<ul> <li>Event Detection - Event detection system for numerical propagators</li> </ul>"},{"location":"library_api/propagators/force_model_config.html","title":"Force Model Configuration","text":"<p>Configuration classes for numerical orbit propagation force models. <code>ForceModelConfig</code> provides factory methods for common configurations and allows customization of gravity, atmospheric drag, solar radiation pressure, and third-body perturbations.</p> <p>Note</p> <p>For conceptual explanations and usage examples, see Force Models in the User Guide.</p>"},{"location":"library_api/propagators/force_model_config.html#forcemodelconfig","title":"ForceModelConfig","text":""},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig","title":"ForceModelConfig","text":"<pre><code>ForceModelConfig(gravity: GravityConfiguration = None, drag: DragConfiguration = None, srp: SolarRadiationPressureConfiguration = None, third_body: ThirdBodyConfiguration = None, relativity: bool = False, mass: ParameterSource = None)\n</code></pre> <p>Force model configuration for numerical orbit propagation.</p> <p>Defines all perturbation forces to be included: gravity, drag, SRP, third-body, relativity.</p> <p>Parameters:</p> Name Type Description Default <code>gravity</code> <code>GravityConfiguration</code> <p>Gravity model configuration. Default is point mass gravity.</p> <code>None</code> <code>drag</code> <code>DragConfiguration</code> <p>Atmospheric drag configuration. Default is None (disabled).</p> <code>None</code> <code>srp</code> <code>SolarRadiationPressureConfiguration</code> <p>Solar radiation pressure configuration. Default is None (disabled).</p> <code>None</code> <code>third_body</code> <code>ThirdBodyConfiguration</code> <p>Third-body perturbations configuration. Default is None (disabled).</p> <code>None</code> <code>relativity</code> <code>bool</code> <p>Enable relativistic corrections. Default is False.</p> <code>False</code> <code>mass</code> <code>ParameterSource</code> <p>Spacecraft mass source. Default is None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>gravity</code> <code>GravityConfiguration</code> <p>Gravity model configuration</p> <code>drag</code> <code>DragConfiguration or None</code> <p>Atmospheric drag configuration</p> <code>srp</code> <code>SolarRadiationPressureConfiguration or None</code> <p>Solar radiation pressure configuration</p> <code>third_body</code> <code>ThirdBodyConfiguration or None</code> <p>Third-body perturbations configuration</p> <code>relativity</code> <code>bool</code> <p>Enable relativistic corrections</p> <code>mass</code> <code>ParameterSource or None</code> <p>Spacecraft mass source</p> Example <pre><code>import brahe as bh\n\n# Create with explicit parameters\nconfig = bh.ForceModelConfig(\n    gravity=bh.GravityConfiguration(degree=20, order=20),\n    relativity=True,\n)\n\n# Or use convenience class methods\nconfig = bh.ForceModelConfig.default()\nconfig = bh.ForceModelConfig.two_body()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.drag","title":"drag  <code>property</code>","text":"<pre><code>drag: Any\n</code></pre> <p>Get the drag configuration (None if disabled).</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.gravity","title":"gravity  <code>property</code>","text":"<pre><code>gravity: Any\n</code></pre> <p>Get the gravity configuration.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.mass","title":"mass  <code>property</code>","text":"<pre><code>mass: Any\n</code></pre> <p>Get the mass parameter source (None if not required).</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.relativity","title":"relativity  <code>property</code>","text":"<pre><code>relativity: Any\n</code></pre> <p>Get whether relativistic corrections are enabled.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.srp","title":"srp  <code>property</code>","text":"<pre><code>srp: Any\n</code></pre> <p>Get the solar radiation pressure configuration (None if disabled).</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.third_body","title":"third_body  <code>property</code>","text":"<pre><code>third_body: Any\n</code></pre> <p>Get the third-body configuration (None if disabled).</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.conservative_forces","title":"conservative_forces  <code>builtin</code>","text":"<pre><code>conservative_forces() -&gt; ForceModelConfig\n</code></pre> <p>Create a conservative forces configuration (gravity + third-body + relativity, no drag/SRP).</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; ForceModelConfig\n</code></pre> <p>Create a default force model configuration.</p> <p>Includes: - 20x20 EGM2008 gravity - Harris-Priester atmospheric drag - Solar radiation pressure with conical eclipse - Sun and Moon third-body perturbations</p> <p>Requires parameter vector: [mass, drag_area, Cd, srp_area, Cr]</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.earth_gravity","title":"earth_gravity  <code>builtin</code>","text":"<pre><code>earth_gravity() -&gt; ForceModelConfig\n</code></pre> <p>Create an Earth gravity-only configuration (no drag, SRP, or third-body).</p> <p>Uses 20x20 EGM2008 gravity. No parameter vector required.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.geo_default","title":"geo_default  <code>builtin</code>","text":"<pre><code>geo_default() -&gt; ForceModelConfig\n</code></pre> <p>Create a configuration suitable for GEO satellites.</p> <p>Includes SRP and third-body perturbations, omits drag. Requires parameter vector: [mass, , , srp_area, Cr]</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.high_fidelity","title":"high_fidelity  <code>builtin</code>","text":"<pre><code>high_fidelity() -&gt; ForceModelConfig\n</code></pre> <p>Create a high-fidelity force model configuration.</p> <p>Includes: - 120x120 EGM2008 gravity - NRLMSISE-00 atmospheric model - SRP with conical eclipse - Sun, Moon, and all planets (DE440s ephemerides) - Relativistic corrections</p> <p>Requires parameter vector: [mass, drag_area, Cd, srp_area, Cr]</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.leo_default","title":"leo_default  <code>builtin</code>","text":"<pre><code>leo_default() -&gt; ForceModelConfig\n</code></pre> <p>Create a configuration suitable for LEO satellites.</p> <p>Includes drag and higher-order gravity, plus SRP and third-body. Requires parameter vector: [mass, drag_area, Cd, srp_area, Cr]</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.requires_params","title":"requires_params  <code>method descriptor</code>","text":"<pre><code>requires_params() -&gt; Any\n</code></pre> <p>Check if this configuration requires a parameter vector.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ForceModelConfig.two_body","title":"two_body  <code>builtin</code>","text":"<pre><code>two_body() -&gt; ForceModelConfig\n</code></pre> <p>Create a two-body (point mass) gravity configuration.</p> <p>Uses only central body gravity with no perturbations. Produces results equivalent to Keplerian propagation. No parameter vector required.</p>"},{"location":"library_api/propagators/force_model_config.html#configuration-components","title":"Configuration Components","text":""},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration","title":"GravityConfiguration","text":"<pre><code>GravityConfiguration(degree: int = None, order: int = None, model_type: GravityModelType = None, use_global: bool = False)\n</code></pre> <p>Gravity model configuration.</p> <p>Specifies the gravity model: point mass or spherical harmonic expansion.</p> <p>Parameters:</p> Name Type Description Default <code>degree</code> <code>int</code> <p>Maximum degree of spherical harmonic expansion. If None, uses point mass gravity.</p> <code>None</code> <code>order</code> <code>int</code> <p>Maximum order of spherical harmonic expansion. If None, uses point mass gravity.</p> <code>None</code> <code>model_type</code> <code>GravityModelType</code> <p>Gravity model to use. Defaults to EGM2008_360.</p> <code>None</code> <code>use_global</code> <code>bool</code> <p>If True, use global gravity model. Defaults to False.</p> <code>False</code> Example <pre><code>import brahe as bh\n\n# Simple two-body point mass gravity (default)\ngravity = bh.GravityConfiguration()\n\n# Spherical harmonic with 20x20 degree/order\ngravity = bh.GravityConfiguration(degree=20, order=20)\n\n# Spherical harmonic with specific model\ngravity = bh.GravityConfiguration(\n    degree=20, order=20, model_type=bh.GravityModelType.GGM05S\n)\n\n# Alternative: use class methods\ngravity = bh.GravityConfiguration.point_mass()\ngravity = bh.GravityConfiguration.spherical_harmonic(degree=20, order=20)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.get_degree","title":"get_degree  <code>method descriptor</code>","text":"<pre><code>get_degree() -&gt; int\n</code></pre> <p>Get the degree (for spherical harmonic).</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: Degree if spherical harmonic, None otherwise.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.get_order","title":"get_order  <code>method descriptor</code>","text":"<pre><code>get_order() -&gt; int\n</code></pre> <p>Get the order (for spherical harmonic).</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: Order if spherical harmonic, None otherwise.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.is_point_mass","title":"is_point_mass  <code>method descriptor</code>","text":"<pre><code>is_point_mass() -&gt; Any\n</code></pre> <p>Check if this is point mass gravity.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.is_spherical_harmonic","title":"is_spherical_harmonic  <code>method descriptor</code>","text":"<pre><code>is_spherical_harmonic() -&gt; Any\n</code></pre> <p>Check if this is spherical harmonic gravity.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.point_mass","title":"point_mass  <code>builtin</code>","text":"<pre><code>point_mass() -&gt; GravityConfiguration\n</code></pre> <p>Create a point mass gravity configuration.</p> <p>Returns:</p> Name Type Description <code>GravityConfiguration</code> <code>GravityConfiguration</code> <p>Point mass (two-body) gravity.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.GravityConfiguration.spherical_harmonic","title":"spherical_harmonic  <code>builtin</code>","text":"<pre><code>spherical_harmonic(degree: int, order: int, model_type: GravityModelType = None, use_global: bool = False) -&gt; GravityConfiguration\n</code></pre> <p>Create a spherical harmonic gravity configuration.</p> <p>Parameters:</p> Name Type Description Default <code>degree</code> <code>int</code> <p>Maximum degree of expansion.</p> required <code>order</code> <code>int</code> <p>Maximum order of expansion.</p> required <code>model_type</code> <code>GravityModelType</code> <p>Gravity model to use. Defaults to EGM2008_360.</p> <code>None</code> <code>use_global</code> <code>bool</code> <p>If True, use global gravity model. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>GravityConfiguration</code> <code>GravityConfiguration</code> <p>Spherical harmonic gravity.</p> Example <pre><code>import brahe as bh\n\n# Default (EGM2008)\ngravity = bh.GravityConfiguration.spherical_harmonic(degree=20, order=20)\n\n# With specific model\ngravity = bh.GravityConfiguration.spherical_harmonic(\n    degree=20, order=20, model_type=bh.GravityModelType.GGM05S\n)\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.DragConfiguration","title":"DragConfiguration","text":"<pre><code>DragConfiguration(model: AtmosphericModel, area: ParameterSource, cd: ParameterSource)\n</code></pre> <p>Atmospheric drag configuration.</p> <p>Defines the atmospheric model and drag parameters.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AtmosphericModel</code> <p>Atmospheric density model.</p> required <code>area</code> <code>ParameterSource</code> <p>Drag cross-sectional area source [m\u00b2].</p> required <code>cd</code> <code>ParameterSource</code> <p>Drag coefficient source (dimensionless).</p> required <p>Attributes:</p> Name Type Description <code>model</code> <code>AtmosphericModel</code> <p>Atmospheric density model</p> <code>area</code> <code>ParameterSource</code> <p>Drag area source</p> <code>cd</code> <code>ParameterSource</code> <p>Drag coefficient source</p> Example <pre><code>import brahe as bh\n\ndrag = bh.DragConfiguration(\n    model=bh.AtmosphericModel.HARRIS_PRIESTER,\n    area=bh.ParameterSource.parameter_index(1),\n    cd=bh.ParameterSource.value(2.2)\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.DragConfiguration.area","title":"area  <code>property</code>","text":"<pre><code>area: Any\n</code></pre> <p>Get the drag area parameter source.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.DragConfiguration.cd","title":"cd  <code>property</code>","text":"<pre><code>cd: Any\n</code></pre> <p>Get the drag coefficient parameter source.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.DragConfiguration.model","title":"model  <code>property</code>","text":"<pre><code>model: Any\n</code></pre> <p>Get the atmospheric model.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.SolarRadiationPressureConfiguration","title":"SolarRadiationPressureConfiguration","text":"<pre><code>SolarRadiationPressureConfiguration(area: ParameterSource, cr: ParameterSource, eclipse_model: EclipseModel)\n</code></pre> <p>Solar radiation pressure configuration.</p> <p>Defines the SRP parameters and eclipse model.</p> <p>Parameters:</p> Name Type Description Default <code>area</code> <code>ParameterSource</code> <p>SRP cross-sectional area source [m\u00b2].</p> required <code>cr</code> <code>ParameterSource</code> <p>Coefficient of reflectivity source (dimensionless).</p> required <code>eclipse_model</code> <code>EclipseModel</code> <p>Eclipse model for shadow effects.</p> required <p>Attributes:</p> Name Type Description <code>area</code> <code>ParameterSource</code> <p>SRP area source</p> <code>cr</code> <code>ParameterSource</code> <p>Reflectivity coefficient source</p> <code>eclipse_model</code> <code>EclipseModel</code> <p>Eclipse model</p> Example <pre><code>import brahe as bh\n\nsrp = bh.SolarRadiationPressureConfiguration(\n    area=bh.ParameterSource.parameter_index(3),\n    cr=bh.ParameterSource.parameter_index(4),\n    eclipse_model=bh.EclipseModel.CONICAL\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.SolarRadiationPressureConfiguration.area","title":"area  <code>property</code>","text":"<pre><code>area: Any\n</code></pre> <p>Get the SRP area parameter source.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.SolarRadiationPressureConfiguration.cr","title":"cr  <code>property</code>","text":"<pre><code>cr: Any\n</code></pre> <p>Get the coefficient of reflectivity parameter source.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.SolarRadiationPressureConfiguration.eclipse_model","title":"eclipse_model  <code>property</code>","text":"<pre><code>eclipse_model: Any\n</code></pre> <p>Get the eclipse model.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBodyConfiguration","title":"ThirdBodyConfiguration","text":"<pre><code>ThirdBodyConfiguration(ephemeris_source: EphemerisSource, bodies: list[ThirdBody])\n</code></pre> <p>Third-body perturbations configuration.</p> <p>Defines which celestial bodies to include and ephemeris source.</p> <p>Parameters:</p> Name Type Description Default <code>ephemeris_source</code> <code>EphemerisSource</code> <p>Source for celestial body ephemerides.</p> required <code>bodies</code> <code>list[ThirdBody]</code> <p>List of bodies to include as perturbers.</p> required <p>Attributes:</p> Name Type Description <code>ephemeris_source</code> <code>EphemerisSource</code> <p>Ephemeris source</p> <code>bodies</code> <code>list[ThirdBody]</code> <p>List of perturbing bodies</p> Example <pre><code>import brahe as bh\n\nthird_body = bh.ThirdBodyConfiguration(\n    ephemeris_source=bh.EphemerisSource.DE440s,\n    bodies=[bh.ThirdBody.SUN, bh.ThirdBody.MOON]\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBodyConfiguration.bodies","title":"bodies  <code>property</code>","text":"<pre><code>bodies: Any\n</code></pre> <p>Get the list of third bodies.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBodyConfiguration.ephemeris_source","title":"ephemeris_source  <code>property</code>","text":"<pre><code>ephemeris_source: Any\n</code></pre> <p>Get the ephemeris source.</p>"},{"location":"library_api/propagators/force_model_config.html#enumerations","title":"Enumerations","text":""},{"location":"library_api/propagators/force_model_config.html#brahe.AtmosphericModel","title":"AtmosphericModel","text":"<pre><code>AtmosphericModel()\n</code></pre> <p>Atmospheric density model selection.</p> Example <pre><code>import brahe as bh\n\nmodel = bh.AtmosphericModel.HARRIS_PRIESTER\nmodel = bh.AtmosphericModel.NRLMSISE00\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.AtmosphericModel.HARRIS_PRIESTER","title":"HARRIS_PRIESTER  <code>class-attribute</code>","text":"<pre><code>HARRIS_PRIESTER: Any = AtmosphericModel(HarrisPriester)\n</code></pre> <p>Atmospheric density model selection.</p> Example <pre><code>import brahe as bh\n\nmodel = bh.AtmosphericModel.HARRIS_PRIESTER\nmodel = bh.AtmosphericModel.NRLMSISE00\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.AtmosphericModel.NRLMSISE00","title":"NRLMSISE00  <code>class-attribute</code>","text":"<pre><code>NRLMSISE00: Any = AtmosphericModel(NRLMSISE00)\n</code></pre> <p>Atmospheric density model selection.</p> Example <pre><code>import brahe as bh\n\nmodel = bh.AtmosphericModel.HARRIS_PRIESTER\nmodel = bh.AtmosphericModel.NRLMSISE00\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.AtmosphericModel.exponential","title":"exponential  <code>builtin</code>","text":"<pre><code>exponential(scale_height: float, rho0: float, h0: float) -&gt; AtmosphericModel\n</code></pre> <p>Create exponential atmosphere model with custom parameters.</p> <p>Parameters:</p> Name Type Description Default <code>scale_height</code> <code>float</code> <p>Scale height in meters.</p> required <code>rho0</code> <code>float</code> <p>Reference density in kg/m\u00b3.</p> required <code>h0</code> <code>float</code> <p>Reference altitude in meters.</p> required"},{"location":"library_api/propagators/force_model_config.html#brahe.EclipseModel","title":"EclipseModel","text":"<pre><code>EclipseModel()\n</code></pre> <p>Eclipse model for solar radiation pressure calculations.</p> Example <pre><code>import brahe as bh\n\neclipse = bh.EclipseModel.CONICAL\neclipse = bh.EclipseModel.CYLINDRICAL\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.EclipseModel.CONICAL","title":"CONICAL  <code>class-attribute</code>","text":"<pre><code>CONICAL: Any = EclipseModel.Conical\n</code></pre> <p>Eclipse model for solar radiation pressure calculations.</p> Example <pre><code>import brahe as bh\n\neclipse = bh.EclipseModel.CONICAL\neclipse = bh.EclipseModel.CYLINDRICAL\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.EclipseModel.CYLINDRICAL","title":"CYLINDRICAL  <code>class-attribute</code>","text":"<pre><code>CYLINDRICAL: Any = EclipseModel.Cylindrical\n</code></pre> <p>Eclipse model for solar radiation pressure calculations.</p> Example <pre><code>import brahe as bh\n\neclipse = bh.EclipseModel.CONICAL\neclipse = bh.EclipseModel.CYLINDRICAL\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.EclipseModel.NONE","title":"NONE  <code>class-attribute</code>","text":"<pre><code>NONE: Any = EclipseModel.None\n</code></pre> <p>Eclipse model for solar radiation pressure calculations.</p> Example <pre><code>import brahe as bh\n\neclipse = bh.EclipseModel.CONICAL\neclipse = bh.EclipseModel.CYLINDRICAL\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody","title":"ThirdBody","text":"<pre><code>ThirdBody()\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.JUPITER","title":"JUPITER  <code>class-attribute</code>","text":"<pre><code>JUPITER: Any = ThirdBody.JUPITER\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.MARS","title":"MARS  <code>class-attribute</code>","text":"<pre><code>MARS: Any = ThirdBody.MARS\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.MERCURY","title":"MERCURY  <code>class-attribute</code>","text":"<pre><code>MERCURY: Any = ThirdBody.MERCURY\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.MOON","title":"MOON  <code>class-attribute</code>","text":"<pre><code>MOON: Any = ThirdBody.MOON\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.NEPTUNE","title":"NEPTUNE  <code>class-attribute</code>","text":"<pre><code>NEPTUNE: Any = ThirdBody.NEPTUNE\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.SATURN","title":"SATURN  <code>class-attribute</code>","text":"<pre><code>SATURN: Any = ThirdBody.SATURN\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.SUN","title":"SUN  <code>class-attribute</code>","text":"<pre><code>SUN: Any = ThirdBody.SUN\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.URANUS","title":"URANUS  <code>class-attribute</code>","text":"<pre><code>URANUS: Any = ThirdBody.URANUS\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ThirdBody.VENUS","title":"VENUS  <code>class-attribute</code>","text":"<pre><code>VENUS: Any = ThirdBody.VENUS\n</code></pre> <p>Third-body perturber.</p> <p>Celestial bodies that can act as gravitational perturbers.</p> Example <pre><code>import brahe as bh\n\nsun = bh.ThirdBody.SUN\nmoon = bh.ThirdBody.MOON\n</code></pre>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource","title":"ParameterSource","text":"<pre><code>ParameterSource()\n</code></pre> <p>Source for a parameter value (fixed or from parameter vector).</p> <p>Allows specifying whether a parameter comes from a fixed value or from an index in the parameter vector.</p> Example <pre><code>import brahe as bh\n\n# Fixed drag coefficient\ncd = bh.ParameterSource.value(2.2)\n\n# Variable mass from parameter vector index 0\nmass = bh.ParameterSource.parameter_index(0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.get_index","title":"get_index  <code>method descriptor</code>","text":"<pre><code>get_index() -&gt; int\n</code></pre> <p>Get the parameter index (if this is a ParameterIndex source).</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The parameter index, or None if this is a Value.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.get_value","title":"get_value  <code>method descriptor</code>","text":"<pre><code>get_value() -&gt; float\n</code></pre> <p>Get the fixed value (if this is a Value source).</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: The fixed value, or None if this is a ParameterIndex.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.is_parameter_index","title":"is_parameter_index  <code>method descriptor</code>","text":"<pre><code>is_parameter_index() -&gt; Any\n</code></pre> <p>Check if this source references a parameter index.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.is_value","title":"is_value  <code>method descriptor</code>","text":"<pre><code>is_value() -&gt; Any\n</code></pre> <p>Check if this source is a fixed value.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.parameter_index","title":"parameter_index  <code>builtin</code>","text":"<pre><code>parameter_index(index: int) -&gt; ParameterSource\n</code></pre> <p>Create a parameter index source.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index into the parameter vector.</p> required <p>Returns:</p> Name Type Description <code>ParameterSource</code> <code>ParameterSource</code> <p>A parameter source referencing a parameter vector index.</p>"},{"location":"library_api/propagators/force_model_config.html#brahe.ParameterSource.value","title":"value  <code>builtin</code>","text":"<pre><code>value(value: float) -&gt; ParameterSource\n</code></pre> <p>Create a fixed value parameter source.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The fixed parameter value.</p> required <p>Returns:</p> Name Type Description <code>ParameterSource</code> <code>ParameterSource</code> <p>A parameter source with a fixed value.</p>"},{"location":"library_api/propagators/force_model_config.html#see-also","title":"See Also","text":"<ul> <li>NumericalOrbitPropagator - Propagator using force models</li> <li>Orbital Dynamics - Detailed force model documentation</li> <li>Force Models Guide - User guide</li> </ul>"},{"location":"library_api/propagators/functions.html","title":"Propagator Functions","text":"<p>Utility functions for orbit propagation operations.</p>"},{"location":"library_api/propagators/functions.html#par_propagate_to","title":"par_propagate_to","text":""},{"location":"library_api/propagators/functions.html#brahe.par_propagate_to","title":"par_propagate_to  <code>builtin</code>","text":"<pre><code>par_propagate_to(propagators: Union[List[KeplerianPropagator], List[SGPPropagator], List[NumericalOrbitPropagator]], target_epoch: Epoch) -&gt; None\n</code></pre> <p>Propagate multiple propagators to a target epoch in parallel.</p> <p>This function takes a list of propagators and calls <code>propagate_to</code> on each one in parallel using the global thread pool. Each propagator's internal state is updated to reflect the new epoch.</p> <p>All propagators in the list must be of the same type (either all <code>KeplerianPropagator</code>, all <code>SGPPropagator</code>, or all <code>NumericalOrbitPropagator</code>). Mixing propagator types is not supported.</p> <p>Note: <code>NumericalPropagator</code> (with user-defined Python dynamics) is NOT supported because Python callbacks cannot safely execute in parallel due to the GIL. Use <code>NumericalOrbitPropagator</code> for parallel propagation of orbital dynamics.</p> <p>Note: For SGPPropagator and NumericalOrbitPropagator, event detectors and event logs are properly preserved during parallel propagation. Events detected during propagation will be available in each propagator's <code>event_log()</code> after the call completes.</p> <p>Parameters:</p> Name Type Description Default <code>propagators</code> <code>List[KeplerianPropagator] or List[SGPPropagator] or List[NumericalOrbitPropagator]</code> <p>List of propagators to update.</p> required <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate all propagators to.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Propagators are updated in place.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create multiple propagators\npropagators = []\nfor i in range(10):\n    oe = np.array([bh.R_EARTH + 500e3 + i*10e3, 0.001, 98.0, i*10.0, 0.0, 0.0])\n    state = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\n    propagators.append(prop)\n\n# Propagate all to target epoch in parallel\ntarget = epoch + 3600.0  # 1 hour later\nbh.par_propagate_to(propagators, target)\n\n# All propagators are now at target epoch\nfor prop in propagators:\n    assert prop.current_epoch() == target\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html","title":"Keplerian Propagator","text":"<p>Analytical two-body orbit propagator using Keplerian orbital elements. The Keplerian propagator provides fast, analytical orbit propagation for unperturbed two-body motion. It uses closed-form solutions to Kepler's equations for orbital element propagation.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#orbital-elements","title":"Orbital Elements","text":"<p>The propagator accepts orbital elements in the following order: 1. a - Semi-major axis (meters) 2. e - Eccentricity (dimensionless) 3. i - Inclination (degrees radians) 4. \u03a9 - Right ascension of ascending node (degrees radians) 5. \u03c9 - Argument of periapsis (degrees radians) 6. M or \u03bd - Mean anomaly or true anomaly (degrees radians)</p> <p>Use <code>OrbitRepresentation</code> to specify element type: - <code>MEAN_ELEMENTS</code> - Mean orbital elements with mean anomaly - <code>OSCULATING_ELEMENTS</code> - Osculating elements with true anomaly</p>"},{"location":"library_api/propagators/keplerian_propagator.html#class-reference","title":"Class Reference","text":""},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator","title":"KeplerianPropagator","text":"<pre><code>KeplerianPropagator(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat, step_size: float)\n</code></pre> <p>Keplerian orbit propagator using two-body dynamics.</p> <p>The Keplerian propagator implements ideal two-body orbital mechanics without perturbations. It's fast and accurate for short time spans but doesn't account for real-world effects like drag, J2, solar radiation pressure, etc.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for Keplerian elements.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Attributes:</p> Name Type Description <code>current_epoch</code> <code>Epoch</code> <p>Current propagation time</p> <code>initial_epoch</code> <code>Epoch</code> <p>Initial epoch from propagator creation</p> <code>step_size</code> <code>float</code> <p>Current step size in seconds</p> <code>trajectory</code> <code>OrbitTrajectory</code> <p>Accumulated trajectory states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initial epoch and orbital elements\nepc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\n\n# Create propagator from Keplerian elements\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\n)\n\n# Propagate forward one orbit\nperiod = bh.orbital_period(oe[0])\nepc_future = epc0 + period\nstate = prop.state(epc_future)\nprint(f\"State after one orbit: {state}\")\n\n# Create from Cartesian state\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\nprop2 = bh.KeplerianPropagator(\n    epc0, x_cart, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    bh.AngleFormat.RADIANS, 60.0\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Epoch\n</code></pre> <p>Get initial epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Initial propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: SOrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>SOrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\ntraj = prop.trajectory\nprint(f\"Trajectory contains {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_ecef","title":"from_ecef  <code>builtin</code>","text":"<pre><code>from_ecef(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECEF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECEF frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECI frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_keplerian","title":"from_keplerian  <code>builtin</code>","text":"<pre><code>from_keplerian(epoch: Epoch, elements: ndarray, angle_format: AngleFormat, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>elements</code> <code>ndarray</code> <p>6-element Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format (Degrees or Radians).</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_id(12345)\nprint(f\"ID: {prop.get_id()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_name(\"MySat\")\nprint(f\"Name: {prop.get_name()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator.from_eci(epc, state, 60.0).with_new_uuid()\nprint(f\"UUID: {prop.get_uuid()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)  # Take 10 steps (600 seconds total)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 3600.0  # Propagate to 1 hour ahead\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\nprop.reset()  # Return to initial epoch and state\nprint(f\"Reset to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_age(3600.0)  # Keep only states within 1 hour\nprop.propagate_to(epc + 7200.0)  # Propagate 2 hours\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_size(100)  # Keep only 100 most recent states\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_initial_conditions","title":"set_initial_conditions  <code>method descriptor</code>","text":"<pre><code>set_initial_conditions(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Set initial conditions.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame.</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\n\n# Change initial conditions to a different orbit\nnew_oe = np.array([bh.R_EARTH + 800e3, 0.02, 1.2, 0.5, 0.3, 0.0])\nnew_state = bh.state_koe_to_eci(new_oe, bh.AngleFormat.RADIANS)\nnew_epc = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop.set_initial_conditions(new_epc, new_state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, bh.AngleFormat.RADIANS)\nprint(f\"New initial epoch: {prop.initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_step_size","title":"set_step_size  <code>method descriptor</code>","text":"<pre><code>set_step_size(new_step_size: float) -&gt; Any\n</code></pre> <p>Set step size in seconds (explicit method).</p> <p>Parameters:</p> Name Type Description Default <code>new_step_size</code> <code>float</code> <p>New step size in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\npropagator.set_step_size(120.0)  # Can use explicit method\n# or propagator.step_size = 120.0  # Can use property\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_eme2000","title":"state_eme2000  <code>method descriptor</code>","text":"<pre><code>state_eme2000(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in EME2000 coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in EME2000 frame (meters, m/s).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_gcrf","title":"state_gcrf  <code>method descriptor</code>","text":"<pre><code>state_gcrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in GCRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in GCRF frame (meters, m/s).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_itrf","title":"state_itrf  <code>method descriptor</code>","text":"<pre><code>state_itrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ITRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ITRF frame (meters, m/s).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_koe_mean","title":"state_koe_mean  <code>method descriptor</code>","text":"<pre><code>state_koe_mean(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as mean Keplerian elements at a specific epoch.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Mean Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_koe_osc","title":"state_koe_osc  <code>method descriptor</code>","text":"<pre><code>state_koe_osc(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_ecef","title":"states_ecef  <code>method descriptor</code>","text":"<pre><code>states_ecef(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECEF state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_gcrf","title":"states_gcrf  <code>method descriptor</code>","text":"<pre><code>states_gcrf(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in GCRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of GCRF state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_itrf","title":"states_itrf  <code>method descriptor</code>","text":"<pre><code>states_itrf(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ITRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ITRF state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_koe_mean","title":"states_koe_mean  <code>method descriptor</code>","text":"<pre><code>states_koe_mean(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as mean Keplerian elements at multiple epochs.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of mean Keplerian element vectors [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_koe_osc","title":"states_koe_osc  <code>method descriptor</code>","text":"<pre><code>states_koe_osc(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step()  # Advance by default step_size (60 seconds)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step_by(120.0)  # Advance by 120 seconds\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 300.0  # Target 5 minutes ahead\nprop.step_past(target)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; KeplerianPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; KeplerianPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with identity set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000e3, 0.001, 0.9, 0.0, 0.0, 0.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc, oe, bh.AngleFormat.RADIANS, 60.0\n).with_name(\"My Orbit\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; KeplerianPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#see-also","title":"See Also","text":"<ul> <li>SGPPropagator - SGP4/SDP4 propagator for TLE data</li> <li>Keplerian Elements - Orbital element conversion functions</li> <li>OrbitRepresentation - Element type specification</li> </ul>"},{"location":"library_api/propagators/numerical_orbit_propagator.html","title":"NumericalOrbitPropagator","text":"<p>High-fidelity numerical orbit propagator with built-in force models. The <code>NumericalOrbitPropagator</code> integrates orbital dynamics equations using configurable integrators and force models including gravity harmonics, atmospheric drag, solar radiation pressure, and third-body perturbations.</p> <p>Note</p> <p>For conceptual explanations and usage examples, see Numerical Propagation in the User Guide.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator","title":"NumericalOrbitPropagator","text":"<pre><code>NumericalOrbitPropagator(epoch: Epoch, state: ndarray, propagation_config: NumericalPropagationConfig, force_config: ForceModelConfig, params: Union[ndarray, None] = None, initial_covariance: Union[ndarray, None] = None, additional_dynamics: Union[callable, None] = None, control_input: Union[callable, None] = None)\n</code></pre> <p>High-fidelity numerical orbit propagator with configurable force models.</p> <p>This propagator uses numerical integration with built-in orbital force models: - Gravity (point mass or spherical harmonic) - Atmospheric drag (Harris-Priester, NRLMSISE-00, or exponential) - Solar radiation pressure with eclipse modeling - Third-body perturbations (Sun, Moon, planets) - Relativistic corrections</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector in ECI Cartesian [x, y, z, vx, vy, vz] (meters, m/s). Can be 6D or 6+N dimensional for extended state.</p> required <code>propagation_config</code> <code>NumericalPropagationConfig</code> <p>Propagation configuration.</p> required <code>force_config</code> <code>ForceModelConfig</code> <p>Force model configuration.</p> required <code>params</code> <code>ndarray or None</code> <p>Parameter vector [mass, drag_area, Cd, srp_area, Cr, ...]. Required if force_config references parameter indices.</p> <code>None</code> <code>initial_covariance</code> <code>ndarray or None</code> <p>Optional 6x6 initial covariance matrix (enables STM).</p> <code>None</code> <code>additional_dynamics</code> <code>callable or None</code> <p>Optional function for extended state dynamics. Signature: f(t, state, params) -&gt; derivative.</p> <code>None</code> <code>control_input</code> <code>callable or None</code> <p>Optional control input function for thrust accelerations. Signature: f(t, state, params) -&gt; 3D acceleration vector.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>current_epoch</code> <code>Epoch</code> <p>Current propagation time</p> <code>initial_epoch</code> <code>Epoch</code> <p>Initial epoch from propagator creation</p> <code>state_dim</code> <code>int</code> <p>Dimension of state vector (6 for basic, 6+N for extended)</p> <code>step_size</code> <code>float</code> <p>Current integration step size in seconds</p> <code>trajectory</code> <code>OrbitTrajectory</code> <p>Accumulated trajectory states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Create initial state (ECI Cartesian)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.DEGREES)\n\n# Parameters: [mass, drag_area, Cd, srp_area, Cr]\nparams = np.array([1000.0, 10.0, 2.2, 10.0, 1.3])\n\n# Create propagator with default configs\nprop = bh.NumericalOrbitPropagator(\n    epoch, state,\n    bh.NumericalPropagationConfig.default(),\n    bh.ForceModelConfig.default(),\n    params\n)\n\n# Propagate\nprop.propagate_to(epoch + 3600.0)  # 1 hour\nprint(f\"Final state: {prop.current_state()}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Any\n</code></pre> <p>Get current epoch.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Any\n</code></pre> <p>Get initial epoch.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_dim","title":"state_dim  <code>property</code>","text":"<pre><code>state_dim: ndarray\n</code></pre> <p>Get state dimension.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: Any\n</code></pre> <p>Get current step size.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.trajectory_mode","title":"trajectory_mode  <code>property</code>","text":"<pre><code>trajectory_mode: TrajectoryMode\n</code></pre> <p>Get current trajectory storage mode.</p> <p>Returns:</p> Name Type Description <code>TrajectoryMode</code> <code>TrajectoryMode</code> <p>Current trajectory mode.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.add_event_detector","title":"add_event_detector  <code>method descriptor</code>","text":"<pre><code>add_event_detector(event: Union[TimeEvent, ValueEvent, BinaryEvent, AltitudeEvent]) -&gt; Any\n</code></pre> <p>Add an event detector to this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>TimeEvent or ValueEvent or BinaryEvent or AltitudeEvent</code> <p>Event detector</p> required Example <pre><code>import brahe as bh\n\nprop = bh.NumericalOrbitPropagator.from_eci(epoch, state)\nevent = bh.TimeEvent(epoch + 1800.0, \"30 min mark\")\nprop.add_event_detector(event)\n</code></pre>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.clear_events","title":"clear_events  <code>method descriptor</code>","text":"<pre><code>clear_events() -&gt; Any\n</code></pre> <p>Clear all detected events from the event log.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.covariance","title":"covariance  <code>method descriptor</code>","text":"<pre><code>covariance(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get covariance at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Covariance matrix at the requested epoch.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.covariance_gcrf","title":"covariance_gcrf  <code>method descriptor</code>","text":"<pre><code>covariance_gcrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get covariance at a specific epoch in GCRF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Covariance matrix in GCRF frame.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.covariance_rtn","title":"covariance_rtn  <code>method descriptor</code>","text":"<pre><code>covariance_rtn(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get covariance at a specific epoch in RTN (Radial-Tangential-Normal) frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Covariance matrix in RTN frame.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.current_params","title":"current_params  <code>method descriptor</code>","text":"<pre><code>current_params() -&gt; ndarray\n</code></pre> <p>Get current parameter vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: Current parameter vector, or None if no params.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.event_log","title":"event_log  <code>method descriptor</code>","text":"<pre><code>event_log() -&gt; list[DetectedEvent]\n</code></pre> <p>Get the event log (list of detected events).</p> <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: List of events detected during propagation.</p> Example <pre><code>import brahe as bh\n\nprop.propagate_to(epoch + 3600.0)\nevents = prop.event_log()\nfor event in events:\n    print(f\"Event '{event.name}' at {event.window_open}\")\n</code></pre>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.events_by_detector_index","title":"events_by_detector_index  <code>method descriptor</code>","text":"<pre><code>events_by_detector_index(index: int) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by detector index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Detector index (0-based, in order of add_event_detector calls).</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events from the specified detector.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.events_by_detector_index_in_range","title":"events_by_detector_index_in_range  <code>method descriptor</code>","text":"<pre><code>events_by_detector_index_in_range(index: int, start: Epoch, end: Epoch) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by detector index within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Detector index (0-based, in order of add_event_detector calls).</p> required <code>start</code> <code>Epoch</code> <p>Start of time range (inclusive).</p> required <code>end</code> <code>Epoch</code> <p>End of time range (inclusive).</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events from the specified detector within the time range.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.events_by_name","title":"events_by_name  <code>method descriptor</code>","text":"<pre><code>events_by_name(name: str) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name to filter by.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events matching the given name.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.events_by_name_in_range","title":"events_by_name_in_range  <code>method descriptor</code>","text":"<pre><code>events_by_name_in_range(name_pattern: str, start: Epoch, end: Epoch) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by name pattern within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>name_pattern</code> <code>str</code> <p>Substring to search for in event names.</p> required <code>start</code> <code>Epoch</code> <p>Start of time range (inclusive).</p> required <code>end</code> <code>Epoch</code> <p>End of time range (inclusive).</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events matching the name pattern within the time range.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.events_in_range","title":"events_in_range  <code>method descriptor</code>","text":"<pre><code>events_in_range(start: Epoch, end: Epoch) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events in time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Epoch</code> <p>Start of time range.</p> required <code>end</code> <code>Epoch</code> <p>End of time range.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events within the given time range.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, params: Union[ndarray, None] = None, force_config: Union[ForceModelConfig, None] = None) -&gt; NumericalOrbitPropagator\n</code></pre> <p>Create a propagator from ECI Cartesian state with simplified configuration.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial ECI Cartesian state [x, y, z, vx, vy, vz].</p> required <code>params</code> <code>ndarray or None</code> <p>Parameter vector.</p> <code>None</code> <code>force_config</code> <code>ForceModelConfig or None</code> <p>Force model config (default if None).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NumericalOrbitPropagator</code> <code>NumericalOrbitPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.get_covariance_interpolation_method","title":"get_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_covariance_interpolation_method() -&gt; CovarianceInterpolationMethod\n</code></pre> <p>Get current interpolation method for covariance queries.</p> <p>Returns:</p> Name Type Description <code>CovarianceInterpolationMethod</code> <code>CovarianceInterpolationMethod</code> <p>Current covariance interpolation method.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; Any\n</code></pre> <p>Get the current numeric ID.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get current interpolation method for state trajectory queries.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; Any\n</code></pre> <p>Get the current name.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; Any\n</code></pre> <p>Get the current UUID.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state vector.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.latest_event","title":"latest_event  <code>method descriptor</code>","text":"<pre><code>latest_event() -&gt; DetectedEvent\n</code></pre> <p>Get latest detected event, if any.</p> <p>Returns:</p> Type Description <code>DetectedEvent</code> <p>DetectedEvent or None: The most recently detected event.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.query_events","title":"query_events  <code>method descriptor</code>","text":"<pre><code>query_events() -&gt; EventQuery\n</code></pre> <p>Create an event query builder for filtering detected events.</p> <p>Returns an EventQuery that allows chainable filtering of detected events. Call <code>.collect()</code> on the query to get the final list of events.</p> <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>Query builder for filtering events</p> Example <pre><code>import brahe as bh\n\n# Get events from detector 0 within a time range\nevents = prop.query_events() \\\n    .by_detector_index(0) \\\n    .in_time_range(start, end) \\\n    .collect()\n\n# Count events by name pattern\ncount = prop.query_events() \\\n    .by_name_contains(\"Altitude\") \\\n    .count()\n\n# Combined filters\nevents = prop.query_events() \\\n    .by_detector_index(1) \\\n    .in_time_range(start, end) \\\n    .collect()\n</code></pre>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.reset_termination","title":"reset_termination  <code>method descriptor</code>","text":"<pre><code>reset_termination() -&gt; Any\n</code></pre> <p>Reset the termination flag to allow continued propagation.</p> <p>After calling this, propagation can continue even if it was previously stopped by a terminal event.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.sensitivity","title":"sensitivity  <code>method descriptor</code>","text":"<pre><code>sensitivity() -&gt; ndarray\n</code></pre> <p>Get current sensitivity matrix if enabled.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: The current sensitivity (n x p matrix), or None if not enabled.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.sensitivity_at","title":"sensitivity_at  <code>method descriptor</code>","text":"<pre><code>sensitivity_at(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get sensitivity matrix at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for sensitivity query.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: The sensitivity matrix at the requested epoch, or None if not enabled.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_covariance_interpolation_method","title":"set_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method for covariance queries.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>Interpolation method for covariance.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set propagator numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>New numeric ID for the propagator.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields at once (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>New name.</p> required <code>uuid_str</code> <code>str or None</code> <p>New UUID string.</p> required <code>id</code> <code>int or None</code> <p>New numeric ID.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the UUID string is invalid.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method for state trajectory queries.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>Interpolation method to use.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set propagator name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>New name for the propagator.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_trajectory_mode","title":"set_trajectory_mode  <code>method descriptor</code>","text":"<pre><code>set_trajectory_mode(mode: TrajectoryMode) -&gt; Any\n</code></pre> <p>Set trajectory storage mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>TrajectoryMode</code> <p>The new trajectory mode.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.set_uuid","title":"set_uuid  <code>method descriptor</code>","text":"<pre><code>set_uuid(uuid_str: Union[str, None]) -&gt; Any\n</code></pre> <p>Set propagator UUID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str or None</code> <p>New UUID string for the propagator.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the UUID string is invalid.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at the requested epoch.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_eme2000","title":"state_eme2000  <code>method descriptor</code>","text":"<pre><code>state_eme2000(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in EME2000 coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in EME2000 frame.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_gcrf","title":"state_gcrf  <code>method descriptor</code>","text":"<pre><code>state_gcrf(epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in GCRF coordinates.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_itrf","title":"state_itrf  <code>method descriptor</code>","text":"<pre><code>state_itrf(epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ITRF coordinates.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_koe_mean","title":"state_koe_mean  <code>method descriptor</code>","text":"<pre><code>state_koe_mean(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as mean Keplerian elements at a specific epoch.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Mean Keplerian elements [a, e, i, \u03a9, \u03c9, M].</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.state_koe_osc","title":"state_koe_osc  <code>method descriptor</code>","text":"<pre><code>state_koe_osc(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating Keplerian elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements [a, e, i, \u03a9, \u03c9, M].</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.states_koe_mean","title":"states_koe_mean  <code>method descriptor</code>","text":"<pre><code>states_koe_mean(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as mean Keplerian elements at multiple epochs.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of target epochs.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of mean Keplerian elements [a, e, i, \u03a9, \u03c9, M].</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.states_koe_osc","title":"states_koe_osc  <code>method descriptor</code>","text":"<pre><code>states_koe_osc(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating Keplerian elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of target epochs.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating Keplerian elements [a, e, i, \u03a9, \u03c9, M].</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.stm","title":"stm  <code>method descriptor</code>","text":"<pre><code>stm() -&gt; ndarray\n</code></pre> <p>Get current STM (State Transition Matrix) if enabled.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: The current STM (n x n matrix), or None if STM not enabled.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.stm_at","title":"stm_at  <code>method descriptor</code>","text":"<pre><code>stm_at(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get STM (State Transition Matrix) at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for STM query.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: The STM at the requested epoch, or None if STM not enabled.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.terminated","title":"terminated  <code>method descriptor</code>","text":"<pre><code>terminated() -&gt; bool\n</code></pre> <p>Check if propagator is terminated due to a terminal event.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if propagation was stopped by a terminal event.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id) -&gt; Any\n</code></pre> <p>Set the numeric ID and return self.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; NumericalOrbitPropagator\n</code></pre> <p>Set all identity fields and return self (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>New name.</p> required <code>uuid_str</code> <code>str or None</code> <p>New UUID string.</p> required <code>id</code> <code>int or None</code> <p>New numeric ID.</p> required <p>Returns:</p> Name Type Description <code>NumericalOrbitPropagator</code> <code>NumericalOrbitPropagator</code> <p>Self for method chaining.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the UUID string is invalid.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name) -&gt; Any\n</code></pre> <p>Set the name and return self.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID, set it, and return self.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#brahe.NumericalOrbitPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str) -&gt; Any\n</code></pre> <p>Set the UUID and return self.</p>"},{"location":"library_api/propagators/numerical_orbit_propagator.html#see-also","title":"See Also","text":"<ul> <li>NumericalPropagator - Generic numerical propagator for arbitrary dynamics</li> <li>ForceModelConfig - Force model configuration</li> <li>Event Detection - Event detection system</li> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>Numerical Propagation Guide - User guide documentation</li> </ul>"},{"location":"library_api/propagators/numerical_propagation_config.html","title":"Numerical Propagation Configuration","text":"<p>Configuration classes for numerical integration settings. <code>NumericalPropagationConfig</code> combines the integration method, integrator tolerances, and variational equation settings into a single configuration object.</p> <p>Note</p> <p>For conceptual explanations and usage examples, see Integrator Configuration in the User Guide.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig","title":"NumericalPropagationConfig","text":"<pre><code>NumericalPropagationConfig(method: Any, integrator: Any, variational: Any)\n</code></pre> <p>Configuration for numerical propagation.</p> <p>Controls the integrator settings, tolerances, and variational equation options.</p> Note <p>This class is created via class methods or static methods: - <code>NumericalPropagationConfig.default()</code> - DP54 with standard tolerances - <code>NumericalPropagationConfig.high_precision()</code> - RKN1210 with tight tolerances - <code>NumericalPropagationConfig.with_method(method)</code> - Custom method with default settings - <code>NumericalPropagationConfig.new(method, integrator, variational)</code> - Full customization</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>IntegrationMethod</code> <p>Integration method</p> <code>integrator</code> <code>IntegratorConfig</code> <p>Integrator configuration (tolerances, step sizes)</p> <code>variational</code> <code>VariationalConfig</code> <p>Variational configuration (STM/sensitivity settings)</p> <code>trajectory_mode</code> <code>TrajectoryMode</code> <p>Trajectory storage mode</p> <code>sampling</code> <code>SamplingConfig</code> <p>Output sampling configuration</p> Example <pre><code>import brahe as bh\n\n# Default configuration (DP54 with standard tolerances)\nconfig = bh.NumericalPropagationConfig.default()\n\n# High precision configuration\nconfig = bh.NumericalPropagationConfig.high_precision()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.abs_tol","title":"abs_tol  <code>property</code>","text":"<pre><code>abs_tol: Any\n</code></pre> <p>Get absolute tolerance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.interpolation_method","title":"interpolation_method  <code>property</code>","text":"<pre><code>interpolation_method: Any\n</code></pre> <p>Get the interpolation method.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.method","title":"method  <code>property</code>","text":"<pre><code>method: Any\n</code></pre> <p>Get the integration method.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.rel_tol","title":"rel_tol  <code>property</code>","text":"<pre><code>rel_tol: Any\n</code></pre> <p>Get relative tolerance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.store_accelerations","title":"store_accelerations  <code>property</code>","text":"<pre><code>store_accelerations: Any\n</code></pre> <p>Get whether acceleration storage is enabled.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.variational","title":"variational  <code>property</code>","text":"<pre><code>variational: Any\n</code></pre> <p>Get variational configuration (STM/sensitivity settings).</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; NumericalPropagationConfig\n</code></pre> <p>Create a default configuration (DP54 with standard tolerances).</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.high_precision","title":"high_precision  <code>builtin</code>","text":"<pre><code>high_precision() -&gt; NumericalPropagationConfig\n</code></pre> <p>Create a high-precision configuration (RKN1210 with tight tolerances).</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_abs_tol","title":"with_abs_tol  <code>method descriptor</code>","text":"<pre><code>with_abs_tol(abs_tol: float) -&gt; NumericalPropagationConfig\n</code></pre> <p>Set absolute tolerance for adaptive integrators.</p> <p>Parameters:</p> Name Type Description Default <code>abs_tol</code> <code>float</code> <p>Absolute tolerance.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated tolerance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_initial_step","title":"with_initial_step  <code>method descriptor</code>","text":"<pre><code>with_initial_step(step: float) -&gt; NumericalPropagationConfig\n</code></pre> <p>Set initial step size.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Initial step size in seconds.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated step size.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(method: InterpolationMethod) -&gt; NumericalPropagationConfig\n</code></pre> <p>Set the interpolation method for trajectory queries.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>The interpolation method to use.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated interpolation method.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_max_step","title":"with_max_step  <code>method descriptor</code>","text":"<pre><code>with_max_step(step: float) -&gt; NumericalPropagationConfig\n</code></pre> <p>Set maximum step size.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Maximum step size in seconds.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated step size.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_method","title":"with_method  <code>builtin</code>","text":"<pre><code>with_method(method: IntegrationMethod) -&gt; NumericalPropagationConfig\n</code></pre> <p>Create a configuration with a specific integration method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>IntegrationMethod</code> <p>The integration method to use.</p> required"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_rel_tol","title":"with_rel_tol  <code>method descriptor</code>","text":"<pre><code>with_rel_tol(rel_tol: float) -&gt; NumericalPropagationConfig\n</code></pre> <p>Set relative tolerance for adaptive integrators.</p> <p>Parameters:</p> Name Type Description Default <code>rel_tol</code> <code>float</code> <p>Relative tolerance.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated tolerance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_sensitivity","title":"with_sensitivity  <code>method descriptor</code>","text":"<pre><code>with_sensitivity() -&gt; NumericalPropagationConfig\n</code></pre> <p>Enable sensitivity matrix propagation (requires params).</p> <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with sensitivity enabled.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_sensitivity_history","title":"with_sensitivity_history  <code>method descriptor</code>","text":"<pre><code>with_sensitivity_history() -&gt; NumericalPropagationConfig\n</code></pre> <p>Enable sensitivity history storage in trajectory.</p> <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with sensitivity history enabled.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_stm","title":"with_stm  <code>method descriptor</code>","text":"<pre><code>with_stm() -&gt; NumericalPropagationConfig\n</code></pre> <p>Enable STM (State Transition Matrix) propagation.</p> <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with STM enabled.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_stm_history","title":"with_stm_history  <code>method descriptor</code>","text":"<pre><code>with_stm_history() -&gt; NumericalPropagationConfig\n</code></pre> <p>Enable STM history storage in trajectory.</p> <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with STM history enabled.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.NumericalPropagationConfig.with_store_accelerations","title":"with_store_accelerations  <code>method descriptor</code>","text":"<pre><code>with_store_accelerations(store: bool) -&gt; NumericalPropagationConfig\n</code></pre> <p>Enable or disable acceleration storage in trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>bool</code> <p>Whether to store accelerations.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagationConfig</code> <code>NumericalPropagationConfig</code> <p>Self with updated setting.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.VariationalConfig","title":"VariationalConfig","text":"<pre><code>VariationalConfig(enable_stm: bool = False, enable_sensitivity: bool = False, store_stm_history: bool = False, store_sensitivity_history: bool = False)\n</code></pre> <p>Configuration for STM and sensitivity matrix propagation.</p> <p>Controls whether the propagator computes and stores variational matrices (State Transition Matrix and Sensitivity Matrix) during propagation.</p> <p>Parameters:</p> Name Type Description Default <code>enable_stm</code> <code>bool</code> <p>Enable State Transition Matrix propagation. Defaults to False.</p> <code>False</code> <code>enable_sensitivity</code> <code>bool</code> <p>Enable sensitivity matrix propagation. Defaults to False.</p> <code>False</code> <code>store_stm_history</code> <code>bool</code> <p>Store STM at output times. Defaults to False.</p> <code>False</code> <code>store_sensitivity_history</code> <code>bool</code> <p>Store sensitivity at output times. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>enable_stm</code> <code>bool</code> <p>Enable State Transition Matrix propagation</p> <code>enable_sensitivity</code> <code>bool</code> <p>Enable sensitivity matrix propagation</p> <code>store_stm_history</code> <code>bool</code> <p>Store STM at output times</p> <code>store_sensitivity_history</code> <code>bool</code> <p>Store sensitivity at output times</p> Example <pre><code>import brahe as bh\n\nconfig = bh.VariationalConfig(enable_stm=True, store_stm_history=True)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.VariationalConfig.enable_sensitivity","title":"enable_sensitivity  <code>property</code>","text":"<pre><code>enable_sensitivity: Any\n</code></pre> <p>Enable sensitivity matrix propagation.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.VariationalConfig.enable_stm","title":"enable_stm  <code>property</code>","text":"<pre><code>enable_stm: Any\n</code></pre> <p>Enable State Transition Matrix (STM) propagation.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.VariationalConfig.store_sensitivity_history","title":"store_sensitivity_history  <code>property</code>","text":"<pre><code>store_sensitivity_history: Any\n</code></pre> <p>Store sensitivity matrix at output times in trajectory.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.VariationalConfig.store_stm_history","title":"store_stm_history  <code>property</code>","text":"<pre><code>store_stm_history: Any\n</code></pre> <p>Store STM at output times in trajectory.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod","title":"IntegrationMethod","text":"<pre><code>IntegrationMethod()\n</code></pre> <p>Integration method for numerical orbit propagation.</p> <p>Specifies which numerical integrator to use. Different methods trade off accuracy, efficiency, and applicability.</p> Example <pre><code>import brahe as bh\n\n# Use default (DP54)\nmethod = bh.IntegrationMethod.DP54\n\n# Create config with specific method\nconfig = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod.DP54","title":"DP54  <code>class-attribute</code>","text":"<pre><code>DP54: Any = IntegrationMethod.DP54\n</code></pre> <p>Integration method for numerical orbit propagation.</p> <p>Specifies which numerical integrator to use. Different methods trade off accuracy, efficiency, and applicability.</p> Example <pre><code>import brahe as bh\n\n# Use default (DP54)\nmethod = bh.IntegrationMethod.DP54\n\n# Create config with specific method\nconfig = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod.RK4","title":"RK4  <code>class-attribute</code>","text":"<pre><code>RK4: Any = IntegrationMethod.RK4\n</code></pre> <p>Integration method for numerical orbit propagation.</p> <p>Specifies which numerical integrator to use. Different methods trade off accuracy, efficiency, and applicability.</p> Example <pre><code>import brahe as bh\n\n# Use default (DP54)\nmethod = bh.IntegrationMethod.DP54\n\n# Create config with specific method\nconfig = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod.RKF45","title":"RKF45  <code>class-attribute</code>","text":"<pre><code>RKF45: Any = IntegrationMethod.RKF45\n</code></pre> <p>Integration method for numerical orbit propagation.</p> <p>Specifies which numerical integrator to use. Different methods trade off accuracy, efficiency, and applicability.</p> Example <pre><code>import brahe as bh\n\n# Use default (DP54)\nmethod = bh.IntegrationMethod.DP54\n\n# Create config with specific method\nconfig = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod.RKN1210","title":"RKN1210  <code>class-attribute</code>","text":"<pre><code>RKN1210: Any = IntegrationMethod.RKN1210\n</code></pre> <p>Integration method for numerical orbit propagation.</p> <p>Specifies which numerical integrator to use. Different methods trade off accuracy, efficiency, and applicability.</p> Example <pre><code>import brahe as bh\n\n# Use default (DP54)\nmethod = bh.IntegrationMethod.DP54\n\n# Create config with specific method\nconfig = bh.NumericalPropagationConfig.with_method(bh.IntegrationMethod.RKF45)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagation_config.html#brahe.IntegrationMethod.is_adaptive","title":"is_adaptive  <code>method descriptor</code>","text":"<pre><code>is_adaptive() -&gt; Any\n</code></pre> <p>Returns true if this integrator uses adaptive step size control.</p>"},{"location":"library_api/propagators/numerical_propagation_config.html#see-also","title":"See Also","text":"<ul> <li>IntegratorConfig - Integrator configuration</li> <li>NumericalOrbitPropagator - Orbit propagator using this configuration</li> <li>NumericalPropagator - Generic propagator using this configuration</li> <li>ForceModelConfig - Force model configuration</li> <li>Integrator Configuration Guide - User guide</li> <li>Covariance and Sensitivity - Variational equations guide</li> </ul>"},{"location":"library_api/propagators/numerical_propagator.html","title":"NumericalPropagator","text":"<p>Generic numerical propagator for arbitrary dynamical systems. Unlike <code>NumericalOrbitPropagator</code> which has built-in orbital force models, <code>NumericalPropagator</code> accepts user-defined dynamics functions, making it suitable for attitude propagation, chemical kinetics, population models, or any ODE system.</p> <p>Note</p> <p>For conceptual explanations and usage examples, see Generic Dynamics in the User Guide.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator","title":"NumericalPropagator","text":"<pre><code>NumericalPropagator(epoch: Epoch, state: ndarray, dynamics: callable, propagation_config: NumericalPropagationConfig, params: Union[ndarray, None] = None, initial_covariance: Union[ndarray, None] = None, control_input: Any = None)\n</code></pre> <p>Generic numerical propagator for arbitrary N-dimensional dynamical systems.</p> <p>This propagator accepts a user-defined Python dynamics function and can be applied to any system of ODEs: attitude dynamics, chemical kinetics, population models, control systems, etc.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector (N-dimensional).</p> required <code>dynamics</code> <code>callable</code> <p>Dynamics function: f(t, state, params) -&gt; derivative. Should accept (float, np.ndarray, Optional[np.ndarray]) and return np.ndarray.</p> required <code>propagation_config</code> <code>NumericalPropagationConfig</code> <p>Propagation configuration.</p> required <code>params</code> <code>ndarray or None</code> <p>Optional parameter vector for the dynamics function.</p> <code>None</code> <code>initial_covariance</code> <code>ndarray or None</code> <p>Optional initial covariance matrix (enables STM).</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>current_epoch</code> <code>Epoch</code> <p>Current propagation time</p> <code>initial_epoch</code> <code>Epoch</code> <p>Initial epoch from propagator creation</p> <code>state_dim</code> <code>int</code> <p>Dimension of state vector</p> <code>step_size</code> <code>float</code> <p>Current integration step size in seconds</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define dynamics: simple harmonic oscillator\n# dx/dt = v, dv/dt = -\u03c9\u00b2x\nomega = 1.0\ndef sho_dynamics(t, state, params):\n    return np.array([state[1], -omega**2 * state[0]])\n\n# Create initial state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([1.0, 0.0])  # [position, velocity]\n\n# Create propagator\nprop = bh.NumericalPropagator(\n    epoch, state, sho_dynamics,\n    bh.NumericalPropagationConfig.default()\n)\n\n# Propagate one period\nprop.propagate_to(epoch + 2.0 * np.pi)\nprint(f\"Final state: {prop.current_state()}\")  # Should be ~[1, 0]\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Any\n</code></pre> <p>Get current epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Any\n</code></pre> <p>Get initial epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.state_dim","title":"state_dim  <code>property</code>","text":"<pre><code>state_dim: ndarray\n</code></pre> <p>Get state dimension.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: Any\n</code></pre> <p>Get current step size.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: SOrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.add_event_detector","title":"add_event_detector  <code>method descriptor</code>","text":"<pre><code>add_event_detector(event: Union[TimeEvent, ValueEvent, BinaryEvent]) -&gt; Any\n</code></pre> <p>Add an event detector to this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>TimeEvent or ValueEvent or BinaryEvent</code> <p>Event detector</p> required Example <pre><code>import brahe as bh\n\nprop = bh.NumericalPropagator(epoch, state, dynamics, config)\nevent = bh.TimeEvent(epoch + 5.0, \"5 second mark\")\nprop.add_event_detector(event)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.clear_events","title":"clear_events  <code>method descriptor</code>","text":"<pre><code>clear_events() -&gt; Any\n</code></pre> <p>Clear all detected events from the event log.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.covariance","title":"covariance  <code>method descriptor</code>","text":"<pre><code>covariance(epoch) -&gt; Any\n</code></pre> <p>Get covariance at a specific epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.event_log","title":"event_log  <code>method descriptor</code>","text":"<pre><code>event_log() -&gt; list[DetectedEvent]\n</code></pre> <p>Get the event log (list of detected events).</p> <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: List of events detected during propagation.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.events_by_detector_index","title":"events_by_detector_index  <code>method descriptor</code>","text":"<pre><code>events_by_detector_index(index: int) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by detector index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Detector index (0-based, in order of add_event_detector calls).</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events from the specified detector.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.events_by_name","title":"events_by_name  <code>method descriptor</code>","text":"<pre><code>events_by_name(name: str) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Event name to filter by.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events matching the given name.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.events_in_range","title":"events_in_range  <code>method descriptor</code>","text":"<pre><code>events_in_range(start: Epoch, end: Epoch) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events in time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Epoch</code> <p>Start of time range.</p> required <code>end</code> <code>Epoch</code> <p>End of time range.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events within the given time range.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.get_covariance_interpolation_method","title":"get_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_covariance_interpolation_method() -&gt; CovarianceInterpolationMethod\n</code></pre> <p>Get the current covariance interpolation method.</p> <p>Returns:</p> Name Type Description <code>CovarianceInterpolationMethod</code> <code>CovarianceInterpolationMethod</code> <p>The current covariance interpolation method.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; Any\n</code></pre> <p>Get the current numeric ID.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>The current interpolation method.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; Any\n</code></pre> <p>Get the current name.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; Any\n</code></pre> <p>Get the current UUID.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state vector.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.latest_event","title":"latest_event  <code>method descriptor</code>","text":"<pre><code>latest_event() -&gt; DetectedEvent\n</code></pre> <p>Get latest detected event, if any.</p> <p>Returns:</p> Type Description <code>DetectedEvent</code> <p>DetectedEvent or None: The most recently detected event.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.query_events","title":"query_events  <code>method descriptor</code>","text":"<pre><code>query_events() -&gt; EventQuery\n</code></pre> <p>Create an event query builder for filtering detected events.</p> <p>Returns an EventQuery that allows chainable filtering of detected events. Call <code>.collect()</code> on the query to get the final list of events.</p> <p>Returns:</p> Name Type Description <code>EventQuery</code> <code>EventQuery</code> <p>Query builder for filtering events</p> Example <pre><code>import brahe as bh\n\n# Get events from detector 0 within a time range\nevents = prop.query_events() \\\n    .by_detector_index(0) \\\n    .in_time_range(start, end) \\\n    .collect()\n\n# Count events by name pattern\ncount = prop.query_events() \\\n    .by_name_contains(\"Altitude\") \\\n    .count()\n\n# Combined filters\nevents = prop.query_events() \\\n    .by_detector_index(1) \\\n    .in_time_range(start, end) \\\n    .collect()\n</code></pre>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.reset_termination","title":"reset_termination  <code>method descriptor</code>","text":"<pre><code>reset_termination() -&gt; Any\n</code></pre> <p>Reset the termination flag to allow continued propagation.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.sensitivity","title":"sensitivity  <code>method descriptor</code>","text":"<pre><code>sensitivity() -&gt; Any\n</code></pre> <p>Get current sensitivity matrix if enabled.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_covariance_interpolation_method","title":"set_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; Any\n</code></pre> <p>Set the covariance interpolation method in-place.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>The covariance interpolation method to use.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method in-place.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>The interpolation method to use.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_trajectory_mode","title":"set_trajectory_mode  <code>method descriptor</code>","text":"<pre><code>set_trajectory_mode(mode: TrajectoryMode) -&gt; Any\n</code></pre> <p>Set the trajectory storage mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>TrajectoryMode</code> <p>The trajectory storage mode.</p> required Example <pre><code>import brahe as bh\n\nprop = bh.NumericalPropagator(epoch, state, dynamics, config)\nprop.set_trajectory_mode(bh.TrajectoryMode.DISABLED)\n</code></pre>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.set_uuid","title":"set_uuid  <code>method descriptor</code>","text":"<pre><code>set_uuid(uuid_str: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the UUID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str or None</code> <p>UUID string to assign, or None to clear.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.stm","title":"stm  <code>method descriptor</code>","text":"<pre><code>stm() -&gt; Any\n</code></pre> <p>Get current STM if enabled.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.terminated","title":"terminated  <code>method descriptor</code>","text":"<pre><code>terminated() -&gt; bool\n</code></pre> <p>Check if propagator is terminated due to a terminal event.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if propagation was stopped by a terminal event.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.trajectory_mode","title":"trajectory_mode  <code>method descriptor</code>","text":"<pre><code>trajectory_mode() -&gt; TrajectoryMode\n</code></pre> <p>Get the current trajectory storage mode.</p> <p>Returns:</p> Name Type Description <code>TrajectoryMode</code> <code>TrajectoryMode</code> <p>The current trajectory storage mode.</p> Example <pre><code>import brahe as bh\n\nprop = bh.NumericalPropagator(epoch, state, dynamics, config)\nmode = prop.trajectory_mode()\nprint(f\"Mode: {mode}\")\n</code></pre>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_covariance_interpolation_method","title":"with_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; Any\n</code></pre> <p>Set the covariance interpolation method using builder pattern. Note: Returns None as Python doesn't support returning mutable self with borrowed args. Use method chaining via separate calls or use set_covariance_interpolation_method instead.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>The covariance interpolation method to use.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id) -&gt; Any\n</code></pre> <p>Set the numeric ID and return self.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; NumericalPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>NumericalPropagator</code> <code>NumericalPropagator</code> <p>Self with identity set.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method using builder pattern. Note: Returns None as Python doesn't support returning mutable self with borrowed args. Use method chaining via separate calls or use set_interpolation_method instead.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>The interpolation method to use.</p> required"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name) -&gt; Any\n</code></pre> <p>Set the name and return self.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID, set it, and return self.</p>"},{"location":"library_api/propagators/numerical_propagator.html#brahe.NumericalPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str) -&gt; Any\n</code></pre> <p>Set the UUID and return self.</p>"},{"location":"library_api/propagators/numerical_propagator.html#see-also","title":"See Also","text":"<ul> <li>NumericalOrbitPropagator - Orbit propagator with built-in force models</li> <li>Event Detection - Event detection system</li> <li>Numerical Propagation Guide - User guide documentation</li> </ul>"},{"location":"library_api/propagators/sgp_propagator.html","title":"SGP Propagator","text":"<p>The SGP4/SDP4 propagator for satellite orbit propagation using Two-Line Element (TLE) data. The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using TLE orbital data. This is the standard model used for tracking objects in Earth orbit and is maintained by NORAD/Space Force.</p> <p>Key Features: - Industry-standard orbit propagation - Atmospheric drag modeling - Automatic selection between SGP4 (near-Earth) and SDP4 (deep-space) models - Compatible with standard TLE format</p> <p>Module: <code>brahe.orbits</code></p>"},{"location":"library_api/propagators/sgp_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator from TLE\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get current epoch\nepoch = prop.epoch()\n\n# Propagate to a specific time\nfuture_epoch = epoch + 3600.0  # 1 hour later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz] in TEME frame\n\n# Propagate to multiple times\nimport numpy as np\ntimes = np.linspace(0, 86400, 100)  # 1 day in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)  # Returns array of states\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#class-reference","title":"Class Reference","text":""},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator","title":"SGPPropagator","text":"<pre><code>SGPPropagator()\n</code></pre> <p>SGP4/SDP4 satellite propagator using TLE data.</p> <p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using Two-Line Element (TLE) orbital data. This is the standard model used for tracking objects in Earth orbit.</p> Note <p>This class is created via class methods, not direct instantiation. Use <code>SGPPropagator.from_tle()</code> or <code>SGPPropagator.from_elements()</code>.</p> <p>Attributes:</p> Name Type Description <code>current_epoch</code> <code>Epoch</code> <p>Current propagation time</p> <code>initial_epoch</code> <code>Epoch</code> <p>TLE epoch</p> <code>step_size</code> <code>float</code> <p>Current step size in seconds</p> <code>norad_id</code> <code>int</code> <p>NORAD catalog ID</p> <code>satellite_name</code> <code>str or None</code> <p>Satellite name if available</p> <code>trajectory</code> <code>OrbitTrajectory</code> <p>Accumulated trajectory states</p> Example <pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_eci = prop.state(epc)\nprint(f\"Position: {state_eci[:3]}\")\nprint(f\"Velocity: {state_eci[3:]}\")\n\n# Propagate multiple epochs\nepochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\nstates = prop.states(epochs)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.arg_perigee","title":"arg_perigee  <code>property</code>","text":"<pre><code>arg_perigee: float\n</code></pre> <p>Get argument of periapsis at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Argument of periapsis in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nargp = prop.arg_perigee\nprint(f\"Argument of periapsis: {argp:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.step()\nprint(f\"Current epoch: {propagator.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.eccentricity","title":"eccentricity  <code>property</code>","text":"<pre><code>eccentricity: float\n</code></pre> <p>Get eccentricity at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentricity (dimensionless).</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\necc = prop.eccentricity\nprint(f\"Eccentricity: {ecc:.6f}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.ephemeris_age","title":"ephemeris_age  <code>property</code>","text":"<pre><code>ephemeris_age: float\n</code></pre> <p>Get age of ephemeris data (time since TLE epoch).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time since TLE epoch in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nage = prop.ephemeris_age\nprint(f\"Ephemeris age: {age:.1f} s\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Epoch\n</code></pre> <p>Get TLE epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch of the TLE data.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.inclination","title":"inclination  <code>property</code>","text":"<pre><code>inclination: float\n</code></pre> <p>Get inclination at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\ninc = prop.inclination\nprint(f\"Inclination: {inc:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.line1","title":"line1  <code>property</code>","text":"<pre><code>line1: str\n</code></pre> <p>Get TLE line 1.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>First line of the TLE.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(propagator.line1)\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.line2","title":"line2  <code>property</code>","text":"<pre><code>line2: str\n</code></pre> <p>Get TLE line 2.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Second line of the TLE.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(propagator.line2)\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.mean_anomaly","title":"mean_anomaly  <code>property</code>","text":"<pre><code>mean_anomaly: float\n</code></pre> <p>Get mean anomaly at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nma = prop.mean_anomaly\nprint(f\"Mean anomaly: {ma:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.norad_id","title":"norad_id  <code>property</code>","text":"<pre><code>norad_id: int\n</code></pre> <p>Get NORAD ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>NORAD catalog ID.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.right_ascension","title":"right_ascension  <code>property</code>","text":"<pre><code>right_ascension: float\n</code></pre> <p>Get right ascension of ascending node at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Right ascension of ascending node (RAAN) in degrees.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nraan = prop.right_ascension\nprint(f\"RAAN: {raan:.4f} deg\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: str\n</code></pre> <p>Get satellite name (if available).</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: Satellite name if provided.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Satellite: {propagator.satellite_name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.semi_major_axis","title":"semi_major_axis  <code>property</code>","text":"<pre><code>semi_major_axis: float\n</code></pre> <p>Get semi-major axis at TLE epoch.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\nsma = prop.semi_major_axis\nprint(f\"Semi-major axis: {sma:.3f} m\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(f\"Step size: {propagator.step_size} seconds\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.terminated","title":"terminated  <code>property</code>","text":"<pre><code>terminated: bool\n</code></pre> <p>Check if propagation was terminated by an event.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if propagation was stopped by a terminal event.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: SOrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>SOrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.propagate_steps(100)\ntraj = prop.trajectory\nprint(f\"Trajectory has {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.add_event_detector","title":"add_event_detector  <code>method descriptor</code>","text":"<pre><code>add_event_detector(event: TimeEvent | AscendingNodeEvent | DescendingNodeEvent | AltitudeEvent | AOIEntryEvent | AOIExitEvent) -&gt; Any\n</code></pre> <p>Add an event detector to the propagator.</p> <p>Supported event types: - TimeEvent: Triggers at a specific epoch - AscendingNodeEvent: Triggers at ascending node crossings - DescendingNodeEvent: Triggers at descending node crossings - AltitudeEvent: Triggers at altitude crossings - And other orbital element events (SemiMajorAxis, Eccentricity, etc.)</p> Note <p>Custom ValueEvent and BinaryEvent with Python callbacks are not supported for SGPPropagator. Use NumericalOrbitPropagator for custom event functions.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>TimeEvent | AscendingNodeEvent | DescendingNodeEvent | AltitudeEvent | AOIEntryEvent | AOIExitEvent</code> <p>Event detector to add</p> required Example <pre><code>import brahe as bh\n\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Add time event\nepoch = prop.epoch\nevent = bh.TimeEvent(epoch + 1800.0, \"30 Min Mark\")\nprop.add_event_detector(event)\n\n# Add node crossing event\nasc_node = bh.AscendingNodeEvent(\"Ascending Node\")\nprop.add_event_detector(asc_node)\n\n# Propagate and check events\nprop.propagate_to(epoch + 6000.0)\nfor e in prop.event_log():\n    print(f\"{e.name}: {e.window_open}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.clear_events","title":"clear_events  <code>method descriptor</code>","text":"<pre><code>clear_events() -&gt; Any\n</code></pre> <p>Clear all events from the event log.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.event_log","title":"event_log  <code>method descriptor</code>","text":"<pre><code>event_log() -&gt; list[DetectedEvent]\n</code></pre> <p>Get all detected events from the event log.</p> <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: List of all detected events.</p> Example <pre><code>import brahe as bh\n\nprop = bh.SGPPropagator.from_tle(line1, line2)\nevent = bh.AscendingNodeEvent(\"Asc Node\")\nprop.add_event_detector(event)\n\nprop.propagate_to(prop.epoch + 6000.0)\n\nfor e in prop.event_log():\n    print(f\"{e.name} at {e.window_open}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.events_by_name","title":"events_by_name  <code>method descriptor</code>","text":"<pre><code>events_by_name(name: str) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events filtered by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Exact event name to match.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events matching the name.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.events_in_range","title":"events_in_range  <code>method descriptor</code>","text":"<pre><code>events_in_range(start: Epoch, end: Epoch) -&gt; list[DetectedEvent]\n</code></pre> <p>Get events within a time range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Epoch</code> <p>Start of time range.</p> required <code>end</code> <code>Epoch</code> <p>End of time range.</p> required <p>Returns:</p> Type Description <code>list[DetectedEvent]</code> <p>list[DetectedEvent]: Events within the range.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_3le","title":"from_3le  <code>builtin</code>","text":"<pre><code>from_3le(name: str, line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from 3-line TLE format (with satellite name).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (line 0).</p> required <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_omm_elements","title":"from_omm_elements  <code>builtin</code>","text":"<pre><code>from_omm_elements(epoch: str, mean_motion: float, eccentricity: float, inclination: float, raan: float, arg_of_pericenter: float, mean_anomaly: float, norad_id: int, step_size: float = 60.0, object_name: Union[str, None] = None, object_id: Union[str, None] = None, classification: Union[str, None] = None, bstar: Union[float, None] = None, mean_motion_dot: Union[float, None] = None, mean_motion_ddot: Union[float, None] = None, ephemeris_type: Union[int, None] = None, element_set_no: Union[int, None] = None, rev_at_epoch: Union[int, None] = None) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from CCSDS OMM (Orbit Mean-elements Message) fields.</p> <p>This method directly constructs an SGP4 propagator from OMM orbital elements, bypassing TLE parsing. It creates synthetic TLE lines for API consistency.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>str</code> <p>ISO 8601 datetime string (e.g., \"2025-11-29T20:01:44.058144\").</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>eccentricity</code> <code>float</code> <p>Orbital eccentricity (dimensionless).</p> required <code>inclination</code> <code>float</code> <p>Orbital inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>arg_of_pericenter</code> <code>float</code> <p>Argument of pericenter in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>norad_id</code> <code>int</code> <p>NORAD catalog ID.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <code>object_name</code> <code>str or None</code> <p>Satellite name (OBJECT_NAME). Defaults to None.</p> <code>None</code> <code>object_id</code> <code>str or None</code> <p>International designator (OBJECT_ID). Defaults to None.</p> <code>None</code> <code>classification</code> <code>str or None</code> <p>Classification character ('U', 'C', or 'S'). Defaults to 'U'.</p> <code>None</code> <code>bstar</code> <code>float or None</code> <p>B* drag term. Defaults to 0.0.</p> <code>None</code> <code>mean_motion_dot</code> <code>float or None</code> <p>First derivative of mean motion / 2. Defaults to 0.0.</p> <code>None</code> <code>mean_motion_ddot</code> <code>float or None</code> <p>Second derivative of mean motion / 6. Defaults to 0.0.</p> <code>None</code> <code>ephemeris_type</code> <code>int or None</code> <p>Ephemeris type (usually 0). Defaults to 0.</p> <code>None</code> <code>element_set_no</code> <code>int or None</code> <p>Element set number. Defaults to 999.</p> <code>None</code> <code>rev_at_epoch</code> <code>int or None</code> <p>Revolution number at epoch. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p> Example <pre><code>import brahe as bh\n\n# ISS OMM data\nprop = bh.SGPPropagator.from_omm_elements(\n    epoch=\"2025-11-29T20:01:44.058144\",\n    mean_motion=15.49193835,\n    eccentricity=0.0003723,\n    inclination=51.6312,\n    raan=206.3646,\n    arg_of_pericenter=184.1118,\n    mean_anomaly=175.9840,\n    norad_id=25544,\n    object_name=\"ISS (ZARYA)\",\n    object_id=\"1998-067A\",\n    bstar=0.15237e-3,\n    mean_motion_dot=0.801e-4,\n    rev_at_epoch=54085,\n)\nstate = prop.state(prop.epoch)\nprint(f\"Position: {state[:3]}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_tle","title":"from_tle  <code>builtin</code>","text":"<pre><code>from_tle(line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_elements","title":"get_elements  <code>method descriptor</code>","text":"<pre><code>get_elements(angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get Keplerian orbital elements from TLE data.</p> <p>Extracts the Keplerian elements directly from the TLE lines used to initialize this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements (DEGREES or RADIANS).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Keplerian elements [a, e, i, \u03a9, \u03c9, M] where: - a: semi-major axis [m] - e: eccentricity [dimensionless] - i: inclination [rad or deg] - \u03a9: right ascension of ascending node [rad or deg] - \u03c9: argument of periapsis [rad or deg] - M: mean anomaly [rad or deg]</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements in degrees\noe_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nprint(f\"Inclination: {oe_deg[2]:.4f} degrees\")\n\n# Get elements in radians\noe_rad = prop.get_elements(bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {oe_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_id(25544)\nprint(f\"ID: {prop.get_id()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Name: {prop.get_name()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_new_uuid()\nprint(f\"UUID: {prop.get_uuid()}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.latest_event","title":"latest_event  <code>method descriptor</code>","text":"<pre><code>latest_event() -&gt; DetectedEvent\n</code></pre> <p>Get the most recent detected event.</p> <p>Returns:</p> Type Description <code>DetectedEvent</code> <p>DetectedEvent or None: Most recent event, or None if no events.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\nprop.propagate_steps(10)  # Advance by 10 steps (600 seconds)\nprint(f\"After 10 steps: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ninitial_epoch = prop.epoch\nprop.propagate_steps(100)\nprop.reset()\nprint(f\"Reset to: {prop.current_epoch == initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.reset_termination","title":"reset_termination  <code>method descriptor</code>","text":"<pre><code>reset_termination() -&gt; Any\n</code></pre> <p>Reset the termination flag.</p> <p>Call this to allow propagation to continue after a terminal event.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_age(86400.0)  # Keep 1 day of history\nprint(\"Trajectory limited to 24 hours of states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_size(1000)\nprint(\"Trajectory limited to 1000 states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: Union[str, None]) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_output_format","title":"set_output_format  <code>method descriptor</code>","text":"<pre><code>set_output_format(frame: OrbitFrame, representation: OrbitRepresentation, angle_format: Union[AngleFormat, None]) -&gt; Any\n</code></pre> <p>Set output format (frame, representation, and angle format).</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>OrbitFrame</code> <p>Output frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>Output representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian (None for Cartesian).</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_step_size","title":"set_step_size  <code>method descriptor</code>","text":"<pre><code>set_step_size(new_step_size: float) -&gt; Any\n</code></pre> <p>Set step size in seconds (explicit method).</p> <p>Parameters:</p> Name Type Description Default <code>new_step_size</code> <code>float</code> <p>New step size in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.set_step_size(120.0)  # Can use explicit method\n# or propagator.step_size = 120.0  # Can use property\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_eme2000","title":"state_eme2000  <code>method descriptor</code>","text":"<pre><code>state_eme2000(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in EME2000 coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in EME2000 frame (meters, m/s).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_gcrf","title":"state_gcrf  <code>method descriptor</code>","text":"<pre><code>state_gcrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in GCRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in GCRF frame (meters, m/s).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_itrf","title":"state_itrf  <code>method descriptor</code>","text":"<pre><code>state_itrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ITRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ITRF frame (meters, m/s).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_koe_mean","title":"state_koe_mean  <code>method descriptor</code>","text":"<pre><code>state_koe_mean(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as mean Keplerian elements at the given epoch.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Mean Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get mean elements at initial epoch\nepoch = prop.epoch\nmean_deg = prop.state_koe_mean(epoch, bh.AngleFormat.DEGREES)\nosc_deg = prop.state_koe_osc(epoch, bh.AngleFormat.DEGREES)\nprint(f\"Mean semi-major axis: {mean_deg[0]/1000:.3f} km\")\nprint(f\"Osc semi-major axis: {osc_deg[0]/1000:.3f} km\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_koe_osc","title":"state_koe_osc  <code>method descriptor</code>","text":"<pre><code>state_koe_osc(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get osculating elements at initial epoch\nepoch = prop.epoch\nelements_deg = prop.state_koe_osc(epoch, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements_deg[0]/1000:.3f} km\")\nprint(f\"Inclination: {elements_deg[2]:.4f} degrees\")\n\n# Get elements in radians\nelements_rad = prop.state_koe_osc(epoch, bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {elements_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_pef","title":"state_pef  <code>method descriptor</code>","text":"<pre><code>state_pef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in PEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in PEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_gcrf","title":"states_gcrf  <code>method descriptor</code>","text":"<pre><code>states_gcrf(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in GCRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of GCRF state vectors.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_itrf","title":"states_itrf  <code>method descriptor</code>","text":"<pre><code>states_itrf(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ITRF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ITRF state vectors.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_koe_mean","title":"states_koe_mean  <code>method descriptor</code>","text":"<pre><code>states_koe_mean(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as mean Keplerian elements at multiple epochs.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of mean Keplerian element vectors [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get mean elements at multiple epochs\nepoch0 = prop.epoch\nepochs = [epoch0 + i*3600.0 for i in range(10)]  # Every hour for 10 hours\nmean_list = prop.states_koe_mean(epochs, bh.AngleFormat.DEGREES)\n\nfor i, elements in enumerate(mean_list):\n    print(f\"Hour {i}: mean a={elements[0]/1000:.3f} km\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_koe_osc","title":"states_koe_osc  <code>method descriptor</code>","text":"<pre><code>states_koe_osc(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors [a, e, i, raan, argp, mean_anomaly].</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements at multiple epochs\nepoch0 = prop.epoch\nepochs = [epoch0 + i*3600.0 for i in range(10)]  # Every hour for 10 hours\nelements_list = prop.states_koe_osc(epochs, bh.AngleFormat.DEGREES)\n\nfor i, elements in enumerate(elements_list):\n    print(f\"Hour {i}: a={elements[0]/1000:.3f} km, e={elements[1]:.6f}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step()  # Advance by default step_size\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step_by(120.0)  # Advance by 2 minutes\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 3600.0  # 1 hour later\nprop.step_past(target)\nprint(f\"Stepped past target\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; SGPPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: Union[str, None], uuid_str: Union[str, None], id: Union[int, None]) -&gt; SGPPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with identity set.</p> Example <pre><code>import brahe as bh\nimport uuid\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nmy_uuid = str(uuid.uuid4())\nprop = bh.SGPPropagator.from_tle(line1, line2).with_identity(\"ISS\", my_uuid, 25544)\nprint(f\"Name: {prop.name}, ID: {prop.id}, UUID: {prop.uuid}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; SGPPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_name(\"My Satellite\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; SGPPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; SGPPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>TLE - Two-Line Element format details</li> <li>Keplerian Elements - Orbital element functions</li> </ul>"},{"location":"library_api/relative_motion/index.html","title":"Relative Motion","text":"<p>The relative motion module provides tools for satellite relative motion analysis and orbital reference frame transformations.</p> <p>For conceptual explanations and usage examples, see the Relative Motion Learn section.</p>"},{"location":"library_api/relative_motion/index.html#module-contents","title":"Module Contents","text":"<ul> <li>RTN Transformations - Rotation matrices between ECI and RTN frames</li> </ul>"},{"location":"library_api/relative_motion/eci_roe_transformations.html","title":"ECI-ROE Transformations","text":"<p>Transformations between Earth-Centered Inertial (ECI) state vectors and Relative Orbital Elements (ROE).</p> <p>These functions combine the ECI\u2194KOE and OE\u2194ROE transformations to provide direct conversion between inertial Cartesian states and quasi-nonsingular Relative Orbital Elements.</p> <p>Note</p> <p>For conceptual explanations of ROE, see ROE Transformations.</p>"},{"location":"library_api/relative_motion/eci_roe_transformations.html#brahe.state_eci_to_roe","title":"state_eci_to_roe  <code>builtin</code>","text":"<pre><code>state_eci_to_roe(x_chief: Union[ndarray, List], x_deputy: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Converts chief and deputy satellite ECI state vectors to quasi-nonsingular Relative Orbital Elements (ROE).</p> <p>This function converts both ECI states to Keplerian orbital elements, then computes the quasi-nonsingular Relative Orbital Elements between them.</p> <p>The ROE formulation provides a mean description of relative motion that is nonsingular for circular and near-circular orbits. The ROE vector contains: - da: Relative semi-major axis (dimensionless) - d\u03bb: Relative mean longitude (degrees or radians) - dex: x-component of relative eccentricity vector (dimensionless) - dey: y-component of relative eccentricity vector (dimensionless) - dix: x-component of relative inclination vector (degrees or radians) - diy: y-component of relative inclination vector (degrees or radians)</p> <p>Parameters:</p> Name Type Description Default <code>x_chief</code> <code>ndarray or list</code> <p>6D ECI state vector of the chief satellite [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <code>x_deputy</code> <code>ndarray or list</code> <p>6D ECI state vector of the deputy satellite [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements in output (DEGREES or RADIANS)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative orbital elements [da, d\u03bb, dex, dey, dix, diy] shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief and deputy orbital elements (degrees)\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\noe_deputy = np.array([bh.R_EARTH + 701e3, 0.0015, 97.85, 15.05, 30.05, 45.05])\n\n# Convert to ECI states\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\nx_deputy = bh.state_koe_to_eci(oe_deputy, bh.AngleFormat.DEGREES)\n\n# Compute ROE directly from ECI states\nroe = bh.state_eci_to_roe(x_chief, x_deputy, bh.AngleFormat.DEGREES)\nprint(f\"Relative orbital elements: {roe}\")\n# Relative orbital elements: [1.413e-4, 9.321e-2, 4.324e-4, 2.511e-4, 5.0e-2, 4.954e-2]\n</code></pre>"},{"location":"library_api/relative_motion/eci_roe_transformations.html#brahe.state_roe_to_eci","title":"state_roe_to_eci  <code>builtin</code>","text":"<pre><code>state_roe_to_eci(x_chief: Union[ndarray, List], roe: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Converts chief satellite ECI state and quasi-nonsingular Relative Orbital Elements (ROE) to deputy satellite ECI state.</p> <p>This function converts the chief ECI state to Keplerian orbital elements, applies the ROE to obtain deputy orbital elements, then converts back to ECI state.</p> <p>Parameters:</p> Name Type Description Default <code>x_chief</code> <code>ndarray or list</code> <p>6D ECI state vector of the chief satellite [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <code>roe</code> <code>ndarray or list</code> <p>Relative orbital elements [da, d\u03bb, dex, dey, dix, diy] shape (6,)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements in input ROE (DEGREES or RADIANS)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 6D ECI state vector of the deputy satellite [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief orbital elements and convert to ECI\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\n\n# Define ROE (small relative orbit)\nroe = np.array([1.413e-4, 9.321e-2, 4.324e-4, 2.511e-4, 5.0e-2, 4.954e-2])\n\n# Compute deputy ECI state from chief and ROE\nx_deputy = bh.state_roe_to_eci(x_chief, roe, bh.AngleFormat.DEGREES)\nprint(f\"Deputy ECI state: {x_deputy}\")\n</code></pre>"},{"location":"library_api/relative_motion/roe_transformations.html","title":"ROE Transformations","text":"<p>Transformations between Keplerian Orbital Elements (KOE/oe) and Relative Orbital Elements (ROE/roe).</p> <p>Note</p> <p>For conceptual explanations of the transformation, see ROE Transformations.</p>"},{"location":"library_api/relative_motion/roe_transformations.html#brahe.state_oe_to_roe","title":"state_oe_to_roe  <code>builtin</code>","text":"<pre><code>state_oe_to_roe(oe_chief: Union[ndarray, List], oe_deputy: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Converts chief and deputy satellite orbital elements (OE) to quasi-nonsingular relative orbital elements (ROE).</p> <p>The ROE formulation provides a mean description of relative motion that is nonsingular for circular and near-circular orbits. The ROE vector contains: - da: Relative semi-major axis (dimensionless) - d\u03bb: Relative mean longitude (degrees or radians) - dex: x-component of relative eccentricity vector (dimensionless) - dey: y-component of relative eccentricity vector (dimensionless) - dix: x-component of relative inclination vector (degrees or radians) - diy: y-component of relative inclination vector (degrees or radians)</p> <p>Parameters:</p> Name Type Description Default <code>oe_chief</code> <code>ndarray or list</code> <p>Chief satellite orbital elements [a, e, i, \u03a9, \u03c9, M] shape (6,)</p> required <code>oe_deputy</code> <code>ndarray or list</code> <p>Deputy satellite orbital elements [a, e, i, \u03a9, \u03c9, M] shape (6,)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements (DEGREES or RADIANS)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Relative orbital elements [da, d\u03bb, dex, dey, dix, diy] shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define chief and deputy orbital elements (degrees)\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\noe_deputy = np.array([bh.R_EARTH + 701e3, 0.0015, 97.85, 15.05, 30.05, 45.05])\n\n# Convert to ROE\nroe = bh.state_oe_to_roe(oe_chief, oe_deputy, bh.AngleFormat.DEGREES)\nprint(f\"Relative orbital elements: {roe}\")\n# Relative orbital elements: [1.413e-4, 9.321e-2, 4.324e-4, 2.511e-4, 5.0e-2, 4.954e-2]\n</code></pre>"},{"location":"library_api/relative_motion/roe_transformations.html#brahe.state_roe_to_oe","title":"state_roe_to_oe  <code>builtin</code>","text":"<pre><code>state_roe_to_oe(oe_chief: Union[ndarray, List], roe: Union[ndarray, List], angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Converts chief satellite orbital elements (OE) and quasi-nonsingular relative orbital elements (ROE) to deputy satellite orbital elements.</p> <p>This is the inverse transformation of <code>state_oe_to_roe</code>, converting from ROE representation back to classical orbital elements for the deputy satellite.</p> <p>Parameters:</p> Name Type Description Default <code>oe_chief</code> <code>ndarray or list</code> <p>Chief satellite orbital elements [a, e, i, \u03a9, \u03c9, M] shape (6,)</p> required <code>roe</code> <code>ndarray or list</code> <p>Relative orbital elements [da, d\u03bb, dex, dey, dix, diy] shape (6,)</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Format of angular elements (DEGREES or RADIANS)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Deputy satellite orbital elements [a, e, i, \u03a9, \u03c9, M] shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define chief orbital elements and ROE (degrees)\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nroe = np.array([1.413e-4, 9.321e-2, 4.324e-4, 2.511e-4, 5.0e-2, 4.954e-2])\n\n# Convert to deputy OE\noe_deputy = bh.state_roe_to_oe(oe_chief, roe, bh.AngleFormat.DEGREES)\nprint(f\"Deputy orbital elements: {oe_deputy}\")\n# Deputy orbital elements: [7.079e6, 1.5e-3, 97.85, 15.05, 30.05, 45.05]\n</code></pre>"},{"location":"library_api/relative_motion/rtn_transformations.html","title":"RTN Transformations","text":"<p>Rotation matrices between ECI (Earth-Centered Inertial) and RTN (Radial-Tangential-Normal) orbital frames.</p> <p>Note</p> <p>For conceptual explanations of the RTN frame, see Relative Motion.</p>"},{"location":"library_api/relative_motion/rtn_transformations.html#brahe.rotation_rtn_to_eci","title":"rotation_rtn_to_eci  <code>builtin</code>","text":"<pre><code>rotation_rtn_to_eci(x_eci: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Computes the rotation matrix transforming a vector in the radial, along-track, cross-track (RTN) frame to the Earth-Centered Inertial (ECI) frame.</p> <p>The ECI frame can be any inertial frame centered at the Earth's center, such as GCRF or EME2000.</p> <p>The RTN frame is defined as follows: - R (Radial): Points from the Earth's center to the satellite's position. - N (Cross-Track): Perpendicular to the orbital plane, defined by the angular momentum vector (cross product of position and velocity). - T (Along-Track): Completes the right-handed coordinate system, lying in the orbital plane and perpendicular to R and N.</p> <p>Parameters:</p> Name Type Description Default <code>x_eci</code> <code>ndarray or list</code> <p>6D state vector in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming from RTN to ECI frame, shape (3, 3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define satellite state\nsma = bh.R_EARTH + 700e3  # Semi-major axis in meters\nstate = np.array([sma, 0.0, 0.0, 0.0, bh.perigee_velocity(sma, 0.0), 0.0])\n\n# Get rotation matrix\nR = bh.rotation_rtn_to_eci(state)\nprint(f\"RTN to ECI rotation matrix:\\n{R}\")\n</code></pre>"},{"location":"library_api/relative_motion/rtn_transformations.html#brahe.rotation_eci_to_rtn","title":"rotation_eci_to_rtn  <code>builtin</code>","text":"<pre><code>rotation_eci_to_rtn(x_eci: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Computes the rotation matrix transforming a vector in the Earth-Centered Inertial (ECI) frame to the radial, along-track, cross-track (RTN) frame.</p> <p>This is the transpose (inverse) of the RTN-to-ECI rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>x_eci</code> <code>ndarray or list</code> <p>6D state vector in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix transforming from ECI to RTN frame, shape (3, 3)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Define satellite state\nsma = bh.R_EARTH + 700e3  # Semi-major axis in meters\nstate = np.array([sma, 0.0, 0.0, 0.0, bh.perigee_velocity(sma, 0.0), 0.0])\n\n# Get rotation matrix\nR = bh.rotation_eci_to_rtn(state)\nprint(f\"ECI to RTN rotation matrix:\\n{R}\")\n</code></pre>"},{"location":"library_api/relative_motion/rtn_transformations.html#brahe.state_rtn_to_eci","title":"state_rtn_to_eci  <code>builtin</code>","text":"<pre><code>state_rtn_to_eci(x_chief: Union[ndarray, List], x_rel_rtn: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms the relative state of a deputy satellite with respect to a chief satellite from the rotating Radial, Along-Track, Cross-Track (RTN) frame to the absolute state of the deputy in the Earth-Centered Inertial (ECI) frame.</p> <p>Parameters:</p> Name Type Description Default <code>x_chief</code> <code>ndarray or list</code> <p>6D state vector of the chief satellite in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <code>x_rel_rtn</code> <code>ndarray or list</code> <p>6D relative state vector of the deputy with respect to the chief in the RTN frame [\u03c1_R, \u03c1_T, \u03c1_N, \u03c1\u0307_R, \u03c1\u0307_T, \u03c1\u0307_N] (m, m/s), shape (6,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 6D state vector of the deputy satellite in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief state and relative RTN state\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\n\n# Relative state: 1km radial, 0.5km along-track, -0.3km cross-track\nx_rel_rtn = np.array([1000.0, 500.0, -300.0, 0.0, 0.0, 0.0])\n\n# Transform to absolute deputy ECI state\nx_deputy = bh.state_rtn_to_eci(x_chief, x_rel_rtn)\nprint(f\"Deputy state in ECI: {x_deputy}\")\n</code></pre>"},{"location":"library_api/relative_motion/rtn_transformations.html#brahe.state_eci_to_rtn","title":"state_eci_to_rtn  <code>builtin</code>","text":"<pre><code>state_eci_to_rtn(x_chief: Union[ndarray, List], x_deputy: Union[ndarray, List]) -&gt; ndarray\n</code></pre> <p>Transforms the absolute states of a chief and deputy satellite from the Earth-Centered Inertial (ECI) frame to the relative state of the deputy with respect to the chief in the rotating Radial, Along-Track, Cross-Track (RTN) frame.</p> <p>Parameters:</p> Name Type Description Default <code>x_chief</code> <code>ndarray or list</code> <p>6D state vector of the chief satellite in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <code>x_deputy</code> <code>ndarray or list</code> <p>6D state vector of the deputy satellite in the ECI frame [x, y, z, vx, vy, vz] (m, m/s), shape (6,)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 6D relative state vector of the deputy with respect to the chief in the RTN frame [\u03c1_R, \u03c1_T, \u03c1_N, \u03c1\u0307_R, \u03c1\u0307_T, \u03c1\u0307_N] (m, m/s), shape (6,)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nbh.initialize_eop()\n\n# Define chief and deputy orbital elements\noe_chief = np.array([bh.R_EARTH + 700e3, 0.001, 97.8, 15.0, 30.0, 45.0])\noe_deputy = np.array([bh.R_EARTH + 701e3, 0.0015, 97.85, 15.05, 30.05, 45.05])\n\n# Convert to Cartesian states\nx_chief = bh.state_koe_to_eci(oe_chief, bh.AngleFormat.DEGREES)\nx_deputy = bh.state_koe_to_eci(oe_deputy, bh.AngleFormat.DEGREES)\n\n# Transform to relative RTN state\nx_rel_rtn = bh.state_eci_to_rtn(x_chief, x_deputy)\nprint(f\"Relative state in RTN: {x_rel_rtn}\")\n</code></pre>"},{"location":"library_api/space_weather/index.html","title":"Space Weather Data","text":"<p>Module: <code>brahe.space_weather</code></p> <p>Space weather data provides geomagnetic indices and solar flux values required for atmospheric density models used in satellite drag calculations and orbit propagation with atmospheric perturbations.</p>"},{"location":"library_api/space_weather/index.html#overview","title":"Overview","text":"<p>Space weather data includes: - Kp/Ap indices: Geomagnetic activity indices (8 values per day for 3-hour intervals) - F10.7: 10.7 cm solar radio flux (solar flux units, sfu) - Sunspot Number: International Sunspot Number (ISN)</p>"},{"location":"library_api/space_weather/index.html#global-space-weather-management","title":"Global Space Weather Management","text":"<p>Space weather data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/space_weather/index.html#functions","title":"Functions","text":"<ul> <li>Setting global space weather providers</li> <li>Querying Kp/Ap indices</li> <li>Querying F10.7 solar flux</li> <li>Accessing historical data</li> </ul>"},{"location":"library_api/space_weather/index.html#space-weather-providers","title":"Space Weather Providers","text":"<p>Brahe supports three types of space weather providers:</p>"},{"location":"library_api/space_weather/index.html#cachingspaceweatherprovider","title":"CachingSpaceWeatherProvider","text":"<p>Automatically download and cache the latest CSSI space weather data from CelesTrak with configurable refresh intervals.</p>"},{"location":"library_api/space_weather/index.html#filespaceweatherprovider","title":"FileSpaceWeatherProvider","text":"<p>Load space weather data from CSSI format files for production applications with current data.</p>"},{"location":"library_api/space_weather/index.html#staticspaceweatherprovider","title":"StaticSpaceWeatherProvider","text":"<p>Use user-defined fixed values, ideal for testing, offline use, or applications with known constant conditions.</p>"},{"location":"library_api/space_weather/index.html#see-also","title":"See Also","text":"<ul> <li>Managing Space Weather Data - Practical guide to providers</li> <li>Space Weather Learn - Conceptual overview</li> </ul>"},{"location":"library_api/space_weather/caching_provider.html","title":"CachingSpaceWeatherProvider","text":"<p>Automatically download and cache space weather data from CelesTrak.</p>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider","title":"CachingSpaceWeatherProvider","text":"<pre><code>CachingSpaceWeatherProvider(max_age_seconds: int, auto_refresh: bool, extrapolate: str, cache_dir: str = None)\n</code></pre> <p>Caching Space Weather provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileSpaceWeatherProvider and adds automatic cache management. It checks the age of the space weather file and downloads updated versions when the file exceeds the maximum age value. If the file doesn't exist, it will be downloaded on initialization from CelesTrak.</p> <p>Parameters:</p> Name Type Description Default <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside data range: \"Hold\", \"Zero\", or \"Error\"</p> required <code>cache_dir</code> <code>str</code> <p>Custom cache directory. If None, uses ~/.cache/brahe/</p> <code>None</code> Example <pre><code>import brahe as bh\n\n# Using default cache location (recommended)\nprovider = bh.CachingSpaceWeatherProvider(\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    extrapolate=\"Hold\"\n)\nbh.set_global_space_weather_provider(provider)\n\n# Check file status\nprint(f\"File loaded at: {provider.file_epoch()}\")\nprint(f\"File age: {provider.file_age() / 86400:.1f} days\")\n\n# Manually refresh\nprovider.refresh()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Extrapolation: {provider.extrapolation()}\")  # \"Hold\"\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nage = provider.file_age()\nprint(f\"File age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the space weather file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nfile_epoch = provider.file_epoch()\nprint(f\"File loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_ap","title":"get_ap  <code>method descriptor</code>","text":"<pre><code>get_ap(mjd: float) -&gt; float\n</code></pre> <p>Get Ap index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ap index</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nap = provider.get_ap(60000.0)\nprint(f\"Ap: {ap}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_ap_all","title":"get_ap_all  <code>method descriptor</code>","text":"<pre><code>get_ap_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Ap indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Ap indices</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nap_all = provider.get_ap_all(60000.0)\nprint(f\"8 Ap indices: {ap_all}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_ap_daily","title":"get_ap_daily  <code>method descriptor</code>","text":"<pre><code>get_ap_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Ap index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Ap</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nap_daily = provider.get_ap_daily(60000.0)\nprint(f\"Daily Ap: {ap_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_f107_adj_avg81","title":"get_f107_adj_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_adj_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average adjusted F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nf107_adj_avg = provider.get_f107_adj_avg81(60000.0)\nprint(f\"F10.7 adj 81-day avg: {f107_adj_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_f107_adjusted","title":"get_f107_adjusted  <code>method descriptor</code>","text":"<pre><code>get_f107_adjusted(mjd: float) -&gt; float\n</code></pre> <p>Get adjusted F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nf107_adj = provider.get_f107_adjusted(60000.0)\nprint(f\"F10.7 adjusted: {f107_adj} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_f107_obs_avg81","title":"get_f107_obs_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_obs_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average observed F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nf107_avg = provider.get_f107_obs_avg81(60000.0)\nprint(f\"F10.7 81-day avg: {f107_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_f107_observed","title":"get_f107_observed  <code>method descriptor</code>","text":"<pre><code>get_f107_observed(mjd: float) -&gt; float\n</code></pre> <p>Get observed F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nf107 = provider.get_f107_observed(60000.0)\nprint(f\"F10.7: {f107} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_kp","title":"get_kp  <code>method descriptor</code>","text":"<pre><code>get_kp(mjd: float) -&gt; float\n</code></pre> <p>Get Kp index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Kp index (0.0-9.0)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nkp = provider.get_kp(60000.0)\nprint(f\"Kp: {kp}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_kp_all","title":"get_kp_all  <code>method descriptor</code>","text":"<pre><code>get_kp_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Kp indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Kp indices</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nkp_all = provider.get_kp_all(60000.0)\nprint(f\"8 Kp indices: {kp_all}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_kp_daily","title":"get_kp_daily  <code>method descriptor</code>","text":"<pre><code>get_kp_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Kp index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Kp</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nkp_daily = provider.get_kp_daily(60000.0)\nprint(f\"Daily Kp: {kp_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_ap","title":"get_last_ap  <code>method descriptor</code>","text":"<pre><code>get_last_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of 3-hourly values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of Ap indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nap_last = provider.get_last_ap(60000.0, 8)\nprint(f\"Last 8 Ap values: {ap_last}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_daily_ap","title":"get_last_daily_ap  <code>method descriptor</code>","text":"<pre><code>get_last_daily_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of daily average Ap indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nap_daily_last = provider.get_last_daily_ap(60000.0, 7)\nprint(f\"Last 7 daily Ap: {ap_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_daily_epochs","title":"get_last_daily_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_daily_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N daily values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nepochs = provider.get_last_daily_epochs(60000.0, 7)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_daily_kp","title":"get_last_daily_kp  <code>method descriptor</code>","text":"<pre><code>get_last_daily_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of daily average Kp indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nkp_daily_last = provider.get_last_daily_kp(60000.0, 7)\nprint(f\"Last 7 daily Kp: {kp_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_f107","title":"get_last_f107  <code>method descriptor</code>","text":"<pre><code>get_last_f107(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily observed F10.7 values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of F10.7 values in sfu (oldest first)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nf107_last = provider.get_last_f107(60000.0, 7)\nprint(f\"Last 7 F10.7 values: {f107_last}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_kp","title":"get_last_kp  <code>method descriptor</code>","text":"<pre><code>get_last_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of 3-hourly values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of Kp indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nkp_last = provider.get_last_kp(60000.0, 8)\nprint(f\"Last 8 Kp values: {kp_last}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_last_kpap_epochs","title":"get_last_kpap_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_kpap_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N 3-hourly Kp/Ap intervals.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nepochs = provider.get_last_kpap_epochs(60000.0, 8)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.get_sunspot_number","title":"get_sunspot_number  <code>method descriptor</code>","text":"<pre><code>get_sunspot_number(mjd: float) -&gt; int\n</code></pre> <p>Get International Sunspot Number.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sunspot number</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nssn = provider.get_sunspot_number(60000.0)\nprint(f\"Sunspot number: {ssn}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Initialized: {provider.is_initialized()}\")  # True\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of space weather data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of data points</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Data points: {provider.len()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.mjd_last_daily_predicted","title":"mjd_last_daily_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_daily_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with daily predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with daily predicted data</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Last daily predicted MJD: {provider.mjd_last_daily_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.mjd_last_monthly_predicted","title":"mjd_last_monthly_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_monthly_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with monthly predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with monthly predicted data</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Last monthly predicted MJD: {provider.mjd_last_monthly_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.mjd_last_observed","title":"mjd_last_observed  <code>method descriptor</code>","text":"<pre><code>mjd_last_observed() -&gt; float\n</code></pre> <p>Get the last MJD with observed data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with observed data</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Last observed MJD: {provider.mjd_last_observed()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Max MJD: {provider.mjd_max()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Min MJD: {provider.mjd_min()}\")\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached space weather data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprovider.refresh()\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.sw_type","title":"sw_type  <code>method descriptor</code>","text":"<pre><code>sw_type() -&gt; str\n</code></pre> <p>Get the space weather data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Space weather type</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nprint(f\"Type: {provider.sw_type()}\")  # \"CssiSpaceWeather\"\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#brahe.CachingSpaceWeatherProvider.with_url","title":"with_url  <code>builtin</code>","text":"<pre><code>with_url(url: str, max_age_seconds: int, auto_refresh: bool, extrapolate: str, cache_dir: str = None) -&gt; CachingSpaceWeatherProvider\n</code></pre> <p>Create a caching provider with a custom URL for downloading space weather data.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to download space weather data from</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every access</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside data range: \"Hold\", \"Zero\", or \"Error\"</p> required <code>cache_dir</code> <code>str</code> <p>Custom cache directory. If None, uses ~/.cache/brahe/</p> <code>None</code> <p>Returns:</p> Name Type Description <code>CachingSpaceWeatherProvider</code> <code>CachingSpaceWeatherProvider</code> <p>Provider with automatic cache management from custom URL</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingSpaceWeatherProvider.with_url(\n    url=\"https://example.com/sw19571001.txt\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    extrapolate=\"Hold\"\n)\nbh.set_global_space_weather_provider(provider)\n</code></pre>"},{"location":"library_api/space_weather/caching_provider.html#see-also","title":"See Also","text":"<ul> <li>FileSpaceWeatherProvider - File-based provider</li> <li>StaticSpaceWeatherProvider - Fixed value provider</li> <li>Space Weather Functions - Global management functions</li> </ul>"},{"location":"library_api/space_weather/file_provider.html","title":"FileSpaceWeatherProvider","text":"<p>Load space weather data from CSSI format files.</p>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider","title":"FileSpaceWeatherProvider","text":"<pre><code>FileSpaceWeatherProvider()\n</code></pre> <p>File-based Space Weather provider.</p> <p>Loads space weather data from CSSI format files and provides extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from file\nsw = bh.FileSpaceWeatherProvider.from_file(\n    \"./sw_data/sw19571001.txt\",\n    extrapolate=\"Hold\"\n)\n\n# Use default packaged file\nsw = bh.FileSpaceWeatherProvider.from_default_file()\n\n# Set as global provider\nbh.set_global_space_weather_provider(sw)\n\n# Get data for a specific MJD\nmjd = 60000.0\nkp = sw.get_kp(mjd)\nap = sw.get_ap_daily(mjd)\nf107 = sw.get_f107_observed(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Extrapolation: {sw.extrapolation()}\")  # \"Hold\"\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file() -&gt; FileSpaceWeatherProvider\n</code></pre> <p>Create provider from the default packaged space weather file.</p> <p>Returns:</p> Name Type Description <code>FileSpaceWeatherProvider</code> <code>FileSpaceWeatherProvider</code> <p>Provider initialized with default file</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nbh.set_global_space_weather_provider(sw)\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, extrapolate: str) -&gt; FileSpaceWeatherProvider\n</code></pre> <p>Create provider from a CSSI space weather file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to CSSI space weather file</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileSpaceWeatherProvider</code> <code>FileSpaceWeatherProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_file(\"./sw19571001.txt\", \"Hold\")\nbh.set_global_space_weather_provider(sw)\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_ap","title":"get_ap  <code>method descriptor</code>","text":"<pre><code>get_ap(mjd: float) -&gt; float\n</code></pre> <p>Get Ap index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ap index</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nap = sw.get_ap(60000.0)\nprint(f\"Ap: {ap}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_ap_all","title":"get_ap_all  <code>method descriptor</code>","text":"<pre><code>get_ap_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Ap indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Ap indices</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nap_all = sw.get_ap_all(60000.0)\nprint(f\"8 Ap indices: {ap_all}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_ap_daily","title":"get_ap_daily  <code>method descriptor</code>","text":"<pre><code>get_ap_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Ap index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Ap</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nap_daily = sw.get_ap_daily(60000.0)\nprint(f\"Daily Ap: {ap_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_f107_adj_avg81","title":"get_f107_adj_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_adj_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average adjusted F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nf107_adj_avg = sw.get_f107_adj_avg81(60000.0)\nprint(f\"F10.7 adj 81-day avg: {f107_adj_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_f107_adjusted","title":"get_f107_adjusted  <code>method descriptor</code>","text":"<pre><code>get_f107_adjusted(mjd: float) -&gt; float\n</code></pre> <p>Get adjusted F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nf107_adj = sw.get_f107_adjusted(60000.0)\nprint(f\"F10.7 adjusted: {f107_adj} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_f107_obs_avg81","title":"get_f107_obs_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_obs_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average observed F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nf107_avg = sw.get_f107_obs_avg81(60000.0)\nprint(f\"F10.7 81-day avg: {f107_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_f107_observed","title":"get_f107_observed  <code>method descriptor</code>","text":"<pre><code>get_f107_observed(mjd: float) -&gt; float\n</code></pre> <p>Get observed F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nf107 = sw.get_f107_observed(60000.0)\nprint(f\"F10.7: {f107} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_kp","title":"get_kp  <code>method descriptor</code>","text":"<pre><code>get_kp(mjd: float) -&gt; float\n</code></pre> <p>Get Kp index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Kp index (0.0-9.0)</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nkp = sw.get_kp(60000.0)\nprint(f\"Kp: {kp}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_kp_all","title":"get_kp_all  <code>method descriptor</code>","text":"<pre><code>get_kp_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Kp indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Kp indices</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nkp_all = sw.get_kp_all(60000.0)\nprint(f\"8 Kp indices: {kp_all}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_kp_daily","title":"get_kp_daily  <code>method descriptor</code>","text":"<pre><code>get_kp_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Kp index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Kp</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nkp_daily = sw.get_kp_daily(60000.0)\nprint(f\"Daily Kp: {kp_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_ap","title":"get_last_ap  <code>method descriptor</code>","text":"<pre><code>get_last_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Ap values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nap_last = sw.get_last_ap(60000.0, 8)\nprint(f\"Last 8 Ap values: {ap_last}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_daily_ap","title":"get_last_daily_ap  <code>method descriptor</code>","text":"<pre><code>get_last_daily_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Daily Ap values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nap_daily_last = sw.get_last_daily_ap(60000.0, 7)\nprint(f\"Last 7 daily Ap: {ap_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_daily_epochs","title":"get_last_daily_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_daily_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N daily values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nepochs = sw.get_last_daily_epochs(60000.0, 7)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_daily_kp","title":"get_last_daily_kp  <code>method descriptor</code>","text":"<pre><code>get_last_daily_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Daily Kp values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nkp_daily_last = sw.get_last_daily_kp(60000.0, 7)\nprint(f\"Last 7 daily Kp: {kp_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_f107","title":"get_last_f107  <code>method descriptor</code>","text":"<pre><code>get_last_f107(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily F10.7 values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: F10.7 values in sfu, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nf107_last = sw.get_last_f107(60000.0, 7)\nprint(f\"Last 7 F10.7 values: {f107_last}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_kp","title":"get_last_kp  <code>method descriptor</code>","text":"<pre><code>get_last_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Kp values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nkp_last = sw.get_last_kp(60000.0, 8)\nprint(f\"Last 8 Kp values: {kp_last}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_last_kpap_epochs","title":"get_last_kpap_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_kpap_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N 3-hourly Kp/Ap intervals.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nepochs = sw.get_last_kpap_epochs(60000.0, 8)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.get_sunspot_number","title":"get_sunspot_number  <code>method descriptor</code>","text":"<pre><code>get_sunspot_number(mjd: float) -&gt; int\n</code></pre> <p>Get International Sunspot Number.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sunspot number</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nssn = sw.get_sunspot_number(60000.0)\nprint(f\"Sunspot number: {ssn}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Initialized: {sw.is_initialized()}\")  # True\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of space weather data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of data points</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Data points: {sw.len()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.mjd_last_daily_predicted","title":"mjd_last_daily_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_daily_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with daily predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with daily predicted data</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Last daily predicted MJD: {sw.mjd_last_daily_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.mjd_last_monthly_predicted","title":"mjd_last_monthly_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_monthly_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with monthly predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with monthly predicted data</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Last monthly predicted MJD: {sw.mjd_last_monthly_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.mjd_last_observed","title":"mjd_last_observed  <code>method descriptor</code>","text":"<pre><code>mjd_last_observed() -&gt; float\n</code></pre> <p>Get the last MJD with observed data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with observed data</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Last observed MJD: {sw.mjd_last_observed()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Max MJD: {sw.mjd_max()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Min MJD: {sw.mjd_min()}\")\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#brahe.FileSpaceWeatherProvider.sw_type","title":"sw_type  <code>method descriptor</code>","text":"<pre><code>sw_type() -&gt; str\n</code></pre> <p>Get the space weather data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Space weather type string</p> Example <pre><code>import brahe as bh\n\nsw = bh.FileSpaceWeatherProvider.from_default_file()\nprint(f\"Type: {sw.sw_type()}\")  # \"CssiSpaceWeather\"\n</code></pre>"},{"location":"library_api/space_weather/file_provider.html#see-also","title":"See Also","text":"<ul> <li>CachingSpaceWeatherProvider - Auto-downloading provider</li> <li>StaticSpaceWeatherProvider - Fixed value provider</li> <li>Space Weather Functions - Global management functions</li> </ul>"},{"location":"library_api/space_weather/functions.html","title":"Space Weather Functions","text":"<p>Global space weather management and query functions.</p> <p>Module: <code>brahe.space_weather</code></p>"},{"location":"library_api/space_weather/functions.html#managing-global-provider","title":"Managing Global Provider","text":""},{"location":"library_api/space_weather/functions.html#brahe.initialize_sw","title":"initialize_sw  <code>builtin</code>","text":"<pre><code>initialize_sw() -&gt; Any\n</code></pre> <p>Initialize the global space weather provider with recommended default settings.</p> <p>This convenience function creates a CachingSpaceWeatherProvider with sensible defaults and sets it as the global provider. The provider will:</p> <ul> <li>Automatically download/update space weather files when older than 7 days</li> <li>Use the default cache location (~/.cache/brahe/sw19571001.txt)</li> <li>Hold the last known value when extrapolating beyond available data</li> <li>NOT auto-refresh on every access (manual refresh required)</li> </ul> <p>This is the recommended way to initialize space weather data for most applications.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file download or loading failed</p> Example <pre><code>import brahe as bh\n\n# Initialize with recommended defaults\nbh.initialize_sw()\n\n# Now you can access space weather data\nmjd = 60000.0\nkp = bh.get_global_kp(mjd)\nap = bh.get_global_ap_daily(mjd)\nf107 = bh.get_global_f107_observed(mjd)\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.set_global_space_weather_provider","title":"set_global_space_weather_provider  <code>builtin</code>","text":"<pre><code>set_global_space_weather_provider(provider: StaticSpaceWeatherProvider | FileSpaceWeatherProvider | CachingSpaceWeatherProvider) -&gt; Any\n</code></pre> <p>Set the global space weather provider using any supported provider type.</p> <p>This function accepts any of the three space weather provider types.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticSpaceWeatherProvider | FileSpaceWeatherProvider | CachingSpaceWeatherProvider</code> <p>Space weather provider to set globally</p> required Example <pre><code>import brahe as bh\n\n# Use with StaticSpaceWeatherProvider\nprovider = bh.StaticSpaceWeatherProvider.from_zero()\nbh.set_global_space_weather_provider(provider)\n\n# Use with FileSpaceWeatherProvider\nprovider = bh.FileSpaceWeatherProvider.from_default_file()\nbh.set_global_space_weather_provider(provider)\n\n# Use with CachingSpaceWeatherProvider\nprovider = bh.CachingSpaceWeatherProvider(7 * 86400, False, \"Hold\")\nbh.set_global_space_weather_provider(provider)\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_initialization","title":"get_global_sw_initialization  <code>builtin</code>","text":"<pre><code>get_global_sw_initialization() -&gt; bool\n</code></pre> <p>Check if the global space weather provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nis_init = bh.get_global_sw_initialization()\nprint(f\"Initialized: {is_init}\")  # True\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_len","title":"get_global_sw_len  <code>builtin</code>","text":"<pre><code>get_global_sw_len() -&gt; int\n</code></pre> <p>Get the number of data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of data points</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nlength = bh.get_global_sw_len()\nprint(f\"Data points: {length}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_type","title":"get_global_sw_type  <code>builtin</code>","text":"<pre><code>get_global_sw_type() -&gt; str\n</code></pre> <p>Get the space weather data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Space weather type string</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nsw_type = bh.get_global_sw_type()\nprint(f\"Type: {sw_type}\")  # \"CssiSpaceWeather\"\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_extrapolation","title":"get_global_sw_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_sw_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nextrapolation = bh.get_global_sw_extrapolation()\nprint(f\"Extrapolation: {extrapolation}\")  # \"Hold\"\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_mjd_min","title":"get_global_sw_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_sw_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nmjd_min = bh.get_global_sw_mjd_min()\nprint(f\"Min MJD: {mjd_min}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_mjd_max","title":"get_global_sw_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_sw_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nmjd_max = bh.get_global_sw_mjd_max()\nprint(f\"Max MJD: {mjd_max}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_mjd_last_observed","title":"get_global_sw_mjd_last_observed  <code>builtin</code>","text":"<pre><code>get_global_sw_mjd_last_observed() -&gt; float\n</code></pre> <p>Get the last MJD with observed data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with observed data</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nmjd_obs = bh.get_global_sw_mjd_last_observed()\nprint(f\"Last observed MJD: {mjd_obs}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_mjd_last_daily_predicted","title":"get_global_sw_mjd_last_daily_predicted  <code>builtin</code>","text":"<pre><code>get_global_sw_mjd_last_daily_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with daily predicted data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with daily predicted data</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nmjd_daily = bh.get_global_sw_mjd_last_daily_predicted()\nprint(f\"Last daily predicted MJD: {mjd_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_sw_mjd_last_monthly_predicted","title":"get_global_sw_mjd_last_monthly_predicted  <code>builtin</code>","text":"<pre><code>get_global_sw_mjd_last_monthly_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with monthly predicted data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with monthly predicted data</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nmjd_monthly = bh.get_global_sw_mjd_last_monthly_predicted()\nprint(f\"Last monthly predicted MJD: {mjd_monthly}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#querying-kp-index","title":"Querying Kp Index","text":""},{"location":"library_api/space_weather/functions.html#brahe.get_global_kp","title":"get_global_kp  <code>builtin</code>","text":"<pre><code>get_global_kp(mjd: float) -&gt; float\n</code></pre> <p>Get Kp index from the global space weather provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Kp index (0.0-9.0)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nkp = bh.get_global_kp(60000.0)\nprint(f\"Kp: {kp}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_kp_all","title":"get_global_kp_all  <code>builtin</code>","text":"<pre><code>get_global_kp_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Kp indices from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Kp indices</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nkp_all = bh.get_global_kp_all(60000.0)\nprint(f\"8 Kp indices: {kp_all}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_kp_daily","title":"get_global_kp_daily  <code>builtin</code>","text":"<pre><code>get_global_kp_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Kp from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Kp</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nkp_daily = bh.get_global_kp_daily(60000.0)\nprint(f\"Daily Kp: {kp_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#querying-ap-index","title":"Querying Ap Index","text":""},{"location":"library_api/space_weather/functions.html#brahe.get_global_ap","title":"get_global_ap  <code>builtin</code>","text":"<pre><code>get_global_ap(mjd: float) -&gt; float\n</code></pre> <p>Get Ap index from the global space weather provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ap index</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nap = bh.get_global_ap(60000.0)\nprint(f\"Ap: {ap}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_ap_all","title":"get_global_ap_all  <code>builtin</code>","text":"<pre><code>get_global_ap_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Ap indices from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Ap indices</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nap_all = bh.get_global_ap_all(60000.0)\nprint(f\"8 Ap indices: {ap_all}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_ap_daily","title":"get_global_ap_daily  <code>builtin</code>","text":"<pre><code>get_global_ap_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Ap from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Ap</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nap_daily = bh.get_global_ap_daily(60000.0)\nprint(f\"Daily Ap: {ap_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#querying-f107-solar-flux","title":"Querying F10.7 Solar Flux","text":""},{"location":"library_api/space_weather/functions.html#brahe.get_global_f107_observed","title":"get_global_f107_observed  <code>builtin</code>","text":"<pre><code>get_global_f107_observed(mjd: float) -&gt; float\n</code></pre> <p>Get observed F10.7 flux from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nf107 = bh.get_global_f107_observed(60000.0)\nprint(f\"F10.7: {f107} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_f107_adjusted","title":"get_global_f107_adjusted  <code>builtin</code>","text":"<pre><code>get_global_f107_adjusted(mjd: float) -&gt; float\n</code></pre> <p>Get adjusted F10.7 flux from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nf107_adj = bh.get_global_f107_adjusted(60000.0)\nprint(f\"F10.7 adjusted: {f107_adj} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_f107_obs_avg81","title":"get_global_f107_obs_avg81  <code>builtin</code>","text":"<pre><code>get_global_f107_obs_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day average observed F10.7 flux from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nf107_avg = bh.get_global_f107_obs_avg81(60000.0)\nprint(f\"F10.7 81-day avg: {f107_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_f107_adj_avg81","title":"get_global_f107_adj_avg81  <code>builtin</code>","text":"<pre><code>get_global_f107_adj_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day average adjusted F10.7 flux from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nf107_adj_avg = bh.get_global_f107_adj_avg81(60000.0)\nprint(f\"F10.7 adj 81-day avg: {f107_adj_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#querying-sunspot-number","title":"Querying Sunspot Number","text":""},{"location":"library_api/space_weather/functions.html#brahe.get_global_sunspot_number","title":"get_global_sunspot_number  <code>builtin</code>","text":"<pre><code>get_global_sunspot_number(mjd: float) -&gt; int\n</code></pre> <p>Get International Sunspot Number from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sunspot number</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nssn = bh.get_global_sunspot_number(60000.0)\nprint(f\"Sunspot number: {ssn}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#range-queries","title":"Range Queries","text":""},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_kp","title":"get_global_last_kp  <code>builtin</code>","text":"<pre><code>get_global_last_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Kp values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of 3-hourly values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of Kp indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nkp_last = bh.get_global_last_kp(60000.0, 8)\nprint(f\"Last 8 Kp values: {kp_last}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_ap","title":"get_global_last_ap  <code>builtin</code>","text":"<pre><code>get_global_last_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Ap values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of 3-hourly values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of Ap indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nap_last = bh.get_global_last_ap(60000.0, 8)\nprint(f\"Last 8 Ap values: {ap_last}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_daily_kp","title":"get_global_last_daily_kp  <code>builtin</code>","text":"<pre><code>get_global_last_daily_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Kp values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of daily average Kp indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nkp_daily_last = bh.get_global_last_daily_kp(60000.0, 7)\nprint(f\"Last 7 daily Kp: {kp_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_daily_ap","title":"get_global_last_daily_ap  <code>builtin</code>","text":"<pre><code>get_global_last_daily_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Ap values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of daily average Ap indices (oldest first)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nap_daily_last = bh.get_global_last_daily_ap(60000.0, 7)\nprint(f\"Last 7 daily Ap: {ap_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_f107","title":"get_global_last_f107  <code>builtin</code>","text":"<pre><code>get_global_last_f107(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily observed F10.7 values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of daily values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: List of F10.7 values in sfu (oldest first)</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nf107_last = bh.get_global_last_f107(60000.0, 7)\nprint(f\"Last 7 F10.7 values: {f107_last}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_kpap_epochs","title":"get_global_last_kpap_epochs  <code>builtin</code>","text":"<pre><code>get_global_last_kpap_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N 3-hourly Kp/Ap intervals from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nepochs = bh.get_global_last_kpap_epochs(60000.0, 8)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#brahe.get_global_last_daily_epochs","title":"get_global_last_daily_epochs  <code>builtin</code>","text":"<pre><code>get_global_last_daily_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N daily values from the global provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nbh.initialize_sw()\nepochs = bh.get_global_last_daily_epochs(60000.0, 7)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/functions.html#see-also","title":"See Also","text":"<ul> <li>FileSpaceWeatherProvider</li> <li>CachingSpaceWeatherProvider</li> <li>StaticSpaceWeatherProvider</li> </ul>"},{"location":"library_api/space_weather/static_provider.html","title":"StaticSpaceWeatherProvider","text":"<p>Use fixed space weather values for testing or offline use.</p>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider","title":"StaticSpaceWeatherProvider","text":"<pre><code>StaticSpaceWeatherProvider()\n</code></pre> <p>Static Space Weather provider with constant values.</p> <p>Provides space weather data using fixed values that don't change with time. Useful for testing or scenarios where time-varying space weather data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static provider with default (uninitialized) values\nsw = bh.StaticSpaceWeatherProvider()\n\n# Create static provider with zero values\nsw_zero = bh.StaticSpaceWeatherProvider.from_zero()\n\n# Create with custom values\nsw_custom = bh.StaticSpaceWeatherProvider.from_values(\n    kp=3.0, ap=15.0, f107=150.0, f107a=145.0, s=100\n)\n\n# Set as global provider\nbh.set_global_space_weather_provider(sw_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Extrapolation: {sw.extrapolation()}\")  # \"Hold\"\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(kp: float, ap: float, f107: float, f107a: float, s: int) -&gt; StaticSpaceWeatherProvider\n</code></pre> <p>Create a static space weather provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>kp</code> <code>float</code> <p>Kp geomagnetic index (0.0-9.0)</p> required <code>ap</code> <code>float</code> <p>Ap geomagnetic index</p> required <code>f107</code> <code>float</code> <p>F10.7 solar radio flux in sfu</p> required <code>f107a</code> <code>float</code> <p>81-day average F10.7 flux in sfu</p> required <code>s</code> <code>int</code> <p>International Sunspot Number</p> required <p>Returns:</p> Name Type Description <code>StaticSpaceWeatherProvider</code> <code>StaticSpaceWeatherProvider</code> <p>Provider with specified values</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(\n    kp=3.0, ap=15.0, f107=150.0, f107a=145.0, s=100\n)\nbh.set_global_space_weather_provider(sw)\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticSpaceWeatherProvider\n</code></pre> <p>Create a static space weather provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticSpaceWeatherProvider</code> <code>StaticSpaceWeatherProvider</code> <p>Provider with all values set to zero</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nbh.set_global_space_weather_provider(sw)\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_ap","title":"get_ap  <code>method descriptor</code>","text":"<pre><code>get_ap(mjd: float) -&gt; float\n</code></pre> <p>Get Ap index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Ap index</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nap = sw.get_ap(60000.0)\nprint(f\"Ap: {ap}\")  # 15.0\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_ap_all","title":"get_ap_all  <code>method descriptor</code>","text":"<pre><code>get_ap_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Ap indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Ap indices</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nap_all = sw.get_ap_all(60000.0)\nprint(f\"8 Ap indices: {ap_all}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_ap_daily","title":"get_ap_daily  <code>method descriptor</code>","text":"<pre><code>get_ap_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Ap index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Ap</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nap_daily = sw.get_ap_daily(60000.0)\nprint(f\"Daily Ap: {ap_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_f107_adj_avg81","title":"get_f107_adj_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_adj_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average adjusted F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nf107_adj_avg = sw.get_f107_adj_avg81(60000.0)\nprint(f\"F10.7 adj 81-day avg: {f107_adj_avg} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_f107_adjusted","title":"get_f107_adjusted  <code>method descriptor</code>","text":"<pre><code>get_f107_adjusted(mjd: float) -&gt; float\n</code></pre> <p>Get adjusted F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adjusted F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nf107_adj = sw.get_f107_adjusted(60000.0)\nprint(f\"F10.7 adjusted: {f107_adj} sfu\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_f107_obs_avg81","title":"get_f107_obs_avg81  <code>method descriptor</code>","text":"<pre><code>get_f107_obs_avg81(mjd: float) -&gt; float\n</code></pre> <p>Get 81-day centered average observed F10.7 flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>81-day average F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nf107_avg = sw.get_f107_obs_avg81(60000.0)\nprint(f\"F10.7 81-day avg: {f107_avg} sfu\")  # 145.0 sfu\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_f107_observed","title":"get_f107_observed  <code>method descriptor</code>","text":"<pre><code>get_f107_observed(mjd: float) -&gt; float\n</code></pre> <p>Get observed F10.7 solar flux.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>F10.7 flux in sfu</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nf107 = sw.get_f107_observed(60000.0)\nprint(f\"F10.7: {f107} sfu\")  # 150.0 sfu\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_kp","title":"get_kp  <code>method descriptor</code>","text":"<pre><code>get_kp(mjd: float) -&gt; float\n</code></pre> <p>Get Kp index for the specified MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Kp index (0.0-9.0)</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nkp = sw.get_kp(60000.0)\nprint(f\"Kp: {kp}\")  # 3.0\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_kp_all","title":"get_kp_all  <code>method descriptor</code>","text":"<pre><code>get_kp_all(mjd: float) -&gt; list[float]\n</code></pre> <p>Get all eight 3-hourly Kp indices for the day.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Array of 8 Kp indices</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nkp_all = sw.get_kp_all(60000.0)\nprint(f\"8 Kp indices: {kp_all}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_kp_daily","title":"get_kp_daily  <code>method descriptor</code>","text":"<pre><code>get_kp_daily(mjd: float) -&gt; float\n</code></pre> <p>Get daily average Kp index.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Daily average Kp</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nkp_daily = sw.get_kp_daily(60000.0)\nprint(f\"Daily Kp: {kp_daily}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_ap","title":"get_last_ap  <code>method descriptor</code>","text":"<pre><code>get_last_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Ap values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nap_last = sw.get_last_ap(60000.0, 8)\nprint(f\"Last 8 Ap values: {ap_last}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_daily_ap","title":"get_last_daily_ap  <code>method descriptor</code>","text":"<pre><code>get_last_daily_ap(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Ap values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Daily Ap values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nap_daily_last = sw.get_last_daily_ap(60000.0, 7)\nprint(f\"Last 7 daily Ap: {ap_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_daily_epochs","title":"get_last_daily_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_daily_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N daily values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nepochs = sw.get_last_daily_epochs(60000.0, 7)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_daily_kp","title":"get_last_daily_kp  <code>method descriptor</code>","text":"<pre><code>get_last_daily_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily average Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Daily Kp values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nkp_daily_last = sw.get_last_daily_kp(60000.0, 7)\nprint(f\"Last 7 daily Kp: {kp_daily_last}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_f107","title":"get_last_f107  <code>method descriptor</code>","text":"<pre><code>get_last_f107(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N daily F10.7 values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: F10.7 values in sfu, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nf107_last = sw.get_last_f107(60000.0, 7)\nprint(f\"Last 7 F10.7 values: {f107_last}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_kp","title":"get_last_kp  <code>method descriptor</code>","text":"<pre><code>get_last_kp(mjd: float, n: int) -&gt; list[float]\n</code></pre> <p>Get the last N 3-hourly Kp values.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of values to return</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Kp values, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nkp_last = sw.get_last_kp(60000.0, 8)\nprint(f\"Last 8 Kp values: {kp_last}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_last_kpap_epochs","title":"get_last_kpap_epochs  <code>method descriptor</code>","text":"<pre><code>get_last_kpap_epochs(mjd: float, n: int) -&gt; list[Epoch]\n</code></pre> <p>Get epochs for the last N 3-hourly Kp/Ap intervals.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date (end point)</p> required <code>n</code> <code>int</code> <p>Number of epochs to return</p> required <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: Epoch objects, oldest first</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nepochs = sw.get_last_kpap_epochs(60000.0, 8)\nfor epoch in epochs:\n    print(f\"Epoch: {epoch}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.get_sunspot_number","title":"get_sunspot_number  <code>method descriptor</code>","text":"<pre><code>get_sunspot_number(mjd: float) -&gt; int\n</code></pre> <p>Get International Sunspot Number.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Sunspot number</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_values(3.0, 15.0, 150.0, 145.0, 100)\nssn = sw.get_sunspot_number(60000.0)\nprint(f\"Sunspot number: {ssn}\")  # 100\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Initialized: {sw.is_initialized()}\")  # True\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of space weather data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of data points</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Data points: {sw.len()}\")  # 1\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.mjd_last_daily_predicted","title":"mjd_last_daily_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_daily_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with daily predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with daily predicted data</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Last daily predicted MJD: {sw.mjd_last_daily_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.mjd_last_monthly_predicted","title":"mjd_last_monthly_predicted  <code>method descriptor</code>","text":"<pre><code>mjd_last_monthly_predicted() -&gt; float\n</code></pre> <p>Get the last MJD with monthly predicted data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with monthly predicted data</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Last monthly predicted MJD: {sw.mjd_last_monthly_predicted()}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.mjd_last_observed","title":"mjd_last_observed  <code>method descriptor</code>","text":"<pre><code>mjd_last_observed() -&gt; float\n</code></pre> <p>Get the last MJD with observed data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with observed data</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Last observed MJD: {sw.mjd_last_observed()}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Max MJD: {sw.mjd_max()}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Min MJD: {sw.mjd_min()}\")\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#brahe.StaticSpaceWeatherProvider.sw_type","title":"sw_type  <code>method descriptor</code>","text":"<pre><code>sw_type() -&gt; str\n</code></pre> <p>Get the space weather data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Space weather type string</p> Example <pre><code>import brahe as bh\n\nsw = bh.StaticSpaceWeatherProvider.from_zero()\nprint(f\"Type: {sw.sw_type()}\")  # \"Static\"\n</code></pre>"},{"location":"library_api/space_weather/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileSpaceWeatherProvider - File-based provider</li> <li>CachingSpaceWeatherProvider - Auto-downloading provider</li> <li>Space Weather Functions - Global management functions</li> </ul>"},{"location":"library_api/time/index.html","title":"Time","text":"<p>Module: <code>brahe.time</code></p> <p>High-precision time system management and conversions.</p>"},{"location":"library_api/time/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Epoch Class - Core time representation supporting multiple time systems</li> <li>Time Conversions - Functions for converting between time systems and formats</li> </ul>"},{"location":"library_api/time/conversions.html","title":"Time Conversions","text":"<p>Functions for converting between different time systems and formats.</p>"},{"location":"library_api/time/conversions.html#time-system-offset-functions","title":"Time System Offset Functions","text":""},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_mjd","title":"time_system_offset_for_mjd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_mjd(mjd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from UTC to TAI at J2000 epoch\nmjd_j2000 = 51544.0\noffset = bh.time_system_offset_for_mjd(mjd_j2000, bh.TimeSystem.UTC, bh.TimeSystem.TAI)\nprint(f\"UTC to TAI offset: {offset} seconds\")\n# Output: UTC to TAI offset: 32.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_jd","title":"time_system_offset_for_jd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_jd(jd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from GPS to UTC at a specific Julian Date\njd = 2460000.0\noffset = bh.time_system_offset_for_jd(jd, bh.TimeSystem.GPS, bh.TimeSystem.UTC)\nprint(f\"GPS to UTC offset: {offset} seconds\")\n# Output: GPS to UTC offset: -18.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_datetime","title":"time_system_offset_for_datetime  <code>builtin</code>","text":"<pre><code>time_system_offset_for_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Gregorian calendar date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from TT to TAI on January 1, 2024\noffset = bh.time_system_offset_for_datetime(\n    2024, 1, 1, 0, 0, 0.0, 0.0,\n    bh.TimeSystem.TT, bh.TimeSystem.TAI\n)\nprint(f\"TT to TAI offset: {offset} seconds\")\n# Output: TT to TAI offset: -32.184 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#datetime-conversion-functions","title":"DateTime Conversion Functions","text":""},{"location":"library_api/time/conversions.html#brahe.datetime_to_jd","title":"datetime_to_jd  <code>builtin</code>","text":"<pre><code>datetime_to_jd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Julian Date\njd = bh.datetime_to_jd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460311.000000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.datetime_to_mjd","title":"datetime_to_mjd  <code>builtin</code>","text":"<pre><code>datetime_to_mjd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Modified Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Modified Julian Date\nmjd = bh.datetime_to_mjd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.500000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.jd_to_datetime","title":"jd_to_datetime  <code>builtin</code>","text":"<pre><code>jd_to_datetime(jd: float) -&gt; Tuple\n</code></pre> <p>Convert a Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Julian Date to Gregorian calendar\njd = 2460311.0\nyear, month, day, hour, minute, second, nanosecond = bh.jd_to_datetime(jd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.mjd_to_datetime","title":"mjd_to_datetime  <code>builtin</code>","text":"<pre><code>mjd_to_datetime(mjd: float) -&gt; Tuple\n</code></pre> <p>Convert a Modified Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Modified Julian Date to Gregorian calendar\nmjd = 60310.5\nyear, month, day, hour, minute, second, nanosecond = bh.mjd_to_datetime(mjd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html","title":"Epoch Class","text":"<p>The <code>Epoch</code> class is the foundational time representation in Brahe, providing comprehensive support for multiple time systems and high-precision time computations with nanosecond accuracy.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch","title":"Epoch","text":"<pre><code>Epoch(args: Any, time_system: Any = None)\n</code></pre> <p>Represents a specific instant in time.</p> <p>Epoch is the primary and preferred mechanism for representing time in brahe. It accurately represents, tracks, and compares instants in time with nanosecond precision.</p> <p>Internally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation was chosen to enable accurate time system conversions using the IAU SOFA library (which operates in days and fractional days) while maintaining high precision for small time differences. The structure uses Kahan summation to accurately handle running sums over long periods without losing accuracy to floating-point rounding errors.</p> <p>All arithmetic operations (addition, subtraction) use seconds as the default unit and return time differences in seconds.</p> <p>The Epoch constructor accepts multiple input formats for convenience:</p> <ul> <li>Date components: <code>Epoch(year, month, day)</code> - creates epoch at midnight</li> <li>Full datetime: <code>Epoch(year, month, day, hour, minute, second, nanosecond)</code> - full precision</li> <li>Partial datetime: <code>Epoch(year, month, day, hour)</code> or <code>Epoch(year, month, day, hour, minute)</code> etc.</li> <li>ISO 8601 string: <code>Epoch(\"2024-01-01T12:00:00Z\")</code> - parse from string</li> <li>Python datetime: <code>Epoch(datetime_obj)</code> - convert from Python datetime</li> <li>Copy constructor: <code>Epoch(other_epoch)</code> - create a copy</li> <li>Time system: All constructors accept optional <code>time_system=</code> keyword argument (default: UTC)</li> </ul> Example <pre><code>import brahe as bh\nfrom datetime import datetime\n\n# Multiple ways to create the same epoch\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\nepc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\nprint(epc1)\n# Output: 2024-01-01 12:00:00.000 UTC\n\n# Create epoch at midnight\nmidnight = bh.Epoch(2024, 1, 1)\nprint(midnight)\n# Output: 2024-01-01 00:00:00.000 UTC\n\n# Use different time systems\ngps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\nprint(gps_time)\n# Output: 2024-01-01 12:00:00.000 GPS\n\n# Perform arithmetic operations\nepoch2 = epc1 + 3600.0  # Add one hour (in seconds)\ndiff = epoch2 - epc1     # Difference in seconds\nprint(f\"Time difference: {diff} seconds\")\n# Output: Time difference: 3600.0 seconds\n\n# Legacy constructors still available\nepc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nepc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.time_system","title":"time_system  <code>property</code>","text":"<pre><code>time_system: TimeSystem\n</code></pre> <p>Time system of the epoch.</p> <p>Returns:</p> Name Type Description <code>TimeSystem</code> <code>TimeSystem</code> <p>The time system used by this epoch</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day","title":"day  <code>method descriptor</code>","text":"<pre><code>day() -&gt; int\n</code></pre> <p>Returns the day component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The day of the month as an integer from 1 to 31</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year","title":"day_of_year  <code>method descriptor</code>","text":"<pre><code>day_of_year() -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the epoch's time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <pre><code>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, \"UTC\")\ndoy = epoch.day_of_year()\nprint(f\"Day of year: {doy}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year_as_time_system","title":"day_of_year_as_time_system  <code>method descriptor</code>","text":"<pre><code>day_of_year_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the specified time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>The time system to use for the calculation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <pre><code>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, brahe.TimeSystem.UTC)\ndoy_tai = epoch.day_of_year_as_time_system(brahe.TimeSystem.TAI)\nprint(f\"Day of year in TAI: {doy_tai}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_date","title":"from_date  <code>builtin</code>","text":"<pre><code>from_date(year: int, month: int, day: int, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a calendar date at midnight.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing midnight on the specified date</p> Example <pre><code>import brahe as bh\n\n# Create an epoch at midnight on January 1, 2024 UTC\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T00:00:00.000000000 UTC\n\n# Create epoch in different time system\nepc_tai = bh.Epoch.from_date(2024, 6, 15, bh.TimeSystem.TAI)\nprint(epc_tai)\n# Output: 2024-06-15T00:00:00.000000000 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_datetime","title":"from_datetime  <code>builtin</code>","text":"<pre><code>from_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a complete Gregorian calendar date and time.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified date and time</p> Example <pre><code>import brahe as bh\n\n# Create epoch for January 1, 2024 at 12:30:45.5 UTC\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T12:30:45.500000000 UTC\n\n# With nanosecond precision\nepc_ns = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 0.0, 123456789.0, bh.TimeSystem.TAI)\nprint(epc_ns)\n# Output: 2024-06-15T14:30:00.123456789 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_day_of_year","title":"from_day_of_year  <code>builtin</code>","text":"<pre><code>from_day_of_year(year: int, day_of_year: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a year and floating-point day-of-year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>day_of_year</code> <code>float</code> <p>Day of year as a floating-point number (1.0 = January 1st, 1.5 = January 1st noon, etc.)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified day of year</p> Example <pre><code>import brahe as bh\n\n# Create epoch for day 100 of 2024 at midnight\nepc = bh.Epoch.from_day_of_year(2024, 100.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-04-09T00:00:00.000000000 UTC\n\n# Create epoch for day 100.5 (noon on day 100)\nepc_noon = bh.Epoch.from_day_of_year(2024, 100.5, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc_noon.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-04-09 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_date","title":"from_gps_date  <code>builtin</code>","text":"<pre><code>from_gps_date(week: int, seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS week and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>week</code> <code>int</code> <p>GPS week number since GPS epoch (January 6, 1980)</p> required <code>seconds</code> <code>float</code> <p>Seconds into the GPS week</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS week 2200, day 3, noon\nweek = 2200\nseconds = 3 * 86400 + 12 * 3600  # 3 days + 12 hours\nepc = bh.Epoch.from_gps_date(week, seconds)\nprint(epc)\n\n# Verify GPS week extraction\nweek_out, sec_out = epc.gps_date()\nprint(f\"GPS Week: {week_out}, Seconds: {sec_out}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_nanoseconds","title":"from_gps_nanoseconds  <code>builtin</code>","text":"<pre><code>from_gps_nanoseconds(gps_nanoseconds: int) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS nanoseconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_nanoseconds</code> <code>int</code> <p>Nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS nanoseconds with high precision\ngps_ns = 1234567890123456789\nepc = bh.Epoch.from_gps_nanoseconds(gps_ns)\nprint(f\"Epoch: {epc}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_seconds","title":"from_gps_seconds  <code>builtin</code>","text":"<pre><code>from_gps_seconds(gps_seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS seconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_seconds</code> <code>float</code> <p>Seconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS seconds\ngps_seconds = 1234567890.5\nepc = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"Epoch: {epc}\")\nprint(f\"GPS seconds: {epc.gps_seconds()}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_jd","title":"from_jd  <code>builtin</code>","text":"<pre><code>from_jd(jd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Julian Date\njd = 2460000.0\nepc = bh.Epoch.from_jd(jd, bh.TimeSystem.UTC)\nprint(epc)\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"JD: {jd_out:.10f}\")\n# Output: JD: 2460000.0000000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_mjd","title":"from_mjd  <code>builtin</code>","text":"<pre><code>from_mjd(mjd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Modified Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Modified Julian Date\nmjd = 60000.0\nepc = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\nprint(epc)\n\n# MJD is commonly used in astronomy\nmjd_j2000 = 51544.0  # J2000 epoch\nepc_j2000 = bh.Epoch.from_mjd(mjd_j2000, bh.TimeSystem.TT)\nprint(f\"J2000: {epc_j2000}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_string","title":"from_string  <code>builtin</code>","text":"<pre><code>from_string(datestr: str) -&gt; Epoch\n</code></pre> <p>Create an Epoch from an ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>datestr</code> <code>str</code> <p>ISO 8601 formatted date string (e.g., \"2024-01-01T12:00:00.000000000 UTC\")</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the parsed date and time</p> Example <pre><code>import brahe as bh\n\n# Parse ISO 8601 string with full precision\nepc = bh.Epoch.from_string(\"2024-01-01T12:00:00.000000000 UTC\")\nprint(epc)\n# Output: 2024-01-01T12:00:00.000000000 UTC\n\n# Parse different time systems\nepc_tai = bh.Epoch.from_string(\"2024-06-15T14:30:45.123456789 TAI\")\nprint(epc_tai.time_system)\n# Output: TimeSystem.TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gast","title":"gast  <code>method descriptor</code>","text":"<pre><code>gast(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Apparent Sidereal Time (GAST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GAST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngast_rad = epc.gast(bh.AngleFormat.RADIANS)\ngast_deg = epc.gast(bh.AngleFormat.DEGREES)\nprint(f\"GAST: {gast_rad:.6f} rad = {gast_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gmst","title":"gmst  <code>method descriptor</code>","text":"<pre><code>gmst(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Mean Sidereal Time (GMST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GMST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngmst_rad = epc.gmst(bh.AngleFormat.RADIANS)\ngmst_deg = epc.gmst(bh.AngleFormat.DEGREES)\nprint(f\"GMST: {gmst_rad:.6f} rad = {gmst_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_date","title":"gps_date  <code>method descriptor</code>","text":"<pre><code>gps_date() -&gt; Tuple\n</code></pre> <p>Get the GPS week number and seconds into the week.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (week, seconds_into_week)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.GPS)\nweek, seconds = epc.gps_date()\nprint(f\"GPS Week: {week}, Seconds: {seconds:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_nanoseconds","title":"gps_nanoseconds  <code>method descriptor</code>","text":"<pre><code>gps_nanoseconds() -&gt; float\n</code></pre> <p>Get the nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS nanoseconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 123456789.0, bh.TimeSystem.GPS)\ngps_ns = epc.gps_nanoseconds()\nprint(f\"GPS nanoseconds: {gps_ns:.0f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_seconds","title":"gps_seconds  <code>method descriptor</code>","text":"<pre><code>gps_seconds() -&gt; float\n</code></pre> <p>Get the seconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS seconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\ngps_sec = epc.gps_seconds()\nprint(f\"GPS seconds: {gps_sec:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.hour","title":"hour  <code>method descriptor</code>","text":"<pre><code>hour() -&gt; int\n</code></pre> <p>Returns the hour component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hour as an integer from 0 to 23</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring","title":"isostring  <code>method descriptor</code>","text":"<pre><code>isostring() -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string with full nanosecond precision</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso = epc.isostring()\nprint(iso)\n# Output: 2024-01-01T12:30:45.123456789Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring_with_decimals","title":"isostring_with_decimals  <code>method descriptor</code>","text":"<pre><code>isostring_with_decimals(decimals: int) -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string with specified decimal precision.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimal places for the seconds field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso3 = epc.isostring_with_decimals(3)\niso6 = epc.isostring_with_decimals(6)\nprint(iso3)  # Output: 2024-01-01T12:30:45.123Z\nprint(iso6)  # Output: 2024-01-01T12:30:45.123457Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd","title":"jd  <code>method descriptor</code>","text":"<pre><code>jd() -&gt; float\n</code></pre> <p>Get the Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd = epc.jd()\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460310.500000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd_as_time_system","title":"jd_as_time_system  <code>method descriptor</code>","text":"<pre><code>jd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd_utc = epc.jd()\njd_tai = epc.jd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"JD UTC: {jd_utc:.10f}\")\nprint(f\"JD TAI: {jd_tai:.10f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.minute","title":"minute  <code>method descriptor</code>","text":"<pre><code>minute() -&gt; int\n</code></pre> <p>Returns the minute component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The minute as an integer from 0 to 59</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd","title":"mjd  <code>method descriptor</code>","text":"<pre><code>mjd() -&gt; float\n</code></pre> <p>Get the Modified Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epc.mjd()\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd_as_time_system","title":"mjd_as_time_system  <code>method descriptor</code>","text":"<pre><code>mjd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Modified Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd_utc = epc.mjd()\nmjd_gps = epc.mjd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"MJD UTC: {mjd_utc:.6f}\")\nprint(f\"MJD GPS: {mjd_gps:.6f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.month","title":"month  <code>method descriptor</code>","text":"<pre><code>month() -&gt; int\n</code></pre> <p>Returns the month component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The month as an integer from 1 to 12</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.nanosecond","title":"nanosecond  <code>method descriptor</code>","text":"<pre><code>nanosecond() -&gt; float\n</code></pre> <p>Returns the nanosecond component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The nanosecond component as a floating-point number</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.now","title":"now  <code>builtin</code>","text":"<pre><code>now() -&gt; Epoch\n</code></pre> <p>Create an Epoch representing the current UTC instant.</p> <p>This method uses the system clock to get the current time and creates an Epoch in the UTC time system.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the current instant in time in UTC</p> Example <pre><code>import brahe as bh\n\n# Get current time as an Epoch\nnow = bh.Epoch.now()\nprint(f\"Current time: {now}\")\nprint(f\"Time system: {now.time_system}\")\n# Output: Time system: TimeSystem.UTC\n\n# Use in orbital calculations\nimport numpy as np\ncurrent_epoch = bh.Epoch.now()\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_koe_to_eci(oe, bh.AngleFormat.RADIANS)\npropagator = bh.KeplerianPropagator.from_eci(current_epoch, state, 60.0)\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.second","title":"second  <code>method descriptor</code>","text":"<pre><code>second() -&gt; float\n</code></pre> <p>Returns the second component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The second as a floating-point number from 0.0 to 59.999...</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime","title":"to_datetime  <code>method descriptor</code>","text":"<pre><code>to_datetime() -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-06-15 14:30:45.500\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime_as_time_system","title":"to_datetime_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_datetime_as_time_system(time_system: TimeSystem) -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Create epoch in UTC and convert to TAI\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime_as_time_system(bh.TimeSystem.TAI)\nprint(f\"TAI: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: TAI: 2024-01-01 12:00:37.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_pydatetime","title":"to_pydatetime  <code>method descriptor</code>","text":"<pre><code>to_pydatetime() -&gt; datetime\n</code></pre> <p>Convert the epoch to a Python datetime object in UTC timezone.</p> <p>This method always converts the epoch to UTC before creating the datetime object, regardless of the epoch's original time system.</p> <p>Returns:</p> Type Description <code>datetime</code> <p>datetime.datetime: Python datetime object with UTC timezone</p> Example <pre><code>import brahe as bh\nfrom datetime import datetime, timezone\n\n# Create epoch in GPS time\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.GPS)\n\n# Convert to Python datetime (always UTC)\ndt = epc.to_pydatetime()\nprint(dt)  # datetime object in UTC\nprint(dt.tzinfo)  # timezone.utc\n\n# Verify it's always UTC\nassert dt.tzinfo == timezone.utc\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_string_as_time_system","title":"to_string_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_string_as_time_system(time_system: TimeSystem) -&gt; str\n</code></pre> <p>Convert the epoch to a string representation in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the epoch</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprint(epc.to_string_as_time_system(bh.TimeSystem.UTC))\nprint(epc.to_string_as_time_system(bh.TimeSystem.TAI))\n# Shows same instant in different time systems\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.year","title":"year  <code>method descriptor</code>","text":"<pre><code>year() -&gt; int\n</code></pre> <p>Returns the year component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year as a 4-digit integer</p>"},{"location":"library_api/time/time_range.html","title":"TimeRange Class","text":"<p>The <code>TimeRange</code> class provides an iterator for generating sequences of epochs over a time range with a specified step size. It is particularly useful for orbit propagation, trajectory sampling, and time-series analysis.</p>"},{"location":"library_api/time/time_range.html#brahe._brahe.TimeRange","title":"TimeRange","text":"<pre><code>TimeRange(epoch_start: Epoch, epoch_end: Epoch, step: float)\n</code></pre> <p>Iterator that generates a sequence of epochs over a time range.</p> <p>TimeRange creates an iterator that yields epochs from a start time to an end time with a specified step size in seconds. This is useful for propagating orbits, sampling trajectories, or generating time grids for analysis.</p> <p>Parameters:</p> Name Type Description Default <code>epoch_start</code> <code>Epoch</code> <p>Starting epoch for the range</p> required <code>epoch_end</code> <code>Epoch</code> <p>Ending epoch for the range</p> required <code>step</code> <code>float</code> <p>Time step in seconds between consecutive epochs</p> required <p>Examples:</p> <pre><code>from brahe import Epoch, TimeRange, TimeSystem\nstart = Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, TimeSystem.UTC)\nend = start + 3600.0  # One hour later\ntime_range = TimeRange(start, end, 60.0)  # 60-second steps\nfor epoch in time_range:\n    print(epoch)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/index.html","title":"Trajectories","text":"<p>Module: <code>brahe.trajectories</code></p> <p>Trajectory containers for storing, managing, and interpolating time-series state data.</p>"},{"location":"library_api/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":""},{"location":"library_api/trajectories/index.html#trajectory","title":"Trajectory","text":"<p>Dynamic-dimension trajectory container where dimension is set at runtime. Flexible for storing any N-dimensional state data.</p>"},{"location":"library_api/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized orbital trajectory with frame-aware storage and automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>InterpolationMethod - Interpolation options</li> <li>OrbitFrame - Frame specifications</li> <li>KeplerianPropagator - Analytical orbit propagation</li> <li>SGPPropagator - SGP4/SDP4 orbit propagation</li> </ul>"},{"location":"library_api/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that stores states in a specific reference frame (ECI or ECEF) and can automatically transform between frames when querying.</p> <p>OrbitTrajectory has the same API as Trajectory, plus frame awareness.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory","title":"OrbitTrajectory","text":"<pre><code>OrbitTrajectory(dimension: int, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: Union[AngleFormat, None] = None)\n</code></pre> <p>Orbital trajectory with frame and representation awareness.</p> <p>Stores a sequence of orbital states at specific epochs with support for interpolation, frame conversions, and representation transformations.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>State dimension (minimum 6 for position + velocity)</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the trajectory</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>dimension</code> <code>int</code> <p>State vector dimension</p> <code>frame</code> <code>OrbitFrame</code> <p>Reference frame</p> <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian representation</p> <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\n# Create trajectory in ECI Cartesian frame\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.angle_format","title":"angle_format  <code>property</code>","text":"<pre><code>angle_format: AngleFormat\n</code></pre> <p>Get trajectory angle format for Keplerian states.</p> <p>Returns:</p> Type Description <code>AngleFormat</code> <p>AngleFormat or None: Angle format for Keplerian representation, None for Cartesian</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Angle format: {traj.angle_format}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: OrbitFrame\n</code></pre> <p>Get trajectory reference frame.</p> <p>Returns:</p> Name Type Description <code>OrbitFrame</code> <code>OrbitFrame</code> <p>Reference frame of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Frame: {traj.frame}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.representation","title":"representation  <code>property</code>","text":"<pre><code>representation: OrbitRepresentation\n</code></pre> <p>Get trajectory state representation.</p> <p>Returns:</p> Name Type Description <code>OrbitRepresentation</code> <code>OrbitRepresentation</code> <p>State representation format of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Representation: {traj.representation}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.acceleration_at_idx","title":"acceleration_at_idx  <code>method descriptor</code>","text":"<pre><code>acceleration_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get the acceleration vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state point</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray | None: Acceleration vector if stored, None if acceleration storage is not enabled</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.enable_acceleration_storage(3)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\nacc = np.array([-9.0, 0.1, -0.05])\ntraj.add_with_acceleration(epoch, state, acc)\n\nretrieved_acc = traj.acceleration_at_idx(0)\nprint(retrieved_acc)  # [-9.0, 0.1, -0.05]\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>State vector with dimension matching trajectory's dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Standard 6D trajectory\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n\n# Extended 9D trajectory\ntraj_ext = bh.OrbitTrajectory(9, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nstate_ext = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0, 1.0, 2.0, 3.0])\ntraj_ext.add(epc, state_ext)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add_state_and_covariance","title":"add_state_and_covariance  <code>method descriptor</code>","text":"<pre><code>add_state_and_covariance(epoch: Epoch, state: ndarray, covariance: ndarray) -&gt; ndarray\n</code></pre> <p>Add a state vector and associated covariance matrix to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state and covariance</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector [x, y, z, vx, vy, vz] in meters and m/s</p> required <code>covariance</code> <code>ndarray</code> <p>6x6 covariance matrix in the same units</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the trajectory was not initialized with covariances enabled</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ncov = np.eye(6) * 1000.0\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    [epoch], [state], bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN,\n    covariances=np.array([cov])\n)\n\nnew_epoch = epoch + 60.0\nnew_state = np.array([bh.R_EARTH + 500e3, 100.0, 0.0, 0.0, 7.5e3, 0.0])\nnew_cov = np.eye(6) * 1100.0\ntraj.add_state_and_covariance(new_epoch, new_state, new_cov)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add_with_acceleration","title":"add_with_acceleration  <code>method descriptor</code>","text":"<pre><code>add_with_acceleration(epoch: Epoch, state: ndarray, acceleration: ndarray) -&gt; Any\n</code></pre> <p>Add a state with its corresponding acceleration to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch for the state</p> required <code>state</code> <code>ndarray</code> <p>State vector</p> required <code>acceleration</code> <code>ndarray</code> <p>Acceleration vector</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If acceleration storage is not enabled or dimension mismatch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.enable_acceleration_storage(3)\ntraj.set_interpolation_method(bh.InterpolationMethod.HERMITE_QUINTIC)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\nacc = np.array([-9.0, 0.0, 0.0])  # Gravity acceleration\n\ntraj.add_with_acceleration(epoch, state, acc)\ntraj.add_with_acceleration(epoch + 60.0, state, acc)\n\n# Now HermiteQuintic interpolation will use stored accelerations\nmid_state = traj.interpolate(epoch + 30.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.additional_dimension","title":"additional_dimension  <code>method descriptor</code>","text":"<pre><code>additional_dimension() -&gt; int\n</code></pre> <p>Get the number of additional state elements beyond the orbital state.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of additional states (dimension - 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(9, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Additional dimension: {traj.additional_dimension()}\")  # 3\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.clear()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.covariance","title":"covariance  <code>method descriptor</code>","text":"<pre><code>covariance(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get the covariance matrix at a specific epoch in the trajectory's native frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time at which to retrieve the covariance</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray | None: 6x6 covariance matrix, or None if no covariances are available</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ncov = np.eye(6) * 1000.0\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    [epoch], [state], bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN,\n    covariances=np.array([cov])\n)\n\nresult = traj.covariance(epoch)\nprint(result)  # 6x6 numpy array\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.covariance_eci","title":"covariance_eci  <code>method descriptor</code>","text":"<pre><code>covariance_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get the covariance matrix at a specific epoch in the ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time at which to retrieve the covariance</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray | None: 6x6 covariance matrix in ECI frame, or None if no covariances are available</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ncov = np.eye(6) * 1000.0\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    [epoch], [state], bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN,\n    covariances=np.array([cov])\n)\n\nresult = traj.covariance_eci(epoch)\nprint(result)  # 6x6 numpy array\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.covariance_gcrf","title":"covariance_gcrf  <code>method descriptor</code>","text":"<pre><code>covariance_gcrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get the covariance matrix at a specific epoch in the GCRF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time at which to retrieve the covariance</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray | None: 6x6 covariance matrix in GCRF frame, or None if no covariances are available</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ncov = np.eye(6) * 1000.0\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    [epoch], [state], bh.OrbitFrame.GCRF, bh.OrbitRepresentation.CARTESIAN,\n    covariances=np.array([cov])\n)\n\nresult = traj.covariance_gcrf(epoch)\nprint(result)  # 6x6 numpy array\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.covariance_rtn","title":"covariance_rtn  <code>method descriptor</code>","text":"<pre><code>covariance_rtn(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get the covariance matrix at a specific epoch in the RTN (Radial, Along-Track, Normal) frame.</p> <p>The RTN frame is defined as: - R (Radial): Along the position vector (away from Earth center) - T (Along-track): Completes right-handed system (N \u00d7 R) - N (Normal): Perpendicular to the orbital plane (along angular momentum)</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time at which to retrieve the covariance</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray | None: 6x6 covariance matrix in RTN frame, or None if no covariances are available</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ncov = np.eye(6) * 1000.0\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    [epoch], [state], bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN,\n    covariances=np.array([cov])\n)\n\nresult = traj.covariance_rtn(epoch)\nprint(result)  # 6x6 numpy array in RTN frame\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; OrbitTrajectory\n</code></pre> <p>Create a default empty orbital trajectory (ECI Cartesian).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory with ECI frame and Cartesian representation</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6 for orbital trajectories).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Dimension: {traj.dimension()}\")\nprint(f\"Orbital dimension: {traj.orbital_dimension()}\")\nprint(f\"Additional dimension: {traj.additional_dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.enable_acceleration_storage","title":"enable_acceleration_storage  <code>method descriptor</code>","text":"<pre><code>enable_acceleration_storage(dimension: int) -&gt; OrbitTrajectory\n</code></pre> <p>Enable storage of acceleration data for this trajectory.</p> <p>When enabled, accelerations can be stored alongside state data. This is useful for HermiteQuintic interpolation which uses acceleration information for smoother C2-continuous interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Dimension of acceleration vectors (typically 3 for 3D acceleration)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with acceleration storage enabled</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.enable_acceleration_storage(3)  # Enable 3D acceleration storage\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\nacc = np.array([-9.0, 0.0, 0.0])  # Gravity acceleration\ntraj.add_with_acceleration(epoch, state, acc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"End epoch: {traj.end_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get the epoch at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch to retrieve</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get epoch at index\nepoch_0 = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epochs","title":"epochs  <code>method descriptor</code>","text":"<pre><code>epochs() -&gt; list[Epoch]\n</code></pre> <p>Get all epochs as a list of Epoch objects.</p> <p>Returns:</p> Type Description <code>list[Epoch]</code> <p>list[Epoch]: List of Epoch objects for all trajectory points</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nepochs_list = traj.epochs()\nprint(f\"First epoch: {epochs_list[0]}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.from_orbital_data","title":"from_orbital_data  <code>builtin</code>","text":"<pre><code>from_orbital_data(epochs: list[Epoch], states: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: Union[AngleFormat, None] = None, covariances: Union[ndarray, None] = None) -&gt; OrbitTrajectory\n</code></pre> <p>Create orbital trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs for each state</p> required <code>states</code> <code>ndarray</code> <p>2D array of 6-element state vectors with shape (N, 6) where N is the number of epochs. Each row is one state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the states</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <code>covariances</code> <code>ndarray or None</code> <p>Optional 3D array of 6x6 covariance matrices with shape (N, 6, 6) where N is the number of epochs. Only supported for ECI and GCRF frames.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory instance populated with data</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepochs = [bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0)]\nstates = np.array([[bh.R_EARTH + 500e3, 0, 0, 0, 7500, 0]])\n# Covariance is optional\ncovs = np.array([np.eye(6) * 100.0])  # 100 m\u00b2 position variance\n\ntraj = bh.OrbitTrajectory.from_orbital_data(\n    epochs, states, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN, None,\n    covariances=covs\n)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_covariance_interpolation_method","title":"get_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_covariance_interpolation_method() -&gt; CovarianceInterpolationMethod\n</code></pre> <p>Get the current covariance interpolation method.</p> <p>Returns:</p> Name Type Description <code>CovarianceInterpolationMethod</code> <code>CovarianceInterpolationMethod</code> <p>Current covariance interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_covariance_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the trajectory numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: The trajectory ID, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_id(12345)\nprint(traj.get_id())  # 12345\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the trajectory name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: The trajectory name, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_name(\"My Trajectory\")\nprint(traj.get_name())  # \"My Trajectory\"\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the trajectory UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: The trajectory UUID as a string, or None if not set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_new_uuid()\nprint(traj.get_uuid())  # e.g., \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.has_accelerations","title":"has_accelerations  <code>method descriptor</code>","text":"<pre><code>has_accelerations() -&gt; bool\n</code></pre> <p>Check if this trajectory has acceleration storage enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if acceleration storage is enabled, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(traj.has_accelerations())  # False\n\ntraj.enable_acceleration_storage(3)\nprint(traj.has_accelerations())  # True\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.orbital_dimension","title":"orbital_dimension  <code>method descriptor</code>","text":"<pre><code>orbital_dimension() -&gt; int\n</code></pre> <p>Get the orbital state dimension (always 6).</p> <p>The orbital state consists of position (3) and velocity (3) components.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Always returns 6</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(9, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Orbital dimension: {traj.orbital_dimension()}\")  # 6\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_acceleration_at","title":"set_acceleration_at  <code>method descriptor</code>","text":"<pre><code>set_acceleration_at(index: int, acceleration: ndarray) -&gt; Any\n</code></pre> <p>Set the acceleration vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state point</p> required <code>acceleration</code> <code>ndarray</code> <p>Acceleration vector to set</p> required <p>Raises:</p> Type Description <code>IndexError</code> <p>If index is out of bounds</p> <code>ValueError</code> <p>If acceleration storage is not enabled or dimension mismatch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(6, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.enable_acceleration_storage(3)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epoch, state)  # Add state without acceleration\n\n# Set acceleration later\nacc = np.array([-9.0, 0.1, -0.05])\ntraj.set_acceleration_at(0, acc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_covariance_interpolation_method","title":"set_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; Any\n</code></pre> <p>Set the covariance interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>Covariance interpolation method to use</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_covariance_interpolation_method(bh.CovarianceInterpolationMethod.MATRIX_SQUARE_ROOT)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Start epoch: {traj.start_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state at specified epoch (in native frame/representation).</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in trajectory's native frame and representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate1 = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc1, state1)\n\n# Query state at epoch\nstate = traj.state(epc1)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get the state vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to retrieve</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get state at index\nstate_0 = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECEF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECEF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_eci = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_eci)\n\n# Get ECEF state (automatically converted from ECI)\nstate_ecef = traj.state_ecef(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECI Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECI Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory in any frame/representation\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 98.0, 15.0, 30.0, 45.0])\ntraj.add(epc, oe)\n\n# Get ECI Cartesian state (automatically converted from Keplerian)\nstate_eci = traj.state_eci(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_eme2000","title":"state_eme2000  <code>method descriptor</code>","text":"<pre><code>state_eme2000(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in EME2000 Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in EME2000 Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create GCRF trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.GCRF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_gcrf = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_gcrf)\n\n# Get EME2000 state (automatically converted from GCRF)\nstate_eme2000 = traj.state_eme2000(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_gcrf","title":"state_gcrf  <code>method descriptor</code>","text":"<pre><code>state_gcrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in GCRF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in GCRF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ITRF trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ITRF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_itrf = np.array([7000e3, 0.0, 0.0, 0.0, 0.0, 7.5e3])\ntraj.add(epc, state_itrf)\n\n# Get GCRF state (automatically converted from ITRF)\nstate_gcrf = traj.state_gcrf(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_itrf","title":"state_itrf  <code>method descriptor</code>","text":"<pre><code>state_itrf(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ITRF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ITRF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create GCRF trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.GCRF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_gcrf = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_gcrf)\n\n# Get ITRF state (automatically converted from GCRF)\nstate_itrf = traj.state_itrf(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_koe_mean","title":"state_koe_mean  <code>method descriptor</code>","text":"<pre><code>state_koe_mean(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get mean Keplerian elements at a given epoch.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>The epoch to get elements at.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Mean Keplerian elements [a, e, i, raan, argp, M]</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_cart = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_cart)\n\n# Get mean elements in degrees\nmean_elems = traj.state_koe_mean(epc, bh.AngleFormat.DEGREES)\nosc_elems = traj.state_koe_osc(epc, bh.AngleFormat.DEGREES)\nprint(f\"Mean semi-major axis: {mean_elems[0]/1000:.2f} km\")\nprint(f\"Osc semi-major axis: {osc_elems[0]/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_koe_osc","title":"state_koe_osc  <code>method descriptor</code>","text":"<pre><code>state_koe_osc(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get state as osculating Keplerian elements at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements [a, e, i, raan, argp, M]</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_cart = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_cart)\n\n# Get osculating elements in degrees\nelements = traj.state_koe_osc(epc, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements[0]/1000:.2f} km\")\nprint(f\"Inclination: {elements[2]:.2f} degrees\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array of states with shape (N, 6) where N is the number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nstates_array = traj.states()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states_koe_mean","title":"states_koe_mean  <code>method descriptor</code>","text":"<pre><code>states_koe_mean(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Get mean Keplerian elements at multiple epochs.</p> <p>Mean elements are orbit-averaged elements that remove short-period and long-period J2 perturbations using first-order Brouwer-Lyddane theory.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs to query.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of mean Keplerian elements [a, e, i, raan, argp, M].</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states_koe_osc","title":"states_koe_osc  <code>method descriptor</code>","text":"<pre><code>states_koe_osc(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Get osculating Keplerian elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs to query.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating Keplerian elements [a, e, i, raan, argp, M].</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 3600.0, state)\nprint(f\"Timespan: {traj.timespan()} seconds\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_ecef","title":"to_ecef  <code>method descriptor</code>","text":"<pre><code>to_ecef() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECEF (Earth-Centered Earth-Fixed) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECEF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_ecef = traj.to_ecef()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eci","title":"to_eci  <code>method descriptor</code>","text":"<pre><code>to_eci() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECI (Earth-Centered Inertial) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\ntraj.add(epc, state)\ntraj_eci = traj.to_eci()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eme2000","title":"to_eme2000  <code>method descriptor</code>","text":"<pre><code>to_eme2000() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to EME2000 (Earth Mean Equator and Equinox of J2000.0) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in EME2000 Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.GCRF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_eme2000 = traj.to_eme2000()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_gcrf","title":"to_gcrf  <code>method descriptor</code>","text":"<pre><code>to_gcrf() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to GCRF (Geocentric Celestial Reference Frame) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in GCRF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.EME2000, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_gcrf = traj.to_gcrf()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_itrf","title":"to_itrf  <code>method descriptor</code>","text":"<pre><code>to_itrf() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ITRF (International Terrestrial Reference Frame) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ITRF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.GCRF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_itrf = traj.to_itrf()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_keplerian","title":"to_keplerian  <code>method descriptor</code>","text":"<pre><code>to_keplerian(angle_format: AngleFormat) -&gt; OrbitTrajectory\n</code></pre> <p>Convert to Keplerian representation in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for the result (Radians or Degrees)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Keplerian representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_kep = traj.to_keplerian(bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert trajectory to matrix representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array with shape (6, N) where N is number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nmatrix = traj.to_matrix()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_covariance_interpolation_method","title":"with_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set covariance interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>Covariance interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated covariance interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_covariance_interpolation_method(bh.CovarianceInterpolationMethod.TWO_WASSERSTEIN)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set the trajectory numeric ID and return self (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to the trajectory</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with ID set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_id(12345)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; OrbitTrajectory\n</code></pre> <p>Set the trajectory name and return self (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to the trajectory</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with name set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_name(\"My Trajectory\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; OrbitTrajectory\n</code></pre> <p>Generate a new UUID and set it on the trajectory (builder pattern).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with new UUID set</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_new_uuid()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>Trajectory - Dynamic-dimension trajectory</li> <li>OrbitFrame - Frame specifications</li> </ul>"},{"location":"library_api/trajectories/trajectory.html","title":"Trajectory","text":"<p>Dynamic-dimension trajectory container for N-dimensional state data.</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory","title":"Trajectory","text":"<pre><code>Trajectory(dimension: int = 6)\n</code></pre> <p>Dynamic-dimension trajectory container.</p> <p>Stores a sequence of N-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is determined at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>dimension</code> <code>int</code> <p>Trajectory dimension (default 6, must be greater than 0)</p> <code>6</code> <p>Attributes:</p> Name Type Description <code>dimension</code> <code>int</code> <p>State vector dimension</p> <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.Trajectory(6)  # 6D trajectory\ntraj = bh.Trajectory(3)  # 3D trajectory\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>N-element state vector where N is the trajectory dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.add_with_covariance","title":"add_with_covariance  <code>method descriptor</code>","text":"<pre><code>add_with_covariance(epoch: Epoch, state: ndarray, covariance: ndarray) -&gt; Any\n</code></pre> <p>Add a state with its corresponding covariance matrix.</p> <p>This automatically enables covariance storage if not already enabled.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time epoch</p> required <code>state</code> <code>ndarray</code> <p>State vector (must match trajectory dimension)</p> required <code>covariance</code> <code>ndarray</code> <p>Covariance matrix (must be square, dimension x dimension)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ncov = np.eye(6) * 100.0  # 100 m\u00b2/m\u00b2/s\u00b2 diagonal covariance\ntraj.add_with_covariance(epc, state, cov)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.covariance_at","title":"covariance_at  <code>method descriptor</code>","text":"<pre><code>covariance_at(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get covariance matrix at a specific epoch (with interpolation).</p> <p>Returns None if covariance storage is not enabled or epoch is out of range.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time epoch to query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray or None: Covariance matrix at the requested epoch (interpolated if necessary)</p> Example <pre><code>import brahe as bh\n\n# ... create trajectory with covariances ...\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 5, 0.0, 0.0, bh.TimeSystem.UTC)\ncov = traj.covariance_at(epc)\nif cov is not None:\n    print(f\"Position variance: {cov[0,0]} m\u00b2\")\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get the trajectory dimension (method form).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.enable_covariance_storage","title":"enable_covariance_storage  <code>method descriptor</code>","text":"<pre><code>enable_covariance_storage() -&gt; Any\n</code></pre> <p>Enable covariance storage for this trajectory.</p> <p>Initializes the covariance vector with zero matrices for all existing states. After calling this, covariances can be added using <code>add_with_covariance()</code> or <code>set_covariance_at()</code>.</p> Example <pre><code>import brahe as bh\ntraj = bh.DTrajectory(6)\ntraj.enable_covariance_storage()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Any\n</code></pre> <p>Get end epoch of trajectory</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; Trajectory\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of states with shape (num_epochs, dimension) where each row is a state vector</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>Trajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.get_covariance_interpolation_method","title":"get_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_covariance_interpolation_method() -&gt; CovarianceInterpolationMethod\n</code></pre> <p>Get current covariance interpolation method.</p> <p>Returns:</p> Name Type Description <code>CovarianceInterpolationMethod</code> <code>CovarianceInterpolationMethod</code> <p>Current covariance interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_covariance_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.set_covariance_at","title":"set_covariance_at  <code>method descriptor</code>","text":"<pre><code>set_covariance_at(index: int, covariance: ndarray) -&gt; Any\n</code></pre> <p>Set covariance matrix at a specific index.</p> <p>Enables covariance storage if not already enabled.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index in the trajectory</p> required <code>covariance</code> <code>ndarray</code> <p>Covariance matrix (must be square, dimension x dimension)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\n# ... add states ...\ncov = np.eye(6) * 100.0\ntraj.set_covariance_at(0, cov)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.set_covariance_interpolation_method","title":"set_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; Any\n</code></pre> <p>Set covariance interpolation method.</p> <p>Covariance matrices require special interpolation methods to preserve positive semi-definiteness.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>Covariance interpolation method to use</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj.set_covariance_interpolation_method(bh.CovarianceInterpolationMethod.MATRIX_SQUARE_ROOT)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = bh.InterpolationMethod.LINEAR\ntraj.set_interpolation_method(method)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Any\n</code></pre> <p>Get start epoch of trajectory</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; Any\n</code></pre> <p>Get time span of trajectory in seconds</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.with_covariance_interpolation_method","title":"with_covariance_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_covariance_interpolation_method(method: CovarianceInterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set covariance interpolation method using builder pattern.</p> <p>Covariance matrices require special interpolation methods to preserve positive semi-definiteness. This method allows setting the interpolation method used when calling <code>covariance_at()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>CovarianceInterpolationMethod</code> <p>Covariance interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated covariance interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_covariance_interpolation_method(bh.CovarianceInterpolationMethod.TWO_WASSERSTEIN)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#brahe.Trajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/trajectory.html#see-also","title":"See Also","text":"<ul> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> <li>InterpolationMethod</li> </ul>"},{"location":"library_api/utils/index.html","title":"Utilities API Reference","text":"<p>This section provides detailed API documentation for all utility functions in Brahe.</p>"},{"location":"library_api/utils/index.html#overview","title":"Overview","text":"<p>The utilities module provides support functions for:</p> <ul> <li>Caching: Cache directory management for downloaded data</li> <li>Multithreading: Thread pool configuration for parallel computation</li> <li>String Formatting: Human-readable output formatting</li> </ul>"},{"location":"library_api/utils/index.html#quick-links","title":"Quick Links","text":"Module Description Caching Functions for managing cache directories Threading Functions for configuring the thread pool Formatting Functions for formatting values as strings"},{"location":"library_api/utils/index.html#see-also","title":"See Also","text":"<ul> <li>Utilities Learn Section - Conceptual guides and examples</li> </ul>"},{"location":"library_api/utils/caching.html","title":"Caching Functions","text":"<p>Functions for managing cache directories where Brahe stores downloaded data.</p>"},{"location":"library_api/utils/caching.html#main-cache-directory","title":"Main Cache Directory","text":""},{"location":"library_api/utils/caching.html#brahe.get_brahe_cache_dir","title":"get_brahe_cache_dir  <code>builtin</code>","text":"<pre><code>get_brahe_cache_dir() -&gt; str\n</code></pre> <p>Get the brahe cache directory path.</p> <p>The cache directory is determined by the <code>BRAHE_CACHE</code> environment variable. If not set, defaults to <code>~/.cache/brahe</code>.</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\ncache_dir = bh.get_brahe_cache_dir()\nprint(f\"Cache directory: {cache_dir}\")\n\n# You can also override with environment variable\nimport os\nos.environ['BRAHE_CACHE'] = '/custom/cache/path'\ncache_dir = bh.get_brahe_cache_dir()\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#brahe.get_brahe_cache_dir_with_subdir","title":"get_brahe_cache_dir_with_subdir  <code>builtin</code>","text":"<pre><code>get_brahe_cache_dir_with_subdir(subdirectory: Union[str, None]) -&gt; str\n</code></pre> <p>Get the brahe cache directory path with an optional subdirectory.</p> <p>The cache directory is determined by the <code>BRAHE_CACHE</code> environment variable. If not set, defaults to <code>~/.cache/brahe</code>. If a subdirectory is provided, it is appended to the cache path.</p> <p>The directory is created if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>subdirectory</code> <code>str or None</code> <p>Optional subdirectory name to append to cache path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the cache directory (with subdirectory if provided).</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\n# Get main cache directory\ncache_dir = bh.get_brahe_cache_dir_with_subdir(None)\nprint(f\"Cache: {cache_dir}\")\n\n# Get custom subdirectory\ncustom_cache = bh.get_brahe_cache_dir_with_subdir(\"my_data\")\nprint(f\"Custom cache: {custom_cache}\")\n</code></pre> Note <p>The directory (and subdirectory) will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#specialized-cache-directories","title":"Specialized Cache Directories","text":""},{"location":"library_api/utils/caching.html#brahe.get_eop_cache_dir","title":"get_eop_cache_dir  <code>builtin</code>","text":"<pre><code>get_eop_cache_dir() -&gt; str\n</code></pre> <p>Get the EOP cache directory path.</p> <p>Returns the path to the EOP (Earth Orientation Parameters) cache subdirectory. Defaults to <code>~/.cache/brahe/eop</code> (or <code>$BRAHE_CACHE/eop</code> if environment variable is set).</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the EOP cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\neop_cache = bh.get_eop_cache_dir()\nprint(f\"EOP cache: {eop_cache}\")\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/caching.html#brahe.get_celestrak_cache_dir","title":"get_celestrak_cache_dir  <code>builtin</code>","text":"<pre><code>get_celestrak_cache_dir() -&gt; str\n</code></pre> <p>Get the CelesTrak cache directory path.</p> <p>Returns the path to the CelesTrak cache subdirectory used for storing downloaded TLE data. Defaults to <code>~/.cache/brahe/celestrak</code> (or <code>$BRAHE_CACHE/celestrak</code> if environment variable is set).</p> <p>The directory is created if it doesn't exist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The full path to the CelesTrak cache directory.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the cache directory cannot be created or accessed.</p> Example <pre><code>import brahe as bh\n\ncelestrak_cache = bh.get_celestrak_cache_dir()\nprint(f\"CelesTrak cache: {celestrak_cache}\")\n</code></pre> Note <p>The directory will be created on first access if it doesn't exist.</p>"},{"location":"library_api/utils/formatting.html","title":"String Formatting Functions","text":"<p>Functions for formatting numerical values into human-readable strings.</p>"},{"location":"library_api/utils/formatting.html#time-formatting","title":"Time Formatting","text":""},{"location":"library_api/utils/formatting.html#brahe.format_time_string","title":"format_time_string  <code>builtin</code>","text":"<pre><code>format_time_string(seconds: float, short: bool = False) -&gt; str\n</code></pre> <p>Format a time duration in seconds to a human-readable string.</p> <p>Converts a duration in seconds to either a long format (e.g., \"6 minutes and 2.00 seconds\") or a short format (e.g., \"6m 2s\").</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Time duration in seconds</p> required <code>short</code> <code>bool</code> <p>If True, use short format; otherwise use long format (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable string representation of the time duration</p> Example <pre><code>import brahe as bh\n\n# Long format (default)\nprint(bh.format_time_string(90.0))\n# Output: \"1 minutes and 30.00 seconds\"\n\nprint(bh.format_time_string(3665.0))\n# Output: \"1 hours, 1 minutes, and 5.00 seconds\"\n\n# Short format\nprint(bh.format_time_string(90.0, short=True))\n# Output: \"1m 30s\"\n\nprint(bh.format_time_string(3665.0, short=True))\n# Output: \"1h 1m 5s\"\n</code></pre>"},{"location":"library_api/utils/threading.html","title":"Threading Functions","text":"<p>Functions for configuring the global thread pool used for parallel computation.</p>"},{"location":"library_api/utils/threading.html#thread-pool-configuration","title":"Thread Pool Configuration","text":""},{"location":"library_api/utils/threading.html#brahe.set_num_threads","title":"set_num_threads  <code>builtin</code>","text":"<pre><code>set_num_threads(n: int) -&gt; Any\n</code></pre> <p>Set the number of threads for parallel computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations such as access computations. This function can be called multiple times to dynamically change the thread pool configuration - each call will reinitialize the pool with the new thread count.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If n &lt; 1.</p> <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Set to 4 threads initially\nbh.set_num_threads(4)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 4\n\n# Reinitialize with 8 threads - no error!\nbh.set_num_threads(8)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 8\n\n# All parallel operations (e.g., location_accesses) will now use\n# 8 threads unless overridden with AccessSearchConfig.num_threads\n</code></pre> Note <p>Unlike earlier versions, this function no longer raises an error if the thread pool has already been initialized. You can safely call it at any time to reconfigure the thread pool.</p>"},{"location":"library_api/utils/threading.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads() -&gt; Any\n</code></pre> <p>Set the thread pool to use all available CPU cores.</p> <p>This is a convenience function that sets the number of threads to 100% of available CPU cores. Can be called multiple times to reinitialize the thread pool dynamically.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Use all available CPU cores\nbh.set_max_threads()\nprint(f\"Using all {bh.get_max_threads()} cores\")\n\n# Switch to 2 threads\nbh.set_num_threads(2)\n\n# Switch back to max - no error!\nbh.set_max_threads()\nprint(f\"Back to {bh.get_max_threads()} cores\")\n</code></pre> Note <p>This function can be called at any time, even after the thread pool has been initialized with a different configuration.</p>"},{"location":"library_api/utils/threading.html#brahe.set_ludicrous_speed","title":"set_ludicrous_speed  <code>builtin</code>","text":"<pre><code>set_ludicrous_speed() -&gt; Any\n</code></pre> <p>LUDICROUS SPEED! GO!</p> <p>Set the thread pool to use all available CPU cores (alias for <code>set_max_threads</code>).</p> <p>This is a fun alias for <code>set_max_threads()</code> that sets the number of threads to 100% of available CPU cores for maximum performance. Can be called multiple times to dynamically reinitialize the thread pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# MAXIMUM POWER! Use all available CPU cores\nbh.set_ludicrous_speed()\nprint(f\"Going ludicrous with {bh.get_max_threads()} threads!\")\n\n# Throttle down for testing\nbh.set_num_threads(1)\n\n# ENGAGE LUDICROUS SPEED again - no error!\nbh.set_ludicrous_speed()\n</code></pre> Note <p>This function can be called at any time to reconfigure the thread pool to use maximum available cores, regardless of previous configuration.</p>"},{"location":"library_api/utils/threading.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores, initialized on first call)\nthreads = bh.get_max_threads()\nprint(f\"Default: {threads} threads\")\n\n# Set to specific value and verify\nbh.set_num_threads(4)\nassert bh.get_max_threads() == 4\n\n# Reconfigure and verify again\nbh.set_num_threads(8)\nassert bh.get_max_threads() == 8\n\n# Switch to max cores\nbh.set_max_threads()\nprint(f\"Max cores: {bh.get_max_threads()}\")\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings (90% of cores) if it hasn't been configured yet. After initialization, you can still reconfigure it using set_num_threads() or set_max_threads().</p>"}]}