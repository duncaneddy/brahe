{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Brahe","text":"<p> Brahe - Practical Astrodynamics </p> <p> </p> <p>Pure-Python Brahe Deprecation Notice</p> <p>The older pure-Python implementaiton of brahe is currently being deprecated in favor of an improved Rust-based implementation. There will be breaking changes during this period that include breaking changes. You can read more about this change in the deprecation notice.</p>"},{"location":"index.html#brahe","title":"Brahe","text":"<p>All software is wrong, but some is useful.</p> <p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, quick-to-deploy, and easy to build on. The north-star of the development is enabling users to solve meaningful problems and answer questions quickly and correctly.</p> <p>The Brahe permissively licensed and distributed under an MIT License to encourage adoption and enable the broader community to build on the work.</p> <p>If you do find it useful, please consider starring the repository on GitHub to help increase its visibility. If you're using Brahe for school, research, a commercial endeavour, or flying a mission. I'd love to know about it! You can find my contact information on my personal website,  or open an issue on the GitHub repository.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#python","title":"Python","text":"<p>To install the latest release of brahe for Python, simply run:</p> <pre><code>pip install brahe\n</code></pre> <p>You can then import the package in your Python code with:</p> <pre><code>import brahe as bh\n</code></pre> <p>And do something fun like calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>import brahe as bh\n\n# Define the semi-major axis of a low Earth orbit (in meters)\na = bh.R_EARTH + 400e3  # 400 km altitude\n\n# Calculate the orbital period using Kepler's third law\nT = bh.orbital_period(a)\n\nprint(f\"Orbital Period: {T / 60:.2f} minutes\")\n</code></pre> <p>Here are some common operations to get you started:</p> <p>Working with Time: <pre><code>import brahe as bh\n\n# Create an epoch from a specific date and time\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, bh.TimeSystem.UTC)\n\n# Convert between time systems\nmjd_utc = epc.mjd_as_time_system(bh.TimeSystem.UTC)\nmjd_tai = epc.mjd_as_time_system(bh.TimeSystem.TAI)\n\n# Time arithmetic\nfuture_epc = epc + 3600  # Add 3600 seconds (1 hour)\ntime_diff = future_epc - epc  # Difference in seconds\n</code></pre></p> <p>Propagating an Orbit: <pre><code>import brahe as bh\nimport numpy as np\n\n# Create an SGP4 propagator from Two-Line Element (TLE) data\nline1 = \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Propagate to a specific epoch\nepc = bh.Epoch(2024, 6, 1, 0, 0, 0.0, bh.TimeSystem.UTC)\nstate = prop.propagate(epc)  # Returns [x, y, z, vx, vy, vz] in meters and m/s\n\nprint(f\"Position: {state[:3] / 1000} km\")\nprint(f\"Velocity: {state[3:] / 1000} km/s\")\n</code></pre></p> <p>Coordinate Transformations: <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates to ECEF\nlat = 40.0  # degrees North\nlon = -105.0  # degrees East\nalt = 1000.0  # meters above ellipsoid\ngeod = np.array([lat, lon, alt])  # [latitude, longitude, altitude]\necef = bh.position_geodetic_to_ecef(geod, bh.AngleFormat.DEGREES)\n\n# Convert ECEF to ECI at a specific epoch\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, bh.TimeSystem.UTC)\neci = bh.position_ecef_to_eci(epc, ecef)\n</code></pre></p>"},{"location":"index.html#rust","title":"Rust","text":"<p>To use brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre> <p>Here are some common operations to get you started:</p> <p>Working with Time: <pre><code>use brahe::time::Epoch;\nuse brahe::time::TimeSystem;\n\n// Create an epoch from a specific date and time\nlet epc = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0, TimeSystem::UTC);\n\n// Convert between time systems\nlet mjd_utc = epc.to_mjd(TimeSystem::UTC);\nlet mjd_tai = epc.to_mjd(TimeSystem::TAI);\n\n// Time arithmetic\nlet future_epc = epc + 3600.0;  // Add 3600 seconds (1 hour)\nlet time_diff = future_epc - epc;  // Difference in seconds\n</code></pre></p> <p>Propagating an Orbit: <pre><code>use brahe::orbits::{TLE, SGPPropagator};\nuse brahe::time::Epoch;\n\n// Create a Two-Line Element (TLE) for a satellite\nlet tle = TLE::from_lines(\n    \"ISS (ZARYA)\",\n    \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\",\n    \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n).unwrap();\n\n// Create an SGP4 propagator\nlet prop = SGPPropagator::from_tle(&amp;tle);\n\n// Propagate to a specific epoch\nlet epc = Epoch::from_datetime(2024, 6, 1, 0, 0, 0.0, 0, TimeSystem::UTC);\nlet state = prop.propagate(&amp;epc);  // Returns [x, y, z, vx, vy, vz] in meters and m/s\n\nprintln!(\"Position: {:?} km\", [state[0]/1000.0, state[1]/1000.0, state[2]/1000.0]);\nprintln!(\"Velocity: {:?} km/s\", [state[3]/1000.0, state[4]/1000.0, state[5]/1000.0]);\n</code></pre></p> <p>Coordinate Transformations: <pre><code>use brahe::coordinates::position_geodetic_to_ecef;\nuse brahe::frames::position_ecef_to_eci;\nuse brahe::time::Epoch;\nuse brahe::time::TimeSystem;\nuse brahe::constants::AngleFormat;\nuse nalgebra::Vector3;\n\n// Convert geodetic coordinates (lat, lon, alt) to ECEF\nlet geod = Vector3::new(\n    40.0_f64.to_radians(),   // latitude in radians\n    -105.0_f64.to_radians(), // longitude in radians\n    1000.0                   // altitude in meters\n);\nlet ecef = position_geodetic_to_ecef(geod, AngleFormat::Radians);\n\n// Convert ECEF to ECI at a specific epoch\nlet epc = Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0, TimeSystem::UTC);\nlet eci = position_ecef_to_eci(epc, ecef);\n</code></pre></p>"},{"location":"index.html#going-further","title":"Going Further","text":"<p>If you want to learn more about how to use the package the documentation is structured in the following way:</p> <ul> <li>Learn: Provides short-form documentation of major concepts of the package.</li> <li>Examples: Provides longer-form examples of how-to examples of accomplish common tasks.</li> <li>Library API: Provides detailed reference documentation of the Python API.</li> <li>Rust API: Provides detailed reference documentation of the Rust API.</li> </ul>"},{"location":"index.html#support-and-acknowledgement","title":"Support and Acknowledgement","text":"<p>Brahe is currently being developed primarily for my own enjoyment and because I find having these tools helpful in professional and hobby work. I plan to continue developing it for the time being regardless of greater adoption as time permitting.</p> <p>That being said, it's incredibly encouraging and useful to know if the software is being adopted or found useful in wider practice.</p>"},{"location":"contributing.html","title":"Contributing","text":""},{"location":"contributing.html#development-workflow","title":"Development Workflow","text":"<p>For all development we recommend using uv to manage your environment. The guidelines for contributing, developing, and extending brahe assume you are using uv.</p>"},{"location":"contributing.html#setting-up-your-environment","title":"Setting up your environment","text":"<p>If you need to setup the development environment, including installing the necessary development dependencies.</p> <p>First, you need to install Rust from rustup.rs.</p> <p>Then you can install the nightly toolchain with:</p> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <p>After this you can now setup your python environment with:</p> <pre><code>uv sync --dev\n</code></pre> <p>Finally, you can install the pre-commit hooks with:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"contributing.html#testing","title":"Testing","text":"<p>The package includes Rust tests, Python tests, and documentation example tests.</p> <p>Run all tests: <pre><code>make test\n</code></pre></p> <p>Individual test suites: <pre><code>make test-rust          # Rust tests only\nmake test-python        # Python tests only\nmake test-examples      # Documentation examples (warn on parity issues)\n</code></pre></p> <p>Pre-ship validation (runs all tests, formatters, linters, and doc builds): <pre><code>make ship-tests\n</code></pre></p>"},{"location":"contributing.html#development-workflow-implementing-a-new-feature","title":"Development Workflow: Implementing a New Feature","text":"<p>When adding new functionality to Brahe, follow this sequence:</p> <p>1. Rust Implementation - Implement functionality in the appropriate module under <code>src/</code> - Use SI base units (meters, radians, seconds) in all public APIs - Follow existing patterns and naming conventions</p> <p>2. Rust Tests - Write comprehensive unit tests in the same file (in <code>#[cfg(test)] mod tests</code>) - Test edge cases and typical use cases - Run: <code>cargo test</code> - Ensure all tests pass before proceeding</p> <p>3. Python Bindings - Create 1:1 Python bindings in <code>src/pymodule/</code> - Use identical function names and parameter names as Rust - Add complete Google-style docstrings with Args, Returns, Examples - Export new classes in <code>src/pymodule/mod.rs</code> - Export in Python package (<code>brahe/*.py</code> files) - Reinstall: <code>uv pip install -e .</code></p> <p>4. Python Tests - Write Python tests that mirror Rust tests in <code>tests/</code> - Follow the same test structure and assertions - Run: <code>uv run pytest tests/ -v</code></p> <p>5. Documentation Examples - Create standalone example files in <code>examples/&lt;module&gt;/</code> - Create both Python and Rust versions (see templates below) - Test: <code>make test-examples</code></p> <p>6. Documentation - Update or create documentation in <code>docs/</code> - Reference examples using snippet includes (see template below) - Build: <code>make build-docs</code> - Preview: <code>make serve-docs</code></p> <p>7. Quality Checks <pre><code>make format      # Auto-format code\nmake lint        # Check for issues\nmake ship-tests  # Full validation\n</code></pre></p>"},{"location":"contributing.html#rust-standards-and-guidelines","title":"Rust Standards and Guidelines","text":""},{"location":"contributing.html#rust-testing-conventions","title":"Rust Testing Conventions","text":"<p>New functions implemented in rust are expected to have unit tests and documentation tests. Unit tests should cover all edge cases and typical use cases for the function. Documentation tests should provide examples of how to use the function.</p> <p>Unit tests should be placed in the same file as the function they are testing, in a module named <code>tests</code>. The names of tests should follow the general convention of <code>test_&lt;struct&gt;_&lt;trait&gt;_&lt;method&gt;_&lt;case&gt;</code> or <code>test_&lt;function&gt;_&lt;case&gt;</code>.</p>"},{"location":"contributing.html#rust-docstring-template","title":"Rust Docstring Template","text":"<p>New functions implemented in rust are expected to use the following docstring to standardize information on functions to enable users to more easily navigate and learn the library.</p> <pre><code>{{ Function Description }}\n\n## Arguments\n\n* `argument_name`: {{ Arugment description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Returns\n\n* `value_name`: {{ Value description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Examples\n\\`\\`\\`\n{{ Implement shor function in language }}\n\\`\\`\\`\n\n## References:\n1. {{ author, *title/journal*, pp. page_number, eq. equation_number, year}}\n2. O. Montenbruck, and E. Gill, *Satellite Orbits: Models, Methods and Applications*, pp. 24, eq. 2.43 &amp; 2.44, 2012.\n</code></pre>"},{"location":"contributing.html#python-standards-and-guidelines","title":"Python Standards and Guidelines","text":""},{"location":"contributing.html#python-testing-conventions","title":"Python Testing Conventions","text":"<p>Python tests should be placed in the <code>tests</code> directory. The test structure and names should mirror the structure of the <code>brahe</code> package. For example, tests for <code>brahe.orbits.keplerian</code> should be placed in <code>tests/orbits/test_keplerian.py</code>.</p> <p>All Python tests should be exact mirrors of the Rust tests, ensuring that both implementations are equivalent and consistent. There are a few exceptions to this rule, such as tests that check for Python-specific functionality or behavior, or capabilities that are not possible to reproduce in Python due to language limitations.</p>"},{"location":"contributing.html#documentation-examples","title":"Documentation Examples","text":"<p>Documentation examples are standalone executable files that demonstrate library functionality. Every example must exist in both Python and Rust versions to ensure API parity.</p>"},{"location":"contributing.html#example-file-structure","title":"Example File Structure","text":"<p>Examples are organized by module in <code>examples/</code>: <pre><code>examples/\n\u251c\u2500\u2500 time/           # Time system examples\n\u251c\u2500\u2500 orbits/         # Orbital mechanics examples\n\u251c\u2500\u2500 coordinates/    # Coordinate transformation examples\n\u251c\u2500\u2500 frames/         # Reference frame examples\n\u251c\u2500\u2500 attitude/       # Attitude representation examples\n\u251c\u2500\u2500 eop/            # Earth orientation parameter examples\n\u251c\u2500\u2500 trajectories/   # Trajectory examples\n\u2514\u2500\u2500 workflows/      # Complete workflow examples\n</code></pre></p>"},{"location":"contributing.html#naming-convention","title":"Naming Convention","text":"<p>Example files should follow this pattern: <pre><code>&lt;module&gt;_&lt;functionality&gt;_&lt;description&gt;.{py,rs}\n</code></pre></p> <p>Examples: - <code>time_epoch_creation.py</code> / <code>time_epoch_creation.rs</code> - <code>orbits_keplerian_conversion.py</code> / <code>orbits_keplerian_conversion.rs</code> - <code>coordinates_geodetic_transform.py</code> / <code>coordinates_geodetic_transform.rs</code></p>"},{"location":"contributing.html#python-example-template","title":"Python Example Template","text":"<p>See <code>examples/TEMPLATE.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"pytest\"]\n# ///\n\"\"\"\nBrief description of what this example demonstrates.\n\"\"\"\nimport brahe as bh\nimport pytest\n\nif __name__ == '__main__':\n    # Setup: Define any input parameters\n    value = 1.0\n\n    # Action: Demonstrate the functionality\n    result = value * 2.0  # Replace with actual brahe function call\n\n    # Validation: Assert the result is correct\n    expected = 2.0\n    assert result == pytest.approx(expected, abs=1e-10)\n\n    print(\"\u2713 Example validated successfully!\")\n</code></pre> <p>Note: The <code># /// script</code> header makes this a uv script, allowing it to be run standalone with <code>uv run example.py</code>.</p>"},{"location":"contributing.html#rust-example-template","title":"Rust Example Template","text":"<p>See <code>examples/TEMPLATE.rs</code>:</p> <pre><code>//! Brief description of what this example demonstrates.\n\nuse approx::assert_abs_diff_eq;\nuse brahe::time::{Epoch, TimeSystem};\n\nfn main() {\n    // Setup: Define any input parameters\n    let value = 1.0;\n\n    // Action: Demonstrate the functionality\n    let result = value * 2.0; // Replace with actual brahe function call\n\n    // Validation: Assert the result is correct\n    let expected = 2.0;\n    assert_abs_diff_eq!(result, expected, epsilon = 1e-10);\n\n    println!(\"\u2713 Example validated successfully!\");\n}\n</code></pre>"},{"location":"contributing.html#testing-examples","title":"Testing Examples","text":"<p>Test examples locally: <pre><code># Test all examples (warns on parity issues)\nmake test-examples\n\n# Test in strict mode (fails on parity issues)\nmake test-examples-strict\n</code></pre></p> <p>The build system will: 1. Execute all <code>.rs</code> files via <code>rust-script</code> 2. Execute all <code>.py</code> files via <code>uv run python</code> 3. Verify every <code>.rs</code> has a matching <code>.py</code> (and vice versa) 4. Report pass/fail for each example</p>"},{"location":"contributing.html#including-examples-in-documentation","title":"Including Examples in Documentation","text":"<p>Use the <code>pymdownx.snippets</code> directive to include examples in markdown files:</p> <pre><code>## Example: Creating Epochs\n\n=== \"Python\"\n\n    ``` python\n    ```\n\n=== \"Rust\"\n\n    ``` rust\n    ```\n</code></pre> <p>This will: - Create tabbed interface with Python shown first - Include the actual file contents (always in sync) - Automatically update when examples change</p>"},{"location":"contributing.html#documentation-plots","title":"Documentation Plots","text":"<p>Interactive plots are generated from Python scripts in <code>plots/</code> and embedded in documentation.</p>"},{"location":"contributing.html#plot-naming-convention","title":"Plot Naming Convention","text":"<p>Plot files should follow this pattern: <pre><code>fig_&lt;description&gt;.py\n</code></pre></p> <p>Examples: - <code>fig_time_system_offsets.py</code> - <code>fig_orbital_period.py</code> - <code>fig_anomaly_conversions.py</code></p>"},{"location":"contributing.html#plot-template","title":"Plot Template","text":"<p>See <code>plots/TEMPLATE_plot.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# ///\n\"\"\"\nBrief description of what this plot visualizes.\n\"\"\"\nimport os\nimport pathlib\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport brahe as bh\nimport numpy as np\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\")\nOUTFILE = f\"{OUTDIR}/{SCRIPT_NAME}.html\"\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Replace with actual data\n\n# Create figure\nfig = go.Figure()\nfig.update_layout(\n    title=\"Plot Title\",\n    xaxis_title=\"X Axis Label\",\n    yaxis_title=\"Y Axis Label\",\n    paper_bgcolor='rgba(0,0,0,0)',  # Transparent for dark mode\n    plot_bgcolor='rgba(0,0,0,0)'\n)\n\n# Add traces\nfig.add_trace(go.Scatter(x=x, y=y, name=\"Data\", mode='lines'))\n\n# Write HTML (partial, not full page)\npio.write_html(\n    fig,\n    file=OUTFILE,\n    include_plotlyjs='cdn',\n    full_html=False,\n    auto_play=False\n)\n\nprint(f\"\u2713 Generated {OUTFILE}\")\n</code></pre> <p>Note: The <code># /// script</code> header allows standalone execution with <code>uv run fig_plot.py</code>.</p>"},{"location":"contributing.html#generating-plots","title":"Generating Plots","text":"<p>Generate all plots: <pre><code>make figures\n</code></pre></p> <p>Plots are written to <code>docs/figures/</code> as partial HTML files for embedding.</p>"},{"location":"contributing.html#including-plots-in-documentation","title":"Including Plots in Documentation","text":"<pre><code>## Time System Offsets\n\nThe following plot shows time system offsets from UTC:\n\n\n??? \"Plot Source\"\n\n    ``` python title=\"fig_time_system_offsets.py\"\n    ```\n</code></pre> <p>This will: - Embed the interactive Plotly plot - Add a collapsible section showing the source code</p>"},{"location":"installation.html","title":"Installation","text":""},{"location":"installation.html#rust","title":"Rust","text":""},{"location":"installation.html#python","title":"Python","text":""},{"location":"about/index.html","title":"About","text":"<p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, high-performance, and quick-to-deploy. The north-star of the development is enabling users to solve meaningful problems and answer questions quickly, easily, and correctly.</p> <p>The key features of the library are:</p> <ul> <li>Intuitive API: API designed to be easily composable, making it easy to solve complex problems correctly by building on core functionality.</li> <li>Easy-to-Learn: Designed to be easy to use and learn. The objective is to provide clear documentation and visibility into what the software is doing so that users don't need to spend time reverse engineering internal routines and more time solving their own problems.</li> <li>High-Performance: Brahe provides a Python 3.6+ wrapper that is auto-generated from a core Rust library. This provides fast core implementation, while allowing users to take advantage of Python's rich scientific ecosystem if they so choose.</li> <li>Answer Questions Quickly: Brahe is designed to make it easy to code up solutions to meaningful problems. High-fieldity, high-performance APIs are not the end-objective, but helping users solve their problems.</li> </ul> <p>The library specifically focuses on satellite astrodynamics and space mission analysis. While the underlying concepts have been studied and known since Kepler wrote down his three laws, there are few modern software libraries that make these concepts easily accessible. While extremely well tested, other astrodynamics and mission analysis software can have an extremely steep learning curve, making it difficult to quickly run simple analysis that is known to be correct. Because of this, students, researchers, and engineers frequently end up reimplementing common astrodynamics and mission analysis tools with unfortunately frequent regularity. While  reimplementation of common code can be a good learning mechanisms, in most cases it is both error-prone and costs time better spent on other endeavours. This project seeks to providing an easy-to-use, well-tested library, to enable everyone to more easily, and quickly perform astrodynamics and space mission analysis without sacrificing performance or correctness. The software built in Rust for performance with bindings to Python for ease of use.</p> <p>The implementation approach is opinionated, the objective is to provide an easy-to-use and accurate astrodynamics library to enable users to quickly and correctly solve most common problem types. it is not practical to try to implement every aerodynamics model and function utilized in practice or historically. Since Brahe is open source, if a specific function is not present, or a different implementation is required, users can modify the code to address their specific use case. This means that Brahe, while we want to continue expanding the capabilities of the module over time, the immediate goal is to provide a well-tested, flexible, composable API to quickly address modern problems in astrodynamics.</p> <p>One example of this in practice is that the built-in Earth reference frame transformation utilizes the IAU 2006/2000A precession-nutation model, CIO-based transformation. Even through there are multiple ways to construct this transformation, Brahe only implements one. Another example, is that the geodetic and geocentric transformations use the latest NIMA technical report definitions for Earth's radius and flatness. If a desired model isn't implemented users are free to extend the software to address and functionality or modeling gaps that exist to address their specific application.</p>"},{"location":"about/design_decisions.html","title":"Design Decisions","text":"<p>This page documents significant design decisions of the library.</p>"},{"location":"about/design_decisions.html#default-64-bit-floating-point-functions","title":"Default 64-bit Floating Point Functions","text":"<p>There is a decision to be made as to whether to support both 32-bit and 64-bit operations for all standard functions that could be used with either type. However, this results in duplicating a large amount of code as Rust does not support overloading primitive types. While some space missions may use lower-precision processors that do not support 64-bit floating point operations, the majority of modern computers and processors do support 64-bit floating point operations. Furthermore, the primary focus of this library is for us in terrestrial applications, and analysis, or space-processors that do support 64-bit floating point operations.</p> <p>Therefore, the decision is to only support 64-bit floating point operations for the time being.</p>"},{"location":"about/design_decisions.html#inline-pyo3-annotations-vs-written-wrappers","title":"Inline PyO3 Annotations vs Written Wrappers","text":"<p>There is a decision to use PyO3 macros to generate Python bindings or  to write them manually. Currently, the decision is to write them manually to have more control over the generated code and be able to more easily navigate issues related to type conversions that can arise. As a secondary benefit separate python-formatted docstrings can be written for the new functions.</p> <p>PyO3 macros would ultimately be preferable to reduce duplication of code, the  amount of boilerplate, and to make the code more maintainable. However, at the current time the complexity and difficulty to get them working is not worth the effort. This decision may be revisited in the future, and any change  proposals and pull requests to use PyO3 macros are welcome.</p>"},{"location":"about/license.html","title":"License","text":"<p>Brahe is released under a commercially-permissive MIT License that can be found here.</p> <p>The reason is so that individuals, studens, and companies can stop reinventing the wheel to get access to useful software that solves common problems without paying prohibitive amounts of money.</p>"},{"location":"about/python_deprecation.html","title":"Pure-Python Brahe Deprecation Notice","text":"<p>The older pure-Python version of brahe is currently being deprecated in favor of a mixed Rust-Python implementation, along with improved documentation. That means that the development on the <code>master</code> branch has been frozen and will no longer be developed against. Moving forward the <code>main</code> branch will be the primary branch for the project.</p> <p>There will be point commits (less than <code>1.0.0</code>) during this period that include breaking changes.</p> <p>Furthermore, initially the features of the new implementation will not be at partity with the old python implementation, so users should pin their requirements file to use the latest commit of the master branch:</p> <pre><code>brahe @ git+https://github.com/duncaneddy/brahe@master\n</code></pre> <p>To install and use the latest master branch via pip</p> <pre><code>pip install git+https://github.com/duncaneddy/brahe.git@master\n</code></pre> <p>The old master branch can be found here.</p>"},{"location":"examples/downloading_satellite_data.html","title":"How to Download Satellite Ephemeris Data","text":"<p>This guide shows how to download, process, and use satellite ephemeris data from CelesTrak using Brahe's datasets module.</p>"},{"location":"examples/downloading_satellite_data.html#prerequisites","title":"Prerequisites","text":"<pre><code>import brahe as bh\nimport numpy as np\nfrom pathlib import Path\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#quick-start-download-and-use","title":"Quick Start: Download and Use","text":"<p>The simplest workflow downloads ephemeris data and creates propagators in one step:</p> <pre><code># Get GNSS satellites as ready-to-use propagators\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\n    \"gnss\",\n    step_size=60.0  # Internal propagation step in seconds\n)\n\nprint(f\"Loaded {len(propagators)} GNSS satellites\")\n\n# Propagate all satellites to a specific time\nepoch = bh.Epoch.from_datetime(2024, 6, 15, 12, 0, 0, tsys=\"UTC\")\nfor i, prop in enumerate(propagators[:5]):  # First 5 satellites\n    state = prop.state_eci(epoch)\n    position = state[:3]  # Extract position [x, y, z]\n    print(f\"Satellite {i+1}: {position / 1000:.1f} km\")\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#download-raw-ephemeris-data","title":"Download Raw Ephemeris Data","text":"<p>Get ephemeris as tuples for custom processing:</p> <pre><code># Download GNSS constellation ephemeris\nephemeris = bh.datasets.celestrak.get_ephemeris(\"gnss\")\n\n# ephemeris is a list of (name, line1, line2) tuples\nprint(f\"Downloaded {len(ephemeris)} satellites\")\n\n# Process first satellite\nname, line1, line2 = ephemeris[0]\nprint(f\"\\nSatellite: {name}\")\nprint(f\"Line 1: {line1}\")\nprint(f\"Line 2: {line2}\")\n\n# Create SGP propagator\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Extract epoch\nepoch = bh.epoch_from_tle(line1)\nprint(f\"Epoch: {epoch}\")\n\n# Convert to Keplerian elements\nepoch_tle, keplerian = bh.keplerian_elements_from_tle(line1, line2)\na, e, i, raan, argp, M = keplerian\nprint(f\"Semi-major axis: {a/1000:.1f} km\")\nprint(f\"Eccentricity: {e:.6f}\")\nprint(f\"Inclination: {i:.2f} deg\")  # Already in degrees\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#save-ephemeris-to-files","title":"Save Ephemeris to Files","text":""},{"location":"examples/downloading_satellite_data.html#save-as-plain-text","title":"Save as Plain Text","text":"<p>Use standard TLE format for compatibility with other tools:</p> <pre><code># Download and save GPS satellites as text\nbh.datasets.celestrak.download_ephemeris(\n    \"gps-ops\",\n    \"gps_satellites.txt\",\n    content_format=\"3le\",  # Include satellite names\n    file_format=\"txt\"      # Plain text format\n)\n\nprint(\"Saved GPS satellites to gps_satellites.txt\")\n</code></pre> <p>File format: <pre><code>GPS BIIA-10 (PRN 32)\n1 20959U 90103A   24167.50000000  .00000012  00000+0  00000+0 0  9998\n2 20959  54.9876 123.4567 0123456 234.5678 123.4567  2.00561234567890\n\nGPS BIIR-2  (PRN 13)\n1 24876U 97035A   24167.50000000  .00000011  00000+0  00000+0 0  9997\n2 24876  55.1234 234.5678 0098765 345.6789 012.3456  2.00557890123456\n</code></pre></p>"},{"location":"examples/downloading_satellite_data.html#save-as-csv","title":"Save as CSV","text":"<p>For spreadsheet analysis or database import:</p> <pre><code># Download Starlink satellites as CSV\nbh.datasets.celestrak.download_ephemeris(\n    \"starlink\",\n    \"starlink_satellites.csv\",\n    content_format=\"3le\",\n    file_format=\"csv\"\n)\n\nprint(\"Saved Starlink satellites to CSV\")\n\n# Load with pandas for analysis\nimport pandas as pd\ndf = pd.read_csv(\"starlink_satellites.csv\")\nprint(f\"Loaded {len(df)} Starlink satellites\")\nprint(df.head())\n</code></pre> <p>CSV format: <pre><code>Name,Line1,Line2\nSTARLINK-1007,1 44713U 19074A   24167.50000000  .00001234  00000-0  12345-4 0  9991,2 44713  53.0543 123.4567 0001234  90.1234 269.9876 15.06391234567890\nSTARLINK-1008,1 44714U 19074B   24167.50000000  .00001235  00000-0  12346-4 0  9992,2 44714  53.0544 123.4568 0001235  90.1235 269.9877 15.06391345678901\n</code></pre></p>"},{"location":"examples/downloading_satellite_data.html#save-as-json","title":"Save as JSON","text":"<p>For web applications or structured processing:</p> <pre><code># Download space stations as JSON\nbh.datasets.celestrak.download_ephemeris(\n    \"stations\",\n    \"space_stations.json\",\n    content_format=\"3le\",\n    file_format=\"json\"\n)\n\nprint(\"Saved space stations to JSON\")\n\n# Load and parse\nimport json\nwith open(\"space_stations.json\", \"r\") as f:\n    stations = json.load(f)\n\nfor station in stations:\n    print(f\"{station['name']}: NORAD ID {station['line1'].split()[1]}\")\n</code></pre> <p>JSON format: <pre><code>[\n  {\n    \"name\": \"ISS (ZARYA)\",\n    \"line1\": \"1 25544U 98067A   24167.50000000  .00002182  00000-0  41420-4 0  9990\",\n    \"line2\": \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n  },\n  {\n    \"name\": \"TIANGONG\",\n    \"line1\": \"1 48274U 21035A   24167.50000000  .00001234  00000-0  23456-4 0  9991\",\n    \"line2\": \"2 48274  41.4700 123.4560 0001234  56.7890  12.3456 15.59876543012345\"\n  }\n]\n</code></pre></p>"},{"location":"examples/downloading_satellite_data.html#work-with-multiple-satellite-groups","title":"Work with Multiple Satellite Groups","text":"<p>Combine ephemeris from several groups:</p> <pre><code># Download all navigation constellations\nnavigation_groups = [\"gps-ops\", \"glonass-ops\", \"galileo\", \"beidou\"]\nall_ephemeris = []\n\nfor group in navigation_groups:\n    ephemeris = bh.datasets.celestrak.get_ephemeris(group)\n    all_ephemeris.extend(ephemeris)\n    print(f\"{group}: {len(ephemeris)} satellites\")\n\nprint(f\"\\nTotal navigation satellites: {len(all_ephemeris)}\")\n\n# Save combined data\nimport json\noutput = [\n    {\"name\": name, \"line1\": line1, \"line2\": line2}\n    for name, line1, line2 in all_ephemeris\n]\nwith open(\"all_navigation_satellites.json\", \"w\") as f:\n    json.dump(output, f, indent=2)\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#filter-satellites-by-criteria","title":"Filter Satellites by Criteria","text":"<p>Select specific satellites from ephemeris data:</p> <pre><code># Get all active satellites\nall_sats = bh.datasets.celestrak.get_ephemeris(\"active\")\n\n# Filter for LEO satellites (period &lt; 128 minutes = ~8000 km altitude)\nleo_sats = []\nfor name, line1, line2 in all_sats:\n    # Extract mean-Keplerian elements at epoch\n    epoch_tle, elements = bh.keplerian_elements_from_tle(line1, line2)\n\n    # Calculate orbital period\n    a = elements[0]  # Semi-major axis in meters\n    period = bh.orbital_period(a)  # Period in seconds\n\n    if period &lt; 128 * 60:  # 128 minutes in seconds\n        leo_sats.append((name, line1, line2))\n\nprint(f\"Found {len(leo_sats)} LEO satellites out of {len(all_sats)} total\")\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#compute-satellite-visibility","title":"Compute Satellite Visibility","text":"<p>Use downloaded ephemeris to predict visibility from a ground station:</p> <pre><code># Download satellites of interest\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\n    \"weather\",\n    step_size=60.0\n)\n\n# Ground station location (geodetic coordinates)\nstation_lat = 40.7128   # New York City latitude\nstation_lon = -74.0060  # New York City longitude\nstation_alt = 10.0      # Altitude in meters (approximate)\n\n# Convert to ECEF\nstation_ecef = bh.position_geodetic_to_ecef(\n    np.array([station_lat, station_lon, station_alt]),\n    bh.DEGREES\n)\n\n# Check visibility at specific time\nepoch = bh.Epoch.from_datetime(2024, 6, 15, 18, 0, 0, tsys=\"UTC\")\n\nvisible_satellites = []\nfor i, prop in enumerate(propagators):\n    # Get satellite position in ECI\n    state_eci = prop.propagate(epoch)\n    pos_eci = state_eci[:3]\n\n    # Convert to ECEF\n    pos_ecef = bh.position_eci_to_ecef(pos_eci, epoch)\n\n    # Compute relative position\n    relative_ecef = pos_ecef - station_ecef\n\n    # Convert to topocentric (ENZ)\n    relative_enz = bh.relative_position_ecef_to_enz(\n        station_lat,\n        station_lon,\n        relative_ecef\n    )\n\n    # Convert to azimuth/elevation\n    az, el, _ = bh.position_enz_to_azel(relative_enz)\n\n    # Check if above horizon (elevation &gt; 0)\n    if el &gt; 0:\n        visible_satellites.append({\n            \"index\": i,\n            \"azimuth\": np.rad2deg(az),\n            \"elevation\": np.rad2deg(el)\n        })\n\nprint(f\"Visible satellites: {len(visible_satellites)}\")\nfor sat in visible_satellites[:5]:\n    print(f\"Satellite {sat['index']}: f\"Az={sat['azimuth']:.1f}\u00b0, El={sat['elevation']:.1f}\u00b0\")\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#handle-errors-gracefully","title":"Handle Errors Gracefully","text":"<p>Implement robust error handling and retries:</p> <pre><code>import time\n\ndef download_with_retry(group, filepath, max_retries=3):\n    \"\"\"Download ephemeris with exponential backoff\"\"\"\n    for attempt in range(max_retries):\n        try:\n            bh.datasets.celestrak.download_ephemeris(\n                group,\n                filepath,\n                content_format=\"3le\",\n                file_format=\"json\"\n            )\n            print(f\"Successfully downloaded {group}\")\n            return True\n\n        except Exception as e:\n            if attempt &lt; max_retries - 1:\n                wait_time = 2 ** attempt  # Exponential backoff: 1s, 2s, 4s\n                print(f\"Attempt {attempt + 1} failed: {e}\")\n                print(f\"Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                print(f\"All {max_retries} attempts failed for {group}\")\n                return False\n\n# Use with error handling\nsuccess = download_with_retry(\"gnss\", \"gnss_satellites.json\")\nif not success:\n    print(\"Failed to download\")\n    # Load from previous download or use fallback\n</code></pre>"},{"location":"examples/downloading_satellite_data.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets module</li> <li>CelesTrak Details - CelesTrak data source specifics</li> <li>TLE and SGP - Understanding TLE format and SGP propagation</li> <li>Datasets API Reference - Complete function reference</li> </ul>"},{"location":"examples/loading_groundstations.html","title":"Loading Groundstation Datasets","text":"<p>This guide shows how to load and work with groundstation location datasets in Brahe.</p>"},{"location":"examples/loading_groundstations.html#overview","title":"Overview","text":"<p>Brahe provides curated groundstation datasets from multiple commercial providers. The data is embedded in the library, so no internet connection or external files are required.</p> <p>Available providers:</p> <ul> <li>atlas: Atlas Space Operations</li> <li>aws: Amazon Web Services Ground Station</li> <li>ksat: Kongsberg Satellite Services (KSAT)</li> <li>leaf: Leaf Space</li> <li>ssc: Swedish Space Corporation</li> <li>viasat: Viasat</li> </ul>"},{"location":"examples/loading_groundstations.html#loading-groundstations-by-provider","title":"Loading Groundstations by Provider","text":"<p>Load groundstations from a specific provider:</p> <pre><code>import brahe as bh\n\n# Load KSAT groundstations\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\n\nprint(f\"Loaded {len(ksat_stations)} KSAT stations\")\n\n# Display first few stations\nfor station in ksat_stations[:5]:\n    print(f\"{station.get_name()}: ({station.lon():.2f}\u00b0, {station.lat():.2f}\u00b0)\")\n</code></pre> <p>Provider names are case-insensitive:</p> <pre><code># These all work the same\nstations1 = bh.datasets.groundstations.load(\"KSAT\")\nstations2 = bh.datasets.groundstations.load(\"ksat\")\nstations3 = bh.datasets.groundstations.load(\"KsAt\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#loading-all-groundstations","title":"Loading All Groundstations","text":"<p>Load groundstations from all providers at once:</p> <pre><code>import brahe as bh\n\n# Load all groundstations\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Total stations: {len(all_stations)}\")\n\n# Group by provider\nby_provider = {}\nfor station in all_stations:\n    props = station.properties\n    provider = props.get(\"provider\", \"Unknown\")\n\n    if provider not in by_provider:\n        by_provider[provider] = []\n    by_provider[provider].append(station)\n\n# Display counts\nfor provider, stations in sorted(by_provider.items()):\n    print(f\"{provider}: {len(stations)} stations\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#listing-available-providers","title":"Listing Available Providers","text":"<p>Get a list of all available providers:</p> <pre><code>import brahe as bh\n\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"Available providers: {', '.join(providers)}\")\n\n# Load stations for each provider\nfor provider in providers:\n    stations = bh.datasets.groundstations.load(provider)\n    print(f\"{provider}: {len(stations)} stations\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#working-with-groundstation-properties","title":"Working with Groundstation Properties","text":"<p>Each groundstation has metadata stored in properties:</p> <pre><code>import brahe as bh\n\nstations = bh.datasets.groundstations.load(\"atlas\")\nstation = stations[0]\n\n# Access basic info\nprint(f\"Name: {station.get_name()}\")\nprint(f\"Location: {station.lon():.3f}\u00b0, {station.lat():.3f}\u00b0, {station.alt():.0f} m\")\n\n# Access properties\nprops = station.properties\n\n# Provider name\nprint(f\"Provider: {props['provider']}\")\n\n# Supported frequency bands\nbands = props['frequency_bands']\nprint(f\"Frequency bands: {', '.join(bands)}\")\n</code></pre> <p>All groundstations have these properties:</p> <ul> <li><code>provider</code>: Provider name (e.g., \"KSAT\", \"Atlas\")</li> <li><code>frequency_bands</code>: List of supported frequency bands (e.g., <code>[\"S\", \"X\", \"Ka\"]</code>)</li> </ul>"},{"location":"examples/loading_groundstations.html#accessing-coordinates","title":"Accessing Coordinates","text":"<p>Groundstations provide convenient coordinate accessors:</p> <pre><code>import brahe as bh\n\nstation = bh.datasets.groundstations.load(\"ksat\")[0]\n\n# Quick accessors (always in degrees)\nlon = station.lon()    # Longitude in degrees\nlat = station.lat()    # Latitude in degrees\nalt = station.alt()    # Altitude in meters\n\nprint(f\"Position: {lon:.4f}\u00b0E, {lat:.4f}\u00b0N, {alt:.1f}m\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#computing-satellite-access","title":"Computing Satellite Access","text":"<p>Use groundstations with the access module to compute visibility windows:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n# Load groundstations\nstations = bh.datasets.groundstations.load(\"ksat\")\n\n# Create satellite propagator from TLE\ntle_line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\ntle_line2 = \"2 25544  51.6461 306.0234 0003417  88.1267  25.5695 15.48919103000003\"\npropagator = bh.SGPPropagator.from_tle(tle_line1, tle_line2)\n\n# Define time range\nstart_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0, tsys=\"UTC\")\nend_epoch = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0, tsys=\"UTC\")\n\n# Compute access windows with elevation constraint\nconstraint = bh.ElevationConstraint(5.0)  # 5 degree minimum elevation\n\naccesses = bh.location_accesses(\n    stations,      # All KSAT stations\n    propagator,\n    start_epoch,\n    end_epoch,\n    constraint,\n    step_size=60.0  # 60 second time step\n)\n\n# Print access windows\nfor access in accesses:\n    station_name = access.location.name\n    duration = (access.end - access.start) / 60.0  # Convert to minutes\n    print(f\"{station_name}: {access.start} ({duration:.1f} min)\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#filtering-stations-by-frequency-band","title":"Filtering Stations by Frequency Band","text":"<p>Find stations that support specific frequency bands:</p> <pre><code>import brahe as bh\n\n# Load all stations\nall_stations = bh.datasets.groundstations.load_all()\n\n# Filter for X-band capable stations\nx_band_stations = []\nfor station in all_stations:\n    props = station.properties\n    if \"X\" in props[\"frequency_bands\"]:\n        x_band_stations.append(station)\n\nprint(f\"Found {len(x_band_stations)} X-band capable stations\")\n\n# Display by provider\nby_provider = {}\nfor station in x_band_stations:\n    provider = station.properties[\"provider\"]\n    if provider not in by_provider:\n        by_provider[provider] = 0\n    by_provider[provider] += 1\n\nfor provider, count in sorted(by_provider.items()):\n    print(f\"  {provider}: {count} stations\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#filtering-by-geographic-region","title":"Filtering by Geographic Region","text":"<p>Find stations in a specific geographic region:</p> <pre><code>import brahe as bh\n\n# Load all stations\nall_stations = bh.datasets.groundstations.load_all()\n\n# Filter for Arctic stations (latitude &gt; 60\u00b0N)\narctic_stations = [\n    s for s in all_stations\n    if s.lat() &gt; 60.0\n]\n\nprint(f\"Found {len(arctic_stations)} Arctic stations:\")\nfor station in arctic_stations:\n    print(f\"  {station.get_name()}: {station.lat():.2f}\u00b0N\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#loading-from-custom-geojson-files","title":"Loading from Custom GeoJSON Files","text":"<p>You can also load groundstations from custom GeoJSON files:</p> <pre><code>import brahe as bh\n\n# Load from custom file\ncustom_stations = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n\nprint(f\"Loaded {len(custom_stations)} custom stations\")\n</code></pre> <p>The GeoJSON file must be a FeatureCollection with Point geometries:</p> <pre><code>{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 0.0]\n      },\n      \"properties\": {\n        \"name\": \"My Ground Station\",\n        \"provider\": \"Custom\",\n        \"frequency_bands\": [\"S\", \"X\"]\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"examples/loading_groundstations.html#using-the-cli","title":"Using the CLI","text":"<p>Brahe provides command-line tools for working with groundstations:</p>"},{"location":"examples/loading_groundstations.html#list-available-providers","title":"List Available Providers","text":"<pre><code>brahe datasets groundstations list\n</code></pre>"},{"location":"examples/loading_groundstations.html#show-stations","title":"Show Stations","text":"<pre><code># Show KSAT stations\nbrahe datasets groundstations show ksat\n\n# Show with properties\nbrahe datasets groundstations show atlas --properties\n</code></pre>"},{"location":"examples/loading_groundstations.html#show-all-stations","title":"Show All Stations","text":"<pre><code>brahe datasets groundstations show-all\n\n# With properties\nbrahe datasets groundstations show-all --properties\n</code></pre>"},{"location":"examples/loading_groundstations.html#common-patterns","title":"Common Patterns","text":""},{"location":"examples/loading_groundstations.html#find-nearest-station","title":"Find Nearest Station","text":"<p>Find the groundstation nearest to a given point:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n# Target location\ntarget_lon, target_lat = 10.0, 60.0  # degrees\n\n# Load all stations\nall_stations = bh.datasets.groundstations.load_all()\n\n# Find nearest (simple great circle distance)\nmin_distance = float('inf')\nnearest_station = None\n\nfor station in all_stations:\n    # Simple distance approximation\n    dlon = station.lon() - target_lon\n    dlat = station.lat() - target_lat\n    distance = np.sqrt(dlon**2 + dlat**2)\n\n    if distance &lt; min_distance:\n        min_distance = distance\n        nearest_station = station\n\nprint(f\"Nearest station: {nearest_station.get_name()}\")\nprint(f\"Location: {nearest_station.lon():.2f}\u00b0, {nearest_station.lat():.2f}\u00b0\")\nprint(f\"Provider: {nearest_station.properties['provider']}\")\n</code></pre>"},{"location":"examples/loading_groundstations.html#create-coverage-map","title":"Create Coverage Map","text":"<p>Create a simple coverage map showing station distribution:</p> <pre><code>import brahe as bh\nimport matplotlib.pyplot as plt\n\n# Load all stations\nall_stations = bh.datasets.groundstations.load_all()\n\n# Extract coordinates\nlons = [s.lon() for s in all_stations]\nlats = [s.lat() for s in all_stations]\n\n# Get colors by provider\nproviders = [s.properties[\"provider\"] for s in all_stations]\nunique_providers = sorted(set(providers))\ncolors = [unique_providers.index(p) for p in providers]\n\n# Plot\nplt.figure(figsize=(12, 6))\nplt.scatter(lons, lats, c=colors, cmap='tab10', alpha=0.6, s=50)\nplt.xlabel('Longitude (degrees)')\nplt.ylabel('Latitude (degrees)')\nplt.title(f'Global Groundstation Coverage ({len(all_stations)} stations)')\nplt.grid(True, alpha=0.3)\nplt.colorbar(label='Provider', ticks=range(len(unique_providers)))\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"examples/loading_groundstations.html#see-also","title":"See Also","text":"<ul> <li>Computing Ground Contacts</li> <li>Groundstation Functions Reference</li> </ul>"},{"location":"examples/point_imaging_opportunities.html","title":"Point Imaging Opportunities","text":"<p>This example demonstrates how to find imaging opportunities for ground targets using satellite access computation. We'll analyze when an Earth observation satellite can image specific points of interest while satisfying geometric and operational constraints.</p>"},{"location":"examples/point_imaging_opportunities.html#scenario","title":"Scenario","text":"<p>Satellite: Earth observation satellite with side-looking optical sensor - Altitude: 500 km - Inclination: 97.8\u00b0 (sun-synchronous) - Sensor: Off-nadir imaging capability - Look direction: Right-looking only (fixed sensor orientation)</p> <p>Targets: High-value imaging locations - Paris, France (urban monitoring) - Tokyo, Japan (disaster response) - Amazon Basin, Brazil (deforestation tracking)</p> <p>Constraints: - Off-nadir angle: 5\u00b0 to 30\u00b0 (avoid nadir, limit distortion) - Look direction: Right only (sensor limitation) - Daylight: 10 AM to 4 PM local time (good sun angles)</p> <p>Analysis Period: 7 days</p>"},{"location":"examples/point_imaging_opportunities.html#complete-implementation","title":"Complete Implementation","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP provider\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider_from_static_provider(eop)\n\n# Define analysis period\nepoch = bh.Epoch.from_datetime(2024, 7, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nsearch_start = epoch\nsearch_end = epoch + 7 * 86400.0  # 7 days\n\n# Create imaging targets\ntargets = [\n    bh.PointLocation(2.3, 48.9, 0.0)\n        .with_name(\"Paris\")\n        .with_id(1)\n        .add_property(\"priority\", \"high\")\n        .add_property(\"target_type\", \"urban\"),\n\n    bh.PointLocation(139.7, 35.7, 0.0)\n        .with_name(\"Tokyo\")\n        .with_id(2)\n        .add_property(\"priority\", \"high\")\n        .add_property(\"target_type\", \"urban\"),\n\n    bh.PointLocation(-60.0, -3.0, 0.0)\n        .with_name(\"Amazon-Basin\")\n        .with_id(3)\n        .add_property(\"priority\", \"medium\")\n        .add_property(\"target_type\", \"environmental\"),\n]\n\n# Create satellite propagator\noe = np.array([\n    bh.R_EARTH + 500e3,      # 500 km altitude\n    0.001,                    # Near-circular\n    np.radians(97.8),         # Sun-synchronous\n    np.radians(45.0),         # RAAN\n    0.0,                      # Argument of perigee\n    0.0,                      # Mean anomaly\n])\n\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nsatellite = bh.KeplerianPropagator.from_eci(epoch, state, 60.0) \\\n    .with_name(\"EO-Sat-1\") \\\n    .with_id(1)\n\n# Define imaging constraints\nimaging_constraint = bh.ConstraintAll([\n    # Geometric constraints\n    bh.OffNadirConstraint(\n        min_off_nadir_deg=5.0,   # Avoid nadir (better geometry)\n        max_off_nadir_deg=30.0   # Limit distortion\n    ),\n    bh.LookDirectionConstraint(\n        look_direction=bh.LookDirection.RIGHT  # Sensor limitation\n    ),\n\n    # Operational constraints\n    bh.LocalTimeConstraint(\n        min_hour=10.0,   # 10 AM local time\n        max_hour=16.0    # 4 PM local time\n    ),\n])\n\n# Compute imaging opportunities\nopportunities = bh.location_accesses(\n    targets,\n    [satellite],\n    search_start,\n    search_end,\n    imaging_constraint\n)\n\n# Analyze results\nprint(\"Imaging Opportunity Analysis\")\nprint(f\"Period: {search_start} to {search_end}\")\nprint(f\"=\" * 70)\nprint(f\"\\nTotal imaging opportunities: {len(opportunities)}\")\n\n# Statistics per target\nfor target in targets:\n    target_opps = [o for o in opportunities if o.location_id == target.get_id()]\n\n    print(f\"\\n{target.get_name()} ({target.properties()['priority']} priority):\")\n    print(f\"  Opportunities: {len(target_opps)}\")\n\n    if target_opps:\n        # Duration statistics\n        durations = [o.duration for o in target_opps]\n        print(f\"  Total imaging time: {sum(durations)/60:.1f} minutes\")\n        print(f\"  Average opportunity: {np.mean(durations)/60:.1f} minutes\")\n        print(f\"  Max duration: {max(durations)/60:.1f} minutes\")\n\n        # Geometry statistics\n        max_elevations = [o.properties.get(\"elevation_max\", 0) for o in target_opps]\n        off_nadirs = [o.properties.get(\"off_nadir_min\", 0) for o in target_opps]\n\n        print(f\"  Avg max elevation: {np.mean(max_elevations):.1f}\u00b0\")\n        print(f\"  Avg off-nadir: {np.mean(off_nadirs):.1f}\u00b0\")\n\n# Detailed opportunity listing (first 5)\nprint(f\"\\n{'='*70}\")\nprint(\"Detailed Opportunities (first 5)\")\nprint(f\"{'='*70}\")\n\nfor i, opp in enumerate(opportunities[:5], 1):\n    # Find target name\n    target_name = next(\n        (t.get_name() for t in targets if t.get_id() == opp.location_id),\n        \"Unknown\"\n    )\n\n    duration_sec = opp.duration\n    max_el = opp.properties.get(\"elevation_max\", 0.0)\n    off_nadir = opp.properties.get(\"off_nadir_min\", 0.0)\n\n    print(f\"\\nOpportunity {i}: {target_name}\")\n    print(f\"  Start:       {opp.window_open}\")\n    print(f\"  Duration:    {duration_sec:.1f} seconds\")\n    print(f\"  Max Elev:    {max_el:.1f}\u00b0\")\n    print(f\"  Off-Nadir:   {off_nadir:.1f}\u00b0\")\n    print(f\"  Look Dir:    {opp.properties.get('look_direction', 'N/A')}\")\n    print(f\"  Local Time:  {opp.properties.get('local_time', 0)/3600:.1f} hours\")\n\nif len(opportunities) &gt; 5:\n    print(f\"\\n... and {len(opportunities) - 5} more opportunities\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#expected-output","title":"Expected Output","text":"<pre><code>Imaging Opportunity Analysis\nPeriod: 2024-07-01T00:00:00.000000000 UTC to 2024-07-08T00:00:00.000000000 UTC\n======================================================================\n\nTotal imaging opportunities: 18\n\nParis (high priority):\n  Opportunities: 6\n  Total imaging time: 3.2 minutes\n  Average opportunity: 32.0 seconds\n  Max duration: 38.5 seconds\n  Avg max elevation: 28.3\u00b0\n  Avg off-nadir: 18.2\u00b0\n\nTokyo (high priority):\n  Opportunities: 6\n  Total imaging time: 3.1 minutes\n  Average opportunity: 31.2 seconds\n  Max duration: 37.8 seconds\n  Avg max elevation: 27.9\u00b0\n  Avg off-nadir: 17.8\u00b0\n\nAmazon-Basin (medium priority):\n  Opportunities: 6\n  Total imaging time: 3.3 minutes\n  Average opportunity: 33.1 seconds\n  Max duration: 39.2 seconds\n  Avg max elevation: 29.1\u00b0\n  Avg off-nadir: 16.9\u00b0\n\n======================================================================\nDetailed Opportunities (first 5)\n======================================================================\n\nOpportunity 1: Paris\n  Start:       2024-07-01T11:23:45.000000000 UTC\n  Duration:    35.2 seconds\n  Max Elev:    31.2\u00b0\n  Off-Nadir:   15.3\u00b0\n  Look Dir:    RIGHT\n  Local Time:  13.4 hours\n\nOpportunity 2: Tokyo\n  Start:       2024-07-02T02:15:33.000000000 UTC\n  Duration:    32.8 seconds\n  Max Elev:    26.7\u00b0\n  Off-Nadir:   19.1\u00b0\n  Look Dir:    RIGHT\n  Local Time:  11.3 hours\n\n... (continues)\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#analysis-extensions","title":"Analysis Extensions","text":""},{"location":"examples/point_imaging_opportunities.html#prioritize-high-quality-opportunities","title":"Prioritize High-Quality Opportunities","text":"<p>Filter for best imaging geometry:</p> <pre><code># Only near-overhead passes (elevation &gt; 45\u00b0, off-nadir &lt; 20\u00b0)\nhigh_quality_constraint = bh.ConstraintAll([\n    imaging_constraint,  # Base constraints\n    bh.ElevationConstraint(min_elevation_deg=45.0),\n    bh.OffNadirConstraint(max_off_nadir_deg=20.0),\n])\n\nhigh_quality_opps = bh.location_accesses(\n    targets,\n    [satellite],\n    search_start,\n    search_end,\n    high_quality_constraint\n)\n\nprint(f\"\\nHigh-quality opportunities: {len(high_quality_opps)}\")\nprint(f\"  (vs {len(opportunities)} with relaxed constraints)\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#compute-image-quality-metrics","title":"Compute Image Quality Metrics","text":"<p>Add custom properties for image quality assessment:</p> <pre><code>def image_quality_computer(epoch, sat_state_eci, sat_state_ecef, location_ecef):\n    \"\"\"Compute image quality metrics\"\"\"\n    sat_pos = sat_state_ecef[:3]\n    sat_vel = sat_state_ecef[3:6]\n\n    # Ground sample distance (GSD) - simplified model\n    # Assumes 500mm focal length, 5\u03bcm pixel pitch\n    altitude = np.linalg.norm(sat_pos) - bh.R_EARTH\n    focal_length_m = 0.5\n    pixel_pitch_m = 5e-6\n\n    # Off-nadir angle affects GSD\n    range_vec = sat_pos - location_ecef\n    slant_range = np.linalg.norm(range_vec)\n    nadir_range = altitude\n\n    off_nadir_rad = np.arccos(nadir_range / slant_range)\n    gsd_m = (slant_range * pixel_pitch_m) / focal_length_m\n\n    # Adjusted for off-nadir\n    gsd_cross_track = gsd_m / np.cos(off_nadir_rad)\n    gsd_along_track = gsd_m\n\n    # Smear (motion blur) - simplified\n    ground_speed = np.linalg.norm(sat_vel)\n    integration_time_s = 0.001  # 1ms exposure\n    smear_m = ground_speed * integration_time_s\n\n    return {\n        \"gsd_cross_track_m\": gsd_cross_track,\n        \"gsd_along_track_m\": gsd_along_track,\n        \"smear_m\": smear_m,\n        \"quality_score\": 100.0 / (1.0 + smear_m + (gsd_cross_track - 1.0)**2)\n    }\n\n# Create computer\nquality_computer = bh.AccessPropertyComputer(image_quality_computer)\n\n# Compute with quality metrics\nopps_with_quality = bh.location_accesses(\n    targets,\n    [satellite],\n    search_start,\n    search_end,\n    imaging_constraint,\n    property_computers=[quality_computer]\n)\n\n# Find best opportunities by quality score\nsorted_opps = sorted(\n    opps_with_quality,\n    key=lambda o: o.properties.get(\"quality_score\", 0),\n    reverse=True\n)\n\nprint(\"\\nTop 5 Opportunities by Image Quality:\")\nfor i, opp in enumerate(sorted_opps[:5], 1):\n    target_name = next(\n        (t.get_name() for t in targets if t.get_id() == opp.location_id),\n        \"Unknown\"\n    )\n    props = opp.properties\n\n    print(f\"\\n{i}. {target_name}\")\n    print(f\"   Time: {opp.window_open}\")\n    print(f\"   GSD: {props['gsd_cross_track_m']:.2f}m \u00d7 {props['gsd_along_track_m']:.2f}m\")\n    print(f\"   Smear: {props['smear_m']:.2f}m\")\n    print(f\"   Quality: {props['quality_score']:.1f}/100\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#multi-satellite-constellation","title":"Multi-Satellite Constellation","text":"<p>Analyze multiple satellites for revisit analysis:</p> <pre><code># Create constellation (3 satellites, different orbital planes)\nconstellation = []\n\nfor i in range(3):\n    oe_constellation = np.array([\n        bh.R_EARTH + 500e3,\n        0.001,\n        np.radians(97.8),\n        np.radians(i * 120),  # 120\u00b0 RAAN separation\n        0.0,\n        np.radians(i * 60),\n    ])\n\n    state = bh.state_osculating_to_cartesian(oe_constellation, bh.AngleFormat.RADIANS)\n    sat = bh.KeplerianPropagator.from_eci(epoch, state, 60.0) \\\n        .with_name(f\"EO-Sat-{i+1}\") \\\n        .with_id(i + 1)\n\n    constellation.append(sat)\n\n# Compute opportunities with full constellation\nconstellation_opps = bh.location_accesses(\n    targets,\n    constellation,\n    search_start,\n    search_end,\n    imaging_constraint\n)\n\n# Analyze revisit times per target\nfor target in targets:\n    target_opps = sorted(\n        [o for o in constellation_opps if o.location_id == target.get_id()],\n        key=lambda o: o.window_open\n    )\n\n    if len(target_opps) &gt; 1:\n        # Compute revisit intervals\n        revisits = [\n            (target_opps[i+1].window_open - target_opps[i].window_open) / 3600.0\n            for i in range(len(target_opps) - 1)\n        ]\n\n        print(f\"\\n{target.get_name()} Revisit Analysis:\")\n        print(f\"  Total opportunities: {len(target_opps)}\")\n        print(f\"  Average revisit: {np.mean(revisits):.1f} hours\")\n        print(f\"  Min revisit: {min(revisits):.1f} hours\")\n        print(f\"  Max revisit: {max(revisits):.1f} hours\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#export-opportunities-to-csv","title":"Export Opportunities to CSV","text":"<p>Save results for mission planning:</p> <pre><code>import csv\n\n# Export opportunities to CSV\nwith open(\"imaging_opportunities.csv\", \"w\", newline=\"\") as f:\n    writer = csv.writer(f)\n\n    # Header\n    writer.writerow([\n        \"Target\", \"Satellite\", \"Start Time\", \"Duration (s)\",\n        \"Max Elevation (deg)\", \"Off-Nadir (deg)\", \"Look Direction\"\n    ])\n\n    # Data rows\n    for opp in opportunities:\n        target_name = next(\n            (t.get_name() for t in targets if t.get_id() == opp.location_id),\n            \"Unknown\"\n        )\n\n        writer.writerow([\n            target_name,\n            opp.propagator_name or f\"Sat-{opp.propagator_id}\",\n            str(opp.window_open),\n            f\"{opp.duration:.1f}\",\n            f\"{opp.properties.get('elevation_max', 0):.1f}\",\n            f\"{opp.properties.get('off_nadir_min', 0):.1f}\",\n            opp.properties.get('look_direction', 'N/A'),\n        ])\n\nprint(\"Opportunities exported to imaging_opportunities.csv\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#advanced-constraints","title":"Advanced Constraints","text":""},{"location":"examples/point_imaging_opportunities.html#avoid-sun-glint","title":"Avoid Sun Glint","text":"<p>Exclude opportunities where sun reflection might interfere:</p> <pre><code>def no_sun_glint_computer(epoch, sat_state_eci, sat_state_ecef, location_ecef):\n    \"\"\"Check for sun glint conditions\"\"\"\n    # Simplified: exclude when satellite azimuth is within 30\u00b0 of sun azimuth\n    # (Real implementation would use actual sun position)\n\n    # This is a placeholder - real sun position calculation needed\n    sun_azimuth = 180.0  # Placeholder\n\n    sat_azimuth = compute_azimuth(sat_state_ecef[:3], location_ecef)\n    azimuth_diff = abs(sat_azimuth - sun_azimuth)\n    if azimuth_diff &gt; 180:\n        azimuth_diff = 360 - azimuth_diff\n\n    return {\n        \"sun_glint_risk\": azimuth_diff &lt; 30.0,\n        \"azimuth_from_sun\": azimuth_diff\n    }\n\n# Use as post-filter\nopps_with_glint = bh.location_accesses(\n    targets, [satellite], search_start, search_end,\n    imaging_constraint,\n    property_computers=[bh.AccessPropertyComputer(no_sun_glint_computer)]\n)\n\n# Filter out glint risks\nsafe_opps = [\n    o for o in opps_with_glint\n    if not o.properties.get(\"sun_glint_risk\", False)\n]\n\nprint(f\"Opportunities without sun glint: {len(safe_opps)} (vs {len(opps_with_glint)} total)\")\n</code></pre>"},{"location":"examples/point_imaging_opportunities.html#see-also","title":"See Also","text":"<ul> <li>Access Computation Overview</li> <li>Constraints</li> <li>Locations</li> <li>Svalbard Ground Contacts</li> <li>API Reference: Access Module</li> </ul>"},{"location":"examples/svalbard_ground_contacts.html","title":"Computing Ground Station Contacts","text":"<p>This example demonstrates how to compute satellite passes over a ground station using Brahe's access computation system. We'll analyze contacts for the Svalbard ground station\u2014a critical high-latitude station used for polar-orbiting satellites.</p>"},{"location":"examples/svalbard_ground_contacts.html#scenario","title":"Scenario","text":"<p>Ground Station: Svalbard Satellite Station (Norway) - Location: 78.2\u00b0N, 15.4\u00b0E - Minimum elevation: 5\u00b0 (typical for X-band communications) - Operational hours: 24/7 - Application: Polar orbit data downlinks</p> <p>Satellites: Small constellation of 3 sun-synchronous satellites - Altitude: 550 km - Inclination: 97.8\u00b0 (sun-synchronous) - Different orbital planes for coverage diversity</p> <p>Analysis Period: 24 hours</p>"},{"location":"examples/svalbard_ground_contacts.html#complete-implementation","title":"Complete Implementation","text":"<pre><code>import brahe as bh\nimport numpy as np\nfrom datetime import datetime\n\n# Initialize EOP provider (required for ECEF transformations)\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider_from_static_provider(eop)\n\n# Define analysis period\nepoch = bh.Epoch.from_datetime(2024, 6, 15, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nsearch_start = epoch\nsearch_end = epoch + 86400.0  # 24 hours\n\n# Create Svalbard ground station\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0) \\\n    .with_name(\"Svalbard\") \\\n    .add_property(\"station_code\", \"SG\") \\\n    .add_property(\"frequency_band\", \"X-band\") \\\n    .add_property(\"max_data_rate_mbps\", 300.0)\n\n# Create constellation - 3 satellites in sun-synchronous orbits\npropagators = []\n\nfor i in range(3):\n    # Orbital elements: [a, e, i, raan, argp, M]\n    oe = np.array([\n        bh.R_EARTH + 550e3,     # 550 km altitude\n        0.001,                   # Low eccentricity (near-circular)\n        np.radians(97.8),        # Sun-synchronous inclination\n        np.radians(i * 60),      # Different RAANs for plane diversity\n        0.0,                     # Argument of perigee\n        np.radians(i * 45),      # Different starting positions\n    ])\n\n    # Convert to Cartesian state\n    state = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\n    # Create propagator\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0) \\\n        .with_name(f\"Sat-{i+1}\") \\\n        .with_id(i + 1)\n\n    propagators.append(prop)\n\n# Define constraint - minimum 5\u00b0 elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0)\n\n# Compute all accesses\nwindows = bh.location_accesses(\n    [svalbard],\n    propagators,\n    search_start,\n    search_end,\n    constraint\n)\n\n# Analyze results\nprint(f\"Svalbard Ground Station Contact Analysis\")\nprint(f\"Analysis Period: {search_start} to {search_end}\")\nprint(f\"=\" * 70)\nprint(f\"\\nFound {len(windows)} contacts\")\n\n# Statistics per satellite\nfor i, prop in enumerate(propagators):\n    sat_windows = [w for w in windows if w.propagator_id == prop.get_id()]\n    total_duration = sum(w.duration for w in sat_windows)\n    avg_duration = total_duration / len(sat_windows) if sat_windows else 0\n\n    print(f\"\\n{prop.get_name()}:\")\n    print(f\"  Contacts: {len(sat_windows)}\")\n    print(f\"  Total contact time: {total_duration/60:.1f} minutes\")\n    print(f\"  Average pass duration: {avg_duration/60:.1f} minutes\")\n\n# Overall statistics\ntotal_contact_time = sum(w.duration for w in windows)\ncoverage_fraction = total_contact_time / 86400.0 * 100\n\nprint(f\"\\nOverall Statistics:\")\nprint(f\"  Total contact time: {total_contact_time/3600:.1f} hours\")\nprint(f\"  Coverage: {coverage_fraction:.1f}%\")\n\n# Detailed pass information\nprint(f\"\\n{'='*70}\")\nprint(f\"Detailed Pass Information\")\nprint(f\"{'='*70}\")\n\nfor i, window in enumerate(windows[:10], 1):  # Show first 10 passes\n    duration_min = window.duration / 60.0\n    max_el = window.properties.get(\"elevation_max\", 0.0)\n\n    # Find satellite name\n    sat_name = next(\n        (p.get_name() for p in propagators if p.get_id() == window.propagator_id),\n        \"Unknown\"\n    )\n\n    print(f\"\\nPass {i}: {sat_name}\")\n    print(f\"  Start:    {window.window_open}\")\n    print(f\"  End:      {window.window_close}\")\n    print(f\"  Duration: {duration_min:.1f} minutes\")\n    print(f\"  Max Elev: {max_el:.1f}\u00b0\")\n    print(f\"  AOS Az:   {window.properties.get('azimuth_open', 0.0):.1f}\u00b0\")\n    print(f\"  LOS Az:   {window.properties.get('azimuth_close', 0.0):.1f}\u00b0\")\n\nif len(windows) &gt; 10:\n    print(f\"\\n... and {len(windows) - 10} more passes\")\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#expected-output","title":"Expected Output","text":"<pre><code>Svalbard Ground Station Contact Analysis\nAnalysis Period: 2024-06-15T00:00:00.000000000 UTC to 2024-06-16T00:00:00.000000000 UTC\n======================================================================\n\nFound 42 contacts\n\nSat-1:\n  Contacts: 14\n  Total contact time: 112.3 minutes\n  Average pass duration: 8.0 minutes\n\nSat-2:\n  Contacts: 14\n  Total contact time: 109.8 minutes\n  Average pass duration: 7.8 minutes\n\nSat-3:\n  Contacts: 14\n  Total contact time: 114.1 minutes\n  Average pass duration: 8.2 minutes\n\nOverall Statistics:\n  Total contact time: 5.6 hours\n  Coverage: 23.4%\n\n======================================================================\nDetailed Pass Information\n======================================================================\n\nPass 1: Sat-1\n  Start:    2024-06-15T00:23:15.000000000 UTC\n  End:      2024-06-15T00:31:47.000000000 UTC\n  Duration: 8.5 minutes\n  Max Elev: 42.3\u00b0\n  AOS Az:   12.5\u00b0\n  LOS Az:   348.7\u00b0\n\nPass 2: Sat-2\n  Start:    2024-06-15T01:08:22.000000000 UTC\n  End:      2024-06-15T01:16:33.000000000 UTC\n  Duration: 8.2 minutes\n  Max Elev: 38.9\u00b0\n  AOS Az:   18.3\u00b0\n  LOS Az:   342.1\u00b0\n\n... (continues)\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#analysis-extensions","title":"Analysis Extensions","text":""},{"location":"examples/svalbard_ground_contacts.html#filter-by-time-of-day","title":"Filter by Time of Day","text":"<p>Add operational hour constraints for manned operations:</p> <pre><code># Daytime operations only (8 AM - 6 PM local solar time)\ndaytime_constraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=5.0),\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0)\n])\n\ndaytime_windows = bh.location_accesses(\n    [svalbard],\n    propagators,\n    search_start,\n    search_end,\n    daytime_constraint\n)\n\nprint(f\"Daytime passes: {len(daytime_windows)} (vs {len(windows)} total)\")\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#compute-link-budget-properties","title":"Compute Link Budget Properties","text":"<p>Add custom properties for communications analysis:</p> <pre><code>def link_budget_computer(epoch, sat_state_eci, sat_state_ecef, location_ecef):\n    \"\"\"Compute link budget parameters\"\"\"\n    # Slant range\n    sat_pos = sat_state_ecef[:3]\n    slant_range_m = np.linalg.norm(sat_pos - location_ecef)\n    slant_range_km = slant_range_m / 1000.0\n\n    # Free-space path loss (simplified, X-band 8 GHz)\n    freq_hz = 8e9\n    wavelength = 3e8 / freq_hz\n    fspl_db = 20 * np.log10(slant_range_m) + 20 * np.log10(freq_hz) - 147.55\n\n    # Range rate (for Doppler estimation)\n    sat_vel = sat_state_ecef[3:6]\n    range_vec = sat_pos - location_ecef\n    range_rate = np.dot(sat_vel, range_vec) / slant_range_m\n\n    return {\n        \"slant_range_km\": slant_range_km,\n        \"free_space_path_loss_db\": fspl_db,\n        \"range_rate_m_s\": range_rate,\n    }\n\n# Create property computer\ncomputer = bh.AccessPropertyComputer(link_budget_computer)\n\n# Compute with custom properties\nwindows_with_link = bh.location_accesses(\n    [svalbard],\n    propagators,\n    search_start,\n    search_end,\n    constraint,\n    property_computers=[computer]\n)\n\n# Access custom properties\nfor window in windows_with_link[:3]:\n    props = window.properties\n    print(f\"\\nPass: {window.window_open}\")\n    print(f\"  Slant range: {props['slant_range_km']:.1f} km\")\n    print(f\"  Path loss: {props['free_space_path_loss_db']:.1f} dB\")\n    print(f\"  Range rate: {props['range_rate_m_s']:.1f} m/s\")\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#high-elevation-passes-only","title":"High-Elevation Passes Only","text":"<p>Filter for overhead passes with better signal quality:</p> <pre><code># Only high-elevation passes (&gt; 30\u00b0)\nhigh_el_constraint = bh.ElevationConstraint(min_elevation_deg=30.0)\n\nhigh_el_windows = bh.location_accesses(\n    [svalbard],\n    propagators,\n    search_start,\n    search_end,\n    high_el_constraint\n)\n\nprint(f\"\\nHigh-elevation passes (&gt;30\u00b0): {len(high_el_windows)}\")\nprint(f\"  Percentage: {len(high_el_windows)/len(windows)*100:.1f}%\")\n\n# Average max elevation comparison\navg_max_el_all = np.mean([w.properties[\"elevation_max\"] for w in windows])\navg_max_el_high = np.mean([w.properties[\"elevation_max\"] for w in high_el_windows])\n\nprint(f\"  Avg max elevation (all): {avg_max_el_all:.1f}\u00b0\")\nprint(f\"  Avg max elevation (&gt;30\u00b0): {avg_max_el_high:.1f}\u00b0\")\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#export-to-geojson","title":"Export to GeoJSON","text":"<p>Save results for visualization in GIS tools:</p> <pre><code>import json\n\n# Create GeoJSON feature for station with pass statistics\nsvalbard_geojson = svalbard.to_geojson()\nsvalbard_geojson[\"properties\"][\"total_passes\"] = len(windows)\nsvalbard_geojson[\"properties\"][\"total_contact_hours\"] = total_contact_time / 3600\n\n# Create FeatureCollection\nfeature_collection = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [svalbard_geojson]\n}\n\n# Save to file\nwith open(\"svalbard_contacts.geojson\", \"w\") as f:\n    json.dump(feature_collection, f, indent=2)\n\nprint(\"Results saved to svalbard_contacts.geojson\")\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#performance-optimization","title":"Performance Optimization","text":"<p>For long analysis periods or many satellites, enable parallelization:</p> <pre><code># Configure parallel computation\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=True,     # Adaptive stepping for efficiency\n    parallel=True,           # Enable parallelization\n    num_threads=8           # Use 8 threads\n)\n\n# Compute with parallel configuration\nwindows_parallel = bh.location_accesses(\n    [svalbard],\n    propagators,\n    search_start,\n    search_end,\n    constraint,\n    config=config\n)\n\n# Results identical to sequential, just faster\nassert len(windows_parallel) == len(windows)\n</code></pre>"},{"location":"examples/svalbard_ground_contacts.html#real-world-considerations","title":"Real-World Considerations","text":"<p>Earth Orientation Parameters: - This example uses static EOP (all zeros) for simplicity - Production systems should use <code>FileEOPProvider</code> or <code>CachingEOPProvider</code> - Download current EOP data: <code>bh.download_standard_eop_file(path)</code></p> <p>TLE-Based Analysis: - Replace Keplerian propagators with SGP4 for real satellites: <pre><code>tle_line1 = \"1 25544U 98067A   ...\"\ntle_line2 = \"2 25544  51.6461 ...\"\ntle = bh.TLE.from_lines(tle_line1, tle_line2)\nprop_sgp4 = bh.SGPPropagator.from_tle(tle, 60.0).with_name(\"ISS\")\n</code></pre></p> <p>Elevation Masks: - Account for terrain obstructions or antenna limits: <pre><code>mask = [\n    (0.0, 10.0),     # North: 10\u00b0 due to building\n    (90.0, 5.0),     # East: 5\u00b0 clear\n    (180.0, 15.0),   # South: 15\u00b0 mountain\n    (270.0, 5.0),    # West: 5\u00b0 clear\n    (360.0, 10.0),   # Wrap to north\n]\nmask_constraint = bh.ElevationMaskConstraint(mask)\n</code></pre></p>"},{"location":"examples/svalbard_ground_contacts.html#see-also","title":"See Also","text":"<ul> <li>Access Computation Overview</li> <li>Constraints</li> <li>Locations</li> <li>Point Imaging Opportunities</li> <li>API Reference: Access Module</li> </ul>"},{"location":"learn/earth_orientation_data.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth Orientation Parameters are essential data for high-precision transformations between Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) reference frames. These parameters account for irregularities in Earth's rotation that cannot be modeled purely mathematically.</p> <p>Since many transformations depend on accurate EOP data, Brahe abstracts thsi complexity through a flexible global provider system. This allows users to initialize EOP data once and have it automatically applied in all relevant calculations without needing to pass EOP data explicitly with each function call.</p>"},{"location":"learn/earth_orientation_data.html#overview","title":"Overview","text":"<p>EOP data provides corrections for:</p> <ul> <li>UT1-UTC: Difference between Universal Time (based on Earth rotation) and Coordinated Universal Time</li> <li>Polar Motion (x, y): Variation in Earth's rotation axis position relative to its crust</li> <li>Celestial Pole Offsets (dX, dY): Corrections to precession-nutation models</li> <li>Length of Day (LOD): Variations in Earth's rotation rate</li> </ul>"},{"location":"learn/earth_orientation_data.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports multiple ways to access EOP data, each suited for different use cases.</p>"},{"location":"learn/earth_orientation_data.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Uses fixed EOP data, best for applications that don't require the most current data or when internet access is unavailable.</p> <pre><code>import brahe as bh\n\n# Use built-in static data\nprovider = bh.StaticEOPProvider.from_zero() # Sets all EOP values to zero\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>Testing and development</li> <li>Offline environments</li> <li>Applications where high precision is not critical</li> </ul>"},{"location":"learn/earth_orientation_data.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Loads EOP data from IERS (International Earth Rotation and Reference Systems Service) data files. Provides the most flexibility and control over EOP data sources.</p> <pre><code>import brahe as bh\n\n# Download latest EOP file\nbh.download_standard_eop_file(\"./eop_data/finals.all.iau2000.txt\")\n\n# Load from file\nprovider = bh.FileEOPProvider.from_file(\n    \"./eop_data/finals.all.iau2000.txt\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_file_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>You manage EOP file updates externally</li> <li>You need specific historical EOP data versions</li> <li>You want full control over data sources</li> <li>Minimal runtime overhead is critical</li> </ul>"},{"location":"learn/earth_orientation_data.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manages EOP file freshness by monitoring file age and downloading updates when data becomes stale. Combines the precision of file-based data with automatic updates.</p> <pre><code>import brahe as bh\n\n# Create provider that refreshes files older than 7 days\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,          # Manual refresh only\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n</code></pre> <p>When to use:</p> <ul> <li>Long-running services that need current EOP data for accuracy</li> <li>Applications where automatic updates are preferred over manual management</li> <li>Production systems requiring data freshness guarantees</li> </ul>"},{"location":"learn/earth_orientation_data.html#automatic-cache-management","title":"Automatic Cache Management","text":"<p>The <code>CachingEOPProvider</code> offers two refresh strategies:</p>"},{"location":"learn/earth_orientation_data.html#manual-refresh-recommended","title":"Manual Refresh (Recommended)","text":"<p>Check and update EOP data at controlled intervals:</p> <pre><code>import brahe as bh\nimport time\n\n# Create provider with manual refresh\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Use in application\nwhile True:\n    # Refresh at start of processing cycle\n    provider.refresh()\n\n    # Process data with current EOP\n    perform_calculations()\n\n    # Wait before next cycle\n    time.sleep(3600)  # 1 hour\n</code></pre> <p>Advantages:</p> <ul> <li>No performance overhead during data access</li> <li>Predictable refresh timing</li> <li>Better for batch processing and scheduled tasks</li> </ul>"},{"location":"learn/earth_orientation_data.html#auto-refresh","title":"Auto-Refresh","text":"<p>Automatically check and update on every data access:</p> <pre><code>import brahe as bh\n\n# Provider checks file age on every access\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,           # Check on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# EOP data automatically stays current\nut1_utc = provider.get_ut1_utc(mjd)\npm_x, pm_y = provider.get_pm(mjd)\n</code></pre> <p>Advantages:</p> <ul> <li>Guaranteed data freshness</li> <li>Simpler application code</li> <li>Suitable for long-running services</li> </ul> <p>Considerations:</p> <ul> <li>Small performance overhead on each access (microseconds)</li> <li>May trigger downloads during time-critical operations, potentially causing delays</li> <li>Better suited for applications where data access is not in tight loops</li> </ul>"},{"location":"learn/earth_orientation_data.html#monitoring-file-freshness","title":"Monitoring File Freshness","text":"<p>Track when EOP data was loaded and how old it is:</p> <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Check when file was loaded\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n\n# Check file age in seconds\nage_seconds = provider.file_age()\nage_hours = age_seconds / 3600\nage_days = age_seconds / 86400\n\nprint(f\"File age: {age_hours:.1f} hours ({age_days:.1f} days)\")\n\n# Refresh if needed\nif age_days &gt; 7:\n    print(\"EOP data is stale, refreshing...\")\n    provider.refresh()\n</code></pre>"},{"location":"learn/earth_orientation_data.html#eop-file-types","title":"EOP File Types","text":""},{"location":"learn/earth_orientation_data.html#standard-format-finals2000aall","title":"Standard Format (finals2000A.all)","text":"<p>Combined rapid + predicted data updated daily by IERS. Contains: - Historical data (final values) - Recent rapid service data - Predicted values for near future</p> <p>Use case: Most applications requiring current EOP data</p> <pre><code>provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#c04-format","title":"C04 Format","text":"<p>Long-term consistent EOP series from IERS C04 product. Updated less frequently but provides consistent historical record.</p> <p>Use case: Historical analysis, research, long-term consistency</p> <pre><code>provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/eopc04.txt\",\n    eop_type=\"C04\",\n    max_age_seconds=30 * 86400,  # 30 days (less frequent updates)\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#configuration-options","title":"Configuration Options","text":""},{"location":"learn/earth_orientation_data.html#interpolation","title":"Interpolation","text":"<p>Enable interpolation for smoother data between tabulated points:</p> <pre><code># With interpolation (recommended for most applications)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,  # Smooth interpolation\n    extrapolate=\"Hold\"\n)\n\n# Without interpolation (step function between points)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=False,  # No interpolation\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#extrapolation","title":"Extrapolation","text":"<p>Control behavior for dates outside the EOP data range:</p> <pre><code># Hold last value (recommended for most applications)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"  # Use last known value\n)\n\n# Return zero for out-of-range dates\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Zero\"  # Return 0.0\n)\n\n# Raise error for out-of-range dates\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Error\"  # Raise exception\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#recommended-refresh-intervals","title":"Recommended Refresh Intervals","text":"<p>Choose refresh intervals based on your accuracy requirements:</p> Application Type Recommended Interval Rationale Real-time operations 1-3 days Balance freshness with download overhead Batch processing 7 days Weekly updates sufficient for most accuracy needs Historical analysis 30+ days Data rarely changes for historical periods Testing/development No auto-refresh Use manual refresh as needed <pre><code>import brahe as bh\n\n# Real-time operations\nrealtime_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/realtime.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=2 * 86400,  # 2 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Batch processing\nbatch_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/batch.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Historical analysis\nhistorical_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/historical.txt\",\n    eop_type=\"C04\",\n    max_age_seconds=30 * 86400,  # 30 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#complete-example-long-running-service","title":"Complete Example: Long-Running Service","text":"<pre><code>import brahe as bh\nimport time\nfrom datetime import datetime\n\n# Initialize caching provider for service\nprovider = bh.CachingEOPProvider(\n    filepath=\"/var/lib/myapp/eop_data/finals.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=3 * 86400,  # 3 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider_from_caching_provider(provider)\n\nprint(\"Service started with EOP caching\")\nprint(f\"Initial EOP age: {provider.file_age() / 86400:.1f} days\")\n\n# Service loop\nwhile True:\n    # Refresh EOP data at start of cycle\n    try:\n        provider.refresh()\n        print(f\"EOP refreshed at {datetime.now()}\")\n    except Exception as e:\n        print(f\"EOP refresh failed: {e}\")\n        # Continue with existing data\n\n    # Perform calculations with current EOP data\n    for mjd in range(59000, 59100):\n        try:\n            # Frame transformations automatically use global EOP provider\n            ut1_utc = bh.get_global_ut1_utc(mjd)\n            pm_x, pm_y = bh.get_global_pm(mjd)\n\n            # Use for ECEF/ECI transformations\n            # ...\n\n        except Exception as e:\n            print(f\"Error processing MJD {mjd}: {e}\")\n\n    # Log current EOP file age\n    age_days = provider.file_age() / 86400\n    print(f\"EOP file age: {age_days:.1f} days\")\n\n    # Wait before next cycle (e.g., hourly processing)\n    time.sleep(3600)\n</code></pre>"},{"location":"learn/earth_orientation_data.html#thread-safety","title":"Thread Safety","text":"<p><code>CachingEOPProvider</code> is thread-safe and can be safely shared across multiple threads:</p> <pre><code>import brahe as bh\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Create shared provider\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\ndef process_epoch(mjd):\n    \"\"\"Process epoch using shared EOP provider\"\"\"\n    ut1_utc = provider.get_ut1_utc(mjd)\n    pm_x, pm_y = provider.get_pm(mjd)\n    # Process...\n    return result\n\n# Process epochs concurrently\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    mjds = range(59000, 60000)\n    results = list(executor.map(process_epoch, mjds))\n</code></pre>"},{"location":"learn/earth_orientation_data.html#see-also","title":"See Also","text":"<ul> <li>Frame Transformations - Using EOP data for coordinate frame conversions</li> <li>Time Systems - Understanding UT1, UTC, and other time systems</li> <li>API Reference: EOP Module - Complete API documentation</li> </ul>"},{"location":"learn/tle_and_sgp.html","title":"Two-Line Elements (TLE) and Simplified General Perturbations (SGP) Models","text":"<p>Two-Line Element (TLE) sets are a standardized data format for distributing satellite orbital elements. Originally developed by NORAD (North American Aerospace Defense Command) in the 1960s, TLEs remain the most widely used format for sharing satellite ephemeris data.</p> Warning <p>TLEs are designed specifically for use with the Simplified General Perturbation 4 (SGP4) orbit propagation models. They are not suitable for other propagation methods without conversion. For high-precision applications, consider using osculating elements or numerical propagators.</p> Abstract <p>There is an upcoming problem of running out of NORAD IDs. The current format supports 5-digit IDs (up to 99999). Space Force has officially augmented the format my moving to something known as \"alpha-5\" TLEs, which use a letter as the leading character to extend the range. This is not yet widely adopted.</p> <p>Given the limited representational capacity of TLEs, there is a push to move to more modern formats such as General Perturbations (GP) elements.</p>"},{"location":"learn/tle_and_sgp.html#overview","title":"Overview","text":"<p>A TLE encodes the orbital state of a satellite at a specific epoch, along with drag and perturbation coefficients needed for propagation using the SGP4/SDP4 models.</p>"},{"location":"learn/tle_and_sgp.html#format-variations","title":"Format Variations","text":""},{"location":"learn/tle_and_sgp.html#two-line-element-2le","title":"Two-Line Element (2LE)","text":"<p>The standard format consists of two 69-character lines:</p> <pre><code>1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\n2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\n</code></pre> <p>Line 1 contains: - Satellite catalog number (NORAD ID) - International designator - Epoch (year and day of year with fractional day) - First derivative of mean motion (ballistic coefficient) - Second derivative of mean motion - BSTAR drag term - Element set number - Checksum</p> <p>Line 2 contains: - Satellite catalog number (repeated) - Inclination (degrees) - Right ascension of ascending node (degrees) - Eccentricity (decimal point assumed) - Argument of perigee (degrees) - Mean anomaly (degrees) - Mean motion (revolutions per day) - Revolution number at epoch - Checksum</p>"},{"location":"learn/tle_and_sgp.html#three-line-element-3le","title":"Three-Line Element (3LE)","text":"<p>The extended format adds a satellite name line:</p> <pre><code>ISS (ZARYA)\n1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\n2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\n</code></pre> <p>The name line (line 0) can be up to 24 characters and helps identify satellites when working with large datasets.</p>"},{"location":"learn/tle_and_sgp.html#checksums","title":"Checksums","text":"<p>Each TLE line ends with a modulo-10 checksum: - Computed from all characters in the line (excluding the checksum itself) - Digits contribute their value (<code>0-9</code>) - Minus signs (<code>-</code>) contribute 1 - All other characters contribute 0 - Sum taken modulo 10</p> <p>Brahe automatically validates checksums when parsing TLEs and computes them when creating new TLE lines.</p>"},{"location":"learn/tle_and_sgp.html#tle-limitations","title":"TLE Limitations","text":""},{"location":"learn/tle_and_sgp.html#accuracy-degradation","title":"Accuracy Degradation","text":"<p>TLEs are mean orbital elements, not osculating (instantaneous) elements. They're designed to work specifically with SGP4/SDP4 propagators and may give incorrect results with other propagation methods. They were designed to provide reasonable accuracy over short periods of time to support general object tracking. Because they fit a mean-element model to observations, they inherently do not model the true orbit perfectly and contain some level of error, even at epoch.</p> <p>Typical accuracy: - Within hours of epoch: ~1 km position error - Within days of epoch: ~1-10 km position error - Beyond 1-2 weeks: Accuracy degrades significantly</p> <p>For high-precision applications, use osculating elements or numerical propagators with force models.</p>"},{"location":"learn/tle_and_sgp.html#atmospheric-drag","title":"Atmospheric Drag","text":"<p>The BSTAR drag coefficient in line 1 is a fitted parameter, not a physical measurement. It compensates for: - Atmospheric density variations - Satellite ballistic properties - Solar activity effects</p> <p>TLEs for the same satellite issued at different times may have different BSTAR values as the atmosphere and solar conditions change.</p>"},{"location":"learn/tle_and_sgp.html#data-currency","title":"Data Currency","text":"<p>TLEs become stale quickly due to: - Atmospheric drag (LEO satellites) - Solar radiation pressure - Gravitational perturbations - Orbital maneuvers</p> <p>Recommended refresh intervals: - LEO satellites: Daily to weekly - MEO satellites: Weekly - GEO satellites: Monthly</p>"},{"location":"learn/tle_and_sgp.html#tle-data-sources","title":"TLE Data Sources","text":"<p>There are a few primary sources for obtaining TLE data:</p>"},{"location":"learn/tle_and_sgp.html#celestrak","title":"CelesTrak","text":"<p>Maintained by T.S. Kelso, CelesTrak provides free TLE data grouped by satellite type and mission. Access via Brahe's datasets module:</p> <pre><code>import brahe as bh\n\n# Get GPS constellation TLEs\ngps_ephemeris = bh.datasets.celestrak.get_ephemeris(\"gnss\")\n\n# Get recently launched satellites\nrecent = bh.datasets.celestrak.get_ephemeris(\"last-30-days\")\n</code></pre>"},{"location":"learn/tle_and_sgp.html#working-with-tles-in-brahe","title":"Working with TLEs in Brahe","text":""},{"location":"learn/tle_and_sgp.html#parsing-and-validation","title":"Parsing and Validation","text":"<pre><code>import brahe as bh\n\n# Validate TLE format\nline1 = \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\"\n\nis_valid = bh.validate_tle_lines(line1, line2)\n\n# Extract epoch\nepoch = bh.epoch_from_tle(tle)\n\n# Convert to Keplerian elements\nkeplerian = bh.keplerian_elements_from_tle(tle)\n# Returns: [a, e, i, raan, argp, M] in SI units (meters, radians)\n</code></pre>"},{"location":"learn/tle_and_sgp.html#propagation","title":"Propagation","text":"<p>Because SGP4 is a semi-analytical model, the SGPPropagator class is used to propagate TLEs is considered an \"Analytic Propagator\" in Brahe, which provides direct computation of the orbital state at any epoch without numerical integration.</p> <p>The following methods are available: - <code>SGPPropagtor.state(epoch)</code> - Get state vector at specified epoch in the native TLE frame (TEME) - <code>SGPPropagator.state_eci(epoch)</code> - Get state vector in ECI frame (GCRF) - <code>SGPPropagator.state_ecef(epoch)</code> - Get state vector in ECEF frame (ITRF) - <code>SGPPropagator.state_pef(epoch)</code> - Get position in the intermediate Psudo Earth-Fixed (PEF) frame</p> <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a Two-Line Element (TLE) for a satellite\ntle = bh.SGPPropagator.from_3le(\n    \"ISS (ZARYA)\",\n    \"1 25544U 98067A   21001.00000000  .00002182  00000-0  41420-4 0  9990\",\n    \"2 25544  51.6461 339.8014 0002571  34.5857 120.4689 15.48919393265104\",\n    60.0 # Propagator step size. Only used for auto-stepping computations\n)\n\n# Propagate to a specific epoch\nepc = bh.Epoch(2024, 6, 1, 0, 0, 0.0, bh.TimeSystem.UTC)\n\nstate = tle.state_eci(epc)  # Returns [x, y, z, vx, vy, vz] in meters and m/s\n\n# You can also get the state in other frames and formats\nstate_ecef = tle.state_ecef(epc)  # ECEF frame\n</code></pre>"},{"location":"learn/tle_and_sgp.html#batch-processing","title":"Batch Processing","text":"<pre><code>import brahe as bh\n\n# Get ephemeris and initialize propagators directly\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\n    \"gnss\",\n    step_size=60.0\n)\n\n# Propagate all satellites to same epoch\nepoch = bh.Epoch.from_datetime(2021, 1, 2, 12, 0, 0, tsys=\"UTC\")\nstates = [prop.state(epoch) for prop in propagators]\n</code></pre>"},{"location":"learn/tle_and_sgp.html#see-also","title":"See Also","text":"<ul> <li>SGP Propagation - Using TLEs for orbit propagation</li> <li>Datasets - Downloading satellite ephemeris data</li> <li>TLE Functions API Reference - Functions for manipulating and working with TLEs</li> </ul>"},{"location":"learn/access_computation/index.html","title":"Access Computation","text":"<p>Access computation determines when and under what conditions satellites can observe or communicate with ground locations. This is fundamental for mission planning, ground station contact scheduling, imaging opportunity analysis, and communications link budgets.</p> <p>Brahe provides a comprehensive access computation system that handles the geometric complexity of satellite-ground visibility while offering flexibility through constraints, extensible properties, and performance optimization.</p>"},{"location":"learn/access_computation/index.html#overview","title":"Overview","text":"<p>Access computation involves:</p> <ul> <li>Geometric visibility: Is the satellite above the horizon from the ground location's perspective?</li> <li>Constraint satisfaction: Do viewing angles, lighting conditions, or other requirements meet mission needs?</li> <li>Time window identification: When do access periods start and end?</li> <li>Property computation: What are the specific characteristics (elevation, azimuth, range, etc.) during access?</li> </ul>"},{"location":"learn/access_computation/index.html#core-concepts","title":"Core Concepts","text":""},{"location":"learn/access_computation/index.html#locations","title":"Locations","text":"<p>Locations represent ground positions that satellites can access:</p> <ul> <li>PointLocation: Discrete points (ground stations, imaging targets)</li> <li>PolygonLocation: Areas of interest (countries, regions, imaging swaths)</li> </ul> <p>All locations support: - Geodetic coordinates (latitude, longitude, altitude) - ECEF coordinates (Earth-fixed Cartesian) - GeoJSON interoperability - Extensible properties via metadata dictionary - Identifiable trait (name, ID, UUID)</p> <p>See Locations for details.</p>"},{"location":"learn/access_computation/index.html#constraints","title":"Constraints","text":"<p>Constraints define access criteria that must be satisfied:</p> <p>Built-in Constraints: - <code>ElevationConstraint</code>: Minimum/maximum elevation angles - <code>ElevationMaskConstraint</code>: Azimuth-dependent elevation masks - <code>OffNadirConstraint</code>: Satellite pointing angles - <code>LookDirectionConstraint</code>: Left/right/either looking direction - <code>LocalTimeConstraint</code>: Time-of-day access windows - <code>OrbitTypeConstraint</code>: Ascending/descending pass filtering</p> <p>Logical Composition: - <code>ConstraintAll</code>: AND logic (all constraints must be satisfied) - <code>ConstraintAny</code>: OR logic (any constraint must be satisfied) - <code>ConstraintNot</code>: NOT logic (constraint must NOT be satisfied)</p> <p>Custom Constraints: - Python-defined constraints via <code>AccessPropertyComputer</code> - Arbitrary logic based on epoch, satellite state, and location</p> <p>See Constraints for details.</p>"},{"location":"learn/access_computation/index.html#access-windows","title":"Access Windows","text":"<p>Access windows represent periods when constraints are satisfied:</p> <pre><code>import brahe as bh\n\n# Each window provides:\nwindow.window_open      # Start epoch\nwindow.window_close     # End epoch\nwindow.duration         # Duration in seconds\nwindow.location_id      # Location identifier\nwindow.propagator_id    # Satellite identifier\nwindow.properties       # Computed properties during access\n</code></pre>"},{"location":"learn/access_computation/index.html#access-properties","title":"Access Properties","text":"<p>Properties characterize access windows with geometric and custom metrics:</p> <p>Built-in Properties: - <code>elevation</code>: Satellite elevation angle (degrees) - <code>azimuth</code>: Satellite azimuth angle (degrees) - <code>range</code>: Satellite-to-location distance (meters) - <code>range_rate</code>: Range rate of change (m/s) - <code>off_nadir</code>: Satellite off-nadir angle (degrees) - <code>look_direction</code>: LEFT/RIGHT/BOTH viewing geometry</p> <p>Custom Properties: - Compute arbitrary metrics using Python functions - Access to epoch, satellite state (ECI/ECEF), and location - Properties stored in window for post-processing</p> <p>See Computation for details.</p>"},{"location":"learn/access_computation/index.html#basic-workflow","title":"Basic Workflow","text":"<ol> <li>Define locations: Create ground sites or areas of interest</li> <li>Setup propagators: Initialize satellite orbit propagators</li> <li>Configure constraints: Specify access criteria</li> <li>Compute accesses: Find time windows when constraints are satisfied</li> <li>Analyze results: Extract properties and schedule activities</li> </ol> <p>Example:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP provider\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider_from_static_provider(eop)\n\n# Define ground station\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\")\n\n# Create satellite propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite-1\")\n\n# Define constraint (10\u00b0 minimum elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute accesses over 24 hours\nwindows = bh.location_accesses(\n    [svalbard],\n    [propagator],\n    epoch,\n    epoch + 86400.0,\n    constraint\n)\n\nprint(f\"Found {len(windows)} access windows\")\nfor window in windows:\n    duration_min = window.duration / 60.0\n    print(f\"  {window.window_open} - {window.window_close} ({duration_min:.1f} min)\")\n</code></pre>"},{"location":"learn/access_computation/index.html#performance-optimization","title":"Performance Optimization","text":"<p>Access computation can be computationally intensive for large-scale analyses. Brahe provides several optimization strategies:</p>"},{"location":"learn/access_computation/index.html#parallelization","title":"Parallelization","text":"<p>By default, access computation runs in parallel using 90% of available CPU cores:</p> <pre><code># Default: parallel with 90% of cores\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start_epoch,\n    end_epoch,\n    constraint\n)\n\n# Explicit configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=False,\n    parallel=True,        # Enable parallelization\n    num_threads=None      # Use global default (90% of cores)\n)\n\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start_epoch,\n    end_epoch,\n    constraint,\n    config=config\n)\n</code></pre>"},{"location":"learn/access_computation/index.html#thread-pool-configuration","title":"Thread Pool Configuration","text":"<p>Control parallelization globally or per-computation:</p> <pre><code># Set global thread pool (must be called before any parallel operations)\nbh.set_max_threads(4)\n\n# Or configure per-computation\nconfig = bh.AccessSearchConfig(\n    parallel=True,\n    num_threads=8  # Use 8 threads for this computation\n)\n\n# Or disable parallelization entirely\nconfig = bh.AccessSearchConfig(parallel=False)\n</code></pre>"},{"location":"learn/access_computation/index.html#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>Adaptive stepping increases efficiency by using larger time steps when constraints are far from satisfied:</p> <pre><code>config = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=True,           # Enable adaptive stepping\n    adaptive_fraction=0.75,       # Aggressiveness factor\n    parallel=True\n)\n</code></pre> <p>When adaptive stepping helps: - Long search periods with sparse accesses - Tight elevation constraints (e.g., &gt; 60\u00b0) - Complex composed constraints</p> <p>When to disable: - Very frequent accesses (LEO constellation to global coverage) - Short search periods - When deterministic timing is required</p>"},{"location":"learn/access_computation/index.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch processing: Compute multiple location-satellite pairs in one call</li> <li>Pre-filter candidates: Use geometric screening before detailed constraint checking</li> <li>Adjust time step: Balance between accuracy and performance</li> <li>Use parallelization: Leverage multiple cores for large problems</li> <li>Cache propagators: Reuse state providers across multiple access computations</li> </ol>"},{"location":"learn/access_computation/index.html#use-cases","title":"Use Cases","text":"<p>Ground Station Contact Scheduling: - Find all passes above minimum elevation - Filter by local time constraints (operational hours) - Compute pass characteristics (max elevation, duration)</p> <p>Imaging Opportunity Analysis: - Identify when targets are within sensor field of view - Filter by off-nadir angle and look direction - Compute sun angles and lighting conditions</p> <p>Communications Link Analysis: - Determine line-of-sight windows - Compute range and range-rate for Doppler estimation - Assess elevation angles for link margin</p> <p>Constellation Coverage Analysis: - Analyze global or regional coverage - Identify coverage gaps - Optimize constellation design</p>"},{"location":"learn/access_computation/index.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/access_computation/index.html#multiple-locations-and-satellites","title":"Multiple Locations and Satellites","text":"<pre><code># Define multiple ground stations\nlocations = [\n    bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\"),\n    bh.PointLocation(-64.5, -31.5, 0.0).with_name(\"Malargue\"),\n    bh.PointLocation(-117.2, 34.1, 0.0).with_name(\"Goldstone\"),\n]\n\n# Define constellation\npropagators = []\nfor i in range(5):\n    oe = np.array([bh.R_EARTH + 550e3, 0.001, 97.8, i*30.0, 0.0, i*45.0])\n    state = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(f\"Sat-{i}\")\n    propagators.append(prop)\n\n# Compute all location-satellite combinations\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Windows are sorted by opening time\n# Each window has location_id and propagator_id for filtering\n</code></pre>"},{"location":"learn/access_computation/index.html#complex-constraints","title":"Complex Constraints","text":"<pre><code># Combine multiple constraints with AND logic\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),  # Daylight operations\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n\n# OR logic: Either high elevation OR ascending pass\nconstraint = bh.ConstraintAny([\n    bh.ElevationConstraint(min_elevation_deg=60.0),\n    bh.OrbitTypeConstraint(orbit_type=bh.AscDsc.ASC),\n])\n\n# NOT logic: Exclude nighttime passes\ndaytime = bh.ConstraintNot(\n    bh.LocalTimeConstraint(min_hour=18.0, max_hour=8.0)  # NOT nighttime\n)\n</code></pre>"},{"location":"learn/access_computation/index.html#custom-property-computation","title":"Custom Property Computation","text":"<pre><code>import math\n\n# Define custom property computer\ndef compute_slant_range_km(epoch, sat_state_eci, sat_state_ecef, location_ecef):\n    \"\"\"Compute slant range in kilometers\"\"\"\n    range_m = np.linalg.norm(sat_state_ecef[:3] - location_ecef)\n    return {\"slant_range_km\": range_m / 1000.0}\n\n# Create property computer\ncomputer = bh.AccessPropertyComputer(compute_slant_range_km)\n\n# Compute accesses with custom properties\nconfig = bh.AccessSearchConfig()\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start,\n    end,\n    constraint,\n    config=config,\n    property_computers=[computer]\n)\n\n# Access custom properties\nfor window in windows:\n    props = window.properties\n    print(f\"Slant range: {props['slant_range_km']:.1f} km\")\n</code></pre>"},{"location":"learn/access_computation/index.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and GeoJSON support</li> <li>Constraints - Built-in and custom constraint types</li> <li>Computation - Access algorithms and property computation</li> <li>Example: Svalbard Ground Contacts - Complete ground station example</li> <li>Example: Point Imaging Opportunities - Imaging scenario</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/computation.html","title":"Access Computation","text":"<p>This document explains how Brahe computes access windows\u2014the algorithms, design decisions, and performance considerations that make access computation both accurate and efficient.</p>"},{"location":"learn/access_computation/computation.html#overview","title":"Overview","text":"<p>Access computation involves finding time periods when a satellite can observe or communicate with a ground location while satisfying specified constraints. This is fundamentally a root-finding problem: we need to identify when constraint satisfaction transitions from <code>False</code> to <code>True</code> (window opens) and from <code>True</code> to <code>False</code> (window closes).</p>"},{"location":"learn/access_computation/computation.html#algorithm-overview","title":"Algorithm Overview","text":"<p>Brahe uses a two-phase approach:</p> <ol> <li>Coarse grid search: Quickly identify candidate access periods using large time steps</li> <li>Bisection refinement: Precisely locate window boundaries using binary search</li> </ol> <p>This hybrid approach balances speed (coarse search) with precision (refinement).</p>"},{"location":"learn/access_computation/computation.html#phase-1-coarse-grid-search","title":"Phase 1: Coarse Grid Search","text":""},{"location":"learn/access_computation/computation.html#basic-algorithm","title":"Basic Algorithm","text":"<p>The coarse search evaluates constraints at regular time intervals to identify candidate access periods.</p>"},{"location":"learn/access_computation/computation.html#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>For improved efficiency, Brahe optionally adapts the time step based on orbital period:</p> <pre><code># Configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=True,\n    adaptive_fraction=0.75\n)\n</code></pre> <p>How it works: 1. Compute orbital period from semi-major axis 2. Set step size = <code>orbital_period * adaptive_fraction</code> 3. Use this step for first step immediately after finding a candidate window because it's unlikely for LEO to have another access until the next orbit.</p> <p>When to use: - When computing accesses for LEO satellites - Long search periods (days to weeks) - Computational efficiency is critical</p> <p>When to avoid: - Non-LEO orbits (GEO, HEO) where orbital period is very long</p>"},{"location":"learn/access_computation/computation.html#phase-2-bisection-refinement","title":"Phase 2: Bisection Refinement","text":"<p>Once candidates are identified, bisection search refines boundaries to high precision.</p>"},{"location":"learn/access_computation/computation.html#bisection-algorithm","title":"Bisection Algorithm","text":""},{"location":"learn/access_computation/computation.html#window-opening-vs-closing","title":"Window Opening vs. Closing","text":"<p>Bisection refines both boundaries:</p> <ol> <li>Window open: Refine between last <code>False</code> and first <code>True</code> from coarse search</li> <li>Window close: Refine between last <code>True</code> and first <code>False</code> from coarse search</li> </ol> <p>Each window requires two bisection searches (open and close boundaries).</p>"},{"location":"learn/access_computation/computation.html#phase-3-property-computation","title":"Phase 3: Property Computation","text":"<p>After window boundaries are refined, properties are computed to characterize the access.</p>"},{"location":"learn/access_computation/computation.html#core-properties","title":"Core Properties","text":"<p>Computed automatically for every window:</p> <pre><code># At window open\nazimuth_open = compute_azimuth(sat_pos, location)\n\n# At window close\nazimuth_close = compute_azimuth(sat_pos, location)\n\n# Throughout window (via sampling)\nelevation_max = max(compute_elevation(sat_pos, location) for t in window)\nelevation_min = min(compute_elevation(sat_pos, location) for t in window)\n\n# At window midtime\noff_nadir_min = compute_off_nadir(sat_pos, sat_vel, location)\nlocal_time = compute_local_solar_time(location, epoch)\nlook_direction = compute_look_direction(sat_vel, location_vector)\nasc_dsc = compute_ascending_or_descending(sat_state)\n</code></pre>"},{"location":"learn/access_computation/computation.html#custom-properties","title":"Custom Properties","text":"<p>User-defined property computers can compute additional window properties by subclassing <code>AccessPropertyComputer</code>:</p> <pre><code>import brahe as bh\nimport numpy as np\n\nclass SlantRangeComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes slant range and related metrics for each access window.\n    \"\"\"\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"\n        Compute slant range properties.\n\n        Args:\n            window: AccessWindow with timing information\n            satellite_state_ecef: Satellite state [x,y,z,vx,vy,vz] at window midtime (m, m/s)\n            location_ecef: Location position [x,y,z] (m)\n\n        Returns:\n            dict: Property name -&gt; value mapping\n        \"\"\"\n        sat_pos = satellite_state_ecef[:3]\n        slant_range_m = np.linalg.norm(sat_pos - location_ecef)\n\n        return {\n            \"slant_range_km\": slant_range_m / 1000.0,\n            \"within_2000km\": slant_range_m &lt; 2000e3,\n            \"slant_range_category\": self._categorize_range(slant_range_m)\n        }\n\n    def property_names(self):\n        \"\"\"Return list of property names this computer produces\"\"\"\n        return [\"slant_range_km\", \"within_2000km\", \"slant_range_category\"]\n\n    def _categorize_range(self, range_m):\n        \"\"\"Helper to categorize range\"\"\"\n        if range_m &lt; 1000e3:\n            return \"close\"\n        elif range_m &lt; 2000e3:\n            return \"medium\"\n        else:\n            return \"far\"\n\n# Use with access computation\ncomputer = SlantRangeComputer()\nwindows = bh.location_accesses(\n    locations, propagators, start, end,\n    constraint,\n    property_computers=[computer]\n)\n\n# Access custom properties\nfor window in windows:\n    slant_range = window.properties.additional[\"slant_range_km\"]\n    category = window.properties.additional[\"slant_range_category\"]\n    print(f\"Range: {slant_range:.1f} km ({category})\")\n</code></pre>"},{"location":"learn/access_computation/computation.html#advanced-property-computer","title":"Advanced Property Computer","text":"<pre><code>class DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes Doppler shift at window midtime.\n\n    Useful for communications link budget analysis.\n    \"\"\"\n\n    def __init__(self, frequency_hz=2.4e9):\n        \"\"\"\n        Args:\n            frequency_hz: Carrier frequency in Hz (default: 2.4 GHz)\n        \"\"\"\n        self.frequency = frequency_hz\n        self.c = 299792458.0  # Speed of light (m/s)\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"Compute Doppler shift\"\"\"\n        # Extract satellite velocity\n        sat_vel = satellite_state_ecef[3:6]\n\n        # Line-of-sight vector\n        sat_pos = satellite_state_ecef[:3]\n        los = location_ecef - sat_pos\n        los_unit = los / np.linalg.norm(los)\n\n        # Radial velocity (positive = approaching)\n        radial_vel = np.dot(sat_vel, los_unit)\n\n        # Doppler shift\n        doppler_hz = -(radial_vel / self.c) * self.frequency\n\n        return {\n            \"doppler_shift_hz\": doppler_hz,\n            \"doppler_shift_khz\": doppler_hz / 1000.0,\n            \"radial_velocity_mps\": radial_vel,\n            \"is_approaching\": radial_vel &gt; 0.0\n        }\n\n    def property_names(self):\n        return [\n            \"doppler_shift_hz\",\n            \"doppler_shift_khz\",\n            \"radial_velocity_mps\",\n            \"is_approaching\"\n        ]\n</code></pre>"},{"location":"learn/access_computation/computation.html#time-series-properties","title":"Time Series Properties","text":"<p>Property computers can return time series data:</p> <pre><code>class ElevationProfileComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes elevation angle profile throughout the window.\n    \"\"\"\n\n    def __init__(self, sample_rate_sec=10.0):\n        self.sample_rate = sample_rate_sec\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"\n        Sample elevation throughout window.\n\n        Note: This is called at window midtime, so for time series\n        you would need to resample the trajectory or use the StateProvider.\n        This is a simplified example.\n        \"\"\"\n        # In real implementation, would resample throughout window\n        # For now, just return midtime elevation\n        from brahe.access import compute_elevation\n\n        midtime_elevation = compute_elevation(\n            satellite_state_ecef[:3],\n            location_ecef\n        )\n\n        return {\n            \"elevation_profile\": {\n                \"times\": [0.0],  # Seconds from window start\n                \"values\": [midtime_elevation]\n            },\n            \"peak_elevation\": midtime_elevation\n        }\n\n    def property_names(self):\n        return [\"elevation_profile\", \"peak_elevation\"]\n</code></pre> <p>When to use property computers: - Computing derived metrics for link budgets or mission analysis - Recording time-series data for later analysis - Annotating windows with mission-specific information - Filtering windows based on computed properties</p> <p>Performance note: Property computers are called once per window at the midtime. For expensive computations, this is more efficient than computing properties for every constraint evaluation.</p>"},{"location":"learn/access_computation/computation.html#complete-pipeline","title":"Complete Pipeline","text":"<p>The full access computation pipeline:</p> <pre><code>1. For each (location, propagator) pair:\n\n   2. Coarse grid search\n      \u2193\n      [Candidate windows with ~60s boundary uncertainty]\n\n   3. For each candidate:\n\n      4. Bisection refinement (window open)\n         \u2193\n      5. Bisection refinement (window close)\n         \u2193\n         [Precise window boundaries within 0.01s]\n\n      6. Compute core properties\n         \u2193\n      7. Compute custom properties (if any)\n         \u2193\n         [Complete AccessWindow]\n\n8. Sort all windows by opening time\n   \u2193\n   [Final sorted list of AccessWindow objects]\n</code></pre>"},{"location":"learn/access_computation/computation.html#parallelization","title":"Parallelization","text":"<p>For large-scale problems, Brahe parallelizes access computation across location-propagator pairs.</p> <p>Access computation is parallel by default, utilizing up to 90% of available CPU cores on the machine. This can be disabled or configured as needed.</p> <p>Parallelization occurs at the pair level: - Each (location, propagator) pair is independent - No shared state during window finding - Results aggregated and sorted after all pairs complete</p> <p>Performance scaling: - Near-linear speedup for many pairs (e.g., 10 locations \u00d7 10 satellites = 100 pairs) - Limited benefit for single pair (no parallelism)</p>"},{"location":"learn/access_computation/computation.html#configuration","title":"Configuration","text":"<pre><code># Default: parallel with 90% of cores\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Explicit control\nconfig = bh.AccessSearchConfig(\n    parallel=True,        # Enable parallelization\n    num_threads=4         # Use 4 threads (overrides global default)\n)\n\nwindows = bh.location_accesses(\n    locations, propagators, start, end, constraint, config=config\n)\n\n# Sequential (debugging or reproducibility)\nconfig = bh.AccessSearchConfig(parallel=False)\n</code></pre> <p>Thread pool management: <pre><code># Set global default (must be called before any parallel operations)\nbh.set_max_threads(8)\n\n# Query current setting\nnum_threads = bh.get_max_threads()\n</code></pre></p>"},{"location":"learn/access_computation/computation.html#optimization-guidelines","title":"Optimization Guidelines","text":"<p>Choose appropriate time step: - Smaller step: more accurate, slower - Larger step: faster, may miss short windows - Rule of thumb: <code>dt \u2264 min_expected_window_duration / 3</code></p> <p>Use adaptive stepping when: - Search period &gt;&gt; orbital period - LEO satellites</p> <p>Use parallelization when: - Multiple location-propagator pairs (N \u00d7 M &gt; 10) - Multiple CPU cores available</p> <p>Avoid parallelization when: - Single location-propagator pair - Custom constraints use external resources (databases, files)</p>"},{"location":"learn/access_computation/computation.html#accuracy-considerations","title":"Accuracy Considerations","text":""},{"location":"learn/access_computation/computation.html#numerical-precision","title":"Numerical Precision","text":"<p>Bisection tolerance: - Default 0.01s provides sub-second precision - Can be tightened to 0.001s or more for high-precision applications - Diminishing returns below ~0.001s due to floating-point limits and state propagation errors</p>"},{"location":"learn/access_computation/computation.html#implementation-notes","title":"Implementation Notes","text":""},{"location":"learn/access_computation/computation.html#state-provider-architecture","title":"State Provider Architecture","text":"<p>Access computation works with any <code>StateProvider</code>:</p> <pre><code>pub trait StateProvider {\n    fn state(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n    fn state_eci(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n    fn state_ecef(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n}\n</code></pre> <p>This abstraction allows: - Analytical propagators (Keplerian, SGP4) - Pre-computed trajectories (OrbitTrajectory) - Hybrid approaches (mix propagator types) - Future propagators (numerical integrators, etc.)</p> <p>All use the same access computation code\u2014no special-casing required.</p>"},{"location":"learn/access_computation/computation.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and properties</li> <li>Constraints - Constraint system and composition</li> <li>Access Computation Index - Overview and usage examples</li> <li>Example: Svalbard Ground Contacts - Complete workflow</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/constraints.html","title":"Constraints","text":"<p>Constraints define the criteria that must be satisfied for satellite access to ground locations. Brahe provides a comprehensive constraint system with built-in geometric constraints, logical composition operators, and support for custom user-defined constraints.</p>"},{"location":"learn/access_computation/constraints.html#overview","title":"Overview","text":"<p>Access constraints answer questions like:</p> <ul> <li>\"Is the satellite above 10\u00b0 elevation?\"</li> <li>\"Is the satellite looking in the right direction?\"</li> <li>\"Is it daytime at the ground location?\"</li> <li>\"Are all of these conditions satisfied simultaneously?\"</li> </ul> <p>Constraints are evaluated at each time step during access computation to determine when access windows open and close.</p>"},{"location":"learn/access_computation/constraints.html#core-concept","title":"Core Concept","text":"<p>All constraints implement the <code>AccessConstraint</code> trait, which provides:</p> <pre><code>def evaluate(epoch, sat_state_ecef, location_ecef) -&gt; bool:\n    \"\"\"\n    Returns True if constraint is satisfied, False otherwise.\n\n    Args:\n        epoch: Time of evaluation\n        sat_state_ecef: Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\n        location_ecef: Location in ECEF [x, y, z] (meters)\n    \"\"\"\n    pass\n</code></pre> <p>This simple interface enables powerful composition and extension.</p>"},{"location":"learn/access_computation/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevation-constraints","title":"Elevation Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevationconstraint","title":"ElevationConstraint","text":"<p>Constrains access based on satellite elevation angle above the local horizon:</p> <pre><code>import brahe as bh\n\n# Minimum elevation only (typical ground station)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Both bounds (avoid low and zenith angles)\nconstraint = bh.ElevationConstraint(\n    min_elevation_deg=10.0,\n    max_elevation_deg=85.0\n)\n\n# Maximum only (avoid zenith)\nconstraint = bh.ElevationConstraint(max_elevation_deg=80.0)\n</code></pre> <p>When to use: - Ground station visibility (min elevation &gt; 5-10\u00b0) - Link budget requirements (min elevation affects signal strength) - Avoiding multipath (exclude low elevations) - Zenith avoidance for dish antennas (max elevation)</p> <p>Design note: At least one bound (min or max) must be specified. An unbounded constraint would match everything and serves no purpose.</p>"},{"location":"learn/access_computation/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":"<p>Azimuth-dependent elevation masks for terrain obstructions or antenna limitations:</p> <pre><code># Define mask as (azimuth_deg, min_elevation_deg) pairs\nmask = [\n    (0.0, 10.0),     # North: 10\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 15.0),   # South: 15\u00b0 minimum (mountain)\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n    (360.0, 10.0),   # Wrap to north\n]\n\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Key features: - Linear interpolation between azimuth points - Automatic wrapping at 0\u00b0/360\u00b0 - Must be sorted by azimuth in ascending order</p> <p>When to use: - Ground stations with terrain obstructions - Antenna mechanical limitations - Building/structure interference - Regulatory restrictions by direction</p>"},{"location":"learn/access_computation/constraints.html#satellite-pointing-constraints","title":"Satellite Pointing Constraints","text":""},{"location":"learn/access_computation/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":"<p>Constrains satellite off-nadir angle (angle between satellite-to-location vector and nadir):</p> <pre><code># Imaging sensor with 30\u00b0 max off-nadir\nconstraint = bh.OffNadirConstraint(\n    min_off_nadir_deg=0.0,\n    max_off_nadir_deg=30.0\n)\n\n# Minimum off-nadir (avoid direct nadir)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=5.0)\n</code></pre> <p>When to use: - Imaging missions with sensor field-of-view limits - Avoiding geometry that causes distortion - Nadir-pointing vs. off-nadir pointing modes - Synthetic aperture radar (SAR) geometry requirements</p> <p>Geometry note: 0\u00b0 off-nadir = directly below satellite (nadir pointing). Larger angles = more oblique viewing.</p>"},{"location":"learn/access_computation/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":"<p>Constrains satellite look direction (left/right relative to velocity vector):</p> <pre><code># Right-looking only\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT)\n\n# Left-looking only\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.LEFT)\n\n# Either direction (permissive)\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.BOTH)\n</code></pre> <p>When to use: - Imaging satellites with fixed-side sensors - SAR missions with specific look-direction requirements - Avoiding sun glint (prefer specific look direction) - Stereo imaging pairs (require consistent look direction)</p> <p>Geometry note: Look direction is computed relative to satellite velocity vector using cross product. BOTH is equivalent to no constraint.</p>"},{"location":"learn/access_computation/constraints.html#temporal-constraints","title":"Temporal Constraints","text":""},{"location":"learn/access_computation/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":"<p>Constrains access based on local solar time at the ground location:</p> <pre><code># Daylight operations only (8 AM - 6 PM local)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=8.0,\n    max_hour=18.0\n)\n\n# Nighttime operations (10 PM - 4 AM local)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=22.0,\n    max_hour=4.0\n)\n\n# Early morning (wrap around midnight)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=4.0,\n    max_hour=8.0\n)\n</code></pre> <p>Key features: - Based on sun position (local solar time) - Automatically handles day/night wrap-around - Hours are floating-point (e.g., 13.5 = 1:30 PM)</p> <p>When to use: - Operational hour restrictions - Imaging with sun angle requirements - Avoiding local midnight (thermal constraints) - Sun-synchronous orbit planning</p> <p>Implementation note: Uses sun position calculations, not time zones. This is more accurate for satellite applications.</p>"},{"location":"learn/access_computation/constraints.html#orbit-geometry-constraints","title":"Orbit Geometry Constraints","text":""},{"location":"learn/access_computation/constraints.html#orbittypeconstraint-ascdscconstraint","title":"OrbitTypeConstraint (AscDscConstraint)","text":"<p>Filters by ascending vs. descending passes:</p> <pre><code># Ascending passes only (southbound to northbound)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC)\n\n# Descending passes only (northbound to southbound)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.DSC)\n\n# Either (no filtering)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.BOTH)\n</code></pre> <p>When to use: - Sun-synchronous orbits (different local times for asc/dsc) - Imaging with specific sun-angle requirements - Ground station scheduling (separate asc/dsc antennas) - Radar interferometry (consistent geometry)</p> <p>Geometry note: Determined by sign of latitude rate (d\u03c6/dt).</p>"},{"location":"learn/access_computation/constraints.html#logical-composition","title":"Logical Composition","text":"<p>Combine constraints with Boolean logic:</p>"},{"location":"learn/access_computation/constraints.html#constraintall-and","title":"ConstraintAll (AND)","text":"<p>All child constraints must be satisfied:</p> <pre><code># Ground station with elevation and time constraints\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n])\n\n# Complex imaging requirements\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=30.0),\n    bh.OffNadirConstraint(max_off_nadir_deg=25.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n    bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC),\n])\n</code></pre> <p>Behavior: Returns <code>True</code> only if ALL child constraints return <code>True</code>.</p> <p>Short-circuit evaluation: Stops checking as soon as any constraint returns <code>False</code> (performance optimization).</p>"},{"location":"learn/access_computation/constraints.html#constraintany-or","title":"ConstraintAny (OR)","text":"<p>At least one child constraint must be satisfied:</p> <pre><code># High elevation OR ascending pass\nconstraint = bh.ConstraintAny([\n    bh.ElevationConstraint(min_elevation_deg=60.0),  # Very high passes\n    bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC),  # OR ascending\n])\n\n# Multiple time windows\nconstraint = bh.ConstraintAny([\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=12.0),   # Morning\n    bh.LocalTimeConstraint(min_hour=14.0, max_hour=18.0),  # Afternoon\n])\n</code></pre> <p>Behavior: Returns <code>True</code> if ANY child constraint returns <code>True</code>.</p> <p>Short-circuit evaluation: Stops checking as soon as any constraint returns <code>True</code>.</p>"},{"location":"learn/access_computation/constraints.html#constraintnot-not","title":"ConstraintNot (NOT)","text":"<p>Inverts constraint result:</p> <pre><code># Exclude nighttime (i.e., daytime only)\nconstraint = bh.ConstraintNot(\n    bh.LocalTimeConstraint(min_hour=20.0, max_hour=6.0)  # NOT nighttime\n)\n\n# Avoid nadir pointing\nconstraint = bh.ConstraintNot(\n    bh.OffNadirConstraint(max_off_nadir_deg=5.0)  # NOT near-nadir\n)\n</code></pre> <p>Behavior: Returns opposite of child constraint (<code>not child.evaluate(...)</code>).</p> <p>Design tip: Often clearer to use opposite bounds rather than NOT, but NOT is essential for complex compositions.</p>"},{"location":"learn/access_computation/constraints.html#nested-composition","title":"Nested Composition","text":"<p>Combine logical operators arbitrarily:</p> <pre><code># (High elevation AND daytime) OR (Medium elevation AND right-looking)\nconstraint = bh.ConstraintAny([\n    bh.ConstraintAll([\n        bh.ElevationConstraint(min_elevation_deg=60.0),\n        bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n    ]),\n    bh.ConstraintAll([\n        bh.ElevationConstraint(min_elevation_deg=30.0),\n        bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n    ]),\n])\n\n# Complex exclusion logic\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Basic visibility\n    bh.ConstraintNot(  # NOT (nighttime AND low elevation)\n        bh.ConstraintAll([\n            bh.LocalTimeConstraint(min_hour=20.0, max_hour=6.0),\n            bh.ElevationConstraint(max_elevation_deg=30.0),\n        ])\n    ),\n])\n</code></pre> <p>Performance note: Evaluation is lazy and short-circuits. Order child constraints with most likely to fail first.</p>"},{"location":"learn/access_computation/constraints.html#custom-constraints","title":"Custom Constraints","text":"<p>Define application-specific constraints by subclassing <code>AccessConstraintComputer</code>:</p>"},{"location":"learn/access_computation/constraints.html#basic-custom-constraint","title":"Basic Custom Constraint","text":"<pre><code>import brahe as bh\nimport numpy as np\n\nclass SlantRangeConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Custom constraint that limits access based on slant range.\n\n    Only allows access when satellite is within 2000 km of location.\n    \"\"\"\n\n    def __init__(self, max_range_km=2000.0):\n        self.max_range_m = max_range_km * 1000.0\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"\n        Check if satellite is within maximum slant range.\n\n        Args:\n            epoch: Current evaluation time\n            sat_state_ecef: Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef: Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            bool: True if within range, False otherwise\n        \"\"\"\n        sat_pos = sat_state_ecef[:3]\n        range_m = np.linalg.norm(sat_pos - location_ecef)\n        return range_m &lt; self.max_range_m\n\n    def name(self):\n        \"\"\"Return constraint name\"\"\"\n        return f\"SlantRange(max={self.max_range_m/1000:.0f}km)\"\n\n# Use with access computation\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Built-in constraint\n    SlantRangeConstraint(max_range_km=2000.0),       # Custom constraint\n])\n\nwindows = bh.location_accesses(\n    locations, propagators, start, end, constraint\n)\n</code></pre>"},{"location":"learn/access_computation/constraints.html#advanced-custom-constraint","title":"Advanced Custom Constraint","text":"<pre><code>class NorthernHemisphereConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Only allows access when satellite is in northern hemisphere.\n\n    Useful for sun-synchronous orbits or regional coverage requirements.\n    \"\"\"\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Check if satellite Z-coordinate is positive (northern hemisphere)\"\"\"\n        z_coord = sat_state_ecef[2]  # Z in ECEF\n        return z_coord &gt;= 0.0\n\n    def name(self):\n        return \"NorthernHemisphere\"\n\nclass SunAngleConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Constraint based on sun elevation angle at location.\n\n    Requires daylight conditions for optical imaging.\n    \"\"\"\n\n    def __init__(self, min_sun_elevation_deg=10.0, max_sun_elevation_deg=70.0):\n        self.min_sun_elev = np.radians(min_sun_elevation_deg)\n        self.max_sun_elev = np.radians(max_sun_elevation_deg)\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Check if sun elevation is within acceptable range\"\"\"\n        # Compute sun position (placeholder - use actual ephemeris)\n        # Real implementation would use:\n        # sun_pos = bh.sun_position(epoch)\n        # sun_elev = compute_sun_elevation(sun_pos, location_ecef)\n\n        # For demonstration:\n        sun_elevation = 0.5  # Radians (placeholder)\n\n        return self.min_sun_elev &lt;= sun_elevation &lt;= self.max_sun_elev\n\n    def name(self):\n        return f\"SunAngle({np.degrees(self.min_sun_elev):.0f}\u00b0-{np.degrees(self.max_sun_elev):.0f}\u00b0)\"\n\n# Combine with built-in constraints\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=30.0),\n    bh.OffNadirConstraint(max_off_nadir_deg=25.0),\n    SunAngleConstraint(min_sun_elevation_deg=10.0, max_sun_elevation_deg=70.0),\n])\n</code></pre>"},{"location":"learn/access_computation/constraints.html#stateful-custom-constraints","title":"Stateful Custom Constraints","text":"<p>Custom constraints can maintain internal state:</p> <pre><code>class EvaluationCounterConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Example constraint that counts how many times it's been evaluated.\n\n    Useful for performance profiling or debugging.\n    \"\"\"\n\n    def __init__(self):\n        self.evaluation_count = 0\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Always returns True, but counts evaluations\"\"\"\n        self.evaluation_count += 1\n        return True\n\n    def name(self):\n        return f\"EvaluationCounter(count={self.evaluation_count})\"\n\n# Use in access computation\ncounter = EvaluationCounterConstraint()\nwindows = bh.location_accesses(locations, propagators, start, end, counter)\nprint(f\"Constraint evaluated {counter.evaluation_count} times\")\n</code></pre> <p>When to use custom constraints: - Domain-specific requirements not covered by built-in constraints - Complex logic requiring external data (weather, sun angles, etc.) - Research/experimental constraint types</p> <p>Performance note: Custom Python constraints are slower than built-in Rust constraints (~100-1000\u00d7 slower). For performance-critical applications, combine custom constraints with restrictive built-in constraints using <code>ConstraintAll</code> to minimize custom constraint evaluations.</p>"},{"location":"learn/access_computation/constraints.html#design-patterns","title":"Design Patterns","text":""},{"location":"learn/access_computation/constraints.html#layered-constraints","title":"Layered Constraints","text":"<p>Build constraints from permissive to restrictive:</p> <pre><code># Layer 1: Basic visibility\nbasic = bh.ElevationConstraint(min_elevation_deg=5.0)\n\n# Layer 2: Add operational constraints\noperational = bh.ConstraintAll([\n    basic,\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n])\n\n# Layer 3: Add mission-specific requirements\nmission = bh.ConstraintAll([\n    operational,\n    bh.OffNadirConstraint(max_off_nadir_deg=30.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n</code></pre> <p>Benefit: Easy to test intermediate constraint sets and identify which layer is most restrictive.</p>"},{"location":"learn/access_computation/constraints.html#constraint-reuse","title":"Constraint Reuse","text":"<p>Define common constraint components once:</p> <pre><code># Common constraint sets\nGROUND_STATION_BASIC = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nDAYLIGHT_OPS = bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0)\n\nIMAGING_GEOMETRY = bh.ConstraintAll([\n    bh.OffNadirConstraint(max_off_nadir_deg=30.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n\n# Compose for specific missions\nground_contact = bh.ConstraintAll([GROUND_STATION_BASIC, DAYLIGHT_OPS])\nimaging_mission = bh.ConstraintAll([GROUND_STATION_BASIC, IMAGING_GEOMETRY])\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraint-validation","title":"Constraint Validation","text":"<p>Test constraints in isolation before composition:</p> <pre><code># Create test scenario\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nsat_state = ...  # Test satellite state\nloc_ecef = ...   # Test location\n\n# Test individual constraints\nelev_constraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nprint(f\"Elevation constraint: {elev_constraint.evaluate(epoch, sat_state, loc_ecef)}\")\n\ntime_constraint = bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0)\nprint(f\"Time constraint: {time_constraint.evaluate(epoch, sat_state, loc_ecef)}\")\n\n# Test composition\ncombined = bh.ConstraintAll([elev_constraint, time_constraint])\nprint(f\"Combined: {combined.evaluate(epoch, sat_state, loc_ecef)}\")\n</code></pre>"},{"location":"learn/access_computation/constraints.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/access_computation/constraints.html#constraint-ordering","title":"Constraint Ordering","text":"<p>In <code>ConstraintAll</code>, place fast-to-fail constraints first:</p> <pre><code># Good: Cheap elevation check first\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Fast geometric check\n    compute_intensive_custom_constraint(),             # Expensive computation\n])\n\n# Suboptimal: Expensive check runs even when elevation fails\nconstraint = bh.ConstraintAll([\n    compute_intensive_custom_constraint(),             # Runs first\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Would have failed anyway\n])\n</code></pre> <p>Rule of thumb: Order by computational cost (cheapest first).</p>"},{"location":"learn/access_computation/constraints.html#constraint-complexity","title":"Constraint Complexity","text":"<ul> <li>Simple constraints (elevation, off-nadir): ~1 microsecond per evaluation</li> <li>Time-based constraints: ~10 microseconds (sun position calculation)</li> <li>Custom Python constraints: 100-1000 microseconds (Python call overhead)</li> </ul> <p>For million-evaluation problems, minimize custom constraint complexity.</p>"},{"location":"learn/access_computation/constraints.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types</li> <li>Computation - How constraints are evaluated during access search</li> <li>API Reference: Constraints</li> <li>Example: Svalbard Ground Contacts</li> <li>Example: Point Imaging Opportunities</li> </ul>"},{"location":"learn/access_computation/locations.html","title":"Locations","text":"<p>Locations represent ground positions or areas that satellites can access. Brahe provides two fundamental location types\u2014points and polygons\u2014with full GeoJSON interoperability and extensible metadata support.</p>"},{"location":"learn/access_computation/locations.html#overview","title":"Overview","text":"<p>All locations in Brahe share common capabilities:</p> <ul> <li>Geographic coordinates: Geodetic (lat/lon/alt) and ECEF (Earth-fixed Cartesian)</li> <li>Identification: Name, numeric ID, and UUID support</li> <li>Properties: Extensible metadata dictionary for custom data</li> <li>GeoJSON: Import/export compatibility with GIS systems</li> <li>Type safety: Strong typing with the <code>AccessibleLocation</code> trait</li> </ul>"},{"location":"learn/access_computation/locations.html#pointlocation","title":"PointLocation","text":"<p>Point locations represent discrete positions on Earth's surface, such as:</p> <ul> <li>Ground stations and tracking sites</li> <li>Imaging targets and waypoints</li> </ul>"},{"location":"learn/access_computation/locations.html#creating-point-locations","title":"Creating Point Locations","text":"<pre><code>import brahe as bh\n\n# Simple creation with lon, lat, alt\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0)\n\n# With identification\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\")\n\n# With multiple identifiers\nstation = bh.PointLocation(-117.2, 34.1, 500.0) \\\n    .with_name(\"Goldstone\") \\\n    .with_id(42) \\\n    .with_new_uuid()\n\n# With custom properties\nloc = bh.PointLocation(15.4, 78.2, 0.0) \\\n    .with_name(\"Svalbard\") \\\n    .add_property(\"country\", \"Norway\") \\\n    .add_property(\"operator\", \"KSAT\") \\\n    .add_property(\"frequency_band\", \"X-band\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#coordinate-systems","title":"Coordinate Systems","text":"<p>Point locations maintain coordinates in both geodetic and ECEF systems:</p> <pre><code>loc = bh.PointLocation(15.4, 78.2, 500.0)\n\n# Geodetic coordinates (degrees, meters)\nlon = loc.lon()      # 15.4 degrees\nlat = loc.lat()      # 78.2 degrees\nalt = loc.alt()      # 500.0 meters\n\n# ECEF coordinates (meters)\necef = loc.center_ecef()  # Vector3 [x, y, z] in meters\n\n# Access with angle format conversion\nlon_deg = loc.longitude(bh.AngleFormat.DEGREES)\nlon_rad = loc.longitude(bh.AngleFormat.RADIANS)\n</code></pre> <p>Coordinate Conventions: - Longitude: -180\u00b0 to +180\u00b0 (negative = West, positive = East) - Latitude: -90\u00b0 to +90\u00b0 (negative = South, positive = North) - Altitude: Height above WGS84 ellipsoid (meters) - ECEF: Earth-fixed Cartesian coordinates (meters)</p>"},{"location":"learn/access_computation/locations.html#geojson-integration","title":"GeoJSON Integration","text":"<p>Point locations seamlessly convert to/from GeoJSON Feature format:</p> <pre><code>import brahe as bh\nimport json\n\n# Create from GeoJSON\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 500.0]  # [lon, lat, alt]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\",\n        \"country\": \"Norway\"\n    }\n}\n\nloc = bh.PointLocation.from_geojson(geojson)\n\n# Export to GeoJSON\ngeojson = loc.to_geojson()\nprint(json.dumps(geojson, indent=2))\n</code></pre> <p>GeoJSON format details: - Coordinates: <code>[longitude, latitude, altitude]</code> (note lon/lat order!) - Altitude is optional (defaults to 0.0) - Properties include identity fields (name, id, uuid) plus custom metadata - Fully compatible with QGIS, GeoPandas, and other GIS tools</p>"},{"location":"learn/access_computation/locations.html#use-cases","title":"Use Cases","text":"<p>Ground Stations: <pre><code># Ground station network\nstations = [\n    bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\"),\n    bh.PointLocation(-64.5, -31.5, 0.0).with_name(\"Malargue\"),\n    bh.PointLocation(-117.2, 34.1, 0.0).with_name(\"Goldstone\"),\n]\n\nfor station in stations:\n    station.add_property(\"elevation_mask_deg\", 5.0)\n    station.add_property(\"max_data_rate_mbps\", 300.0)\n</code></pre></p> <p>Imaging Targets: <pre><code># Points of interest\ntargets = [\n    bh.PointLocation(2.3, 48.9, 0.0)\n        .with_name(\"Paris\")\n        .add_property(\"priority\", \"high\")\n        .add_property(\"min_off_nadir_deg\", 5.0)\n        .add_property(\"max_off_nadir_deg\", 30.0),\n\n    bh.PointLocation(139.7, 35.7, 0.0)\n        .with_name(\"Tokyo\")\n        .add_property(\"priority\", \"medium\")\n        .add_property(\"cloud_tolerance_pct\", 20.0),\n]\n</code></pre></p> <p>Grid Tessellation: <pre><code># Create global grid\nimport numpy as np\n\ngrid_points = []\nfor lat in np.arange(-90, 90, 10):\n    for lon in np.arange(-180, 180, 10):\n        point = bh.PointLocation(lon, lat, 0.0) \\\n            .with_name(f\"Grid_{lat}_{lon}\") \\\n            .add_property(\"grid_cell_id\", f\"{lat}_{lon}\")\n        grid_points.append(point)\n\nprint(f\"Created {len(grid_points)} grid points\")\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#polygonlocation","title":"PolygonLocation","text":"<p>Polygon locations represent areas on Earth's surface, such as:</p> <ul> <li>Areas of interest (countries, regions, sea zones)</li> <li>Imaging swaths and coverage footprints</li> </ul>"},{"location":"learn/access_computation/locations.html#creating-polygon-locations","title":"Creating Polygon Locations","text":"<pre><code>import brahe as bh\nfrom nalgebra import Vector3  # From brahe Rust bindings\nimport numpy as np\n\n# Define vertices [lon, lat, alt]\nvertices = [\n    Vector3(10.0, 50.0, 0.0),\n    Vector3(11.0, 50.0, 0.0),\n    Vector3(11.0, 51.0, 0.0),\n    Vector3(10.0, 51.0, 0.0),\n    Vector3(10.0, 50.0, 0.0),  # Closed polygon (first == last)\n]\n\n# Create polygon\naoi = bh.PolygonLocation(vertices).with_name(\"AOI-1\")\n\n# Auto-closure: First/last vertex don't need to match\nvertices = [\n    Vector3(10.0, 50.0, 0.0),\n    Vector3(11.0, 50.0, 0.0),\n    Vector3(11.0, 51.0, 0.0),\n    Vector3(10.0, 51.0, 0.0),\n    # Last vertex automatically added to close polygon\n]\naoi = bh.PolygonLocation(vertices)  # Auto-closed\n\n# With properties\nregion = bh.PolygonLocation(vertices) \\\n    .with_name(\"Europe-Central\") \\\n    .add_property(\"population_millions\", 82) \\\n    .add_property(\"min_cloud_free_pct\", 80)\n</code></pre>"},{"location":"learn/access_computation/locations.html#polygon-properties","title":"Polygon Properties","text":"<p>Polygons compute their centroid automatically:</p> <pre><code>poly = bh.PolygonLocation(vertices)\n\n# Centroid coordinates\ncenter_lon = poly.lon  # Average longitude\ncenter_lat = poly.lat  # Average latitude\ncenter_alt = poly.alt  # Average altitude\n\n# Vertex access\nverts = poly.vertices  # All vertices (including closure)\nnum_unique = poly.num_vertices  # Excluding closure vertex\n\n# ECEF center\necef_center = poly.center_ecef\n</code></pre>"},{"location":"learn/access_computation/locations.html#geojson-for-polygons","title":"GeoJSON for Polygons","text":"<pre><code># Create from GeoJSON\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[  # Note: nested array for outer ring\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\",\n        \"region\": \"Europe\"\n    }\n}\n\npoly = bh.PolygonLocation.from_geojson(geojson)\n\n# Export to GeoJSON\ngeojson = poly.to_geojson()\n</code></pre> <p>Polygon GeoJSON notes: - Coordinates are nested: <code>[[[lon, lat, alt], ...]]</code> (outer ring) - First and last vertex must match (closed) - All vertices must be unique (except closure)</p> Polygon Validity <p>Polygons must not contain holes.</p>"},{"location":"learn/access_computation/locations.html#use-cases_1","title":"Use Cases","text":"<p>Coverage Analysis: <pre><code># Define coverage regions\nregions = [\n    bh.PolygonLocation([\n        Vector3(-10.0, 35.0, 0.0),\n        Vector3(40.0, 35.0, 0.0),\n        Vector3(40.0, 70.0, 0.0),\n        Vector3(-10.0, 70.0, 0.0),\n    ]).with_name(\"Europe\"),\n\n    bh.PolygonLocation([\n        Vector3(-125.0, 25.0, 0.0),\n        Vector3(-65.0, 25.0, 0.0),\n        Vector3(-65.0, 50.0, 0.0),\n        Vector3(-125.0, 50.0, 0.0),\n    ]).with_name(\"North-America\"),\n]\n</code></pre></p> <p>Sensor Footprint: <pre><code># Imaging sensor footprint (simplified rectangular approximation)\ndef create_footprint(center_lon, center_lat, width_deg, height_deg):\n    \"\"\"Create rectangular footprint around center point\"\"\"\n    half_w = width_deg / 2.0\n    half_h = height_deg / 2.0\n\n    vertices = [\n        Vector3(center_lon - half_w, center_lat - half_h, 0.0),\n        Vector3(center_lon + half_w, center_lat - half_h, 0.0),\n        Vector3(center_lon + half_w, center_lat + half_h, 0.0),\n        Vector3(center_lon - half_w, center_lat + half_h, 0.0),\n    ]\n\n    return bh.PolygonLocation(vertices)\n\n# Create footprints\nfootprint1 = create_footprint(15.0, 50.0, 2.0, 1.5) \\\n    .with_name(\"Footprint-1\") \\\n    .add_property(\"swath_width_km\", 100.0)\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#extensible-properties","title":"Extensible Properties","text":"<p>Both location types support arbitrary metadata through a properties dictionary:</p>"},{"location":"learn/access_computation/locations.html#adding-properties","title":"Adding Properties","text":"<pre><code>loc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Builder pattern\nloc = loc.add_property(\"country\", \"Norway\") \\\n         .add_property(\"elevation_mask_deg\", 5.0) \\\n         .add_property(\"operational_hours\", [8, 18])\n\n# Direct access\nprops = loc.properties()\ncountry = props.get(\"country\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#common-property-patterns","title":"Common Property Patterns","text":"<p>Ground Station Metadata: <pre><code>station = bh.PointLocation(lon, lat, alt) \\\n    .with_name(\"Station-1\") \\\n    .add_property(\"operator\", \"ESA\") \\\n    .add_property(\"dish_diameter_m\", 15.0) \\\n    .add_property(\"frequency_bands\", [\"X\", \"Ka\"]) \\\n    .add_property(\"max_data_rate_mbps\", 800.0) \\\n    .add_property(\"elevation_mask_deg\", 5.0) \\\n    .add_property(\"operational_24_7\", True)\n</code></pre></p> <p>Imaging Target Constraints: <pre><code>target = bh.PointLocation(lon, lat, 0.0) \\\n    .with_name(\"Target-Alpha\") \\\n    .add_property(\"priority\", 10) \\\n    .add_property(\"min_off_nadir_deg\", 0.0) \\\n    .add_property(\"max_off_nadir_deg\", 30.0) \\\n    .add_property(\"preferred_look_direction\", \"RIGHT\") \\\n    .add_property(\"min_sun_elevation_deg\", 10.0) \\\n    .add_property(\"max_cloud_cover_pct\", 20.0)\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#identification-and-traceability","title":"Identification and Traceability","text":"<p>All locations implement the <code>Identifiable</code> trait for tracking and association:</p>"},{"location":"learn/access_computation/locations.html#identity-methods","title":"Identity Methods","text":"<pre><code># Name-based identification\nloc = bh.PointLocation(lon, lat, alt).with_name(\"Station-1\")\nassert loc.get_name() == \"Station-1\"\n\n# Numeric ID\nloc = loc.with_id(42)\nassert loc.get_id() == 42\n\n# UUID for global uniqueness\nimport uuid\nmy_uuid = uuid.uuid4()\nloc = loc.with_uuid(my_uuid)\nassert loc.get_uuid() == my_uuid\n\n# Or generate new UUID\nloc = loc.with_new_uuid()\nassert loc.get_uuid() is not None\n\n# Combined identity\nloc = loc.with_identity(\n    name=\"Station-1\",\n    uuid=my_uuid,\n    id=42\n)\n</code></pre>"},{"location":"learn/access_computation/locations.html#linking-locations-to-access-windows","title":"Linking Locations to Access Windows","text":"<p>Access windows preserve location and propagator identifiers:</p> <pre><code>windows = bh.location_accesses(locations, propagators, start, end, constraint)\n\nfor window in windows:\n    # Identifiers stored in window\n    loc_id = window.location_id\n    prop_id = window.propagator_id\n\n    # Find original location/propagator by ID\n    matching_loc = next(l for l in locations if l.get_id() == loc_id)\n    matching_prop = next(p for p in propagators if p.get_id() == prop_id)\n\n    print(f\"Access: {matching_prop.get_name()} -&gt; {matching_loc.get_name()}\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/access_computation/locations.html#loading-locations-from-geojson","title":"Loading Locations from GeoJSON","text":"<pre><code>import json\nimport brahe as bh\n\n# Load GeoJSON FeatureCollection\nwith open(\"ground_stations.geojson\") as f:\n    data = json.load(f)\n\nlocations = []\nfor feature in data[\"features\"]:\n    loc = bh.PointLocation.from_geojson(feature)\n    locations.append(loc)\n\nprint(f\"Loaded {len(locations)} locations\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#exporting-results-to-geojson","title":"Exporting Results to GeoJSON","text":"<pre><code># Collect access results\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Create GeoJSON with access statistics\nfeatures = []\nfor loc in locations:\n    # Find all windows for this location\n    loc_windows = [w for w in windows if w.location_id == loc.get_id()]\n\n    # Add access statistics to properties\n    loc = loc.add_property(\"total_passes\", len(loc_windows))\n    loc = loc.add_property(\"total_duration_sec\", sum(w.duration for w in loc_windows))\n\n    features.append(loc.to_geojson())\n\n# Export FeatureCollection\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": features\n}\n\nwith open(\"access_results.geojson\", \"w\") as f:\n    json.dump(geojson, f, indent=2)\n</code></pre>"},{"location":"learn/access_computation/locations.html#custom-property-computation","title":"Custom Property Computation","text":"<pre><code># Compute derived properties\nfor loc in locations:\n    # Geographic region classification\n    if loc.lat() &gt; 60:\n        region = \"polar\"\n    elif abs(loc.lat()) &lt; 23.5:\n        region = \"tropical\"\n    else:\n        region = \"temperate\"\n\n    loc = loc.add_property(\"climate_region\", region)\n\n    # Sun-synchronous orbit access potential\n    if 96.0 &lt;= abs(loc.lat()) &lt;= 100.0:\n        loc = loc.add_property(\"sso_compatible\", True)\n</code></pre>"},{"location":"learn/access_computation/locations.html#see-also","title":"See Also","text":"<ul> <li>Constraints - Defining access criteria for locations</li> <li>Computation - Access algorithms and property computation</li> <li>API Reference: Locations</li> <li>Example: Svalbard Ground Contacts</li> </ul>"},{"location":"learn/datasets/index.html","title":"Datasets","text":"<p>The datasets module in Brahe provides easy access to common datasources used in astrodynamics, space mission analysis, and research. This includes ephemeris data for Earth-orbiting satellites and locations of ground stations.</p>"},{"location":"learn/datasets/index.html#available-datasets","title":"Available Datasets","text":""},{"location":"learn/datasets/index.html#satellite-ephemeris","title":"Satellite Ephemeris","text":"<ul> <li>CelesTrak: Two-Line Element (TLE) sets for thousands of Earth-orbiting satellites</li> <li>Free access, no registration required</li> <li>Organized by satellite groups (GNSS, communications, Earth observation, etc.)</li> <li>Updated multiple times daily</li> <li>See CelesTrak documentation for details</li> </ul>"},{"location":"learn/datasets/index.html#groundstation-networks","title":"Groundstation Networks","text":"<ul> <li>Groundstation Datasets: Commercial ground station locations and metadata</li> <li>Six major provider networks (Atlas, AWS, KSAT, Leaf, SSC, Viasat)</li> <li>Embedded data (no external files required)</li> <li>Geographic coordinates and frequency band information</li> <li>See Groundstation documentation for details</li> </ul>"},{"location":"learn/datasets/index.html#use-cases","title":"Use Cases","text":"<p>Satellite Tracking: Download current TLE data for satellites of interest and propagate their orbits</p> <p>Coverage Analysis: Evaluate ground network coverage for satellite missions</p> <p>Mission Planning: Assess communication opportunities using real groundstation networks</p> <p>Research: Access historical or current ephemeris for analysis and validation</p>"},{"location":"learn/datasets/index.html#data-philosophy","title":"Data Philosophy","text":"<p>Brahe's datasets module aims to:</p> <ul> <li>Reduce friction: Provide easy access to commonly needed data</li> <li>No surprises: Data sources are clearly documented with known limitations</li> <li>Offline capable: Prefer embedded data when feasible (groundstations)</li> <li>Respect providers: Follow best practices and rate limiting (CelesTrak)</li> <li>Stay current: Update data sources as the ecosystem evolves</li> </ul>"},{"location":"learn/datasets/celestrak.html","title":"CelesTrak Data Source","text":"<p>CelesTrak is a public source for satellite Two-Line Element (TLE) data, maintained by T.S. Kelso since 1985. It provides free, frequently updated orbital element sets for thousands of satellites, making it a useful resource for satellite tracking, orbit determination, and space situational awareness.</p>"},{"location":"learn/datasets/celestrak.html#overview","title":"Overview","text":"<p>Website: https://celestrak.org</p> <p>Maintainer: Dr. T.S. Kelso</p> <p>Update frequency: Multiple times daily (varies by satellite priority)</p> <p>Access: No registration or API key required</p>"},{"location":"learn/datasets/celestrak.html#why-celestrak","title":"Why CelesTrak?","text":""},{"location":"learn/datasets/celestrak.html#advantages","title":"Advantages","text":"<p>Free and Open: - No registration required - No rate limits for reasonable use - Publicly accessible worldwide - Stable, long-term availability</p> <p>Well-Organized: - Satellites grouped by function and constellation - Consistent naming conventions - Regular group updates as missions change - Special groupings for recent launches and interesting events</p>"},{"location":"learn/datasets/celestrak.html#limitations","title":"Limitations","text":"<p>Update Latency: - Data comes from Space-Track.org with some delay - Not as current as direct Space-Track access - Typically 1-6 hours behind during active tracking periods</p> <p>Limited Historical Data: - Focuses on current/recent TLEs - Historical archives available but not comprehensive - For deep historical analysis, use Space-Track.org directly</p>"},{"location":"learn/datasets/celestrak.html#satellite-groups","title":"Satellite Groups","text":"<p>CelesTrak organizes satellites into logical groups accessible via simple names. These groups are maintained as constellations evolve.</p>"},{"location":"learn/datasets/celestrak.html#temporal-groups","title":"Temporal Groups","text":"Group Description Typical Count <code>active</code> All active satellites ~5,000+ <code>last-30-days</code> Recently launched satellites 20-100 (varies) <code>tle-new</code> Newly added TLEs (last 15 days) Variable"},{"location":"learn/datasets/celestrak.html#communications","title":"Communications","text":"Group Description <code>starlink</code> SpaceX Starlink constellation <code>oneweb</code> OneWeb constellation <code>kuiper</code> Amazon Kuiper constellation <code>intelsat</code> Intelsat satellites <code>eutelsat</code> Eutelsat constellation <code>orbcomm</code> ORBCOMM constellation <code>telesat</code> Telesat constellation <code>globalstar</code> Globalstar constellation <code>iridium-NEXT</code> Iridium constellation <code>qianfan</code> Qianfan constellation <code>hulianwang</code> Hulianwang Digui constellation"},{"location":"learn/datasets/celestrak.html#earth-observation","title":"Earth Observation","text":"Group Description <code>weather</code> Weather satellites (NOAA, GOES, Metop, etc.) <code>earth-resources</code> Earth observation (Landsat, Sentinel, etc.) <code>planet</code> Planet Labs imaging satellites <code>spire</code> Spire Global satellites"},{"location":"learn/datasets/celestrak.html#navigation","title":"Navigation","text":"Group Description <code>gnss</code> All navigation satellites (GPS, GLONASS, Galileo, BeiDou, QZSS, IRNSS) <code>gps-ops</code> Operational GPS satellites only <code>glonass-ops</code> Operational GLONASS satellites only <code>galileo</code> European Galileo constellation <code>beidou</code> Chinese BeiDou/COMPASS constellation <code>sbas</code> Satellite-Based Augmentation System (WAAS/EGNOS/MSAS)"},{"location":"learn/datasets/celestrak.html#scientific-and-special-purpose","title":"Scientific and Special Purpose","text":"Group Description <code>science</code> Scientific research satellites <code>noaa</code> NOAA satellites <code>stations</code> Space stations (ISS, Tiangong) <code>analyst</code> Analyst satellites (tracking placeholder IDs) <code>visual</code> 100 (or so) brightest objects <code>gpz</code> Geostationary Protected Zone <code>gpz-plus</code> Geostationary Protected Zone Plus <p>Note: Group names and contents evolve as missions launch, deorbit, or change status. Visit CelesTrak GP Element Sets for the current complete list.</p>"},{"location":"learn/datasets/celestrak.html#data-quality-and-currency","title":"Data Quality and Currency","text":"<p>TLE updates depend on the object itself, it's tracking priority, how difficult to track it is, and how often it's maneuvering. CelesTrak provides statistics on the median and mean age of TLEs by group. This has been about 0.8 and 1.5 days respectively in recent years, but can vary.</p>"},{"location":"learn/datasets/celestrak.html#accuracy-considerations","title":"Accuracy Considerations","text":"<p>For most operational applications TLEs should be updated daily. For research or general analysis, it's generally fine to just download and save the ephemeris once.</p> <p>Propagation accuracy: - Best within hours of epoch - Degrades beyond 3-7 days for LEO - Acceptable for 1-2 weeks for MEO/GEO</p> <p>When to refresh: - LEO tracking: Daily updates recommended - GNSS analysis: Weekly updates acceptable - GEO operations: Monthly updates sufficient</p>"},{"location":"learn/datasets/celestrak.html#access-methods","title":"Access Methods","text":""},{"location":"learn/datasets/celestrak.html#brahe-integration","title":"Brahe Integration","text":"<p>Brahe provides convenient API for CelesTrak access:</p> <pre><code>import brahe as bh\n\n# Get ephemeris data\nephemeris = bh.datasets.celestrak.get_ephemeris(\"gnss\")\n# Returns: List of (name, line1, line2) tuples\n\n# Get as propagators\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\n    \"gnss\",\n    step_size=60.0\n)\n\n# Download and save\nbh.datasets.celestrak.download_ephemeris(\n    \"gnss\",\n    \"gnss_satellites.json\",\n    content_format=\"3le\",\n    file_format=\"json\"\n)\n</code></pre>"},{"location":"learn/datasets/celestrak.html#best-practices","title":"Best Practices","text":""},{"location":"learn/datasets/celestrak.html#respectful-usage","title":"Respectful Usage","text":"<p>While CelesTrak has no strict rate limits, follow these guidelines:</p> <p>DO: - Cache downloaded data locally - Refresh on reasonable schedules (hourly at most) - Use appropriate update intervals for your orbit regime - Implement exponential backoff on errors</p> <p>DON'T: - Poll every minute (excessive) - Download all groups when you need one - Ignore errors and retry immediately - Run unattended scripts without rate limiting</p>"},{"location":"learn/datasets/celestrak.html#error-handling","title":"Error Handling","text":"<p>Implement robust error handling:</p> <pre><code>import brahe as bh\nimport time\n\ndef download_with_retry(group, max_retries=3):\n    \"\"\"Download ephemeris with exponential backoff\"\"\"\n    for attempt in range(max_retries):\n        try:\n            ephemeris = bh.datasets.celestrak.get_ephemeris(group)\n            return ephemeris\n        except Exception as e:\n            if attempt &lt; max_retries - 1:\n                wait_time = 2 ** attempt  # Exponential backoff\n                print(f\"Attempt {attempt + 1} failed: {e}\")\n                print(f\"Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                print(f\"All retries failed for {group}\")\n                raise\n\n# Use with error handling\ntry:\n    ephemeris = download_with_retry(\"gnss\")\nexcept Exception as e:\n    print(f\"Failed to download: {e}\")\n    # Fall back to cached data\n</code></pre>"},{"location":"learn/datasets/celestrak.html#caching-strategy","title":"Caching Strategy","text":"<p>Implement local caching to reduce load:</p> <pre><code>import brahe as bh\nfrom pathlib import Path\nimport time\nimport json\n\ndef get_cached_ephemeris(group, cache_dir=\"./cache\", max_age_hours=24):\n    \"\"\"Get ephemeris from cache or download if stale\"\"\"\n    cache_path = Path(cache_dir)\n    cache_path.mkdir(exist_ok=True)\n\n    cache_file = cache_path / f\"{group}.json\"\n\n    # Check if cache exists and is fresh\n    if cache_file.exists():\n        age_seconds = time.time() - cache_file.stat().st_mtime\n        age_hours = age_seconds / 3600\n\n        if age_hours &lt; max_age_hours:\n            # Use cached data\n            with open(cache_file, 'r') as f:\n                return json.load(f)\n\n    # Cache miss or stale - download fresh data\n    ephemeris = bh.datasets.celestrak.get_ephemeris(group)\n\n    # Save to cache\n    with open(cache_file, 'w') as f:\n        json.dump(ephemeris, f)\n\n    return ephemeris\n\n# Use cached ephemeris\nephemeris = get_cached_ephemeris(\"gnss\", max_age_hours=6)\n</code></pre>"},{"location":"learn/datasets/celestrak.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding satellite ephemeris datasets</li> <li>TLE and SGP - TLE and 3LE format details</li> <li>Downloading Satellite Data - Practical examples</li> <li>CelesTrak API Reference - Function documentation</li> </ul>"},{"location":"learn/datasets/groundstations.html","title":"Groundstation Datasets","text":"<p>Brahe includes curated groundstation location datasets from commercial satellite communication providers. These datasets provide standardized geographic coordinates and metadata for ground stations used in satellite operations, tracking, and communications.</p>"},{"location":"learn/datasets/groundstations.html#overview","title":"Overview","text":"<p>Groundstation data in Brahe is embedded directly in the library, requiring no external files or network access. The data represents real commercial groundstation networks maintained by major satellite service providers.</p> <p>Data Source: Publicly available information compiled from provider websites and documentation</p> <p>Format: GeoJSON FeatureCollections parsed into <code>PointLocation</code> objects</p> <p>Update Frequency: Updated periodically with Brahe releases</p>"},{"location":"learn/datasets/groundstations.html#available-providers","title":"Available Providers","text":"<p>Brahe includes groundstation data from six major commercial providers:</p> Provider Description Network Type Atlas Atlas Space Operations Commercial ground network AWS Amazon Web Services Ground Station Cloud-based ground services KSAT Kongsberg Satellite Services Global polar network Leaf Leaf Space Commercial ground network SSC Swedish Space Corporation Commercial and institutional Viasat Viasat Communication services"},{"location":"learn/datasets/groundstations.html#provider-characteristics","title":"Provider Characteristics","text":"<p>Atlas Space Operations - Modern cloud-based ground station network - Focus on automated operations and API access - Growing global coverage - Multiple frequency band support</p> <p>AWS Ground Station - Cloud-native ground station service - Pay-as-you-go pricing model - Integration with AWS services - Strategic global placement</p> <p>KSAT (Kongsberg Satellite Services) - Extensive polar coverage (Arctic and Antarctic) - Long operational history - Large established network - Strong Earth observation support</p> <p>Leaf Space - European-based commercial provider - Focus on LEO satellite support - Flexible antenna sharing - Modern infrastructure</p> <p>SSC (Swedish Space Corporation) - Mix of commercial and institutional facilities - Strong presence in northern latitudes - Launch support capabilities - Experienced operator</p> <p>Viasat - Primarily communications-focused - Global coverage - High-capacity infrastructure - Commercial satellite services</p>"},{"location":"learn/datasets/groundstations.html#data-format","title":"Data Format","text":"<p>Each groundstation is represented as a <code>PointLocation</code> with standardized properties:</p> <pre><code>import brahe as bh\n\nstations = bh.datasets.groundstations.load(\"ksat\")\nstation = stations[0]\n\n# Geographic coordinates (WGS84)\nlon = station.lon()      # Longitude in degrees\nlat = station.lat()      # Latitude in degrees\nalt = station.alt()      # Altitude in meters\n\n# Metadata properties\nprops = station.properties\nname = station.get_name()              # Station name\nprovider = props[\"provider\"]            # Provider name (e.g., \"KSAT\")\nbands = props[\"frequency_bands\"]        # Supported bands (e.g., [\"S\", \"X\"])\n</code></pre>"},{"location":"learn/datasets/groundstations.html#properties-dictionary","title":"Properties Dictionary","text":"<p>All groundstations include these standard properties:</p> <ul> <li><code>provider</code>: Provider name (string, e.g., \"KSAT\", \"Atlas\")</li> <li><code>frequency_bands</code>: List of supported frequency bands (e.g., <code>[\"S\", \"X\", \"Ka\"]</code>)</li> </ul> <p>Additional properties may be included in future releases as data becomes available.</p>"},{"location":"learn/datasets/groundstations.html#frequency-bands","title":"Frequency Bands","text":"<p>Common frequency bands in groundstation data:</p> Band Frequency Range Typical Use S 2-4 GHz TT&amp;C, telemetry X 8-12 GHz High-rate downlink, radar Ku 12-18 GHz Communications Ka 26-40 GHz High-bandwidth communications"},{"location":"learn/datasets/groundstations.html#use-cases","title":"Use Cases","text":""},{"location":"learn/datasets/groundstations.html#access-analysis","title":"Access Analysis","text":"<p>Compute visibility windows between satellites and ground networks:</p> <pre><code>import brahe as bh\n\n# Load ground network\nstations = bh.datasets.groundstations.load(\"ksat\")\n\n# Create satellite propagator\ntle1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\ntle2 = \"2 25544  51.6461 306.0234 0003417  88.1267  25.5695 15.48919103000003\"\npropagator = bh.SGPPropagator.from_tle(tle1, tle2)\n\n# Define search period\nstart = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0, tsys=\"UTC\")\nend = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0, tsys=\"UTC\")\n\n# Compute access windows with minimum elevation constraint\nconstraint = bh.ElevationConstraint(5.0)  # 5 degrees\naccesses = bh.location_accesses(\n    stations,\n    propagator,\n    start,\n    end,\n    constraint\n)\n\n# Analyze coverage\nfor access in accesses:\n    station_name = access.location.get_name()\n    duration = (access.end - access.start) / 60.0\n    print(f\"{station_name}: {duration:.1f} minutes\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#network-coverage-analysis","title":"Network Coverage Analysis","text":"<p>Evaluate geographic distribution and coverage:</p> <pre><code>import brahe as bh\n\n# Load all providers\nall_stations = bh.datasets.groundstations.load_all()\n\n# Analyze by latitude band\narctic = [s for s in all_stations if s.lat() &gt; 66.5]\ntemperate = [s for s in all_stations if -66.5 &lt;= s.lat() &lt;= 66.5]\nantarctic = [s for s in all_stations if s.lat() &lt; -66.5]\n\nprint(f\"Arctic stations: {len(arctic)}\")\nprint(f\"Temperate stations: {len(temperate)}\")\nprint(f\"Antarctic stations: {len(antarctic)}\")\n\n# Find stations by capability\nx_band_stations = [\n    s for s in all_stations\n    if \"X\" in s.properties[\"frequency_bands\"]\n]\nprint(f\"X-band capable: {len(x_band_stations)}\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#mission-planning","title":"Mission Planning","text":"<p>Select appropriate ground network for mission requirements:</p> <pre><code>import brahe as bh\n\n# Requirements\nrequired_bands = [\"S\", \"X\"]\nmin_elevation = 5.0\npreferred_regions = [\"arctic\", \"temperate\"]\n\n# Evaluate providers\nproviders = bh.datasets.groundstations.list_providers()\n\nfor provider in providers:\n    stations = bh.datasets.groundstations.load(provider)\n\n    # Filter by capability\n    capable = [\n        s for s in stations\n        if all(band in s.properties[\"frequency_bands\"] for band in required_bands)\n    ]\n\n    # Check geographic distribution\n    arctic_count = len([s for s in capable if s.lat() &gt; 60])\n\n    print(f\"\\n{provider.upper()}\")\n    print(f\"  Capable stations: {len(capable)}\")\n    print(f\"  Arctic coverage: {arctic_count}\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#data-quality-and-limitations","title":"Data Quality and Limitations","text":""},{"location":"learn/datasets/groundstations.html#accuracy","title":"Accuracy","text":"<p>Geographic Coordinates: - Based on publicly available information - Typically accurate to ~100-1000 meters - Sufficient for access analysis and mission planning - Not suitable for precision pointing or RF link budgets</p> <p>Frequency Bands: - Reflects general provider capabilities - May not represent all antennas at a site - Subject to provider updates and changes - Verify specific capabilities with provider for operational use</p>"},{"location":"learn/datasets/groundstations.html#whats-included","title":"What's Included","text":"<p>Included Data: - Geographic location (latitude, longitude, altitude) - Provider identification - Supported frequency bands - Station names (where available)</p> <p>Not Included: - Antenna parameters (gain, beamwidth, etc.) - Operational schedules or availability - Pricing or commercial terms - Real-time status or health - Contact information</p>"},{"location":"learn/datasets/groundstations.html#data-currency","title":"Data Currency","text":"<p>Groundstation data is updated periodically as part of Brahe releases:</p> <ul> <li>Sources: Provider websites, press releases, public documentation</li> <li>Update cycle: As providers announce new stations or changes</li> <li>Verification: Manual review of provider information</li> <li>No guarantee: Networks change; verify operational details with providers</li> </ul>"},{"location":"learn/datasets/groundstations.html#best-practices","title":"Best Practices","text":""},{"location":"learn/datasets/groundstations.html#when-to-use-embedded-data","title":"When to Use Embedded Data","text":"<p>Appropriate Uses: - Access analysis and link budget studies - Mission planning and concept development - Geographic coverage visualization - Network comparison studies - Educational purposes</p> <p>Verify Before: - Contract negotiations - Operational mission planning - RF link budget calculations - Regulatory filings - Critical mission operations</p>"},{"location":"learn/datasets/groundstations.html#combining-networks","title":"Combining Networks","text":"<p>For comprehensive coverage, combine multiple providers:</p> <pre><code>import brahe as bh\n\n# Load multiple providers\nprimary = bh.datasets.groundstations.load(\"ksat\")\nbackup = bh.datasets.groundstations.load(\"ssc\")\n\n# Combine into single network\ncombined = primary + backup\n\n# Compute access with redundant coverage\naccesses = bh.location_accesses(\n    combined,\n    propagator,\n    start,\n    end,\n    constraint\n)\n</code></pre>"},{"location":"learn/datasets/groundstations.html#custom-groundstation-data","title":"Custom Groundstation Data","text":"<p>For proprietary or specialized groundstations, create custom data:</p> <pre><code>import brahe as bh\n\n# Create custom groundstation\ncustom_station = bh.PointLocation(\n    lon=-122.4,  # degrees\n    lat=37.8,    # degrees\n    alt=100.0    # meters\n).add_property(\"provider\", \"Custom\") \\\n .add_property(\"frequency_bands\", [\"S\", \"X\", \"Ka\"])\n\n# Combine with commercial network\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nall_stations = [custom_station] + ksat_stations\n</code></pre> <p>Or load from GeoJSON file:</p> <pre><code>import brahe as bh\n\n# Load custom network from file\ncustom_network = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#api-access","title":"API Access","text":""},{"location":"learn/datasets/groundstations.html#loading-data","title":"Loading Data","text":"<pre><code>import brahe as bh\n\n# Single provider\nksat = bh.datasets.groundstations.load(\"ksat\")\n\n# All providers\nall_stations = bh.datasets.groundstations.load_all()\n\n# List available providers\nproviders = bh.datasets.groundstations.list_providers()\n</code></pre> <p>See the Groundstation Functions Reference for complete API documentation.</p>"},{"location":"learn/datasets/groundstations.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets in Brahe</li> <li>Groundstation API Reference - Complete function documentation</li> </ul>"},{"location":"library_api/index.html","title":"Python API Reference","text":"<p>This section provides comprehensive documentation for the Brahe Python API. All classes, functions, and modules are documented with detailed descriptions, parameters, return values, and usage examples.</p>"},{"location":"library_api/index.html#core-modules","title":"Core Modules","text":""},{"location":"library_api/index.html#time","title":"Time","text":"<p>The time module provides precise time representation and conversion between different time systems (UTC, TAI, GPS, TT, UT1). The <code>Epoch</code> class is the foundational time representation used throughout Brahe.</p> <p>Key Components: - <code>Epoch</code>: High-precision time representation with nanosecond accuracy - Time system conversions and utilities</p>"},{"location":"library_api/index.html#coordinates","title":"Coordinates","text":"<p>Coordinate transformation functions for converting between various coordinate systems used in astrodynamics.</p> <p>Key Components: - Cartesian coordinates (position and velocity vectors) - Geodetic coordinates (latitude, longitude, altitude) - Geocentric coordinates - Topocentric coordinates (East-North-Up, South-East-Zenith)</p>"},{"location":"library_api/index.html#frames","title":"Frames","text":"<p>Reference frame transformations between Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) coordinate frames using IAU 2006/2000A models.</p>"},{"location":"library_api/index.html#orbits","title":"Orbits","text":"<p>Orbital mechanics representations and propagators for satellite trajectory computation.</p> <p>Key Components: - Keplerian orbital elements - Two-Line Element (TLE) format parsing - Analytical propagators (Keplerian, SGP4/SDP4)</p>"},{"location":"library_api/index.html#attitude","title":"Attitude","text":"<p>Attitude representation and conversion between different rotation parameterizations.</p> <p>Key Components: - Quaternions - Rotation matrices (Direction Cosine Matrices) - Euler angles (various sequences) - Euler axis-angle representation</p>"},{"location":"library_api/index.html#trajectories","title":"Trajectories","text":"<p>High-level trajectory containers with interpolation support for storing and querying orbital states over time.</p>"},{"location":"library_api/index.html#earth-orientation-parameters-eop","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth orientation parameter data management for high-precision coordinate frame transformations.</p>"},{"location":"library_api/index.html#constants","title":"Constants","text":"<p>Mathematical, physical, and time-related constants used throughout the library.</p>"},{"location":"library_api/index.html#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the detailed API documentation for each module. Each page includes:</p> <ul> <li>Complete class and function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value specifications</li> <li>Usage examples</li> <li>References to related functionality</li> </ul> <p>All documentation is automatically generated from the source code docstrings to ensure accuracy and consistency.</p>"},{"location":"library_api/frames.html","title":"Reference Frames Module","text":"<p>Reference frame transformations between ECI and ECEF coordinate systems.</p>"},{"location":"library_api/frames.html#brahe.frames","title":"frames","text":"<p>Reference Frames Module</p> <p>Reference frame transformations between ECI and ECEF coordinate systems.</p> <p>This module provides transformations between: - ECI (Earth-Centered Inertial): J2000/GCRF frame - ECEF (Earth-Centered Earth-Fixed): ITRF frame</p> <p>The transformations implement the IAU 2006/2000A precession-nutation model and use Earth Orientation Parameters (EOP) for high-precision conversions.</p> <p>Functions are provided for: - Rotation matrices (bias-precession-nutation, Earth rotation, polar motion) - Position vector transformations - State vector (position + velocity) transformations</p>"},{"location":"library_api/frames.html#brahe.frames.bias_precession_nutation","title":"bias_precession_nutation  <code>builtin</code>","text":"<pre><code>bias_precession_nutation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Bias-Precession-Nutation matrix transforming the <code>GCRS</code> to the <code>CIRS</code> intermediate reference frame. This transformation corrects for the bias, precession, and nutation of Celestial Intermediate Origin (<code>CIO</code>) with respect to inertial space.</p> <p>This formulation computes the Bias-Precession-Nutation correction matrix according using a <code>CIO</code> based model using using the <code>IAU 2006</code> precession and <code>IAU 2000A</code> nutation models.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to the Celestial Intermediate Pole (<code>CIP</code>) derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRS</code> -&gt; <code>CIRS</code></p> References <p>IAU SOFA Tools For Earth Attitude, Example 5.5 http://www.iausofa.org/2021_0512_C/sofa/sofa_pn_c.pdf Software Version 18, 2021-04-18</p>"},{"location":"library_api/frames.html#brahe.frames.earth_rotation","title":"earth_rotation  <code>builtin</code>","text":"<pre><code>earth_rotation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>CIRS</code> to the <code>TIRS</code> intermediate reference frame. This transformation corrects for the Earth rotation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>CIRS</code> -&gt; <code>TIRS</code></p>"},{"location":"library_api/frames.html#brahe.frames.polar_motion","title":"polar_motion  <code>builtin</code>","text":"<pre><code>polar_motion(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>TIRS</code> to the <code>ITRF</code> reference frame.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to compute the polar motion correction based on empirical observations of polar motion drift.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>TIRS</code> -&gt; <code>ITRF</code></p>"},{"location":"library_api/frames.html#brahe.frames.rotation_eci_to_ecef","title":"rotation_eci_to_ecef  <code>builtin</code>","text":"<pre><code>rotation_eci_to_ecef(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>ITRF</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix\nR = bh.rotation_eci_to_ecef(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_ecef_to_eci","title":"rotation_ecef_to_eci  <code>builtin</code>","text":"<pre><code>rotation_ecef_to_eci(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>ITRF</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR = bh.rotation_ecef_to_eci(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_eci_to_ecef","title":"position_eci_to_ecef  <code>builtin</code>","text":"<pre><code>position_eci_to_ecef(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in ECI (meters)\nr_eci = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ECEF\nr_ecef = bh.position_eci_to_ecef(epc, r_eci)\nprint(f\"ECEF position: {r_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_ecef_to_eci","title":"position_ecef_to_eci  <code>builtin</code>","text":"<pre><code>position_ecef_to_eci(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ECEF (ground station)\nr_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to ECI\nr_eci = bh.position_ecef_to_eci(epc, r_ecef)\nprint(f\"ECI position: {r_eci}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_eci_to_ecef","title":"state_eci_to_ecef  <code>builtin</code>","text":"<pre><code>state_eci_to_ecef(epc: Epoch, x_eci: ndarray) -&gt; np.ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_eci</code> <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECI [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eci = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\nprint(f\"ECEF state: {state_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_ecef_to_eci","title":"state_ecef_to_eci  <code>builtin</code>","text":"<pre><code>state_ecef_to_eci(epc: Epoch, x_ecef: ndarray) -&gt; np.ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_ecef</code> <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_ecef = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to ECI\nstate_eci = bh.state_ecef_to_eci(epc, state_ecef)\nprint(f\"ECI state: {state_eci}\")\n</code></pre>"},{"location":"library_api/access/index.html","title":"Access Computation API","text":"<p>The access computation module provides comprehensive tools for determining when satellites can observe or communicate with ground locations.</p>"},{"location":"library_api/access/index.html#core-functions","title":"Core Functions","text":""},{"location":"library_api/access/index.html#brahe.location_accesses","title":"location_accesses  <code>builtin</code>","text":"<pre><code>location_accesses(locations: PointLocation | PolygonLocation | List[PointLocation | PolygonLocation], propagators: SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator], search_start: Epoch, search_end: Epoch, constraint: Union[ElevationConstraint, OffNadirConstraint, LocalTimeConstraint, LookDirectionConstraint, AscDscConstraint, ElevationMaskConstraint, ConstraintAll, ConstraintAny, ConstraintNot], property_computers: [List[AccessPropertyComputer]] = None, config: [AccessSearchConfig] = None, time_tolerance: [float] = None) -&gt; List[AccessWindow]\n</code></pre> <p>Compute access windows for locations and satellites.</p> <p>This function accepts either single items or lists for both locations and propagators, automatically handling all combinations. All location-satellite pairs are computed and results are returned sorted by window start time.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>PointLocation | PolygonLocation | List[PointLocation | PolygonLocation]</code> <p>Single location or list of locations</p> required <code>propagators</code> <code>SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator]</code> <p>Single propagator or list of propagators</p> required <code>search_start</code> <code>Epoch</code> <p>Start of search window</p> required <code>search_end</code> <code>Epoch</code> <p>End of search window</p> required <code>constraint</code> <code>AccessConstraint</code> <p>Access constraints to evaluate</p> required <code>property_computers</code> <code>Optional[List[AccessPropertyComputer]]</code> <p>Optional property computers</p> <code>None</code> <code>config</code> <code>Optional[AccessSearchConfig]</code> <p>Search configuration (default: 60s fixed grid, no adaptation)</p> <code>None</code> <code>time_tolerance</code> <code>Optional[float]</code> <p>Bisection search tolerance in seconds (default: 0.01)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AccessWindow]</code> <p>List[AccessWindow]: List of access windows sorted by start time</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a ground station\nstation = bh.PointLocation(-75.0, 40.0, 0.0)  # Philadelphia\n\n# Create satellite propagators\nepoch = bh.Epoch(2024, 1, 1, 0, 0, 0.0)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator(epoch, state)\n\n# Define access constraints\nconstraint = bh.ElevationConstraint(10.0)  # 10 degree minimum elevation\n\n# Single location, single propagator\nsearch_end = epoch + 86400.0  # 1 day\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint)\n\n# Single location, multiple propagators\nprop2 = bh.KeplerianPropagator(epoch, state)  # Different satellite\nwindows = bh.location_accesses(station, [prop1, prop2], epoch, search_end, constraint)\n\n# Multiple locations, single propagator\nstation2 = bh.PointLocation(-122.0, 37.0, 0.0)  # San Francisco\nwindows = bh.location_accesses([station, station2], prop1, epoch, search_end, constraint)\n\n# Multiple locations, multiple propagators\nwindows = bh.location_accesses([station, station2], [prop1, prop2], epoch, search_end, constraint)\n\n# Custom search configuration\nconfig = bh.AccessSearchConfig(initial_time_step=30.0, adaptive_step=True)\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint, config=config)\n</code></pre>"},{"location":"library_api/access/index.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/index.html#brahe.AccessSearchConfig","title":"AccessSearchConfig","text":"<pre><code>AccessSearchConfig(initial_time_step: float, adaptive_step: bool, adaptive_fraction: float)\n</code></pre> <p>Configuration for access search grid parameters.</p> <p>Controls the time step and adaptive stepping behavior for access window finding.</p> <p>Parameters:</p> Name Type Description Default <code>initial_time_step</code> <code>float</code> <p>Initial time step in seconds for grid search (default: 60.0)</p> required <code>adaptive_step</code> <code>bool</code> <p>Enable adaptive stepping after first access (default: False)</p> required <code>adaptive_fraction</code> <code>float</code> <p>Fraction of orbital period to use for adaptive step (default: 0.75)</p> required Example <pre><code>import brahe as bh\n\n# Create a config with custom parameters\nconfig = bh.AccessSearchConfig(\n    initial_time_step=30.0,\n    adaptive_step=True,\n    adaptive_fraction=0.5\n)\n\n# Use config with location_accesses\nwindows = bh.location_accesses(\n    station, prop, search_start, search_end,\n    constraint, config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Configuration for access search grid parameters.\\n\\nControls the time step and adaptive stepping behavior for access window finding.\\n\\nArgs:\\n    initial_time_step (float): Initial time step in seconds for grid search (default: 60.0)\\n    adaptive_step (bool): Enable adaptive stepping after first access (default: False)\\n    adaptive_fraction (float): Fraction of orbital period to use for adaptive step (default: 0.75)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a config with custom parameters\\n    config = bh.AccessSearchConfig(\\n        initial_time_step=30.0,\\n        adaptive_step=True,\\n        adaptive_fraction=0.5\\n    )\\n\\n    # Use config with location_accesses\\n    windows = bh.location_accesses(\\n        station, prop, search_start, search_end,\\n        constraint, config=config\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_fraction","title":"adaptive_fraction  <code>property</code>","text":"<pre><code>adaptive_fraction: float\n</code></pre> <p>Get the adaptive fraction (fraction of orbital period).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adaptive fraction</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_step","title":"adaptive_step  <code>property</code>","text":"<pre><code>adaptive_step: bool\n</code></pre> <p>Get whether adaptive stepping is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Adaptive stepping flag</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.initial_time_step","title":"initial_time_step  <code>property</code>","text":"<pre><code>initial_time_step: float\n</code></pre> <p>Get the initial time step in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Initial time step</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.num_threads","title":"num_threads  <code>property</code>","text":"<pre><code>num_threads: Optional[int]\n</code></pre> <p>Get the number of threads for parallel computation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Number of threads, or None to use global setting</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.parallel","title":"parallel  <code>property</code>","text":"<pre><code>parallel: bool\n</code></pre> <p>Get whether parallel computation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Parallel computation flag (default: True)</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/index.html#threading-control","title":"Threading Control","text":""},{"location":"library_api/access/index.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads(n: int) -&gt; Any\n</code></pre> <p>Set the maximum number of threads for parallel access computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations. Must be called before any parallel operations begin, otherwise the default (90% of available cores) will be used.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If called after the thread pool has already been initialized, or if n &lt; 1.</p> Example <pre><code>import brahe as bh\n\n# Use 4 threads for all parallel access computations\nbh.set_max_threads(4)\n\n# Now all location_accesses calls will use 4 threads\n# (unless overridden with AccessSearchConfig.num_threads)\n</code></pre> Note <p>This function should be called early in your program, before any access computations are performed. Once the thread pool is initialized, it cannot be changed.</p>"},{"location":"library_api/access/index.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores)\nthreads = bh.get_max_threads()\nprint(f\"Using {threads} threads\")\n\n# Or set explicitly first\nbh.set_max_threads(4)\nassert bh.get_max_threads() == 4\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings if it hasn't been initialized yet. After that, set_max_threads() can no longer be called.</p>"},{"location":"library_api/access/constraints.html","title":"Constraints","text":"<p>Constraints define criteria that must be satisfied for satellite access.</p>"},{"location":"library_api/access/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"library_api/access/constraints.html#elevationconstraint","title":"ElevationConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint","title":"ElevationConstraint","text":"<pre><code>ElevationConstraint(min_elevation_deg: float | None, max_elevation_deg: float | None)\n</code></pre> <p>Elevation angle constraint for satellite visibility.</p> <p>Constrains access based on the elevation angle of the satellite above the local horizon at the ground location.</p> <p>Parameters:</p> Name Type Description Default <code>min_elevation_deg</code> <code>float | None</code> <p>Minimum elevation angle in degrees, or None for no minimum</p> required <code>max_elevation_deg</code> <code>float | None</code> <p>Maximum elevation angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None (unbounded constraint is meaningless)</p> Example <pre><code>import brahe as bh\n\n# Typical ground station constraint: 5\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\n\n# Both bounds specified\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\n\n# Only maximum (e.g., avoid zenith)\nconstraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Elevation angle constraint for satellite visibility.\\n\\nConstrains access based on the elevation angle of the satellite above\\nthe local horizon at the ground location.\\n\\nArgs:\\n    min_elevation_deg (float | None): Minimum elevation angle in degrees, or None for no minimum\\n    max_elevation_deg (float | None): Maximum elevation angle in degrees, or None for no maximum\\n\\nRaises:\\n    ValueError: If both min and max are None (unbounded constraint is meaningless)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Typical ground station constraint: 5\u00b0 minimum elevation\\n    constraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\\n\\n    # Both bounds specified\\n    constraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\\n\\n    # Only maximum (e.g., avoid zenith)\\n    constraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint","title":"ElevationMaskConstraint","text":"<pre><code>ElevationMaskConstraint(mask: list[tuple[float, float]])\n</code></pre> <p>Azimuth-dependent elevation mask constraint.</p> <p>Constrains access based on azimuth-dependent elevation masks. Useful for ground stations with terrain obstructions or antenna limitations.</p> <p>The mask is defined as a list of (azimuth, elevation) pairs in degrees. Linear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>list[tuple[float, float]]</code> <p>List of (azimuth_deg, min_elevation_deg) pairs</p> required Example <pre><code>import brahe as bh\n\n# Ground station with terrain obstruction to the north\nmask = [\n    (0.0, 15.0),     # North: 15\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 5.0),    # South: 5\u00b0 minimum\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n]\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Azimuth-dependent elevation mask constraint.\\n\\nConstrains access based on azimuth-dependent elevation masks.\\nUseful for ground stations with terrain obstructions or antenna limitations.\\n\\nThe mask is defined as a list of (azimuth, elevation) pairs in degrees.\\nLinear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.\\n\\nArgs:\\n    mask (list[tuple[float, float]]): List of (azimuth_deg, min_elevation_deg) pairs\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Ground station with terrain obstruction to the north\\n    mask = [\\n        (0.0, 15.0),     # North: 15\u00b0 minimum\\n        (90.0, 5.0),     # East: 5\u00b0 minimum\\n        (180.0, 5.0),    # South: 5\u00b0 minimum\\n        (270.0, 5.0),    # West: 5\u00b0 minimum\\n    ]\\n    constraint = bh.ElevationMaskConstraint(mask)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint","title":"OffNadirConstraint","text":"<pre><code>OffNadirConstraint(min_off_nadir_deg: float | None, max_off_nadir_deg: float | None)\n</code></pre> <p>Off-nadir angle constraint for satellite imaging.</p> <p>Constrains access based on the off-nadir angle (angle between the satellite's nadir vector and the line-of-sight to the location).</p> <p>Parameters:</p> Name Type Description Default <code>min_off_nadir_deg</code> <code>float | None</code> <p>Minimum off-nadir angle in degrees, or None for no minimum</p> required <code>max_off_nadir_deg</code> <code>float | None</code> <p>Maximum off-nadir angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None, or if any angle is negative</p> Example <pre><code>import brahe as bh\n\n# Imaging satellite with 45\u00b0 maximum slew angle\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\n\n# Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = \"Off-nadir angle constraint for satellite imaging.\\n\\nConstrains access based on the off-nadir angle (angle between the satellite's\\nnadir vector and the line-of-sight to the location).\\n\\nArgs:\\n    min_off_nadir_deg (float | None): Minimum off-nadir angle in degrees, or None for no minimum\\n    max_off_nadir_deg (float | None): Maximum off-nadir angle in degrees, or None for no maximum\\n\\nRaises:\\n    ValueError: If both min and max are None, or if any angle is negative\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Imaging satellite with 45\u00b0 maximum slew angle\\n    constraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\\n\\n    # Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\\n    constraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\\n    ```\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint","title":"LookDirectionConstraint","text":"<pre><code>LookDirectionConstraint(allowed: LookDirection)\n</code></pre> <p>Look direction constraint (left/right relative to velocity).</p> <p>Constrains access based on the look direction of the satellite relative to its velocity vector.</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>LookDirection</code> <p>Required look direction (LEFT, RIGHT, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Satellite can only look right\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Either direction is acceptable\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Look direction constraint (left/right relative to velocity).\\n\\nConstrains access based on the look direction of the satellite relative\\nto its velocity vector.\\n\\nArgs:\\n    allowed (LookDirection): Required look direction (LEFT, RIGHT, or EITHER)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Satellite can only look right\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\\n\\n    # Either direction is acceptable\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint","title":"LocalTimeConstraint","text":"<pre><code>LocalTimeConstraint(time_windows: list[tuple[int, int]])\n</code></pre> <p>Local solar time constraint.</p> <p>Constrains access based on the local solar time at the ground location. Useful for sun-synchronous orbits or daytime-only imaging.</p> <p>Time windows are specified in military time format (HHMM). Wrap-around windows (e.g., 2200-0200) are supported.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[int, int]]</code> <p>List of (start_military, end_military) tuples (0-2400)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any military time is invalid (&gt;2400 or minutes &gt;=60)</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\n\n# Two windows: morning (6-9 AM) and evening (4-7 PM)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\n\n# Overnight window (10 PM to 2 AM) - handles wrap-around\nconstraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Local solar time constraint.\\n\\nConstrains access based on the local solar time at the ground location.\\nUseful for sun-synchronous orbits or daytime-only imaging.\\n\\nTime windows are specified in military time format (HHMM).\\nWrap-around windows (e.g., 2200-0200) are supported.\\n\\nArgs:\\n    time_windows (list[tuple[int, int]]): List of (start_military, end_military) tuples (0-2400)\\n\\nRaises:\\n    ValueError: If any military time is invalid (&gt;2400 or minutes &gt;=60)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Only daytime (6 AM to 6 PM local time)\\n    constraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\\n\\n    # Two windows: morning (6-9 AM) and evening (4-7 PM)\\n    constraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\\n\\n    # Overnight window (10 PM to 2 AM) - handles wrap-around\\n    constraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.from_hours","title":"from_hours  <code>builtin</code>","text":"<pre><code>from_hours(time_windows: list[tuple[float, float]]) -&gt; LocalTimeConstraint\n</code></pre> <p>Create from decimal hour windows instead of military time.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[float, float]]</code> <p>List of (start_hour, end_hour) tuples [0, 24)</p> required <p>Returns:</p> Name Type Description <code>LocalTimeConstraint</code> <code>LocalTimeConstraint</code> <p>The constraint instance</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint.from_hours([(6.0, 18.0)])\n\n# Overnight window (10 PM to 2 AM)\nconstraint = bh.LocalTimeConstraint.from_hours([(22.0, 2.0)])\n</code></pre>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#ascdscconstraint","title":"AscDscConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint","title":"AscDscConstraint","text":"<pre><code>AscDscConstraint(allowed: AscDsc)\n</code></pre> <p>Ascending/descending pass constraint.</p> <p>Constrains access based on whether the satellite is on an ascending or descending pass (moving north or south).</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>AscDsc</code> <p>Required pass type (ASCENDING, DESCENDING, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Either type is acceptable\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Ascending/descending pass constraint.\\n\\nConstrains access based on whether the satellite is on an ascending or\\ndescending pass (moving north or south).\\n\\nArgs:\\n    allowed (AscDsc): Required pass type (ASCENDING, DESCENDING, or EITHER)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Only ascending passes\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\\n\\n    # Either type is acceptable\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#logical-composition","title":"Logical Composition","text":""},{"location":"library_api/access/constraints.html#constraintall","title":"ConstraintAll","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAll","title":"ConstraintAll","text":"<pre><code>ConstraintAll(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with AND logic.</p> <p>All constraints must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with AND logic</p> required Example <pre><code>import brahe as bh\n\n# Ground station with multiple requirements\nelev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\ncombined = bh.ConstraintAll(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint combining multiple constraints with AND logic.\\n\\nAll constraints must be satisfied for the composite to evaluate to true.\\n\\nArgs:\\n    constraints (list): List of constraint objects to combine with AND logic\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Ground station with multiple requirements\\n    elev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\\n    time = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\\n    combined = bh.ConstraintAll(constraints=[elev, time])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ALL constraints are satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintany","title":"ConstraintAny","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAny","title":"ConstraintAny","text":"<pre><code>ConstraintAny(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with OR logic.</p> <p>At least one constraint must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with OR logic</p> required Example <pre><code>import brahe as bh\n\n# Accept either high elevation or specific time window\nelev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\ncombined = bh.ConstraintAny(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint combining multiple constraints with OR logic.\\n\\nAt least one constraint must be satisfied for the composite to evaluate to true.\\n\\nArgs:\\n    constraints (list): List of constraint objects to combine with OR logic\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Accept either high elevation or specific time window\\n    elev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\\n    time = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\\n    combined = bh.ConstraintAny(constraints=[elev, time])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if AT LEAST ONE constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintnot","title":"ConstraintNot","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintNot","title":"ConstraintNot","text":"<pre><code>ConstraintNot()\n</code></pre> <p>Composite constraint negating another constraint with NOT logic.</p> <p>The negated constraint must NOT be satisfied for this to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <p>Constraint object to negate</p> required Example <pre><code>import brahe as bh\n\n# Avoid low elevation angles (i.e., require high elevation)\nlow_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\nhigh_elev = bh.ConstraintNot(constraint=low_elev)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint negating another constraint with NOT logic.\\n\\nThe negated constraint must NOT be satisfied for this to evaluate to true.\\n\\nArgs:\\n    constraint: Constraint object to negate\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Avoid low elevation angles (i.e., require high elevation)\\n    low_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\\n    high_elev = bh.ConstraintNot(constraint=low_elev)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the negated constraint is NOT satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#custom-constraints","title":"Custom Constraints","text":""},{"location":"library_api/access/constraints.html#accesspropertycomputer","title":"AccessPropertyComputer","text":""},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer","title":"AccessPropertyComputer","text":"<pre><code>AccessPropertyComputer(window: AccessWindow, satellite_state_ecef: ndarray, location_ecef: ndarray)\n</code></pre> <p>Base class for custom access property computers.</p> <p>Subclass this class and implement the <code>compute</code> and <code>property_names</code> methods to create custom property calculations that can be applied to access windows.</p> <p>The compute method is called for each access window and should return a dictionary of property names to values. Properties can be scalars, vectors, time series, booleans, strings, or any JSON-serializable value.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    '''Computes Doppler shift at window midtime.'''\n\n    def compute(self, window: bh.AccessWindow, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; dict:\n        '''\n        Args:\n            window (AccessWindow): AccessWindow with timing information\n            satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef (ndarray): Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            dict: Property name -&gt; value\n        '''\n        # Extract velocity\n        vx, vy, vz = satellite_state_ecef[3:6]\n\n        # Line-of-sight vector\n        sat_pos = satellite_state_ecef[:3]\n        los = location_ecef - sat_pos\n        los_unit = los / np.linalg.norm(los)\n\n        # Radial velocity\n        sat_vel = np.array([vx, vy, vz])\n        radial_velocity = np.dot(sat_vel, los_unit)\n\n        # Doppler shift (L-band)\n        freq_hz = 1.57542e9  # GPS L1\n        doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\n\n        return {\"doppler_shift\": doppler_hz}\n\n    def property_names(self) -&gt; list:\n        '''Return list of property names this computer produces.'''\n        return [\"doppler_shift\"]\n\n# Use with access computation (future)\ncomputer = DopplerComputer()\n# accesses = bh.compute_accesses(..., property_computers=[computer])\n</code></pre> Notes <ul> <li>The <code>compute</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Property values are automatically converted to appropriate Rust types</li> <li>The window parameter provides access to timing via:</li> <li><code>window.window_open</code>: Start epoch</li> <li><code>window.window_close</code>: End epoch</li> <li><code>window.midtime()</code>: Midpoint epoch</li> <li><code>window.duration()</code>: Duration in seconds</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Base class for custom access property computers.\\n\\nSubclass this class and implement the `compute` and `property_names` methods\\nto create custom property calculations that can be applied to access windows.\\n\\nThe compute method is called for each access window and should return a dictionary\\nof property names to values. Properties can be scalars, vectors, time series,\\nbooleans, strings, or any JSON-serializable value.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    class DopplerComputer(bh.AccessPropertyComputer):\\n        \\'\\'\\'Computes Doppler shift at window midtime.\\'\\'\\'\\n\\n        def compute(self, window: bh.AccessWindow, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; dict:\\n            \\'\\'\\'\\n            Args:\\n                window (AccessWindow): AccessWindow with timing information\\n                satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\\n                location_ecef (ndarray): Location position [x,y,z] in ECEF (m)\\n\\n            Returns:\\n                dict: Property name -&gt; value\\n            \\'\\'\\'\\n            # Extract velocity\\n            vx, vy, vz = satellite_state_ecef[3:6]\\n\\n            # Line-of-sight vector\\n            sat_pos = satellite_state_ecef[:3]\\n            los = location_ecef - sat_pos\\n            los_unit = los / np.linalg.norm(los)\\n\\n            # Radial velocity\\n            sat_vel = np.array([vx, vy, vz])\\n            radial_velocity = np.dot(sat_vel, los_unit)\\n\\n            # Doppler shift (L-band)\\n            freq_hz = 1.57542e9  # GPS L1\\n            doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\\n\\n            return {\"doppler_shift\": doppler_hz}\\n\\n        def property_names(self) -&gt; list:\\n            \\'\\'\\'Return list of property names this computer produces.\\'\\'\\'\\n            return [\"doppler_shift\"]\\n\\n    # Use with access computation (future)\\n    computer = DopplerComputer()\\n    # accesses = bh.compute_accesses(..., property_computers=[computer])\\n    ```\\n\\nNotes:\\n    - The `compute` method receives ECEF coordinates in SI units (meters, m/s)\\n    - Property values are automatically converted to appropriate Rust types\\n    - The window parameter provides access to timing via:\\n      - `window.window_open`: Start epoch\\n      - `window.window_close`: End epoch\\n      - `window.midtime()`: Midpoint epoch\\n      - `window.duration()`: Duration in seconds'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(_window, _satellite_state_ecef, _location_ecef) -&gt; dict\n</code></pre> <p>Compute custom properties for an access window.</p> <p>Override this method in your subclass to implement custom property calculations.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>AccessWindow</code> <p>Access window with timing information</p> required <code>satellite_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping property names (str) to values (scalar, list, dict, etc.)</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.property_names","title":"property_names  <code>method descriptor</code>","text":"<pre><code>property_names() -&gt; list[str]\n</code></pre> <p>Return list of property names this computer will produce.</p> <p>Override this method to return the list of property names that your compute() method will include in its returned dictionary.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of property names</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/enums.html","title":"Access Enumerations","text":"<p>Enumeration types used in access computation.</p>"},{"location":"library_api/access/enums.html#lookdirection","title":"LookDirection","text":""},{"location":"library_api/access/enums.html#brahe.LookDirection","title":"LookDirection","text":"<pre><code>LookDirection()\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <code>Any</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <code>Any</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <code>Any</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = LookDirection.Either\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.LEFT","title":"LEFT  <code>class-attribute</code>","text":"<pre><code>LEFT: Any = LookDirection.Left\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.RIGHT","title":"RIGHT  <code>class-attribute</code>","text":"<pre><code>RIGHT: Any = LookDirection.Right\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Look direction of a satellite relative to its velocity vector.\\n\\nIndicates whether a satellite is looking to the left (counterclockwise from velocity),\\nright (clockwise from velocity), or either direction.\\n\\nThis is commonly used for imaging satellites with side-looking sensors or SAR systems\\nthat have a preferred look direction.\\n\\nAttributes:\\n    LEFT: Left-looking (counterclockwise from velocity vector)\\n    RIGHT: Right-looking (clockwise from velocity vector)\\n    EITHER: Either left or right is acceptable\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a constraint for right-looking only satellites\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\\n\\n    # Create a constraint accepting either direction\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\\n\\n    # Compare look directions\\n    assert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\\n    assert bh.LookDirection.LEFT == bh.LookDirection.LEFT\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/enums.html#ascdsc","title":"AscDsc","text":""},{"location":"library_api/access/enums.html#brahe.AscDsc","title":"AscDsc","text":"<pre><code>AscDsc()\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>Any</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <code>Any</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <code>Any</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.ASCENDING","title":"ASCENDING  <code>class-attribute</code>","text":"<pre><code>ASCENDING: Any = AscDsc.Ascending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.DESCENDING","title":"DESCENDING  <code>class-attribute</code>","text":"<pre><code>DESCENDING: Any = AscDsc.Descending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = AscDsc.Either\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Ascending or descending pass type for satellite orbits.\\n\\nIndicates whether a satellite is moving from south to north (ascending) or\\nnorth to south (descending) in its orbit. This is determined by the sign of\\nthe Z-component of the velocity vector in ECEF coordinates.\\n\\nThis is useful for:\\n- Sun-synchronous orbits that prefer specific pass types\\n- Minimizing lighting variation between passes\\n- Coordinating multi-satellite observations\\n\\nAttributes:\\n    ASCENDING: Satellite moving from south to north (vz &gt; 0 in ECEF)\\n    DESCENDING: Satellite moving from north to south (vz &lt; 0 in ECEF)\\n    EITHER: Either ascending or descending is acceptable\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a constraint for ascending passes only\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\\n\\n    # Create a constraint for descending passes only\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\\n\\n    # Accept either type\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\\n\\n    # Compare pass types\\n    assert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\\n    assert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html","title":"Locations","text":"<p>Location types represent ground positions or areas that satellites can access.</p>"},{"location":"library_api/access/locations.html#pointlocation","title":"PointLocation","text":""},{"location":"library_api/access/locations.html#brahe.PointLocation","title":"PointLocation","text":"<pre><code>PointLocation(lon: float, lat: float, alt: float)\n</code></pre> <p>A single point location on Earth's surface.</p> <p>Represents a discrete point with geodetic coordinates (longitude, latitude, altitude). Commonly used for ground stations, imaging targets, or tessellated polygon tiles.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude in degrees (-180 to 180)</p> required <code>lat</code> <code>float</code> <p>Latitude in degrees (-90 to 90)</p> required <code>alt</code> <code>float</code> <p>Altitude above ellipsoid in meters (default: 0.0)</p> required Example <pre><code>import brahe as bh\n\n# Create a ground station in Svalbard\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\n\n# With identity\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard Ground Station\") \\\\\n    .with_id(1)\n\n# With custom properties\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"min_elevation_deg\", 5.0)\n\n# Access coordinates as properties\nlon = svalbard.lon  # Property (always degrees)\nlat = svalbard.lat  # Property (always degrees)\nlat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'A single point location on Earth\\'s surface.\\n\\nRepresents a discrete point with geodetic coordinates (longitude, latitude, altitude).\\nCommonly used for ground stations, imaging targets, or tessellated polygon tiles.\\n\\nArgs:\\n    lon (float): Longitude in degrees (-180 to 180)\\n    lat (float): Latitude in degrees (-90 to 90)\\n    alt (float): Altitude above ellipsoid in meters (default: 0.0)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a ground station in Svalbard\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\\n\\n    # With identity\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\\\\\\n        .with_name(\"Svalbard Ground Station\") \\\\\\\\\\n        .with_id(1)\\n\\n    # With custom properties\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\\\\\\n        .add_property(\"country\", \"Norway\") \\\\\\\\\\n        .add_property(\"min_elevation_deg\", 5.0)\\n\\n    # Access coordinates as properties\\n    lon = svalbard.lon  # Property (always degrees)\\n    lat = svalbard.lat  # Property (always degrees)\\n    lat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nprint(loc.properties[\"climate\"])  # \"Arctic\"\n\n# Dict methods\nif \"country\" in loc.properties:\n    del loc.properties[\"country\"]\n\n# Iteration\nfor key in loc.properties.keys():\n    print(key, loc.properties[key])\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value) -&gt; PointLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"elevation_mask_deg\", 5.0)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; np.ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; np.ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PointLocation\n</code></pre> <p>Create from GeoJSON Point Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Point geometry</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>New location instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Point Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 0.0]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\"\n    }\n}\n\nlocation = bh.PointLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard\")\n\ngeojson = location.to_geojson()\n# Returns:\n# {\n#     \"type\": \"Feature\",\n#     \"geometry\": {\n#         \"type\": \"Point\",\n#         \"coordinates\": [15.4, 78.2, 0.0]\n#     },\n#     \"properties\": {\n#         \"name\": \"Svalbard\"\n#     }\n# }\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PointLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PointLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PointLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PointLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/locations.html#polygonlocation","title":"PolygonLocation","text":""},{"location":"library_api/access/locations.html#brahe.PolygonLocation","title":"PolygonLocation","text":"<pre><code>PolygonLocation(vertices: list[list[float]])\n</code></pre> <p>A polygonal area on Earth's surface.</p> <p>Represents a closed polygon with multiple vertices. Commonly used for areas of interest, no-fly zones, or imaging footprints.</p> <p>The polygon is automatically closed if the first and last vertices don't match.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[list[float]]</code> <p>List of [lon, lat, alt] vertices in degrees and meters</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If polygon has fewer than 4 vertices or has validation errors</p> Example <pre><code>import brahe as bh\n\n# Define a rectangular area\nvertices = [\n    [10.0, 50.0, 0.0],  # lon, lat, alt\n    [11.0, 50.0, 0.0],\n    [11.0, 51.0, 0.0],\n    [10.0, 51.0, 0.0],\n    [10.0, 50.0, 0.0],  # Closed (first == last)\n]\npolygon = bh.PolygonLocation(vertices)\n\n# With identity\npolygon = bh.PolygonLocation(vertices) \\\\\n    .with_name(\"AOI-1\") \\\\\n    .add_property(\"region\", \"Europe\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'A polygonal area on Earth\\'s surface.\\n\\nRepresents a closed polygon with multiple vertices.\\nCommonly used for areas of interest, no-fly zones, or imaging footprints.\\n\\nThe polygon is automatically closed if the first and last vertices don\\'t match.\\n\\nArgs:\\n    vertices (list[list[float]]): List of [lon, lat, alt] vertices in degrees and meters\\n\\nRaises:\\n    ValueError: If polygon has fewer than 4 vertices or has validation errors\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Define a rectangular area\\n    vertices = [\\n        [10.0, 50.0, 0.0],  # lon, lat, alt\\n        [11.0, 50.0, 0.0],\\n        [11.0, 51.0, 0.0],\\n        [10.0, 51.0, 0.0],\\n        [10.0, 50.0, 0.0],  # Closed (first == last)\\n    ]\\n    polygon = bh.PolygonLocation(vertices)\\n\\n    # With identity\\n    polygon = bh.PolygonLocation(vertices) \\\\\\\\\\n        .with_name(\"AOI-1\") \\\\\\\\\\n        .add_property(\"region\", \"Europe\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get center latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get center longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.num_vertices","title":"num_vertices  <code>property</code>","text":"<pre><code>num_vertices: int\n</code></pre> <p>Get number of unique vertices (excluding closure).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of unique vertices</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nverts = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]\npoly = bh.PolygonLocation(verts)\n\n# Dict-style assignment\npoly.properties[\"region\"] = \"Test Area\"\npoly.properties[\"area_km2\"] = 123.45\n\n# Dict-style access\nprint(poly.properties[\"region\"])  # \"Test Area\"\n\n# Dict methods\nif \"area_km2\" in poly.properties:\n    del poly.properties[\"area_km2\"]\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.vertices","title":"vertices  <code>property</code>","text":"<pre><code>vertices: ndarray\n</code></pre> <p>Get polygon vertices.</p> <p>Returns all vertices including the closure vertex (first == last).</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Vertices as Nx3 array [[lon, lat, alt], ...]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value) -&gt; PolygonLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; np.ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; np.ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PolygonLocation\n</code></pre> <p>Create from GeoJSON Polygon Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Polygon geometry</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>New polygon instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Polygon Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\"\n    }\n}\n\npolygon = bh.PolygonLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PolygonLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PolygonLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PolygonLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PolygonLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/windows.html","title":"Access Windows","text":"<p>Access windows represent time periods when satellites can access ground locations.</p>"},{"location":"library_api/access/windows.html#accesswindow","title":"AccessWindow","text":""},{"location":"library_api/access/windows.html#brahe.AccessWindow","title":"AccessWindow","text":"<pre><code>AccessWindow(window_open: Epoch, window_close: Epoch)\n</code></pre> <p>An access window representing a period of time when access constraints are satisfied.</p> <p>AccessWindow stores the opening and closing times of an access period, along with computed properties for that window.</p> <p>Parameters:</p> Name Type Description Default <code>window_open</code> <code>Epoch</code> <p>Opening time of the access window</p> required <code>window_close</code> <code>Epoch</code> <p>Closing time of the access window</p> required Example <pre><code>import brahe as bh\n\n# Create an access window\nt_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\nt_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\nwindow = bh.AccessWindow(t_open, t_close)\n\n# Access window properties\nprint(f\"Duration: {window.duration()} seconds\")\nprint(f\"Midpoint: {window.midtime()}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'An access window representing a period of time when access constraints are satisfied.\\n\\nAccessWindow stores the opening and closing times of an access period, along with\\ncomputed properties for that window.\\n\\nArgs:\\n    window_open (Epoch): Opening time of the access window\\n    window_close (Epoch): Closing time of the access window\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create an access window\\n    t_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\\n    t_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\\n    window = bh.AccessWindow(t_open, t_close)\\n\\n    # Access window properties\\n    print(f\"Duration: {window.duration()} seconds\")\\n    print(f\"Midpoint: {window.midtime()}\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: AscDsc\n</code></pre> <p>Get ascending/descending pass type.</p> <p>Returns:</p> Name Type Description <code>AscDsc</code> <code>AscDsc</code> <p>Pass type enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: float\n</code></pre> <p>Get azimuth angle at window closing (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: float\n</code></pre> <p>Get azimuth angle at window opening (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Get the duration of the access window in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Duration in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: float\n</code></pre> <p>Get maximum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: float\n</code></pre> <p>Get minimum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.end","title":"end  <code>property</code>","text":"<pre><code>end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[int]\n</code></pre> <p>Get the access window numeric ID.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Window ID, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: float\n</code></pre> <p>Get local solar time at window midpoint (seconds since midnight, 0-86400).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Local time in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_id","title":"location_id  <code>property</code>","text":"<pre><code>location_id: Optional[int]\n</code></pre> <p>Get the location ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_name","title":"location_name  <code>property</code>","text":"<pre><code>location_name: Optional[str]\n</code></pre> <p>Get the location name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_uuid","title":"location_uuid  <code>property</code>","text":"<pre><code>location_uuid: Optional[str]\n</code></pre> <p>Get the location UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the location as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: LookDirection\n</code></pre> <p>Get look direction (Left or Right).</p> <p>Returns:</p> Name Type Description <code>LookDirection</code> <code>LookDirection</code> <p>Look direction enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.midtime","title":"midtime  <code>property</code>","text":"<pre><code>midtime: Epoch\n</code></pre> <p>Get the midpoint time of the access window.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Midpoint time (average of start and end)</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>Get the access window name (auto-generated or user-set).</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Window name, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: float\n</code></pre> <p>Get maximum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: float\n</code></pre> <p>Get minimum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: AccessProperties\n</code></pre> <p>Get the access properties object.</p> <p>Returns:</p> Name Type Description <code>AccessProperties</code> <code>AccessProperties</code> <p>Computed properties for this access window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_id","title":"satellite_id  <code>property</code>","text":"<pre><code>satellite_id: Optional[int]\n</code></pre> <p>Get the satellite/object ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: Optional[str]\n</code></pre> <p>Get the satellite/object name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_uuid","title":"satellite_uuid  <code>property</code>","text":"<pre><code>satellite_uuid: Optional[str]\n</code></pre> <p>Get the satellite UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the satellite as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.start","title":"start  <code>property</code>","text":"<pre><code>start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: Optional[str]\n</code></pre> <p>Get the access window UUID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_close","title":"window_close  <code>property</code>","text":"<pre><code>window_close: Epoch\n</code></pre> <p>Get the window closing time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window closing time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_open","title":"window_open  <code>property</code>","text":"<pre><code>window_open: Epoch\n</code></pre> <p>Get the window opening time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window opening time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/windows.html#accessproperties","title":"AccessProperties","text":""},{"location":"library_api/access/windows.html#brahe.AccessProperties","title":"AccessProperties","text":"<pre><code>AccessProperties()\n</code></pre> <p>Properties computed for an access window.</p> <p>AccessProperties contains geometric properties (azimuth, elevation, off-nadir angles, local time, look direction, ascending/descending) computed over an access window, plus a dictionary of additional custom properties.</p> <p>Attributes:</p> Name Type Description <code>azimuth_open</code> <code>float</code> <p>Azimuth angle at window opening (degrees, 0-360)</p> <code>azimuth_close</code> <code>float</code> <p>Azimuth angle at window closing (degrees, 0-360)</p> <code>elevation_min</code> <code>float</code> <p>Minimum elevation angle (degrees)</p> <code>elevation_max</code> <code>float</code> <p>Maximum elevation angle (degrees)</p> <code>off_nadir_min</code> <code>float</code> <p>Minimum off-nadir angle (degrees)</p> <code>off_nadir_max</code> <code>float</code> <p>Maximum off-nadir angle (degrees)</p> <code>local_time</code> <code>float</code> <p>Local solar time (seconds since midnight, 0-86400)</p> <code>look_direction</code> <code>LookDirection</code> <p>Required look direction (Left or Right)</p> <code>asc_dsc</code> <code>AscDsc</code> <p>Pass type (Ascending or Descending)</p> Example <pre><code>import brahe as bh\n\n# Access properties are typically computed by the access computation system\n# This example shows accessing the properties\nprops = ...  # From access computation\n\nprint(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\nprint(f\"Max elevation: {props.elevation_max}\u00b0\")\nprint(f\"Look direction: {props.look_direction}\")\n\n# Access additional custom properties\nif \"signal_strength\" in props.additional:\n    print(f\"Signal: {props.additional['signal_strength']}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Properties computed for an access window.\\n\\nAccessProperties contains geometric properties (azimuth, elevation, off-nadir angles,\\nlocal time, look direction, ascending/descending) computed over an access window,\\nplus a dictionary of additional custom properties.\\n\\nAttributes:\\n    azimuth_open (float): Azimuth angle at window opening (degrees, 0-360)\\n    azimuth_close (float): Azimuth angle at window closing (degrees, 0-360)\\n    elevation_min (float): Minimum elevation angle (degrees)\\n    elevation_max (float): Maximum elevation angle (degrees)\\n    off_nadir_min (float): Minimum off-nadir angle (degrees)\\n    off_nadir_max (float): Maximum off-nadir angle (degrees)\\n    local_time (float): Local solar time (seconds since midnight, 0-86400)\\n    look_direction (LookDirection): Required look direction (Left or Right)\\n    asc_dsc (AscDsc): Pass type (Ascending or Descending)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Access properties are typically computed by the access computation system\\n    # This example shows accessing the properties\\n    props = ...  # From access computation\\n\\n    print(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\\n    print(f\"Max elevation: {props.elevation_max}\u00b0\")\\n    print(f\"Look direction: {props.look_direction}\")\\n\\n    # Access additional custom properties\\n    if \"signal_strength\" in props.additional:\\n        print(f\"Signal: {props.additional[\\'signal_strength\\']}\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.additional","title":"additional  <code>property</code>","text":"<pre><code>additional: AdditionalPropertiesDict\n</code></pre> <p>Get additional properties as a dict-like wrapper.</p> <p>Returns a dictionary-like object that automatically converts between Python types and internal PropertyValue representation.</p> <p>Supported Python types: - float -&gt; Scalar - list[float] -&gt; Vector - bool -&gt; Boolean - str -&gt; String - dict -&gt; Json</p> <p>Returns:</p> Name Type Description <code>AdditionalPropertiesDict</code> <code>AdditionalPropertiesDict</code> <p>Dict-like wrapper for additional properties</p> Example <pre><code># Dict-style assignment\nprops.additional[\"doppler_shift\"] = 2500.0\nprops.additional[\"snr_values\"] = [10.5, 12.3, 15.1]\nprops.additional[\"has_eclipse\"] = False\n\n# Dict-style access\nprint(props.additional[\"doppler_shift\"])  # 2500.0\n\n# Dict methods\nif \"doppler_shift\" in props.additional:\n    del props.additional[\"doppler_shift\"]\n\n# Iteration\nfor key in props.additional.keys():\n    print(key, props.additional[key])\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/index.html","title":"Attitude","text":"<p>Module: <code>brahe.attitude</code></p> <p>Classes for representing and converting between different attitude representations.</p>"},{"location":"library_api/attitude/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Quaternion - Quaternion representation</li> <li>Rotation Matrix - Direction Cosine Matrix (DCM) representation</li> <li>Euler Angles - Euler angle sequences</li> <li>Euler Axis - Euler axis-angle representation</li> </ul>"},{"location":"library_api/attitude/euler_angles.html","title":"EulerAngle Class","text":"<p>The <code>EulerAngle</code> class represents attitude using Euler angle sequences for intuitive spacecraft orientation specification.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle","title":"EulerAngle","text":"<pre><code>EulerAngle(order: str, phi: float, theta: float, psi: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler angles.</p> <p>Euler angles describe rotations as a sequence of three rotations about specified axes. The rotation sequence is specified by the order parameter (e.g., \"XYZ\", \"ZYX\").</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")</p> required <code>phi</code> <code>float</code> <p>First rotation angle in radians or degrees</p> required <code>theta</code> <code>float</code> <p>Second rotation angle in radians or degrees</p> required <code>psi</code> <code>float</code> <p>Third rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\n\n# Create Euler angle rotation (roll, pitch, yaw in ZYX order)\ne = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n\n# Convert to rotation matrix\ndcm = e.to_rotation_matrix()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler angles.\\n\\nEuler angles describe rotations as a sequence of three rotations about\\nspecified axes. The rotation sequence is specified by the order parameter\\n(e.g., \"XYZ\", \"ZYX\").\\n\\nArgs:\\n    order (str): Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")\\n    phi (float): First rotation angle in radians or degrees\\n    theta (float): Second rotation angle in radians or degrees\\n    psi (float): Third rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angles (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create Euler angle rotation (roll, pitch, yaw in ZYX order)\\n    e = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\\n    print(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n\\n    # Convert to rotation matrix\\n    dcm = e.to_rotation_matrix()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.order","title":"order  <code>property</code>","text":"<pre><code>order: str\n</code></pre> <p>Get the rotation sequence order.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Order: {e.order}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.phi","title":"phi  <code>property</code>","text":"<pre><code>phi: float\n</code></pre> <p>Get the first rotation angle (phi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Phi: {e.phi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.psi","title":"psi  <code>property</code>","text":"<pre><code>psi: float\n</code></pre> <p>Get the third rotation angle (psi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Third rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Psi: {e.psi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.theta","title":"theta  <code>property</code>","text":"<pre><code>theta: float\n</code></pre> <p>Get the second rotation angle (theta) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Theta: {e.theta}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from another Euler angle with different order.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Source Euler angles</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAngle.from_euler_angle(e1, \"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = bh.EulerAngle.from_euler_axis(ea, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAngle.from_quaternion(q, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAngle.from_rotation_matrix(r, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, order: str, angle_format: AngleFormat) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>3-element array [phi, theta, psi]</p> required <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>New Euler angle instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.1, 0.2, 0.3])\neuler = bh.EulerAngle.from_vector(v, \"XYZ\", bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angles with different rotation sequence.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_angle(\"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nea = e.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html","title":"EulerAxis Class","text":"<p>The <code>EulerAxis</code> class represents attitude using axis-angle representation (Euler's rotation theorem).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis","title":"EulerAxis","text":"<pre><code>EulerAxis(axis: ndarray, angle: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler axis-angle representation.</p> <p>The Euler axis-angle representation describes a rotation as a single rotation about a specified axis by a given angle. This is also known as the axis-angle or rotation vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>3-element unit vector specifying rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Rotation of 90 degrees about z-axis\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle} rad\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler axis-angle representation.\\n\\nThe Euler axis-angle representation describes a rotation as a single rotation\\nabout a specified axis by a given angle. This is also known as the axis-angle\\nor rotation vector representation.\\n\\nArgs:\\n    axis (numpy.ndarray): 3-element unit vector specifying rotation axis\\n    angle (float): Rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angle (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Rotation of 90 degrees about z-axis\\n    axis = np.array([0.0, 0.0, 1.0])\\n    e = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\\n    print(f\"Angle: {e.angle} rad\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.angle","title":"angle  <code>property</code>","text":"<pre><code>angle: float\n</code></pre> <p>Get the rotation angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rotation angle in radians</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.axis","title":"axis  <code>property</code>","text":"<pre><code>axis: ndarray\n</code></pre> <p>Get the rotation axis as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3-element unit vector specifying rotation axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Axis: {e.axis}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne = bh.EulerAxis.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from another Euler axis (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Source Euler axis</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAxis.from_euler_axis(e1)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAxis.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAxis.from_rotation_matrix(r)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(x: float, y: float, z: float, angle: float, angle_format: AngleFormat) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from individual axis components and angle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X component of rotation axis</p> required <code>y</code> <code>float</code> <p>Y component of rotation axis</p> required <code>z</code> <code>float</code> <p>Z component of rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAxis.from_values(0.0, 0.0, 1.0, 1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, angle_format: AngleFormat, vector_first: bool) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing axis and angle</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, array is [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.0, 0.0, 1.0, 1.5708])\ne = bh.EulerAxis.from_vector(v, bh.AngleFormat.RADIANS, True)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = ea.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation (returns self).</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>This Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(angle_format: AngleFormat, vector_first: bool) -&gt; np.ndarray\n</code></pre> <p>Convert Euler axis to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Units for output angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, returns [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing axis and angle</p>"},{"location":"library_api/attitude/quaternion.html","title":"Quaternion Class","text":"<p>The <code>Quaternion</code> class provides a compact, singularity-free representation of 3D rotations for spacecraft attitude determination and control.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(w: float, x: float, y: float, z: float)\n</code></pre> <p>Represents a quaternion for 3D rotations.</p> <p>Quaternions provide a compact, singularity-free representation of rotations. The quaternion is stored as [w, x, y, z] where w is the scalar part and [x, y, z] is the vector part.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Scalar component</p> required <code>x</code> <code>float</code> <p>X component of vector part</p> required <code>y</code> <code>float</code> <p>Y component of vector part</p> required <code>z</code> <code>float</code> <p>Z component of vector part</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity quaternion\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nprint(f\"Norm: {q.norm()}\")\n\n# Create from array\nq_vec = np.array([1.0, 0.0, 0.0, 0.0])\nq2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\n\n# Convert to rotation matrix\ndcm = q.to_rotation_matrix()\n\n# Quaternion multiplication\nq3 = q * q2\n\n# Normalize\nq3.normalize()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a quaternion for 3D rotations.\\n\\nQuaternions provide a compact, singularity-free representation of rotations.\\nThe quaternion is stored as [w, x, y, z] where w is the scalar part and\\n[x, y, z] is the vector part.\\n\\nArgs:\\n    w (float): Scalar component\\n    x (float): X component of vector part\\n    y (float): Y component of vector part\\n    z (float): Z component of vector part\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity quaternion\\n    q = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\\n    print(f\"Norm: {q.norm()}\")\\n\\n    # Create from array\\n    q_vec = np.array([1.0, 0.0, 0.0, 0.0])\\n    q2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\\n\\n    # Convert to rotation matrix\\n    dcm = q.to_rotation_matrix()\\n\\n    # Quaternion multiplication\\n    q3 = q * q2\\n\\n    # Normalize\\n    q3.normalize()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the quaternion components as a numpy array [w, x, y, z].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.conjugate","title":"conjugate  <code>method descriptor</code>","text":"<pre><code>conjugate() -&gt; Quaternion\n</code></pre> <p>Compute the conjugate of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Conjugate quaternion with negated vector part</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_conj = q.conjugate()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from another quaternion (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion.from_quaternion(q1)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nrm = bh.RotationMatrix.from_matrix(mat)\nq = bh.Quaternion.from_rotation_matrix(rm)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, scalar_first: bool) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing quaternion components</p> required <code>scalar_first</code> <code>bool</code> <p>If True, array is [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([1.0, 0.0, 0.0, 0.0])\nq = bh.Quaternion.from_vector(v, scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.inverse","title":"inverse  <code>method descriptor</code>","text":"<pre><code>inverse() -&gt; Quaternion\n</code></pre> <p>Compute the inverse of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Inverse quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_inv = q.inverse()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.norm","title":"norm  <code>method descriptor</code>","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Calculate the norm (magnitude) of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean norm of the quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nnorm = q.norm()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.normalize","title":"normalize  <code>method descriptor</code>","text":"<pre><code>normalize() -&gt; Any\n</code></pre> <p>Normalize the quaternion in-place to unit length.</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(2.0, 0.0, 0.0, 0.0)\nq.normalize()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.slerp","title":"slerp  <code>method descriptor</code>","text":"<pre><code>slerp(other: Quaternion, t: float) -&gt; Quaternion\n</code></pre> <p>Perform spherical linear interpolation (SLERP) between two quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Quaternion</code> <p>Target quaternion</p> required <code>t</code> <code>float</code> <p>Interpolation parameter in [0, 1]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Interpolated quaternion</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion(0.707, 0.707, 0.0, 0.0)\nq_mid = q1.slerp(q2, 0.5)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = q.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation (returns self).</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>This quaternion</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(scalar_first: bool) -&gt; np.ndarray\n</code></pre> <p>Convert quaternion to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_first</code> <code>bool</code> <p>If True, returns [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nv = q.to_vector(scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html","title":"RotationMatrix Class","text":"<p>The <code>RotationMatrix</code> class represents attitude using Direction Cosine Matrices (DCM) for spacecraft orientation and coordinate transformations.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix","title":"RotationMatrix","text":"<pre><code>RotationMatrix(r11: float, r12: float, r13: float, r21: float, r22: float, r23: float, r31: float, r32: float, r33: float)\n</code></pre> <p>Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).</p> <p>A rotation matrix is an orthogonal 3x3 matrix with determinant +1 that represents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>r11</code> <code>float</code> <p>Element at row 1, column 1</p> required <code>r12</code> <code>float</code> <p>Element at row 1, column 2</p> required <code>r13</code> <code>float</code> <p>Element at row 1, column 3</p> required <code>r21</code> <code>float</code> <p>Element at row 2, column 1</p> required <code>r22</code> <code>float</code> <p>Element at row 2, column 2</p> required <code>r23</code> <code>float</code> <p>Element at row 2, column 3</p> required <code>r31</code> <code>float</code> <p>Element at row 3, column 1</p> required <code>r32</code> <code>float</code> <p>Element at row 3, column 2</p> required <code>r33</code> <code>float</code> <p>Element at row 3, column 3</p> required <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity rotation\ndcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n\n# Create from numpy array\nR = np.eye(3)\ndcm2 = bh.RotationMatrix.from_matrix(R)\n\n# Convert to quaternion\nq = dcm.to_quaternion()\n\n# Rotate a vector\nv = np.array([1.0, 0.0, 0.0])\nv_rot = dcm.rotate_vector(v)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).\\n\\nA rotation matrix is an orthogonal 3x3 matrix with determinant +1 that\\nrepresents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).\\n\\nArgs:\\n    r11 (float): Element at row 1, column 1\\n    r12 (float): Element at row 1, column 2\\n    r13 (float): Element at row 1, column 3\\n    r21 (float): Element at row 2, column 1\\n    r22 (float): Element at row 2, column 2\\n    r23 (float): Element at row 2, column 3\\n    r31 (float): Element at row 3, column 1\\n    r32 (float): Element at row 3, column 2\\n    r33 (float): Element at row 3, column 3\\n\\nRaises:\\n    BraheError: If the matrix is not a valid rotation matrix\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity rotation\\n    dcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\\n\\n    # Create from numpy array\\n    R = np.eye(3)\\n    dcm2 = bh.RotationMatrix.from_matrix(R)\\n\\n    # Convert to quaternion\\n    q = dcm.to_quaternion()\\n\\n    # Rotate a vector\\n    v = np.array([1.0, 0.0, 0.0])\\n    v_rot = dcm.rotate_vector(v)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rx","title":"Rx  <code>builtin</code>","text":"<pre><code>Rx(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for X-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Ry","title":"Ry  <code>builtin</code>","text":"<pre><code>Ry(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Y-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rz","title":"Rz  <code>builtin</code>","text":"<pre><code>Rz(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Z-axis rotation</p> Example <pre><code>import brahe as bh\n\nr = bh.RotationMatrix.Rz(1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from an Euler axis.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_matrix","title":"from_matrix  <code>builtin</code>","text":"<pre><code>from_matrix(m: ndarray) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a 3x3 numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nr = bh.RotationMatrix.from_matrix(mat)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nr = bh.RotationMatrix.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from another rotation matrix (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Source rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = bh.RotationMatrix.from_rotation_matrix(r1)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\neuler = r.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = r.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Convert rotation matrix to a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\nq = r.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation (returns self).</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>This rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = r1.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/constants/index.html","title":"Constants","text":"<p>Mathematical, physical, and astronomical constants used throughout the brahe library.</p>"},{"location":"library_api/constants/index.html#categories","title":"Categories","text":""},{"location":"library_api/constants/index.html#units","title":"Units","text":"<p>Angle format enumerations and time system constants for specifying units and reference frames.</p>"},{"location":"library_api/constants/index.html#mathematical-constants","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/index.html#time-constants","title":"Time Constants","text":"<p>Julian date references and time system offset values.</p>"},{"location":"library_api/constants/index.html#physical-constants","title":"Physical Constants","text":"<p>Physical properties of Earth, celestial bodies, and universal constants.</p>"},{"location":"library_api/constants/index.html#quick-reference","title":"Quick Reference","text":"<p>All constants use SI base units unless otherwise noted:</p> <ul> <li>Distance: meters (m)</li> <li>Time: seconds (s)</li> <li>Angles: radians (rad)</li> <li>Gravitational Parameter: m\u00b3/s\u00b2</li> </ul> <p>Constants are accessible directly from the <code>brahe</code> module:</p> <pre><code>import brahe as bh\n\n# Mathematical constants\nangle_rad = 45.0 * bh.DEG2RAD  # Convert degrees to radians\n\n# Physical constants\nmu_earth = bh.GM_EARTH  # Earth's gravitational parameter\nc = bh.C_LIGHT          # Speed of light\n\n# Time system\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n</code></pre>"},{"location":"library_api/constants/math.html","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/math.html#angle-conversions","title":"Angle Conversions","text":""},{"location":"library_api/constants/math.html#deg2rad","title":"DEG2RAD","text":"<p>Value: <code>0.017453292519943295</code> rad/deg</p> <p>Converts degrees to radians. Equivalent to \u03c0/180.</p>"},{"location":"library_api/constants/math.html#brahe.DEG2RAD","title":"DEG2RAD  <code>module-attribute</code>","text":"<pre><code>DEG2RAD: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2deg","title":"RAD2DEG","text":"<p>Value: <code>57.29577951308232</code> deg/rad</p> <p>Converts radians to degrees. Equivalent to 180/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2DEG","title":"RAD2DEG  <code>module-attribute</code>","text":"<pre><code>RAD2DEG: float = 57.29577951308232\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#as2rad","title":"AS2RAD","text":"<p>Value: <code>4.84813681109536e-06</code> rad/arcsec</p> <p>Converts arc seconds to radians. Equivalent to \u03c0/(180 \u00d7 3600).</p>"},{"location":"library_api/constants/math.html#brahe.AS2RAD","title":"AS2RAD  <code>module-attribute</code>","text":"<pre><code>AS2RAD: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2as","title":"RAD2AS","text":"<p>Value: <code>206264.80624709636</code> arcsec/rad</p> <p>Converts radians to arc seconds. Equivalent to (180 \u00d7 3600)/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2AS","title":"RAD2AS  <code>module-attribute</code>","text":"<pre><code>RAD2AS: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html","title":"Physical Constants","text":"<p>Physical properties of celestial bodies and universal constants. All values use SI base units.</p>"},{"location":"library_api/constants/physical.html#universal-constants","title":"Universal Constants","text":""},{"location":"library_api/constants/physical.html#c_light","title":"C_LIGHT","text":"<p>Value: <code>299792458.0</code> m/s</p> <p>Speed of light in vacuum.</p>"},{"location":"library_api/constants/physical.html#brahe.C_LIGHT","title":"C_LIGHT  <code>module-attribute</code>","text":"<pre><code>C_LIGHT: float = 299792458.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#au","title":"AU","text":"<p>Value: <code>1.495978707e11</code> m</p> <p>Astronomical Unit - mean distance of Earth from the Sun. TDB-compatible value.</p>"},{"location":"library_api/constants/physical.html#brahe.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870700.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#p_sun","title":"P_SUN","text":"<p>Value: <code>4.56e-6</code> N/m\u00b2</p> <p>Solar radiation pressure at 1 AU.</p>"},{"location":"library_api/constants/physical.html#brahe.P_SUN","title":"P_SUN  <code>module-attribute</code>","text":"<pre><code>P_SUN: float = 4.56e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#earth-constants","title":"Earth Constants","text":""},{"location":"library_api/constants/physical.html#geometry","title":"Geometry","text":""},{"location":"library_api/constants/physical.html#r_earth","title":"R_EARTH","text":"<p>Value: <code>6378136.3</code> m</p> <p>Earth's equatorial radius (GGM05 gravity model).</p>"},{"location":"library_api/constants/physical.html#brahe.R_EARTH","title":"R_EARTH  <code>module-attribute</code>","text":"<pre><code>R_EARTH: float = 6378136.3\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_a","title":"WGS84_A","text":"<p>Value: <code>6378137.0</code> m</p> <p>Earth's semi-major axis as defined by WGS84 geodetic system.</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_A","title":"WGS84_A  <code>module-attribute</code>","text":"<pre><code>WGS84_A: float = 6378137.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_f","title":"WGS84_F","text":"<p>Value: <code>0.0033528106647474805</code> (dimensionless)</p> <p>Earth's ellipsoidal flattening. WGS84 value: 1/298.257223563</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_F","title":"WGS84_F  <code>module-attribute</code>","text":"<pre><code>WGS84_F: float = 0.0033528106647474805\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#ecc_earth","title":"ECC_EARTH","text":"<p>Value: <code>0.081819190842622</code> (dimensionless)</p> <p>Earth's first eccentricity (WGS84 value).</p>"},{"location":"library_api/constants/physical.html#brahe.ECC_EARTH","title":"ECC_EARTH  <code>module-attribute</code>","text":"<pre><code>ECC_EARTH: float = 0.081819190842622\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gravitational-properties","title":"Gravitational Properties","text":""},{"location":"library_api/constants/physical.html#gm_earth","title":"GM_EARTH","text":"<p>Value: <code>3.986004415e14</code> m\u00b3/s\u00b2</p> <p>Earth's gravitational parameter (\u03bc = G \u00d7 M).</p>"},{"location":"library_api/constants/physical.html#brahe.GM_EARTH","title":"GM_EARTH  <code>module-attribute</code>","text":"<pre><code>GM_EARTH: float = 398600441500000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#j2_earth","title":"J2_EARTH","text":"<p>Value: <code>0.0010826358191967</code> (dimensionless)</p> <p>Earth's J2 zonal harmonic coefficient (GGM05s gravity model). Represents Earth's oblateness.</p>"},{"location":"library_api/constants/physical.html#brahe.J2_EARTH","title":"J2_EARTH  <code>module-attribute</code>","text":"<pre><code>J2_EARTH: float = 0.0010826358191967\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#omega_earth","title":"OMEGA_EARTH","text":"<p>Value: <code>7.292115146706979e-05</code> rad/s</p> <p>Earth's axial rotation rate.</p>"},{"location":"library_api/constants/physical.html#brahe.OMEGA_EARTH","title":"OMEGA_EARTH  <code>module-attribute</code>","text":"<pre><code>OMEGA_EARTH: float = 7.292115146706979e-05\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#celestial-body-gravitational-parameters","title":"Celestial Body Gravitational Parameters","text":"<p>Gravitational parameters (\u03bc = G \u00d7 M) for major solar system bodies in m\u00b3/s\u00b2.</p>"},{"location":"library_api/constants/physical.html#sun","title":"Sun","text":""},{"location":"library_api/constants/physical.html#gm_sun","title":"GM_SUN","text":"<p>Value: <code>1.32712440041939e20</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SUN","title":"GM_SUN  <code>module-attribute</code>","text":"<pre><code>GM_SUN: float = 1.327124400419394e+20\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_sun","title":"R_SUN","text":"<p>Value: <code>6.9634e8</code> m</p> <p>Solar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_SUN","title":"R_SUN  <code>module-attribute</code>","text":"<pre><code>R_SUN: float = 695700000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#moon","title":"Moon","text":""},{"location":"library_api/constants/physical.html#gm_moon","title":"GM_MOON","text":"<p>Value: <code>4.9028e12</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MOON","title":"GM_MOON  <code>module-attribute</code>","text":"<pre><code>GM_MOON: float = 4902800066000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_moon","title":"R_MOON","text":"<p>Value: <code>1.738e6</code> m</p> <p>Lunar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_MOON","title":"R_MOON  <code>module-attribute</code>","text":"<pre><code>R_MOON: float = 1738000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#inner-planets","title":"Inner Planets","text":""},{"location":"library_api/constants/physical.html#gm_mercury","title":"GM_MERCURY","text":"<p>Value: <code>2.2031868551e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MERCURY","title":"GM_MERCURY  <code>module-attribute</code>","text":"<pre><code>GM_MERCURY: float = 22031780000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_venus","title":"GM_VENUS","text":"<p>Value: <code>3.257e14</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_VENUS","title":"GM_VENUS  <code>module-attribute</code>","text":"<pre><code>GM_VENUS: float = 324858592000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_mars","title":"GM_MARS","text":"<p>Value: <code>4.305e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MARS","title":"GM_MARS  <code>module-attribute</code>","text":"<pre><code>GM_MARS: float = 42828375210000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#outer-planets","title":"Outer Planets","text":""},{"location":"library_api/constants/physical.html#gm_jupiter","title":"GM_JUPITER","text":"<p>Value: <code>1.268e17</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_JUPITER","title":"GM_JUPITER  <code>module-attribute</code>","text":"<pre><code>GM_JUPITER: float = 1.267127648e+17\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_saturn","title":"GM_SATURN","text":"<p>Value: <code>3.794e16</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SATURN","title":"GM_SATURN  <code>module-attribute</code>","text":"<pre><code>GM_SATURN: float = 3.79405852e+16\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_uranus","title":"GM_URANUS","text":"<p>Value: <code>5.794e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_URANUS","title":"GM_URANUS  <code>module-attribute</code>","text":"<pre><code>GM_URANUS: float = 5794548600000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_neptune","title":"GM_NEPTUNE","text":"<p>Value: <code>6.837e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_NEPTUNE","title":"GM_NEPTUNE  <code>module-attribute</code>","text":"<pre><code>GM_NEPTUNE: float = 6836527100580000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#dwarf-planets","title":"Dwarf Planets","text":""},{"location":"library_api/constants/physical.html#gm_pluto","title":"GM_PLUTO","text":"<p>Value: <code>9.77e11</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_PLUTO","title":"GM_PLUTO  <code>module-attribute</code>","text":"<pre><code>GM_PLUTO: float = 977000000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html","title":"Time Constants","text":"<p>Constants related to time systems, epochs, and time conversions.</p>"},{"location":"library_api/constants/time.html#julian-date-references","title":"Julian Date References","text":""},{"location":"library_api/constants/time.html#mjd_zero","title":"MJD_ZERO","text":"<p>Value: <code>2400000.5</code> days</p> <p>Offset of Modified Julian Date (MJD) with respect to Julian Date (JD). For any time t: <pre><code>MJD_ZERO = JD - MJD\n</code></pre></p>"},{"location":"library_api/constants/time.html#brahe.MJD_ZERO","title":"MJD_ZERO  <code>module-attribute</code>","text":"<pre><code>MJD_ZERO: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#mjd2000","title":"MJD2000","text":"<p>Value: <code>51544.5</code> days</p> <p>Modified Julian Date of January 1, 2000 12:00:00 (J2000.0 epoch). Value is independent of time system.</p>"},{"location":"library_api/constants/time.html#brahe.MJD2000","title":"MJD2000  <code>module-attribute</code>","text":"<pre><code>MJD2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps_zero","title":"GPS_ZERO","text":"<p>Value: <code>44244.0</code> days</p> <p>Modified Julian Date of the start of GPS time (January 6, 1980 00:00:00 UTC).</p>"},{"location":"library_api/constants/time.html#brahe.GPS_ZERO","title":"GPS_ZERO  <code>module-attribute</code>","text":"<pre><code>GPS_ZERO: float = 44244.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#time-system-offsets","title":"Time System Offsets","text":"<p>All offset values are in seconds.</p>"},{"location":"library_api/constants/time.html#gps-tai","title":"GPS \u2194 TAI","text":""},{"location":"library_api/constants/time.html#gps_tai","title":"GPS_TAI","text":"<p>Value: <code>-19.0</code> seconds</p> <p>Offset of GPS time with respect to TAI: <code>GPS = TAI + GPS_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TAI","title":"GPS_TAI  <code>module-attribute</code>","text":"<pre><code>GPS_TAI: float = -19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_gps","title":"TAI_GPS","text":"<p>Value: <code>19.0</code> seconds</p> <p>Offset of TAI time with respect to GPS: <code>TAI = GPS + TAI_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_GPS","title":"TAI_GPS  <code>module-attribute</code>","text":"<pre><code>TAI_GPS: float = 19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt-tai","title":"TT \u2194 TAI","text":""},{"location":"library_api/constants/time.html#tt_tai","title":"TT_TAI","text":"<p>Value: <code>32.184</code> seconds</p> <p>Offset of Terrestrial Time with respect to TAI: <code>TT = TAI + TT_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_TAI","title":"TT_TAI  <code>module-attribute</code>","text":"<pre><code>TT_TAI: float = 32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_tt","title":"TAI_TT","text":"<p>Value: <code>-32.184</code> seconds</p> <p>Offset of TAI with respect to Terrestrial Time: <code>TAI = TT + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_TT","title":"TAI_TT  <code>module-attribute</code>","text":"<pre><code>TAI_TT: float = -32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps-tt","title":"GPS \u2194 TT","text":""},{"location":"library_api/constants/time.html#gps_tt","title":"GPS_TT","text":"<p>Value: <code>13.184</code> seconds</p> <p>Offset of GPS time with respect to TT: <code>GPS = TT + GPS_TT</code></p> <p>Computed as: <code>GPS_TAI + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TT","title":"GPS_TT  <code>module-attribute</code>","text":"<pre><code>GPS_TT: float = -51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt_gps","title":"TT_GPS","text":"<p>Value: <code>-13.184</code> seconds</p> <p>Offset of TT with respect to GPS time: <code>TT = GPS + TT_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_GPS","title":"TT_GPS  <code>module-attribute</code>","text":"<pre><code>TT_GPS: float = 51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/units.html","title":"Units","text":"<p>Enumerations for specifying angle formats and time systems.</p>"},{"location":"library_api/constants/units.html#angle-format","title":"Angle Format","text":"<p>The <code>AngleFormat</code> enumeration specifies whether angles are in radians or degrees.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create rotation with angle in degrees\nq = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=90.0,\n    angle_format=bh.AngleFormat.DEGREES\n)\n\n# Create rotation with angle in radians\nq2 = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=np.pi/2,\n    angle_format=bh.AngleFormat.RADIANS\n)\n</code></pre>"},{"location":"library_api/constants/units.html#time-system","title":"Time System","text":"<p>The <code>TimeSystem</code> enumeration specifies the time reference system for epochs.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem","title":"TimeSystem","text":"<pre><code>TimeSystem()\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UTC","title":"UTC  <code>class-attribute</code>","text":"<pre><code>UTC: Any = TimeSystem.UTC\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TAI","title":"TAI  <code>class-attribute</code>","text":"<pre><code>TAI: Any = TimeSystem.TAI\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TT","title":"TT  <code>class-attribute</code>","text":"<pre><code>TT: Any = TimeSystem.TT\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.GPS","title":"GPS  <code>class-attribute</code>","text":"<pre><code>GPS: Any = TimeSystem.GPS\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UT1","title":"UT1  <code>class-attribute</code>","text":"<pre><code>UT1: Any = TimeSystem.UT1\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#time-system-descriptions","title":"Time System Descriptions","text":"<ul> <li>UTC (Coordinated Universal Time): Civil time standard used worldwide. Includes leap seconds to keep within 0.9 seconds of UT1.</li> <li>TAI (International Atomic Time): Continuous time scale based on atomic clocks. Currently 37 seconds ahead of UTC (as of 2024).</li> <li>TT (Terrestrial Time): Theoretical time scale for solar system calculations. TT = TAI + 32.184 seconds.</li> <li>GPS (Global Positioning System): Continuous time starting from GPS epoch (January 6, 1980). Does not include leap seconds.</li> <li>UT1 (Universal Time 1): Based on Earth's rotation. Computed from UTC using Earth Orientation Parameters (EOP).</li> </ul>"},{"location":"library_api/constants/units.html#usage-example_1","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Create epoch in different time systems\nutc_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ntai_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.TAI)\ngps_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\n\n# Time system is preserved in the epoch\nprint(utc_epoch.time_system)  # Output: UTC\nprint(tai_epoch.time_system)  # Output: TAI\n</code></pre>"},{"location":"library_api/coordinates/index.html","title":"Coordinates","text":"<p>Module: <code>brahe.coordinates</code></p> <p>Comprehensive coordinate system transformations for satellite dynamics.</p>"},{"location":"library_api/coordinates/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Enumerations - Coordinate type enumerations (EllipsoidalConversionType, AngleFormat)</li> <li>Cartesian Coordinates - Cartesian state vectors and orbital element conversions</li> <li>Geodetic &amp; Geocentric - WGS84 geodetic and geocentric coordinate conversions</li> <li>Topocentric Coordinates - Local topocentric frames (ENZ, SEZ, AzElRange)</li> </ul>"},{"location":"library_api/coordinates/cartesian.html","title":"Cartesian Coordinates","text":"<p>Functions for working with Cartesian state vectors and conversions.</p>"},{"location":"library_api/coordinates/cartesian.html#state-conversions","title":"State Conversions","text":""},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_osculating_to_cartesian","title":"state_osculating_to_cartesian  <code>builtin</code>","text":"<pre><code>state_osculating_to_cartesian(x_oe: ndarray, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Convert osculating orbital elements to Cartesian state.</p> <p>Transforms a state vector from osculating Keplerian orbital elements to Cartesian position and velocity coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_oe</code> <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Orbital elements for a circular orbit\noe = np.array([7000000.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\nx_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprint(f\"Cartesian state: {x_cart}\")\n</code></pre>"},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_cartesian_to_osculating","title":"state_cartesian_to_osculating  <code>builtin</code>","text":"<pre><code>state_cartesian_to_osculating(x_cart: ndarray, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Convert Cartesian state to osculating orbital elements.</p> <p>Transforms a state vector from Cartesian position and velocity coordinates to osculating Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>x_cart</code> <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Cartesian state vector\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])  # [x, y, z, vx, vy, vz]\noe = bh.state_cartesian_to_osculating(x_cart, bh.AngleFormat.RADIANS)\nprint(f\"Orbital elements: a={oe[0]:.0f}m, e={oe[1]:.6f}, i={oe[2]:.6f} rad\")\n</code></pre>"},{"location":"library_api/coordinates/enums.html","title":"Coordinate Enumerations","text":"<p>Enumerations for specifying coordinate transformation types.</p>"},{"location":"library_api/coordinates/enums.html#ellipsoidalconversiontype","title":"EllipsoidalConversionType","text":"<p>Specifies the type of ellipsoidal conversion used in topocentric coordinate transformations.</p> <p>Values: - <code>GEOCENTRIC</code> - Uses geocentric latitude where the angle is measured from the center of the Earth - <code>GEODETIC</code> - Uses geodetic latitude where the angle is measured perpendicular to the WGS84 ellipsoid</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType","title":"EllipsoidalConversionType","text":"<pre><code>EllipsoidalConversionType()\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEOCENTRIC","title":"GEOCENTRIC  <code>class-attribute</code>","text":"<pre><code>GEOCENTRIC: Any = EllipsoidalConversionType.Geocentric\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEODETIC","title":"GEODETIC  <code>class-attribute</code>","text":"<pre><code>GEODETIC: Any = EllipsoidalConversionType.Geodetic\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for EllipsoidalConversionType enum\\n\\nSpecifies the type of ellipsoidal conversion used in coordinate transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#angleformat","title":"AngleFormat","text":"<p>Specifies whether angles are in radians or degrees.</p> <p>Values: - <code>RADIANS</code> - Angles are in radians - <code>DEGREES</code> - Angles are in degrees</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for AngleFormat enum'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates</li> <li>Geodetic &amp; Geocentric</li> </ul>"},{"location":"library_api/coordinates/geodetic.html","title":"Geodetic and Geocentric Coordinates","text":"<p>Functions for converting between geodetic, geocentric, and ECEF coordinates.</p>"},{"location":"library_api/coordinates/geodetic.html#geodetic-conversions","title":"Geodetic Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geodetic_to_ecef","title":"position_geodetic_to_ecef  <code>builtin</code>","text":"<pre><code>position_geodetic_to_ecef(x_geod: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geodetic position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geod</code> <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (GPS-like) to ECEF\nlat, lon, alt = 40.0, -105.0, 1655.0  # Boulder, CO (degrees, meters)\nx_geod = np.array([lat, lon, alt])\nx_ecef = bh.position_geodetic_to_ecef(x_geod, bh.AngleFormat.DEGREES)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geodetic","title":"position_ecef_to_geodetic  <code>builtin</code>","text":"<pre><code>position_ecef_to_geodetic(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geodetic coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model.</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geodetic coordinates (GPS-like)\nx_ecef = np.array([-1275936.0, -4797210.0, 4020109.0])  # Example location\nx_geod = bh.position_ecef_to_geodetic(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geodetic: lat={x_geod[0]:.4f}\u00b0, lon={x_geod[1]:.4f}\u00b0, alt={x_geod[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#geocentric-conversions","title":"Geocentric Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geocentric_to_ecef","title":"position_geocentric_to_ecef  <code>builtin</code>","text":"<pre><code>position_geocentric_to_ecef(x_geoc: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geocentric position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geocentric spherical coordinates (latitude, longitude, radius) to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geoc</code> <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geocentric coordinates to ECEF\nlat, lon, r = 0.0, 0.0, 6378137.0  # Equator, prime meridian, Earth's radius\nx_geoc = np.array([lat, lon, r])\nx_ecef = bh.position_geocentric_to_ecef(x_geoc, bh.AngleFormat.RADIANS)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geocentric","title":"position_ecef_to_geocentric  <code>builtin</code>","text":"<pre><code>position_ecef_to_geocentric(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geocentric coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geocentric spherical coordinates (latitude, longitude, radius).</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geocentric coordinates\nx_ecef = np.array([6378137.0, 0.0, 0.0])  # Point on equator, prime meridian\nx_geoc = bh.position_ecef_to_geocentric(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geocentric: lat={x_geoc[0]:.2f}\u00b0, lon={x_geoc[1]:.2f}\u00b0, r={x_geoc[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html","title":"Topocentric Coordinates","text":"<p>Functions for working with local topocentric coordinate frames including East-North-Up (ENZ), South-East-Zenith (SEZ), and Azimuth-Elevation-Range.</p>"},{"location":"library_api/coordinates/topocentric.html#enz-east-north-up-frame","title":"ENZ (East-North-Up) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_enz","title":"rotation_ellipsoid_to_enz  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_enz(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to East-North-Up (<code>ENZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>ENZ</code> frame.</p>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_enz_to_ellipsoid","title":"rotation_enz_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_enz_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from East-North-Up (<code>ENZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local East-North-Up (<code>ENZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>ENZ</code> frame to ellipsoidal frame.</p>"},{"location":"library_api/coordinates/topocentric.html#position-conversions","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_enz","title":"relative_position_ecef_to_enz  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_enz(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to East-North-Up (<code>ENZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nenz = bh.relative_position_ecef_to_enz(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"ENZ: East={enz[0]/1000:.1f}km, North={enz[1]/1000:.1f}km, Up={enz[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_enz_to_ecef","title":"relative_position_enz_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_enz_to_ecef(location_ecef: ndarray, r_enz: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from East-North-Up (<code>ENZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local East-North-Up (<code>ENZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_enz</code> <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nenz_offset = np.array([50000.0, 30000.0, 100000.0])  # 50km east, 30km north, 100km up\ntarget_ecef = bh.relative_position_enz_to_ecef(station_ecef, enz_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_enz_to_azel","title":"position_enz_to_azel  <code>builtin</code>","text":"<pre><code>position_enz_to_azel(x_enz: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from East-North-Up (<code>ENZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local East-North-Up (<code>ENZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_enz</code> <code>ndarray</code> <p>Position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ to azimuth-elevation for satellite tracking\nenz = np.array([50000.0, 100000.0, 200000.0])  # East, North, Up (meters)\nazel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#sez-south-east-zenith-frame","title":"SEZ (South-East-Zenith) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices_1","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_sez","title":"rotation_ellipsoid_to_sez  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_sez(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>SEZ</code> frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix for ground station in SEZ frame\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_sez = bh.rotation_ellipsoid_to_sez(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_sez.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_sez_to_ellipsoid","title":"rotation_sez_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_sez_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from South-East-Zenith (<code>SEZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>SEZ</code> frame to ellipsoidal frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get inverse rotation matrix from SEZ to ellipsoidal\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_ellipsoid = bh.rotation_sez_to_ellipsoid(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_ellipsoid.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#position-conversions_1","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_sez","title":"relative_position_ecef_to_sez  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_sez(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nsez = bh.relative_position_ecef_to_sez(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"SEZ: South={sez[0]/1000:.1f}km, East={sez[1]/1000:.1f}km, Zenith={sez[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_sez_to_ecef","title":"relative_position_sez_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_sez_to_ecef(location_ecef: ndarray, x_sez: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from South-East-Zenith (<code>SEZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>x_sez</code> <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsez_offset = np.array([30000.0, 50000.0, 100000.0])  # 30km south, 50km east, 100km up\ntarget_ecef = bh.relative_position_sez_to_ecef(station_ecef, sez_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_sez_to_azel","title":"position_sez_to_azel  <code>builtin</code>","text":"<pre><code>position_sez_to_azel(x_sez: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from South-East-Zenith (<code>SEZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_sez</code> <code>ndarray</code> <p>Position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ to azimuth-elevation for satellite tracking\nsez = np.array([30000.0, 50000.0, 100000.0])  # South, East, Zenith (meters)\nazel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/datasets/index.html","title":"Datasets Module","text":"<p>The datasets module provides convenient access to satellite ephemeris data and groundstation locations from multiple sources. It handles downloading, parsing, and format conversion automatically.</p>"},{"location":"library_api/datasets/index.html#module-overview","title":"Module Overview","text":"<p>The module is organized by data source, with each source providing a consistent API:</p> <ul> <li><code>brahe.datasets.celestrak</code>: CelesTrak satellite ephemeris data</li> <li><code>brahe.datasets.groundstations</code>: Curated groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#submodules","title":"Submodules","text":"<ul> <li>CelesTrak Functions - Satellite ephemeris from CelesTrak</li> <li>Groundstation Functions - Groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets module</li> <li>CelesTrak Details - CelesTrak data source specifics</li> <li>Downloading Satellite Data - How-to guide</li> <li>Loading Groundstations - Groundstation datasets guide</li> </ul>"},{"location":"library_api/datasets/celestrak.html","title":"CelesTrak Functions","text":"<p>Functions for accessing satellite ephemeris data from CelesTrak.</p> <p>All functions are available via <code>brahe.datasets.celestrak.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/celestrak.html#get_ephemeris","title":"get_ephemeris","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_ephemeris","title":"celestrak_get_ephemeris  <code>builtin</code>","text":"<pre><code>celestrak_get_ephemeris(group: str) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Get satellite ephemeris data from CelesTrak</p> <p>Downloads and parses 3LE (three-line element) data for the specified satellite group from CelesTrak (https://celestrak.org).</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\"). See https://celestrak.org/NORAD/elements/ for available groups.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>list[tuple[str, str, str]]: List of (name, line1, line2) tuples containing satellite names and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or data cannot be parsed.</p> Example <pre><code>import brahe as bh\n\n# Download ephemeris for ground stations\nephemeris = bh.datasets.celestrak.get_ephemeris(\"stations\")\n\n# Print first 5 satellites\nfor name, line1, line2 in ephemeris[:5]:\n    print(f\"Satellite: {name}\")\n    print(f\"  Line 1: {line1[:20]}...\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_ephemeris_as_propagators","title":"get_ephemeris_as_propagators","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_ephemeris_as_propagators","title":"celestrak_get_ephemeris_as_propagators  <code>builtin</code>","text":"<pre><code>celestrak_get_ephemeris_as_propagators(group: str, step_size: float) -&gt; list[SGPPropagator]\n</code></pre> <p>Get satellite ephemeris as SGP propagators from CelesTrak</p> <p>Downloads and parses 3LE data from CelesTrak, then creates SGP4/SDP4 propagators for each satellite. This is a convenient way to get ready-to-use propagators.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagators in seconds.</p> required <p>Returns:</p> Type Description <code>list[SGPPropagator]</code> <p>list[SGPPropagator]: List of configured SGP propagators (PySGPPropagator), one per satellite.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or no valid propagators can be created.</p> Note <p>Satellites with invalid TLE data will be skipped with a warning printed to stderr. The function will only raise an error if NO valid propagators can be created.</p> Example <pre><code>import brahe as bh\n\n# Get propagators for GNSS satellites with 60-second step size\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\"gnss\", 60.0)\nprint(f\"Loaded {len(propagators)} GNSS satellites\")\n\n# Propagate first satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0, tsys=\"UTC\")\nstate = propagators[0].propagate(epoch)\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#download_ephemeris","title":"download_ephemeris","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_download_ephemeris","title":"celestrak_download_ephemeris  <code>builtin</code>","text":"<pre><code>celestrak_download_ephemeris(group: str, filepath: str, content_format: str, file_format: str) -&gt; Any\n</code></pre> <p>Download satellite ephemeris from CelesTrak and save to file</p> <p>Downloads 3LE data from CelesTrak and serializes to the specified file format. The file can contain either 2-line elements (TLE, without names) or 3-line elements (3LE, with satellite names), and can be saved as plain text, CSV, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>filepath</code> <code>str</code> <p>Output file path. Parent directories will be created if needed.</p> required <code>content_format</code> <code>str</code> <p>Content format - \"tle\" (2-line without names) or \"3le\" (3-line with names).</p> required <code>file_format</code> <code>str</code> <p>File format - \"txt\" (plain text), \"csv\" (comma-separated), or \"json\" (JSON array).</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, format is invalid, or file cannot be written.</p> Example <pre><code>import brahe as bh\n\n# Download GNSS satellites as 3LE in JSON format\nbh.datasets.celestrak.download_ephemeris(\"gnss\", \"gnss_sats.json\", \"3le\", \"json\")\n\n# Download active satellites as 2LE in plain text\nbh.datasets.celestrak.download_ephemeris(\"active\", \"active.txt\", \"tle\", \"txt\")\n\n# Download stations as 3LE in CSV format\nbh.datasets.celestrak.download_ephemeris(\"stations\", \"stations.csv\", \"3le\", \"csv\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html","title":"Groundstation Functions","text":"<p>Functions for accessing curated groundstation location datasets.</p> <p>All functions are available via <code>brahe.datasets.groundstations.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/groundstations.html#load","title":"load","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load","title":"groundstations_load  <code>builtin</code>","text":"<pre><code>groundstations_load(provider: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstation locations for a specific provider</p> <p>Loads groundstation locations from embedded data. The data is compiled into the binary and does not require external files or internet connection.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name (case-insensitive). Available providers: - \"atlas\": Atlas Space Operations - \"aws\": Amazon Web Services Ground Station - \"ksat\": Kongsberg Satellite Services - \"leaf\": Leaf Space - \"ssc\": Swedish Space Corporation - \"viasat\": Viasat</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects with properties: - name: Groundstation name - provider: Provider name - frequency_bands: List of supported frequency bands</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If provider is unknown or data cannot be loaded.</p> Example <pre><code>import brahe as bh\n\n# Load KSAT groundstations\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\n\nfor station in ksat_stations:\n    print(f\"{station.name}: ({station.lon():.2f}, {station.lat():.2f})\")\n\n# Check properties\nprops = ksat_stations[0].properties()\nprint(f\"Frequency bands: {props['frequency_bands']}\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_from_file","title":"load_from_file","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_from_file","title":"groundstations_load_from_file  <code>builtin</code>","text":"<pre><code>groundstations_load_from_file(filepath: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstations from a custom GeoJSON file</p> <p>Loads groundstation locations from a user-provided GeoJSON file. The file must be a FeatureCollection with Point geometries.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to GeoJSON file.</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file cannot be read or parsed.</p> Example <pre><code>import brahe as bh\n\n# Load custom groundstations\nstations = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_all","title":"load_all","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_all","title":"groundstations_load_all  <code>builtin</code>","text":"<pre><code>groundstations_load_all() -&gt; list[PointLocation]\n</code></pre> <p>Load all groundstations from all providers</p> <p>Convenience function to load groundstations from all available providers.</p> <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: Combined list of all groundstations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no groundstations can be loaded.</p> Example <pre><code>import brahe as bh\n\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Loaded {len(all_stations)} total groundstations\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#list_providers","title":"list_providers","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_list_providers","title":"groundstations_list_providers  <code>builtin</code>","text":"<pre><code>groundstations_list_providers() -&gt; list[str]\n</code></pre> <p>Get list of available groundstation providers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of provider names that can be used with load().</p> Example <pre><code>import brahe as bh\n\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"Available: {', '.join(providers)}\")\n</code></pre>"},{"location":"library_api/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Module: <code>brahe.eop</code></p> <p>Earth Orientation Parameters provide corrections for the irregular rotation and orientation of the Earth, essential for accurate coordinate frame transformations between ECI and ECEF systems.</p>"},{"location":"library_api/eop/index.html#overview","title":"Overview","text":"<p>EOP data includes: - UT1-UTC: Difference between UT1 (Earth rotation time) and UTC - Polar Motion (x, y): Movement of Earth's rotation axis relative to the crust - dX, dY: Celestial pole offsets - LOD: Length of day variations</p>"},{"location":"library_api/eop/index.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports three types of EOP providers:</p>"},{"location":"library_api/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manage EOP file freshness with cache management and automatic updates.</p>"},{"location":"library_api/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Load EOP data from files (Standard or C04 format) for production applications with current data.</p>"},{"location":"library_api/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Use user-defined fixed data, ideal for testing, offline use, or applications not requiring the most precise transformations.</p>"},{"location":"library_api/eop/index.html#global-eop-management","title":"Global EOP Management","text":"<p>EOP data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/eop/index.html#functions","title":"Functions","text":"<ul> <li>Setting global EOP providers</li> <li>Querying global EOP data</li> <li>Downloading latest EOP files</li> </ul>"},{"location":"library_api/eop/index.html#quick-start","title":"Quick Start","text":"<pre><code>import brahe as bh\n\n# Option 1: Use file-based EOP (recommended for production)\nbh.set_global_eop_provider_from_file_provider(\n    bh.FileEOPProvider.from_default_standard()\n)\n\n# Option 2: Use static EOP (for testing/offline use)\nbh.set_global_eop_provider_from_static_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Now frame transformations will use the global EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]  # meters\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/index.html#see-also","title":"See Also","text":"<ul> <li>Frames - Coordinate frame transformations that use EOP</li> <li>Epoch - Time representation</li> </ul>"},{"location":"library_api/eop/caching_provider.html","title":"CachingEOPProvider","text":""},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider","title":"CachingEOPProvider","text":"<pre><code>CachingEOPProvider(filepath: str, eop_type: str, max_age_seconds: int, auto_refresh: bool, interpolate: bool, extrapolate: str)\n</code></pre> <p>Caching EOP provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileEOPProvider and adds automatic cache management. It checks the age of the EOP file and downloads updated versions when the file exceeds the maximum age threshold. If the file doesn't exist, it will be downloaded on initialization.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the EOP file (will be created if it doesn't exist)</p> required <code>eop_type</code> <code>str</code> <p>Type of EOP file - \"C04\" for IERS C04 format or \"StandardBulletinA\" for IERS finals2000A.all format</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh. Common values: 86400 (1 day), 604800 (7 days)</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access. If False, only checks on initialization and manual refresh() calls</p> required <code>interpolate</code> <code>bool</code> <p>Enable linear interpolation between tabulated EOP values. Recommended: True for smoother data</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside EOP data range: \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file download fails or file is invalid</p> Example <pre><code>import brahe as bh\n\n# Manual refresh mode (recommended for performance)\nprovider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n\n# Check and refresh as needed\nprovider.refresh()\n\n# Auto-refresh mode (convenience)\nauto_provider = bh.CachingEOPProvider(\n    filepath=\"./eop_data/finals.all.iau2000.txt\",\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,  # Checks on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Caching EOP provider that automatically downloads updated files when stale.\\n\\nThis provider wraps a FileEOPProvider and adds automatic cache management.\\nIt checks the age of the EOP file and downloads updated versions when the file\\nexceeds the maximum age threshold. If the file doesn\\'t exist, it will be\\ndownloaded on initialization.\\n\\nArgs:\\n    filepath (str): Path to the EOP file (will be created if it doesn\\'t exist)\\n    eop_type (str): Type of EOP file - \"C04\" for IERS C04 format or\\n        \"StandardBulletinA\" for IERS finals2000A.all format\\n    max_age_seconds (int): Maximum age of file in seconds before triggering\\n        a refresh. Common values: 86400 (1 day), 604800 (7 days)\\n    auto_refresh (bool): If True, automatically checks file age and refreshes\\n        on every data access. If False, only checks on initialization and\\n        manual refresh() calls\\n    interpolate (bool): Enable linear interpolation between tabulated EOP\\n        values. Recommended: True for smoother data\\n    extrapolate (str): Behavior for dates outside EOP data range:\\n        \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)\\n\\nRaises:\\n    RuntimeError: If file download fails or file is invalid\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Manual refresh mode (recommended for performance)\\n    provider = bh.CachingEOPProvider(\\n        filepath=\"./eop_data/finals.all.iau2000.txt\",\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=7 * 86400,  # 7 days\\n        auto_refresh=False,\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    bh.set_global_eop_provider_from_caching_provider(provider)\\n\\n    # Check and refresh as needed\\n    provider.refresh()\\n\\n    # Auto-refresh mode (convenience)\\n    auto_provider = bh.CachingEOPProvider(\\n        filepath=\"./eop_data/finals.all.iau2000.txt\",\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=24 * 3600,  # 24 hours\\n        auto_refresh=True,  # Checks on every access\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP file type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type (\"C04\", \"StandardBulletinA\", etc.)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded EOP file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\nage = provider.file_age()\nprint(f\"EOP file age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the EOP file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; Tuple\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(pm_x, pm_y, ut1_utc, dx, dy, lod)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last MJD with valid celestial pole offset data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dX/dY data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last MJD with valid LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with length of day data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached EOP data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\n\n# Later, manually force a refresh check\nprovider.refresh()\n</code></pre>"},{"location":"library_api/eop/file_provider.html","title":"FileEOPProvider","text":"<p>Load Earth Orientation Parameters from IERS data files.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider","title":"FileEOPProvider","text":"<pre><code>FileEOPProvider()\n</code></pre> <p>File-based Earth Orientation Parameter provider.</p> <p>Loads EOP data from files in standard IERS formats and provides interpolation and extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from C04 file with interpolation\neop = bh.FileEOPProvider.from_c04_file(\n    \"./eop_data/finals2000A.all.csv\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Create from standard file\neop = bh.FileEOPProvider.from_standard_file(\n    \"./eop_data/finals.all\",\n    interpolate=True,\n    extrapolate=\"Zero\"\n)\n\n# Use default file location\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(eop)\n\n# Get EOP data for a specific MJD\nmjd = 60310.0\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'File-based Earth Orientation Parameter provider.\\n\\nLoads EOP data from files in standard IERS formats and provides\\ninterpolation and extrapolation capabilities.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create from C04 file with interpolation\\n    eop = bh.FileEOPProvider.from_c04_file(\\n        \"./eop_data/finals2000A.all.csv\",\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n\\n    # Create from standard file\\n    eop = bh.FileEOPProvider.from_standard_file(\\n        \"./eop_data/finals.all\",\\n        interpolate=True,\\n        extrapolate=\"Zero\"\\n    )\\n\\n    # Use default file location\\n    eop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_file_provider(eop)\\n\\n    # Get EOP data for a specific MJD\\n    mjd = 60310.0\\n    ut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Extrapolation: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_c04_file","title":"from_c04_file  <code>builtin</code>","text":"<pre><code>from_c04_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a C04 format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to C04 EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with C04 file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_c04_file(\"./eop_data/finals2000A.all.csv\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_c04","title":"from_default_c04  <code>builtin</code>","text":"<pre><code>from_default_c04(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default C04 EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default C04 file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file(eop_type: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from default EOP file location with specified type.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>EOP file type (\"C04\" or \"StandardBulletinA\")</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default file of specified type</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_file(\"C04\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_standard","title":"from_default_standard  <code>builtin</code>","text":"<pre><code>from_default_standard(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default standard IERS EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default standard file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from an EOP file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_file(\"./eop_data/eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_standard_file","title":"from_standard_file  <code>builtin</code>","text":"<pre><code>from_standard_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a standard IERS format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to standard IERS EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with standard file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_standard_file(\"./eop_data/standard_eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"interpolation: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"is_initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_last_dxdy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_max: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#overview","title":"Overview","text":"<p><code>FileEOPProvider</code> loads EOP data from files in either Standard or C04 format provided by the International Earth Rotation and Reference Systems Service (IERS).</p> <p>Module: <code>brahe.eop</code></p> <p>Data Sources: - Standard Format: finals2000A.all - Combined rapid + predicted data - C04 Format: eopc04_IAU2000.XX - Long-term historical data</p>"},{"location":"library_api/eop/file_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/file_provider.html#from-default-files","title":"From Default Files","text":"<pre><code>import brahe as bh\n\n# Use default standard format file\nprovider = bh.FileEOPProvider.from_default_standard()\n\n# Use default C04 format file\nprovider = bh.FileEOPProvider.from_default_c04()\n</code></pre>"},{"location":"library_api/eop/file_provider.html#from-custom-files","title":"From Custom Files","text":"<pre><code>import brahe as bh\n\n# Load from custom standard file\nprovider = bh.FileEOPProvider.from_standard_file(\n    \"/path/to/finals2000A.all\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Load from custom C04 file\nprovider = bh.FileEOPProvider.from_c04_file(\n    \"/path/to/eopc04.XX\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#configuration-options","title":"Configuration Options","text":""},{"location":"library_api/eop/file_provider.html#interpolation","title":"Interpolation","text":"<p><code>interpolate: bool</code> - Enable/disable interpolation between data points</p> <ul> <li><code>True</code>: Linear interpolation for dates between data points (recommended)</li> <li><code>False</code>: Use nearest data point (step function)</li> </ul>"},{"location":"library_api/eop/file_provider.html#extrapolation","title":"Extrapolation","text":"<p><code>extrapolate: str</code> - Behavior when querying dates outside data range</p> <ul> <li><code>\"Hold\"</code>: Use first/last values for dates before/after data range</li> <li><code>\"Zero\"</code>: Return zero for all EOP values outside range</li> <li><code>\"Error\"</code>: Raise an error if date is outside range</li> </ul>"},{"location":"library_api/eop/file_provider.html#usage-with-global-eop","title":"Usage with Global EOP","text":"<pre><code>import brahe as bh\n\n# Create provider from file\nprovider = bh.FileEOPProvider.from_default_standard(\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(provider)\n\n# Now all frame transformations use this EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#downloading-eop-files","title":"Downloading EOP Files","text":"<pre><code>import brahe as bh\n\n# Download latest standard EOP file\nfilepath = bh.download_standard_eop_file(\"./data\")\n\n# Download latest C04 EOP file\nfilepath = bh.download_c04_eop_file(\"./data\")\n\n# Use downloaded file\nprovider = bh.FileEOPProvider.from_standard_file(filepath)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider - Built-in historical EOP data</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations using EOP</li> </ul>"},{"location":"library_api/eop/functions.html","title":"EOP Functions","text":"<p>Global EOP management and query functions.</p> <p>Module: <code>brahe.eop</code></p>"},{"location":"library_api/eop/functions.html#setting-global-eop-provider","title":"Setting Global EOP Provider","text":""},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_caching_provider","title":"set_global_eop_provider_from_caching_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_caching_provider","title":"set_global_eop_provider_from_caching_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_caching_provider(provider: CachingEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a caching provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>CachingEOPProvider</code> <p>Caching EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    \"./eop_data/finals.all.iau2000.txt\",\n    \"StandardBulletinA\",\n    7 * 86400,\n    False,\n    True,\n    \"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_file_provider","title":"set_global_eop_provider_from_file_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_file_provider","title":"set_global_eop_provider_from_file_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_file_provider(provider: FileEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a file-based provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>FileEOPProvider</code> <p>File-based EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider_from_static_provider","title":"set_global_eop_provider_from_static_provider","text":""},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider_from_static_provider","title":"set_global_eop_provider_from_static_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider_from_static_provider(provider: StaticEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using a static provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticEOPProvider</code> <p>Static EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\nprovider = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#querying-global-eop-data","title":"Querying Global EOP Data","text":""},{"location":"library_api/eop/functions.html#get_global_eop","title":"get_global_eop","text":"<p>Get all EOP values for a specific Modified Julian Date.</p> <p>Returns: Tuple of (ut1_utc, pm_x, pm_y, dx, dy, lod)</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop","title":"get_global_eop  <code>builtin</code>","text":"<pre><code>get_global_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p>"},{"location":"library_api/eop/functions.html#get_global_ut1_utc","title":"get_global_ut1_utc","text":"<p>Get UT1-UTC offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_ut1_utc","title":"get_global_ut1_utc  <code>builtin</code>","text":"<pre><code>get_global_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/functions.html#get_global_pm","title":"get_global_pm","text":"<p>Get polar motion (x, y) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_pm","title":"get_global_pm  <code>builtin</code>","text":"<pre><code>get_global_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/functions.html#get_global_dxdy","title":"get_global_dxdy","text":"<p>Get celestial pole offsets (dx, dy) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_dxdy","title":"get_global_dxdy  <code>builtin</code>","text":"<pre><code>get_global_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/functions.html#get_global_lod","title":"get_global_lod","text":"<p>Get length of day offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_lod","title":"get_global_lod  <code>builtin</code>","text":"<pre><code>get_global_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/functions.html#eop-metadata","title":"EOP Metadata","text":""},{"location":"library_api/eop/functions.html#get_global_eop_type","title":"get_global_eop_type","text":"<p>Get the type of global EOP provider (\"file\" or \"static\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_type","title":"get_global_eop_type  <code>builtin</code>","text":"<pre><code>get_global_eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_initialization","title":"get_global_eop_initialization","text":"<p>Check if global EOP provider has been initialized.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_initialization","title":"get_global_eop_initialization  <code>builtin</code>","text":"<pre><code>get_global_eop_initialization() -&gt; bool\n</code></pre> <p>Check if the global EOP provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if global EOP provider is initialized</p>"},{"location":"library_api/eop/functions.html#get_global_eop_interpolation","title":"get_global_eop_interpolation","text":"<p>Check if interpolation is enabled.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_interpolation","title":"get_global_eop_interpolation  <code>builtin</code>","text":"<pre><code>get_global_eop_interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled in the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/functions.html#get_global_eop_extrapolation","title":"get_global_eop_extrapolation","text":"<p>Get extrapolation method (\"Hold\", \"Zero\", or \"Error\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_extrapolation","title":"get_global_eop_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_eop_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_len","title":"get_global_eop_len","text":"<p>Get number of EOP data points in provider.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_len","title":"get_global_eop_len  <code>builtin</code>","text":"<pre><code>get_global_eop_len() -&gt; int\n</code></pre> <p>Get the number of EOP data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_min","title":"get_global_eop_mjd_min","text":"<p>Get minimum (earliest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_min","title":"get_global_eop_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_max","title":"get_global_eop_mjd_max","text":"<p>Get maximum (latest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_max","title":"get_global_eop_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod","text":"<p>Get MJD of last LOD (Length of Day) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy","text":"<p>Get MJD of last dX/dY (celestial pole offset) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p>"},{"location":"library_api/eop/functions.html#downloading-eop-files","title":"Downloading EOP Files","text":""},{"location":"library_api/eop/functions.html#download_standard_eop_file","title":"download_standard_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_standard_eop_file","title":"download_standard_eop_file  <code>builtin</code>","text":"<pre><code>download_standard_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest standard Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre>"},{"location":"library_api/eop/functions.html#download_c04_eop_file","title":"download_c04_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_c04_eop_file","title":"download_c04_eop_file  <code>builtin</code>","text":"<pre><code>download_c04_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest C04 Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"library_api/eop/functions.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Download and set up file-based EOP\neop_file = bh.download_standard_eop_file(\"./data\")\nprovider = bh.FileEOPProvider.from_standard_file(\n    eop_file,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_file_provider(provider)\n\n# Check provider status\nprint(f\"EOP Type: {bh.get_global_eop_type()}\")\nprint(f\"Data points: {bh.get_global_eop_len()}\")\nprint(f\"Date range: MJD {bh.get_global_eop_mjd_min():.1f} to {bh.get_global_eop_mjd_max():.1f}\")\nprint(f\"Interpolation: {bh.get_global_eop_interpolation()}\")\nprint(f\"Extrapolation: {bh.get_global_eop_extrapolation()}\")\n\n# Query EOP for specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\nut1_utc, pm_x, pm_y, dx, dy, lod = bh.get_global_eop(mjd)\nprint(f\"\\nEOP for MJD {mjd}:\")\nprint(f\"  UT1-UTC: {ut1_utc:.6f} s\")\nprint(f\"  Polar Motion: ({pm_x*1e6:.3f}, {pm_y*1e6:.3f}) \u03bcrad\")\nprint(f\"  dX, dY: ({dx*1e6:.3f}, {dy*1e6:.3f}) \u03bcrad\")\nprint(f\"  LOD: {lod*1e3:.6f} ms\")\n</code></pre>"},{"location":"library_api/eop/functions.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider</li> <li>StaticEOPProvider</li> <li>Frames - Frame transformations that use EOP</li> </ul>"},{"location":"library_api/eop/static_provider.html","title":"StaticEOPProvider","text":"<p>Built-in Earth Orientation Parameters for testing and offline use.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider","title":"StaticEOPProvider","text":"<pre><code>StaticEOPProvider()\n</code></pre> <p>Static Earth Orientation Parameter provider with constant values.</p> <p>Provides EOP data using fixed values that don't change with time. Useful for testing or scenarios where time-varying EOP data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static EOP provider with default values\neop = bh.StaticEOPProvider()\n\n# Create static EOP provider with zero values\neop_zero = bh.StaticEOPProvider.from_zero()\n\n# Create with custom values\neop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(eop_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = \"Static Earth Orientation Parameter provider with constant values.\\n\\nProvides EOP data using fixed values that don't change with time.\\nUseful for testing or scenarios where time-varying EOP data is not needed.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create static EOP provider with default values\\n    eop = bh.StaticEOPProvider()\\n\\n    # Create static EOP provider with zero values\\n    eop_zero = bh.StaticEOPProvider.from_zero()\\n\\n    # Create with custom values\\n    eop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_static_provider(eop_custom)\\n    ```\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Extrapolation method: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(ut1_utc: float, pm_x: float, pm_y: float, dx: float, dy: float, lod: float) -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ut1_utc</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> required <code>pm_x</code> <code>float</code> <p>Polar motion x-component in radians</p> required <code>pm_y</code> <code>float</code> <p>Polar motion y-component in radians</p> required <code>dx</code> <code>float</code> <p>Celestial pole offset dx in radians</p> required <code>dy</code> <code>float</code> <p>Celestial pole offset dy in radians</p> required <code>lod</code> <code>float</code> <p>Length of day offset in seconds</p> required <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with specified EOP values</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with custom values\neop = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,\n    pm_x=1e-6,\n    pm_y=2e-6,\n    dx=1e-7,\n    dy=1e-7,\n    lod=0.001\n)\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with all EOP values set to zero</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with all zeros (no corrections)\neop = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider()\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Interpolation enabled: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Is initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with dx/dy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Maximum MJD: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#overview","title":"Overview","text":"<p><code>StaticEOPProvider</code> provides built-in historical EOP data that doesn't require external files. Useful for testing, examples, or when internet access is unavailable.</p> <p>Module: <code>brahe.eop</code></p> <p>Use Cases: - Unit testing - Examples and tutorials - Offline applications - Quick prototyping</p> <p>Limitations: - Fixed historical data (not updated) - Less accurate than file-based providers - Not suitable for production applications requiring current data</p>"},{"location":"library_api/eop/static_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/static_provider.html#zero-values","title":"Zero Values","text":"<pre><code>import brahe as bh\n\n# All EOP values set to zero\nprovider = bh.StaticEOPProvider.from_zero()\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(provider)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#custom-values","title":"Custom Values","text":"<pre><code>import brahe as bh\n\n# Specify custom EOP values\nprovider = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,      # UT1-UTC offset (seconds)\n    pm_x=0.0001,      # Polar motion X (radians)\n    pm_y=0.0001,      # Polar motion Y (radians)\n    dx=0.00001,       # Celestial pole offset dX (radians)\n    dy=0.00001,       # Celestial pole offset dY (radians)\n    lod=0.001         # Length of day offset (seconds)\n)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#default-values","title":"Default Values","text":"<pre><code>import brahe as bh\n\n# Use built-in default values\nprovider = bh.StaticEOPProvider()\n</code></pre>"},{"location":"library_api/eop/static_provider.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Set up static EOP for testing\nbh.set_global_eop_provider_from_static_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Perform frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ECI to ECEF transformation\npos_eci = [7000000.0, 0.0, 0.0]  # meters in ECI\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n\n# ECEF to ECI transformation\nvel_ecef = [0.0, 7500.0, 0.0]  # m/s in ECEF\nvel_eci = bh.position_ecef_to_eci(epoch, vel_ecef)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#when-to-use","title":"When to Use","text":"<p>\u2705 Use StaticEOPProvider for: - Unit tests - Documentation examples - Learning and prototyping - Applications where high accuracy isn't critical</p> <p>\u274c Don't use StaticEOPProvider for: - Production orbit determination - Precise tracking applications - Applications requiring current EOP data - High-accuracy simulations</p>"},{"location":"library_api/eop/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider - File-based EOP for production use</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations</li> </ul>"},{"location":"library_api/orbits/index.html","title":"Orbits","text":"<p>Module: <code>brahe.orbits</code></p> <p>Comprehensive tools for orbital mechanics computations.</p>"},{"location":"library_api/orbits/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Keplerian Elements - Functions for computing orbital properties and converting between anomaly types</li> <li>Two-Line Elements (TLE) - TLE parsing, validation, and conversion utilities</li> <li>KeplerianPropagator - Analytical two-body orbit propagator</li> <li>SGPPropagator - SGP4/SDP4 orbit propagator for TLE data</li> <li>Enumerations - Orbit-related enumerations (OrbitRepresentation, OrbitFrame, etc.)</li> </ul>"},{"location":"library_api/orbits/enums.html","title":"Orbit Enumerations","text":"<p>Enumerations for specifying orbit representation types and reference frames.</p>"},{"location":"library_api/orbits/enums.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies the type of orbital elements being used.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation","title":"OrbitRepresentation","text":"<pre><code>OrbitRepresentation()\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.CARTESIAN","title":"CARTESIAN  <code>class-attribute</code>","text":"<pre><code>CARTESIAN: Any = OrbitRepresentation.Cartesian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.KEPLERIAN","title":"KEPLERIAN  <code>class-attribute</code>","text":"<pre><code>KEPLERIAN: Any = OrbitRepresentation.Keplerian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital state representation format.\\n\\nSpecifies how orbital states are represented in the trajectory.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#orbitframe","title":"OrbitFrame","text":""},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame","title":"OrbitFrame","text":"<pre><code>OrbitFrame()\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECEF","title":"ECEF  <code>class-attribute</code>","text":"<pre><code>ECEF: Any = OrbitFrame.ECEF\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECI","title":"ECI  <code>class-attribute</code>","text":"<pre><code>ECI: Any = OrbitFrame.ECI\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Reference frame for orbital trajectory representation.\\n\\nSpecifies the coordinate reference frame for position and velocity states.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get the full name of the reference frame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable frame name</p>"},{"location":"library_api/orbits/enums.html#interpolationmethod","title":"InterpolationMethod","text":""},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod","title":"InterpolationMethod","text":"<pre><code>InterpolationMethod()\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.LINEAR","title":"LINEAR  <code>class-attribute</code>","text":"<pre><code>LINEAR: Any = InterpolationMethod.Linear\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python bindings for the new trajectory architecture\\nInterpolation method for trajectory state estimation.\\n\\nSpecifies the algorithm used to estimate states at epochs between\\ndiscrete trajectory points.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator</li> <li>Trajectories</li> </ul>"},{"location":"library_api/orbits/keplerian.html","title":"Keplerian Elements","text":"<p>Functions for working with Keplerian orbital elements and computing orbital properties.</p>"},{"location":"library_api/orbits/keplerian.html#orbital-properties","title":"Orbital Properties","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis","title":"semimajor_axis  <code>builtin</code>","text":"<pre><code>semimajor_axis(n: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from Earth given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis from mean motion (typical LEO satellite)\nn = 0.001027  # radians/second (~15 revolutions/day)\na = bh.semimajor_axis(n, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_general","title":"semimajor_axis_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_general(n: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from a general body given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for Jupiter orbiter\nn = 0.0001  # radians/second\na = bh.semimajor_axis_general(n, bh.GM_JUPITER, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period","title":"semimajor_axis_from_orbital_period  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period(period: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for a 90-minute orbit\nperiod = 90 * 60.0  # 90 minutes in seconds\na = bh.semimajor_axis_from_orbital_period(period)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period_general","title":"semimajor_axis_from_orbital_period_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period_general(period: float, gm: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period for a general body.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for 2-hour Venus orbit\nperiod = 2 * 3600.0  # 2 hours in seconds\na = bh.semimajor_axis_from_orbital_period_general(period, bh.GM_VENUS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion","title":"mean_motion  <code>builtin</code>","text":"<pre><code>mean_motion(a: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for geostationary orbit (35786 km altitude)\na = bh.R_EARTH + 35786e3\nn = bh.mean_motion(a, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion_general","title":"mean_motion_general  <code>builtin</code>","text":"<pre><code>mean_motion_general(a: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around a general body given a semi-major axis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for a Mars orbiter\na = 4000000.0  # 4000 km semi-major axis\nn = bh.mean_motion_general(a, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period","title":"orbital_period  <code>builtin</code>","text":"<pre><code>orbital_period(a: float) -&gt; Any\n</code></pre> <p>Computes the orbital period of an object around Earth.</p> <p>Uses rastro.constants.GM_EARTH as the standard gravitational parameter for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period for ISS-like orbit (400 km altitude)\na = bh.R_EARTH + 400e3\nperiod = bh.orbital_period(a)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period_general","title":"orbital_period_general  <code>builtin</code>","text":"<pre><code>orbital_period_general(a: float, gm: float) -&gt; float\n</code></pre> <p>Computes the orbital period of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period around the Moon\na = 1900000.0  # 1900 km semi-major axis\nperiod = bh.orbital_period_general(a, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_distance","title":"periapsis_distance  <code>builtin</code>","text":"<pre><code>periapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at periapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis distance for an elliptical orbit\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_peri = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_distance","title":"apoapsis_distance  <code>builtin</code>","text":"<pre><code>apoapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at apoapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis distance\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_apo = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_velocity","title":"periapsis_velocity  <code>builtin</code>","text":"<pre><code>periapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the periapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at periapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis velocity for a comet around the Sun\na = 5e11  # 5 AU semi-major axis (meters)\ne = 0.95  # highly elliptical\nv_peri = bh.periapsis_velocity(a, e, bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_velocity","title":"apoapsis_velocity  <code>builtin</code>","text":"<pre><code>apoapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the apoapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apoapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis velocity for a Martian satellite\na = 10000000.0  # 10000 km semi-major axis\ne = 0.3\nv_apo = bh.apoapsis_velocity(a, e, bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.perigee_velocity","title":"perigee_velocity  <code>builtin</code>","text":"<pre><code>perigee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the perigee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at perigee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate perigee velocity for Molniya orbit (highly elliptical)\na = 26554000.0  # meters\ne = 0.72  # high eccentricity\nv_peri = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apogee_velocity","title":"apogee_velocity  <code>builtin</code>","text":"<pre><code>apogee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the apogee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apogee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apogee velocity for GTO (Geostationary Transfer Orbit)\na = 24400000.0  # meters\ne = 0.73  # high eccentricity\nv_apo = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.sun_synchronous_inclination","title":"sun_synchronous_inclination  <code>builtin</code>","text":"<pre><code>sun_synchronous_inclination(a: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the inclination for a Sun-synchronous orbit around Earth based on the J2 gravitational perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination for a Sun synchronous orbit in degrees or radians.</p> Example <pre><code>import brahe as bh\n\n# Calculate sun-synchronous inclination for typical Earth observation satellite (600 km)\na = bh.R_EARTH + 600e3\ne = 0.001  # nearly circular\ninc = bh.sun_synchronous_inclination(a, e, bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#anomaly-conversions","title":"Anomaly Conversions","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_mean","title":"anomaly_eccentric_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_mean(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to mean anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.1  # eccentricity\nM = bh.anomaly_eccentric_to_mean(E, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_true","title":"anomaly_eccentric_to_true  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_true(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to true anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.4  # eccentricity\nnu = bh.anomaly_eccentric_to_true(E, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_eccentric","title":"anomaly_mean_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_eccentric(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to eccentric anomaly (solves Kepler's equation)\nM = 1.5  # mean anomaly in radians\ne = 0.3  # eccentricity\nE = bh.anomaly_mean_to_eccentric(M, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_true","title":"anomaly_mean_to_true  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_true(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to true anomaly (combines Kepler's equation + eccentric anomaly conversion)\nM = 2.0  # mean anomaly in radians\ne = 0.25  # eccentricity\nnu = bh.anomaly_mean_to_true(M, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_eccentric","title":"anomaly_true_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_true_to_eccentric(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to eccentric anomaly\nnu = math.pi / 3  # 60 degrees true anomaly\ne = 0.2  # eccentricity\nE = bh.anomaly_true_to_eccentric(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_mean","title":"anomaly_true_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_true_to_mean(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to mean anomaly\nnu = math.pi / 2  # 90 degrees true anomaly\ne = 0.15  # eccentricity\nM = bh.anomaly_true_to_mean(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html","title":"Keplerian Propagator","text":"<p>Analytical two-body orbit propagator using Keplerian orbital elements.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator","title":"KeplerianPropagator","text":"<pre><code>KeplerianPropagator()\n</code></pre> <p>Python wrapper for KeplerianPropagator (new architecture) Keplerian orbit propagator using two-body dynamics.</p> <p>The Keplerian propagator implements ideal two-body orbital mechanics without perturbations. It's fast and accurate for short time spans but doesn't account for real-world effects like drag, J2, solar radiation pressure, etc.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initial epoch and orbital elements\nepc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\n\n# Create propagator from Keplerian elements\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\n)\n\n# Propagate forward one orbit\nperiod = bh.orbital_period(oe[0])\nepc_future = epc0 + period\nstate = prop.state(epc_future)\nprint(f\"State after one orbit: {state}\")\n\n# Create from Cartesian state\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\nprop2 = bh.KeplerianPropagator(\n    epc0, x_cart, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    bh.AngleFormat.RADIANS, 60.0\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for KeplerianPropagator (new architecture)\\nKeplerian orbit propagator using two-body dynamics.\\n\\nThe Keplerian propagator implements ideal two-body orbital mechanics without\\nperturbations. It\\'s fast and accurate for short time spans but doesn\\'t account\\nfor real-world effects like drag, J2, solar radiation pressure, etc.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Initial epoch and orbital elements\\n    epc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    oe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\\n\\n    # Create propagator from Keplerian elements\\n    prop = bh.KeplerianPropagator.from_keplerian(\\n        epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\\n    )\\n\\n    # Propagate forward one orbit\\n    period = bh.orbital_period(oe[0])\\n    epc_future = epc0 + period\\n    state = prop.state(epc_future)\\n    print(f\"State after one orbit: {state}\")\\n\\n    # Create from Cartesian state\\n    x_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\\n    prop2 = bh.KeplerianPropagator(\\n        epc0, x_cart, bh.OrbitFrame.ECI,\\n        bh.OrbitRepresentation.CARTESIAN,\\n        bh.AngleFormat.RADIANS, 60.0\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Epoch\n</code></pre> <p>Get initial epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Initial propagator epoch.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\ntraj = prop.trajectory\nprint(f\"Trajectory contains {traj.len()} states\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; np.ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_ecef","title":"from_ecef  <code>builtin</code>","text":"<pre><code>from_ecef(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECEF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECEF frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECI frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.from_keplerian","title":"from_keplerian  <code>builtin</code>","text":"<pre><code>from_keplerian(epoch: Epoch, elements: ndarray, angle_format: AngleFormat, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>elements</code> <code>ndarray</code> <p>6-element Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format (Degrees or Radians).</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; np.ndarray\n</code></pre> <p>Get initial state.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)  # Take 10 steps (600 seconds total)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 3600.0  # Propagate to 1 hour ahead\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\nprop.reset()  # Return to initial epoch and state\nprint(f\"Reset to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_age(3600.0)  # Keep only states within 1 hour\nprop.propagate_to(epc + 7200.0)  # Propagate 2 hours\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_size(100)  # Keep only 100 most recent states\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int or None) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_initial_conditions","title":"set_initial_conditions  <code>method descriptor</code>","text":"<pre><code>set_initial_conditions(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Set initial conditions.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame.</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\n\n# Change initial conditions to a different orbit\nnew_oe = np.array([bh.R_EARTH + 800e3, 0.02, 1.2, 0.5, 0.3, 0.0])\nnew_state = bh.state_osculating_to_cartesian(new_oe, bh.AngleFormat.RADIANS)\nnew_epc = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop.set_initial_conditions(new_epc, new_state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, bh.AngleFormat.RADIANS)\nprint(f\"New initial epoch: {prop.initial_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str or None) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's native format.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's native format.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_as_osculating_elements","title":"states_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>states_as_osculating_elements(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_ecef","title":"states_ecef  <code>method descriptor</code>","text":"<pre><code>states_ecef(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECEF state vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step()  # Advance by default step_size (60 seconds)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step_by(120.0)  # Advance by 120 seconds\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 300.0  # Target 5 minutes ahead\nprop.step_past(target)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; KeplerianPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; KeplerianPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with identity set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000e3, 0.001, 0.9, 0.0, 0.0, 0.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc, oe, bh.AngleFormat.RADIANS, 60.0\n).with_name(\"My Orbit\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; KeplerianPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#brahe.KeplerianPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/orbits/keplerian_propagator.html#overview","title":"Overview","text":"<p>The Keplerian propagator provides fast, analytical orbit propagation for unperturbed two-body motion. It uses closed-form solutions to Kepler's equations for orbital element propagation.</p> <p>Key Features: - Fast analytical propagation (no numerical integration) - Perfect for preliminary analysis and mission design - No perturbations (atmospheric drag, J2, third-body, etc.) - Suitable for high-altitude orbits where perturbations are minimal</p> <p>Module: <code>brahe.orbits</code></p> <p>When to Use: - Preliminary orbit analysis - High-altitude orbits (GEO, cislunar) - Short propagation times where perturbations are negligible - Educational purposes</p> <p>When NOT to Use: - LEO orbits requiring accuracy beyond a few days - When atmospheric drag is significant - When J2 perturbations matter - Precise orbit determination applications</p>"},{"location":"library_api/orbits/keplerian_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Initial orbital elements [a, e, i, \u03a9, \u03c9, M] in SI units (m, rad)\n# Example: Geostationary orbit\na = 42164000.0        # Semi-major axis (m)\ne = 0.0001            # Eccentricity\ni = 0.0 * bh.DEG2RAD  # Inclination (rad)\nraan = 0.0            # Right ascension of ascending node (rad)\nargp = 0.0            # Argument of periapsis (rad)\nM = 0.0               # Mean anomaly (rad)\n\nelements = np.array([a, e, i, raan, argp, M])\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create propagator\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI,\n    gm=bh.GM_EARTH\n)\n\n# Propagate to a future time\nfuture_epoch = epoch + 86400.0  # 1 day later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz]\n\n# Propagate to multiple times\ntimes = np.linspace(0, 7*86400, 100)  # 1 week in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)\n\nprint(f\"Propagated to {len(states)} epochs\")\nprint(f\"Final position: {states[-1][:3]} m\")\n</code></pre>"},{"location":"library_api/orbits/keplerian_propagator.html#orbital-elements","title":"Orbital Elements","text":"<p>The propagator accepts orbital elements in the following order: 1. a - Semi-major axis (meters) 2. e - Eccentricity (dimensionless) 3. i - Inclination (radians) 4. \u03a9 - Right ascension of ascending node (radians) 5. \u03c9 - Argument of periapsis (radians) 6. M or \u03bd - Mean anomaly or true anomaly (radians)</p> <p>Use <code>OrbitRepresentation</code> to specify element type: - <code>MEAN_ELEMENTS</code> - Mean orbital elements with mean anomaly - <code>OSCULATING_ELEMENTS</code> - Osculating elements with true anomaly</p>"},{"location":"library_api/orbits/keplerian_propagator.html#see-also","title":"See Also","text":"<ul> <li>SGPPropagator - SGP4/SDP4 propagator for TLE data</li> <li>Keplerian Elements - Orbital element conversion functions</li> <li>OrbitRepresentation - Element type specification</li> </ul>"},{"location":"library_api/orbits/sgp_propagator.html","title":"SGP Propagator","text":"<p>The SGP4/SDP4 propagator for satellite orbit propagation using Two-Line Element (TLE) data.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator","title":"SGPPropagator","text":"<pre><code>SGPPropagator()\n</code></pre> <p>Python wrapper for SGPPropagator (replaces TLE) SGP4/SDP4 satellite propagator using TLE data.</p> <p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using Two-Line Element (TLE) orbital data. This is the standard model used for tracking objects in Earth orbit.</p> Example <pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_eci = prop.state(epc)\nprint(f\"Position: {state_eci[:3]}\")\nprint(f\"Velocity: {state_eci[3:]}\")\n\n# Propagate multiple epochs\nepochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\nstates = prop.states(epochs)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for SGPPropagator (replaces TLE)\\nSGP4/SDP4 satellite propagator using TLE data.\\n\\nThe SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models\\nfor propagating satellites using Two-Line Element (TLE) orbital data. This is the standard\\nmodel used for tracking objects in Earth orbit.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # ISS TLE data (example)\\n    line1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\\n    line2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\\n\\n    # Create propagator\\n    prop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\\n\\n    # Propagate to a specific epoch\\n    epc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    state_eci = prop.state(epc)\\n    print(f\"Position: {state_eci[:3]}\")\\n    print(f\"Velocity: {state_eci[3:]}\")\\n\\n    # Propagate multiple epochs\\n    epochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\\n    states = prop.states(epochs)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.step()\nprint(f\"Current epoch: {propagator.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Epoch\n</code></pre> <p>Get TLE epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch of the TLE data.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.norad_id","title":"norad_id  <code>property</code>","text":"<pre><code>norad_id: int\n</code></pre> <p>Get NORAD ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>NORAD catalog ID.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: str\n</code></pre> <p>Get satellite name (if available).</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: Satellite name if provided.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Satellite: {propagator.satellite_name}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(f\"Step size: {propagator.step_size} seconds\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.propagate_steps(100)\ntraj = prop.trajectory\nprint(f\"Trajectory has {traj.len()} states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; np.ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector in the propagator's output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.from_3le","title":"from_3le  <code>builtin</code>","text":"<pre><code>from_3le(name: str, line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from 3-line TLE format (with satellite name).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (line 0).</p> required <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.from_tle","title":"from_tle  <code>builtin</code>","text":"<pre><code>from_tle(line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.get_elements","title":"get_elements  <code>method descriptor</code>","text":"<pre><code>get_elements(angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Get Keplerian orbital elements from TLE data.</p> <p>Extracts the Keplerian elements directly from the TLE lines used to initialize this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements (DEGREES or RADIANS).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Keplerian elements [a, e, i, \u03a9, \u03c9, M] where: - a: semi-major axis [m] - e: eccentricity [dimensionless] - i: inclination [rad or deg] - \u03a9: right ascension of ascending node [rad or deg] - \u03c9: argument of periapsis [rad or deg] - M: mean anomaly [rad or deg]</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements in degrees\noe_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nprint(f\"Inclination: {oe_deg[2]:.4f} degrees\")\n\n# Get elements in radians\noe_rad = prop.get_elements(bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {oe_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; np.ndarray\n</code></pre> <p>Get initial state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector in the propagator's output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\nprop.propagate_steps(10)  # Advance by 10 steps (600 seconds)\nprint(f\"After 10 steps: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ninitial_epoch = prop.epoch\nprop.propagate_steps(100)\nprop.reset()\nprint(f\"Reset to: {prop.current_epoch == initial_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_age(86400.0)  # Keep 1 day of history\nprint(\"Trajectory limited to 24 hours of states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_size(1000)\nprint(\"Trajectory limited to 1000 states\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int or None) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str or None) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.set_output_format","title":"set_output_format  <code>method descriptor</code>","text":"<pre><code>set_output_format(frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None) -&gt; Any\n</code></pre> <p>Set output format (frame, representation, and angle format).</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>OrbitFrame</code> <p>Output frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>Output representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian (None for Cartesian).</p> required"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's current output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.state_pef","title":"state_pef  <code>method descriptor</code>","text":"<pre><code>state_pef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Compute state at a specific epoch in PEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in PEF frame.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's current output format.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step()  # Advance by default step_size\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step_by(120.0)  # Advance by 2 minutes\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 3600.0  # 1 hour later\nprop.step_past(target)\nprint(f\"Stepped past target\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; SGPPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; SGPPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with identity set.</p> Example <pre><code>import brahe as bh\nimport uuid\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nmy_uuid = str(uuid.uuid4())\nprop = bh.SGPPropagator.from_tle(line1, line2).with_identity(\"ISS\", my_uuid, 25544)\nprint(f\"Name: {prop.name}, ID: {prop.id}, UUID: {prop.uuid}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; SGPPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_name(\"My Satellite\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; SGPPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#brahe.SGPPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; SGPPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/orbits/sgp_propagator.html#overview","title":"Overview","text":"<p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using TLE orbital data. This is the standard model used for tracking objects in Earth orbit and is maintained by NORAD/Space Force.</p> <p>Key Features: - Industry-standard orbit propagation - Atmospheric drag modeling - Automatic selection between SGP4 (near-Earth) and SDP4 (deep-space) models - Compatible with standard TLE format</p> <p>Module: <code>brahe.orbits</code></p>"},{"location":"library_api/orbits/sgp_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator from TLE\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get current epoch\nepoch = prop.epoch()\n\n# Propagate to a specific time\nfuture_epoch = epoch + 3600.0  # 1 hour later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz] in TEME frame\n\n# Propagate to multiple times\nimport numpy as np\ntimes = np.linspace(0, 86400, 100)  # 1 day in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)  # Returns array of states\n</code></pre>"},{"location":"library_api/orbits/sgp_propagator.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>TLE - Two-Line Element format details</li> <li>Keplerian Elements - Orbital element functions</li> </ul>"},{"location":"library_api/orbits/tle.html","title":"Two-Line Element (TLE)","text":"<p>Functions for parsing, validating, and converting Two-Line Element sets.</p> <p>For propagating orbits from TLE data, use the <code>SGPPropagator</code> class.</p>"},{"location":"library_api/orbits/tle.html#tle-utility-functions","title":"TLE Utility Functions","text":""},{"location":"library_api/orbits/tle.html#brahe.orbits.epoch_from_tle","title":"epoch_from_tle  <code>builtin</code>","text":"<pre><code>epoch_from_tle(line1: str) -&gt; Epoch\n</code></pre> <p>Extract Epoch from TLE line 1</p> <p>Extracts and parses the epoch timestamp from the first line of TLE data. The epoch is returned in UTC time system.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Extracted epoch in UTC time system</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\n&gt;&gt;&gt; epoch = epoch_from_tle(line1)\n&gt;&gt;&gt; epoch.year()\n2021\n</code></pre>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_from_tle","title":"keplerian_elements_from_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_from_tle(line1: str, line2: str) -&gt; Tuple\n</code></pre> <p>Extract Keplerian orbital elements from TLE lines.</p> <p>Extracts the standard six Keplerian orbital elements from Two-Line Element (TLE) data. Returns elements in standard order: [a, e, i, raan, argp, M] where angles are in radians.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing: - epoch (Epoch): Epoch of the TLE data. - elements (numpy.ndarray): Six Keplerian elements [a, e, i, raan, argp, M] where   a is semi-major axis in meters, e is eccentricity (dimensionless), and   i, raan, argp, M are in radians.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_to_tle","title":"keplerian_elements_to_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_to_tle(epoch: Epoch, elements: ndarray, norad_id: str) -&gt; Tuple\n</code></pre> <p>Convert Keplerian elements to TLE lines.</p> <p>Converts standard Keplerian orbital elements to Two-Line Element (TLE) format. Input angles should be in degrees for compatibility with TLE format.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>elements</code> <code>ndarray</code> <p>Keplerian elements [a (m), e, i (deg), raan (deg), argp (deg), M (deg)].</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.create_tle_lines","title":"create_tle_lines  <code>builtin</code>","text":"<pre><code>create_tle_lines(epoch: Epoch, inclination: float, raan: float, eccentricity: float, arg_perigee: float, mean_anomaly: float, mean_motion: float, norad_id: str, ephemeris_type: int, element_set_number: int, revolution_number: int, classification: str = None, intl_designator: str = None, first_derivative: float = None, second_derivative: float = None, bstar: float = None) -&gt; Tuple\n</code></pre> <p>Create complete TLE lines from all parameters.</p> <p>Creates Two-Line Element (TLE) lines from complete set of orbital and administrative parameters. Provides full control over all TLE fields including derivatives and drag terms.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless).</p> required <code>arg_perigee</code> <code>float</code> <p>Argument of periapsis in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <code>ephemeris_type</code> <code>int</code> <p>Ephemeris type (0-9).</p> required <code>element_set_number</code> <code>int</code> <p>Element set number.</p> required <code>revolution_number</code> <code>int</code> <p>Revolution number at epoch.</p> required <code>classification</code> <code>str</code> <p>Security classification. Defaults to ' '.</p> <code>None</code> <code>intl_designator</code> <code>str</code> <p>International designator. Defaults to ''.</p> <code>None</code> <code>first_derivative</code> <code>float</code> <p>First derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>second_derivative</code> <code>float</code> <p>Second derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>bstar</code> <code>float</code> <p>BSTAR drag term. Defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_line","title":"validate_tle_line  <code>builtin</code>","text":"<pre><code>validate_tle_line(line: str) -&gt; bool\n</code></pre> <p>Validate single TLE line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the line is valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_lines","title":"validate_tle_lines  <code>builtin</code>","text":"<pre><code>validate_tle_lines(line1: str, line2: str) -&gt; bool\n</code></pre> <p>Validate TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both lines are valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.calculate_tle_line_checksum","title":"calculate_tle_line_checksum  <code>builtin</code>","text":"<pre><code>calculate_tle_line_checksum(line: str) -&gt; int\n</code></pre> <p>Calculate TLE line checksum.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum value.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.parse_norad_id","title":"parse_norad_id  <code>builtin</code>","text":"<pre><code>parse_norad_id(norad_str: str) -&gt; int\n</code></pre> <p>Parse NORAD ID from string, handling both classic and Alpha-5 formats.</p> <p>Parameters:</p> Name Type Description Default <code>norad_str</code> <code>str</code> <p>NORAD ID string from TLE.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Parsed numeric NORAD ID.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_numeric_to_alpha5","title":"norad_id_numeric_to_alpha5  <code>builtin</code>","text":"<pre><code>norad_id_numeric_to_alpha5(norad_id: int) -&gt; str\n</code></pre> <p>Convert numeric NORAD ID to Alpha-5 format.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>Numeric NORAD ID (100000-339999).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_alpha5_to_numeric","title":"norad_id_alpha5_to_numeric  <code>builtin</code>","text":"<pre><code>norad_id_alpha5_to_numeric(alpha5_id: str) -&gt; int\n</code></pre> <p>Convert Alpha-5 NORAD ID to numeric format.</p> <p>Parameters:</p> Name Type Description Default <code>alpha5_id</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric NORAD ID.</p>"},{"location":"library_api/time/index.html","title":"Time","text":"<p>Module: <code>brahe.time</code></p> <p>High-precision time system management and conversions.</p>"},{"location":"library_api/time/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Epoch Class - Core time representation supporting multiple time systems</li> <li>Time Conversions - Functions for converting between time systems and formats</li> </ul>"},{"location":"library_api/time/conversions.html","title":"Time Conversions","text":"<p>Functions for converting between different time systems and formats.</p>"},{"location":"library_api/time/conversions.html#time-system-offset-functions","title":"Time System Offset Functions","text":""},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_mjd","title":"time_system_offset_for_mjd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_mjd(mjd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from UTC to TAI at J2000 epoch\nmjd_j2000 = 51544.0\noffset = bh.time_system_offset_for_mjd(mjd_j2000, bh.TimeSystem.UTC, bh.TimeSystem.TAI)\nprint(f\"UTC to TAI offset: {offset} seconds\")\n# Output: UTC to TAI offset: 32.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_jd","title":"time_system_offset_for_jd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_jd(jd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from GPS to UTC at a specific Julian Date\njd = 2460000.0\noffset = bh.time_system_offset_for_jd(jd, bh.TimeSystem.GPS, bh.TimeSystem.UTC)\nprint(f\"GPS to UTC offset: {offset} seconds\")\n# Output: GPS to UTC offset: -18.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_datetime","title":"time_system_offset_for_datetime  <code>builtin</code>","text":"<pre><code>time_system_offset_for_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Gregorian calendar date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from TT to TAI on January 1, 2024\noffset = bh.time_system_offset_for_datetime(\n    2024, 1, 1, 0, 0, 0.0, 0.0,\n    bh.TimeSystem.TT, bh.TimeSystem.TAI\n)\nprint(f\"TT to TAI offset: {offset} seconds\")\n# Output: TT to TAI offset: -32.184 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#datetime-conversion-functions","title":"DateTime Conversion Functions","text":""},{"location":"library_api/time/conversions.html#brahe.datetime_to_jd","title":"datetime_to_jd  <code>builtin</code>","text":"<pre><code>datetime_to_jd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Julian Date\njd = bh.datetime_to_jd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460311.000000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.datetime_to_mjd","title":"datetime_to_mjd  <code>builtin</code>","text":"<pre><code>datetime_to_mjd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Modified Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Modified Julian Date\nmjd = bh.datetime_to_mjd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.500000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.jd_to_datetime","title":"jd_to_datetime  <code>builtin</code>","text":"<pre><code>jd_to_datetime(jd: float) -&gt; Tuple\n</code></pre> <p>Convert a Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Julian Date to Gregorian calendar\njd = 2460311.0\nyear, month, day, hour, minute, second, nanosecond = bh.jd_to_datetime(jd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.mjd_to_datetime","title":"mjd_to_datetime  <code>builtin</code>","text":"<pre><code>mjd_to_datetime(mjd: float) -&gt; Tuple\n</code></pre> <p>Convert a Modified Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Modified Julian Date to Gregorian calendar\nmjd = 60310.5\nyear, month, day, hour, minute, second, nanosecond = bh.mjd_to_datetime(mjd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html","title":"Epoch Class","text":"<p>The <code>Epoch</code> class is the foundational time representation in Brahe, providing comprehensive support for multiple time systems and high-precision time computations with nanosecond accuracy.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch","title":"Epoch","text":"<pre><code>Epoch()\n</code></pre> <p>Represents a specific instant in time.</p> <p>Epoch is the primary and preferred mechanism for representing time in brahe. It accurately represents, tracks, and compares instants in time with nanosecond precision.</p> <p>Internally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation was chosen to enable accurate time system conversions using the IAU SOFA library (which operates in days and fractional days) while maintaining high precision for small time differences. The structure uses Kahan summation to accurately handle running sums over long periods without losing accuracy to floating-point rounding errors.</p> <p>All arithmetic operations (addition, subtraction) use seconds as the default unit and return time differences in seconds.</p> <p>The Epoch constructor accepts multiple input formats for convenience:</p> <ul> <li>Date components: <code>Epoch(year, month, day)</code> - creates epoch at midnight</li> <li>Full datetime: <code>Epoch(year, month, day, hour, minute, second, nanosecond)</code> - full precision</li> <li>Partial datetime: <code>Epoch(year, month, day, hour)</code> or <code>Epoch(year, month, day, hour, minute)</code> etc.</li> <li>ISO 8601 string: <code>Epoch(\"2024-01-01T12:00:00Z\")</code> - parse from string</li> <li>Python datetime: <code>Epoch(datetime_obj)</code> - convert from Python datetime</li> <li>Copy constructor: <code>Epoch(other_epoch)</code> - create a copy</li> <li>Time system: All constructors accept optional <code>time_system=</code> keyword argument (default: UTC)</li> </ul> Example <pre><code>import brahe as bh\nfrom datetime import datetime\n\n# Multiple ways to create the same epoch\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\nepc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\nprint(epc1)\n# Output: 2024-01-01 12:00:00.000 UTC\n\n# Create epoch at midnight\nmidnight = bh.Epoch(2024, 1, 1)\nprint(midnight)\n# Output: 2024-01-01 00:00:00.000 UTC\n\n# Use different time systems\ngps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\nprint(gps_time)\n# Output: 2024-01-01 12:00:00.000 GPS\n\n# Perform arithmetic operations\nepoch2 = epc1 + 3600.0  # Add one hour (in seconds)\ndiff = epoch2 - epc1     # Difference in seconds\nprint(f\"Time difference: {diff} seconds\")\n# Output: Time difference: 3600.0 seconds\n\n# Legacy constructors still available\nepc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nepc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a specific instant in time.\\n\\nEpoch is the primary and preferred mechanism for representing time in brahe.\\nIt accurately represents, tracks, and compares instants in time with nanosecond precision.\\n\\nInternally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation\\nwas chosen to enable accurate time system conversions using the IAU SOFA library (which operates\\nin days and fractional days) while maintaining high precision for small time differences.\\nThe structure uses Kahan summation to accurately handle running sums over long periods without\\nlosing accuracy to floating-point rounding errors.\\n\\nAll arithmetic operations (addition, subtraction) use seconds as the default unit and return\\ntime differences in seconds.\\n\\nThe Epoch constructor accepts multiple input formats for convenience:\\n\\n- **Date components**: `Epoch(year, month, day)` - creates epoch at midnight\\n- **Full datetime**: `Epoch(year, month, day, hour, minute, second, nanosecond)` - full precision\\n- **Partial datetime**: `Epoch(year, month, day, hour)` or `Epoch(year, month, day, hour, minute)` etc.\\n- **ISO 8601 string**: `Epoch(\"2024-01-01T12:00:00Z\")` - parse from string\\n- **Python datetime**: `Epoch(datetime_obj)` - convert from Python datetime\\n- **Copy constructor**: `Epoch(other_epoch)` - create a copy\\n- **Time system**: All constructors accept optional `time_system=` keyword argument (default: UTC)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    from datetime import datetime\\n\\n    # Multiple ways to create the same epoch\\n    epc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\\n    epc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\\n    epc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\\n    print(epc1)\\n    # Output: 2024-01-01 12:00:00.000 UTC\\n\\n    # Create epoch at midnight\\n    midnight = bh.Epoch(2024, 1, 1)\\n    print(midnight)\\n    # Output: 2024-01-01 00:00:00.000 UTC\\n\\n    # Use different time systems\\n    gps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\\n    print(gps_time)\\n    # Output: 2024-01-01 12:00:00.000 GPS\\n\\n    # Perform arithmetic operations\\n    epoch2 = epc1 + 3600.0  # Add one hour (in seconds)\\n    diff = epoch2 - epc1     # Difference in seconds\\n    print(f\"Time difference: {diff} seconds\")\\n    # Output: Time difference: 3600.0 seconds\\n\\n    # Legacy constructors still available\\n    epc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\\n    epc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.time_system","title":"time_system  <code>property</code>","text":"<pre><code>time_system: TimeSystem\n</code></pre> <p>Time system of the epoch.</p> <p>Returns:</p> Name Type Description <code>TimeSystem</code> <code>TimeSystem</code> <p>The time system used by this epoch</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day","title":"day  <code>method descriptor</code>","text":"<pre><code>day() -&gt; int\n</code></pre> <p>Returns the day component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The day of the month as an integer from 1 to 31</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year","title":"day_of_year  <code>method descriptor</code>","text":"<pre><code>day_of_year() -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the epoch's time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, \"UTC\") doy = epoch.day_of_year() print(f\"Day of year: {doy}\") Day of year: 100.5</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year_as_time_system","title":"day_of_year_as_time_system  <code>method descriptor</code>","text":"<pre><code>day_of_year_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the specified time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>The time system to use for the calculation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, brahe.TimeSystem.UTC) doy_tai = epoch.day_of_year_as_time_system(brahe.TimeSystem.TAI) print(f\"Day of year in TAI: {doy_tai}\") Day of year in TAI: 100.50042824074075</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_date","title":"from_date  <code>builtin</code>","text":"<pre><code>from_date(year: int, month: int, day: int, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a calendar date at midnight.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing midnight on the specified date</p> Example <pre><code>import brahe as bh\n\n# Create an epoch at midnight on January 1, 2024 UTC\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T00:00:00.000000000 UTC\n\n# Create epoch in different time system\nepc_tai = bh.Epoch.from_date(2024, 6, 15, bh.TimeSystem.TAI)\nprint(epc_tai)\n# Output: 2024-06-15T00:00:00.000000000 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_datetime","title":"from_datetime  <code>builtin</code>","text":"<pre><code>from_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a complete Gregorian calendar date and time.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified date and time</p> Example <pre><code>import brahe as bh\n\n# Create epoch for January 1, 2024 at 12:30:45.5 UTC\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T12:30:45.500000000 UTC\n\n# With nanosecond precision\nepc_ns = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 0.0, 123456789.0, bh.TimeSystem.TAI)\nprint(epc_ns)\n# Output: 2024-06-15T14:30:00.123456789 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_day_of_year","title":"from_day_of_year  <code>builtin</code>","text":"<pre><code>from_day_of_year(year: int, day_of_year: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a year and floating-point day-of-year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>day_of_year</code> <code>float</code> <p>Day of year as a floating-point number (1.0 = January 1st, 1.5 = January 1st noon, etc.)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified day of year</p> Example <pre><code>import brahe as bh\n\n# Create epoch for day 100 of 2024 at midnight\nepc = bh.Epoch.from_day_of_year(2024, 100.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-04-09T00:00:00.000000000 UTC\n\n# Create epoch for day 100.5 (noon on day 100)\nepc_noon = bh.Epoch.from_day_of_year(2024, 100.5, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc_noon.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-04-09 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_date","title":"from_gps_date  <code>builtin</code>","text":"<pre><code>from_gps_date(week: int, seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS week and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>week</code> <code>int</code> <p>GPS week number since GPS epoch (January 6, 1980)</p> required <code>seconds</code> <code>float</code> <p>Seconds into the GPS week</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS week 2200, day 3, noon\nweek = 2200\nseconds = 3 * 86400 + 12 * 3600  # 3 days + 12 hours\nepc = bh.Epoch.from_gps_date(week, seconds)\nprint(epc)\n\n# Verify GPS week extraction\nweek_out, sec_out = epc.gps_date()\nprint(f\"GPS Week: {week_out}, Seconds: {sec_out}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_nanoseconds","title":"from_gps_nanoseconds  <code>builtin</code>","text":"<pre><code>from_gps_nanoseconds(gps_nanoseconds: int) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS nanoseconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_nanoseconds</code> <code>int</code> <p>Nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS nanoseconds with high precision\ngps_ns = 1234567890123456789\nepc = bh.Epoch.from_gps_nanoseconds(gps_ns)\nprint(f\"Epoch: {epc}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_seconds","title":"from_gps_seconds  <code>builtin</code>","text":"<pre><code>from_gps_seconds(gps_seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS seconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_seconds</code> <code>float</code> <p>Seconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS seconds\ngps_seconds = 1234567890.5\nepc = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"Epoch: {epc}\")\nprint(f\"GPS seconds: {epc.gps_seconds()}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_jd","title":"from_jd  <code>builtin</code>","text":"<pre><code>from_jd(jd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Julian Date\njd = 2460000.0\nepc = bh.Epoch.from_jd(jd, bh.TimeSystem.UTC)\nprint(epc)\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"JD: {jd_out:.10f}\")\n# Output: JD: 2460000.0000000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_mjd","title":"from_mjd  <code>builtin</code>","text":"<pre><code>from_mjd(mjd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Modified Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Modified Julian Date\nmjd = 60000.0\nepc = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\nprint(epc)\n\n# MJD is commonly used in astronomy\nmjd_j2000 = 51544.0  # J2000 epoch\nepc_j2000 = bh.Epoch.from_mjd(mjd_j2000, bh.TimeSystem.TT)\nprint(f\"J2000: {epc_j2000}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_string","title":"from_string  <code>builtin</code>","text":"<pre><code>from_string(datestr: str) -&gt; Epoch\n</code></pre> <p>Create an Epoch from an ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>datestr</code> <code>str</code> <p>ISO 8601 formatted date string (e.g., \"2024-01-01T12:00:00.000000000 UTC\")</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the parsed date and time</p> Example <pre><code>import brahe as bh\n\n# Parse ISO 8601 string with full precision\nepc = bh.Epoch.from_string(\"2024-01-01T12:00:00.000000000 UTC\")\nprint(epc)\n# Output: 2024-01-01T12:00:00.000000000 UTC\n\n# Parse different time systems\nepc_tai = bh.Epoch.from_string(\"2024-06-15T14:30:45.123456789 TAI\")\nprint(epc_tai.time_system)\n# Output: TimeSystem.TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gast","title":"gast  <code>method descriptor</code>","text":"<pre><code>gast(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Apparent Sidereal Time (GAST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GAST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngast_rad = epc.gast(bh.AngleFormat.RADIANS)\ngast_deg = epc.gast(bh.AngleFormat.DEGREES)\nprint(f\"GAST: {gast_rad:.6f} rad = {gast_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gmst","title":"gmst  <code>method descriptor</code>","text":"<pre><code>gmst(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Mean Sidereal Time (GMST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GMST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngmst_rad = epc.gmst(bh.AngleFormat.RADIANS)\ngmst_deg = epc.gmst(bh.AngleFormat.DEGREES)\nprint(f\"GMST: {gmst_rad:.6f} rad = {gmst_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_date","title":"gps_date  <code>method descriptor</code>","text":"<pre><code>gps_date() -&gt; Tuple\n</code></pre> <p>Get the GPS week number and seconds into the week.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (week, seconds_into_week)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.GPS)\nweek, seconds = epc.gps_date()\nprint(f\"GPS Week: {week}, Seconds: {seconds:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_nanoseconds","title":"gps_nanoseconds  <code>method descriptor</code>","text":"<pre><code>gps_nanoseconds() -&gt; float\n</code></pre> <p>Get the nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS nanoseconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 123456789.0, bh.TimeSystem.GPS)\ngps_ns = epc.gps_nanoseconds()\nprint(f\"GPS nanoseconds: {gps_ns:.0f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_seconds","title":"gps_seconds  <code>method descriptor</code>","text":"<pre><code>gps_seconds() -&gt; float\n</code></pre> <p>Get the seconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS seconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\ngps_sec = epc.gps_seconds()\nprint(f\"GPS seconds: {gps_sec:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.hour","title":"hour  <code>method descriptor</code>","text":"<pre><code>hour() -&gt; int\n</code></pre> <p>Returns the hour component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hour as an integer from 0 to 23</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring","title":"isostring  <code>method descriptor</code>","text":"<pre><code>isostring() -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string with full nanosecond precision</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso = epc.isostring()\nprint(iso)\n# Output: 2024-01-01T12:30:45.123456789Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring_with_decimals","title":"isostring_with_decimals  <code>method descriptor</code>","text":"<pre><code>isostring_with_decimals(decimals: int) -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string with specified decimal precision.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimal places for the seconds field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso3 = epc.isostring_with_decimals(3)\niso6 = epc.isostring_with_decimals(6)\nprint(iso3)  # Output: 2024-01-01T12:30:45.123Z\nprint(iso6)  # Output: 2024-01-01T12:30:45.123457Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd","title":"jd  <code>method descriptor</code>","text":"<pre><code>jd() -&gt; float\n</code></pre> <p>Get the Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd = epc.jd()\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460310.500000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd_as_time_system","title":"jd_as_time_system  <code>method descriptor</code>","text":"<pre><code>jd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd_utc = epc.jd()\njd_tai = epc.jd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"JD UTC: {jd_utc:.10f}\")\nprint(f\"JD TAI: {jd_tai:.10f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.minute","title":"minute  <code>method descriptor</code>","text":"<pre><code>minute() -&gt; int\n</code></pre> <p>Returns the minute component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The minute as an integer from 0 to 59</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd","title":"mjd  <code>method descriptor</code>","text":"<pre><code>mjd() -&gt; float\n</code></pre> <p>Get the Modified Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epc.mjd()\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd_as_time_system","title":"mjd_as_time_system  <code>method descriptor</code>","text":"<pre><code>mjd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Modified Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd_utc = epc.mjd()\nmjd_gps = epc.mjd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"MJD UTC: {mjd_utc:.6f}\")\nprint(f\"MJD GPS: {mjd_gps:.6f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.month","title":"month  <code>method descriptor</code>","text":"<pre><code>month() -&gt; int\n</code></pre> <p>Returns the month component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The month as an integer from 1 to 12</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.nanosecond","title":"nanosecond  <code>method descriptor</code>","text":"<pre><code>nanosecond() -&gt; float\n</code></pre> <p>Returns the nanosecond component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The nanosecond component as a floating-point number</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.second","title":"second  <code>method descriptor</code>","text":"<pre><code>second() -&gt; float\n</code></pre> <p>Returns the second component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The second as a floating-point number from 0.0 to 59.999...</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime","title":"to_datetime  <code>method descriptor</code>","text":"<pre><code>to_datetime() -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-06-15 14:30:45.500\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime_as_time_system","title":"to_datetime_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_datetime_as_time_system(time_system: TimeSystem) -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Create epoch in UTC and convert to TAI\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime_as_time_system(bh.TimeSystem.TAI)\nprint(f\"TAI: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: TAI: 2024-01-01 12:00:37.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_string_as_time_system","title":"to_string_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_string_as_time_system(time_system: TimeSystem) -&gt; str\n</code></pre> <p>Convert the epoch to a string representation in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the epoch</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprint(epc.to_string_as_time_system(bh.TimeSystem.UTC))\nprint(epc.to_string_as_time_system(bh.TimeSystem.TAI))\n# Shows same instant in different time systems\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.year","title":"year  <code>method descriptor</code>","text":"<pre><code>year() -&gt; int\n</code></pre> <p>Returns the year component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year as a 4-digit integer</p>"},{"location":"library_api/trajectories/index.html","title":"Trajectories","text":"<p>Module: <code>brahe.trajectories</code></p> <p>Trajectory containers for storing, managing, and interpolating time-series state data.</p>"},{"location":"library_api/trajectories/index.html#overview","title":"Overview","text":"<p>Brahe provides several trajectory container types for storing sequences of states (positions, velocities, or other data) over time with automatic interpolation capabilities.</p>"},{"location":"library_api/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":""},{"location":"library_api/trajectories/index.html#dtrajectory","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container where dimension is set at runtime. Flexible for storing any N-dimensional state data.</p>"},{"location":"library_api/trajectories/index.html#strajectory6","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state vectors [x, y, z, vx, vy, vz]. Faster than DTrajectory for fixed-size data.</p>"},{"location":"library_api/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized orbital trajectory with frame-aware storage and automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/index.html#key-features","title":"Key Features","text":"<ul> <li>Time-ordered storage: States automatically sorted by epoch</li> <li>Interpolation: Linear or Lagrange interpolation between states</li> <li>Eviction policies: Automatic state removal based on age or count</li> <li>Query methods: Get states before/after/at specific times</li> <li>Batch operations: Add and query multiple states efficiently</li> </ul>"},{"location":"library_api/trajectories/index.html#quick-comparison","title":"Quick Comparison","text":"Feature DTrajectory STrajectory6 OrbitTrajectory Dimension Runtime (any N) Compile-time (6) Compile-time (6) Performance Good Better Better Use Case General data Orbital states Frame-aware orbits Frames Not frame-aware Not frame-aware ECI/ECEF support"},{"location":"library_api/trajectories/index.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Option 1: Dynamic trajectory (any dimension)\ntraj_dyn = bh.DTrajectory(dimension=6)\n\n# Option 2: Static 6D trajectory (faster for orbital states)\ntraj_static = bh.STrajectory6()\n\n# Option 3: Orbit trajectory (frame-aware)\ntraj_orbit = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Add states\nstate = np.array([7000000.0, 0.0, 0.0, 0.0, 7500.0, 0.0])  # [x,y,z,vx,vy,vz]\ntraj_static.add(epoch, state)\n\n# Propagate orbit and store trajectory\nprop = bh.KeplerianPropagator(...)\ntimes = np.linspace(0, 86400, 100)\nfor dt in times:\n    future_epoch = epoch + dt\n    state = prop.propagate(future_epoch)\n    traj_static.add(future_epoch, state)\n\n# Query with interpolation\nquery_epoch = epoch + 43200.0  # 12 hours later\ninterpolated_state = traj_static.interpolate(query_epoch)\n</code></pre>"},{"location":"library_api/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>InterpolationMethod - Interpolation options</li> <li>OrbitFrame - Frame specifications</li> <li>KeplerianPropagator - Analytical orbit propagation</li> <li>SGPPropagator - SGP4/SDP4 orbit propagation</li> </ul>"},{"location":"library_api/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container for N-dimensional state data.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory","title":"DTrajectory","text":"<pre><code>DTrajectory()\n</code></pre> <p>Dynamic-dimension trajectory container.</p> <p>Stores a sequence of N-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is determined at runtime.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Dynamic-dimension trajectory container.\\n\\nStores a sequence of N-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is\\ndetermined at runtime.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>N-element state vector where N is the trajectory dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get the trajectory dimension (method form).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Any\n</code></pre> <p>Get end epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; DTrajectory\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of states with shape (num_epochs, dimension) where each row is a state vector</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = bh.InterpolationMethod.LINEAR\ntraj.set_interpolation_method(method)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Any\n</code></pre> <p>Get start epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; np.ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; Any\n</code></pre> <p>Get time span of trajectory in seconds</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#overview","title":"Overview","text":"<p><code>DTrajectory</code> is a flexible trajectory container where the state dimension is determined at runtime. Use this when you need to store state vectors of varying sizes or when the dimension isn't known at compile time.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Runtime dimension specification - Automatic time-ordering of states - Configurable interpolation (Linear or Lagrange) - Eviction policies for memory management - Efficient state queries and interpolation</p>"},{"location":"library_api/trajectories/dtrajectory.html#creating-a-trajectory","title":"Creating a Trajectory","text":"<pre><code>import brahe as bh\n\n# Create with specified dimension\ntraj = bh.DTrajectory(dimension=6)  # For orbital states\n\n# Create with specific interpolation method\ntraj = bh.DTrajectory(\n    dimension=3,\n    interpolation_method=bh.InterpolationMethod.LAGRANGE\n)\n\n# Create from existing data\nimport numpy as np\nepochs = [epoch1, epoch2, epoch3]\nstates = np.array([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])\ntraj = bh.DTrajectory.from_data(\n    epochs,\n    states,\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(dimension=6)\n\n# Add single state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([7e6, 0, 0, 0, 7.5e3, 0])\ntraj.add(epoch, state)\n\n# Add multiple states from propagation\nprop = bh.KeplerianPropagator(...)\nfor i in range(100):\n    future_epoch = epoch + i * 60.0  # Every minute\n    state = prop.propagate(future_epoch)\n    traj.add(future_epoch, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#querying-states","title":"Querying States","text":"<pre><code># Interpolate at specific epoch\nquery_epoch = epoch + 1800.0  # 30 minutes later\ninterp_state = traj.interpolate(query_epoch)\n\n# Get state at specific index\nstate_10 = traj.state(10)\nepoch_10 = traj.epoch(10)\n\n# Get first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\n\n# Get state before/after epoch\nbefore_epoch, before_state = traj.state_before_epoch(query_epoch)\nafter_epoch, after_state = traj.state_after_epoch(query_epoch)\n\n# Get all data\nall_states = traj.to_matrix()  # Returns numpy array (n_states, dimension)\nall_epochs = traj.to_epochs()  # Returns list of Epochs\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#eviction-policies","title":"Eviction Policies","text":"<p>Control memory usage by automatically removing old states:</p> <pre><code># Maximum age: keep only states within 1 hour of newest\ntraj.set_eviction_policy_max_age(3600.0)\n\n# Maximum size: keep only last 1000 states\ntraj.set_eviction_policy_max_size(1000)\n\n# No eviction (default)\ntraj.set_eviction_policy_no_eviction()\n\n# Builder pattern (method chaining)\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_eviction_policy_max_age(3600.0) \\\n    .with_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#interpolation-methods","title":"Interpolation Methods","text":"<pre><code># Linear interpolation (faster, less accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n\n# Lagrange interpolation (slower, more accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#trajectory-information","title":"Trajectory Information","text":"<pre><code># Get dimension\ndim = traj.dimension()  # Returns dimension of state vectors\n\n# Get size\nn_states = traj.len()  # Number of states stored\n\n# Check if empty\nis_empty = traj.is_empty()\n\n# Get time span\nspan = traj.timespan()  # Duration in seconds from first to last\n\n# Get start/end epochs\nstart = traj.start_epoch()\nend = traj.end_epoch()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#clearing-and-removing-states","title":"Clearing and Removing States","text":"<pre><code># Clear all states\ntraj.clear()\n\n# Remove state at specific epoch\nremoved_state = traj.remove_epoch(epoch)\n\n# Remove state at index\nremoved_epoch, removed_state = traj.remove_at(index)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#complete-example","title":"Complete Example","text":"<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set up propagator\nepoch_start = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch_start,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Create trajectory with eviction policy\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_interpolation_method(bh.InterpolationMethod.LINEAR) \\\n    .with_eviction_policy_max_size(1000)\n\n# Propagate and store states\ntimes = np.linspace(0, 86400, 1440)  # 1 day, 1-minute steps\nfor dt in times:\n    epoch = epoch_start + dt\n    state = prop.propagate(epoch)\n    traj.add(epoch, state)\n\nprint(f\"Stored {traj.len()} states\")\nprint(f\"Time span: {traj.timespan()/3600:.1f} hours\")\n\n# Interpolate at arbitrary times\nquery_times = np.linspace(0, 86400, 100)\naltitudes = []\nfor dt in query_times:\n    query_epoch = epoch_start + dt\n    state = traj.interpolate(query_epoch)\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1000  # km\n    altitudes.append(altitude)\n\n# Plot altitude profile\nplt.plot(query_times/3600, altitudes)\nplt.xlabel('Time (hours)')\nplt.ylabel('Altitude (km)')\nplt.title('Orbit Altitude Over 1 Day')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Fixed 6D trajectory (faster)</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> <li>InterpolationMethod</li> </ul>"},{"location":"library_api/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p>Frame-aware orbital trajectory with automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory","title":"OrbitTrajectory","text":"<pre><code>OrbitTrajectory()\n</code></pre> <p>Orbital trajectory with frame and representation awareness.</p> <p>Stores a sequence of orbital states at specific epochs with support for interpolation, frame conversions, and representation transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital trajectory with frame and representation awareness.\\n\\nStores a sequence of orbital states at specific epochs with support for\\ninterpolation, frame conversions, and representation transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.angle_format","title":"angle_format  <code>property</code>","text":"<pre><code>angle_format: AngleFormat\n</code></pre> <p>Get trajectory angle format for Keplerian states.</p> <p>Returns:</p> Type Description <code>AngleFormat</code> <p>AngleFormat or None: Angle format for Keplerian representation, None for Cartesian</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Angle format: {traj.angle_format}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: OrbitFrame\n</code></pre> <p>Get trajectory reference frame.</p> <p>Returns:</p> Name Type Description <code>OrbitFrame</code> <code>OrbitFrame</code> <p>Reference frame of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Frame: {traj.frame}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.representation","title":"representation  <code>property</code>","text":"<pre><code>representation: OrbitRepresentation\n</code></pre> <p>Get trajectory state representation.</p> <p>Returns:</p> Name Type Description <code>OrbitRepresentation</code> <code>OrbitRepresentation</code> <p>State representation format of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Representation: {traj.representation}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.clear()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; OrbitTrajectory\n</code></pre> <p>Create a default empty orbital trajectory (ECI Cartesian).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory with ECI frame and Cartesian representation</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6 for orbital trajectories).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"End epoch: {traj.end_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get the epoch at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch to retrieve</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get epoch at index\nepoch_0 = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epochs","title":"epochs  <code>method descriptor</code>","text":"<pre><code>epochs() -&gt; np.ndarray\n</code></pre> <p>Get all epochs as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 1D array of Julian dates for all epochs</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nepochs_array = traj.epochs()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.from_orbital_data","title":"from_orbital_data  <code>builtin</code>","text":"<pre><code>from_orbital_data(epochs: list[Epoch], states: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None = None) -&gt; OrbitTrajectory\n</code></pre> <p>Create orbital trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs for each state</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6-element state vectors with total length N*6 where N is the number of epochs</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the states</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Start epoch: {traj.start_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Get state at specified epoch (in native frame/representation).</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in trajectory's native frame and representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate1 = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc1, state1)\n\n# Query state at epoch\nstate = traj.state(epc1)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; np.ndarray\n</code></pre> <p>Get state as osculating Keplerian elements at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements [a, e, i, raan, argp, M]</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_cart = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_cart)\n\n# Get osculating elements in degrees\nelements = traj.state_as_osculating_elements(epc, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements[0]/1000:.2f} km\")\nprint(f\"Inclination: {elements[2]:.2f} degrees\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; np.ndarray\n</code></pre> <p>Get the state vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to retrieve</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get state at index\nstate_0 = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Get state in ECEF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECEF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_eci = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_eci)\n\n# Get ECEF state (automatically converted from ECI)\nstate_ecef = traj.state_ecef(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Get state in ECI Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECI Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory in any frame/representation\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 98.0, 15.0, 30.0, 45.0])\ntraj.add(epc, oe)\n\n# Get ECI Cartesian state (automatically converted from Keplerian)\nstate_eci = traj.state_eci(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array of states with shape (6, N) where N is the number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nstates_array = traj.states()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 3600.0, state)\nprint(f\"Timespan: {traj.timespan()} seconds\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_ecef","title":"to_ecef  <code>method descriptor</code>","text":"<pre><code>to_ecef() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECEF (Earth-Centered Earth-Fixed) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECEF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_ecef = traj.to_ecef()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eci","title":"to_eci  <code>method descriptor</code>","text":"<pre><code>to_eci() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECI (Earth-Centered Inertial) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\ntraj.add(epc, state)\ntraj_eci = traj.to_eci()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_keplerian","title":"to_keplerian  <code>method descriptor</code>","text":"<pre><code>to_keplerian(angle_format: AngleFormat) -&gt; OrbitTrajectory\n</code></pre> <p>Convert to Keplerian representation in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for the result (Radians or Degrees)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Keplerian representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_kep = traj.to_keplerian(bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Convert trajectory to matrix representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array with shape (6, N) where N is number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nmatrix = traj.to_matrix()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#overview","title":"Overview","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that stores states in a specific reference frame (ECI or ECEF) and can automatically transform between frames when querying.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Frame-aware storage (ECI or ECEF) - Automatic frame transformations on query - Built on STrajectory6 (6D states only) - Same performance as STrajectory6</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#creating-with-frame","title":"Creating with Frame","text":"<pre><code>import brahe as bh\n\n# ECI frame trajectory\ntraj_eci = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# ECEF frame trajectory\ntraj_ecef = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECEF)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Propagate and store states in ECI\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Add states\nfor i in range(100):\n    t = epoch + i * 60.0\n    state_eci = prop.propagate(t)\n    traj.add(t, state_eci)\n\n# States are stored and retrieved in ECI\nquery_epoch = epoch + 1800.0\nstate = traj.interpolate(query_epoch)  # ECI frame\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#frame-information","title":"Frame Information","text":"<pre><code># Get trajectory frame\nframe = traj.frame()  # Returns OrbitFrame.ECI or OrbitFrame.ECEF\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#api","title":"API","text":"<p>OrbitTrajectory has the same API as STrajectory6 and DTrajectory, plus frame awareness.</p> <p>See STrajectory6 or DTrajectory for full API documentation.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Non-frame-aware 6D trajectory</li> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitFrame - Frame specifications</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory container optimized for orbital state vectors.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6","title":"STrajectory6","text":"<pre><code>STrajectory6()\n</code></pre> <p>Static-dimension 6D trajectory container.</p> <p>Stores a sequence of 6-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is fixed at compile time for performance.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Static-dimension 6D trajectory container.\\n\\nStores a sequence of 6-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is fixed\\nat compile time for performance.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.end_epoch","title":"end_epoch  <code>property</code>","text":"<pre><code>end_epoch: Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolation_method","title":"interpolation_method  <code>property</code>","text":"<pre><code>interpolation_method: InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.start_epoch","title":"start_epoch  <code>property</code>","text":"<pre><code>start_epoch: Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.time_span","title":"time_span  <code>property</code>","text":"<pre><code>time_span: float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; STrajectory6\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6D state vectors with total length N*6 where N is the number of epochs</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>New 6D trajectory instance populated with data</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstates = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0,\n                   bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj = bh.STrajectory6.from_data([epc1, epc2], states)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; np.ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; np.ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; np.ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; STrajectory6\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#overview","title":"Overview","text":"<p><code>STrajectory6</code> is a trajectory container optimized for 6-dimensional state vectors [x, y, z, vx, vy, vz]. The dimension is fixed at compile time, providing better performance than DTrajectory for orbital mechanics applications.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Use When: - Storing orbital state vectors (position + velocity) - Performance is critical - Dimension is always 6</p> <p>Advantages over DTrajectory: - Faster operations (no runtime dimension checks) - More memory efficient - Same API for state management</p>"},{"location":"library_api/trajectories/strajectory6.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\ntraj = bh.STrajectory6(\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n\n# Add states from propagation\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop = bh.KeplerianPropagator(...)\n\nfor i in range(1000):\n    t = epoch + i * 60.0  # Every minute\n    state = prop.propagate(t)  # Returns [x,y,z,vx,vy,vz]\n    traj.add(t, state)\n\n# Query with interpolation\nquery_time = epoch + 1800.0\ninterp_state = traj.interpolate(query_time)\n\nprint(f\"Position: {interp_state[:3]} m\")\nprint(f\"Velocity: {interp_state[3:]} m/s\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#api","title":"API","text":"<p>STrajectory6 has the same methods as DTrajectory: - <code>add()</code>, <code>interpolate()</code>, <code>state()</code>, <code>epoch()</code> - <code>first()</code>, <code>last()</code>, <code>len()</code>, <code>is_empty()</code> - <code>set_eviction_policy_*()</code>, <code>set_interpolation_method()</code> - <code>to_matrix()</code>, <code>to_epochs()</code>, <code>clear()</code></p> <p>See DTrajectory for detailed API documentation.</p>"},{"location":"library_api/trajectories/strajectory6.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> </ul>"}]}