{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Brahe","text":"<p> Brahe - Practical Astrodynamics </p> <p> </p> <p>Documentation: https://duncaneddy.github.io/brahe/latest</p> <p>Rust Library Reference: https://docs.rs/crate/brahe/latest</p> <p>Source Code: https://github.com/duncaneddy/brahe</p>"},{"location":"index.html#brahe","title":"Brahe","text":"<p>Brahe is a modern satellite dynamics library for research and engineering applications. It is designed to be easy-to-learn, quick-to-deploy, and easy to build on. The north-star of the development is enabling users to solve meaningful problems quickly and correctly.</p> <p>Brahe is permissively licensed under an MIT License to encourage enable people to use and build on the work without worrying about licensing restrictions. We want people to be able to stop reinventing the astrodynamics wheel because commercial licenses are expensive, or open-source options are hard to use or incomplete.</p> <p>Finally, we also try to make the software library easy to understand and extend. Many astrodynamics libraries are written in a way that makes them hard to read, understand, or modify. Brahe is written in a modern style with an emphasis on code clarity and modularity to make it easier to understand how algorithms are implemented and to make it easier to extend the library to support new use-cases. This also has the added benefit of making it easier to verify and validate the correctness of the implementation.</p> <p>If you do find this useful, please consider starring the repository on GitHub to help increase its visibility. If you're using Brahe for school, research, a commercial endeavour, or flying a mission. I'd love to know about it!</p> <p>If you find a bug, have a feature request, want to contribute, please open an issue or a pull request on the GitHub repository. Contributions are welcome and encouraged! If you see something missing, but don't know how to start contributing, please open an issue and we can discuss it. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p> <p>We hope you find Brahe useful for your work!</p>"},{"location":"index.html#going-further","title":"Going Further","text":"<p>If you want to learn more about how to use the package the documentation is structured in the following way:</p> <ul> <li>Learn: Provides short-form documentation of major concepts of the package.</li> <li>Examples: Provides longer-form examples of how-to examples of accomplish common tasks.</li> <li>Python API Reference: Provides detailed reference documentation of the Python API.</li> <li>Rust API Reference: Provides detailed reference documentation of the Rust API.</li> </ul>"},{"location":"index.html#license","title":"License","text":"<p>The project is licensed under the MIT License - see the LICENSE for details.</p> <p>We want to make it easy for people to use and build on the work without worrying about licensing restrictions.</p>"},{"location":"index.html#quick-start","title":"Quick Start","text":""},{"location":"index.html#python","title":"Python","text":"<p>To install the latest release of brahe for Python, simply run:</p> <pre><code>pip install brahe\n</code></pre> <p>You can then import the package in your Python code with:</p> <pre><code>import brahe as bh\n</code></pre> <p>And do something fun like calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>import brahe as bh\n\n# Define the semi-major axis of a low Earth orbit (in meters)\na = bh.constants.R_EARTH + 400e3  # 400 km altitude\n\n# Calculate the orbital period\nT = bh.orbital_period(a)\n\nprint(f\"Orbital Period: {T / 60:.2f} minutes\")\n# Outputs:\n# Orbital Period: 92.56 minutes\n</code></pre> <p>Here are some common operations to get you started:</p> <p>Working with Time: <pre><code>import brahe as bh\n\n# Create an epoch from a specific date and time\nepc = bh.Epoch(2024, 1, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Print as ISO 8601 string\nprint(f\"Epoch in UTC: {epc.isostring()}\")\n# Output:\n# Epoch in UTC: 2024-01-01T12:00:00Z\n\n# Get the Modified Julian Date (MJD) in different time systems\nmjd_tai = epc.mjd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"MJD in TAI: {mjd_tai}\")\n# Output:\n# MJD in TAI: 60310.50042824074\n\n# Get the time as a Julian Date (JD) in GPS time system\njd_gps = epc.jd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"JD in GPS: {jd_gps}\")\n# Output:\n# JD in GPS: 2460311.000208333\n\n# Take the difference between two epochs in different time systems\nepc2 = bh.Epoch(2024, 1, 2, 13, 30, 0.0, time_system=bh.TimeSystem.GPS)\ndelta_seconds = epc2 - epc\nprint(f\"Difference between epochs in seconds: {delta_seconds}\")\n# Output:\n# Difference between epochs in seconds: 91782.0\n\n# Get the epoch as a string in different time systems\nepc_utc = epc2.to_string_as_time_system(bh.TimeSystem.UTC)\nprint(f\"Epoch in GPS: {epc2}\")\nprint(f\"Epoch in UTC: {epc_utc}\")\n# Outputs:\n# Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n# Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n</code></pre></p> <p>Coordinate Transformations: <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize Earth Orientation Parameter data\nbh.initialize_eop()\n\n# Define orbital elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis in meters (700 km altitude)\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in radians\nraan = 15.0  # Right Ascension of Ascending Node in radians\narg_periapsis = 30.0  # Argument of Periapsis in radians\nmean_anomaly = 45.0  # Mean Anomaly\n\n# Create a state vector from orbital elements\nstate_kep = np.array([a, e, i, raan, arg_periapsis, mean_anomaly])\n\n# Convert Keplerian state to ECI coordinates\nstate_eci = bh.state_osculating_to_cartesian(state_kep, bh.AngleFormat.DEGREES)\nprint(f\"ECI Coordinates: {state_eci}\")\n# Outputs:\n# ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Define a time epoch\nepoch = bh.Epoch(2024, 6, 1, 12, 0, 0.0, time_system=bh.TimeSystem.UTC)\n\n# Convert ECI coordinates to ECEF coordinates at the given epoch\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\nprint(f\"ECEF Coordinates: {state_ecef}\")\n# Outputs:\n# ECEF Coordinates: [ 1.86480173e+05 -2.07022599e+06  6.76081548e+06 -4.53886373e+03 5.77702345e+03  1.89973203e+03]\n\n# Convert back from ECEF to ECI coordinates\nstate_eci_2 = bh.state_ecef_to_eci(epoch, state_ecef)\nprint(f\"Recovered ECI Coordinates: {state_eci_2}\")\n# Outputs:\n# Recovered ECI Coordinates: [ 2.02651406e+06 -5.27290081e+05  6.75606709e+06 -6.93198095e+03 -2.16097991e+03  1.91618569e+03]\n\n# Convert back from ECI to Keplerian elements\nstate_kep_2 = bh.state_cartesian_to_osculating(state_eci_2, bh.AngleFormat.DEGREES)\nprint(f\"Recovered Keplerian Elements: {state_kep_2}\")\n# Outputs:\n# Recovered Keplerian Elements: [7.0781363e+06 1.0000000e-03 9.8700000e+01 1.5000000e+01 3.0000000e+01 4.5000000e+01]\n</code></pre> Propagating an Orbit: <pre><code>import numpy as np\nimport brahe as bh\n\n# Define the initial Keplerian elements\na = bh.constants.R_EARTH + 700e3  # Semi-major axis: 700 km altitude\ne = 0.001  # Eccentricity\ni = 98.7  # Inclination in degrees\nraan = 15.0  # Right Ascension of Ascending Node in degrees\nargp = 30.0  # Argument of Perigee in degrees\nmean_anomaly = 75.0  # Mean Anomaly at epoch in degrees\n\ninitial_state = np.array([a, e, i, raan, argp, mean_anomaly])\n\n# Define the epoch time\nepoch = bh.Epoch.now()\n\n# Create the Keplerian Orbit Propagator\ndt = 60.0  # Time step in seconds\npropagator = bh.KeplerianPropagator.from_keplerian(\n    epoch, initial_state, bh.AngleFormat.DEGREES, dt\n)\n\n# Propagate the orbit for 3 time steps\npropagator.propagate_steps(3)\n\n# States are stored as a Trajectory object\nassert len(propagator.trajectory) == 4  # Initial state + 3 propagated states\n\n# Convert trajectory to ECI coordinates\neci_trajectory = propagator.trajectory.to_eci()\n\n# Iterate over all stored states\nfor epoch, state in eci_trajectory:\n    print(\n        f\"Epoch: {epoch}, Position (ECI): {state[0] / 1e3:.2f} km, {state[1] / 1e3:.2f} km, {state[2] / 1e3:.2f} km\"\n    )\n\n# Output:\n# Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n# Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n# Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n# Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n# Propagate for 7 days\nend_epoch = epoch + 86400 * 7  # 7 days later\npropagator.propagate_to(end_epoch)\n\n# Confirm the final epoch is as expected\nassert abs(propagator.current_epoch - end_epoch) &lt; 1e-6\nprint(\"Propagation complete. Final epoch:\", propagator.current_epoch)\n# Output:\n# Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>import brahe as bh\n\n# Initialize EOP\nbh.initialize_eop()\n\n# Set the location\nlocation = bh.PointLocation(-122.4194, 37.7749, 0.0).with_name(\"San Francisco\")\n\n# Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\npropagator = bh.datasets.celestrak.get_tle_by_id_as_propagator(25544, 60.0)\n\n# Configure Search Window\nepoch_start = bh.Epoch.now()\nepoch_end = epoch_start + 7 * 86400.0  # 7 days later\n\n# Set access constraints -&gt; Must be above 10 degrees elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access windows\nwindows = bh.location_accesses(location, propagator, epoch_start, epoch_end, constraint)\n\nassert len(windows) &gt; 0, \"Should find at least one access window\"\n\n# Print first 3 access windows\nfor window in windows[:3]:\n    print(\n        f\"Access Window: {window.window_open} to {window.window_close}, Duration: {window.duration / 60:.2f} minutes\"\n    )\n# Outputs:\n# Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n# Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n# Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n</code></pre></p>"},{"location":"index.html#rust","title":"Rust","text":"<p>To use brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre> <p>You can then use the crate in your rust code with:</p> <pre><code>use brahe as bh;\n</code></pre> <p>And still calculate the orbital-period of a satellite in low Earth orbit:</p> <pre><code>use brahe::{R_EARTH, orbital_period};\n\nfn main() {\n    // Define the semi-major axis of a low Earth orbit (in meters)\n    let semi_major_axis = R_EARTH + 400e3; // 400 km altitude\n\n    // Calculate the orbital period\n    let period = orbital_period(semi_major_axis); \n\n    println!(\"Orbital Period: {:.2} minutes\", period / 60.0);\n    // Outputs:\n    // Orbital Period: 92.56 minutes\n}\n</code></pre> <p>You can do everything that you can do in Python in Rust as well:</p> <p>Working with Time: <pre><code>use brahe::{Epoch, TimeSystem};\n\nfn main() {\n    // Create an epoch from a specific date and time\n    let epc = Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Print as ISO 8601 string\n    println!(\"Epoch in UTC: {}\", epc.isostring());\n    // Output:\n    // Epoch in UTC: 2024-01-01T12:00:00Z\n\n    // Get the Modified Julian Date (MJD) in different time systems\n    let mjd_tai = epc.mjd_as_time_system(TimeSystem::TAI);\n    println!(\"MJD in TAI: {}\", mjd_tai);\n    // Output:\n    // MJD in TAI: 60310.50042824074\n\n    // Get the time as a Julian Date (JD) in GPS time system\n    let jd_gps = epc.jd_as_time_system(TimeSystem::GPS);\n    println!(\"JD in GPS: {}\", jd_gps);\n    // Output:\n    // JD in GPS: 2460311.000208333\n\n    // Take the difference between two epochs in different time systems\n    let epc2 = Epoch::from_datetime(2024, 1, 2, 13, 30, 0.0, 0.0, TimeSystem::GPS);\n    let delta_seconds = epc2 - epc;\n    println!(\"Difference between epochs in seconds: {}\", delta_seconds);\n    // Output:\n    // Difference between epochs in seconds: 91782.0\n\n    // Get the epoch as a string in different time systems\n    let epc_utc = epc2.to_string_as_time_system(TimeSystem::UTC);\n    println!(\"Epoch in GPS: {}\", epc2);\n    println!(\"Epoch in UTC: {}\", epc_utc);\n    // Outputs:\n    // Epoch in GPS: 2024-01-02 13:30:00.000 GPS\n    // Epoch in UTC: 2024-01-02 13:29:42.000 UTC\n}\n</code></pre></p> <p>Coordinate Transformations: <pre><code>use brahe as bh;\nuse brahe::{Epoch, TimeSystem, R_EARTH, state_osculating_to_cartesian,\n            state_eci_to_ecef, state_ecef_to_eci, state_cartesian_to_osculating, AngleFormat};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Define orbital elements\n    let a = R_EARTH + 700e3;    // Semi-major axis in meters (700 km altitude)\n    let e = 0.001;              // Eccentricity\n    let i = 98.7;               // Inclination in degrees\n    let raan = 15.0;            // Right Ascension of Ascending Node in degrees\n    let arg_periapsis = 30.0;   // Argument of Periapsis in degrees\n    let mean_anomaly = 45.0;    // Mean Anomaly in degrees\n\n    // Create a state vector from orbital elements\n    let state_kep = Vector6::new(a, e, i, raan, arg_periapsis, mean_anomaly);\n\n    // Convert Keplerian state to ECI coordinates\n    let state_eci = state_osculating_to_cartesian(state_kep, AngleFormat::Degrees);\n    println!(\"ECI Coordinates: {:?}\", state_eci);\n    // Outputs:\n    // ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Define a time epoch\n    let epoch = Epoch::from_datetime(2024, 6, 1, 12, 0, 0.0, 0.0, TimeSystem::UTC);\n\n    // Convert ECI coordinates to ECEF coordinates at the given epoch\n    let state_ecef = state_eci_to_ecef(epoch, state_eci);\n    println!(\"ECEF Coordinates: {:?}\", state_ecef);\n    // Outputs:\n    // ECEF Coordinates: [186480.17260881448, -2070225.9929370368, 6760815.482882127, -4538.863726757974, 5777.023453395301, 1899.7320274086795]\n\n    // Convert back from ECEF to ECI coordinates\n    let state_eci_2 = state_ecef_to_eci(epoch, state_ecef);\n    println!(\"Recovered ECI Coordinates: {:?}\", state_eci_2);\n    // Outputs:\n    // Recovered ECI Coordinates: [2026514.0589990876, -527290.0808564089, 6756067.089961103, -6931.980949848838, -2160.9799111629056, 1916.1856855691967]\n\n    // Convert back from ECI to Keplerian elements\n    let state_kep_2 = state_cartesian_to_osculating(state_eci_2, AngleFormat::Degrees);\n    println!(\"Recovered Keplerian Elements: {:?}\", state_kep_2);\n    // Outputs:\n    // Recovered Keplerian Elements: [7078136.3, 0.001, 98.7, 15.0, 30.0, 45.0]\n}\n</code></pre></p> <p>Propagating an Orbit: <pre><code>use brahe as bh;\nuse brahe::{Epoch, R_EARTH, KeplerianPropagator, AngleFormat};\nuse brahe::traits::{OrbitPropagator, OrbitalTrajectory, Trajectory};\nuse nalgebra::Vector6;\n\nfn main() {\n    // Define the initial Keplerian elements\n    let a = R_EARTH + 700e3;  // Semi-major axis: 700 km altitude\n    let e = 0.001;            // Eccentricity\n    let i = 98.7;             // Inclination in degrees\n    let raan = 15.0;          // Right Ascension of Ascending Node in degrees\n    let argp = 30.0;          // Argument of Perigee in degrees\n    let mean_anomaly = 75.0;  // Mean Anomaly at epoch in degrees\n\n    let initial_state = Vector6::new(a, e, i, raan, argp, mean_anomaly);\n\n    // Define the epoch time\n    let epoch = Epoch::now();\n\n    // Create the Keplerian Orbit Propagator\n    let dt = 60.0;  // Time step in seconds\n    let mut propagator = KeplerianPropagator::from_keplerian(\n        epoch,\n        initial_state,\n        AngleFormat::Degrees,\n        dt\n    );\n\n    // Propagate the orbit for 3 time steps\n    propagator.propagate_steps(3);\n\n    // States are stored as a Trajectory object\n    assert_eq!(propagator.trajectory.len(), 4);  // Initial state + 3 propagated states\n\n    // Convert trajectory to ECI coordinates\n    let eci_trajectory = propagator.trajectory.to_eci();\n\n    // Iterate over all stored states\n    for i in 0..eci_trajectory.len() {\n        let epoch = eci_trajectory.epochs[i];\n        let state = eci_trajectory.states[i];\n        println!(\n            \"Epoch: {}, Position (ECI): {:.2} km, {:.2} km, {:.2} km\",\n            epoch,\n            state[0] / 1e3,\n            state[1] / 1e3,\n            state[2] / 1e3\n        );\n    }\n    // Output (will vary based on current time):\n    // Epoch: 2025-10-24 22:14:56.707 UTC, Position (ECI): -1514.38 km, -1475.59 km, 6753.03 km\n    // Epoch: 2025-10-24 22:15:56.707 UTC, Position (ECI): -1935.70 km, -1568.01 km, 6623.80 km\n    // Epoch: 2025-10-24 22:16:56.707 UTC, Position (ECI): -2349.19 km, -1654.08 km, 6467.76 km\n    // Epoch: 2025-10-24 22:17:56.707 UTC, Position (ECI): -2753.17 km, -1733.46 km, 6285.55 km\n\n    // Propagate for 7 days\n    let end_epoch = epoch + 86400.0 * 7.0;  // 7 days later\n    propagator.propagate_to(end_epoch);\n\n    // Confirm the final epoch is close to expected time\n    let time_diff = (propagator.current_epoch() - end_epoch).abs();\n    assert!(time_diff &lt; 1.0e-6, \"Final epoch should be within 1 second of target\");\n    println!(\"Propagation complete. Final epoch: {}\", propagator.current_epoch());\n    // Output (will vary based on current time):\n    // Propagation complete. Final epoch: 2025-10-31 22:18:40.413 UTC\n}\n</code></pre></p> <p>Computing ISS Access Windows: <pre><code>use brahe as bh;\nuse brahe::{Epoch, PointLocation, ElevationConstraint, location_accesses};\nuse brahe::datasets::celestrak::get_tle_by_id_as_propagator;\nuse brahe::utils::Identifiable;\n\nfn main() {\n    // Initialize EOP\n    bh::initialize_eop().unwrap();\n\n    // Set the location\n    let location = PointLocation::new(-122.4194, 37.7749, 0.0)\n        .with_name(\"San Francisco\");\n\n    // Get the latest TLE for the ISS (NORAD ID 25544) from Celestrak\n    let propagator = get_tle_by_id_as_propagator(25544, None, 60.0).unwrap();\n\n    // Configure Search Window\n    let epoch_start = Epoch::now();\n    let epoch_end = epoch_start + 7.0 * 86400.0;  // 7 days later\n\n    // Set access constraints -&gt; Must be above 10 degrees elevation\n    let constraint = ElevationConstraint::new(Some(10.0), None).unwrap();\n\n    // Compute access windows\n    let windows = location_accesses(\n        &amp;location,\n        &amp;propagator,\n        epoch_start,\n        epoch_end,\n        &amp;constraint,\n        None,\n        None,\n        None\n    );\n\n    assert!(!windows.is_empty(), \"Should find at least one access window\");\n\n    // Print first 3 access windows\n    for window in windows.iter().take(3) {\n        println!(\n            \"Access Window: {} to {}, Duration: {:.2} minutes\",\n            window.window_open,\n            window.window_close,\n            window.duration() / 60.0\n        );\n    }\n    // Outputs (will vary based on current time and ISS orbit):\n    // Access Window: 2025-10-25 08:49:40.062 UTC to 2025-10-25 08:53:48.463 UTC, Duration: 4.14 minutes\n    // Access Window: 2025-10-25 10:25:40.245 UTC to 2025-10-25 10:31:48.463 UTC, Duration: 6.14 minutes\n    // Access Window: 2025-10-25 12:05:33.455 UTC to 2025-10-25 12:06:48.463 UTC, Duration: 1.25 minutes\n}\n</code></pre></p>"},{"location":"code_of_conduct.html","title":"Contributor Covenant 3.0 Code of Conduct","text":""},{"location":"code_of_conduct.html#our-pledge","title":"Our Pledge","text":"<p>We pledge to make our community welcoming, safe, and equitable for all.</p> <p>Space has inspired us and continues to inspire the whole world. We are building software to help everyone on this planet explore the universe - regardless of race, creed, or any other distinction. We encourage you to bring your unique perspective to help make us stronger, including those who are traditionally underrepresented in tech. We seek to build a highly collaborative, respectful, inclusive, and curious community. We appreciate contributions from everyone, no prior space experience is needed to participate. We joyously welcome everyone who is excited about tackling seemingly impossible challenges, learning new skills and concepts, and helping each other achieve success.</p> <p>We are committed to fostering an environment that respects and promotes the dignity, rights, and contributions of all individuals, regardless of characteristics including race, ethnicity, caste, color, age, physical characteristics, neurodiversity, disability, sex or gender, gender identity or expression, sexual orientation, language, philosophy or religion, national or social origin, socio-economic position, level of education, or other status. The same privileges of participation are extended to everyone who participates in good faith and in accordance with this Covenant.</p>"},{"location":"code_of_conduct.html#encouraged-behaviors","title":"Encouraged Behaviors","text":"<p>While acknowledging differences in social norms, we all strive to meet our community's expectations for positive behavior. We also understand that our words and actions may be interpreted differently than we intend based on culture, background, or native language.</p> <p>With these considerations in mind, we agree to behave mindfully toward each other and act in ways that center our shared values, including:</p> <ol> <li>Respecting the purpose of our community, our activities, and our ways of gathering.</li> <li>Engaging kindly and honestly with others.</li> <li>Respecting different viewpoints and experiences.</li> <li>Gracefully giving and accepting constructive feedback.</li> <li>Taking responsibility for our actions and contributions.</li> <li>Committing to repairing harm when it occurs.</li> <li>Behaving in other ways that promote and sustain the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#restricted-behaviors","title":"Restricted Behaviors","text":"<p>We agree to restrict the following behaviors in our community. Instances, threats, and promotion of these behaviors are violations of this Code of Conduct.</p> <ol> <li>Harassment. Violating explicitly expressed boundaries or engaging in unnecessary personal attention after any clear request to stop.</li> <li>Character attacks. Making insulting, demeaning, or pejorative comments directed at a community member or group of people.</li> <li>Stereotyping or discrimination. Characterizing anyone\u2019s personality or behavior on the basis of immutable identities or traits.</li> <li>Sexualization. Behaving in a way that would generally be considered inappropriately intimate in the context or purpose of the community.</li> <li>Violating confidentiality. Sharing or acting on someone's personal or private information without their permission.</li> <li>Endangerment. Causing, encouraging, or threatening violence or other harm toward any person or group.</li> <li>Behaving in other ways that threaten the well-being of our community.</li> </ol>"},{"location":"code_of_conduct.html#other-restrictions","title":"Other Restrictions","text":"<ol> <li>Misleading identity. Impersonating someone else for any reason, or pretending to be someone else to evade enforcement actions.</li> <li>Failing to credit sources. Not properly crediting the sources of content you contribute.</li> <li>Promotional materials. Sharing marketing or other commercial content in a way that is outside the norms of the community.</li> <li>Irresponsible communication. Failing to responsibly present content which includes, links or describes any other restricted behaviors.</li> </ol>"},{"location":"code_of_conduct.html#reporting-an-issue","title":"Reporting an Issue","text":"<p>Tensions can occur between community members even when they are trying their best to collaborate. Not every conflict represents a code of conduct violation, and this Code of Conduct reinforces encouraged behaviors and norms that can help avoid conflicts and minimize harm.</p> <p>When an incident does occur, it is important to report it promptly. To report a possible violation, directly contact the repository owner, maintainers, or community moderators at: <code>duncan [send-email-symbol] argoinnovations.com</code>.</p> <p>We take reports of violations seriously and will make every effort to respond in a timely manner. We will investigate all reports of code of conduct violations, reviewing messages, logs, and recordings, or interviewing witnesses and other participants. We prioritize safety and confidentiality, while also trying to keep enforcement actions as transparent as possible. In order to honor these values, enforcement actions are carried out in private with the involved parties, but reserve the right to publicly share the outcome of enforcement actions when appropriate for the safety and well-being of the community as a whole.</p>"},{"location":"code_of_conduct.html#addressing-and-repairing-harm","title":"Addressing and Repairing Harm","text":"<p>If an investigation by the Community Moderators finds that this Code of Conduct has been violated, the following enforcement ladder may be used to determine how best to repair harm, based on the incident's impact on the individuals involved and the community as a whole. Depending on the severity of a violation, lower rungs on the ladder may be skipped.</p> <p>1) Warning    1) Event: A violation involving a single incident or series of incidents.    2) Consequence: A private, written warning from the Community Moderators.    3) Repair: Examples of repair include a private written apology, acknowledgement of responsibility, and seeking clarification on expectations. 2) Temporarily Limited Activities    1) Event: A repeated incidence of a violation that previously resulted in a warning, or the first incidence of a more serious violation.    2) Consequence: A private, written warning with a time-limited cooldown period designed to underscore the seriousness of the situation and give the community members involved time to process the incident. The cooldown period may be limited to particular communication channels or interactions with particular community members.    3) Repair: Examples of repair may include making an apology, using the cooldown period to reflect on actions and impact, and being thoughtful about re-entering community spaces after the period is over. 3) Temporary Suspension    1) Event: A pattern of repeated violation which the Community Moderators have tried to address with warnings, or a single serious violation.    2) Consequence: A private written warning with conditions for return from suspension. In general, temporary suspensions give the person being suspended time to reflect upon their behavior and possible corrective actions.    3) Repair: Examples of repair include respecting the spirit of the suspension, meeting the specified conditions for return, and being thoughtful about how to reintegrate with the community when the suspension is lifted. 4) Permanent Ban    1) Event: A pattern of repeated code of conduct violations that other steps on the ladder have failed to resolve, or a violation so serious that the Community Moderators determine there is no way to keep the community safe with this person as a member.    2) Consequence: Access to all community spaces, tools, and communication channels is removed. In general, permanent bans should be rarely used, should have strong reasoning behind them, and should only be resorted to if working through other remedies has failed to change the behavior.    3) Repair: There is no possible repair in cases of this severity.</p> <p>This enforcement ladder is intended as a guideline. It does not limit the ability of Community Managers to use their discretion and judgment, in keeping with the best interests of our community.</p>"},{"location":"code_of_conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public or other spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 3.0, permanently available at https://www.contributor-covenant.org/version/3/0/.</p>"},{"location":"contributing.html","title":"Contributing to Brahe","text":"<p>Thank you for your interest in contributing to Brahe! We welcome contributions from everyone\u2014whether you're improving documentation, fixing bugs, or adding new features. We are building software to help everyone on this planet explore the universe. We encourage you to bring your unique perspective to help make us stronger. We appreciate contributions from everyone, no prior space experience is needed to participate.</p> <p>Checkout the main documentation for the Contributing Guidelines and Code of Conduct.</p>"},{"location":"contributing.html#how-you-can-contribute","title":"How you can contribute","text":"<p>You can contribute in many ways, including: - Reporting bugs or issues. - Suggesting enhancements or new features. - Writing or improving documentation or tutorials. - Adding or improving tests. - Reviewing other contributors\u2019 pull requests.</p>"},{"location":"contributing.html#getting-started","title":"Getting Started","text":"<p>First, check out the development guidelines in the developer guidelines for setting up your development environment, running tests, and the development workflow for implementing new features or fixing bugs.</p>"},{"location":"contributing.html#workflow","title":"Workflow","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally: <code>git clone https://github.com/YOUR_USERNAME/brahe.git</code></li> <li>Create a new branch for your changes: <code>git checkout -b feature/your-feature-name</code></li> <li>Make your changes and commit them with clear, descriptive messages.</li> <li>Push your changes to your fork: <code>git push origin feature/your-feature-name</code></li> <li>Open a pull request against the main branch of the upstream repository.</li> <li>A maintainer will review your contribution; you may be asked to make changes.</li> <li>After approval and CI passing, your pull request will be merged.</li> </ol>"},{"location":"contributing.html#code-style-testing","title":"Code Style &amp; Testing","text":"<ul> <li>Follow the project\u2019s style guidelines (e.g., linting, formatting).</li> <li>Include tests for new functionality, and ensure existing tests pass.</li> <li>Ensure that your changes do not break existing behaviour unless they are intentional, documented, well-motivated, complete, and reviewed. We don't break things without a solution.</li> </ul>"},{"location":"contributing.html#communication-etiquette","title":"Communication &amp; Etiquette","text":"<ul> <li>Please review the Code of Conduct to understand the expected behaviour in our community.</li> <li>If you\u2019re planning a large or complex change, consider opening an issue first to discuss design and get early feedback.</li> <li>Be responsive to review comments. If you need time, it\u2019s okay to say so.</li> <li>Respect the maintainers\u2019 decision. If they decline your change, you\u2019re free to discuss politely or move on.</li> </ul>"},{"location":"contributing.html#license-rights","title":"License &amp; Rights","text":"<p>By submitting a pull request, you agree that your contribution will be available under the project's MIT License and you grant the maintainers the right to apply any necessary changes (e.g., rebase, squash) before merging.</p>"},{"location":"contributing.html#thank-you","title":"Thank You","text":"<p>We appreciate your interest and contribution. Together we build something better!</p>"},{"location":"design.html","title":"Design Philosophy &amp; Decisions","text":"<p>This page documents significant design decisions of the library. Right now this is mostly just what I think is \"good design\" for an astrodynamics library, which is highly subjective and somewhat hard to write down concretely. Over time I hope to expand this page to include more specific design decisions made in the library, along with the reasoning behind them.</p>"},{"location":"design.html#rust-core-with-python-bindings","title":"Rust Core with Python Bindings","text":"<p>The core of the library is implemented in Rust for performance and safety, with Python bindings provided for ease of use and accessibility to the Python community. This design choice allows us to leverage Rust's strengths while still providing a user-friendly interface in Python. Providing Python bindings also opens the library to a wider audience, as Python is a popular language in the scientific and engineering communities.</p>"},{"location":"design.html#tightly-coupled-documentation","title":"Tightly Coupled Documentation","text":"<p>The documentation is designed to be tightly coupled with the codebase, ensuring that users have access to up-to-date and relevant information. This is achieved by organizing the documentation in a way that mirrors the structure of the code, and automatically testing code examples within the documentation to ensure sure that documentation cannot be released without it working. This approach helps maintain consistency between the library's functionality and its documentation, making it easier for users to understand and utilize the library effectively.</p>"},{"location":"design.html#earth-centered-focus","title":"Earth-Centered Focus","text":"<p>Currently the library is focused on Earth-centered applications, while extending to other celestial bodies is not ruled out in the future, they are not a design priority. This choice has enabled us to optimize the design of the library API by dropping support for multiple central bodies, simplifying the user experience for the primary use case.</p>"},{"location":"development_guidelines.html","title":"Development Guidelines","text":""},{"location":"development_guidelines.html#development-workflow","title":"Development Workflow","text":"<p>For all development we recommend using uv to manage your environment. The guidelines for contributing, developing, and extending brahe assume you are using uv.</p>"},{"location":"development_guidelines.html#setting-up-your-environment","title":"Setting up your environment","text":"<p>If you need to setup the development environment, including installing the necessary development dependencies.</p> <p>First, you need to install Rust from rustup.rs.</p> <p>Then you can install the nightly toolchain with:</p> <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre> <p>After this you can now setup your python environment with:</p> <pre><code>uv sync --dev\n</code></pre> <p>Finally, you can install the pre-commit hooks with:</p> <pre><code>uv run pre-commit install\n</code></pre>"},{"location":"development_guidelines.html#testing","title":"Testing","text":"<p>The package includes Rust tests, Python tests, and documentation example tests.</p> <p>Run all tests: <pre><code>make test\n</code></pre></p> <p>Individual test suites: <pre><code>make test-rust          # Rust tests only\nmake test-python        # Python tests only\nmake test-examples      # Documentation examples (warn on parity issues)\n</code></pre></p> <p>Pre-ship validation (runs all tests, formatters, linters, and doc builds): <pre><code>make ship-tests\n</code></pre></p>"},{"location":"development_guidelines.html#development-workflow-implementing-a-new-feature","title":"Development Workflow: Implementing a New Feature","text":"<p>When adding new functionality to Brahe, follow this sequence:</p> <p>1. Rust Implementation - Implement functionality in the appropriate module under <code>src/</code> - Use SI base units (meters, radians, seconds) in all public APIs - Follow existing patterns and naming conventions</p> <p>2. Rust Tests - Write comprehensive unit tests in the same file (in <code>#[cfg(test)] mod tests</code>) - Test edge cases and typical use cases - Run: <code>cargo test</code> - Ensure all tests pass before proceeding</p> <p>3. Python Bindings - Create 1:1 Python bindings in <code>src/pymodule/</code> - Use identical function names and parameter names as Rust - Add complete Google-style docstrings with Args, Returns, Examples - Export new classes in <code>src/pymodule/mod.rs</code> - Export in Python package (<code>brahe/*.py</code> files) - Reinstall: <code>uv pip install -e .</code></p> <p>4. Python Tests - Write Python tests that mirror Rust tests in <code>tests/</code> - Follow the same test structure and assertions - Run: <code>uv run pytest tests/ -v</code></p> <p>5. Documentation Examples - Create standalone example files in <code>examples/&lt;module&gt;/</code> - Create both Python and Rust versions (see templates below) - Test: <code>make test-examples</code></p> <p>6. Documentation - Update or create documentation in <code>docs/</code> - Reference examples using snippet includes (see template below) - Build: <code>make build-docs</code> - Preview: <code>make serve-docs</code></p> <p>7. Quality Checks <pre><code>make format      # Auto-format code\nmake lint        # Check for issues\nmake ship-tests  # Full validation\n</code></pre></p>"},{"location":"development_guidelines.html#rust-standards-and-guidelines","title":"Rust Standards and Guidelines","text":""},{"location":"development_guidelines.html#rust-testing-conventions","title":"Rust Testing Conventions","text":"<p>New functions implemented in rust are expected to have unit tests and documentation tests. Unit tests should cover all edge cases and typical use cases for the function. Documentation tests should provide examples of how to use the function.</p> <p>Unit tests should be placed in the same file as the function they are testing, in a module named <code>tests</code>. The names of tests should follow the general convention of <code>test_&lt;struct&gt;_&lt;trait&gt;_&lt;method&gt;_&lt;case&gt;</code> or <code>test_&lt;function&gt;_&lt;case&gt;</code>.</p>"},{"location":"development_guidelines.html#rust-docstring-template","title":"Rust Docstring Template","text":"<p>New functions implemented in rust are expected to use the following docstring to standardize information on functions to enable users to more easily navigate and learn the library.</p> <pre><code>{{ Function Description }}\n\n## Arguments\n\n* `argument_name`: {{ Arugment description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Returns\n\n* `value_name`: {{ Value description}}. Units: {{ Optional, Units as (value). e.g. (rad) or (deg)}}\n\n## Examples\n\\`\\`\\`\n{{ Implement shor function in language }}\n\\`\\`\\`\n\n## References:\n1. {{ author, *title/journal*, pp. page_number, eq. equation_number, year}}\n2. O. Montenbruck, and E. Gill, *Satellite Orbits: Models, Methods and Applications*, pp. 24, eq. 2.43 &amp; 2.44, 2012.\n</code></pre>"},{"location":"development_guidelines.html#python-standards-and-guidelines","title":"Python Standards and Guidelines","text":""},{"location":"development_guidelines.html#python-testing-conventions","title":"Python Testing Conventions","text":"<p>Python tests should be placed in the <code>tests</code> directory. The test structure and names should mirror the structure of the <code>brahe</code> package. For example, tests for <code>brahe.orbits.keplerian</code> should be placed in <code>tests/orbits/test_keplerian.py</code>.</p> <p>All Python tests should be exact mirrors of the Rust tests, ensuring that both implementations are equivalent and consistent. There are a few exceptions to this rule, such as tests that check for Python-specific functionality or behavior, or capabilities that are not possible to reproduce in Python due to language limitations.</p>"},{"location":"development_guidelines.html#documentation-examples","title":"Documentation Examples","text":"<p>Documentation examples are standalone executable files that demonstrate library functionality. Every example must exist in both Python and Rust versions to ensure API parity.</p>"},{"location":"development_guidelines.html#example-file-structure","title":"Example File Structure","text":"<p>Examples are organized by module in <code>examples/</code>: <pre><code>examples/\n\u251c\u2500\u2500 time/           # Time system examples\n\u251c\u2500\u2500 orbits/         # Orbital mechanics examples\n\u251c\u2500\u2500 coordinates/    # Coordinate transformation examples\n\u251c\u2500\u2500 frames/         # Reference frame examples\n\u251c\u2500\u2500 attitude/       # Attitude representation examples\n\u251c\u2500\u2500 eop/            # Earth orientation parameter examples\n\u251c\u2500\u2500 trajectories/   # Trajectory examples\n\u2514\u2500\u2500 workflows/      # Complete workflow examples\n</code></pre></p>"},{"location":"development_guidelines.html#naming-convention","title":"Naming Convention","text":"<p>Example files should follow this pattern: <pre><code>&lt;module&gt;_&lt;functionality&gt;_&lt;description&gt;.{py,rs}\n</code></pre></p> <p>Examples: - <code>time_epoch_creation.py</code> / <code>time_epoch_creation.rs</code> - <code>orbits_keplerian_conversion.py</code> / <code>orbits_keplerian_conversion.rs</code> - <code>coordinates_geodetic_transform.py</code> / <code>coordinates_geodetic_transform.rs</code></p>"},{"location":"development_guidelines.html#python-example-template","title":"Python Example Template","text":"<p>See <code>examples/TEMPLATE.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"pytest\"]\n# ///\n\"\"\"\nBrief description of what this example demonstrates.\n\"\"\"\nimport brahe as bh\nimport pytest\n\nif __name__ == '__main__':\n    # Setup: Define any input parameters\n    value = 1.0\n\n    # Action: Demonstrate the functionality\n    result = value * 2.0  # Replace with actual brahe function call\n\n    # Validation: Assert the result is correct\n    expected = 2.0\n    assert result == pytest.approx(expected, abs=1e-10)\n\n    print(\"\u2713 Example validated successfully!\")\n</code></pre> <p>Note: The <code># /// script</code> header makes this a uv script, allowing it to be run standalone with <code>uv run example.py</code>.</p>"},{"location":"development_guidelines.html#rust-example-template","title":"Rust Example Template","text":"<p>See <code>examples/TEMPLATE.rs</code>:</p> <pre><code>//! Brief description of what this example demonstrates.\n\nuse approx::assert_abs_diff_eq;\nuse brahe::time::{Epoch, TimeSystem};\n\nfn main() {\n    // Setup: Define any input parameters\n    let value = 1.0;\n\n    // Action: Demonstrate the functionality\n    let result = value * 2.0; // Replace with actual brahe function call\n\n    // Validation: Assert the result is correct\n    let expected = 2.0;\n    assert_abs_diff_eq!(result, expected, epsilon = 1e-10);\n\n    println!(\"\u2713 Example validated successfully!\");\n}\n</code></pre>"},{"location":"development_guidelines.html#testing-examples","title":"Testing Examples","text":"<p>Test examples locally: <pre><code>uv run make.py test-examples\n</code></pre></p> <p>The build system will: 1. Execute all <code>.rs</code> files via <code>rust-script</code> 2. Execute all <code>.py</code> files via <code>uv run python</code> 3. Verify every <code>.rs</code> has a matching <code>.py</code> (and vice versa) 4. Report pass/fail for each example</p>"},{"location":"development_guidelines.html#including-examples-in-documentation","title":"Including Examples in Documentation","text":"<p>Use the <code>pymdownx.snippets</code> directive to include examples in markdown files. See the snippets plugin documentation for additional details on usage.</p> <pre><code>## Example: Creating Epochs\n\n=== \"Python\"\n\n    ``` python\n    ```\n\n=== \"Rust\"\n\n    ``` rust\n    ```\n</code></pre> <p>This will: - Create tabbed interface with Python shown first - Include the actual file contents (always in sync) - Automatically update when examples change</p>"},{"location":"development_guidelines.html#documentation-plots","title":"Documentation Plots","text":"<p>Interactive plots are generated from Python scripts in <code>plots/</code> and embedded in documentation.</p>"},{"location":"development_guidelines.html#plot-naming-convention","title":"Plot Naming Convention","text":"<p>Plot files should follow this pattern: <pre><code>fig_&lt;description&gt;.py\n</code></pre></p> <p>Examples: - <code>fig_time_system_offsets.py</code> - <code>fig_orbital_period.py</code> - <code>fig_anomaly_conversions.py</code></p>"},{"location":"development_guidelines.html#plot-template","title":"Plot Template","text":"<p>See <code>plots/TEMPLATE_plot.py</code>:</p> <pre><code># /// script\n# dependencies = [\"brahe\", \"plotly\", \"numpy\"]\n# ///\n\"\"\"\nBrief description of what this plot visualizes.\n\"\"\"\nimport os\nimport pathlib\nimport plotly.graph_objects as go\nimport plotly.io as pio\nimport brahe as bh\nimport numpy as np\n\n# Configuration\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\")\nOUTFILE = f\"{OUTDIR}/{SCRIPT_NAME}.html\"\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# Generate data\nx = np.linspace(0, 10, 100)\ny = np.sin(x)  # Replace with actual data\n\n# Create figure\nfig = go.Figure()\nfig.update_layout(\n    title=\"Plot Title\",\n    xaxis_title=\"X Axis Label\",\n    yaxis_title=\"Y Axis Label\",\n    paper_bgcolor='rgba(0,0,0,0)',  # Transparent for dark mode\n    plot_bgcolor='rgba(0,0,0,0)'\n)\n\n# Add traces\nfig.add_trace(go.Scatter(x=x, y=y, name=\"Data\", mode='lines'))\n\n# Write HTML (partial, not full page)\npio.write_html(\n    fig,\n    file=OUTFILE,\n    include_plotlyjs='cdn',\n    full_html=False,\n    auto_play=False\n)\n\nprint(f\"\u2713 Generated {OUTFILE}\")\n</code></pre> <p>Note: The <code># /// script</code> header allows standalone execution with <code>uv run fig_plot.py</code>.</p>"},{"location":"development_guidelines.html#generating-plots","title":"Generating Plots","text":"<p>Generate all plots: <pre><code>uv run make.py make-plots\n</code></pre></p> <p>Plots are written to <code>docs/figures/</code> as partial HTML files for embedding.</p>"},{"location":"development_guidelines.html#including-plots-in-documentation","title":"Including Plots in Documentation","text":"<pre><code>## Time System Offsets\n\nThe following plot shows time system offsets from UTC:\n\n\n??? \"Plot Source\"\n\n    ``` python title=\"fig_time_system_offsets.py\"\n    ```\n</code></pre> <p>This will: - Embed the interactive Plotly plot - Add a collapsible section showing the source code</p>"},{"location":"installation.html","title":"Installation","text":"<p>Brahe is available for both Python and Rust. Choose the installation method that best fits your workflow.</p>"},{"location":"installation.html#python-installation","title":"Python Installation","text":""},{"location":"installation.html#using-pip-recommended","title":"Using pip (Recommended)","text":"<p>The simplest way to install Brahe is using pip from PyPI:</p> <pre><code>pip install brahe\n</code></pre> <p>This will install the latest stable release of Brahe and all required dependencies.</p>"},{"location":"installation.html#optional-dependencies","title":"Optional Dependencies","text":"<p>Brahe includes optional dependencies for enhanced plotting capabilities:</p> <pre><code># Install with scienceplots for publication-quality plots\npip install brahe[plots]\n</code></pre>"},{"location":"installation.html#using-uv-fast-alternative","title":"Using uv (Fast Alternative)","text":"<p>uv is a fast Python package installer. To install Brahe with uv:</p> <pre><code># Install brahe\nuv pip install brahe\n\n# Or with optional plot dependencies\nuv pip install \"brahe[plots]\"\n</code></pre>"},{"location":"installation.html#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that Brahe is working correctly:</p> <pre><code>import brahe as bh\nprint(bh.__version__)\n\n# Test basic functionality\na = bh.R_EARTH + 500e3  # Semi-major axis for 500 km altitude\nT = bh.orbital_period(a)\nprint(f\"Orbital period: {T/60:.2f} minutes\")\n</code></pre>"},{"location":"installation.html#building-from-source-python","title":"Building from Source (Python)","text":"<p>If you want to build Brahe from source (e.g., for development or to use unreleased features), follow these steps:</p>"},{"location":"installation.html#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Rust toolchain (required for building the native extensions):    <pre><code># Install Rust using rustup\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# Follow the prompts, then restart your shell\n# Verify installation\nrustc --version\ncargo --version\n</code></pre></p> </li> <li> <p>Configure Rust to Use Nightly:    <pre><code>rustup toolchain install nightly\nrustup default nightly\n</code></pre></p> </li> <li> <p>Python 3.9+ with development headers:    <pre><code># On Ubuntu/Debian\nsudo apt-get install python3-dev\n\n# On macOS (usually included with Python)\n# On Windows, ensure you have Python from python.org\n</code></pre></p> </li> </ol>"},{"location":"installation.html#building-with-uv-recommended","title":"Building with uv (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Install uv if you haven't already\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Sync dependencies and create virtual environment\nuv sync\n\n# Build and install in editable mode\nuv pip install -e .\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre>"},{"location":"installation.html#building-with-pip-and-maturin","title":"Building with pip and maturin","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Create and activate a virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n\n# Install maturin (the build tool for PyO3)\npip install maturin\n\n# Build and install in development mode\nmaturin develop --release\n\n# Or install normally\npip install -e .\n</code></pre>"},{"location":"installation.html#development-installation","title":"Development Installation","text":"<p>For development work, install with development dependencies:</p> <pre><code># With uv\nuv sync --dev\n\n# With pip\npip install -e \".[dev]\"\n</code></pre> <p>This includes tools for: - Testing (pytest, pytest-cov) - Documentation (mkdocs, mkdocstrings) - Code quality (ruff, pre-commit) - Type stubs generation (pyo3-stubgen)</p>"},{"location":"installation.html#running-tests","title":"Running Tests","text":"<p>After building from source, verify everything works:</p> <pre><code># Run Python tests\npytest tests/ -v\n\n# Run Rust tests\ncargo test\n\n# Run with code coverage\npytest tests/ --cov=brahe --cov-report=html\n</code></pre>"},{"location":"installation.html#updating-type-stubs","title":"Updating Type Stubs","text":"<p>If you modify the Rust Python bindings, regenerate Python type stubs:</p> <pre><code>./scripts/generate_stubs.sh\n</code></pre>"},{"location":"installation.html#rust-installation","title":"Rust Installation","text":"<p>To use Brahe in your Rust project, add it to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nbrahe = \"0.5\"\n</code></pre>"},{"location":"installation.html#building-the-rust-library","title":"Building the Rust Library","text":"<pre><code># Clone the repository\ngit clone https://github.com/duncaneddy/brahe.git\ncd brahe\n\n# Build the library\ncargo build\n\n# Run tests\ncargo test\n\n# Build documentation\ncargo doc --open\n</code></pre>"},{"location":"installation.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation.html#common-issues","title":"Common Issues","text":"<p>\"Failed to build wheel\" (Python) - Ensure Rust is installed: <code>rustc --version</code> - Update Rust: <code>rustup update</code> - Install Python development headers (see prerequisites above)</p> <p>Import errors after installation - Verify installation: <code>pip show brahe</code> - Check Python version: <code>python --version</code> (must be 3.9+) - Try reinstalling: <code>pip install --force-reinstall brahe</code></p> <p>Cartopy installation fails - On Ubuntu/Debian: <code>sudo apt-get install libgeos-dev</code> - On macOS: <code>brew install geos</code> - See Cartopy installation docs</p> <p>Type hints not working in IDE - Ensure type stubs are installed: <code>ls $(python -c \"import brahe; print(brahe.__path__[0])\")/_brahe.pyi</code> - If missing, regenerate: <code>./scripts/generate_stubs.sh</code> (from source installation)</p>"},{"location":"installation.html#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the GitHub Issues for similar problems</li> <li>Review the documentation</li> <li>Open a new issue with:</li> <li>Your operating system and version</li> <li>Python/Rust version</li> <li>Complete error message</li> <li>Steps to reproduce</li> </ol>"},{"location":"installation.html#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"installation.html#macos","title":"macOS","text":"<p>On Apple Silicon (M1/M2/M3): - Brahe builds natively for ARM64 - Ensure you have the ARM64 version of Python</p>"},{"location":"installation.html#windows","title":"Windows","text":"<ul> <li>Install Microsoft C++ Build Tools</li> <li>Consider using WSL2 for a smoother development experience</li> </ul>"},{"location":"installation.html#linux","title":"Linux","text":"<p>Most distributions work out-of-the-box. If you encounter issues: - Install build essentials: <code>sudo apt-get install build-essential</code> - Ensure GEOS library is installed for Cartopy</p>"},{"location":"license.html","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019-2025 Duncan Eddy</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"examples/doppler_complementation.html","title":"Calculating Doppler Compensation","text":"<p>Coming Soon</p> <p>This example is under development. Check back soon for details on calculating Doppler compensation for satellite communications.</p>"},{"location":"examples/doppler_complementation.html#overview","title":"Overview","text":"<p>This example will demonstrate how to calculate Doppler shift and compensation for satellite ground station communications.</p>"},{"location":"examples/downloading_tle_data.html","title":"Downloading TLE Data","text":"<p>Coming Soon</p> <p>This example is under development. Check back soon for details on downloading TLE data from CelesTrak.</p>"},{"location":"examples/downloading_tle_data.html#overview","title":"Overview","text":"<p>This example will demonstrate how to download Two-Line Element (TLE) data from various sources including CelesTrak.</p>"},{"location":"examples/downloading_tle_data.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak Dataset</li> <li>Two-Line Elements</li> </ul>"},{"location":"examples/ground_contacts.html","title":"Predicting Ground Contacts","text":"<p>Coming Soon</p> <p>This example is under development. Check back soon for details on predicting satellite ground station contacts.</p>"},{"location":"examples/ground_contacts.html#overview","title":"Overview","text":"<p>This example will demonstrate how to predict when a satellite will be visible from a ground station.</p>"},{"location":"examples/ground_contacts.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Locations</li> <li>Constraints</li> </ul>"},{"location":"examples/imaging_opportunities.html","title":"Computing Imaging Opportunities","text":"<p>Coming Soon</p> <p>This example is under development. Check back soon for details on computing imaging opportunities.</p>"},{"location":"examples/imaging_opportunities.html#overview","title":"Overview","text":"<p>This example will demonstrate how to compute when a satellite can image a specific target location on Earth.</p>"},{"location":"examples/imaging_opportunities.html#see-also","title":"See Also","text":"<ul> <li>Access Computation</li> <li>Constraints</li> </ul>"},{"location":"examples/visualizing_orbital_trajectories.html","title":"Visualizing Orbital Trajectories","text":"<p>Coming Soon</p> <p>This example is under development. Check back soon for details on visualizing orbital trajectories.</p>"},{"location":"examples/visualizing_orbital_trajectories.html#overview","title":"Overview","text":"<p>This example will demonstrate how to visualize satellite orbital trajectories using plotting libraries.</p>"},{"location":"examples/visualizing_orbital_trajectories.html#see-also","title":"See Also","text":"<ul> <li>Trajectories</li> <li>Orbit Propagation</li> </ul>"},{"location":"learn/index.html","title":"User Guide","text":"<p>Here you will find the introductory and conceptual documentation for Brahe. This is the main user guide for the package, and is intended to help you get started with using Brahe for your work.</p> <p>Contributions Welcome</p> <p>If you find something missing or unclear in this documentation, particularly feedback on the conceptual flow, how things are introduced or otherwise, please consider contributing! We welcome contributions of all kinds, including:</p> <ul> <li>Reporting issues or suggesting improvements</li> <li>Writing new documentation pages or improving existing ones</li> <li>Adding examples or tutorials</li> <li>Enhancing the codebase with new features or bug fixes</li> </ul> <p>Check out our contributing guide to get started.</p>"},{"location":"learn/index.html#module-structure","title":"Module Structure","text":"<p>The Brahe package is organized into several key modules, each providing providing some core functionality. We can generally think of these modules as falling into four main categories: Foundational Modules, Orbit &amp; Attitude Representations, State Propagation &amp; Dynamics, and Applications. Below is an overview of the main modules and their purposes:</p>"},{"location":"learn/index.html#foundational-modules","title":"Foundational Modules","text":"<p>These modules provide the basic building blocks for the package, including utilities for time handling, constants, and Earth Orientation Parameters (EOP).</p> <ul> <li>Constants: This module contains physical and mathematical constants used throughout the package.</li> <li>Time: This module provides tools for representing and dealing with time. It provides the ubiquitous Epoch class which is the basis for all time handling in Brahe.</li> <li>EOP: This module handles Earth Orientation Parameters, which are essential for accurate coordinate transformations and orbit propagation. An Earth Orientation Provider is required for many operations in Brahe. There are multiple kinds provided, but <code>initialize_eop()</code> is the easiest way to get started.</li> </ul>"},{"location":"learn/index.html#orbit-attitude-representations","title":"Orbit &amp; Attitude Representations","text":"<p>These modules help transform between different state and coordinate representations for both spacecraft orbits (position and velocity) and attitudes (orientation).</p> <ul> <li>Coordinates: This module provides functions to convert between different coordinate systems, such as Cartesian, Geocentric, Geodetic, and Topocentric coordinates.</li> <li>Frames: This module deals with reference frames, including Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) frames, and provides rotation matrices and state transformations between them.</li> <li>Orbits: This module provides functions for working with orbital elements, including conversions between Keplerian elements and Cartesian states, as well as handling special orbit types like Sun-synchronous orbits and Two-Line Elements (TLEs).</li> <li>Attitude: This module provides tools for representing and manipulating spacecraft attitudes using rotation matrices, quaternions, Euler angles, and Euler axes.</li> </ul>"},{"location":"learn/index.html#state-propagation-dynamics","title":"State Propagation &amp; Dynamics","text":"<p>These modules focus on propagating spacecraft states over time using various dynamics models. It also provides methods for representing these state trajectories.</p> <ul> <li>Trajectories: This module defines traits and structures for representing dynamics trajectories, including orbit trajectories.</li> <li>Keplerian Propagator: This module implements a simple Keplerian propagator for orbit propagation based on Kepler's laws.</li> <li>SGP Propagator: This module implements the SGP (Simplified General Perturbations) propagator, a widely used method for propagating Earth-orbiting satellites, in particular those defined by TLEs.</li> <li>Orbit Dynamics: This module implements various force models used in orbit propagation, such as gravity, drag, solar radiation pressure, and more.</li> </ul>"},{"location":"learn/index.html#applications","title":"Applications","text":"<p>These modules provide higher-level functionalities for specific applications, such as working with datasets, computing access windows, and plotting.</p> <ul> <li>Datasets: This module provides access to common datasets used in space applications, such as ground stations and satellite ephemeris catalogs (e.g., Celestrak).</li> <li>Access Computation: This module provides tools for computing access windows between satellites and terrestrial locations, including defining access constraints and computing access properties.</li> <li>Plotting: This module offers functions for visualizing satellite data, including ground tracks, state vectors, orbital elements, and access geometry.</li> </ul> <p>Each of these modules are defined to have composable, interoperable interfaces so that you can easily combine functionality from different modules to accomplish your tasks. As you explore the documentation further, you'll find detailed explanations and examples for each module to help you understand how to use them effectively.</p> <p>For detailed information on all functions, classes, and methods available in each module, please refer to the Python API Reference and Rust API Reference.</p>"},{"location":"learn/constants.html","title":"Constants","text":"<p>The Constants module provides frequently occuring fundamental mathematical  and astronomical constants.</p>"},{"location":"learn/constants.html#mathematical","title":"Mathematical","text":"<p>Mathematical constants provide quick-reference to common factors.</p> Constant Description <code>DEG2RAD</code> Factor to convert from degrees and radians. <code>RAD2DEG</code> Factor to convert from radians to degrees. <code>AS2RAD</code> Factor to convert from arc-seconds to radians. <code>RAD2AS</code> Factor to convert from radians to arc-seconds."},{"location":"learn/constants.html#time","title":"Time","text":"<p>Time constants are used for conversions between different time systems.</p> Constant Description Value Units Source <code>MJD_ZERO</code> Offset between Modified Julian Date and Julian Date time scales. $t_{mjd} + {mjd}{0} = t{jd $ \\(2400000.5\\) Days Montenbruck and Gill <sup>1</sup> <code>MJD2000</code> Modified Julian date of J2000 Epoch. January 1, 2000 12:00:00. \\(51544.5\\) Days Montenbruck and Gill <sup>1</sup> <code>GPS_TAI</code> Constant offset from TAI to GPS time scale. \\(t_{gps} = t_{tai} + \\Delta_{GPS-TAI}\\) \\(19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_GPS</code> Constant offset from GPS to TAI time scale. \\(t_{tai} = t_{gps}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; + \\Delta_{TAI-GPS}\\) \\(-19.0\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_TAI</code> Constant offset from TT to TAI time scale. \\(t_{tt} = t_{tai} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-TAI}\\) \\(32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TAI_TT</code> Constant offset from TAI to TT time scale. \\(t_{tai} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TAI-TT}\\) \\(-32.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_TT</code> Constant offset from GPS to TT time scale. \\(t_{gps} = t_{tt} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{GPS-TT}\\) \\(-51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>TT_GPS</code> Constant offset from TT to GPS time scale. \\(t_{tt} = t_{gps} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;+ \\Delta_{TT-GPS}\\) \\(51.184\\) \\(s\\) Montenbruck and Gill <sup>1</sup> <code>GPS_ZERO</code> Modified Julian Date of the start of the GPS time scale in the GPS time scale. This date is January 6, 1980 00:00:00 hours reckoned in the UTC time scale \\(44244.0\\) Days Montenbruck and Gill <sup>1</sup>"},{"location":"learn/constants.html#physical-constants","title":"Physical Constants","text":"<p>Physical constants are fundamental physical constants or properties of  astronomical bodies. While these values are estimated they are considered to  be well known and do not change frequently.</p> Constant Description Value Units Source <code>C_LIGHT</code> Speed of light in vacuum. \\(299792458.0\\) \\(\\frac{m}{s}\\) Vallado <sup>2</sup> <code>AU</code> Astronominal Unit. TDB reference frame compatible value equal to the mean distance of the Earth from the Sun. \\(1.49597870700 \\times 10^{11}\\) \\(m\\) G\u00e9rard and Luzum <sup>3</sup> <code>R_EARTH</code> Earth's semi-major axis as defined by the Grace GGM05S gravity model. \\(.378136.3\\) \\(m\\) Ries et al. <sup>4</sup> <code>WGS84_A</code> Earth geoid model's semi-major axis as defined by the World Geodetic System 1984 edition. \\(6378137.0\\) \\(m\\) NIMA Technical Report <sup>5</sup> <code>WGS84_F</code> Earth geoid model's flattening as defined by the World Geodetic System 1984 edition. \\(\\frac{1.0}{298.257223563}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>GM_EARTH</code> Gravitational Constant of the Earth. \\(3.986004415 \\times 10^{14}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>ECC_EARTH</code> Earth geoid model's eccentricity. \\(8.1819190842622 \\times 10^{-2}\\) Dimensionless NIMA Technical Report <sup>5</sup> <code>J2_EARTH</code> Earth's first zonal harmonic. Also known as Earth's oblateness. \\(0.0010826358191967\\) Dimensionless Montenbruck and Gill <sup>1</sup> <code>OMEGA_EARTH</code> Earth's axial rotation rate. \\(7.292115146706979 \\times 10^{-5}\\) \\(\\frac{rad}{s}\\) Vallado <sup>2</sup> <code>GM_SUN</code> Gravitational constant of the Sun. \\(1.32712440041939400 \\times 10^{20}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Nominal photosphere radius of the Sun. \\(6.957 \\times 10^{8}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>P_SUN</code> Nominal solar radiation pressure at 1 AU. \\(4.560 \\times 10^{-6}\\) \\(\\frac{N}{m^2}\\) Montenbruck and Gill <sup>1</sup> <code>R_SUN</code> Equatorial radius of the Moon. \\(1.738 \\times 10^{6}\\) \\(m\\) Montenbruck and Gill <sup>1</sup> <code>GM_MOON</code> Gravitational constant of the Moon. \\(4.902800066 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MERCURY</code> Gravitational constant of the Mercury. \\(2.2031780 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_VENUS</code> Gravitational constant of the Venus. \\(3.248585920 \\times 10^{12}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_MARS</code> Gravitational constant of the Mars. \\(4.282837521 \\times 10^{13}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_JUPITER</code> Gravitational constant of the Jupiter. \\(1.267127648 \\times 10^{17}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_SATURN</code> Gravitational constant of the Saturn. \\(3.79405852 \\times 10^{16}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_URANUS</code> Gravitational constant of the Uranus. \\(5.7945486 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_NEPTUNE</code> Gravitational constant of the Neptune. \\(6.836527100580 \\times 10^{15}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <code>GM_PLUTO</code> Gravitational constant of the Pluto. \\(9.770 \\times 10^{11}\\) \\(\\frac{m^3}{s^2}\\) Montenbruck and Gill <sup>1</sup> <ol> <li> <p>O. Montenbruck, and E. Gill, Satellite Orbits: Models, Methods and Applications, 2012\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>D. Vallado, Fundamentals of Astrodynamics and Applications (4th Ed.), 2010\u00a0\u21a9\u21a9</p> </li> <li> <p>P. G\u00e9rard and B. Luzum, IERS Technical Note 36, 2010\u00a0\u21a9</p> </li> <li> <p>J. Ries, S. Bettadpur, R. Eanes, Z. Kang, U. Ko, C. McCullough, P. Nagel, N. Pie, S. Poole, T. Richter, H. Save, and B. Tapley, Development and Evaluation of the Global Gravity Model GGM05, 2016\u00a0\u21a9</p> </li> <li> <p>Department of Defense World Geodetic System 1984, Its Definition and Relationships With Local Geodetic Systems\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"learn/access_computation/index.html","title":"Access Computation","text":"<p>Access computation determines when and under what conditions satellites can observe or communicate with ground locations. This is fundamental for mission planning, ground station contact scheduling, imaging opportunity analysis, and communications link budgets.</p> <p>Brahe provides a comprehensive access computation system that handles the geometric complexity of satellite-ground visibility while offering flexibility through constraints, extensible properties, and performance optimization.</p>"},{"location":"learn/access_computation/index.html#overview","title":"Overview","text":"<p>Access computation involves:</p> <ul> <li>Geometric visibility: Is the satellite above the horizon from the ground location's perspective?</li> <li>Constraint satisfaction: Do viewing angles, lighting conditions, or other requirements meet mission needs?</li> <li>Time window identification: When do access periods start and end?</li> <li>Property computation: What are the specific characteristics (elevation, azimuth, range, etc.) during access?</li> </ul>"},{"location":"learn/access_computation/index.html#core-concepts","title":"Core Concepts","text":""},{"location":"learn/access_computation/index.html#locations","title":"Locations","text":"<p>Locations represent ground positions that satellites can access:</p> <ul> <li>PointLocation: Discrete points (ground stations, imaging targets)</li> <li>PolygonLocation: Areas of interest (countries, regions, imaging swaths)</li> </ul> <p>All locations support: - Geodetic coordinates (latitude, longitude, altitude) - ECEF coordinates (Earth-fixed Cartesian) - GeoJSON interoperability - Extensible properties via metadata dictionary - Identifiable trait (name, ID, UUID)</p> <p>See Locations for details.</p>"},{"location":"learn/access_computation/index.html#constraints","title":"Constraints","text":"<p>Constraints define access criteria that must be satisfied:</p> <p>Built-in Constraints: - <code>ElevationConstraint</code>: Minimum/maximum elevation angles - <code>ElevationMaskConstraint</code>: Azimuth-dependent elevation masks - <code>OffNadirConstraint</code>: Satellite pointing angles - <code>LookDirectionConstraint</code>: Left/right/either looking direction - <code>LocalTimeConstraint</code>: Time-of-day access windows - <code>OrbitTypeConstraint</code>: Ascending/descending pass filtering</p> <p>Logical Composition: - <code>ConstraintAll</code>: AND logic (all constraints must be satisfied) - <code>ConstraintAny</code>: OR logic (any constraint must be satisfied) - <code>ConstraintNot</code>: NOT logic (constraint must NOT be satisfied)</p> <p>Custom Constraints: - Python-defined constraints via <code>AccessPropertyComputer</code> - Arbitrary logic based on epoch, satellite state, and location</p> <p>See Constraints for details.</p>"},{"location":"learn/access_computation/index.html#access-windows","title":"Access Windows","text":"<p>Access windows represent periods when constraints are satisfied:</p> <pre><code>import brahe as bh\n\n# Each window provides:\nwindow.window_open      # Start epoch\nwindow.window_close     # End epoch\nwindow.duration         # Duration in seconds\nwindow.location_id      # Location identifier\nwindow.propagator_id    # Satellite identifier\nwindow.properties       # Computed properties during access\n</code></pre>"},{"location":"learn/access_computation/index.html#access-properties","title":"Access Properties","text":"<p>Properties characterize access windows with geometric and custom metrics:</p> <p>Built-in Properties: - <code>elevation</code>: Satellite elevation angle (degrees) - <code>azimuth</code>: Satellite azimuth angle (degrees) - <code>range</code>: Satellite-to-location distance (meters) - <code>range_rate</code>: Range rate of change (m/s) - <code>off_nadir</code>: Satellite off-nadir angle (degrees) - <code>look_direction</code>: LEFT/RIGHT/BOTH viewing geometry</p> <p>Custom Properties: - Compute arbitrary metrics using Python functions - Access to epoch, satellite state (ECI/ECEF), and location - Properties stored in window for post-processing</p> <p>See Computation for details.</p>"},{"location":"learn/access_computation/index.html#basic-workflow","title":"Basic Workflow","text":"<ol> <li>Define locations: Create ground sites or areas of interest</li> <li>Setup propagators: Initialize satellite orbit propagators</li> <li>Configure constraints: Specify access criteria</li> <li>Compute accesses: Find time windows when constraints are satisfied</li> <li>Analyze results: Extract properties and schedule activities</li> </ol> <p>Example:</p> <pre><code>import brahe as bh\nimport numpy as np\n\n# Initialize EOP provider\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider(eop)\n\n# Define ground station\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\")\n\n# Create satellite propagator\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 600e3, 0.001, 97.8, 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\npropagator = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite-1\")\n\n# Define constraint (10\u00b0 minimum elevation)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute accesses over 24 hours\nwindows = bh.location_accesses(\n    [svalbard],\n    [propagator],\n    epoch,\n    epoch + 86400.0,\n    constraint\n)\n\nprint(f\"Found {len(windows)} access windows\")\nfor window in windows:\n    duration_min = window.duration / 60.0\n    print(f\"  {window.window_open} - {window.window_close} ({duration_min:.1f} min)\")\n</code></pre>"},{"location":"learn/access_computation/index.html#performance-optimization","title":"Performance Optimization","text":"<p>Access computation can be computationally intensive for large-scale analyses. Brahe provides several optimization strategies:</p>"},{"location":"learn/access_computation/index.html#parallelization","title":"Parallelization","text":"<p>By default, access computation runs in parallel using 90% of available CPU cores:</p> <pre><code># Default: parallel with 90% of cores\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start_epoch,\n    end_epoch,\n    constraint\n)\n\n# Explicit configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=False,\n    parallel=True,        # Enable parallelization\n    num_threads=None      # Use global default (90% of cores)\n)\n\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start_epoch,\n    end_epoch,\n    constraint,\n    config=config\n)\n</code></pre>"},{"location":"learn/access_computation/index.html#thread-pool-configuration","title":"Thread Pool Configuration","text":"<p>Control parallelization globally or per-computation:</p> <pre><code># Set specific number of threads (must be called before any parallel operations)\nbh.set_num_threads(4)\n\n# Or use all available CPU cores\nbh.set_max_threads()\n\n# Or go LUDICROUS SPEED (alias for set_max_threads)\nbh.set_ludicrous_speed()\n\n# Configure per-computation\nconfig = bh.AccessSearchConfig(\n    parallel=True,\n    num_threads=8  # Use 8 threads for this computation\n)\n\n# Or disable parallelization entirely\nconfig = bh.AccessSearchConfig(parallel=False)\n</code></pre>"},{"location":"learn/access_computation/index.html#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>Adaptive stepping increases efficiency by using larger time steps when constraints are far from satisfied:</p> <pre><code>config = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=True,           # Enable adaptive stepping\n    adaptive_fraction=0.75,       # Aggressiveness factor\n    parallel=True\n)\n</code></pre> <p>When adaptive stepping helps: - Long search periods with sparse accesses - Tight elevation constraints (e.g., &gt; 60\u00b0) - Complex composed constraints</p> <p>When to disable: - Very frequent accesses (LEO constellation to global coverage) - Short search periods - When deterministic timing is required</p>"},{"location":"learn/access_computation/index.html#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch processing: Compute multiple location-satellite pairs in one call</li> <li>Pre-filter candidates: Use geometric screening before detailed constraint checking</li> <li>Adjust time step: Balance between accuracy and performance</li> <li>Use parallelization: Leverage multiple cores for large problems</li> <li>Cache propagators: Reuse state providers across multiple access computations</li> </ol>"},{"location":"learn/access_computation/index.html#use-cases","title":"Use Cases","text":"<p>Ground Station Contact Scheduling: - Find all passes above minimum elevation - Filter by local time constraints (operational hours) - Compute pass characteristics (max elevation, duration)</p> <p>Imaging Opportunity Analysis: - Identify when targets are within sensor field of view - Filter by off-nadir angle and look direction - Compute sun angles and lighting conditions</p> <p>Communications Link Analysis: - Determine line-of-sight windows - Compute range and range-rate for Doppler estimation - Assess elevation angles for link margin</p> <p>Constellation Coverage Analysis: - Analyze global or regional coverage - Identify coverage gaps - Optimize constellation design</p>"},{"location":"learn/access_computation/index.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/access_computation/index.html#multiple-locations-and-satellites","title":"Multiple Locations and Satellites","text":"<pre><code># Define multiple ground stations\nlocations = [\n    bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\"),\n    bh.PointLocation(-64.5, -31.5, 0.0).with_name(\"Malargue\"),\n    bh.PointLocation(-117.2, 34.1, 0.0).with_name(\"Goldstone\"),\n]\n\n# Define constellation\npropagators = []\nfor i in range(5):\n    oe = np.array([bh.R_EARTH + 550e3, 0.001, 97.8, i*30.0, 0.0, i*45.0])\n    state = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\n    prop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(f\"Sat-{i}\")\n    propagators.append(prop)\n\n# Compute all location-satellite combinations\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Windows are sorted by opening time\n# Each window has location_id and propagator_id for filtering\n</code></pre>"},{"location":"learn/access_computation/index.html#complex-constraints","title":"Complex Constraints","text":"<pre><code># Combine multiple constraints with AND logic\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),  # Daylight operations\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n\n# OR logic: Either high elevation OR ascending pass\nconstraint = bh.ConstraintAny([\n    bh.ElevationConstraint(min_elevation_deg=60.0),\n    bh.OrbitTypeConstraint(orbit_type=bh.AscDsc.ASC),\n])\n\n# NOT logic: Exclude nighttime passes\ndaytime = bh.ConstraintNot(\n    bh.LocalTimeConstraint(min_hour=18.0, max_hour=8.0)  # NOT nighttime\n)\n</code></pre>"},{"location":"learn/access_computation/index.html#custom-property-computation","title":"Custom Property Computation","text":"<pre><code>import math\n\n# Define custom property computer\ndef compute_slant_range_km(epoch, sat_state_eci, sat_state_ecef, location_ecef):\n    \"\"\"Compute slant range in kilometers\"\"\"\n    range_m = np.linalg.norm(sat_state_ecef[:3] - location_ecef)\n    return {\"slant_range_km\": range_m / 1000.0}\n\n# Create property computer\ncomputer = bh.AccessPropertyComputer(compute_slant_range_km)\n\n# Compute accesses with custom properties\nconfig = bh.AccessSearchConfig()\nwindows = bh.location_accesses(\n    locations,\n    propagators,\n    start,\n    end,\n    constraint,\n    config=config,\n    property_computers=[computer]\n)\n\n# Access custom properties\nfor window in windows:\n    props = window.properties\n    print(f\"Slant range: {props['slant_range_km']:.1f} km\")\n</code></pre>"},{"location":"learn/access_computation/index.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and GeoJSON support</li> <li>Constraints - Built-in and custom constraint types</li> <li>Computation - Access algorithms and property computation</li> <li>Example: Predicting Ground Contacts - Complete ground station example</li> <li>Example: Computing Imaging Opportunities - Imaging scenario</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/computation.html","title":"Access Computation","text":"<p>This document explains how Brahe computes access windows\u2014the algorithms, design decisions, and performance considerations that make access computation both accurate and efficient.</p>"},{"location":"learn/access_computation/computation.html#overview","title":"Overview","text":"<p>Access computation involves finding time periods when a satellite can observe or communicate with a ground location while satisfying specified constraints. This is fundamentally a root-finding problem: we need to identify when constraint satisfaction transitions from <code>False</code> to <code>True</code> (window opens) and from <code>True</code> to <code>False</code> (window closes).</p>"},{"location":"learn/access_computation/computation.html#algorithm-overview","title":"Algorithm Overview","text":"<p>Brahe uses a two-phase approach:</p> <ol> <li>Coarse grid search: Quickly identify candidate access periods using large time steps</li> <li>Bisection refinement: Precisely locate window boundaries using binary search</li> </ol> <p>This hybrid approach balances speed (coarse search) with precision (refinement).</p>"},{"location":"learn/access_computation/computation.html#phase-1-coarse-grid-search","title":"Phase 1: Coarse Grid Search","text":""},{"location":"learn/access_computation/computation.html#basic-algorithm","title":"Basic Algorithm","text":"<p>The coarse search evaluates constraints at regular time intervals to identify candidate access periods.</p>"},{"location":"learn/access_computation/computation.html#adaptive-time-stepping","title":"Adaptive Time Stepping","text":"<p>For improved efficiency, Brahe optionally adapts the time step based on orbital period:</p> <pre><code># Configuration\nconfig = bh.AccessSearchConfig(\n    initial_time_step=60.0,\n    adaptive_step=True,\n    adaptive_fraction=0.75\n)\n</code></pre> <p>How it works: 1. Compute orbital period from semi-major axis 2. Set step size = <code>orbital_period * adaptive_fraction</code> 3. Use this step for first step immediately after finding a candidate window because it's unlikely for LEO to have another access until the next orbit.</p> <p>When to use: - When computing accesses for LEO satellites - Long search periods (days to weeks) - Computational efficiency is critical</p> <p>When to avoid: - Non-LEO orbits (GEO, HEO) where orbital period is very long</p>"},{"location":"learn/access_computation/computation.html#phase-2-bisection-refinement","title":"Phase 2: Bisection Refinement","text":"<p>Once candidates are identified, bisection search refines boundaries to high precision.</p>"},{"location":"learn/access_computation/computation.html#bisection-algorithm","title":"Bisection Algorithm","text":""},{"location":"learn/access_computation/computation.html#window-opening-vs-closing","title":"Window Opening vs. Closing","text":"<p>Bisection refines both boundaries:</p> <ol> <li>Window open: Refine between last <code>False</code> and first <code>True</code> from coarse search</li> <li>Window close: Refine between last <code>True</code> and first <code>False</code> from coarse search</li> </ol> <p>Each window requires two bisection searches (open and close boundaries).</p>"},{"location":"learn/access_computation/computation.html#phase-3-property-computation","title":"Phase 3: Property Computation","text":"<p>After window boundaries are refined, properties are computed to characterize the access.</p>"},{"location":"learn/access_computation/computation.html#core-properties","title":"Core Properties","text":"<p>Computed automatically for every window:</p> <pre><code># At window open\nazimuth_open = compute_azimuth(sat_pos, location)\n\n# At window close\nazimuth_close = compute_azimuth(sat_pos, location)\n\n# Throughout window (via sampling)\nelevation_max = max(compute_elevation(sat_pos, location) for t in window)\nelevation_min = min(compute_elevation(sat_pos, location) for t in window)\n\n# At window midtime\noff_nadir_min = compute_off_nadir(sat_pos, sat_vel, location)\nlocal_time = compute_local_solar_time(location, epoch)\nlook_direction = compute_look_direction(sat_vel, location_vector)\nasc_dsc = compute_ascending_or_descending(sat_state)\n</code></pre>"},{"location":"learn/access_computation/computation.html#custom-properties","title":"Custom Properties","text":"<p>User-defined property computers can compute additional window properties by subclassing <code>AccessPropertyComputer</code>:</p> <pre><code>import brahe as bh\nimport numpy as np\n\nclass SlantRangeComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes slant range and related metrics for each access window.\n    \"\"\"\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"\n        Compute slant range properties.\n\n        Args:\n            window: AccessWindow with timing information\n            satellite_state_ecef: Satellite state [x,y,z,vx,vy,vz] at window midtime (m, m/s)\n            location_ecef: Location position [x,y,z] (m)\n\n        Returns:\n            dict: Property name -&gt; value mapping\n        \"\"\"\n        sat_pos = satellite_state_ecef[:3]\n        slant_range_m = np.linalg.norm(sat_pos - location_ecef)\n\n        return {\n            \"slant_range_km\": slant_range_m / 1000.0,\n            \"within_2000km\": slant_range_m &lt; 2000e3,\n            \"slant_range_category\": self._categorize_range(slant_range_m)\n        }\n\n    def property_names(self):\n        \"\"\"Return list of property names this computer produces\"\"\"\n        return [\"slant_range_km\", \"within_2000km\", \"slant_range_category\"]\n\n    def _categorize_range(self, range_m):\n        \"\"\"Helper to categorize range\"\"\"\n        if range_m &lt; 1000e3:\n            return \"close\"\n        elif range_m &lt; 2000e3:\n            return \"medium\"\n        else:\n            return \"far\"\n\n# Use with access computation\ncomputer = SlantRangeComputer()\nwindows = bh.location_accesses(\n    locations, propagators, start, end,\n    constraint,\n    property_computers=[computer]\n)\n\n# Access custom properties\nfor window in windows:\n    slant_range = window.properties.additional[\"slant_range_km\"]\n    category = window.properties.additional[\"slant_range_category\"]\n    print(f\"Range: {slant_range:.1f} km ({category})\")\n</code></pre>"},{"location":"learn/access_computation/computation.html#advanced-property-computer","title":"Advanced Property Computer","text":"<pre><code>class DopplerComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes Doppler shift at window midtime.\n\n    Useful for communications link budget analysis.\n    \"\"\"\n\n    def __init__(self, frequency_hz=2.4e9):\n        \"\"\"\n        Args:\n            frequency_hz: Carrier frequency in Hz (default: 2.4 GHz)\n        \"\"\"\n        self.frequency = frequency_hz\n        self.c = 299792458.0  # Speed of light (m/s)\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"Compute Doppler shift\"\"\"\n        # Extract satellite velocity\n        sat_vel = satellite_state_ecef[3:6]\n\n        # Line-of-sight vector\n        sat_pos = satellite_state_ecef[:3]\n        los = location_ecef - sat_pos\n        los_unit = los / np.linalg.norm(los)\n\n        # Radial velocity (positive = approaching)\n        radial_vel = np.dot(sat_vel, los_unit)\n\n        # Doppler shift\n        doppler_hz = -(radial_vel / self.c) * self.frequency\n\n        return {\n            \"doppler_shift_hz\": doppler_hz,\n            \"doppler_shift_khz\": doppler_hz / 1000.0,\n            \"radial_velocity_mps\": radial_vel,\n            \"is_approaching\": radial_vel &gt; 0.0\n        }\n\n    def property_names(self):\n        return [\n            \"doppler_shift_hz\",\n            \"doppler_shift_khz\",\n            \"radial_velocity_mps\",\n            \"is_approaching\"\n        ]\n</code></pre>"},{"location":"learn/access_computation/computation.html#time-series-properties","title":"Time Series Properties","text":"<p>Property computers can return time series data:</p> <pre><code>class ElevationProfileComputer(bh.AccessPropertyComputer):\n    \"\"\"\n    Computes elevation angle profile throughout the window.\n    \"\"\"\n\n    def __init__(self, sample_rate_sec=10.0):\n        self.sample_rate = sample_rate_sec\n\n    def compute(self, window, satellite_state_ecef, location_ecef):\n        \"\"\"\n        Sample elevation throughout window.\n\n        Note: This is called at window midtime, so for time series\n        you would need to resample the trajectory or use the StateProvider.\n        This is a simplified example.\n        \"\"\"\n        # In real implementation, would resample throughout window\n        # For now, just return midtime elevation\n        from brahe.access import compute_elevation\n\n        midtime_elevation = compute_elevation(\n            satellite_state_ecef[:3],\n            location_ecef\n        )\n\n        return {\n            \"elevation_profile\": {\n                \"times\": [0.0],  # Seconds from window start\n                \"values\": [midtime_elevation]\n            },\n            \"peak_elevation\": midtime_elevation\n        }\n\n    def property_names(self):\n        return [\"elevation_profile\", \"peak_elevation\"]\n</code></pre> <p>When to use property computers: - Computing derived metrics for link budgets or mission analysis - Recording time-series data for later analysis - Annotating windows with mission-specific information - Filtering windows based on computed properties</p> <p>Performance note: Property computers are called once per window at the midtime. For expensive computations, this is more efficient than computing properties for every constraint evaluation.</p>"},{"location":"learn/access_computation/computation.html#complete-pipeline","title":"Complete Pipeline","text":"<p>The full access computation pipeline:</p> <pre><code>1. For each (location, propagator) pair:\n\n   2. Coarse grid search\n      \u2193\n      [Candidate windows with ~60s boundary uncertainty]\n\n   3. For each candidate:\n\n      4. Bisection refinement (window open)\n         \u2193\n      5. Bisection refinement (window close)\n         \u2193\n         [Precise window boundaries within 0.01s]\n\n      6. Compute core properties\n         \u2193\n      7. Compute custom properties (if any)\n         \u2193\n         [Complete AccessWindow]\n\n8. Sort all windows by opening time\n   \u2193\n   [Final sorted list of AccessWindow objects]\n</code></pre>"},{"location":"learn/access_computation/computation.html#parallelization","title":"Parallelization","text":"<p>For large-scale problems, Brahe parallelizes access computation across location-propagator pairs.</p> <p>Access computation is parallel by default, utilizing up to 90% of available CPU cores on the machine. This can be disabled or configured as needed.</p> <p>Parallelization occurs at the pair level: - Each (location, propagator) pair is independent - No shared state during window finding - Results aggregated and sorted after all pairs complete</p> <p>Performance scaling: - Near-linear speedup for many pairs (e.g., 10 locations \u00d7 10 satellites = 100 pairs) - Limited benefit for single pair (no parallelism)</p>"},{"location":"learn/access_computation/computation.html#configuration","title":"Configuration","text":"<pre><code># Default: parallel with 90% of cores\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Explicit control\nconfig = bh.AccessSearchConfig(\n    parallel=True,        # Enable parallelization\n    num_threads=4         # Use 4 threads (overrides global default)\n)\n\nwindows = bh.location_accesses(\n    locations, propagators, start, end, constraint, config=config\n)\n\n# Sequential (debugging or reproducibility)\nconfig = bh.AccessSearchConfig(parallel=False)\n</code></pre> <p>Thread pool management: <pre><code># Set specific number of threads (must be called before any parallel operations)\nbh.set_num_threads(8)\n\n# Use all available CPU cores\nbh.set_max_threads()\n\n# Or go LUDICROUS SPEED (alias for set_max_threads)\nbh.set_ludicrous_speed()\n\n# Query current setting\nnum_threads = bh.get_max_threads()\n</code></pre></p>"},{"location":"learn/access_computation/computation.html#optimization-guidelines","title":"Optimization Guidelines","text":"<p>Choose appropriate time step: - Smaller step: more accurate, slower - Larger step: faster, may miss short windows - Rule of thumb: <code>dt \u2264 min_expected_window_duration / 3</code></p> <p>Use adaptive stepping when: - Search period &gt;&gt; orbital period - LEO satellites</p> <p>Use parallelization when: - Multiple location-propagator pairs (N \u00d7 M &gt; 10) - Multiple CPU cores available</p> <p>Avoid parallelization when: - Single location-propagator pair - Custom constraints use external resources (databases, files)</p>"},{"location":"learn/access_computation/computation.html#accuracy-considerations","title":"Accuracy Considerations","text":""},{"location":"learn/access_computation/computation.html#numerical-precision","title":"Numerical Precision","text":"<p>Bisection tolerance: - Default 0.01s provides sub-second precision - Can be tightened to 0.001s or more for high-precision applications - Diminishing returns below ~0.001s due to floating-point limits and state propagation errors</p>"},{"location":"learn/access_computation/computation.html#implementation-notes","title":"Implementation Notes","text":""},{"location":"learn/access_computation/computation.html#state-provider-architecture","title":"State Provider Architecture","text":"<p>Access computation works with any <code>StateProvider</code>:</p> <pre><code>pub trait StateProvider {\n    fn state(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n    fn state_eci(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n    fn state_ecef(&amp;self, epoch: &amp;Epoch) -&gt; Vector6&lt;f64&gt;;\n}\n</code></pre> <p>This abstraction allows: - Analytical propagators (Keplerian, SGP4) - Pre-computed trajectories (OrbitTrajectory) - Hybrid approaches (mix propagator types) - Future propagators (numerical integrators, etc.)</p> <p>All use the same access computation code\u2014no special-casing required.</p>"},{"location":"learn/access_computation/computation.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types and properties</li> <li>Constraints - Constraint system and composition</li> <li>Access Computation Index - Overview and usage examples</li> <li>Example: Predicting Ground Contacts - Complete workflow</li> <li>API Reference: Access Module - Complete API documentation</li> </ul>"},{"location":"learn/access_computation/constraints.html","title":"Constraints","text":"<p>Constraints define the criteria that must be satisfied for satellite access to ground locations. Brahe provides a comprehensive constraint system with built-in geometric constraints, logical composition operators, and support for custom user-defined constraints.</p>"},{"location":"learn/access_computation/constraints.html#overview","title":"Overview","text":"<p>Access constraints answer questions like:</p> <ul> <li>\"Is the satellite above 10\u00b0 elevation?\"</li> <li>\"Is the satellite looking in the right direction?\"</li> <li>\"Is it daytime at the ground location?\"</li> <li>\"Are all of these conditions satisfied simultaneously?\"</li> </ul> <p>Constraints are evaluated at each time step during access computation to determine when access windows open and close.</p>"},{"location":"learn/access_computation/constraints.html#core-concept","title":"Core Concept","text":"<p>All constraints implement the <code>AccessConstraint</code> trait, which provides:</p> <pre><code>def evaluate(epoch, sat_state_ecef, location_ecef) -&gt; bool:\n    \"\"\"\n    Returns True if constraint is satisfied, False otherwise.\n\n    Args:\n        epoch: Time of evaluation\n        sat_state_ecef: Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\n        location_ecef: Location in ECEF [x, y, z] (meters)\n    \"\"\"\n    pass\n</code></pre> <p>This simple interface enables powerful composition and extension.</p>"},{"location":"learn/access_computation/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevation-constraints","title":"Elevation Constraints","text":""},{"location":"learn/access_computation/constraints.html#elevationconstraint","title":"ElevationConstraint","text":"<p>Constrains access based on satellite elevation angle above the local horizon:</p> <pre><code>import brahe as bh\n\n# Minimum elevation only (typical ground station)\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Both bounds (avoid low and zenith angles)\nconstraint = bh.ElevationConstraint(\n    min_elevation_deg=10.0,\n    max_elevation_deg=85.0\n)\n\n# Maximum only (avoid zenith)\nconstraint = bh.ElevationConstraint(max_elevation_deg=80.0)\n</code></pre> <p>When to use: - Ground station visibility (min elevation &gt; 5-10\u00b0) - Link budget requirements (min elevation affects signal strength) - Avoiding multipath (exclude low elevations) - Zenith avoidance for dish antennas (max elevation)</p> <p>Design note: At least one bound (min or max) must be specified. An unbounded constraint would match everything and serves no purpose.</p>"},{"location":"learn/access_computation/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":"<p>Azimuth-dependent elevation masks for terrain obstructions or antenna limitations:</p> <pre><code># Define mask as (azimuth_deg, min_elevation_deg) pairs\nmask = [\n    (0.0, 10.0),     # North: 10\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 15.0),   # South: 15\u00b0 minimum (mountain)\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n    (360.0, 10.0),   # Wrap to north\n]\n\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Key features: - Linear interpolation between azimuth points - Automatic wrapping at 0\u00b0/360\u00b0 - Must be sorted by azimuth in ascending order</p> <p>When to use: - Ground stations with terrain obstructions - Antenna mechanical limitations - Building/structure interference - Regulatory restrictions by direction</p>"},{"location":"learn/access_computation/constraints.html#satellite-pointing-constraints","title":"Satellite Pointing Constraints","text":""},{"location":"learn/access_computation/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":"<p>Constrains satellite off-nadir angle (angle between satellite-to-location vector and nadir):</p> <pre><code># Imaging sensor with 30\u00b0 max off-nadir\nconstraint = bh.OffNadirConstraint(\n    min_off_nadir_deg=0.0,\n    max_off_nadir_deg=30.0\n)\n\n# Minimum off-nadir (avoid direct nadir)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=5.0)\n</code></pre> <p>When to use: - Imaging missions with sensor field-of-view limits - Avoiding geometry that causes distortion - Nadir-pointing vs. off-nadir pointing modes - Synthetic aperture radar (SAR) geometry requirements</p> <p>Geometry note: 0\u00b0 off-nadir = directly below satellite (nadir pointing). Larger angles = more oblique viewing.</p>"},{"location":"learn/access_computation/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":"<p>Constrains satellite look direction (left/right relative to velocity vector):</p> <pre><code># Right-looking only\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT)\n\n# Left-looking only\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.LEFT)\n\n# Either direction (permissive)\nconstraint = bh.LookDirectionConstraint(look_direction=bh.LookDirection.BOTH)\n</code></pre> <p>When to use: - Imaging satellites with fixed-side sensors - SAR missions with specific look-direction requirements - Avoiding sun glint (prefer specific look direction) - Stereo imaging pairs (require consistent look direction)</p> <p>Geometry note: Look direction is computed relative to satellite velocity vector using cross product. BOTH is equivalent to no constraint.</p>"},{"location":"learn/access_computation/constraints.html#temporal-constraints","title":"Temporal Constraints","text":""},{"location":"learn/access_computation/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":"<p>Constrains access based on local solar time at the ground location:</p> <pre><code># Daylight operations only (8 AM - 6 PM local)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=8.0,\n    max_hour=18.0\n)\n\n# Nighttime operations (10 PM - 4 AM local)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=22.0,\n    max_hour=4.0\n)\n\n# Early morning (wrap around midnight)\nconstraint = bh.LocalTimeConstraint(\n    min_hour=4.0,\n    max_hour=8.0\n)\n</code></pre> <p>Key features: - Based on sun position (local solar time) - Automatically handles day/night wrap-around - Hours are floating-point (e.g., 13.5 = 1:30 PM)</p> <p>When to use: - Operational hour restrictions - Imaging with sun angle requirements - Avoiding local midnight (thermal constraints) - Sun-synchronous orbit planning</p> <p>Implementation note: Uses sun position calculations, not time zones. This is more accurate for satellite applications.</p>"},{"location":"learn/access_computation/constraints.html#orbit-geometry-constraints","title":"Orbit Geometry Constraints","text":""},{"location":"learn/access_computation/constraints.html#orbittypeconstraint-ascdscconstraint","title":"OrbitTypeConstraint (AscDscConstraint)","text":"<p>Filters by ascending vs. descending passes:</p> <pre><code># Ascending passes only (southbound to northbound)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC)\n\n# Descending passes only (northbound to southbound)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.DSC)\n\n# Either (no filtering)\nconstraint = bh.AscDscConstraint(orbit_type=bh.AscDsc.BOTH)\n</code></pre> <p>When to use: - Sun-synchronous orbits (different local times for asc/dsc) - Imaging with specific sun-angle requirements - Ground station scheduling (separate asc/dsc antennas) - Radar interferometry (consistent geometry)</p> <p>Geometry note: Determined by sign of latitude rate (d\u03c6/dt).</p>"},{"location":"learn/access_computation/constraints.html#logical-composition","title":"Logical Composition","text":"<p>Combine constraints with Boolean logic:</p>"},{"location":"learn/access_computation/constraints.html#constraintall-and","title":"ConstraintAll (AND)","text":"<p>All child constraints must be satisfied:</p> <pre><code># Ground station with elevation and time constraints\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n])\n\n# Complex imaging requirements\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=30.0),\n    bh.OffNadirConstraint(max_off_nadir_deg=25.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n    bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC),\n])\n</code></pre> <p>Behavior: Returns <code>True</code> only if ALL child constraints return <code>True</code>.</p> <p>Short-circuit evaluation: Stops checking as soon as any constraint returns <code>False</code> (performance optimization).</p>"},{"location":"learn/access_computation/constraints.html#constraintany-or","title":"ConstraintAny (OR)","text":"<p>At least one child constraint must be satisfied:</p> <pre><code># High elevation OR ascending pass\nconstraint = bh.ConstraintAny([\n    bh.ElevationConstraint(min_elevation_deg=60.0),  # Very high passes\n    bh.AscDscConstraint(orbit_type=bh.AscDsc.ASC),  # OR ascending\n])\n\n# Multiple time windows\nconstraint = bh.ConstraintAny([\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=12.0),   # Morning\n    bh.LocalTimeConstraint(min_hour=14.0, max_hour=18.0),  # Afternoon\n])\n</code></pre> <p>Behavior: Returns <code>True</code> if ANY child constraint returns <code>True</code>.</p> <p>Short-circuit evaluation: Stops checking as soon as any constraint returns <code>True</code>.</p>"},{"location":"learn/access_computation/constraints.html#constraintnot-not","title":"ConstraintNot (NOT)","text":"<p>Inverts constraint result:</p> <pre><code># Exclude nighttime (i.e., daytime only)\nconstraint = bh.ConstraintNot(\n    bh.LocalTimeConstraint(min_hour=20.0, max_hour=6.0)  # NOT nighttime\n)\n\n# Avoid nadir pointing\nconstraint = bh.ConstraintNot(\n    bh.OffNadirConstraint(max_off_nadir_deg=5.0)  # NOT near-nadir\n)\n</code></pre> <p>Behavior: Returns opposite of child constraint (<code>not child.evaluate(...)</code>).</p> <p>Design tip: Often clearer to use opposite bounds rather than NOT, but NOT is essential for complex compositions.</p>"},{"location":"learn/access_computation/constraints.html#nested-composition","title":"Nested Composition","text":"<p>Combine logical operators arbitrarily:</p> <pre><code># (High elevation AND daytime) OR (Medium elevation AND right-looking)\nconstraint = bh.ConstraintAny([\n    bh.ConstraintAll([\n        bh.ElevationConstraint(min_elevation_deg=60.0),\n        bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n    ]),\n    bh.ConstraintAll([\n        bh.ElevationConstraint(min_elevation_deg=30.0),\n        bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n    ]),\n])\n\n# Complex exclusion logic\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Basic visibility\n    bh.ConstraintNot(  # NOT (nighttime AND low elevation)\n        bh.ConstraintAll([\n            bh.LocalTimeConstraint(min_hour=20.0, max_hour=6.0),\n            bh.ElevationConstraint(max_elevation_deg=30.0),\n        ])\n    ),\n])\n</code></pre> <p>Performance note: Evaluation is lazy and short-circuits. Order child constraints with most likely to fail first.</p>"},{"location":"learn/access_computation/constraints.html#custom-constraints","title":"Custom Constraints","text":"<p>Define application-specific constraints by subclassing <code>AccessConstraintComputer</code>:</p>"},{"location":"learn/access_computation/constraints.html#basic-custom-constraint","title":"Basic Custom Constraint","text":"<pre><code>import brahe as bh\nimport numpy as np\n\nclass SlantRangeConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Custom constraint that limits access based on slant range.\n\n    Only allows access when satellite is within 2000 km of location.\n    \"\"\"\n\n    def __init__(self, max_range_km=2000.0):\n        self.max_range_m = max_range_km * 1000.0\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"\n        Check if satellite is within maximum slant range.\n\n        Args:\n            epoch: Current evaluation time\n            sat_state_ecef: Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef: Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            bool: True if within range, False otherwise\n        \"\"\"\n        sat_pos = sat_state_ecef[:3]\n        range_m = np.linalg.norm(sat_pos - location_ecef)\n        return range_m &lt; self.max_range_m\n\n    def name(self):\n        \"\"\"Return constraint name\"\"\"\n        return f\"SlantRange(max={self.max_range_m/1000:.0f}km)\"\n\n# Use with access computation\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Built-in constraint\n    SlantRangeConstraint(max_range_km=2000.0),       # Custom constraint\n])\n\nwindows = bh.location_accesses(\n    locations, propagators, start, end, constraint\n)\n</code></pre>"},{"location":"learn/access_computation/constraints.html#advanced-custom-constraint","title":"Advanced Custom Constraint","text":"<pre><code>class NorthernHemisphereConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Only allows access when satellite is in northern hemisphere.\n\n    Useful for sun-synchronous orbits or regional coverage requirements.\n    \"\"\"\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Check if satellite Z-coordinate is positive (northern hemisphere)\"\"\"\n        z_coord = sat_state_ecef[2]  # Z in ECEF\n        return z_coord &gt;= 0.0\n\n    def name(self):\n        return \"NorthernHemisphere\"\n\nclass SunAngleConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Constraint based on sun elevation angle at location.\n\n    Requires daylight conditions for optical imaging.\n    \"\"\"\n\n    def __init__(self, min_sun_elevation_deg=10.0, max_sun_elevation_deg=70.0):\n        self.min_sun_elev = np.radians(min_sun_elevation_deg)\n        self.max_sun_elev = np.radians(max_sun_elevation_deg)\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Check if sun elevation is within acceptable range\"\"\"\n        # Compute sun position (placeholder - use actual ephemeris)\n        # Real implementation would use:\n        # sun_pos = bh.sun_position(epoch)\n        # sun_elev = compute_sun_elevation(sun_pos, location_ecef)\n\n        # For demonstration:\n        sun_elevation = 0.5  # Radians (placeholder)\n\n        return self.min_sun_elev &lt;= sun_elevation &lt;= self.max_sun_elev\n\n    def name(self):\n        return f\"SunAngle({np.degrees(self.min_sun_elev):.0f}\u00b0-{np.degrees(self.max_sun_elev):.0f}\u00b0)\"\n\n# Combine with built-in constraints\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=30.0),\n    bh.OffNadirConstraint(max_off_nadir_deg=25.0),\n    SunAngleConstraint(min_sun_elevation_deg=10.0, max_sun_elevation_deg=70.0),\n])\n</code></pre>"},{"location":"learn/access_computation/constraints.html#stateful-custom-constraints","title":"Stateful Custom Constraints","text":"<p>Custom constraints can maintain internal state:</p> <pre><code>class EvaluationCounterConstraint(bh.AccessConstraintComputer):\n    \"\"\"\n    Example constraint that counts how many times it's been evaluated.\n\n    Useful for performance profiling or debugging.\n    \"\"\"\n\n    def __init__(self):\n        self.evaluation_count = 0\n\n    def evaluate(self, epoch, sat_state_ecef, location_ecef):\n        \"\"\"Always returns True, but counts evaluations\"\"\"\n        self.evaluation_count += 1\n        return True\n\n    def name(self):\n        return f\"EvaluationCounter(count={self.evaluation_count})\"\n\n# Use in access computation\ncounter = EvaluationCounterConstraint()\nwindows = bh.location_accesses(locations, propagators, start, end, counter)\nprint(f\"Constraint evaluated {counter.evaluation_count} times\")\n</code></pre> <p>When to use custom constraints: - Domain-specific requirements not covered by built-in constraints - Complex logic requiring external data (weather, sun angles, etc.) - Research/experimental constraint types</p> <p>Performance note: Custom Python constraints are slower than built-in Rust constraints (~100-1000\u00d7 slower). For performance-critical applications, combine custom constraints with restrictive built-in constraints using <code>ConstraintAll</code> to minimize custom constraint evaluations.</p>"},{"location":"learn/access_computation/constraints.html#design-patterns","title":"Design Patterns","text":""},{"location":"learn/access_computation/constraints.html#layered-constraints","title":"Layered Constraints","text":"<p>Build constraints from permissive to restrictive:</p> <pre><code># Layer 1: Basic visibility\nbasic = bh.ElevationConstraint(min_elevation_deg=5.0)\n\n# Layer 2: Add operational constraints\noperational = bh.ConstraintAll([\n    basic,\n    bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0),\n])\n\n# Layer 3: Add mission-specific requirements\nmission = bh.ConstraintAll([\n    operational,\n    bh.OffNadirConstraint(max_off_nadir_deg=30.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n</code></pre> <p>Benefit: Easy to test intermediate constraint sets and identify which layer is most restrictive.</p>"},{"location":"learn/access_computation/constraints.html#constraint-reuse","title":"Constraint Reuse","text":"<p>Define common constraint components once:</p> <pre><code># Common constraint sets\nGROUND_STATION_BASIC = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nDAYLIGHT_OPS = bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0)\n\nIMAGING_GEOMETRY = bh.ConstraintAll([\n    bh.OffNadirConstraint(max_off_nadir_deg=30.0),\n    bh.LookDirectionConstraint(look_direction=bh.LookDirection.RIGHT),\n])\n\n# Compose for specific missions\nground_contact = bh.ConstraintAll([GROUND_STATION_BASIC, DAYLIGHT_OPS])\nimaging_mission = bh.ConstraintAll([GROUND_STATION_BASIC, IMAGING_GEOMETRY])\n</code></pre>"},{"location":"learn/access_computation/constraints.html#constraint-validation","title":"Constraint Validation","text":"<p>Test constraints in isolation before composition:</p> <pre><code># Create test scenario\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nsat_state = ...  # Test satellite state\nloc_ecef = ...   # Test location\n\n# Test individual constraints\nelev_constraint = bh.ElevationConstraint(min_elevation_deg=10.0)\nprint(f\"Elevation constraint: {elev_constraint.evaluate(epoch, sat_state, loc_ecef)}\")\n\ntime_constraint = bh.LocalTimeConstraint(min_hour=8.0, max_hour=18.0)\nprint(f\"Time constraint: {time_constraint.evaluate(epoch, sat_state, loc_ecef)}\")\n\n# Test composition\ncombined = bh.ConstraintAll([elev_constraint, time_constraint])\nprint(f\"Combined: {combined.evaluate(epoch, sat_state, loc_ecef)}\")\n</code></pre>"},{"location":"learn/access_computation/constraints.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/access_computation/constraints.html#constraint-ordering","title":"Constraint Ordering","text":"<p>In <code>ConstraintAll</code>, place fast-to-fail constraints first:</p> <pre><code># Good: Cheap elevation check first\nconstraint = bh.ConstraintAll([\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Fast geometric check\n    compute_intensive_custom_constraint(),             # Expensive computation\n])\n\n# Suboptimal: Expensive check runs even when elevation fails\nconstraint = bh.ConstraintAll([\n    compute_intensive_custom_constraint(),             # Runs first\n    bh.ElevationConstraint(min_elevation_deg=10.0),  # Would have failed anyway\n])\n</code></pre> <p>Rule of thumb: Order by computational cost (cheapest first).</p>"},{"location":"learn/access_computation/constraints.html#constraint-complexity","title":"Constraint Complexity","text":"<ul> <li>Simple constraints (elevation, off-nadir): ~1 microsecond per evaluation</li> <li>Time-based constraints: ~10 microseconds (sun position calculation)</li> <li>Custom Python constraints: 100-1000 microseconds (Python call overhead)</li> </ul> <p>For million-evaluation problems, minimize custom constraint complexity.</p>"},{"location":"learn/access_computation/constraints.html#see-also","title":"See Also","text":"<ul> <li>Locations - Ground location types</li> <li>Computation - How constraints are evaluated during access search</li> <li>API Reference: Constraints</li> <li>Example: Predicting Ground Contacts</li> <li>Example: Computing Imaging Opportunities</li> </ul>"},{"location":"learn/access_computation/locations.html","title":"Locations","text":"<p>Locations represent ground positions or areas that satellites can access. Brahe provides two fundamental location types\u2014points and polygons\u2014with full GeoJSON interoperability and extensible metadata support.</p>"},{"location":"learn/access_computation/locations.html#overview","title":"Overview","text":"<p>All locations in Brahe share common capabilities:</p> <ul> <li>Geographic coordinates: Geodetic (lat/lon/alt) and ECEF (Earth-fixed Cartesian)</li> <li>Identification: Name, numeric ID, and UUID support</li> <li>Properties: Extensible metadata dictionary for custom data</li> <li>GeoJSON: Import/export compatibility with GIS systems</li> <li>Type safety: Strong typing with the <code>AccessibleLocation</code> trait</li> </ul>"},{"location":"learn/access_computation/locations.html#pointlocation","title":"PointLocation","text":"<p>Point locations represent discrete positions on Earth's surface, such as:</p> <ul> <li>Ground stations and tracking sites</li> <li>Imaging targets and waypoints</li> </ul>"},{"location":"learn/access_computation/locations.html#creating-point-locations","title":"Creating Point Locations","text":"<pre><code>import brahe as bh\n\n# Simple creation with lon, lat, alt\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0)\n\n# With identification\nsvalbard = bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\")\n\n# With multiple identifiers\nstation = bh.PointLocation(-117.2, 34.1, 500.0) \\\n    .with_name(\"Goldstone\") \\\n    .with_id(42) \\\n    .with_new_uuid()\n\n# With custom properties\nloc = bh.PointLocation(15.4, 78.2, 0.0) \\\n    .with_name(\"Svalbard\") \\\n    .add_property(\"country\", \"Norway\") \\\n    .add_property(\"operator\", \"KSAT\") \\\n    .add_property(\"frequency_band\", \"X-band\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#coordinate-systems","title":"Coordinate Systems","text":"<p>Point locations maintain coordinates in both geodetic and ECEF systems:</p> <pre><code>loc = bh.PointLocation(15.4, 78.2, 500.0)\n\n# Geodetic coordinates (degrees, meters)\nlon = loc.lon()      # 15.4 degrees\nlat = loc.lat()      # 78.2 degrees\nalt = loc.alt()      # 500.0 meters\n\n# ECEF coordinates (meters)\necef = loc.center_ecef()  # Vector3 [x, y, z] in meters\n\n# Access with angle format conversion\nlon_deg = loc.longitude(bh.AngleFormat.DEGREES)\nlon_rad = loc.longitude(bh.AngleFormat.RADIANS)\n</code></pre> <p>Coordinate Conventions: - Longitude: -180\u00b0 to +180\u00b0 (negative = West, positive = East) - Latitude: -90\u00b0 to +90\u00b0 (negative = South, positive = North) - Altitude: Height above WGS84 ellipsoid (meters) - ECEF: Earth-fixed Cartesian coordinates (meters)</p>"},{"location":"learn/access_computation/locations.html#geojson-integration","title":"GeoJSON Integration","text":"<p>Point locations seamlessly convert to/from GeoJSON Feature format:</p> <pre><code>import brahe as bh\nimport json\n\n# Create from GeoJSON\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 500.0]  # [lon, lat, alt]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\",\n        \"country\": \"Norway\"\n    }\n}\n\nloc = bh.PointLocation.from_geojson(geojson)\n\n# Export to GeoJSON\ngeojson = loc.to_geojson()\nprint(json.dumps(geojson, indent=2))\n</code></pre> <p>GeoJSON format details: - Coordinates: <code>[longitude, latitude, altitude]</code> (note lon/lat order!) - Altitude is optional (defaults to 0.0) - Properties include identity fields (name, id, uuid) plus custom metadata - Fully compatible with QGIS, GeoPandas, and other GIS tools</p>"},{"location":"learn/access_computation/locations.html#use-cases","title":"Use Cases","text":"<p>Ground Stations: <pre><code># Ground station network\nstations = [\n    bh.PointLocation(15.4, 78.2, 0.0).with_name(\"Svalbard\"),\n    bh.PointLocation(-64.5, -31.5, 0.0).with_name(\"Malargue\"),\n    bh.PointLocation(-117.2, 34.1, 0.0).with_name(\"Goldstone\"),\n]\n\nfor station in stations:\n    station.add_property(\"elevation_mask_deg\", 5.0)\n    station.add_property(\"max_data_rate_mbps\", 300.0)\n</code></pre></p> <p>Imaging Targets: <pre><code># Points of interest\ntargets = [\n    bh.PointLocation(2.3, 48.9, 0.0)\n        .with_name(\"Paris\")\n        .add_property(\"priority\", \"high\")\n        .add_property(\"min_off_nadir_deg\", 5.0)\n        .add_property(\"max_off_nadir_deg\", 30.0),\n\n    bh.PointLocation(139.7, 35.7, 0.0)\n        .with_name(\"Tokyo\")\n        .add_property(\"priority\", \"medium\")\n        .add_property(\"cloud_tolerance_pct\", 20.0),\n]\n</code></pre></p> <p>Grid Tessellation: <pre><code># Create global grid\nimport numpy as np\n\ngrid_points = []\nfor lat in np.arange(-90, 90, 10):\n    for lon in np.arange(-180, 180, 10):\n        point = bh.PointLocation(lon, lat, 0.0) \\\n            .with_name(f\"Grid_{lat}_{lon}\") \\\n            .add_property(\"grid_cell_id\", f\"{lat}_{lon}\")\n        grid_points.append(point)\n\nprint(f\"Created {len(grid_points)} grid points\")\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#polygonlocation","title":"PolygonLocation","text":"<p>Polygon locations represent areas on Earth's surface, such as:</p> <ul> <li>Areas of interest (countries, regions, sea zones)</li> <li>Imaging swaths and coverage footprints</li> </ul>"},{"location":"learn/access_computation/locations.html#creating-polygon-locations","title":"Creating Polygon Locations","text":"<pre><code>import brahe as bh\nfrom nalgebra import Vector3  # From brahe Rust bindings\nimport numpy as np\n\n# Define vertices [lon, lat, alt]\nvertices = [\n    Vector3(10.0, 50.0, 0.0),\n    Vector3(11.0, 50.0, 0.0),\n    Vector3(11.0, 51.0, 0.0),\n    Vector3(10.0, 51.0, 0.0),\n    Vector3(10.0, 50.0, 0.0),  # Closed polygon (first == last)\n]\n\n# Create polygon\naoi = bh.PolygonLocation(vertices).with_name(\"AOI-1\")\n\n# Auto-closure: First/last vertex don't need to match\nvertices = [\n    Vector3(10.0, 50.0, 0.0),\n    Vector3(11.0, 50.0, 0.0),\n    Vector3(11.0, 51.0, 0.0),\n    Vector3(10.0, 51.0, 0.0),\n    # Last vertex automatically added to close polygon\n]\naoi = bh.PolygonLocation(vertices)  # Auto-closed\n\n# With properties\nregion = bh.PolygonLocation(vertices) \\\n    .with_name(\"Europe-Central\") \\\n    .add_property(\"population_millions\", 82) \\\n    .add_property(\"min_cloud_free_pct\", 80)\n</code></pre>"},{"location":"learn/access_computation/locations.html#polygon-properties","title":"Polygon Properties","text":"<p>Polygons compute their centroid automatically:</p> <pre><code>poly = bh.PolygonLocation(vertices)\n\n# Centroid coordinates\ncenter_lon = poly.lon  # Average longitude\ncenter_lat = poly.lat  # Average latitude\ncenter_alt = poly.alt  # Average altitude\n\n# Vertex access\nverts = poly.vertices  # All vertices (including closure)\nnum_unique = poly.num_vertices  # Excluding closure vertex\n\n# ECEF center\necef_center = poly.center_ecef\n</code></pre>"},{"location":"learn/access_computation/locations.html#geojson-for-polygons","title":"GeoJSON for Polygons","text":"<pre><code># Create from GeoJSON\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[  # Note: nested array for outer ring\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\",\n        \"region\": \"Europe\"\n    }\n}\n\npoly = bh.PolygonLocation.from_geojson(geojson)\n\n# Export to GeoJSON\ngeojson = poly.to_geojson()\n</code></pre> <p>Polygon GeoJSON notes: - Coordinates are nested: <code>[[[lon, lat, alt], ...]]</code> (outer ring) - First and last vertex must match (closed) - All vertices must be unique (except closure)</p> Polygon Validity <p>Polygons must not contain holes.</p>"},{"location":"learn/access_computation/locations.html#use-cases_1","title":"Use Cases","text":"<p>Coverage Analysis: <pre><code># Define coverage regions\nregions = [\n    bh.PolygonLocation([\n        Vector3(-10.0, 35.0, 0.0),\n        Vector3(40.0, 35.0, 0.0),\n        Vector3(40.0, 70.0, 0.0),\n        Vector3(-10.0, 70.0, 0.0),\n    ]).with_name(\"Europe\"),\n\n    bh.PolygonLocation([\n        Vector3(-125.0, 25.0, 0.0),\n        Vector3(-65.0, 25.0, 0.0),\n        Vector3(-65.0, 50.0, 0.0),\n        Vector3(-125.0, 50.0, 0.0),\n    ]).with_name(\"North-America\"),\n]\n</code></pre></p> <p>Sensor Footprint: <pre><code># Imaging sensor footprint (simplified rectangular approximation)\ndef create_footprint(center_lon, center_lat, width_deg, height_deg):\n    \"\"\"Create rectangular footprint around center point\"\"\"\n    half_w = width_deg / 2.0\n    half_h = height_deg / 2.0\n\n    vertices = [\n        Vector3(center_lon - half_w, center_lat - half_h, 0.0),\n        Vector3(center_lon + half_w, center_lat - half_h, 0.0),\n        Vector3(center_lon + half_w, center_lat + half_h, 0.0),\n        Vector3(center_lon - half_w, center_lat + half_h, 0.0),\n    ]\n\n    return bh.PolygonLocation(vertices)\n\n# Create footprints\nfootprint1 = create_footprint(15.0, 50.0, 2.0, 1.5) \\\n    .with_name(\"Footprint-1\") \\\n    .add_property(\"swath_width_km\", 100.0)\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#extensible-properties","title":"Extensible Properties","text":"<p>Both location types support arbitrary metadata through a properties dictionary:</p>"},{"location":"learn/access_computation/locations.html#adding-properties","title":"Adding Properties","text":"<pre><code>loc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Builder pattern\nloc = loc.add_property(\"country\", \"Norway\") \\\n         .add_property(\"elevation_mask_deg\", 5.0) \\\n         .add_property(\"operational_hours\", [8, 18])\n\n# Direct access\nprops = loc.properties()\ncountry = props.get(\"country\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#common-property-patterns","title":"Common Property Patterns","text":"<p>Ground Station Metadata: <pre><code>station = bh.PointLocation(lon, lat, alt) \\\n    .with_name(\"Station-1\") \\\n    .add_property(\"operator\", \"ESA\") \\\n    .add_property(\"dish_diameter_m\", 15.0) \\\n    .add_property(\"frequency_bands\", [\"X\", \"Ka\"]) \\\n    .add_property(\"max_data_rate_mbps\", 800.0) \\\n    .add_property(\"elevation_mask_deg\", 5.0) \\\n    .add_property(\"operational_24_7\", True)\n</code></pre></p> <p>Imaging Target Constraints: <pre><code>target = bh.PointLocation(lon, lat, 0.0) \\\n    .with_name(\"Target-Alpha\") \\\n    .add_property(\"priority\", 10) \\\n    .add_property(\"min_off_nadir_deg\", 0.0) \\\n    .add_property(\"max_off_nadir_deg\", 30.0) \\\n    .add_property(\"preferred_look_direction\", \"RIGHT\") \\\n    .add_property(\"min_sun_elevation_deg\", 10.0) \\\n    .add_property(\"max_cloud_cover_pct\", 20.0)\n</code></pre></p>"},{"location":"learn/access_computation/locations.html#identification-and-traceability","title":"Identification and Traceability","text":"<p>All locations implement the <code>Identifiable</code> trait for tracking and association:</p>"},{"location":"learn/access_computation/locations.html#identity-methods","title":"Identity Methods","text":"<pre><code># Name-based identification\nloc = bh.PointLocation(lon, lat, alt).with_name(\"Station-1\")\nassert loc.get_name() == \"Station-1\"\n\n# Numeric ID\nloc = loc.with_id(42)\nassert loc.get_id() == 42\n\n# UUID for global uniqueness\nimport uuid\nmy_uuid = uuid.uuid4()\nloc = loc.with_uuid(my_uuid)\nassert loc.get_uuid() == my_uuid\n\n# Or generate new UUID\nloc = loc.with_new_uuid()\nassert loc.get_uuid() is not None\n\n# Combined identity\nloc = loc.with_identity(\n    name=\"Station-1\",\n    uuid=my_uuid,\n    id=42\n)\n</code></pre>"},{"location":"learn/access_computation/locations.html#linking-locations-to-access-windows","title":"Linking Locations to Access Windows","text":"<p>Access windows preserve location and propagator identifiers:</p> <pre><code>windows = bh.location_accesses(locations, propagators, start, end, constraint)\n\nfor window in windows:\n    # Identifiers stored in window\n    loc_id = window.location_id\n    prop_id = window.propagator_id\n\n    # Find original location/propagator by ID\n    matching_loc = next(l for l in locations if l.get_id() == loc_id)\n    matching_prop = next(p for p in propagators if p.get_id() == prop_id)\n\n    print(f\"Access: {matching_prop.get_name()} -&gt; {matching_loc.get_name()}\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/access_computation/locations.html#loading-locations-from-geojson","title":"Loading Locations from GeoJSON","text":"<pre><code>import json\nimport brahe as bh\n\n# Load GeoJSON FeatureCollection\nwith open(\"ground_stations.geojson\") as f:\n    data = json.load(f)\n\nlocations = []\nfor feature in data[\"features\"]:\n    loc = bh.PointLocation.from_geojson(feature)\n    locations.append(loc)\n\nprint(f\"Loaded {len(locations)} locations\")\n</code></pre>"},{"location":"learn/access_computation/locations.html#exporting-results-to-geojson","title":"Exporting Results to GeoJSON","text":"<pre><code># Collect access results\nwindows = bh.location_accesses(locations, propagators, start, end, constraint)\n\n# Create GeoJSON with access statistics\nfeatures = []\nfor loc in locations:\n    # Find all windows for this location\n    loc_windows = [w for w in windows if w.location_id == loc.get_id()]\n\n    # Add access statistics to properties\n    loc = loc.add_property(\"total_passes\", len(loc_windows))\n    loc = loc.add_property(\"total_duration_sec\", sum(w.duration for w in loc_windows))\n\n    features.append(loc.to_geojson())\n\n# Export FeatureCollection\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": features\n}\n\nwith open(\"access_results.geojson\", \"w\") as f:\n    json.dump(geojson, f, indent=2)\n</code></pre>"},{"location":"learn/access_computation/locations.html#custom-property-computation","title":"Custom Property Computation","text":"<pre><code># Compute derived properties\nfor loc in locations:\n    # Geographic region classification\n    if loc.lat() &gt; 60:\n        region = \"polar\"\n    elif abs(loc.lat()) &lt; 23.5:\n        region = \"tropical\"\n    else:\n        region = \"temperate\"\n\n    loc = loc.add_property(\"climate_region\", region)\n\n    # Sun-synchronous orbit access potential\n    if 96.0 &lt;= abs(loc.lat()) &lt;= 100.0:\n        loc = loc.add_property(\"sso_compatible\", True)\n</code></pre>"},{"location":"learn/access_computation/locations.html#see-also","title":"See Also","text":"<ul> <li>Constraints - Defining access criteria for locations</li> <li>Computation - Access algorithms and property computation</li> <li>API Reference: Locations</li> <li>Example: Predicting Ground Contacts</li> </ul>"},{"location":"learn/access_computation/properties.html","title":"Access Properties","text":"<p>Access properties provide additional information about satellite-location access windows.</p>"},{"location":"learn/access_computation/properties.html#overview","title":"Overview","text":"<p>When computing access between satellites and ground locations, you can extract various properties for each access window such as:</p> <ul> <li>Maximum elevation angle</li> <li>Azimuth and elevation at specific times</li> <li>Range and range rate</li> <li>Local time of access</li> </ul>"},{"location":"learn/access_computation/properties.html#property-types","title":"Property Types","text":"<p>Properties can be computed at different points during an access window:</p> <ul> <li>At access start: Initial conditions when satellite becomes visible</li> <li>At maximum elevation: Conditions at the peak of the pass</li> <li>At access end: Final conditions when satellite is no longer visible</li> </ul>"},{"location":"learn/access_computation/properties.html#see-also","title":"See Also","text":"<ul> <li>Access Computation Overview</li> <li>Constraints</li> <li>Locations</li> </ul>"},{"location":"learn/attitude_representations/index.html","title":"Attitude Representations","text":"<p>Brahe supports multiple mathematical representations for 3D rotations and spacecraft attitude.</p>"},{"location":"learn/attitude_representations/index.html#overview","title":"Overview","text":"<p>Attitude representation is fundamental to spacecraft dynamics and control. Brahe provides four different representations, each with their own advantages:</p> <ul> <li>Quaternions: Singularity-free, compact representation (4 parameters)</li> <li>Rotation Matrices: Direct transformation matrices (9 parameters)</li> <li>Euler Angles: Intuitive angular representation (3 parameters, but with singularities)</li> <li>Euler Axis: Axis-angle representation (4 parameters)</li> </ul>"},{"location":"learn/attitude_representations/index.html#choosing-a-representation","title":"Choosing a Representation","text":"<p>Use Quaternions when: - Numerical stability is critical - Interpolating between attitudes - Propagating attitude dynamics</p> <p>Use Rotation Matrices when: - Transforming vectors between frames - Maximum computational speed is needed</p> <p>Use Euler Angles when: - Human readability is important - Working with small attitude changes - Avoiding gimbal lock singularities</p> <p>Use Euler Axis when: - Representing single rotations about an axis - Geometric interpretation is important</p>"},{"location":"learn/attitude_representations/index.html#conversions","title":"Conversions","text":"<p>All representations can be converted between each other using built-in conversion functions.</p>"},{"location":"learn/attitude_representations/index.html#see-also","title":"See Also","text":"<ul> <li>API Reference - Attitude</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html","title":"Euler Angles","text":"<p>Euler angles represent rotations as three sequential rotations about coordinate axes.</p>"},{"location":"learn/attitude_representations/euler_angles.html#overview","title":"Overview","text":"<p>Euler angles describe orientation using three angles representing sequential rotations about specified axes. Brahe supports all 12 possible Euler angle sequences (e.g., XYZ, ZYX, ZYZ).</p>"},{"location":"learn/attitude_representations/euler_angles.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler angle rotation is specified by:</p> <ul> <li>Three angles: \\((\\alpha, \\beta, \\gamma)\\)</li> <li>A rotation sequence (e.g., XYZ, ZYX)</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#common-sequences","title":"Common Sequences","text":"<ul> <li>ZYX (Yaw-Pitch-Roll): Common in aerospace applications</li> <li>XYZ: Common in robotics</li> <li>ZYZ: Common in classical mechanics</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#advantages","title":"Advantages","text":"<ul> <li>Intuitive: Easy to visualize and understand</li> <li>Minimal: Only 3 parameters</li> <li>Human-readable: Natural for manual input</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#disadvantages","title":"Disadvantages","text":"<ul> <li>Gimbal lock: Singularities occur when middle rotation is \u00b190\u00b0</li> <li>Ambiguous: Multiple angle sets can represent same orientation</li> <li>Interpolation: Non-linear, difficult to interpolate smoothly</li> </ul>"},{"location":"learn/attitude_representations/euler_angles.html#gimbal-lock","title":"Gimbal Lock","text":"<p>Gimbal lock occurs when the middle rotation approaches \u00b190 degrees, causing loss of one degree of freedom. Use quaternions to avoid this issue.</p>"},{"location":"learn/attitude_representations/euler_angles.html#see-also","title":"See Also","text":"<ul> <li>Euler Angles API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html","title":"Euler Axis (Axis-Angle)","text":"<p>The Euler axis representation describes rotations using a rotation axis and angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#overview","title":"Overview","text":"<p>Also known as axis-angle representation, this describes any rotation as a single rotation about a unit vector (axis) by a specified angle.</p>"},{"location":"learn/attitude_representations/euler_axis.html#mathematical-representation","title":"Mathematical Representation","text":"<p>An Euler axis rotation is specified by:</p> <ul> <li>Unit vector (axis): \\(\\hat{n} = [n_x, n_y, n_z]\\) where \\(|\\hat{n}| = 1\\)</li> <li>Rotation angle: \\(\\theta\\) (in radians)</li> </ul> <p>Together: \\([\\theta, n_x, n_y, n_z]\\) (4 parameters)</p>"},{"location":"learn/attitude_representations/euler_axis.html#rodrigues-rotation-formula","title":"Rodrigues' Rotation Formula","text":"<p>Any vector \\(\\vec{v}\\) can be rotated about axis \\(\\hat{n}\\) by angle \\(\\theta\\) using:</p> \\[\\vec{v}_{rot} = \\vec{v}\\cos\\theta + (\\hat{n} \\times \\vec{v})\\sin\\theta + \\hat{n}(\\hat{n} \\cdot \\vec{v})(1-\\cos\\theta)\\]"},{"location":"learn/attitude_representations/euler_axis.html#advantages","title":"Advantages","text":"<ul> <li>Intuitive: Natural geometric interpretation</li> <li>Minimal representation: Efficient for single rotations</li> <li>Useful for visualization: Easy to show rotation axis</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html#disadvantages","title":"Disadvantages","text":"<ul> <li>Composition complexity: Combining rotations is not straightforward</li> <li>Singularity at zero rotation: Axis becomes undefined</li> <li>Interpolation: Non-linear</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html#applications","title":"Applications","text":"<p>Best used for:</p> <ul> <li>Visualizing rotation axes</li> <li>Specifying rotations geometrically</li> <li>Converting from/to other representations</li> </ul>"},{"location":"learn/attitude_representations/euler_axis.html#see-also","title":"See Also","text":"<ul> <li>Euler Axis API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/quaternions.html","title":"Quaternions","text":"<p>Quaternions provide a singularity-free representation of 3D rotations.</p>"},{"location":"learn/attitude_representations/quaternions.html#overview","title":"Overview","text":"<p>A quaternion is a four-element mathematical object that can represent any 3D rotation without singularities. In Brahe, quaternions use the scalar-first convention: <code>[w, x, y, z]</code>.</p>"},{"location":"learn/attitude_representations/quaternions.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A unit quaternion is defined as:</p> \\[q = [w, x, y, z]\\] <p>where \\(w^2 + x^2 + y^2 + z^2 = 1\\)</p>"},{"location":"learn/attitude_representations/quaternions.html#advantages","title":"Advantages","text":"<ul> <li>No singularities: Unlike Euler angles, quaternions work for all orientations</li> <li>Compact: Only 4 parameters (vs 9 for rotation matrices)</li> <li>Efficient: Quaternion multiplication is faster than matrix multiplication</li> <li>Interpolation: SLERP (Spherical Linear Interpolation) provides smooth attitude interpolation</li> </ul>"},{"location":"learn/attitude_representations/quaternions.html#operations","title":"Operations","text":"<p>Common quaternion operations include:</p> <ul> <li>Quaternion multiplication (composition of rotations)</li> <li>Quaternion conjugate (inverse rotation)</li> <li>Quaternion normalization</li> <li>Vector rotation</li> </ul>"},{"location":"learn/attitude_representations/quaternions.html#see-also","title":"See Also","text":"<ul> <li>Quaternion API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html","title":"Rotation Matrices","text":"<p>Rotation matrices (Direction Cosine Matrices) represent rotations as 3\u00d73 orthogonal matrices.</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#overview","title":"Overview","text":"<p>A rotation matrix is a 3\u00d73 matrix that transforms vectors from one coordinate frame to another. Also known as Direction Cosine Matrices (DCM).</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#mathematical-representation","title":"Mathematical Representation","text":"<p>A rotation matrix \\(R\\) satisfies:</p> \\[R^T R = I\\] \\[\\det(R) = 1\\] <p>where \\(I\\) is the identity matrix.</p>"},{"location":"learn/attitude_representations/rotation_matrices.html#advantages","title":"Advantages","text":"<ul> <li>Direct transformations: Multiply matrix by vector to transform</li> <li>Intuitive: Each column/row represents a coordinate axis</li> <li>Fast computation: Matrix multiplication is highly optimized</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html#disadvantages","title":"Disadvantages","text":"<ul> <li>Redundant: 9 parameters represent only 3 degrees of freedom</li> <li>Numerical drift: Orthogonality can degrade with repeated operations</li> <li>Storage: Requires more memory than quaternions</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html#operations","title":"Operations","text":"<p>Common rotation matrix operations:</p> <ul> <li>Matrix multiplication (composition)</li> <li>Matrix transpose (inverse rotation)</li> <li>Vector transformation</li> <li>Orthogonalization (Gram-Schmidt)</li> </ul>"},{"location":"learn/attitude_representations/rotation_matrices.html#see-also","title":"See Also","text":"<ul> <li>Rotation Matrix API Reference</li> <li>Attitude Representations Overview</li> </ul>"},{"location":"learn/cli/index.html","title":"Brahe CLI","text":"<p>The Brahe command-line interface provides tools for orbital mechanics, time system conversions, satellite operations, and astrodynamics calculations.</p>"},{"location":"learn/cli/index.html#installation","title":"Installation","text":"<p>The CLI is included with the Brahe Python package:</p> <pre><code>pip install brahe\n# or\nuv pip install brahe\n</code></pre>"},{"location":"learn/cli/index.html#quick-start","title":"Quick Start","text":"<pre><code># Get help\nbrahe --help\n\n# Convert between time formats\nbrahe time convert \"2024-01-01T00:00:00Z\" string mjd\n\n# Calculate orbital period\nbrahe orbits orbital-period \"R_EARTH+500e3\"\n\n# Transform coordinates between representations\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n\n# Compute satellite access windows\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060\n</code></pre>"},{"location":"learn/cli/index.html#command-groups","title":"Command Groups","text":""},{"location":"learn/cli/index.html#transform","title":"transform","text":"<p>Convert between coordinate systems and reference frames: - <code>frame</code> - Transform states between ECI and ECEF frames - <code>coordinates</code> - Convert between Keplerian, Cartesian, Geodetic, and Geocentric representations - <code>attitude</code> - Convert between attitude representations (planned)</p>"},{"location":"learn/cli/index.html#time","title":"time","text":"<p>Time system operations and conversions: - <code>convert</code> - Convert between time formats (MJD, JD, GPS, ISO-8601) - <code>add</code> - Add time offsets to epochs - <code>time-system-offset</code> - Calculate offsets between time systems - <code>range</code> - Generate time ranges</p>"},{"location":"learn/cli/index.html#orbits","title":"orbits","text":"<p>Orbital mechanics calculations: - <code>orbital-period</code> - Calculate orbital period from semi-major axis - <code>sma-from-period</code> - Calculate semi-major axis from period - <code>mean-motion</code> - Calculate mean motion - <code>anomaly-conversion</code> - Convert between anomaly types - <code>sun-sync-inclination</code> - Calculate sun-synchronous inclination - <code>perigee-velocity</code> / <code>apogee-velocity</code> - Calculate velocities at apsides</p>"},{"location":"learn/cli/index.html#eop","title":"eop","text":"<p>Earth Orientation Parameter operations: - <code>download</code> - Download EOP data from IERS - <code>get-utc-ut1</code> - Get UTC-UT1 offset - <code>get-polar-motion</code> - Get polar motion parameters - <code>get-cip-offset</code> - Get CIP offset - <code>get-lod</code> - Get length of day</p>"},{"location":"learn/cli/index.html#access","title":"access","text":"<p>Satellite access window calculations: - <code>compute</code> - Calculate visibility windows for ground stations</p>"},{"location":"learn/cli/index.html#datasets","title":"datasets","text":"<p>Download and query satellite data: - <code>celestrak</code> - CelesTrak TLE data operations - <code>groundstations</code> - Ground station database operations</p>"},{"location":"learn/cli/index.html#global-options","title":"Global Options","text":"<pre><code>--verbose, -v    Enable verbose output (INFO level)\n--debug, -d      Enable debug output (DEBUG level)\n--help           Show help message\n</code></pre>"},{"location":"learn/cli/index.html#features","title":"Features","text":""},{"location":"learn/cli/index.html#constant-expressions","title":"Constant Expressions","text":"<p>Many numeric arguments support mathematical expressions using Brahe constants:</p> <pre><code># Use R_EARTH constant for semi-major axis (500km altitude LEO)\nbrahe orbits orbital-period \"R_EARTH+500e3\"\n\n# Multiple constants in calculations\nbrahe orbits sma-from-period \"2*3.14159*sqrt((R_EARTH+35786e3)^3/GM_EARTH)\" --units seconds\n</code></pre> <p>Available constants include: - <code>R_EARTH</code>, <code>R_SUN</code>, <code>R_MOON</code> - Body radii (meters) - <code>GM_EARTH</code>, <code>GM_SUN</code>, <code>GM_MOON</code> - Gravitational parameters (m\u00b3/s\u00b2) - <code>DEG2RAD</code>, <code>RAD2DEG</code> - Angular conversions - <code>MJD_ZERO</code>, <code>MJD2000</code>, <code>GPS_ZERO</code> - Time epoch constants</p> <p>See the Constants documentation for the complete list.</p>"},{"location":"learn/cli/index.html#angle-formats","title":"Angle Formats","text":"<p>Commands that handle angles typically support both degrees and radians:</p> <pre><code># Degrees (default for most commands)\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 45 --as-degrees\n\n# Radians\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 1.706 0 0 0.785 --no-as-degrees\n</code></pre>"},{"location":"learn/cli/index.html#output-formatting","title":"Output Formatting","text":"<p>Control numeric output precision with <code>--format</code>:</p> <pre><code># Default floating-point\nbrahe orbits orbital-period \"R_EARTH+500e3\"\n# Output: 5673.281746\n\n# High precision\nbrahe orbits orbital-period \"R_EARTH+500e3\" --format .10f\n# Output: 5673.2817464420\n\n# Scientific notation\nbrahe orbits orbital-period \"R_EARTH+500e3\" --format .3e\n# Output: 5.673e+03\n</code></pre>"},{"location":"learn/cli/index.html#earth-orientation-parameters","title":"Earth Orientation Parameters","text":"<p>Commands involving reference frame transformations (ECI \u2194 ECEF) automatically download and cache Earth Orientation Parameter (EOP) data from IERS on first use:</p> <pre><code># EOP data automatically downloaded for frame transformations\nbrahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n\n# Manually download/update EOP data\nbrahe eop download ~/.cache/brahe/iau2000_standard.txt --product standard\n</code></pre> <p>Cache location: <code>~/.cache/brahe/</code></p>"},{"location":"learn/cli/index.html#time-formats","title":"Time Formats","text":"<p>Epochs can be specified in multiple formats:</p> <p>ISO-8601 strings (most common): <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string mjd\nbrahe transform frame ECI ECEF \"2024-01-01T12:30:45.123Z\" 6878137 0 0 0 7500 0\n</code></pre></p> <p>Modified Julian Date (MJD): <pre><code>brahe time convert 60310.0 mjd string --output-time-system UTC\n</code></pre></p> <p>Julian Date (JD): <pre><code>brahe time convert 2460310.5 jd string\n</code></pre></p> <p>GPS time: <pre><code>brahe time convert \"1356998418.0\" gps_nanoseconds string\n</code></pre></p>"},{"location":"learn/cli/index.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/index.html#satellite-state-conversion","title":"Satellite State Conversion","text":"<pre><code># 1. Start with Keplerian elements (SSO, 500km altitude)\nKEP=\"6878137 0.001 97.8 0 0 0\"\n\n# 2. Convert to ECI Cartesian\nbrahe transform coordinates keplerian cartesian \"\" $KEP --as-degrees\n\n# 3. Convert to ECEF at specific epoch\nbrahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6871258.863 0.0 0.0 0.0 -1034.183 7549.721\n\n# 4. Convert to geodetic coordinates\nbrahe transform coordinates cartesian geodetic \"2024-01-01T00:00:00Z\" \\\n  -1176064.179 -6776827.197 15961.825 6895.377 -1196.637 0.241 \\\n  --from-frame ECEF --as-degrees\n</code></pre>"},{"location":"learn/cli/index.html#ground-station-passes","title":"Ground Station Passes","text":"<pre><code># Find ISS passes over New York City\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060 --duration 7\n\n# Use ground station database\nbrahe access compute 25544 --gs-provider ksat --gs-name \"Svalbard\"\n\n# Export to JSON\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-file passes.json\n</code></pre>"},{"location":"learn/cli/index.html#orbital-design","title":"Orbital Design","text":"<pre><code># Design a sun-synchronous orbit at 600km altitude\nSMA=\"R_EARTH+600e3\"\nECC=\"0.001\"\n\n# Calculate required inclination\nINC=$(brahe orbits sun-sync-inclination \"$SMA\" \"$ECC\" --as-degrees)\n\n# Calculate period\nbrahe orbits orbital-period \"$SMA\" --units minutes\n\n# Calculate mean motion\nbrahe orbits mean-motion \"$SMA\"\n</code></pre>"},{"location":"learn/cli/index.html#see-also","title":"See Also","text":"<ul> <li>Python API Documentation</li> <li>Coordinate Systems</li> <li>Time Systems</li> <li>Orbital Mechanics</li> </ul>"},{"location":"learn/cli/access.html","title":"Access Commands","text":"<p>Satellite access window computation for ground stations.</p>"},{"location":"learn/cli/access.html#overview","title":"Overview","text":"<p>The <code>access</code> command group calculates when satellites are visible from ground locations, considering elevation constraints and other visibility criteria.</p>"},{"location":"learn/cli/access.html#commands","title":"Commands","text":""},{"location":"learn/cli/access.html#compute","title":"<code>compute</code>","text":"<p>Compute satellite access windows for a ground location.</p> <p>Syntax: <pre><code>brahe access compute &lt;NORAD_ID&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID of the satellite (integer)</p> <p>Location Options (choose one):</p> <p>Location coordinates: - <code>--lat &lt;degrees&gt;</code> - Latitude in degrees (-90 to 90) - <code>--lon &lt;degrees&gt;</code> - Longitude in degrees (-180 to 180) - <code>--alt &lt;meters&gt;</code> - Altitude above WGS84 ellipsoid (default: 0.0)</p> <p>Or ground station lookup: - <code>--gs-provider &lt;name&gt;</code> - Ground station provider (e.g., 'ksat', 'atlas', 'aws') - <code>--gs-name &lt;name&gt;</code> - Ground station name to lookup</p> <p>Time Range Options:</p> <ul> <li><code>--start-time &lt;epoch&gt;</code> - Start time (ISO-8601). Default: now</li> <li><code>--end-time &lt;epoch&gt;</code> - End time (ISO-8601)</li> <li><code>--duration &lt;days&gt;</code> - Duration in days (default: 7)</li> </ul> <p>Constraint Options:</p> <ul> <li><code>--min-elevation &lt;degrees&gt;</code> - Minimum elevation angle (default: 10.0)</li> </ul> <p>Output Options:</p> <ul> <li><code>--output-format [table|rich|simple]</code> - Output format (default: <code>table</code>)</li> <li><code>--sort-by [contact_number|start_time|end_time|duration|max_elevation|start_azimuth|end_azimuth]</code> - Sort field (default: <code>start_time</code>)</li> <li><code>--sort-order [ascending|descending]</code> - Sort order (default: <code>ascending</code>)</li> <li><code>--max-results &lt;count&gt;</code> - Maximum number of windows to display</li> <li><code>--output-file &lt;path&gt;</code> - Export results to JSON file</li> </ul> <p>Examples:</p> <p>ISS passes over New York City (next 7 days): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060\n</code></pre> Output (table format): <pre><code>Contact | Start Time           | End Time             | Duration | Max El. | Start Az | End Az\n--------|----------------------|----------------------|----------|---------|----------|--------\n1       | 2024-01-01 06:23:15  | 2024-01-01 06:31:42  | 507s     | 45.2\u00b0   | 185\u00b0 (S) | 78\u00b0 (E)\n2       | 2024-01-01 08:01:33  | 2024-01-01 08:09:18  | 465s     | 38.7\u00b0   | 230\u00b0 (SW)| 25\u00b0 (NE)\n...\n</code></pre></p> <p>GPS satellite passes (15\u00b0 minimum elevation): <pre><code>brahe access compute 32260 --lat 40.7128 --lon -74.0060 --min-elevation 15\n</code></pre></p> <p>Custom time range: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --start-time \"2024-06-01T00:00:00Z\" \\\n  --duration 1\n</code></pre></p> <p>Use ground station database: <pre><code>brahe access compute 25544 --gs-provider ksat --gs-name \"Svalbard\"\n</code></pre></p> <p>Simple output format: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-format simple\n</code></pre></p> <p>Export to JSON: <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 --output-file passes.json\n</code></pre></p> <p>Sort by maximum elevation (highest first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by max_elevation --sort-order descending --max-results 5\n</code></pre></p> <p>Sort by duration (longest passes first): <pre><code>brahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --sort-by duration --sort-order descending\n</code></pre></p>"},{"location":"learn/cli/access.html#understanding-access-windows","title":"Understanding Access Windows","text":""},{"location":"learn/cli/access.html#satellite-visibility","title":"Satellite Visibility","text":"<p>A satellite is visible from a ground location when: 1. Above the horizon (elevation &gt; 0\u00b0) 2. Meets minimum elevation constraint (default: 10\u00b0) 3. Not in Earth's shadow (for optical observations)</p>"},{"location":"learn/cli/access.html#elevation-angle","title":"Elevation Angle","text":"<p>Angle between the satellite and the local horizontal plane: - <code>0\u00b0</code> - On the horizon - <code>90\u00b0</code> - Directly overhead (zenith) - Higher elevation = better viewing conditions - Typical minimum: 5-10\u00b0 (atmospheric effects near horizon)</p>"},{"location":"learn/cli/access.html#azimuth-angle","title":"Azimuth Angle","text":"<p>Compass direction to the satellite: - <code>0\u00b0</code> / <code>360\u00b0</code> - North - <code>90\u00b0</code> - East - <code>180\u00b0</code> - South - <code>270\u00b0</code> - West</p> <p>Output shows start and end azimuth with cardinal directions: <code>185\u00b0 (S)</code>, <code>78\u00b0 (E)</code></p>"},{"location":"learn/cli/access.html#access-window-components","title":"Access Window Components","text":"<p>Each access window includes: - Start Time - When satellite rises above minimum elevation - End Time - When satellite sets below minimum elevation - Duration - Contact time in seconds - Max Elevation - Highest elevation during pass - Start/End Azimuth - Entry and exit directions</p>"},{"location":"learn/cli/access.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/access.html#daily-iss-passes","title":"Daily ISS Passes","text":"<pre><code>#!/bin/bash\n# Get today's ISS passes over a location\n\nLAT=\"40.7128\"\nLON=\"-74.0060\"\nLOCATION_NAME=\"New York City\"\n\necho \"ISS passes over $LOCATION_NAME (next 24 hours):\"\nbrahe access compute 25544 --lat $LAT --lon $LON --duration 1 --output-format rich\n</code></pre>"},{"location":"learn/cli/access.html#high-elevation-passes-only","title":"High-Elevation Passes Only","text":"<pre><code>#!/bin/bash\n# Find only the best passes (elevation &gt; 45\u00b0)\n\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --min-elevation 45 \\\n  --sort-by max_elevation --sort-order descending\n</code></pre>"},{"location":"learn/cli/access.html#multi-satellite-constellation","title":"Multi-Satellite Constellation","text":"<pre><code>#!/bin/bash\n# Check access for multiple satellites (e.g., GPS constellation)\n\nGPS_SATS=(32260 32384 38833 40105)  # Example GPS PRNs\nLAT=\"40.7128\"\nLON=\"-74.0060\"\n\nfor norad in \"${GPS_SATS[@]}\"; do\n  echo \"=== NORAD $norad ===\"\n  brahe access compute $norad --lat $LAT --lon $LON \\\n    --duration 1 --min-elevation 15 --output-format simple\n  echo\ndone\n</code></pre>"},{"location":"learn/cli/access.html#export-for-analysis","title":"Export for Analysis","text":"<pre><code>#!/bin/bash\n# Export access windows to JSON for further processing\n\nOUTPUT_DIR=\"./access_windows\"\nmkdir -p $OUTPUT_DIR\n\n# ISS passes\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --output-file \"$OUTPUT_DIR/iss_passes.json\"\n\n# HST passes\nbrahe access compute 20580 --lat 40.7128 --lon -74.0060 \\\n  --output-file \"$OUTPUT_DIR/hst_passes.json\"\n\necho \"Access windows exported to $OUTPUT_DIR\"\n</code></pre>"},{"location":"learn/cli/access.html#ground-station-network","title":"Ground Station Network","text":"<pre><code>#!/bin/bash\n# Check satellite visibility from multiple ground stations\n\nSATELLITE=25544  # ISS\nSTATIONS=(\"Svalbard\" \"Singapore\" \"Troll\")\n\nfor station in \"${STATIONS[@]}\"; do\n  echo \"=== $station ===\"\n  brahe access compute $SATELLITE --gs-provider ksat --gs-name \"$station\" --duration 7\n  echo\ndone\n</code></pre>"},{"location":"learn/cli/access.html#next-visible-pass","title":"Next Visible Pass","text":"<pre><code>#!/bin/bash\n# Find the next visible pass (max 1 result)\n\nbrahe access compute 25544 --lat 40.7128 --lon -74.0060 \\\n  --max-results 1 --output-format simple\n</code></pre>"},{"location":"learn/cli/access.html#tips","title":"Tips","text":""},{"location":"learn/cli/access.html#norad-catalog-ids","title":"NORAD Catalog IDs","text":"<p>Find NORAD IDs using the datasets command: <pre><code># Search for satellite by name\nbrahe datasets celestrak lookup \"ISS\"\n\n# Show TLE with NORAD ID\nbrahe datasets celestrak show 25544\n</code></pre></p> <p>Common satellites: - ISS: 25544 - Hubble Space Telescope: 20580 - Starlink satellites: 40000+</p>"},{"location":"learn/cli/access.html#choosing-minimum-elevation","title":"Choosing Minimum Elevation","text":"<p>Radio communications: - <code>5\u00b0</code> - Minimum for most radio links (atmospheric distortion) - <code>10\u00b0</code> - Good compromise (default) - <code>15\u00b0</code> - High-quality links</p> <p>Optical observations: - <code>15-20\u00b0</code> - Minimum for photography - <code>30\u00b0+</code> - Best conditions (less atmosphere)</p>"},{"location":"learn/cli/access.html#negative-longitudes","title":"Negative Longitudes","text":"<p>For western longitudes, use negative values or <code>--</code>: <pre><code># Method 1: Negative longitude\nbrahe access compute 25544 --lat 40.7128 --lon=-74.0060\n\n# Method 2: After -- separator\nbrahe access compute 25544 -- --lat 40.7128 --lon -74.0060\n</code></pre></p>"},{"location":"learn/cli/access.html#output-formats","title":"Output Formats","text":"<p>table (default): - ASCII table with columns - Good for terminal viewing - Aligned columns</p> <p>rich: - Enhanced table with colors - Better readability in modern terminals</p> <p>simple: - Plain text, one line per pass - Easy to parse with scripts</p> <p>JSON (via <code>--output-file</code>): - Machine-readable - Complete data structure - For further processing</p>"},{"location":"learn/cli/access.html#performance","title":"Performance","text":"<p>Computing access windows requires: 1. Downloading TLE data from CelesTrak (cached) 2. Downloading EOP data (cached) 3. Propagating orbit over time range</p> <p>Longer durations take more time: - 1 day: ~1-2 seconds - 7 days: ~5-10 seconds - 30 days: ~20-30 seconds</p>"},{"location":"learn/cli/access.html#see-also","title":"See Also","text":"<ul> <li>Ground Contacts Example - Detailed access computation examples</li> <li>Datasets CLI - Find NORAD IDs and download TLEs</li> <li>Groundstations Dataset - Ground station database</li> <li>Access API - Python access computation functions</li> </ul>"},{"location":"learn/cli/datasets.html","title":"Datasets Commands","text":"<p>Download and query satellite ephemeris data and ground station information.</p>"},{"location":"learn/cli/datasets.html#overview","title":"Overview","text":"<p>The <code>datasets</code> command group provides access to: - CelesTrak - Satellite TLE (Two-Line Element) data - Ground Stations - Commercial ground station network databases</p>"},{"location":"learn/cli/datasets.html#celestrak-commands","title":"CelesTrak Commands","text":""},{"location":"learn/cli/datasets.html#celestrak-download","title":"<code>celestrak download</code>","text":"<p>Download satellite ephemeris data from CelesTrak and save to file.</p> <p>Syntax: <pre><code>brahe datasets celestrak download &lt;GROUP&gt; &lt;FILEPATH&gt;\n</code></pre></p> <p>Arguments: - <code>GROUP</code> - Satellite group name (e.g., 'stations', 'starlink', 'gps-ops') - <code>FILEPATH</code> - Output file path for TLE data</p> <p>Examples:</p> <p>Download space station TLEs: <pre><code>brahe datasets celestrak download stations ~/satellite_data/stations.txt\n</code></pre></p> <p>Download Starlink constellation: <pre><code>brahe datasets celestrak download starlink ~/satellite_data/starlink.txt\n</code></pre></p> <p>Download GPS satellites: <pre><code>brahe datasets celestrak download gps-ops ~/satellite_data/gps.txt\n</code></pre></p> <p>See available groups: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-lookup","title":"<code>celestrak lookup</code>","text":"<p>Look up a satellite by name and display its NORAD ID and TLE.</p> <p>Syntax: <pre><code>brahe datasets celestrak lookup &lt;NAME&gt;\n</code></pre></p> <p>Arguments: - <code>NAME</code> - Satellite name (partial match supported)</p> <p>Examples:</p> <p>Find ISS: <pre><code>brahe datasets celestrak lookup \"ISS\"\n</code></pre> Output: <pre><code>ISS (ZARYA)\nNORAD ID: 25544\nTLE:\n1 25544U 98067A   24001.12345678  .00001234  00000-0  12345-4 0  9991\n2 25544  51.6400 123.4567 0001234  12.3456 347.8901 15.50000000123456\n</code></pre></p> <p>Find Hubble Space Telescope: <pre><code>brahe datasets celestrak lookup \"HST\"\n</code></pre></p> <p>Find by partial name: <pre><code>brahe datasets celestrak lookup \"STARLINK\"\n</code></pre> (Shows first match)</p>"},{"location":"learn/cli/datasets.html#celestrak-show","title":"<code>celestrak show</code>","text":"<p>Display TLE information and computed orbital parameters for a satellite.</p> <p>Syntax: <pre><code>brahe datasets celestrak show &lt;NORAD_ID&gt;\n</code></pre></p> <p>Arguments: - <code>NORAD_ID</code> - NORAD catalog ID (integer)</p> <p>Examples:</p> <p>Show ISS TLE and orbit info: <pre><code>brahe datasets celestrak show 25544\n</code></pre> Output: <pre><code>Satellite: ISS (ZARYA)\nNORAD ID: 25544\n\nTLE:\n1 25544U 98067A   24001.12345678  .00001234  00000-0  12345-4 0  9991\n2 25544  51.6400 123.4567 0001234  12.3456 347.8901 15.50000000123456\n\nOrbital Parameters:\n  Epoch:           2024-01-01 02:57:46 UTC\n  Inclination:     51.6400\u00b0\n  RAAN:            123.4567\u00b0\n  Eccentricity:    0.0001234\n  Arg. of Perigee: 12.3456\u00b0\n  Mean Anomaly:    347.8901\u00b0\n  Mean Motion:     15.50000000 rev/day\n\nComputed:\n  Period:          92.9 minutes\n  Semi-major axis: 6797.1 km\n  Apogee altitude: 420.2 km\n  Perigee altitude: 417.1 km\n</code></pre></p> <p>Show GPS satellite: <pre><code>brahe datasets celestrak show 32260\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-list-groups","title":"<code>celestrak list-groups</code>","text":"<p>List commonly used CelesTrak satellite groups.</p> <p>Syntax: <pre><code>brahe datasets celestrak list-groups\n</code></pre></p> <p>Examples: <pre><code>brahe datasets celestrak list-groups\n</code></pre> Output: <pre><code>Available CelesTrak Groups:\n\n  Navigation:\n    gps-ops           - GPS Operational Satellites\n    gps-ops-gl        - GLONASS Operational Satellites\n    galileo           - Galileo Satellites\n    beidou            - BeiDou Satellites\n\n  Communication:\n    starlink          - Starlink Constellation\n    oneweb            - OneWeb Constellation\n    iridium           - Iridium Satellites\n\n  Earth Observation:\n    resource          - Earth Resource Satellites\n    weather           - Weather Satellites\n    noaa              - NOAA Satellites\n\n  Science:\n    stations          - Space Stations (ISS, Tiangong)\n    science           - Scientific Satellites\n\n  Special Interest:\n    active            - All Active Satellites\n    analyst           - Analyst Satellites\n    2024-launches     - 2024 Launches\n</code></pre></p>"},{"location":"learn/cli/datasets.html#celestrak-search","title":"<code>celestrak search</code>","text":"<p>Search for satellites by name pattern within a group.</p> <p>Syntax: <pre><code>brahe datasets celestrak search &lt;GROUP&gt; &lt;PATTERN&gt;\n</code></pre></p> <p>Arguments: - <code>GROUP</code> - Satellite group name - <code>PATTERN</code> - Name search pattern (case-insensitive)</p> <p>Examples:</p> <p>Search for Starlink satellites: <pre><code>brahe datasets celestrak search starlink \"1234\"\n</code></pre></p> <p>Search for specific GPS satellite: <pre><code>brahe datasets celestrak search gps-ops \"GPS II\"\n</code></pre></p>"},{"location":"learn/cli/datasets.html#ground-station-commands","title":"Ground Station Commands","text":""},{"location":"learn/cli/datasets.html#groundstations-list-providers","title":"<code>groundstations list-providers</code>","text":"<p>List available ground station providers.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-providers\n</code></pre></p> <p>Examples: <pre><code>brahe datasets groundstations list-providers\n</code></pre> Output: <pre><code>Available Ground Station Providers:\n  - ksat (Kongsberg Satellite Services)\n  - atlas (Atlas Space Operations)\n  - aws (AWS Ground Station)\n  - leaf (Leaf Space)\n</code></pre></p>"},{"location":"learn/cli/datasets.html#groundstations-list-stations","title":"<code>groundstations list-stations</code>","text":"<p>List ground stations, optionally filtered by provider.</p> <p>Syntax: <pre><code>brahe datasets groundstations list-stations [OPTIONS]\n</code></pre></p> <p>Options: - <code>--provider &lt;name&gt;</code> - Filter by provider name</p> <p>Examples:</p> <p>List all ground stations: <pre><code>brahe datasets groundstations list-stations\n</code></pre></p> <p>List KSAT stations only: <pre><code>brahe datasets groundstations list-stations --provider ksat\n</code></pre> Output: <pre><code>KSAT Ground Stations:\n\n  Svalbard, Norway\n    Latitude:  78.23\u00b0 N\n    Longitude: 15.39\u00b0 E\n    Altitude:  500 m\n\n  Troll, Antarctica\n    Latitude:  72.01\u00b0 S\n    Longitude: 2.53\u00b0 E\n    Altitude:  1270 m\n\n  Singapore\n    Latitude:  1.34\u00b0 N\n    Longitude: 103.99\u00b0 E\n    Altitude:  15 m\n</code></pre></p> <p>List AWS Ground Stations: <pre><code>brahe datasets groundstations list-stations --provider aws\n</code></pre></p>"},{"location":"learn/cli/datasets.html#groundstations-show","title":"<code>groundstations show</code>","text":"<p>Show ground stations for a specific provider (deprecated - use <code>list-stations</code>).</p> <p>Syntax: <pre><code>brahe datasets groundstations show &lt;PROVIDER&gt;\n</code></pre></p> <p>Examples: <pre><code>brahe datasets groundstations show ksat\n</code></pre></p> <p>Note: This command is deprecated. Use <code>list-stations --provider &lt;name&gt;</code> instead.</p>"},{"location":"learn/cli/datasets.html#groundstations-show-all","title":"<code>groundstations show-all</code>","text":"<p>Show ground stations from all providers.</p> <p>Syntax: <pre><code>brahe datasets groundstations show-all\n</code></pre></p> <p>Examples: <pre><code>brahe datasets groundstations show-all\n</code></pre></p> <p>Note: Equivalent to <code>list-stations</code> without filters.</p>"},{"location":"learn/cli/datasets.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/datasets.html#download-satellite-data","title":"Download Satellite Data","text":"<pre><code>#!/bin/bash\n# Download TLE data for mission-relevant satellites\n\nDATA_DIR=\"./satellite_data\"\nmkdir -p \"$DATA_DIR\"\n\necho \"Downloading satellite TLE data...\"\n\n# Space stations\nbrahe datasets celestrak download stations \"$DATA_DIR/stations.txt\"\n\n# GPS constellation\nbrahe datasets celestrak download gps-ops \"$DATA_DIR/gps.txt\"\n\n# Starlink\nbrahe datasets celestrak download starlink \"$DATA_DIR/starlink.txt\"\n\n# Weather satellites\nbrahe datasets celestrak download weather \"$DATA_DIR/weather.txt\"\n\necho \"Download complete!\"\n</code></pre>"},{"location":"learn/cli/datasets.html#find-satellite-norad-id","title":"Find Satellite NORAD ID","text":"<pre><code>#!/bin/bash\n# Find NORAD ID for satellite access computation\n\nSATELLITE_NAME=\"ISS\"\n\necho \"Looking up: $SATELLITE_NAME\"\nbrahe datasets celestrak lookup \"$SATELLITE_NAME\"\n\n# Extract just the NORAD ID (for scripting)\nNORAD_ID=$(brahe datasets celestrak lookup \"$SATELLITE_NAME\" | grep \"NORAD ID:\" | awk '{print $3}')\necho \"NORAD ID: $NORAD_ID\"\n\n# Compute access windows\nbrahe access compute $NORAD_ID --lat 40.7128 --lon -74.0060\n</code></pre>"},{"location":"learn/cli/datasets.html#orbital-parameter-survey","title":"Orbital Parameter Survey","text":"<pre><code>#!/bin/bash\n# Survey orbital parameters for satellite constellation\n\nSATS=(25544 20580 43013)  # ISS, HST, sample Starlink\n\necho \"Satellite | Altitude | Inclination | Period\"\necho \"----------|----------|-------------|--------\"\n\nfor norad in \"${SATS[@]}\"; do\n  echo \"Processing NORAD $norad...\"\n  brahe datasets celestrak show $norad | grep -E \"Altitude|Inclination|Period\"\ndone\n</code></pre>"},{"location":"learn/cli/datasets.html#ground-station-selection","title":"Ground Station Selection","text":"<pre><code>#!/bin/bash\n# Select ground stations for satellite mission\n\nSATELLITE=25544  # ISS\nPROVIDERS=(\"ksat\" \"aws\" \"atlas\")\n\necho \"Evaluating ground stations for NORAD $SATELLITE\"\n\nfor provider in \"${PROVIDERS[@]}\"; do\n  echo \"\"\n  echo \"=== $provider stations ===\"\n\n  # List stations\n  brahe datasets groundstations list-stations --provider $provider\n\n  # Would compute access for each station (manual selection needed)\ndone\n</code></pre>"},{"location":"learn/cli/datasets.html#tle-data-update","title":"TLE Data Update","text":"<pre><code>#!/bin/bash\n# Regularly update TLE data for accuracy\n\nDATA_DIR=\"./satellite_data\"\nGROUPS=(\"stations\" \"gps-ops\" \"active\")\n\necho \"Updating TLE data: $(date)\"\n\nfor group in \"${GROUPS[@]}\"; do\n  echo \"Updating $group...\"\n  brahe datasets celestrak download $group \"$DATA_DIR/${group}.txt\"\ndone\n\necho \"TLE data updated: $(date)\"\n</code></pre>"},{"location":"learn/cli/datasets.html#tips","title":"Tips","text":""},{"location":"learn/cli/datasets.html#tle-data-freshness","title":"TLE Data Freshness","text":"<p>TLEs degrade over time: - LEO satellites: Update daily for accurate orbit prediction - MEO/GEO satellites: Update weekly acceptable - Mission-critical: Update before each operation</p>"},{"location":"learn/cli/datasets.html#norad-catalog-ids","title":"NORAD Catalog IDs","text":"<ul> <li>Assigned sequentially by USSPACECOM</li> <li>Unique for each satellite</li> <li>Required for most Brahe access computations</li> <li>Find via <code>celestrak lookup</code> or online databases</li> </ul>"},{"location":"learn/cli/datasets.html#celestrak-groups","title":"CelesTrak Groups","text":"<p>Common group names: - <code>stations</code> - ISS, Tiangong, etc. - <code>starlink</code> - Starlink constellation - <code>gps-ops</code> - GPS operational satellites - <code>galileo</code> - Galileo GNSS - <code>active</code> - All active satellites - <code>2024-launches</code> - Recent launches (year-specific)</p>"},{"location":"learn/cli/datasets.html#ground-station-providers","title":"Ground Station Providers","text":"<p>KSAT (Kongsberg Satellite Services): - Polar ground stations (Svalbard, Troll) - Excellent coverage for polar orbits</p> <p>AWS Ground Station: - Global network - Cloud-integrated</p> <p>Atlas Space Operations: - Freedom Network - Multiple global sites</p> <p>Leaf Space: - European and global coverage</p>"},{"location":"learn/cli/datasets.html#scripting-with-datasets","title":"Scripting with Datasets","text":"<p>Extract specific info: <pre><code># Get just NORAD ID\nbrahe datasets celestrak lookup \"ISS\" | grep \"NORAD ID:\" | awk '{print $3}'\n\n# Get orbital period\nbrahe datasets celestrak show 25544 | grep \"Period:\" | awk '{print $2, $3}'\n</code></pre></p>"},{"location":"learn/cli/datasets.html#see-also","title":"See Also","text":"<ul> <li>CelesTrak - Official TLE data source</li> <li>Two-Line Elements - Understanding Two-Line Elements</li> <li>SGP Propagation - TLE-based orbit propagation</li> <li>Access CLI - Compute satellite passes (uses TLE data)</li> <li>Datasets API - Python dataset functions</li> </ul>"},{"location":"learn/cli/eop.html","title":"EOP Commands","text":"<p>Earth Orientation Parameter operations and queries.</p>"},{"location":"learn/cli/eop.html#overview","title":"Overview","text":"<p>The <code>eop</code> command group provides access to Earth Orientation Parameters (EOP) data from IERS (International Earth Rotation and Reference Systems Service). EOP data is required for accurate transformations between ECI and ECEF reference frames.</p>"},{"location":"learn/cli/eop.html#commands","title":"Commands","text":""},{"location":"learn/cli/eop.html#download","title":"<code>download</code>","text":"<p>Download EOP data from IERS and save to file.</p> <p>Syntax: <pre><code>brahe eop download &lt;FILEPATH&gt; --product &lt;PRODUCT&gt;\n</code></pre></p> <p>Arguments: - <code>FILEPATH</code> - Output file path for EOP data</p> <p>Options: - <code>--product [standard|c04]</code> - Data product type (required)   - <code>standard</code> - Standard rapid EOP data (daily updates, ~1 year of predictions)   - <code>c04</code> - EOP 14 C04 long-term series (high accuracy, historical)</p> <p>Examples:</p> <p>Download standard EOP data: <pre><code>brahe eop download ~/.cache/brahe/iau2000_standard.txt --product standard\n</code></pre></p> <p>Download C04 long-term series: <pre><code>brahe eop download ~/.cache/brahe/iau2000_c04_20.txt --product c04\n</code></pre></p> <p>Update existing EOP file: <pre><code>brahe eop download /path/to/eop_data.txt --product standard\n</code></pre></p> <p>Default Location: The CLI automatically uses <code>~/.cache/brahe/iau2000_standard.txt</code> for frame transformations.</p>"},{"location":"learn/cli/eop.html#get-utc-ut1","title":"<code>get-utc-ut1</code>","text":"<p>Get the UTC-UT1 offset (\u0394UT1) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-utc-ut1 &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get \u0394UT1 for a specific date: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\"\n</code></pre> Output: <pre><code>-0.123456\n</code></pre></p> <p>Use custom EOP file: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --source file --filepath /path/to/eop.txt\n</code></pre></p> <p>Use C04 product: <pre><code>brahe eop get-utc-ut1 \"2024-01-01T00:00:00Z\" --product c04\n</code></pre></p> <p>Note: \u0394UT1 varies irregularly due to Earth rotation variations. Typical values: -0.9s to +0.9s.</p>"},{"location":"learn/cli/eop.html#get-polar-motion","title":"<code>get-polar-motion</code>","text":"<p>Get polar motion parameters (x_p, y_p) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-polar-motion &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get polar motion parameters: <pre><code>brahe eop get-polar-motion \"2024-01-01T00:00:00Z\"\n</code></pre> Output: <pre><code>x_p: 0.123456 (arcseconds)\ny_p: 0.234567 (arcseconds)\n</code></pre></p> <p>Note: Polar motion describes the movement of Earth's rotation axis relative to its crust. Typical magnitudes: ~0.3 arcseconds.</p>"},{"location":"learn/cli/eop.html#get-cip-offset","title":"<code>get-cip-offset</code>","text":"<p>Get Celestial Intermediate Pole (CIP) offset (dX, dY) at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-cip-offset &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get CIP offset: <pre><code>brahe eop get-cip-offset \"2024-01-01T00:00:00Z\"\n</code></pre></p> <p>Note: CIP offset represents deviations from the IAU 2006/2000A precession-nutation model.</p>"},{"location":"learn/cli/eop.html#get-lod","title":"<code>get-lod</code>","text":"<p>Get Length of Day (LOD) variation at a specific epoch.</p> <p>Syntax: <pre><code>brahe eop get-lod &lt;EPOCH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to query (ISO-8601 format)</p> <p>Options: - <code>--product [standard|c04]</code> - EOP data product (default: <code>standard</code>) - <code>--source [default|file]</code> - EOP data source (default: <code>default</code>) - <code>--filepath &lt;path&gt;</code> - Custom EOP file path (if <code>--source file</code>)</p> <p>Examples:</p> <p>Get LOD variation: <pre><code>brahe eop get-lod \"2024-01-01T00:00:00Z\"\n</code></pre> Output: <pre><code>0.001234 (seconds)\n</code></pre></p> <p>Note: LOD represents the deviation of the day length from exactly 86400 seconds due to Earth rotation variations.</p>"},{"location":"learn/cli/eop.html#earth-orientation-parameters-eop","title":"Earth Orientation Parameters (EOP)","text":""},{"location":"learn/cli/eop.html#what-is-eop","title":"What is EOP?","text":"<p>Earth Orientation Parameters describe the relationship between the terrestrial (ECEF) and celestial (ECI) reference frames. These parameters are measured because Earth's rotation is not perfectly uniform:</p> <ul> <li>Polar motion - Movement of Earth's rotation axis relative to crust</li> <li>UT1-UTC - Variation in Earth rotation speed</li> <li>Nutation offsets - Deviations from theoretical nutation model</li> <li>LOD - Length of day variations</li> </ul>"},{"location":"learn/cli/eop.html#why-eop-is-needed","title":"Why EOP is Needed","text":"<p>Accurate transformations between ECI and ECEF require EOP data:</p> <pre><code># This uses EOP data internally\nbrahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> <p>Without EOP: - Position errors: meters to kilometers - Velocity errors: millimeters/second to meters/second - Unacceptable for mission operations, collision avoidance, precise orbit determination</p>"},{"location":"learn/cli/eop.html#eop-products","title":"EOP Products","text":"<p>Standard (Rapid Service): - Updated daily - ~1 year of historical data - ~1 year of predictions - Accuracy: ~0.1 mas (polar motion), ~0.01 ms (UT1-UTC) - Use for: Near real-time operations, recent data</p> <p>C04 (Long-term Series): - Complete historical record (1962-present) - Updated monthly - Higher accuracy for historical data - Use for: Historical analysis, long-term studies</p>"},{"location":"learn/cli/eop.html#automatic-eop-handling","title":"Automatic EOP Handling","text":"<p>The CLI automatically manages EOP data:</p> <ol> <li>First use: Downloads standard EOP to <code>~/.cache/brahe/</code></li> <li>Subsequent uses: Uses cached data</li> <li>Updates: Run <code>brahe eop download</code> to refresh</li> </ol>"},{"location":"learn/cli/eop.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/eop.html#update-eop-data","title":"Update EOP Data","text":"<pre><code>#!/bin/bash\n# Update EOP data for accurate transformations\n\necho \"Updating EOP data...\"\nbrahe eop download ~/.cache/brahe/iau2000_standard.txt --product standard\n\necho \"EOP data updated successfully\"\n</code></pre>"},{"location":"learn/cli/eop.html#eop-parameter-timeline","title":"EOP Parameter Timeline","text":"<pre><code>#!/bin/bash\n# Query EOP parameters over a time range\n\nSTART=\"2024-01-01T00:00:00Z\"\nEND=\"2024-01-07T00:00:00Z\"\nSTEP=86400  # 1 day\n\necho \"Date | \u0394UT1 (s)\"\necho \"-----|----------\"\n\nfor epoch in $(brahe time range \"$START\" \"$END\" \"$STEP\"); do\n  dut1=$(brahe eop get-utc-ut1 \"$epoch\")\n  echo \"$epoch | $dut1\"\ndone\n</code></pre>"},{"location":"learn/cli/eop.html#eop-data-quality-check","title":"EOP Data Quality Check","text":"<pre><code>#!/bin/bash\n# Check if EOP data is available for mission timeframe\n\nMISSION_START=\"2024-06-01T00:00:00Z\"\nMISSION_END=\"2024-12-31T23:59:59Z\"\n\necho \"Checking EOP coverage for mission:\"\necho \"Start: $MISSION_START\"\necho \"End:   $MISSION_END\"\n\n# Try to get EOP for mission start\nbrahe eop get-utc-ut1 \"$MISSION_START\" 2&gt;/dev/null\nif [ $? -eq 0 ]; then\n  echo \"\u2713 EOP data available for mission start\"\nelse\n  echo \"\u2717 EOP data NOT available for mission start\"\nfi\n\n# Try for mission end\nbrahe eop get-utc-ut1 \"$MISSION_END\" 2&gt;/dev/null\nif [ $? -eq 0 ]; then\n  echo \"\u2713 EOP data available for mission end\"\nelse\n  echo \"\u2717 EOP data NOT available - download updated EOP\"\nfi\n</code></pre>"},{"location":"learn/cli/eop.html#tips","title":"Tips","text":""},{"location":"learn/cli/eop.html#when-to-update-eop","title":"When to Update EOP","text":"<ul> <li>Daily operations: Update weekly</li> <li>Mission planning: Update before critical events</li> <li>Historical analysis: Use C04 product for best accuracy</li> <li>Future predictions: Standard product provides ~1 year predictions</li> </ul>"},{"location":"learn/cli/eop.html#eop-file-location","title":"EOP File Location","text":"<p>Default location: <code>~/.cache/brahe/iau2000_standard.txt</code></p> <p>To use custom location: <pre><code>export BRAHE_EOP_FILE=/path/to/custom/eop.txt\n</code></pre></p>"},{"location":"learn/cli/eop.html#eop-data-sources","title":"EOP Data Sources","text":"<p>IERS provides EOP data from: - IERS Rapid Service/Prediction Center (standard product) - IERS Earth Orientation Centre (C04 product)</p> <p>Data is automatically downloaded from IERS servers.</p>"},{"location":"learn/cli/eop.html#offline-usage","title":"Offline Usage","text":"<p>Download EOP data while online: <pre><code>brahe eop download ~/.cache/brahe/iau2000_standard.txt --product standard\n</code></pre></p> <p>Then work offline - the CLI will use cached data.</p>"},{"location":"learn/cli/eop.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - Conceptual overview</li> <li>Reference Frames - ECI/ECEF transformations</li> <li>Transform CLI - Frame transformations (use EOP)</li> <li>Time CLI - UT1 time system</li> <li>EOP API - Python EOP provider classes</li> </ul>"},{"location":"learn/cli/orbits.html","title":"Orbits Commands","text":"<p>Orbital mechanics calculations and orbital element conversions.</p>"},{"location":"learn/cli/orbits.html#overview","title":"Overview","text":"<p>The <code>orbits</code> command group provides calculations for: - Orbital period and semi-major axis - Mean motion - Anomaly conversions (mean, eccentric, true) - Sun-synchronous orbit design - Perigee and apogee velocities</p> <p>All commands support constant expressions (e.g., <code>R_EARTH+500e3</code>).</p>"},{"location":"learn/cli/orbits.html#commands","title":"Commands","text":""},{"location":"learn/cli/orbits.html#orbital-period","title":"<code>orbital-period</code>","text":"<p>Calculate the orbital period from semi-major axis.</p> <p>Syntax: <pre><code>brahe orbits orbital-period &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--units [seconds|minutes|hours|days|years]</code> - Output time units (default: <code>seconds</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>LEO orbit period (500km altitude): <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code>5676.977164\n</code></pre> (Period: ~94.6 minutes)</p> <p>With different units: <pre><code>brahe orbits orbital-period \"R_EARTH+500e3\" --units minutes\n</code></pre> Output: <pre><code>94.616286\n</code></pre></p> <p>GEO orbit period (should be ~24 hours): <pre><code>brahe orbits orbital-period \"R_EARTH+35786e3\" --units hours\n</code></pre> Output: <pre><code>23.934472\n</code></pre></p> <p>Moon's orbit (using GM_EARTH): <pre><code>brahe orbits orbital-period 384400e3 --units days\n</code></pre> Output: <pre><code>27.321582\n</code></pre></p> <p>Mars orbit (using GM_SUN): <pre><code>brahe orbits orbital-period 227.9e9 --gm GM_SUN --units days\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sma-from-period","title":"<code>sma-from-period</code>","text":"<p>Calculate semi-major axis from orbital period.</p> <p>Syntax: <pre><code>brahe orbits sma-from-period &lt;PERIOD&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>PERIOD</code> - Orbital period (supports expressions)</p> <p>Options: - <code>--units [seconds|minutes|hours|days|years]</code> - Input time units (default: <code>seconds</code>) - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Find altitude for 90-minute orbit: <pre><code>brahe orbits sma-from-period 90 --units minutes\n</code></pre> Output: <pre><code>6653137.0\n</code></pre> (Semi-major axis: ~6653 km \u2192 altitude ~275 km)</p> <p>Find GEO altitude (24-hour period): <pre><code>brahe orbits sma-from-period 24 --units hours\n</code></pre> Output: <pre><code>42164169.0\n</code></pre> (Semi-major axis: ~42164 km \u2192 altitude ~35786 km above Earth surface)</p> <p>Calculate altitude: <pre><code># SMA - R_EARTH = altitude\necho \"scale=2; ($(brahe orbits sma-from-period 90 --units minutes) - 6378137) / 1000\" | bc\n</code></pre> Output: <pre><code>275.00\n</code></pre> (Altitude: 275 km)</p>"},{"location":"learn/cli/orbits.html#mean-motion","title":"<code>mean-motion</code>","text":"<p>Calculate mean motion (radians per second).</p> <p>Syntax: <pre><code>brahe orbits mean-motion &lt;SEMI_MAJOR_AXIS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants)</p> <p>Options: - <code>--gm &lt;value&gt;</code> - Gravitational parameter (m\u00b3/s\u00b2). Default: <code>GM_EARTH</code> - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean motion for LEO (500km): <pre><code>brahe orbits mean-motion \"R_EARTH+500e3\"\n</code></pre> Output: <pre><code>0.001106\n</code></pre> (Mean motion: ~0.001106 rad/s)</p> <p>Convert to degrees per second: <pre><code># n (rad/s) * 180/\u03c0\necho \"scale=6; $(brahe orbits mean-motion 'R_EARTH+500e3') * 57.29578\" | bc\n</code></pre></p> <p>Convert to revolutions per day: <pre><code># n (rad/s) * 86400 / (2\u03c0)\necho \"scale=2; $(brahe orbits mean-motion 'R_EARTH+500e3') * 86400 / 6.28318\" | bc\n</code></pre> Output: <pre><code>15.23\n</code></pre> (~15.2 revolutions per day)</p>"},{"location":"learn/cli/orbits.html#anomaly-conversion","title":"<code>anomaly-conversion</code>","text":"<p>Convert between mean, eccentric, and true anomaly.</p> <p>Syntax: <pre><code>brahe orbits anomaly-conversion &lt;ANOMALY&gt; &lt;ECCENTRICITY&gt; &lt;INPUT_ANOMALY&gt; &lt;OUTPUT_ANOMALY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>ANOMALY</code> - Anomaly value to convert (supports expressions) - <code>ECCENTRICITY</code> - Orbital eccentricity (supports expressions) - <code>INPUT_ANOMALY</code> - Input type: <code>mean</code>, <code>eccentric</code>, or <code>true</code> - <code>OUTPUT_ANOMALY</code> - Output type: <code>mean</code>, <code>eccentric</code>, or <code>true</code></p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Use degrees (default: <code>--no-as-degrees</code> = radians) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Mean anomaly to true anomaly (circular orbit): <pre><code>brahe orbits anomaly-conversion 0.785 0.0 mean true\n</code></pre> Output: <pre><code>0.785398\n</code></pre> (For circular orbit, mean \u2248 eccentric \u2248 true)</p> <p>Mean to true (eccentric orbit): <pre><code>brahe orbits anomaly-conversion --as-degrees 45.0 0.1 mean true\n</code></pre> Output: <pre><code>50.123456\n</code></pre></p> <p>True to mean anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 90.0 0.05 true mean\n</code></pre></p> <p>Eccentric to true anomaly: <pre><code>brahe orbits anomaly-conversion --as-degrees 60.0 0.2 eccentric true\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sun-sync-inclination","title":"<code>sun-sync-inclination</code>","text":"<p>Calculate the inclination required for a sun-synchronous orbit.</p> <p>Syntax: <pre><code>brahe orbits sun-sync-inclination &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--as-degrees / --no-as-degrees</code> - Output in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Sun-sync inclination for 500km circular orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code>97.419357\n</code></pre> (Inclination: ~97.42\u00b0)</p> <p>Sun-sync for 600km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+600e3\" 0.001\n</code></pre> Output: <pre><code>97.846523\n</code></pre></p> <p>Sun-sync for 800km orbit: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+800e3\" 0.0\n</code></pre> Output: <pre><code>98.606174\n</code></pre></p> <p>Output in radians: <pre><code>brahe orbits sun-sync-inclination \"R_EARTH+500e3\" 0.0 --no-as-degrees\n</code></pre> Output: <pre><code>1.700814\n</code></pre></p>"},{"location":"learn/cli/orbits.html#perigee-velocity","title":"<code>perigee-velocity</code>","text":"<p>Calculate orbital velocity at perigee (closest approach).</p> <p>Syntax: <pre><code>brahe orbits perigee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit velocity (500km): <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code>7612.653885\n</code></pre> (Velocity: ~7.6 km/s)</p> <p>Eccentric orbit perigee velocity: <pre><code>brahe orbits perigee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code>8023.886574\n</code></pre></p> <p>GTO perigee velocity (highly eccentric): <pre><code>brahe orbits perigee-velocity \"R_EARTH+24000e3\" 0.73\n</code></pre></p>"},{"location":"learn/cli/orbits.html#apogee-velocity","title":"<code>apogee-velocity</code>","text":"<p>Calculate orbital velocity at apogee (farthest point).</p> <p>Syntax: <pre><code>brahe orbits apogee-velocity &lt;SEMI_MAJOR_AXIS&gt; &lt;ECCENTRICITY&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>SEMI_MAJOR_AXIS</code> - Semi-major axis in meters (supports constants) - <code>ECCENTRICITY</code> - Eccentricity (supports expressions)</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Circular orbit (apogee = perigee): <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.0\n</code></pre> Output: <pre><code>7612.653885\n</code></pre></p> <p>Eccentric orbit apogee velocity: <pre><code>brahe orbits apogee-velocity \"R_EARTH+500e3\" 0.1\n</code></pre> Output: <pre><code>7230.594441\n</code></pre> (Lower velocity at apogee)</p> <p>Compare perigee vs apogee: <pre><code>echo \"Perigee: $(brahe orbits perigee-velocity 'R_EARTH+500e3' 0.1) m/s\"\necho \"Apogee:  $(brahe orbits apogee-velocity 'R_EARTH+500e3' 0.1) m/s\"\n</code></pre></p>"},{"location":"learn/cli/orbits.html#orbital-mechanics-concepts","title":"Orbital Mechanics Concepts","text":""},{"location":"learn/cli/orbits.html#semi-major-axis-a","title":"Semi-Major Axis (a)","text":"<p>The average of perigee and apogee distances from Earth's center: <pre><code>a = (r_perigee + r_apogee) / 2\n</code></pre></p> <p>For circular orbits: <code>a = r = R_EARTH + altitude</code></p> <p>Standard orbits: - LEO (500km): <code>a = 6,878,137 m</code> - MEO/GPS (~20,200km): <code>a = 26,578,137 m</code> - GEO (35,786km): <code>a = 42,164,137 m</code></p>"},{"location":"learn/cli/orbits.html#eccentricity-e","title":"Eccentricity (e)","text":"<p>Measure of orbit shape: - <code>e = 0</code>: Perfect circle - <code>0 &lt; e &lt; 1</code>: Ellipse - <code>e = 1</code>: Parabola (escape trajectory) - <code>e &gt; 1</code>: Hyperbola (escape trajectory)</p> <p>Typical values: - Circular orbit: <code>e = 0.0</code> - Near-circular: <code>e = 0.001</code> - ISS: <code>e \u2248 0.0001</code> - GTO (Geostationary Transfer Orbit): <code>e \u2248 0.73</code> - Molniya: <code>e \u2248 0.74</code></p>"},{"location":"learn/cli/orbits.html#orbital-period_1","title":"Orbital Period","text":"<p>Time to complete one revolution: <pre><code>T = 2\u03c0 \u221a(a\u00b3 / \u03bc)\n</code></pre></p> <p>Where: - <code>a</code> = semi-major axis - <code>\u03bc</code> = GM (gravitational parameter)</p> <p>Kepler's Third Law: Period squared is proportional to semi-major axis cubed.</p>"},{"location":"learn/cli/orbits.html#mean-motion-n","title":"Mean Motion (n)","text":"<p>Average angular velocity: <pre><code>n = \u221a(\u03bc / a\u00b3) = 2\u03c0 / T\n</code></pre></p> <p>Units: radians per second</p>"},{"location":"learn/cli/orbits.html#anomalies","title":"Anomalies","text":"<p>Mean Anomaly (M): - Linearly increasing with time - Fictional angle assuming uniform circular motion</p> <p>Eccentric Anomaly (E): - Geometric intermediate between mean and true - Related by Kepler's equation: <code>M = E - e sin(E)</code></p> <p>True Anomaly (\u03bd): - Actual angle from perigee to satellite - Physical position in orbit</p> <p>Conversions: - Mean \u2192 Eccentric: Solve Kepler's equation (iterative) - Eccentric \u2192 True: Geometric transformation - True \u2192 Eccentric \u2192 Mean: Direct formulas</p>"},{"location":"learn/cli/orbits.html#sun-synchronous-orbit","title":"Sun-Synchronous Orbit","text":"<p>Orbit whose orbital plane precesses at the same rate as Earth's orbit around the Sun (~1\u00b0 per day):</p> <p>Properties: - Consistent lighting conditions - Fixed local time of ascending node - Requires specific inclination (typically 96-100\u00b0 for LEO) - Common for Earth observation satellites</p> <p>Inclination vs Altitude: - Lower altitude \u2192 higher inclination needed - 500km: ~97.4\u00b0 - 600km: ~97.8\u00b0 - 800km: ~98.6\u00b0</p>"},{"location":"learn/cli/orbits.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/orbits.html#orbit-design","title":"Orbit Design","text":"<p>Design an orbit with specific period: <pre><code>#!/bin/bash\n# Target: 90-minute orbit\n\n# Calculate semi-major axis\nSMA=$(brahe orbits sma-from-period 90 --units minutes)\necho \"Semi-major axis: $SMA m\"\n\n# Calculate altitude\nALT=$(echo \"scale=2; ($SMA - 6378137) / 1000\" | bc)\necho \"Altitude: $ALT km\"\n\n# Calculate velocity\nVEL=$(brahe orbits perigee-velocity \"$SMA\" 0.0)\necho \"Velocity: $VEL m/s\"\n</code></pre></p>"},{"location":"learn/cli/orbits.html#sun-synchronous-mission","title":"Sun-Synchronous Mission","text":"<p>Design a sun-synchronous orbit: <pre><code>#!/bin/bash\nALT_KM=600\nSMA=\"R_EARTH+${ALT_KM}e3\"\nECC=\"0.001\"\n\necho \"Designing SSO at ${ALT_KM}km altitude\"\n\n# Required inclination\nINC=$(brahe orbits sun-sync-inclination \"$SMA\" \"$ECC\")\necho \"Inclination: $INC\u00b0\"\n\n# Orbital period\nPERIOD=$(brahe orbits orbital-period \"$SMA\" --units minutes)\necho \"Period: $PERIOD minutes\"\n\n# Revolutions per day\nREV_PER_DAY=$(echo \"scale=2; 1440 / $PERIOD\" | bc)\necho \"Revolutions per day: $REV_PER_DAY\"\n</code></pre></p>"},{"location":"learn/cli/orbits.html#anomaly-propagation","title":"Anomaly Propagation","text":"<p>Track satellite position through one orbit: <pre><code>#!/bin/bash\n# Circular orbit, propagate through anomalies\nSMA=\"R_EARTH+500e3\"\nECC=\"0.01\"\n\necho \"Anomaly (degrees) | True Anomaly\"\necho \"------------------|-------------\"\n\nfor M in 0 30 60 90 120 150 180; do\n  NU=$(brahe orbits anomaly-conversion --as-degrees $M $ECC mean true)\n  echo \"$M                | $NU\"\ndone\n</code></pre></p>"},{"location":"learn/cli/orbits.html#apse-velocities","title":"Apse Velocities","text":"<p>Calculate velocity change for orbit raising: <pre><code>#!/bin/bash\n# LEO to GEO transfer\n\n# Initial circular orbit (500km)\nSMA_LEO=\"R_EARTH+500e3\"\nV_LEO=$(brahe orbits perigee-velocity \"$SMA_LEO\" 0.0)\n\n# Transfer orbit (GTO)\nSMA_GTO=\"R_EARTH+19000e3\"  # Average of LEO and GEO\nECC_GTO=\"0.73\"\nV_GTO_PERIGEE=$(brahe orbits perigee-velocity \"$SMA_GTO\" \"$ECC_GTO\")\nV_GTO_APOGEE=$(brahe orbits apogee-velocity \"$SMA_GTO\" \"$ECC_GTO\")\n\n# GEO circular orbit\nSMA_GEO=\"R_EARTH+35786e3\"\nV_GEO=$(brahe orbits perigee-velocity \"$SMA_GEO\" 0.0)\n\n# Delta-V calculations\nDV1=$(echo \"$V_GTO_PERIGEE - $V_LEO\" | bc)\nDV2=$(echo \"$V_GEO - $V_GTO_APOGEE\" | bc)\nDV_TOTAL=$(echo \"$DV1 + $DV2\" | bc)\n\necho \"LEO to GEO Transfer:\"\necho \"\u0394V1 (LEO departure): $DV1 m/s\"\necho \"\u0394V2 (GEO insertion): $DV2 m/s\"\necho \"Total \u0394V: $DV_TOTAL m/s\"\n</code></pre></p>"},{"location":"learn/cli/orbits.html#tips","title":"Tips","text":""},{"location":"learn/cli/orbits.html#using-constants","title":"Using Constants","text":"<p>All orbital commands support constant expressions: <pre><code># Earth orbits\nbrahe orbits orbital-period \"R_EARTH+500e3\"\n\n# Mars orbits (use Mars GM)\nbrahe orbits orbital-period \"R_MARS+300e3\" --gm GM_MARS\n\n# Solar orbits\nbrahe orbits orbital-period \"1.496e11\" --gm GM_SUN --units days\n</code></pre></p>"},{"location":"learn/cli/orbits.html#unit-conversions","title":"Unit Conversions","text":"<p>Convert between different time units: <pre><code># Get period in different units\nPERIOD_SEC=$(brahe orbits orbital-period \"R_EARTH+500e3\" --units seconds)\nPERIOD_MIN=$(brahe orbits orbital-period \"R_EARTH+500e3\" --units minutes)\nPERIOD_HOUR=$(brahe orbits orbital-period \"R_EARTH+500e3\" --units hours)\n</code></pre></p>"},{"location":"learn/cli/orbits.html#precision-control","title":"Precision Control","text":"<p>Use <code>--format</code> for scientific or high-precision output: <pre><code># Scientific notation\nbrahe orbits orbital-period \"R_EARTH+500e3\" --format .3e\n\n# High precision (10 decimals)\nbrahe orbits sun-sync-inclination \"R_EARTH+600e3\" 0.001 --format .10f\n</code></pre></p>"},{"location":"learn/cli/orbits.html#batch-calculations","title":"Batch Calculations","text":"<p>Calculate parameters for multiple altitudes: <pre><code>#!/bin/bash\necho \"Alt(km) | Period(min) | Inclination(\u00b0)\"\necho \"--------|-------------|---------------\"\n\nfor alt_km in 400 500 600 700 800; do\n  sma=\"R_EARTH+${alt_km}e3\"\n  period=$(brahe orbits orbital-period \"$sma\" --units minutes --format .2f)\n  inc=$(brahe orbits sun-sync-inclination \"$sma\" 0.0 --format .2f)\n  echo \"$alt_km     | $period        | $inc\"\ndone\n</code></pre></p>"},{"location":"learn/cli/orbits.html#see-also","title":"See Also","text":"<ul> <li>Keplerian Elements - Conceptual overview</li> <li>Orbits API - Python orbital mechanics functions</li> <li>Transform CLI - Coordinate conversions</li> <li>Constants - Physical constants for calculations</li> </ul>"},{"location":"learn/cli/time.html","title":"Time Commands","text":"<p>Time system operations, conversions, and epoch manipulation.</p>"},{"location":"learn/cli/time.html#overview","title":"Overview","text":"<p>The <code>time</code> command group provides: - Conversion between time formats (MJD, JD, ISO-8601, GPS) - Conversion between time systems (UTC, TAI, GPS, UT1, TT) - Time arithmetic (adding/subtracting durations) - Time range generation</p>"},{"location":"learn/cli/time.html#commands","title":"Commands","text":""},{"location":"learn/cli/time.html#convert","title":"<code>convert</code>","text":"<p>Convert between time formats and time systems.</p> <p>Syntax: <pre><code>brahe time convert &lt;EPOCH&gt; &lt;INPUT_FORMAT&gt; &lt;OUTPUT_FORMAT&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Time value to convert - <code>INPUT_FORMAT</code> - Format of input: <code>mjd</code>, <code>jd</code>, <code>string</code>, <code>gps_date</code>, <code>gps_nanoseconds</code> - <code>OUTPUT_FORMAT</code> - Desired output format (same options as input)</p> <p>Options: - <code>--input-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of input - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Time system of output</p> <p>Examples:</p> <p>Convert ISO-8601 string to Modified Julian Date: <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string mjd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code>60310.0\n</code></pre></p> <p>Convert MJD to Julian Date: <pre><code>brahe time convert 60310.0 mjd jd --input-time-system UTC --output-time-system UTC\n</code></pre> Output: <pre><code>2460310.5\n</code></pre></p> <p>Convert between time systems (UTC to TAI): <pre><code>brahe time convert \"2024-01-01T00:00:00Z\" string string --input-time-system UTC --output-time-system TAI\n</code></pre> Output: <pre><code>2024-01-01 00:00:37.000 TAI\n</code></pre></p> <p>Convert GPS time to UTC: <pre><code>brahe time convert \"1356998418000000000\" gps_nanoseconds string --output-time-system UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#add","title":"<code>add</code>","text":"<p>Add a time offset to an epoch.</p> <p>Syntax: <pre><code>brahe time add &lt;EPOCH&gt; &lt;SECONDS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Starting epoch (ISO-8601 string, MJD, or JD) - <code>SECONDS</code> - Number of seconds to add (can be negative)</p> <p>Options: - <code>--output-format [mjd|jd|string|gps_date|gps_nanoseconds]</code> - Output format (default: <code>string</code>) - <code>--output-time-system [UTC|GPS|TAI|UT1|TT]</code> - Output time system (default: <code>UTC</code>)</p> <p>Examples:</p> <p>Add 1 hour (3600 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 3600\n</code></pre> Output: <pre><code>2024-01-01 01:00:00.000 UTC\n</code></pre></p> <p>Add 1 day (86400 seconds): <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400\n</code></pre> Output: <pre><code>2024-01-02 00:00:00.000 UTC\n</code></pre></p> <p>Subtract 30 minutes (negative seconds): <pre><code>brahe time add \"2024-01-01T12:00:00Z\" -1800\n</code></pre> Output: <pre><code>2024-01-01 11:30:00.000 UTC\n</code></pre></p> <p>Output as MJD: <pre><code>brahe time add \"2024-01-01T00:00:00Z\" 86400 --output-format mjd\n</code></pre> Output: <pre><code>60311.0\n</code></pre></p>"},{"location":"learn/cli/time.html#time-system-offset","title":"<code>time-system-offset</code>","text":"<p>Calculate the offset between two time systems at a given epoch.</p> <p>Syntax: <pre><code>brahe time time-system-offset &lt;EPOCH&gt; &lt;SOURCE&gt; &lt;TARGET&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH</code> - Epoch to calculate offset at (ISO-8601 string) - <code>SOURCE</code> - Source time system: <code>UTC</code>, <code>GPS</code>, <code>TAI</code>, <code>UT1</code>, <code>TT</code> - <code>TARGET</code> - Target time system (same options)</p> <p>Examples:</p> <p>UTC to TAI offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" UTC TAI\n</code></pre> Output: <pre><code>37.0\n</code></pre> (TAI is 37 seconds ahead of UTC in 2024)</p> <p>GPS to UTC offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" GPS UTC\n</code></pre> Output: <pre><code>-18.0\n</code></pre> (GPS is 18 seconds behind UTC... wait, that's the leap second offset)</p> <p>TAI to TT offset: <pre><code>brahe time time-system-offset \"2024-01-01T00:00:00Z\" TAI TT\n</code></pre> Output: <pre><code>32.184\n</code></pre> (TT is always 32.184 seconds ahead of TAI)</p>"},{"location":"learn/cli/time.html#range","title":"<code>range</code>","text":"<p>Generate a sequence of epochs over a time range.</p> <p>Syntax: <pre><code>brahe time range &lt;EPOCH_START&gt; &lt;EPOCH_END&gt; &lt;STEP&gt;\n</code></pre></p> <p>Arguments: - <code>EPOCH_START</code> - Start of time range (ISO-8601 string) - <code>EPOCH_END</code> - End of time range (ISO-8601 string) - <code>STEP</code> - Step size in seconds</p> <p>Examples:</p> <p>Generate epochs every 30 minutes for 1 hour: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-01T01:00:00Z\" 1800\n</code></pre> Output: <pre><code>2024-01-01 00:00:00.000 UTC\n2024-01-01 00:30:00.000 UTC\n</code></pre></p> <p>Generate epochs every 6 hours for 1 day: <pre><code>brahe time range \"2024-01-01T00:00:00Z\" \"2024-01-02T00:00:00Z\" 21600\n</code></pre> Output: <pre><code>2024-01-01 00:00:00.000 UTC\n2024-01-01 06:00:00.000 UTC\n2024-01-01 12:00:00.000 UTC\n2024-01-01 18:00:00.000 UTC\n</code></pre></p> <p>Generate epochs every minute for 5 minutes: <pre><code>brahe time range \"2024-01-01T12:00:00Z\" \"2024-01-01T12:05:00Z\" 60\n</code></pre> Output: <pre><code>2024-01-01 12:00:00.000 UTC\n2024-01-01 12:01:00.000 UTC\n2024-01-01 12:02:00.000 UTC\n2024-01-01 12:03:00.000 UTC\n2024-01-01 12:04:00.000 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#time-systems","title":"Time Systems","text":""},{"location":"learn/cli/time.html#utc-coordinated-universal-time","title":"UTC (Coordinated Universal Time)","text":"<ul> <li>Civil time standard</li> <li>Includes leap seconds</li> <li>Most common for human-readable timestamps</li> </ul>"},{"location":"learn/cli/time.html#tai-international-atomic-time","title":"TAI (International Atomic Time)","text":"<ul> <li>Continuous atomic time scale</li> <li>No leap seconds</li> <li>Currently 37 seconds ahead of UTC (as of 2024)</li> </ul>"},{"location":"learn/cli/time.html#gps-global-positioning-system-time","title":"GPS (Global Positioning System Time)","text":"<ul> <li>Used by GPS satellites</li> <li>Started at 1980-01-06 00:00:00 UTC</li> <li>19 seconds behind TAI (fixed offset)</li> </ul>"},{"location":"learn/cli/time.html#ut1-universal-time-1","title":"UT1 (Universal Time 1)","text":"<ul> <li>Based on Earth's rotation</li> <li>Irregular due to Earth rotation variations</li> <li>Requires Earth Orientation Parameters (EOP)</li> </ul>"},{"location":"learn/cli/time.html#tt-terrestrial-time","title":"TT (Terrestrial Time)","text":"<ul> <li>Ideal time for Earth-based observations</li> <li>Always 32.184 seconds ahead of TAI</li> </ul>"},{"location":"learn/cli/time.html#offset-relationships","title":"Offset Relationships","text":"<pre><code>TT  = TAI + 32.184s\nTAI = GPS + 19s\nTAI = UTC + (leap seconds, currently 37s)\nUT1 = UTC + (DUT1, from EOP data)\n</code></pre>"},{"location":"learn/cli/time.html#time-formats","title":"Time Formats","text":""},{"location":"learn/cli/time.html#iso-8601-string-string","title":"ISO-8601 String (<code>string</code>)","text":"<p>Human-readable format with timezone: <pre><code>2024-01-01T00:00:00Z\n2024-12-31T23:59:59.123Z\n</code></pre></p>"},{"location":"learn/cli/time.html#modified-julian-date-mjd","title":"Modified Julian Date (<code>mjd</code>)","text":"<p>Days since 1858-11-17 00:00:00 UTC: <pre><code>60310.0         # 2024-01-01 00:00:00 UTC\n60310.5         # 2024-01-01 12:00:00 UTC\n60310.25        # 2024-01-01 06:00:00 UTC\n</code></pre></p>"},{"location":"learn/cli/time.html#julian-date-jd","title":"Julian Date (<code>jd</code>)","text":"<p>Days since -4712-01-01 12:00:00 UTC: <pre><code>2460310.5       # 2024-01-01 00:00:00 UTC\n2460311.0       # 2024-01-01 12:00:00 UTC\n</code></pre></p> <p>Relationship: <code>JD = MJD + 2400000.5</code></p>"},{"location":"learn/cli/time.html#gps-date-gps_date","title":"GPS Date (<code>gps_date</code>)","text":"<p>GPS week number and seconds: <pre><code>2295:0.0        # GPS Week 2295, 0 seconds\n</code></pre></p>"},{"location":"learn/cli/time.html#gps-nanoseconds-gps_nanoseconds","title":"GPS Nanoseconds (<code>gps_nanoseconds</code>)","text":"<p>Nanoseconds since GPS epoch (1980-01-06 00:00:00 UTC): <pre><code>1356998418000000000\n</code></pre></p>"},{"location":"learn/cli/time.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/time.html#mission-planning-timeline","title":"Mission Planning Timeline","text":"<pre><code>#!/bin/bash\n# Create mission timeline with 1-hour intervals\nSTART=\"2024-06-01T00:00:00Z\"\nEND=\"2024-06-01T24:00:00Z\"\nSTEP=3600  # 1 hour\n\necho \"Mission timeline:\"\nbrahe time range \"$START\" \"$END\" \"$STEP\"\n</code></pre>"},{"location":"learn/cli/time.html#time-system-comparison","title":"Time System Comparison","text":"<pre><code>#!/bin/bash\n# Compare all time systems at a specific epoch\nEPOCH=\"2024-01-01T00:00:00Z\"\n\necho \"Epoch: $EPOCH\"\necho \"UTC to TAI: $(brahe time time-system-offset \"$EPOCH\" UTC TAI)s\"\necho \"UTC to GPS: $(brahe time time-system-offset \"$EPOCH\" UTC GPS)s\"\necho \"UTC to TT:  $(brahe time time-system-offset \"$EPOCH\" UTC TT)s\"\n</code></pre>"},{"location":"learn/cli/time.html#satellite-pass-duration","title":"Satellite Pass Duration","text":"<pre><code>#!/bin/bash\n# Calculate pass duration\nSTART=\"2024-01-01T14:23:15Z\"\nEND=\"2024-01-01T14:35:42Z\"\n\n# Convert to MJD\nMJD_START=$(brahe time convert \"$START\" string mjd --input-time-system UTC --output-time-system UTC)\nMJD_END=$(brahe time convert \"$END\" string mjd --input-time-system UTC --output-time-system UTC)\n\n# Calculate duration (MJD is in days)\nDURATION=$(echo \"($MJD_END - $MJD_START) * 86400\" | bc)\necho \"Pass duration: ${DURATION} seconds\"\n</code></pre>"},{"location":"learn/cli/time.html#propagation-timeline","title":"Propagation Timeline","text":"<pre><code>#!/bin/bash\n# Generate epochs for 24-hour propagation with 10-minute steps\nSTART=\"2024-01-01T00:00:00Z\"\nDURATION_HOURS=24\nSTEP_SECONDS=600  # 10 minutes\n\n# Calculate end time\nEND=$(brahe time add \"$START\" $((DURATION_HOURS * 3600)) --output-format string)\n\n# Generate timeline\nbrahe time range \"$START\" \"$END\" \"$STEP_SECONDS\" &gt; propagation_epochs.txt\n</code></pre>"},{"location":"learn/cli/time.html#tips","title":"Tips","text":""},{"location":"learn/cli/time.html#leap-seconds","title":"Leap Seconds","text":"<p>UTC includes leap seconds, which are added irregularly: - As of 2024-01-01: 37 leap seconds have been added since 1972 - TAI - UTC = 37 seconds - GPS is 19 seconds behind TAI (fixed)</p> <p>Use TAI or GPS for continuous time calculations without discontinuities.</p>"},{"location":"learn/cli/time.html#high-precision-timestamps","title":"High-Precision Timestamps","text":"<p>ISO-8601 strings support nanosecond precision: <pre><code>brahe time convert \"2024-01-01T00:00:00.123456789Z\" string mjd\n</code></pre></p>"},{"location":"learn/cli/time.html#negative-time-offsets","title":"Negative Time Offsets","text":"<p>Use negative seconds to subtract time: <pre><code># Go back 1 week\nbrahe time add \"2024-01-08T00:00:00Z\" -604800\n</code></pre></p>"},{"location":"learn/cli/time.html#batch-processing","title":"Batch Processing","text":"<p>Use shell loops for batch time conversions: <pre><code># Convert multiple epochs\nfor epoch in \"2024-01-01T00:00:00Z\" \"2024-06-01T00:00:00Z\" \"2024-12-31T00:00:00Z\"; do\n  echo \"$epoch -&gt; $(brahe time convert \"$epoch\" string mjd --input-time-system UTC --output-time-system UTC)\"\ndone\n</code></pre></p>"},{"location":"learn/cli/time.html#see-also","title":"See Also","text":"<ul> <li>Earth Orientation Data - EOP and UT1</li> <li>Epoch API - Python Epoch class</li> <li>EOP CLI - Earth Orientation Parameters</li> <li>Transform CLI - Coordinate transformations (require epochs)</li> </ul>"},{"location":"learn/cli/transform.html","title":"Transform Commands","text":"<p>Convert between coordinate systems and reference frames.</p>"},{"location":"learn/cli/transform.html#overview","title":"Overview","text":"<p>The <code>transform</code> command group provides conversions between: - Reference frames: ECI (Earth-Centered Inertial) \u2194 ECEF (Earth-Centered Earth-Fixed) - Coordinate systems: Keplerian, Cartesian, Geodetic, Geocentric - Attitude representations: Quaternions, Euler angles, rotation matrices (planned)</p>"},{"location":"learn/cli/transform.html#commands","title":"Commands","text":""},{"location":"learn/cli/transform.html#frame","title":"<code>frame</code>","text":"<p>Transform state vectors between ECI and ECEF reference frames.</p> <p>Syntax: <pre><code>brahe transform frame &lt;FROM_FRAME&gt; &lt;TO_FRAME&gt; &lt;EPOCH&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;vx&gt; &lt;vy&gt; &lt;vz&gt; [OPTIONS]\n</code></pre></p> <p>Arguments: - <code>FROM_FRAME</code> - Source reference frame: <code>ECI</code> or <code>ECEF</code> - <code>TO_FRAME</code> - Target reference frame: <code>ECI</code> or <code>ECEF</code> - <code>EPOCH</code> - Epoch for the transformation (ISO-8601 format with timezone) - <code>x y z vx vy vz</code> - State vector [m, m, m, m/s, m/s, m/s]</p> <p>Options: - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p> <p>Convert ECI state to ECEF at a specific epoch: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code>[-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Convert ECEF back to ECI: <pre><code>brahe transform frame ECEF ECI \"2024-01-01T00:00:00Z\" -- -1176064.179 -6776827.197 15961.825 6895.377 -1196.637 0.241\n</code></pre> Output: <pre><code>[6878137.000016, 0.000312, -0.000213, 0.000018, 7500.000440, 0.000398]\n</code></pre></p> <p>High-precision output: <pre><code>brahe transform frame ECI ECEF \"2024-01-01T12:00:00Z\" 6878137 0 0 0 7500 0 --format .6f\n</code></pre> Output: <pre><code>[6593705.875453, -2219542.362118, 15961.820947, 2257.097798, 6768.353894, 0.240601]\n</code></pre></p> <p>Note: Frame transformations require Earth Orientation Parameters (EOP). The CLI automatically downloads and caches EOP data on first use in <code>~/.cache/brahe/</code>.</p>"},{"location":"learn/cli/transform.html#coordinates","title":"<code>coordinates</code>","text":"<p>Convert between coordinate system representations.</p> <p>Syntax: <pre><code>brahe transform coordinates [OPTIONS] &lt;FROM_SYSTEM&gt; &lt;TO_SYSTEM&gt; &lt;EPOCH&gt; &lt;x1&gt; &lt;x2&gt; &lt;x3&gt; &lt;x4&gt; &lt;x5&gt; &lt;x6&gt;\n</code></pre></p> <p>Arguments: - <code>FROM_SYSTEM</code> - Source coordinate system (see below) - <code>TO_SYSTEM</code> - Target coordinate system (see below) - <code>EPOCH</code> - Epoch (ISO-8601 format). Use <code>\"\"</code> if not needed for the conversion - <code>x1 x2 x3 x4 x5 x6</code> - Coordinate values (interpretation depends on system)</p> <p>Coordinate Systems: - <code>keplerian</code> - Keplerian orbital elements [a, e, i, \u03a9, \u03c9, \u03bd] - <code>cartesian</code> - Cartesian state [x, y, z, vx, vy, vz] - <code>geodetic</code> - Geodetic coordinates [lat, lon, alt, 0, 0, 0] - <code>geocentric</code> - Geocentric spherical [lat, lon, radius, 0, 0, 0]</p> <p>Options: - <code>--from-frame [ECI|ECEF]</code> - Reference frame for cartesian input (default: <code>ECI</code>) - <code>--to-frame [ECI|ECEF]</code> - Reference frame for cartesian output (default: <code>ECI</code>) - <code>--as-degrees / --no-as-degrees</code> - Interpret/output angles in degrees (default: <code>--as-degrees</code>) - <code>--format &lt;fmt&gt;</code> - Output format string (default: <code>f</code>)</p> <p>Examples:</p>"},{"location":"learn/cli/transform.html#keplerian-to-cartesian-eci","title":"Keplerian to Cartesian (ECI)","text":"<p>Convert orbital elements to ECI state (no epoch required): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre> Output: <pre><code>[6871258.863000, 0.000000, 0.000000, 0.000000, -1034.183142, 7549.721055]\n</code></pre></p> <p>With different true anomaly (45\u00b0): <pre><code>brahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 45 --as-degrees\n</code></pre> Output: <pre><code>[4858852.313564, 0.000000, 4861186.164467, -5350.034024, -731.184395, 5337.540890]\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-to-keplerian","title":"Cartesian to Keplerian","text":"<p>Convert ECI state back to orbital elements: <pre><code>brahe transform coordinates --as-degrees cartesian keplerian \"\" -- 6871258.863 0.0 0.0 0.0 -1034.183 7549.721\n</code></pre> Output: <pre><code>[6878136.866355, 0.001000, 97.799999, 0.000000, 0.000000, 0.000000]\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-to-cartesian-ecef","title":"Geodetic to Cartesian (ECEF)","text":"<p>Convert geodetic coordinates (New York City) to ECEF: <pre><code>brahe transform coordinates --as-degrees --to-frame ECEF geodetic cartesian \"\" 40.7128 286.0060 10 0 0 0\n</code></pre> Output: <pre><code>[1334224.912305, -4651969.287142, 4140677.827068]\n</code></pre></p> <p>Note: Longitude 286\u00b0 = -74\u00b0 (use positive east longitude, or handle negative with <code>--</code>)</p>"},{"location":"learn/cli/transform.html#ecef-cartesian-to-geodetic","title":"ECEF Cartesian to Geodetic","text":"<p><pre><code>brahe transform coordinates --as-degrees --from-frame ECEF cartesian geodetic \"2024-01-01T00:00:00Z\" 1334915.0 4652372.0 4075345.0 0 0 0\n</code></pre> Output: <pre><code>[73.990114, 40.288227, -41917.492259]\n</code></pre></p>"},{"location":"learn/cli/transform.html#keplerian-to-geodetic-via-ecef","title":"Keplerian to Geodetic (via ECEF)","text":"<p>Convert satellite orbital elements to ground track position at epoch: <pre><code># First to cartesian ECI, then specify ECEF and geodetic\nbrahe transform coordinates --as-degrees --to-frame ECEF keplerian geodetic \"2024-01-01T00:00:00Z\" 6878137 0.001 97.8 0 0 0\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eci-to-ecef-frame-change","title":"Cartesian ECI to ECEF (frame change)","text":"<p><pre><code>brahe transform coordinates --from-frame ECI --to-frame ECEF cartesian cartesian \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0\n</code></pre> Output: <pre><code>[-1176064.179304, -6776827.196931, 15961.825213, 6895.376569, -1196.636908, 0.240602]\n</code></pre></p> <p>Alternative: Use <code>brahe transform frame</code> for dedicated ECI\u2194ECEF transformations.</p>"},{"location":"learn/cli/transform.html#attitude","title":"<code>attitude</code>","text":"<p>Convert between attitude representations (quaternions, Euler angles, rotation matrices).</p> <p>Status: Not yet implemented - planned for future release.</p> <p>Planned conversions: - Quaternion \u2194 Rotation Matrix - Quaternion \u2194 Euler Angles (12 sequences) - Quaternion \u2194 Euler Axis-Angle - And all inverse combinations</p>"},{"location":"learn/cli/transform.html#coordinate-system-details","title":"Coordinate System Details","text":""},{"location":"learn/cli/transform.html#keplerian-elements","title":"Keplerian Elements","text":"<p>Format: <code>[a, e, i, \u03a9, \u03c9, \u03bd]</code></p> <ul> <li><code>a</code> - Semi-major axis (meters)</li> <li><code>e</code> - Eccentricity (dimensionless, 0 \u2264 e &lt; 1)</li> <li><code>i</code> - Inclination (degrees or radians)</li> <li><code>\u03a9</code> - Right Ascension of Ascending Node / RAAN (degrees or radians)</li> <li><code>\u03c9</code> - Argument of periapsis (degrees or radians)</li> <li><code>\u03bd</code> - True anomaly (degrees or radians)</li> </ul> <p>Standard orbits: - LEO (500km): <code>a = R_EARTH + 500e3 = 6878137 m</code> - GEO (35786km): <code>a = R_EARTH + 35786e3 = 42164137 m</code> - SSO inclination: ~97.8\u00b0 (for 500km altitude)</p> <p>Example: <pre><code># Sun-synchronous orbit, 500km altitude, 97.8\u00b0 inclination\nbrahe transform coordinates keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0 --as-degrees\n</code></pre></p>"},{"location":"learn/cli/transform.html#cartesian-eciecef","title":"Cartesian (ECI/ECEF)","text":"<p>Format: <code>[x, y, z, vx, vy, vz]</code></p> <ul> <li><code>x, y, z</code> - Position (meters)</li> <li><code>vx, vy, vz</code> - Velocity (meters/second)</li> </ul> <p>ECI (Earth-Centered Inertial): - Inertial reference frame - Z-axis aligned with Earth's rotation axis - X-axis points to vernal equinox</p> <p>ECEF (Earth-Centered Earth-Fixed): - Rotating with Earth - Z-axis aligned with rotation axis - X-axis through 0\u00b0 latitude, 0\u00b0 longitude</p> <p>Example: <pre><code># Circular equatorial orbit in ECI\nbrahe transform coordinates cartesian keplerian \"\" 6878137 0 0 0 7668 0 --as-degrees\n</code></pre></p>"},{"location":"learn/cli/transform.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Format: <code>[lat, lon, alt, 0, 0, 0]</code></p> <ul> <li><code>lat</code> - Geodetic latitude (degrees or radians)</li> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>alt</code> - Altitude above WGS84 ellipsoid (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul> <p>Geodetic vs Geocentric: - Geodetic: Perpendicular to WGS84 ellipsoid - Geocentric: Angle from Earth's center</p> <p>Example: <pre><code># New York City: 40.7128\u00b0N, 73.9060\u00b0W (= 286.0940\u00b0E)\nbrahe transform coordinates --as-degrees geodetic cartesian \"\" 40.7128 286.094 10 0 0 0 --to-frame ECEF\n</code></pre></p> <p>Note: For negative longitudes, either convert to positive east (add 360\u00b0) or use <code>--</code> separator: <pre><code>brahe transform coordinates --as-degrees geodetic cartesian \"\" -- 40.7128 -73.9060 10 0 0 0 --to-frame ECEF\n</code></pre></p>"},{"location":"learn/cli/transform.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Format: <code>[lat, lon, radius, 0, 0, 0]</code></p> <ul> <li><code>lat</code> - Geocentric latitude (degrees or radians)</li> <li><code>lon</code> - Longitude (degrees or radians, positive east)</li> <li><code>radius</code> - Distance from Earth center (meters)</li> <li>Last 3 values unused (set to 0)</li> </ul> <p>Example: <pre><code># Convert geocentric to geodetic\nbrahe transform coordinates --as-degrees geocentric geodetic \"\" 40.0 285.0 6478137 0 0 0\n</code></pre></p>"},{"location":"learn/cli/transform.html#conversion-matrix","title":"Conversion Matrix","text":"<p>Which conversions are supported and what they require:</p> From \u2192 To Keplerian Cartesian (ECI) Cartesian (ECEF) Geodetic Geocentric Keplerian - Direct Epoch\u2020 Epoch\u2020 Epoch\u2020 Cartesian (ECI) Direct - Epoch\u2020 Epoch\u2020 Epoch\u2020 Cartesian (ECEF) Epoch\u2020 Epoch\u2020 - Direct Direct Geodetic N/A* Epoch\u2020 Direct - Direct Geocentric N/A* Epoch\u2020 Direct Direct - <ul> <li><code>Direct</code> = No epoch required (use <code>\"\"</code> for EPOCH argument)</li> <li><code>Epoch\u2020</code> = Requires epoch in ISO-8601 format</li> <li><code>N/A*</code> = Not physically meaningful (position-only \u2192 velocity-dependent)</li> </ul>"},{"location":"learn/cli/transform.html#common-workflows","title":"Common Workflows","text":""},{"location":"learn/cli/transform.html#satellite-ground-track","title":"Satellite Ground Track","text":"<p>Determine where a satellite is above the Earth:</p> <pre><code>#!/bin/bash\n# Satellite in Keplerian elements (SSO, 500km)\nKEP=\"6878137 0.001 97.8 0 0 45\"\nEPOCH=\"2024-01-01T00:00:00Z\"\n\n# Convert to geodetic position\nbrahe transform coordinates --as-degrees --to-frame ECEF \\\n  keplerian geodetic \"$EPOCH\" $KEP\n</code></pre>"},{"location":"learn/cli/transform.html#orbit-analysis-at-different-anomalies","title":"Orbit Analysis at Different Anomalies","text":"<pre><code>#!/bin/bash\n# Orbit parameters\nSMA=\"6878137\"    # Semi-major axis (500km altitude)\nECC=\"0.01\"       # Eccentricity (elliptical)\nINC=\"63.4\"       # Inclination (Molniya)\n\n# State at perigee (\u03bd = 0\u00b0)\necho \"Perigee:\"\nbrahe transform coordinates keplerian cartesian \"\" $SMA $ECC $INC 0 0 0 --as-degrees\n\n# State at apogee (\u03bd = 180\u00b0)\necho \"Apogee:\"\nbrahe transform coordinates keplerian cartesian \"\" $SMA $ECC $INC 0 0 180 --as-degrees\n</code></pre>"},{"location":"learn/cli/transform.html#ground-station-to-eci","title":"Ground Station to ECI","text":"<p>Convert ground station location to ECI at specific epoch:</p> <pre><code>#!/bin/bash\n# Svalbard ground station: 78.23\u00b0N, 15.39\u00b0E, 500m altitude\nLAT=\"78.23\"\nLON=\"15.39\"\nALT=\"500\"\nEPOCH=\"2024-06-21T12:00:00Z\"  # Summer solstice\n\nbrahe transform coordinates --as-degrees --to-frame ECI \\\n  geodetic cartesian \"$EPOCH\" $LAT $LON $ALT 0 0 0\n</code></pre>"},{"location":"learn/cli/transform.html#eci-state-history","title":"ECI State History","text":"<p>Track how ECEF coordinates change over time:</p> <pre><code>#!/bin/bash\n# Satellite ECI state\nSTATE=\"6878137 0 0 0 7500 0\"\n\n# Different epochs (6-hour intervals)\nfor hour in 0 6 12 18; do\n  epoch=\"2024-01-01T$(printf \"%02d\" $hour):00:00Z\"\n  echo \"Epoch $epoch:\"\n  brahe transform frame ECI ECEF \"$epoch\" $STATE\n  echo\ndone\n</code></pre>"},{"location":"learn/cli/transform.html#tips","title":"Tips","text":""},{"location":"learn/cli/transform.html#handling-negative-values","title":"Handling Negative Values","text":"<p>Shell arguments starting with <code>-</code> are interpreted as options. To pass negative numbers:</p> <p>Method 1: Use <code>--</code> separator (options must come before <code>--</code>): <pre><code>brahe transform coordinates --as-degrees cartesian keplerian \"\" -- -1000 500 0 0 0 0\n</code></pre></p> <p>Method 2: Convert to positive equivalents: <pre><code># Longitude -74\u00b0 = 286\u00b0\nbrahe transform coordinates geodetic cartesian \"\" 40.7128 286.0 10 0 0 0 --as-degrees\n</code></pre></p>"},{"location":"learn/cli/transform.html#when-epoch-is-required","title":"When Epoch is Required","text":"<ul> <li>Frame transformations (ECI \u2194 ECEF): Always required</li> <li>Geodetic/Geocentric involving ECI: Always required</li> <li>Pure Keplerian \u2194 Cartesian (ECI): Not required (use <code>\"\"</code>)</li> <li>Pure Geodetic \u2194 Geocentric: Not required (use <code>\"\"</code>)</li> </ul>"},{"location":"learn/cli/transform.html#angle-format-consistency","title":"Angle Format Consistency","text":"<p><code>--as-degrees</code> applies to both input and output: <pre><code># Input in degrees, output in degrees\nbrahe transform coordinates --as-degrees keplerian cartesian \"\" 6878137 0.001 97.8 0 0 0\n\n# Input in radians, output in radians\nbrahe transform coordinates --no-as-degrees keplerian cartesian \"\" 6878137 0.001 1.706 0 0 0\n</code></pre></p>"},{"location":"learn/cli/transform.html#using-constants","title":"Using Constants","text":"<p>All numeric arguments support Brahe constants: <pre><code># Use R_EARTH constant\nbrahe transform coordinates keplerian cartesian \"\" \"R_EARTH+500e3\" 0.001 97.8 0 0 0 --as-degrees\n\n# Use multiple constants\nbrahe transform coordinates keplerian cartesian \"\" \"R_EARTH+35786e3\" 0.0001 0.1 0 0 0 --as-degrees\n</code></pre></p>"},{"location":"learn/cli/transform.html#output-precision","title":"Output Precision","text":"<p>Control precision for debugging or analysis: <pre><code># Scientific notation\nbrahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0 --format .3e\n\n# High precision (10 decimal places)\nbrahe transform frame ECI ECEF \"2024-01-01T00:00:00Z\" 6878137 0 0 0 7500 0 --format .10f\n</code></pre></p>"},{"location":"learn/cli/transform.html#see-also","title":"See Also","text":"<ul> <li>Coordinate Systems - Conceptual overview</li> <li>Reference Frames - ECI/ECEF details</li> <li>Coordinates API - Python API</li> <li>Frames API - Frame conversion functions</li> <li>Orbits API - Orbital elements</li> <li>Time CLI - Time conversions</li> <li>Orbits CLI - Orbital mechanics calculations</li> </ul>"},{"location":"learn/coordinates/index.html","title":"Coordinate Transformations","text":"<p>Coordinate systems are fundamental to astrodynamics, allowing us to represent positions and velocities in different reference frames optimized for specific calculations. Brahe provides comprehensive coordinate transformation capabilities between multiple systems.</p>"},{"location":"learn/coordinates/index.html#overview","title":"Overview","text":"<p>Brahe supports three primary coordinate systems for representing positions on or near Earth:</p> <ol> <li>Cartesian Coordinates - 3D rectangular coordinates <code>[x, y, z]</code></li> <li>Geocentric Coordinates - Spherical coordinates <code>[radius, latitude, longitude]</code></li> <li>Geodetic Coordinates - Ellipsoidal coordinates accounting for Earth's shape <code>[latitude, longitude, altitude]</code></li> <li>Topocentric Coordinates - Local horizontal coordinates relative to an observer <code>[East, North, Zenith]</code> or <code>[Azimuth, Elevation, Range]</code></li> </ol> <p>Each system has specific use cases and advantages depending on the problem being solved.</p>"},{"location":"learn/coordinates/index.html#coordinate-systems","title":"Coordinate Systems","text":""},{"location":"learn/coordinates/index.html#cartesian-coordinates","title":"Cartesian Coordinates","text":"<p>Cartesian coordinates represent positions as 3D vectors with orthogonal axes:</p> <ul> <li>ECEF (Earth-Centered Earth-Fixed): Rotates with Earth, Z-axis through North Pole</li> <li>ECI (Earth-Centered Inertial): Inertial frame fixed to celestial sphere</li> </ul> <p>Best for: - Orbital mechanics (Newton's laws in inertial frames) - Vector operations (dot products, cross products) - Frame transformations (rotation matrices)</p> <p>See: Cartesian Transformations</p>"},{"location":"learn/coordinates/index.html#geocentric-coordinates","title":"Geocentric Coordinates","text":"<p>Geocentric coordinates use spherical representation <code>[r, \u03c6, \u03bb]</code>:</p> <ul> <li>r: Distance from Earth's center (meters)</li> <li>\u03c6: Geocentric latitude (radians)</li> <li>\u03bb: Longitude (radians)</li> </ul> <p>Best for: - Spherical Earth approximations - Quick distance calculations - When Earth's oblateness can be ignored</p> <p>See: Geocentric Transformations</p>"},{"location":"learn/coordinates/index.html#geodetic-coordinates","title":"Geodetic Coordinates","text":"<p>Geodetic coordinates account for Earth's ellipsoidal shape using WGS84:</p> <ul> <li>\u03c6: Geodetic latitude - angle from equatorial plane to surface normal (radians)</li> <li>\u03bb: Longitude (radians)</li> <li>h: Height above WGS84 ellipsoid (meters)</li> </ul> <p>Best for: - Ground station locations - GPS coordinates - Precise Earth surface positioning - Terrain-relative calculations</p> <p>See: Geodetic &amp; Geocentric Transformations</p>"},{"location":"learn/coordinates/index.html#topocentric-coordinates","title":"Topocentric Coordinates","text":"<p>Topocentric coordinates are local horizontal systems centered at an observer:</p> <p>ENZ (East-North-Zenith): - Local Cartesian with origin at observer - E: East direction, N: North direction, Z: Zenith (up)</p> <p>SEZ (South-East-Zenith): - Alternative convention with S: South, E: East, Z: Zenith</p> <p>Azimuth-Elevation-Range: - Spherical representation of observer-relative position - Az: Compass bearing (0\u00b0 = North, 90\u00b0 = East) - El: Elevation angle above horizon (degrees) - Range: Distance to object (meters)</p> <p>Best for: - Ground station tracking - Antenna pointing - Visibility calculations - Access computation</p> <p>See: Topocentric Transformations</p>"},{"location":"learn/coordinates/index.html#common-transformation-chains","title":"Common Transformation Chains","text":""},{"location":"learn/coordinates/index.html#satellite-state-to-ground-observer","title":"Satellite State to Ground Observer","text":"<pre><code>ECI State \u2192 ECEF State \u2192 Topocentric Position \u2192 Az/El/Range\n</code></pre> <p>Used for ground station tracking and visibility.</p>"},{"location":"learn/coordinates/index.html#ground-location-to-orbit-frame","title":"Ground Location to Orbit Frame","text":"<pre><code>Geodetic (lat/lon/alt) \u2192 ECEF Position \u2192 ECI Position\n</code></pre> <p>Used for determining when satellites can view ground locations.</p>"},{"location":"learn/coordinates/index.html#orbital-elements-to-cartesian","title":"Orbital Elements to Cartesian","text":"<pre><code>Keplerian Elements \u2192 ECI Cartesian State\n</code></pre> <p>Used for orbit propagation and trajectory analysis.</p>"},{"location":"learn/coordinates/index.html#key-concepts","title":"Key Concepts","text":""},{"location":"learn/coordinates/index.html#reference-frames","title":"Reference Frames","text":"<ul> <li>Inertial Frames (ECI): Non-rotating, fixed to celestial sphere. Required for applying Newton's laws.</li> <li>Rotating Frames (ECEF): Rotate with Earth. Natural for ground-based observations.</li> <li>Topocentric Frames (ENZ/SEZ): Local observer-centered. Natural for antenna pointing.</li> </ul>"},{"location":"learn/coordinates/index.html#frame-transformations","title":"Frame Transformations","text":"<p>Transformations between ECI and ECEF require: - Precession and nutation models (IAU 2006/2000A) - Earth Orientation Parameters (EOP) for high precision - Time system conversions (UTC, UT1, TT)</p> <p>See: Frame Transformations</p>"},{"location":"learn/coordinates/index.html#coordinate-system-properties","title":"Coordinate System Properties","text":"System Origin Axes Rotating Best Use Case ECI Earth center Celestial No Orbit propagation ECEF Earth center Earth-fixed Yes Ground locations Geodetic Earth surface Ellipsoid normal Yes GPS, ground stations Geocentric Earth center Spherical Yes Simplified calculations Topocentric Observer Local horizontal Yes Tracking, visibility"},{"location":"learn/coordinates/index.html#usage-patterns","title":"Usage Patterns","text":""},{"location":"learn/coordinates/index.html#converting-satellite-state-to-observer-view","title":"Converting Satellite State to Observer View","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Satellite state in ECI\nsat_state_eci = np.array([...])  # [x, y, z, vx, vy, vz]\n\n# Convert to ECEF\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nsat_state_ecef = bh.state_eci_to_ecef(sat_state_eci, epoch)\n\n# Observer location (geodetic)\nobserver_lat = np.radians(40.0)  # 40\u00b0 N\nobserver_lon = np.radians(-75.0)  # 75\u00b0 W\nobserver_alt = 100.0  # meters\n\n# Convert observer to ECEF\nobserver_ecef = bh.position_geodetic_to_ecef(observer_lat, observer_lon, observer_alt)\n\n# Compute topocentric position\nrelative_ecef = sat_state_ecef[:3] - observer_ecef\nenz = bh.relative_position_ecef_to_enz(relative_ecef, observer_lat, observer_lon)\n\n# Convert to azimuth/elevation\naz, el, range_m = bh.position_enz_to_azel(enz)\n\nprint(f\"Azimuth: {np.degrees(az):.1f}\u00b0\")\nprint(f\"Elevation: {np.degrees(el):.1f}\u00b0\")\nprint(f\"Range: {range_m/1000:.1f} km\")\n</code></pre>"},{"location":"learn/coordinates/index.html#ground-station-network-in-multiple-systems","title":"Ground Station Network in Multiple Systems","text":"<pre><code># Define stations in geodetic (natural input)\nstations_geodetic = [\n    (np.radians(15.4), np.radians(78.2), 0.0),  # Svalbard\n    (np.radians(-64.5), np.radians(-31.5), 0.0),  # Malargue\n    (np.radians(-117.2), np.radians(34.1), 500.0),  # Goldstone\n]\n\n# Convert to ECEF for computations\nstations_ecef = [\n    bh.position_geodetic_to_ecef(lat, lon, alt)\n    for lat, lon, alt in stations_geodetic\n]\n\n# Also compute geocentric for reference\nstations_geocentric = [\n    bh.position_ecef_to_geocentric(ecef)\n    for ecef in stations_ecef\n]\n</code></pre>"},{"location":"learn/coordinates/index.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/coordinates/index.html#transformation-cost","title":"Transformation Cost","text":"<p>Coordinate transformations have different computational costs:</p> <ul> <li>Cartesian \u2194 Geocentric: Fast (trigonometric functions)</li> <li>Cartesian \u2194 Geodetic: Moderate (iterative algorithm for inverse)</li> <li>ECI \u2194 ECEF: Moderate to expensive (precession/nutation models)</li> <li>ECEF \u2192 Topocentric: Fast (rotation matrix)</li> </ul>"},{"location":"learn/coordinates/index.html#when-to-cache","title":"When to Cache","text":"<p>For repeated transformations at the same epoch: - Cache rotation matrices for ECI \u2194 ECEF - Precompute observer ECEF positions - Store frequently-used station locations</p>"},{"location":"learn/coordinates/index.html#batch-operations","title":"Batch Operations","text":"<p>When transforming multiple points: <pre><code># Single rotation matrix for all points at same epoch\nR = bh.rotation_matrix_ecef_to_eci(epoch)\n\n# Apply to all states\nstates_eci = [R @ state_ecef[:3] for state_ecef in states_ecef]\n</code></pre></p>"},{"location":"learn/coordinates/index.html#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"learn/coordinates/index.html#latitude-types","title":"Latitude Types","text":"<p>Geodetic vs Geocentric latitude: - Geodetic: Perpendicular to ellipsoid surface (GPS uses this) - Geocentric: Angle from Earth center</p> <p>These differ by up to 0.2\u00b0 at mid-latitudes!</p>"},{"location":"learn/coordinates/index.html#longitude-wrapping","title":"Longitude Wrapping","text":"<p>Ensure consistent longitude ranges: - Use <code>-180\u00b0 to +180\u00b0</code> (preferred in Brahe) - Not <code>0\u00b0 to 360\u00b0</code></p>"},{"location":"learn/coordinates/index.html#angle-units","title":"Angle Units","text":"<p>All Brahe functions use radians internally: <pre><code># Use AngleFormat enum for clarity\nlat_deg = 40.0\nlat_rad = np.radians(lat_deg)\npos = bh.position_geodetic_to_ecef(lat_rad, lon_rad, alt)\n</code></pre></p>"},{"location":"learn/coordinates/index.html#frame-consistency","title":"Frame Consistency","text":"<p>Never mix coordinates from different frames: <pre><code># WRONG: Mixing ECI and ECEF\nrange_vec = sat_state_eci[:3] - observer_ecef  # Error!\n\n# CORRECT: Convert to same frame first\nsat_state_ecef = bh.state_eci_to_ecef(sat_state_eci, epoch)\nrange_vec = sat_state_ecef[:3] - observer_ecef  # OK\n</code></pre></p>"},{"location":"learn/coordinates/index.html#see-also","title":"See Also","text":"<ul> <li>Cartesian Transformations - ECI and ECEF Cartesian coordinates</li> <li>Geocentric &amp; Geodetic Transformations - Spherical and ellipsoidal Earth models</li> <li>Topocentric Transformations - Local horizontal coordinate systems</li> <li>Frame Transformations - Transformations between reference frames</li> <li>Coordinates API Reference - Complete coordinate function documentation</li> </ul>"},{"location":"learn/coordinates/cartesean_transformations.html","title":"Cartesian Coordinate Transformations","text":"<p>Cartesian coordinates represent positions and velocities in 3D space using orthogonal axes.</p>"},{"location":"learn/coordinates/cartesean_transformations.html#overview","title":"Overview","text":"<p>Cartesian coordinates are the foundation for orbital mechanics computations in Brahe. Positions and velocities are represented as:</p> <ul> <li>Position: <code>[x, y, z]</code> in meters</li> <li>Velocity: <code>[vx, vy, vz]</code> in meters/second</li> <li>State: <code>[x, y, z, vx, vy, vz]</code></li> </ul>"},{"location":"learn/coordinates/cartesean_transformations.html#coordinate-frames","title":"Coordinate Frames","text":"<p>Brahe works with Cartesian coordinates in different reference frames:</p> <ul> <li>ECI (Earth-Centered Inertial): Inertial frame fixed to stars</li> <li>ECEF (Earth-Centered Earth-Fixed): Rotates with Earth</li> <li>Local frames: Relative to ground stations or spacecraft</li> </ul>"},{"location":"learn/coordinates/cartesean_transformations.html#converting-between-frames","title":"Converting Between Frames","text":"<p>Use the frame transformation functions to convert between ECI and ECEF:</p> <pre><code>import brahe as bh\n\n# Convert from ECI to ECEF\nstate_ecef = bh.state_eci_to_ecef(epoch, state_eci)\n\n# Convert from ECEF to ECI\nstate_eci = bh.state_ecef_to_eci(epoch, state_ecef)\n</code></pre>"},{"location":"learn/coordinates/cartesean_transformations.html#see-also","title":"See Also","text":"<ul> <li>Frame Transformations</li> <li>Cartesian API Reference</li> <li>Frames API Reference</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html","title":"Geocentric Coordinate Transformations","text":"<p>Geocentric coordinates represent positions using spherical coordinates centered at Earth's center.</p>"},{"location":"learn/coordinates/geocentric_transformations.html#overview","title":"Overview","text":"<p>Geocentric coordinates describe a position using:</p> <ul> <li>Radius (r): Distance from Earth's center in meters</li> <li>Latitude (\u03c6): Angle north/south of equator in radians</li> <li>Longitude (\u03bb): Angle east of prime meridian in radians</li> </ul> <p>Format: <code>[radius, latitude, longitude]</code></p>"},{"location":"learn/coordinates/geocentric_transformations.html#geocentric-vs-geodetic","title":"Geocentric vs Geodetic","text":"<p>Important Distinction</p> <p>Geocentric coordinates use a spherical Earth model, while geodetic coordinates use the WGS84 ellipsoid. The latitude values differ between the two systems.</p> <p>Geocentric latitude: Angle from equatorial plane to point Geodetic latitude: Angle from equatorial plane to surface normal</p>"},{"location":"learn/coordinates/geocentric_transformations.html#conversions","title":"Conversions","text":""},{"location":"learn/coordinates/geocentric_transformations.html#geocentric-to-ecef-cartesian","title":"Geocentric to ECEF (Cartesian)","text":"<pre><code>import brahe as bh\n\n# Geocentric coordinates [radius, lat, lon] in meters and radians\ngeocentric = [bh.R_EARTH + 500e3, bh.DEG2RAD * 45.0, bh.DEG2RAD * -122.0]\n\n# Convert to ECEF Cartesian\necef = bh.position_geocentric_to_ecef(geocentric)\n</code></pre>"},{"location":"learn/coordinates/geocentric_transformations.html#ecef-to-geocentric","title":"ECEF to Geocentric","text":"<pre><code>import brahe as bh\n\n# ECEF Cartesian position\necef = [3194.469e3, -3194.469e3, 4487.348e3]\n\n# Convert to geocentric\ngeocentric = bh.position_ecef_to_geocentric(ecef)\nradius, lat, lon = geocentric\n</code></pre>"},{"location":"learn/coordinates/geocentric_transformations.html#use-cases","title":"Use Cases","text":"<p>Geocentric coordinates are useful for:</p> <ul> <li>Quick distance calculations from Earth's center</li> <li>Simplified orbital computations</li> <li>When Earth oblateness can be ignored</li> </ul>"},{"location":"learn/coordinates/geocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Geodetic Coordinates</li> <li>Geocentric API Reference</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html","title":"Topocentric Coordinate Transformations","text":"<p>Topocentric coordinates represent positions relative to a location on Earth's surface.</p>"},{"location":"learn/coordinates/topocentric_transformations.html#overview","title":"Overview","text":"<p>Topocentric coordinates describe a position relative to an observer on Earth using local horizontal coordinates:</p> <ul> <li>East (E): Eastward component in meters</li> <li>North (N): Northward component in meters</li> <li>Zenith (Z): Upward component in meters</li> </ul> <p>Format: <code>[east, north, zenith]</code> (ENZ coordinates)</p>"},{"location":"learn/coordinates/topocentric_transformations.html#alternative-sez-coordinates","title":"Alternative: SEZ Coordinates","text":"<p>Some applications use SEZ (South-East-Zenith) coordinates instead:</p> <ul> <li>South (S): Southward component</li> <li>East (E): Eastward component</li> <li>Zenith (Z): Upward component</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html#azimuth-elevation","title":"Azimuth-Elevation","text":"<p>Topocentric positions can also be expressed in spherical coordinates:</p> <ul> <li>Azimuth (Az): Angle from north (clockwise) in radians</li> <li>Elevation (El): Angle above horizon in radians</li> <li>Range (R): Distance from observer in meters</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html#conversions","title":"Conversions","text":""},{"location":"learn/coordinates/topocentric_transformations.html#relative-position-to-enz","title":"Relative Position to ENZ","text":"<pre><code>import brahe as bh\n\n# Observer location (geodetic)\nobserver_lat = bh.DEG2RAD * 40.0\nobserver_lon = bh.DEG2RAD * -105.0\nobserver_alt = 1655.0  # meters\n\n# Satellite position in ECEF\nsatellite_ecef = [...]\n\n# Observer position in ECEF\nobserver_ecef = bh.position_geodetic_to_ecef([observer_lat, observer_lon, observer_alt])\n\n# Relative position\nrelative_ecef = satellite_ecef - observer_ecef\n\n# Convert to ENZ\nenz = bh.relative_position_ecef_to_enz(observer_lat, observer_lon, relative_ecef)\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#enz-to-azimuth-elevation-range","title":"ENZ to Azimuth-Elevation-Range","text":"<pre><code>import brahe as bh\n\n# ENZ position\nenz = [1000.0, 2000.0, 500000.0]\n\n# Convert to azimuth, elevation, range\nazel = bh.position_enz_to_azel(enz)\nazimuth, elevation, range = azel\n</code></pre>"},{"location":"learn/coordinates/topocentric_transformations.html#use-cases","title":"Use Cases","text":"<p>Topocentric coordinates are essential for:</p> <ul> <li>Ground station tracking</li> <li>Satellite visibility analysis</li> <li>Antenna pointing calculations</li> <li>Local horizon constraints</li> </ul>"},{"location":"learn/coordinates/topocentric_transformations.html#see-also","title":"See Also","text":"<ul> <li>Topocentric API Reference</li> <li>Access Computation</li> </ul>"},{"location":"learn/datasets/index.html","title":"Datasets","text":"<p>The datasets module in Brahe provides easy access to common datasources used in astrodynamics, space mission analysis, and research. This includes ephemeris data for Earth-orbiting satellites and locations of ground stations.</p>"},{"location":"learn/datasets/index.html#available-datasets","title":"Available Datasets","text":""},{"location":"learn/datasets/index.html#satellite-ephemeris","title":"Satellite Ephemeris","text":"<ul> <li>CelesTrak: Two-Line Element (TLE) sets for thousands of Earth-orbiting satellites</li> <li>Free access, no registration required</li> <li>Organized by satellite groups (GNSS, communications, Earth observation, etc.)</li> <li>Updated multiple times daily</li> <li>See CelesTrak documentation for details</li> </ul>"},{"location":"learn/datasets/index.html#groundstation-networks","title":"Groundstation Networks","text":"<ul> <li>Groundstation Datasets: Commercial ground station locations and metadata</li> <li>Six major provider networks (Atlas, AWS, KSAT, Leaf, SSC, Viasat)</li> <li>Embedded data (no external files required)</li> <li>Geographic coordinates and frequency band information</li> <li>See Groundstation documentation for details</li> </ul>"},{"location":"learn/datasets/index.html#use-cases","title":"Use Cases","text":"<p>Satellite Tracking: Download current TLE data for satellites of interest and propagate their orbits</p> <p>Coverage Analysis: Evaluate ground network coverage for satellite missions</p> <p>Mission Planning: Assess communication opportunities using real groundstation networks</p> <p>Research: Access historical or current ephemeris for analysis and validation</p>"},{"location":"learn/datasets/index.html#data-philosophy","title":"Data Philosophy","text":"<p>Brahe's datasets module aims to:</p> <ul> <li>Reduce friction: Provide easy access to commonly needed data</li> <li>No surprises: Data sources are clearly documented with known limitations</li> <li>Offline capable: Prefer embedded data when feasible (groundstations)</li> <li>Respect providers: Follow best practices and rate limiting (CelesTrak)</li> <li>Stay current: Update data sources as the ecosystem evolves</li> </ul>"},{"location":"learn/datasets/celestrak.html","title":"CelesTrak Data Source","text":"<p>CelesTrak is a public source for satellite Two-Line Element (TLE) data, maintained by T.S. Kelso since 1985. It provides free, frequently updated orbital element sets for thousands of satellites, making it a useful resource for satellite tracking, orbit determination, and space situational awareness.</p>"},{"location":"learn/datasets/celestrak.html#overview","title":"Overview","text":"<p>Website: https://celestrak.org</p> <p>Maintainer: Dr. T.S. Kelso</p> <p>Update frequency: Multiple times daily (varies by satellite priority)</p> <p>Access: No registration or API key required</p>"},{"location":"learn/datasets/celestrak.html#why-celestrak","title":"Why CelesTrak?","text":""},{"location":"learn/datasets/celestrak.html#advantages","title":"Advantages","text":"<p>Free and Open: - No registration required - No rate limits for reasonable use - Publicly accessible worldwide - Stable, long-term availability</p> <p>Well-Organized: - Satellites grouped by function and constellation - Consistent naming conventions - Regular group updates as missions change - Special groupings for recent launches and interesting events</p>"},{"location":"learn/datasets/celestrak.html#limitations","title":"Limitations","text":"<p>Update Latency: - Data comes from Space-Track.org with some delay - Not as current as direct Space-Track access - Typically 1-6 hours behind during active tracking periods</p> <p>Limited Historical Data: - Focuses on current/recent TLEs - Historical archives available but not comprehensive - For deep historical analysis, use Space-Track.org directly</p>"},{"location":"learn/datasets/celestrak.html#satellite-groups","title":"Satellite Groups","text":"<p>CelesTrak organizes satellites into logical groups accessible via simple names. These groups are maintained as constellations evolve.</p>"},{"location":"learn/datasets/celestrak.html#temporal-groups","title":"Temporal Groups","text":"Group Description Typical Count <code>active</code> All active satellites ~5,000+ <code>last-30-days</code> Recently launched satellites 20-100 (varies) <code>tle-new</code> Newly added TLEs (last 15 days) Variable"},{"location":"learn/datasets/celestrak.html#communications","title":"Communications","text":"Group Description <code>starlink</code> SpaceX Starlink constellation <code>oneweb</code> OneWeb constellation <code>kuiper</code> Amazon Kuiper constellation <code>intelsat</code> Intelsat satellites <code>eutelsat</code> Eutelsat constellation <code>orbcomm</code> ORBCOMM constellation <code>telesat</code> Telesat constellation <code>globalstar</code> Globalstar constellation <code>iridium-NEXT</code> Iridium constellation <code>qianfan</code> Qianfan constellation <code>hulianwang</code> Hulianwang Digui constellation"},{"location":"learn/datasets/celestrak.html#earth-observation","title":"Earth Observation","text":"Group Description <code>weather</code> Weather satellites (NOAA, GOES, Metop, etc.) <code>earth-resources</code> Earth observation (Landsat, Sentinel, etc.) <code>planet</code> Planet Labs imaging satellites <code>spire</code> Spire Global satellites"},{"location":"learn/datasets/celestrak.html#navigation","title":"Navigation","text":"Group Description <code>gnss</code> All navigation satellites (GPS, GLONASS, Galileo, BeiDou, QZSS, IRNSS) <code>gps-ops</code> Operational GPS satellites only <code>glonass-ops</code> Operational GLONASS satellites only <code>galileo</code> European Galileo constellation <code>beidou</code> Chinese BeiDou/COMPASS constellation <code>sbas</code> Satellite-Based Augmentation System (WAAS/EGNOS/MSAS)"},{"location":"learn/datasets/celestrak.html#scientific-and-special-purpose","title":"Scientific and Special Purpose","text":"Group Description <code>science</code> Scientific research satellites <code>noaa</code> NOAA satellites <code>stations</code> Space stations (ISS, Tiangong) <code>analyst</code> Analyst satellites (tracking placeholder IDs) <code>visual</code> 100 (or so) brightest objects <code>gpz</code> Geostationary Protected Zone <code>gpz-plus</code> Geostationary Protected Zone Plus <p>Note: Group names and contents evolve as missions launch, deorbit, or change status. Visit CelesTrak GP Element Sets for the current complete list.</p>"},{"location":"learn/datasets/celestrak.html#data-quality-and-currency","title":"Data Quality and Currency","text":"<p>TLE updates depend on the object itself, it's tracking priority, how difficult to track it is, and how often it's maneuvering. CelesTrak provides statistics on the median and mean age of TLEs by group. This has been about 0.8 and 1.5 days respectively in recent years, but can vary.</p>"},{"location":"learn/datasets/celestrak.html#accuracy-considerations","title":"Accuracy Considerations","text":"<p>For most operational applications TLEs should be updated daily. For research or general analysis, it's generally fine to just download and save the ephemeris once.</p> <p>Propagation accuracy: - Best within hours of epoch - Degrades beyond 3-7 days for LEO - Acceptable for 1-2 weeks for MEO/GEO</p> <p>When to refresh: - LEO tracking: Daily updates recommended - GNSS analysis: Weekly updates acceptable - GEO operations: Monthly updates sufficient</p>"},{"location":"learn/datasets/celestrak.html#access-methods","title":"Access Methods","text":""},{"location":"learn/datasets/celestrak.html#brahe-integration","title":"Brahe Integration","text":"<p>Brahe provides convenient API for CelesTrak access:</p> <pre><code>import brahe as bh\n\n# Get ephemeris data\nephemeris = bh.datasets.celestrak.get_ephemeris(\"gnss\")\n# Returns: List of (name, line1, line2) tuples\n\n# Get as propagators\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\n    \"gnss\",\n    step_size=60.0\n)\n\n# Download and save\nbh.datasets.celestrak.download_ephemeris(\n    \"gnss\",\n    \"gnss_satellites.json\",\n    content_format=\"3le\",\n    file_format=\"json\"\n)\n</code></pre>"},{"location":"learn/datasets/celestrak.html#best-practices","title":"Best Practices","text":""},{"location":"learn/datasets/celestrak.html#respectful-usage","title":"Respectful Usage","text":"<p>While CelesTrak has no strict rate limits, follow these guidelines:</p> <p>DO: - Cache downloaded data locally - Refresh on reasonable schedules (hourly at most) - Use appropriate update intervals for your orbit regime - Implement exponential backoff on errors</p> <p>DON'T: - Poll every minute (excessive) - Download all groups when you need one - Ignore errors and retry immediately - Run unattended scripts without rate limiting</p>"},{"location":"learn/datasets/celestrak.html#error-handling","title":"Error Handling","text":"<p>Implement robust error handling:</p> <pre><code>import brahe as bh\nimport time\n\ndef download_with_retry(group, max_retries=3):\n    \"\"\"Download ephemeris with exponential backoff\"\"\"\n    for attempt in range(max_retries):\n        try:\n            ephemeris = bh.datasets.celestrak.get_ephemeris(group)\n            return ephemeris\n        except Exception as e:\n            if attempt &lt; max_retries - 1:\n                wait_time = 2 ** attempt  # Exponential backoff\n                print(f\"Attempt {attempt + 1} failed: {e}\")\n                print(f\"Retrying in {wait_time} seconds...\")\n                time.sleep(wait_time)\n            else:\n                print(f\"All retries failed for {group}\")\n                raise\n\n# Use with error handling\ntry:\n    ephemeris = download_with_retry(\"gnss\")\nexcept Exception as e:\n    print(f\"Failed to download: {e}\")\n    # Fall back to cached data\n</code></pre>"},{"location":"learn/datasets/celestrak.html#caching-strategy","title":"Caching Strategy","text":"<p>Implement local caching to reduce load:</p> <pre><code>import brahe as bh\nfrom pathlib import Path\nimport time\nimport json\n\ndef get_cached_ephemeris(group, cache_dir=\"./cache\", max_age_hours=24):\n    \"\"\"Get ephemeris from cache or download if stale\"\"\"\n    cache_path = Path(cache_dir)\n    cache_path.mkdir(exist_ok=True)\n\n    cache_file = cache_path / f\"{group}.json\"\n\n    # Check if cache exists and is fresh\n    if cache_file.exists():\n        age_seconds = time.time() - cache_file.stat().st_mtime\n        age_hours = age_seconds / 3600\n\n        if age_hours &lt; max_age_hours:\n            # Use cached data\n            with open(cache_file, 'r') as f:\n                return json.load(f)\n\n    # Cache miss or stale - download fresh data\n    ephemeris = bh.datasets.celestrak.get_ephemeris(group)\n\n    # Save to cache\n    with open(cache_file, 'w') as f:\n        json.dump(ephemeris, f)\n\n    return ephemeris\n\n# Use cached ephemeris\nephemeris = get_cached_ephemeris(\"gnss\", max_age_hours=6)\n</code></pre>"},{"location":"learn/datasets/celestrak.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding satellite ephemeris datasets</li> <li>Two-Line Elements - TLE and 3LE format details</li> <li>Downloading TLE Data - Practical examples</li> <li>CelesTrak API Reference - Function documentation</li> </ul>"},{"location":"learn/datasets/groundstations.html","title":"Groundstation Datasets","text":"<p>Brahe includes curated groundstation location datasets from commercial satellite communication providers. These datasets provide standardized geographic coordinates and metadata for ground stations used in satellite operations, tracking, and communications.</p>"},{"location":"learn/datasets/groundstations.html#overview","title":"Overview","text":"<p>Groundstation data in Brahe is embedded directly in the library, requiring no external files or network access. The data represents real commercial groundstation networks maintained by major satellite service providers.</p> <p>Data Source: Publicly available information compiled from provider websites and documentation</p> <p>Format: GeoJSON FeatureCollections parsed into <code>PointLocation</code> objects</p> <p>Update Frequency: Updated periodically with Brahe releases</p>"},{"location":"learn/datasets/groundstations.html#available-providers","title":"Available Providers","text":"<p>Brahe includes groundstation data from six major commercial providers:</p> Provider Description Network Type Atlas Atlas Space Operations Commercial ground network AWS Amazon Web Services Ground Station Cloud-based ground services KSAT Kongsberg Satellite Services Global polar network Leaf Leaf Space Commercial ground network SSC Swedish Space Corporation Commercial and institutional Viasat Viasat Communication services"},{"location":"learn/datasets/groundstations.html#provider-characteristics","title":"Provider Characteristics","text":"<p>Atlas Space Operations - Modern cloud-based ground station network - Focus on automated operations and API access - Growing global coverage - Multiple frequency band support</p> <p>AWS Ground Station - Cloud-native ground station service - Pay-as-you-go pricing model - Integration with AWS services - Strategic global placement</p> <p>KSAT (Kongsberg Satellite Services) - Extensive polar coverage (Arctic and Antarctic) - Long operational history - Large established network - Strong Earth observation support</p> <p>Leaf Space - European-based commercial provider - Focus on LEO satellite support - Flexible antenna sharing - Modern infrastructure</p> <p>SSC (Swedish Space Corporation) - Mix of commercial and institutional facilities - Strong presence in northern latitudes - Launch support capabilities - Experienced operator</p> <p>Viasat - Primarily communications-focused - Global coverage - High-capacity infrastructure - Commercial satellite services</p>"},{"location":"learn/datasets/groundstations.html#data-format","title":"Data Format","text":"<p>Each groundstation is represented as a <code>PointLocation</code> with standardized properties:</p> <pre><code>import brahe as bh\n\nstations = bh.datasets.groundstations.load(\"ksat\")\nstation = stations[0]\n\n# Geographic coordinates (WGS84)\nlon = station.lon()      # Longitude in degrees\nlat = station.lat()      # Latitude in degrees\nalt = station.alt()      # Altitude in meters\n\n# Metadata properties\nprops = station.properties\nname = station.get_name()              # Station name\nprovider = props[\"provider\"]            # Provider name (e.g., \"KSAT\")\nbands = props[\"frequency_bands\"]        # Supported bands (e.g., [\"S\", \"X\"])\n</code></pre>"},{"location":"learn/datasets/groundstations.html#properties-dictionary","title":"Properties Dictionary","text":"<p>All groundstations include these standard properties:</p> <ul> <li><code>provider</code>: Provider name (string, e.g., \"KSAT\", \"Atlas\")</li> <li><code>frequency_bands</code>: List of supported frequency bands (e.g., <code>[\"S\", \"X\", \"Ka\"]</code>)</li> </ul> <p>Additional properties may be included in future releases as data becomes available.</p>"},{"location":"learn/datasets/groundstations.html#frequency-bands","title":"Frequency Bands","text":"<p>Common frequency bands in groundstation data:</p> Band Frequency Range Typical Use S 2-4 GHz TT&amp;C, telemetry X 8-12 GHz High-rate downlink, radar Ku 12-18 GHz Communications Ka 26-40 GHz High-bandwidth communications"},{"location":"learn/datasets/groundstations.html#use-cases","title":"Use Cases","text":""},{"location":"learn/datasets/groundstations.html#access-analysis","title":"Access Analysis","text":"<p>Compute visibility windows between satellites and ground networks:</p> <pre><code>import brahe as bh\n\n# Load ground network\nstations = bh.datasets.groundstations.load(\"ksat\")\n\n# Create satellite propagator\ntle1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\ntle2 = \"2 25544  51.6461 306.0234 0003417  88.1267  25.5695 15.48919103000003\"\npropagator = bh.SGPPropagator.from_tle(tle1, tle2)\n\n# Define search period\nstart = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0, tsys=\"UTC\")\nend = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0, tsys=\"UTC\")\n\n# Compute access windows with minimum elevation constraint\nconstraint = bh.ElevationConstraint(5.0)  # 5 degrees\naccesses = bh.location_accesses(\n    stations,\n    propagator,\n    start,\n    end,\n    constraint\n)\n\n# Analyze coverage\nfor access in accesses:\n    station_name = access.location.get_name()\n    duration = (access.end - access.start) / 60.0\n    print(f\"{station_name}: {duration:.1f} minutes\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#network-coverage-analysis","title":"Network Coverage Analysis","text":"<p>Evaluate geographic distribution and coverage:</p> <pre><code>import brahe as bh\n\n# Load all providers\nall_stations = bh.datasets.groundstations.load_all()\n\n# Analyze by latitude band\narctic = [s for s in all_stations if s.lat() &gt; 66.5]\ntemperate = [s for s in all_stations if -66.5 &lt;= s.lat() &lt;= 66.5]\nantarctic = [s for s in all_stations if s.lat() &lt; -66.5]\n\nprint(f\"Arctic stations: {len(arctic)}\")\nprint(f\"Temperate stations: {len(temperate)}\")\nprint(f\"Antarctic stations: {len(antarctic)}\")\n\n# Find stations by capability\nx_band_stations = [\n    s for s in all_stations\n    if \"X\" in s.properties[\"frequency_bands\"]\n]\nprint(f\"X-band capable: {len(x_band_stations)}\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#mission-planning","title":"Mission Planning","text":"<p>Select appropriate ground network for mission requirements:</p> <pre><code>import brahe as bh\n\n# Requirements\nrequired_bands = [\"S\", \"X\"]\nmin_elevation = 5.0\npreferred_regions = [\"arctic\", \"temperate\"]\n\n# Evaluate providers\nproviders = bh.datasets.groundstations.list_providers()\n\nfor provider in providers:\n    stations = bh.datasets.groundstations.load(provider)\n\n    # Filter by capability\n    capable = [\n        s for s in stations\n        if all(band in s.properties[\"frequency_bands\"] for band in required_bands)\n    ]\n\n    # Check geographic distribution\n    arctic_count = len([s for s in capable if s.lat() &gt; 60])\n\n    print(f\"\\n{provider.upper()}\")\n    print(f\"  Capable stations: {len(capable)}\")\n    print(f\"  Arctic coverage: {arctic_count}\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#data-quality-and-limitations","title":"Data Quality and Limitations","text":""},{"location":"learn/datasets/groundstations.html#accuracy","title":"Accuracy","text":"<p>Geographic Coordinates: - Based on publicly available information - Typically accurate to ~100-1000 meters - Sufficient for access analysis and mission planning - Not suitable for precision pointing or RF link budgets</p> <p>Frequency Bands: - Reflects general provider capabilities - May not represent all antennas at a site - Subject to provider updates and changes - Verify specific capabilities with provider for operational use</p>"},{"location":"learn/datasets/groundstations.html#whats-included","title":"What's Included","text":"<p>Included Data: - Geographic location (latitude, longitude, altitude) - Provider identification - Supported frequency bands - Station names (where available)</p> <p>Not Included: - Antenna parameters (gain, beamwidth, etc.) - Operational schedules or availability - Pricing or commercial terms - Real-time status or health - Contact information</p>"},{"location":"learn/datasets/groundstations.html#data-currency","title":"Data Currency","text":"<p>Groundstation data is updated periodically as part of Brahe releases:</p> <ul> <li>Sources: Provider websites, press releases, public documentation</li> <li>Update cycle: As providers announce new stations or changes</li> <li>Verification: Manual review of provider information</li> <li>No guarantee: Networks change; verify operational details with providers</li> </ul>"},{"location":"learn/datasets/groundstations.html#best-practices","title":"Best Practices","text":""},{"location":"learn/datasets/groundstations.html#when-to-use-embedded-data","title":"When to Use Embedded Data","text":"<p>Appropriate Uses: - Access analysis and link budget studies - Mission planning and concept development - Geographic coverage visualization - Network comparison studies - Educational purposes</p> <p>Verify Before: - Contract negotiations - Operational mission planning - RF link budget calculations - Regulatory filings - Critical mission operations</p>"},{"location":"learn/datasets/groundstations.html#combining-networks","title":"Combining Networks","text":"<p>For comprehensive coverage, combine multiple providers:</p> <pre><code>import brahe as bh\n\n# Load multiple providers\nprimary = bh.datasets.groundstations.load(\"ksat\")\nbackup = bh.datasets.groundstations.load(\"ssc\")\n\n# Combine into single network\ncombined = primary + backup\n\n# Compute access with redundant coverage\naccesses = bh.location_accesses(\n    combined,\n    propagator,\n    start,\n    end,\n    constraint\n)\n</code></pre>"},{"location":"learn/datasets/groundstations.html#custom-groundstation-data","title":"Custom Groundstation Data","text":"<p>For proprietary or specialized groundstations, create custom data:</p> <pre><code>import brahe as bh\n\n# Create custom groundstation\ncustom_station = bh.PointLocation(\n    lon=-122.4,  # degrees\n    lat=37.8,    # degrees\n    alt=100.0    # meters\n).add_property(\"provider\", \"Custom\") \\\n .add_property(\"frequency_bands\", [\"S\", \"X\", \"Ka\"])\n\n# Combine with commercial network\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\nall_stations = [custom_station] + ksat_stations\n</code></pre> <p>Or load from GeoJSON file:</p> <pre><code>import brahe as bh\n\n# Load custom network from file\ncustom_network = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"learn/datasets/groundstations.html#api-access","title":"API Access","text":""},{"location":"learn/datasets/groundstations.html#loading-data","title":"Loading Data","text":"<pre><code>import brahe as bh\n\n# Single provider\nksat = bh.datasets.groundstations.load(\"ksat\")\n\n# All providers\nall_stations = bh.datasets.groundstations.load_all()\n\n# List available providers\nproviders = bh.datasets.groundstations.list_providers()\n</code></pre> <p>See the Groundstation Functions Reference for complete API documentation.</p>"},{"location":"learn/datasets/groundstations.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets in Brahe</li> <li>Groundstation API Reference - Complete function documentation</li> </ul>"},{"location":"learn/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth Orientation Parameters (EOP) are essential corrections that account for irregularities in Earth's rotation. They are required for high-precision transformations between inertial (ECI) and Earth-fixed (ECEF) reference frames.</p>"},{"location":"learn/eop/index.html#overview","title":"Overview","text":"<p>Earth's rotation is not perfectly uniform or predictable due to:</p> <ul> <li>Polar motion: Wobble of Earth's rotation axis relative to its crust</li> <li>UT1-UTC offset: Variations in Earth's rotation rate</li> <li>Nutation: Short-period oscillations in Earth's axis orientation</li> </ul> <p>EOP data provides the corrections needed to accurately transform between coordinate systems, which is critical for:</p> <ul> <li>Satellite orbit determination</li> <li>Ground station tracking</li> <li>Precision timing</li> <li>Navigation and geodesy</li> </ul>"},{"location":"learn/eop/index.html#why-eop-matters","title":"Why EOP Matters","text":""},{"location":"learn/eop/index.html#without-eop","title":"Without EOP","text":"<p>Coordinate transformations using only theoretical models (precession, nutation) can have errors of:</p> <ul> <li>Position errors: 10-30 meters</li> <li>Velocity errors: mm/s level</li> <li>Timing errors: Milliseconds to seconds</li> </ul>"},{"location":"learn/eop/index.html#with-eop","title":"With EOP","text":"<p>Including measured EOP values reduces errors to:</p> <ul> <li>Position errors: &lt; 1 meter</li> <li>Velocity errors: Sub-mm/s</li> <li>Timing accuracy: Sub-millisecond</li> </ul> <p>For most satellite applications, EOP is required for accurate results.</p>"},{"location":"learn/eop/index.html#eop-parameters","title":"EOP Parameters","text":"<p>Brahe uses five primary EOP parameters:</p> Parameter Description Typical Range Units <code>x_p</code> Polar motion X component \u00b10.7 arcsec arcseconds <code>y_p</code> Polar motion Y component \u00b10.7 arcsec arcseconds <code>UT1_UTC</code> UT1 minus UTC time offset \u00b10.9 seconds seconds <code>dX</code> Celestial pole X offset \u00b10.0003 arcsec arcseconds <code>dY</code> Celestial pole Y offset \u00b10.0003 arcsec arcseconds <p>Additionally, derivatives are used for interpolation: - <code>LOD</code>: Length of day variations - Rates of change for <code>x_p</code> and <code>y_p</code></p>"},{"location":"learn/eop/index.html#eop-data-sources","title":"EOP Data Sources","text":"<p>EOP values are measured by the International Earth Rotation and Reference Systems Service (IERS) using:</p> <ul> <li>Very Long Baseline Interferometry (VLBI)</li> <li>Satellite Laser Ranging (SLR)</li> <li>Global Navigation Satellite Systems (GNSS)</li> <li>Doppler Orbitography and Radiopositioning Integrated by Satellite (DORIS)</li> </ul> <p>IERS publishes several data products:</p> <ul> <li>Finals2000A.all: Combined observed + predicted values (recommended)</li> <li>EOP C04: Long-term series with consistent processing</li> <li>Rapid: Near real-time values updated daily</li> <li>Predictions: Future values (lower accuracy)</li> </ul>"},{"location":"learn/eop/index.html#managing-eop-in-brahe","title":"Managing EOP in Brahe","text":"<p>Brahe provides three EOP provider types:</p>"},{"location":"learn/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Loads EOP data from IERS files for production use:</p> <pre><code>import brahe as bh\n\n# Download latest EOP data\nbh.download_iers_eop_data()\n\n# Load from standard location\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# Set as global provider\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: Production applications requiring maximum accuracy.</p>"},{"location":"learn/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Uses built-in historical EOP data or constant values:</p> <pre><code># Use built-in data (covers ~1990-2024)\neop = bh.StaticEOPProvider.from_static_data()\n\n# Or use constant values (for testing)\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n\nbh.set_global_eop_provider(eop)\n</code></pre> <p>When to use: - Testing and development - Historical analysis within built-in data range - Applications where 10-30m accuracy is acceptable</p>"},{"location":"learn/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Wraps another provider with caching for performance:</p> <pre><code># Wrap file provider with cache\nfile_provider = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\ncached_provider = bh.CachingEOPProvider(file_provider, cache_size=1000)\n\nbh.set_global_eop_provider(cached_provider)\n</code></pre> <p>When to use: High-frequency EOP queries at similar epochs (e.g., batch processing).</p> <p>See: Managing EOP Data</p>"},{"location":"learn/eop/index.html#global-eop-provider","title":"Global EOP Provider","text":"<p>Brahe uses a global EOP provider that is accessed automatically during frame transformations:</p> <pre><code># Set global provider (do this once at program start)\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# Frame transformations automatically use global EOP\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)  # Uses global EOP\n</code></pre> <p>Important: The global provider must be set before any frame transformations, or an error will occur.</p>"},{"location":"learn/eop/index.html#workflow","title":"Workflow","text":""},{"location":"learn/eop/index.html#production-application","title":"Production Application","text":"<pre><code>import brahe as bh\n\n# 1. Download latest EOP data (run periodically, e.g., weekly)\nbh.download_iers_eop_data()\n\n# 2. Load EOP provider at program startup\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n\n# 3. Perform frame transformations (EOP used automatically)\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n</code></pre>"},{"location":"learn/eop/index.html#testingdevelopment","title":"Testing/Development","text":"<pre><code>import brahe as bh\n\n# Use static EOP for reproducible tests\neop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\nbh.set_global_eop_provider(eop)\n\n# All transformations use zero EOP values\n# Results are deterministic but less accurate\n</code></pre>"},{"location":"learn/eop/index.html#eop-data-management","title":"EOP Data Management","text":""},{"location":"learn/eop/index.html#downloading-updates","title":"Downloading Updates","text":"<p>EOP data should be updated periodically:</p> <pre><code># Download latest data\nbh.download_iers_eop_data()\n\n# Reload provider with new data\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\nbh.set_global_eop_provider(eop)\n</code></pre> <p>Update frequency: - Real-time applications: Daily - Planning applications: Weekly - Historical analysis: Not needed (use archived data)</p>"},{"location":"learn/eop/index.html#data-file-location","title":"Data File Location","text":"<p>By default, EOP files are stored in: - Unix/Linux/macOS: <code>~/.brahe/</code> - Windows: <code>C:\\Users\\&lt;username&gt;\\.brahe\\</code></p> <p>Files are cached locally and reused until updated.</p>"},{"location":"learn/eop/index.html#eop-data-coverage","title":"EOP Data Coverage","text":"<p>IERS publishes: - Historical: Observed values from 1973 to ~7 days ago - Recent: Rapid service values (updated daily) - Future: Predictions up to 1 year ahead (less accurate)</p> <p>For dates beyond prediction range, extrapolation is used (accuracy degrades).</p>"},{"location":"learn/eop/index.html#performance-considerations","title":"Performance Considerations","text":""},{"location":"learn/eop/index.html#eop-query-cost","title":"EOP Query Cost","text":"<p>Querying EOP data requires: 1. Date conversion (epoch \u2192 MJD) 2. Table lookup or interpolation 3. Parameter extraction</p> <p>Typical cost: 1-10 microseconds per query</p>"},{"location":"learn/eop/index.html#caching-strategy","title":"Caching Strategy","text":"<p>For repeated transformations at similar epochs:</p> <pre><code># Without caching: ~10 \u03bcs per EOP query\neop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n\n# With caching: ~0.1 \u03bcs per cached query\ncached_eop = bh.CachingEOPProvider(eop, cache_size=1000)\n</code></pre> <p>Caching provides 100\u00d7 speedup for repeated queries.</p>"},{"location":"learn/eop/index.html#batch-operations","title":"Batch Operations","text":"<p>When transforming many states at the same epoch:</p> <pre><code># Query EOP once, reuse for all transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# EOP queried once internally\nfor state in states:\n    state_ecef = bh.state_eci_to_ecef(state, epoch)  # Reuses cached EOP\n</code></pre>"},{"location":"learn/eop/index.html#common-patterns","title":"Common Patterns","text":""},{"location":"learn/eop/index.html#startup-initialization","title":"Startup Initialization","text":"<pre><code>def initialize_eop():\n    \"\"\"Initialize EOP provider at application startup\"\"\"\n    try:\n        # Try to use file-based EOP\n        eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    except Exception:\n        # Fall back to static EOP if file not found\n        print(\"Warning: Using static EOP data (reduced accuracy)\")\n        eop = bh.StaticEOPProvider.from_static_data()\n\n    bh.set_global_eop_provider(eop)\n\n# Call at program start\ninitialize_eop()\n</code></pre>"},{"location":"learn/eop/index.html#periodic-updates","title":"Periodic Updates","text":"<pre><code>import schedule\nimport brahe as bh\n\ndef update_eop_data():\n    \"\"\"Download and reload EOP data\"\"\"\n    bh.download_iers_eop_data()\n    eop = bh.FileEOPProvider.from_default_file(bh.EOPType.StandardBulletinA)\n    bh.set_global_eop_provider(eop)\n    print(\"EOP data updated\")\n\n# Schedule weekly updates\nschedule.every().monday.at(\"02:00\").do(update_eop_data)\n</code></pre>"},{"location":"learn/eop/index.html#testing-with-controlled-eop","title":"Testing with Controlled EOP","text":"<pre><code>import pytest\nimport brahe as bh\n\n@pytest.fixture(autouse=True)\ndef setup_eop():\n    \"\"\"Setup zero EOP for deterministic tests\"\"\"\n    eop = bh.StaticEOPProvider.from_values(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)\n    bh.set_global_eop_provider(eop)\n    yield\n    # Cleanup if needed\n\ndef test_frame_transformation():\n    # Test uses zero EOP values (deterministic)\n    epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n    state_ecef = bh.state_eci_to_ecef(state_eci, epoch)\n    # Assert expected values...\n</code></pre>"},{"location":"learn/eop/index.html#see-also","title":"See Also","text":"<ul> <li>What is EOP Data? - Detailed explanation of EOP parameters and why they matter</li> <li>Managing EOP Data - Practical guide to EOP providers and data management</li> <li>Frame Transformations - How EOP is used in coordinate transformations</li> <li>EOP API Reference - Complete EOP provider documentation</li> <li>IERS Website - Official source for EOP data</li> </ul>"},{"location":"learn/eop/managing_eop_data.html","title":"Managing EOP Data","text":"<p>Generally, users of brahe will not need to directly manage Earth orientation data. The package provides default data files and the <code>CachingEOPProvider</code> to automatically update data as needed. However, for advanced users or those with specific data requirements, brahe provides functionality to load and manage Earth orientation data manually.</p> <p>To make the package interface ergonommic, brahe functions do not explicitly accept Earth orientation data as input parameters. Instead, there is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions. See the Loading Data Sets section for more information on loading and managing Earth orientation data in brahe.</p> <p>If you want to skip understanding Earth orientation data for now, you can initialize the global provider with zeroed values using the <code>initialize_eop()</code> function:</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n}\n</code></pre> <p>Warning</p> <p>Earth orientation data MUST be initialized before using any functionality in brahe that requires Earth orientation data. If no data is initialized, brahe will panic and terminate the program when Earth orientation data is requested.</p>"},{"location":"learn/eop/managing_eop_data.html#earth-orientation-providers","title":"Earth Orientation Providers","text":"<p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>For the most accurate Earth orientation data modeling in scripts, you should download the latest available Earth orientation data for the desired model and the using the file-based loading methods. Alternatively you can the <code>CachingEOPProvider</code> to initialize the Earth orientation data which will automatically download and update the latest data files as needed.</p>"},{"location":"learn/eop/managing_eop_data.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>A static provider is one that just uses fixed values for Earth orientation parameters. This provider is useful for testing and development or if your application only requires low accuracy.</p> PythonRust <pre><code>import brahe as bh\n\n\n# Method 1: Static EOP Provider - All Zeros\neop_static_zeros = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(eop_static_zeros)\n\n# Method 2: Static EOP Provider - Constant Values\neop_static_values = bh.StaticEOPProvider.from_values(\n    0.001, 0.002, 0.003, 0.004, 0.005, 0.006\n)\nbh.set_global_eop_provider(eop_static_values)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Static EOP Provider - All Zeros\n    let eop_static_zeros = bh::eop::StaticEOPProvider::from_zero();\n    bh::eop::set_global_eop_provider(eop_static_zeros);\n\n    // Method 2: Static EOP Provider - Constant Values\n    let eop_static_values = bh::eop::StaticEOPProvider::from_values((0.001, 0.002, 0.003, 0.004, 0.005, 0.006));\n    bh::eop::set_global_eop_provider(eop_static_values);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#fileeopprovider","title":"FileEOPProvider","text":"<p>If you want to use high-accuracy Earth orientation data, you can load data from IERS files using the <code>FileEOPProvider</code>. Brahe provides functions to load default IERS data files provided with the package, or you can specify your own file paths.</p> <p>When creating any new file-based data provider there are two parameters that are set at loading time which will determine how the EOP instances handles data returns for times not in the loaded data.</p> <p>The first parameter is the <code>interpolate</code> setting. When <code>interpolate</code> is set to <code>True</code> and data set will be linearly interpolated to the desired time. When set to <code>False</code>, the function call will return the last value prior to the requested data. Given that IERS data is typically provided at daily intervals, it is generally recommended to enable interpolation for most applications.</p> <p>The second parameter is the <code>extrapolate</code> parameter, which can have a value of <code>Zero</code>, <code>Hold</code>, or <code>Error</code>. This value will determine how requests for data points beyond the end of the loaded data are handled. The possible behaviors are</p> <ul> <li><code>Zero</code>: Returned values will be <code>0.0</code> where data is not available</li> <li><code>Hold</code>: Will return the last available returned value when data is not available</li> <li><code>Error</code>: Data access attempts where data is not present will panic and terminate the program</li> </ul> <p>You can create a file-based Earth orientation provider by specifying the file paths to the desired data files as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n# File-based EOP Provider - Default IERS Standard with Hold Extrapolation\neop_file_default = bh.FileEOPProvider.from_default_standard(\n    True,  # Interpolation -&gt; if True times between data points are interpolated\n    \"Hold\",  # Extrapolation method -&gt; How accesses outside data range are handled\n)\nbh.set_global_eop_provider(eop_file_default)\n\n# File-based EOP Provider - Default C04 Standard with Zero Extrapolation\neop_file_c04 = bh.FileEOPProvider.from_default_c04(False, \"Zero\")\nbh.set_global_eop_provider(eop_file_c04)\n\n# Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\nif False:  # Change to True to enable custom file examples\n    # File-based EOP Provider - Custom Standard File\n    eop_file_custom = bh.FileEOPProvider.from_standard_file(\n        \"path_to_standard_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom)\n\n    # File-based EOP Provider - Custom C04 File\n    eop_file_custom_c04 = bh.FileEOPProvider.from_c04_file(\n        \"path_to_c04_file.txt\",  # Replace with actual file path\n        True,  # Interpolation\n        \"Hold\",  # Extrapolation\n    )\n    bh.set_global_eop_provider(eop_file_custom_c04)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Default Providers -&gt; These are packaged data files within Brahe\n\n    // File-based EOP Provider - Default IERS Standard with Hold Extrapolation\n    let eop_file_default = bh::eop::FileEOPProvider::from_default_standard(\n        true,                                   // Interpolation -&gt; if True times between data points are interpolated\n        bh::eop::EOPExtrapolation::Hold        // Extrapolation method -&gt; How accesses outside data range are handled\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_default);\n\n    // File-based EOP Provider - Default C04 Standard with Zero Extrapolation\n    let eop_file_c04 = bh::eop::FileEOPProvider::from_default_c04(\n        false,\n        bh::eop::EOPExtrapolation::Zero\n    ).unwrap();\n    bh::eop::set_global_eop_provider(eop_file_c04);\n\n    // Method 2: Custom File Paths -&gt; Replace 'path_to_file.txt' with actual file paths\n\n    if false {  // Change to true to enable custom file examples\n        // File-based EOP Provider - Custom Standard File\n        let eop_file_custom = bh::eop::FileEOPProvider::from_standard_file(\n            std::path::Path::new(\"path_to_standard_file.txt\"),  // Replace with actual file path\n            true,                                                 // Interpolation\n            bh::eop::EOPExtrapolation::Hold                      // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom);\n\n        // File-based EOP Provider - Custom C04 File\n        let eop_file_custom_c04 = bh::eop::FileEOPProvider::from_c04_file(\n            std::path::Path::new(\"path_to_c04_file.txt\"),  // Replace with actual file path\n            true,                                           // Interpolation\n            bh::eop::EOPExtrapolation::Hold                // Extrapolation\n        ).unwrap();\n        bh::eop::set_global_eop_provider(eop_file_custom_c04);\n    }\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>The <code>CachingEOPProvider</code> is a <code>FileEOPProvider</code> that automatically downloads and caches the latest Earth orientation data files from the IERS website as needed. It checks the age of the cached data and if the data is older than a specified threshold, it downloads the latest files, then loads them for use. This provider can also be configured to check for a stale cache on use and update the data if needed, which is useful for long-running applications.</p> <p>The <code>CachingEOPProvider</code> is the recommended provider for most applications as it provides high-accuracy Earth orientation data without requiring manual management of data files. <code>initialize_eop()</code> uses this provider by default.</p> <p>The interpolation and extrapolation parameters are also available when creating a <code>CachingEOPProvider</code>, with the same behavior as described for the <code>FileEOPProvider</code>.</p> PythonRust <pre><code>from pathlib import Path\nimport brahe as bh\n\n# Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider)\n\n# Method 2: Initialize from Caching EOP Provider with custom location\nprovider_custom = bh.CachingEOPProvider(\n    filepath=str(\n        Path(bh.get_brahe_cache_dir()) / \"my_eop.txt\"\n    ),  # Replace with desired file path to load / save from\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # Maximum age of file before refreshing\n    auto_refresh=False,  # Check staleness of every access\n    interpolate=True,\n    extrapolate=\"Hold\",\n)\nbh.set_global_eop_provider(provider_custom)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    // Method 1: Initialize from Caching EOP Provider -&gt; Internally caches data to ~/.cache/brahe/eop\n    let provider = bh::eop::CachingEOPProvider::new(\n        None,                                   // filepath (None for default cache location)\n        bh::eop::EOPType::StandardBulletinA,   // eop_type\n        7 * 86400,                             // max_age_seconds - Maximum age of file before refreshing\n        false,                                 // auto_refresh - Check staleness of every access\n        true,                                  // interpolate\n        bh::eop::EOPExtrapolation::Hold       // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider);\n\n    // Method 2: Initialize from Caching EOP Provider with custom location\n    let cache_dir = bh::utils::get_brahe_cache_dir().unwrap();\n    let custom_filepath = std::path::Path::new(&amp;cache_dir).join(\"my_eop.txt\");\n    let provider_custom = bh::eop::CachingEOPProvider::new(\n        Some(&amp;custom_filepath),                        // Replace with desired file path to load / save from\n        bh::eop::EOPType::StandardBulletinA,           // eop_type\n        7 * 86400,                                     // max_age_seconds - Maximum age of file before refreshing\n        false,                                         // auto_refresh - Check staleness of every access\n        true,                                          // interpolate\n        bh::eop::EOPExtrapolation::Hold               // extrapolate\n    ).unwrap();\n    bh::eop::set_global_eop_provider(provider_custom);\n}\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#downloading-eop-data-files","title":"Downloading EOP Data Files","text":"<p>If you want to manually download Earth orientation data files to store or save them, brahe provides two means of doing so. The first is through the command-line interface (CLI) tool included with brahe. The second is through direct function calls in either the Rust or Python APIs.</p>"},{"location":"learn/eop/managing_eop_data.html#cli","title":"CLI","text":"<p>The brahe CLI command includes an <code>eop download</code> subcommand which can be used to download the latest Earth orientation data files from IERS servers.</p> <p>To download the latest standard product file, use the following command:</p> <pre><code>brahe eop download --product standard &lt;output_filepath&gt;\n</code></pre> <p>To download the latest C04 final product file, use the following command:</p> <pre><code>brahe eop download --product c04 &lt;output_filepath&gt;\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#functions","title":"Functions","text":"<p>You can also download Earth orientation data files directly using the <code>download_standard_eop_file</code> and <code>download_c04_eop_file</code> functions in the <code>brahe.eop</code> module.</p> <p>You can download the latest standard EOP data file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre> <pre><code>use brahe::eop::download_standard_eop_file;\n\n// Download latest C04 EOP data\ndownload_standard_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <p>Or download the latest C04 final product file as follows:</p> PythonRust <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre> <pre><code>use brahe::eop::download_c04_eop_file;\n\n// Download latest C04 EOP data\ndownload_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"learn/eop/managing_eop_data.html#accessing-eop-parameters","title":"Accessing EOP Parameters","text":"<p>While not common it is possible to directly access Earth orientation parameters from the currently loaded global Earth orientation provider. This can be useful for debugging or analysis purposes.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Get current time\nepc = bh.Epoch.now()\n\nxp, yp, dut1, lod, dX, dY = bh.get_global_eop(epc.mjd())\n\nprint(f\"At epoch {epc}:\")\nprint(f\"  x_pole: {xp} arcseconds\")\nprint(f\"  y_pole: {yp} arcseconds\")\nprint(f\"  dut1: {dut1} seconds\")\nprint(f\"  length of day: {lod} seconds\")\nprint(f\"  dX: {dX} arcseconds\")\nprint(f\"  dY: {dY} arcseconds\")\n</code></pre> <pre><code>#[allow(unused_imports)]\nuse brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    let epc = bh::Epoch::now();\n    let (xp, yp, dut1, lod, dx, dy) = bh::get_global_eop(epc.mjd()).unwrap();\n\n    println!(\"At epoch {}:\", epc.to_string());\n    println!(\"xp:  {}\", xp);\n    println!(\"yp:  {}\", yp);\n    println!(\"dut1: {}\", dut1);\n    println!(\"lod:  {}\", lod);\n    println!(\"dX:   {}\", dx);\n    println!(\"dY:   {}\", dy);\n}\n</code></pre> <p>You can find more functions to access specific subsets of Earth orientation data in the API Reference.</p>"},{"location":"learn/eop/managing_eop_data.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider API Reference</li> <li>FileEOPProvider API Reference</li> <li>CachingEOPProvider API Reference</li> </ul>"},{"location":"learn/eop/what_is_eop_data.html","title":"What is EOP Data?","text":"<p>Earth Orientation Parameters are empirically observed, estimated parameters that describe the irregularities in Earth's rotation in space. When combined with their specific related models they provide the mechanism to transform between an Earth-Centered Earth-Fixed (ECEF) reference frame and an Earth-Centered Inertial (ECI) reference frame. These transformations are essential for accurate orbit propagation, coordinate transformations, and other space-related applications.</p> <p>Earth Orientation Parameters are stochastic meaning that they are random and cannot be predicted with perfect accuracy into the future. Therefore, Earth orientation data is continually observed, estimated, and updated by various international organizations. The International Earth Rotation and Reference Systems Service (IERS) is the primary organization responsible for providing Earth orientation data products and maintaining the associated reference frames and systems.</p> <p>For example the predicted evolution of the offset between solar time (UT1) and Coordinated Universal Time (UTC) is show below. The difference between UT1 and UTC is primarily driven by variations in Earth's rotation rate, which are influenced by factors such as tidal forces, atmospheric dynamics, and core-mantle interactions. As a result, the UT1-UTC offset exhibits irregular fluctuations that cannot be precisely predicted far into the future.</p> Plot Source fig_ut1_utc_offset.py<pre><code>import os\nimport pathlib\nimport sys\nimport plotly.graph_objects as go\nimport brahe as bh\nimport numpy as np\n\n# Add plots directory to path for importing brahe_theme\nsys.path.insert(0, str(pathlib.Path(__file__).parent))\nfrom brahe_theme import get_theme_colors, save_themed_html\n\n# ------------------------------\n# Configuration\n# ------------------------------\n\nSCRIPT_NAME = pathlib.Path(__file__).stem\nOUTDIR = pathlib.Path(os.getenv(\"BRAHE_FIGURE_OUTPUT_DIR\", \"./docs/figures/\"))\n\n# Ensure output directory exists\nos.makedirs(OUTDIR, exist_ok=True)\n\n# ------------------------------\n\n# Initialize IERS EOP Data\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(eop)\n\n## Generate plot data\n\n# Get range of dates stored in EOP data\nmjd_min = bh.get_global_eop_mjd_min()\nmjd_max = bh.get_global_eop_mjd_max()\nmjd_now = bh.Epoch.now().mjd()\n\nprint(\"EOP MJD Range:\", mjd_min, \"to\", mjd_max)\nprint(\"Current MJD (now):\", mjd_now)\n\n# Split data into past (solid) and predicted (dashed)\ndays_past = np.arange(mjd_min, min(mjd_now, mjd_max), 1)\ndays_predicted = np.arange(max(mjd_now, mjd_min), mjd_max, 1)\n\n# Get UT1-UTC offsets\nut1_utc_past = [bh.get_global_ut1_utc(mjd) for mjd in days_past]\nut1_utc_predicted = [bh.get_global_ut1_utc(mjd) for mjd in days_predicted]\n\n# Get year range for x-axis tick labels\nepoch_min = bh.Epoch.from_mjd(mjd_min, bh.TimeSystem.UTC)\nepoch_max = bh.Epoch.from_mjd(mjd_max, bh.TimeSystem.UTC)\nyear_min = epoch_min.to_datetime()[0]\nyear_max = epoch_max.to_datetime()[0]\n\n\n## Create figure with theme support\n\n\ndef create_figure(theme):\n    \"\"\"Create figure with theme-specific colors.\"\"\"\n    colors = get_theme_colors(theme)\n\n    fig = go.Figure()\n\n    # Plot past data (solid line) - use primary color\n    fig.add_trace(\n        go.Scatter(\n            x=days_past,\n            y=ut1_utc_past,\n            mode=\"lines\",\n            line=dict(color=colors[\"primary\"], width=2),\n            name=\"Past (Measured)\",\n            showlegend=True,\n        )\n    )\n\n    # Plot predicted data (dashed line) - use error color\n    fig.add_trace(\n        go.Scatter(\n            x=days_predicted,\n            y=ut1_utc_predicted,\n            mode=\"lines\",\n            line=dict(color=colors[\"error\"], width=2, dash=\"dash\"),\n            name=\"Future (Predicted)\",\n            showlegend=True,\n        )\n    )\n\n    # Create custom tick values and labels for x-axis (years)\n    # Generate tick positions every 5 years\n    tick_mjds = []\n    tick_labels = []\n    for year in range(year_min, year_max + 1, 5):\n        epoch = bh.Epoch.from_datetime(year, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n        tick_mjds.append(epoch.mjd())\n        tick_labels.append(str(year))\n\n    # Configure axes (theme-agnostic settings)\n    fig.update_xaxes(\n        tickmode=\"array\",\n        tickvals=tick_mjds,\n        ticktext=tick_labels,\n        title_text=\"Year\",\n        range=[mjd_min, mjd_max],\n        showgrid=False,\n    )\n\n    fig.update_yaxes(\n        tickmode=\"array\",\n        tickvals=[-1.0, -0.5, 0.0, 0.5, 1.0],\n        title_text=\"UT1-UTC Offset Magnitude [s]\",\n        showgrid=False,\n    )\n\n    return fig\n\n\n# Generate and save both themed versions\nlight_path, dark_path = save_themed_html(create_figure, OUTDIR / SCRIPT_NAME)\nprint(f\"\u2713 Generated {light_path}\")\nprint(f\"\u2713 Generated {dark_path}\")\n</code></pre>"},{"location":"learn/eop/what_is_eop_data.html#iers","title":"IERS","text":"<p>The International Earth Rotation Service (IERS) was established in 1987 by the International Astronomical Union and the International Union of Geodesy and Geophysics. The IERS provides data on Earth orientation, on the International Celestial Reference System/Frame, and on the International Terrestrial Reference System/Frame. The IERS also maintains conventions containing models, constants, and standards used for modeling Earth orientation.</p> <p>The IERS deals with reference systems and reference frames. A reference system is an idealized mathematical concept for defining a reference used to represent the state of objects in that system. The two primary reference systems developed by the IERS are the International Celestial Reference System (ICRS) and International Terrestrial Reference System (ITRS). The ICRS is an inertial reference system and the one we used to define Earth-centered inertial (ECI) reference frames in brahe. The ITRS is a rotating reference system fixed to the Earth and is used to define Earth-centered, Earth-fixed (ECEF*) reference frames in the packge.</p> <p>A reference system is a concept and cannot be used directly. For example you can say that you'll represent all coordinates in the world with respect to the the North Star, but to actually use that reference you need to define how to measure positions with respect to it. Therefore the IERS develops reference frames, which are specific realizations of a given reference system. A reference frame realization defines the models, standards, and associated data products for users to actually interact and usethat reference system. The primary reference frames of the IERS are the International Celestial Reference Frame (ICRF) and International Terrestrial Reference Frame (ITRF).</p> <p>The ICRS and ITRS models are defined with respect to the solar system barycenter<sup>1</sup>. However, for many satellite-specific engineering applications we are primarily concerned with geocentric references, centered at Earth. Therefore, brahe primarily deals with the Geocentric Celestial Reference Frame (GCRF) and Geocentric Terrestrial Reference Frame (GTRF). For most intents and purposes the international and geocentric references are identical as there is no rotation component between ICRS and GCRS (or ITRF and GCRF)<sup>2</sup>. The transformation between the two reference systems and frames is simply a pure translation.</p> <p>For a more detailed discussion of reference frames and systems please read IERS Technical Note 36 provides an in-depth discussion of the concepts presented and discussed here.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-products","title":"Earth Orientation Products","text":"<p>The IERS provides various Earth orientation products which are derived from Very Long Baseline Interferometry (VLBI) or a network of terrestrial GPS<sup>3</sup>  reference stations. The continual observations made by these stations are  combined with specific reference frame realizations (e.g. the IAU 2010  conventions) to model Earth orientation and enable the transformation between  inertial and Earth-fixed reference frames.</p> <p>The Earth orientation parameter products come in multiple variations, all of which can be found at the IERS data products site. These variations arise from the selection of precession-nutation model, ITRF realization, the data sources, and data processing time span. There are two precession-nutation models widely in use today: IAU 1980 nutation theory andthe IAU2006/2000A precession-nutation model. The ITRF 2014 realization is the most recent realization and preferred in most cases.</p> <p>For data products there are two primary distinctions: standard products and long term products. Standard products, which are produced daily, to provide a daily estimate of the past Earth orientation along with forward-looking predictions available for use in planning. Long term data products are only available for past days, and are produced less frequently, but provider higher accurate estimates of Earth orientation. </p> <p>For most purposes the standard products provide sufficient accuracy along with the benefit of having fairly accurate forward-looking predictions. Therefore, brahe defaults to using standard Earth Orientation data products wherever possible. Unless otherwise stated or specified, brahe uses IERS standard product generated with respect to IAU 2006/2000A precession-nutation model and consistent with ITRF2014.</p>"},{"location":"learn/eop/what_is_eop_data.html#earth-orientation-parameters","title":"Earth Orientation Parameters","text":"<p>The primary Earth orientation parameters provided by the IERS are polar motion coefficients (\\(x_p\\), \\(y_p\\)), UTC-UT1 time system offset (\\(\\Delta_{UTC}\\)), celestial pole offsets (\\(dX\\), \\(dY\\)), and length of day (\\(LOD\\)) corrections. These parameters are used in combination with specific models to compute the transformation between ECEF and ECI reference frames.</p> <p>Brahe defines the <code>EarthOrientationProvider</code> trait to provide a common interface for accessing Earth orientation data. There are multiple different types of providers, each with their own use cases. The package includes default data files for ease of use that are sufficient for most purposes.</p> <p>There is a single, global Earth orientation provider used internally by brahe functions. This global provider can be initialized using one of the provided loading functions. See the Managing EOP Data page for more information on loading and managing Earth orientation data in brahe.</p> <ol> <li> <p>A barycenter is the center of mass of two or more bodies. The solar  system barycenter is the center of mass of the entire solar system. Due to  significant mass contributions and distances of Jupiter and Saturn, the  solar system barycenter evolves in time and is sometimes outside of the  Sun's outer radius.\u00a0\u21a9</p> </li> <li> <p>For applications requiring the highest levels of fidelity, the  equations of motion of an Earth satellite, with respect to the  GCRS will contain a relativistic Coriolis force due to geodesic precession  not present in the ICRS.\u00a0\u21a9</p> </li> <li> <p>Now frequently GNSS receivers\u00a0\u21a9</p> </li> </ol>"},{"location":"learn/orbits/index.html","title":"Orbital Elements","text":"<p>The <code>brahe.orbits</code> module provides tools for working with orbital elements.</p>"},{"location":"learn/orbits/keplerian.html","title":"Keplerian Orbits","text":""},{"location":"learn/orbits/two_line_elements.html","title":"Two-Line Elements (TLEs)","text":"<p>Two-Line Elements are a standardized format for distributing satellite orbital parameters.</p>"},{"location":"learn/orbits/two_line_elements.html#overview","title":"Overview","text":"<p>A Two-Line Element Set (TLE) is a data format used to convey orbital parameters for Earth-orbiting objects. TLEs are widely used for:</p> <ul> <li>Satellite tracking</li> <li>Orbit prediction</li> <li>Space situational awareness</li> <li>Amateur radio satellite tracking</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#tle-format","title":"TLE Format","text":"<p>A TLE consists of three lines:</p> <pre><code>ISS (ZARYA)\n1 25544U 98067A   24001.50000000  .00016717  00000-0  10270-3 0  9005\n2 25544  51.6400 247.4627 0001220  89.6300 270.4997 15.54057614123456\n</code></pre> <p>Line 0: Satellite name (optional) Line 1: General orbital information Line 2: Orbital elements</p>"},{"location":"learn/orbits/two_line_elements.html#line-1-fields","title":"Line 1 Fields","text":"<ul> <li>Satellite catalog number</li> <li>Classification (U=unclassified)</li> <li>International designator</li> <li>Epoch (year and day of year)</li> <li>First derivative of mean motion (ballistic coefficient)</li> <li>Second derivative of mean motion</li> <li>Drag term (B*)</li> <li>Element set number</li> <li>Checksum</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#line-2-fields","title":"Line 2 Fields","text":"<ul> <li>Satellite catalog number</li> <li>Inclination (degrees)</li> <li>Right ascension of ascending node (degrees)</li> <li>Eccentricity (decimal point assumed)</li> <li>Argument of perigee (degrees)</li> <li>Mean anomaly (degrees)</li> <li>Mean motion (revolutions per day)</li> <li>Revolution number</li> <li>Checksum</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#using-tles-in-brahe","title":"Using TLEs in Brahe","text":""},{"location":"learn/orbits/two_line_elements.html#parsing-tles","title":"Parsing TLEs","text":"<pre><code>import brahe as bh\n\n# Parse TLE from strings\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  10270-3 0  9005\"\nline2 = \"2 25544  51.6400 247.4627 0001220  89.6300 270.4997 15.54057614123456\"\n\ntle = bh.TLE(line1, line2, name=\"ISS (ZARYA)\")\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#extracting-orbital-elements","title":"Extracting Orbital Elements","text":"<pre><code>import brahe as bh\n\n# Get orbital elements from TLE\ninclination = tle.inclination()  # radians\nraan = tle.raan()  # radians\neccentricity = tle.eccentricity()\nargp = tle.argp()  # radians\nmean_anomaly = tle.mean_anomaly()  # radians\nmean_motion = tle.mean_motion()  # revolutions/day\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#propagation-with-sgp4","title":"Propagation with SGP4","text":"<pre><code>import brahe as bh\n\n# Create SGP4 propagator from TLE\npropagator = bh.SGPPropagator.from_tle(tle)\n\n# Propagate to specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.UTC)\nstate = propagator.propagate(epoch)\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#tle-sources","title":"TLE Sources","text":""},{"location":"learn/orbits/two_line_elements.html#celestrak","title":"CelesTrak","text":"<p>CelesTrak provides TLEs for thousands of satellites:</p> <pre><code>import brahe as bh\n\n# Download TLEs for all active satellites\ntles = bh.celestrak_fetch_latest_tles(\"active\")\n\n# Download TLEs for specific satellite group\niss_tles = bh.celestrak_fetch_latest_tles(\"stations\")\n</code></pre>"},{"location":"learn/orbits/two_line_elements.html#space-track","title":"Space-Track","text":"<p>Space-Track.org (requires free account) provides:</p> <ul> <li>Historical TLEs</li> <li>High-precision TLEs</li> <li>TLE predictions</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#tle-accuracy-and-limitations","title":"TLE Accuracy and Limitations","text":""},{"location":"learn/orbits/two_line_elements.html#accuracy","title":"Accuracy","text":"<ul> <li>Short-term (&lt; 1 day): Position accuracy ~1 km</li> <li>Medium-term (1-7 days): Accuracy degrades to ~10 km</li> <li>Long-term (&gt; 7 days): Not recommended, errors can exceed 100 km</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#limitations","title":"Limitations","text":"<ul> <li>Simplified model: SGP4/SDP4 uses simplified atmospheric drag</li> <li>No maneuvers: TLEs don't account for spacecraft maneuvers</li> <li>Aging: Accuracy degrades rapidly over time</li> <li>Low orbits: Drag modeling less accurate at low altitudes</li> </ul>"},{"location":"learn/orbits/two_line_elements.html#best-practices","title":"Best Practices","text":"<ol> <li>Use recent TLEs: Download fresh TLEs daily for operational systems</li> <li>Don't extrapolate far: Limit propagation to a few days from TLE epoch</li> <li>Validate results: Cross-check with other data sources when possible</li> <li>Update after maneuvers: Get new TLEs after spacecraft maneuvers</li> </ol>"},{"location":"learn/orbits/two_line_elements.html#see-also","title":"See Also","text":"<ul> <li>TLE API Reference</li> <li>SGP Propagation</li> <li>CelesTrak Dataset</li> <li>CelesTrak Website</li> </ul>"},{"location":"learn/plots/index.html","title":"Plotting &amp; Visualization","text":""},{"location":"learn/time/index.html","title":"Time Systems and Representations","text":"<p>In the beginning the Universe was created. This has made a lot of people very angry and has been widely regarded as a bad move</p> <ul> <li>Douglas Adams</li> </ul> <p>Astrodynamics is the study of motion in space, which is inextricably linked with the concept of time. You cannot have motion without time. The trajectory of an object is defined by how it's state (location) changes between different points in time. As one might therefore expect, accurate timekeeping and the ability to convert between different representations of time are crucial for calculations in orbital mechanics.</p> <p>The <code>time</code> module provides functions for the handling of time. The package makes the distinction between the representation of a specific time and the conversion between different time scales. Precise specification of an instant in time requires the specification of both a time representation and time scale.</p>"},{"location":"learn/time/index.html#time-representation","title":"Time Representation","text":"<p>A single instance in time can be represented in multiple different formats. For examples The J2000 Epoch can be represented as a calendar date in terms of years, months, days, hours, minutes, and seconds as <code>2000-01-01T12:00:00</code>. The same instant can also be represented in terms of Modified Julian Days as <code>51544.5</code>. Both of these representations refer to the same instant in time.</p>"},{"location":"learn/time/index.html#time-scales","title":"Time Scales","text":"<p>In addition to representing time in different manners, there are also different time scales. A time scale is a standard to reckoning and resolving instances in time. Multimple time scales have been introduced due to the criticality of being able to correctly measure and understand when specific events occur in science and engineering.  </p> <p>Within a time scale it is possible to compare different instances in time to determine if one is before, after, or at the same time as another instant. It is also possible to compare between time scales, however you must know how to properly convert between them. It is assumed that all time scales use the same definition of the SI second, and therefore advance at the same rate.</p> <p>Athough the calendar date representations of time <code>2000-01-01T12:00:00 UTC</code> and <code>2000-01-01T12:00:00 GPS</code> have the same values, they are actually  different instances in time!. This is because while the calendar date representations are the same there are actually offsets between the different time scales.</p> <p>The time scales currently supported by brahe are</p> Time Scale Description <code>GPS</code> <code>GPS</code> stands for Global Positioning System time. It is specifically, the time scale used by the US GPS satellites. It is different from TAI and TT by constant, fixed offsets. <code>TAI</code> <code>TAI</code> is a French acronym for temps atomique international. It is an atomic time scale meant to track the proper time on the Earth's surface. <code>UTC</code> <code>UTC</code> stands for Universal Coordinated Time. <code>UTC</code> tracks the solar day, accounting for long term variations due to changes in Earth's rotation to within +/- 1 second. Tracking the solar day in this manner introduces an offset between <code>TAI</code> and <code>UTC</code> of a fixed number of leap seconds. <code>UT1</code> <code>UT1</code> stands for Universal Time 1. <code>UT1</code> represents the time as determined by the true solar day. Due to Earth's rotation rate constantly changing UT1 itself is constantly changing. The difference between <code>UT1</code> and <code>UTC</code> is empirically estimated on a daily basis as an Earth orientation parameter. <code>TT</code> <code>TT</code> is Terrestrial Time, a time scale used historically to model the motion of planets and other solar system bodies. These models are still in wide use."},{"location":"learn/time/index.html#epoch","title":"Epoch","text":"<p>The <code>Epoch</code> type represents a specific instant in time, defined by both a time representation and a time scale. The <code>Epoch</code> type provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>It is the core type used throughout the brahe package to represent time and provides many advandages as </p>"},{"location":"learn/time/index.html#see-also","title":"See Also","text":"<ul> <li>Epoch - Complete guide to the Epoch type</li> <li>Time API Reference - Complete time function documentation</li> <li>Time Constants - Important time-related constants</li> </ul>"},{"location":"learn/time/epoch.html","title":"Epoch","text":"<p>The Epoch class is the fundamental time representation in Brahe. It encapsulates a specific instant in time, defined by both a time representation and a time scale. The Epoch class provides methods for converting between different time representations and time scales, as well as for performing arithmetic operations on time instances.</p> <p>There are even more capabilities and features of the Epoch class beyond what is covered in this guide. For a complete reference of all available methods and properties, please refer to the Epoch API Reference.</p>"},{"location":"learn/time/epoch.html#initialization","title":"Initialization","text":"<p>There are all sorts of ways you can initialize an Epoch instance. The most common methods are described below.</p>"},{"location":"learn/time/epoch.html#date-time","title":"Date Time","text":"<p>The most common way to create an Epoch is from date and time components. You can specify just a date (which defaults to midnight), or provide the full date and time including fractional seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from date only (midnight)\nepc1 = bh.Epoch(2024, 1, 1)\nprint(f\"Date only: {epc1}\")\n# Date only: 2024-01-01 00:00:00.000 UTC\n\n# Create epoch from full datetime components\nepc2 = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Full datetime: {epc2}\")\n# Full datetime: 2024-06-15 14:30:45.500 UTC\n\n# Create epoch with different time system\nepc3 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TimeSystem.GPS)\nprint(f\"GPS time system: {epc3}\")\n# GPS time system: 2024-12-25 18:00:00.000 GPS\n\n# In Python you can also use the direct datetime constant\nepc4 = bh.Epoch(2024, 12, 25, 18, 0, 0.0, 0.0, time_system=bh.TAI)\nprint(f\"GPS time system: {epc4}\")\n# GPS time system: 2024-12-25 18:00:00.000 TAI\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from date only (midnight)\n    let epc1 = bh::Epoch::from_date(2024, 1, 1, bh::TimeSystem::UTC);\n    println!(\"Date only: {}\", epc1);\n\n    // Create epoch from full datetime components\n    let epc2 = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Full datetime: {}\", epc2);\n\n    // Create epoch with different time system\n    let epc3 = bh::Epoch::from_datetime(2024, 12, 25, 18, 0, 0.0, 0.0, bh::TimeSystem::GPS);\n    println!(\"GPS time system: {}\", epc3);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#mjd","title":"MJD","text":"<p>Modified Julian Date (MJD) is a commonly used time representation in astronomy and astrodynamics. MJD is defined as JD - 2400000.5, which makes it more convenient for modern dates.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from MJD\nmjd = 61041.5\nepc2 = bh.Epoch.from_mjd(mjd, bh.UTC)\nprint(f\"MJD {mjd}: {epc2}\")\n# MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n# Verify round-trip conversion\nmjd_out = epc2.mjd()\nprint(f\"Round-trip MJD: {mjd_out:.6f}\")\n# Round-trip MJD: 61041.500000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from MJD\n    let mjd = 61041.5; // 2024-01-01 12:00:00 UTC\n    let epc2 = bh::Epoch::from_mjd(mjd, bh::TimeSystem::UTC);\n    println!(\"MJD {}: {}\", mjd, epc2);\n    // MJD 61041.5: 2026-01-01 12:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let mjd_out = epc2.mjd();\n    println!(\"Round-trip MJD: {:.6}\", mjd_out);\n    // Round-trip MJD: 61041.500000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#jd","title":"JD","text":"<p>Julian Date (JD) is a continuous count of days since the beginning of the Julian Period. It's widely used in astronomy for precise time calculations.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from JD\njd = 2460310.5\nepc = bh.Epoch.from_jd(jd, bh.UTC)\nprint(f\"JD {jd}: {epc}\")\n# JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"Round-trip JD: {jd_out:.10f}\")\n# Round-trip JD: 2460310.5000000000\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from JD\n    let jd = 2460310.5;\n    let epc = bh::Epoch::from_jd(jd, bh::TimeSystem::UTC);\n    println!(\"JD {}: {}\", jd, epc);\n    // JD 2460310.5: 2024-01-01 00:00:00.000 UTC\n\n    // Verify round-trip conversion\n    let jd_out = epc.jd();\n    println!(\"Round-trip JD: {:.10}\", jd_out);\n    // Round-trip JD: 2460310.5000000000\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string","title":"String","text":"<p>Epoch instances can be created from ISO 8601 formatted strings or simple date-time strings. The time system can be specified in the string.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# The string can be an ISO 8601 format\nepc1 = bh.Epoch.from_string(\"2025-01-02T04:56:54.123Z\")\nprint(f\"ISO 8601: {epc1}\")\n\n# It can be a simple space-separated format with a time system\nepc2 = bh.Epoch.from_string(\"2024-06-15 14:30:45.500 GPS\")\nprint(f\"Simple format: {epc2}\")\n\n# It can be a datetime without a time system (defaults to UTC)\nepc3 = bh.Epoch.from_string(\"2023-12-31 23:59:59\")\nprint(f\"Datetime without time system: {epc3}\")\n\n# Or it can just be a date\nepc4 = bh.Epoch.from_string(\"2022-07-04\")\nprint(f\"Date only: {epc4}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // The string can be an ISO 8601 format\n    let epc1 = bh::Epoch::from_string(\"2025-01-02T04:56:54.123Z\").unwrap();\n    println!(\"ISO 8601: {}\", epc1);\n\n    // It can be a simple space-separated format with a time system\n    let epc2 = bh::Epoch::from_string(\"2024-06-15 14:30:45.500 GPS\").unwrap();\n    println!(\"Simple format: {}\", epc2);\n\n    // It can be a datetime without a time system (defaults to UTC)\n    let epc3 = bh::Epoch::from_string(\"2023-12-31 23:59:59\").unwrap();\n    println!(\"Datetime without time system: {}\", epc3);\n\n    // Or it can just be a date\n    let epc4 = bh::Epoch::from_string(\"2022-07-04\").unwrap();\n    println!(\"Date only: {}\", epc4);\n}\n</code></pre>"},{"location":"learn/time/epoch.html#gps-week-and-seconds","title":"GPS Week and Seconds","text":"<p>For GPS applications, you can create epochs from GPS week number and seconds into the week, or from GPS seconds since the GPS epoch (January 6, 1980).</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create epoch from GPS week and seconds\n# Week 2390, day 2 (October 28, 2025)\nweek = 2390\nseconds = 2 * 86400.0\nepc1 = bh.Epoch.from_gps_date(week, seconds)\nprint(f\"GPS Week {week}, Seconds {seconds}: {epc1}\")\n# GPS Week 2390, Seconds 172800.0: 2025-10-28 00:00:00.000 GPS\n\n# Verify round-trip conversion\nweek_out, sec_out = epc1.gps_date()\nprint(f\"Round-trip: Week {week_out}, Seconds {sec_out:.1f}\")\n# Round-trip: Week 2390, Seconds 172800.0\n\n# Create from GPS seconds since GPS epoch\ngps_seconds = week * 7 * 86400.0 + seconds\nepc2 = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"GPS Seconds {gps_seconds}: {epc2}\")\n# GPS Seconds 1445644800.0: 2025-10-28 00:00:00.000 GPS\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create epoch from GPS week and seconds\n    // Week 2390, day 2 (October 28, 2025)\n    let week = 2390;\n    let seconds = 2.0 * 86400.0; // 3 days + 12 hours\n    let epc1 = bh::Epoch::from_gps_date(week, seconds);\n    println!(\"GPS Week {}, Seconds {}: {}\", week, seconds, epc1);\n    // GPS Week 2390, Seconds 172800: 2025-10-28 00:00:00.000 GPS\n\n    // Verify round-trip conversion\n    let (week_out, sec_out) = epc1.gps_date();\n    println!(\"Round-trip: Week {}, Seconds {:.1}\", week_out, sec_out);\n    // Round-trip: Week 2390, Seconds 172800.0\n\n    // Create from GPS seconds since GPS epoch\n    let gps_seconds = week as f64 * 7.0 * 86400.0 + seconds;\n    let epc2 = bh::Epoch::from_gps_seconds(gps_seconds);\n    println!(\"GPS Seconds {}: {}\", gps_seconds, epc2);\n    // 1445644800: 2025-10-28 00:00:00.000 GPS\n}\n</code></pre>"},{"location":"learn/time/epoch.html#operations","title":"Operations","text":"<p>Once you have an epoch class instance you can add and subtract time as you would expect.</p> <p>Info</p> <p>When performing arithmetic the other operand is always interpreted as a time duration in seconds.</p>"},{"location":"learn/time/epoch.html#addition","title":"Addition","text":"<p>You can add a time duration (in seconds) to an Epoch to get a new Epoch at a later time.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2025, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"Original epoch: {epc}\")\n# Original epoch: 2025-01-01 12:00:00.000 UTC\n\n# You can add time in seconds to an Epoch and get a new Epoch back\n\n# Add 1 hour (3600 seconds)\nepc_plus_hour = epc + 3600.0\nprint(f\"Plus 1 hour: {epc_plus_hour}\")\n# Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n# Add 1 day (86400 seconds)\nepc_plus_day = epc + 86400.0\nprint(f\"Plus 1 day: {epc_plus_day}\")\n# Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n# You can also do in-place addition\n\n# Add 1 second in-place\nepc += 1.0\nprint(f\"In-place plus 1 second: {epc}\")\n# In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n# Add 1 milisecond in-place\nepc += 0.001\nprint(f\"In-place plus 1 millisecond: {epc}\")\n# In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2025, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    println!(\"Original epoch: {}\", epc);\n    // Original epoch: 2025-01-01 12:00:00.000 UTC\n\n    // You can add time in seconds to an Epoch and get a new Epoch back\n\n    // Add 1 hour (3600 seconds)\n    let epc_plus_hour = epc + 3600.0;\n    println!(\"Plus 1 hour: {}\", epc_plus_hour);\n    // Plus 1 hour: 2025-01-01 13:00:00.000 UTC\n\n    // Add 1 day (86400 seconds)\n    let epc_plus_day = epc + 86400.0;\n    println!(\"Plus 1 day: {}\", epc_plus_day);\n    // Plus 1 day: 2025-01-02 12:00:00.000 UTC\n\n    // You can also do in-place addition\n\n    // Add 1 second in-place\n    let mut epc = epc;\n    epc += 1.0;\n    println!(\"In-place plus 1 second: {}\", epc);\n    // In-place plus 1 second: 2025-01-01 12:00:01.000 UTC\n\n    // Add 1 millisecond in-place\n    epc += 0.001;\n    println!(\"In-place plus 1 millisecond: {}\", epc);\n    // In-place plus 1 millisecond: 2025-01-01 12:00:01.001 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#subtraction","title":"Subtraction","text":"<p>Subtracting two Epoch instances returns the time difference between them in seconds.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# You can subtract two Epoch instances to get the time difference in seconds\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(2024, 1, 2, 12, 1, 1.0, 0.0)\n\ndt = epc2 - epc1\nprint(f\"Time difference: {dt:.1f} seconds\")\n\n\n# You can also subtract a float (in seconds) from an Epoch to get a new Epoch\nepc = bh.Epoch(2024, 6, 15, 10, 30, 0.0, 0.0)\n\n# Subtract 1 hour (3600 seconds)\nepc_minus_hour = epc - 3600.0\nprint(f\"Minus 1 hour: {epc_minus_hour}\")\n\n# You can also update an Epoch in-place by subtracting seconds\nepc = bh.Epoch(2024, 1, 1, 0, 0, 0.0, 0.0)\nepc -= 61.0  # Subtract 61 seconds\nprint(f\"In-place minus 61 seconds: {epc}\")\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create two epochs\n    let epc1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc2 = bh::Epoch::from_datetime(2024, 1, 2, 13, 1, 1.0, 0.0, bh::TimeSystem::UTC);\n\n    // Compute time difference in seconds\n    let dt = epc2 - epc1;\n    println!(\"Time difference: {:.1} seconds\", dt);\n    // Time difference: 90061.0 seconds\n\n    // You can also subtract a float (in seconds) from an Epoch to get a new Epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 10, 30, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_minus_hour = epc - 3600.0;\n    println!(\"Minus 1 hour: {}\", epc_minus_hour);\n    // Minus 1 hour: 2024-06-15 09:30:00.000 UTC\n\n    // You can also update an Epoch in-place by subtracting seconds\n    let mut epc = bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    epc -= 61.0; // Subtract 61 seconds\n    println!(\"In-place minus 61 seconds: {}\", epc);\n    // In-place minus 61 seconds: 2023-12-31 23:58:59.000 UTC\n}\n</code></pre>"},{"location":"learn/time/epoch.html#other-operations","title":"Other Operations","text":"<p>The Epoch class also supports comparison operations (e.g., equality, less than, greater than) to compare different time instances. It also supports methods for getting string representations using language-specific formatting options.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc_1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc_2 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 1.0)\nepc_3 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\n\n# You can compare two Epoch instances for equality\nprint(f\"epc_1 == epc_2: {epc_1 == epc_2}\")\n# epc_1 == epc_2: False\nprint(f\"epc_1 == epc_3: {epc_1 == epc_3}\")\n# epc_1 == epc_3: True\n\n# You can also use inequality and comparison operators\nprint(f\"epc_1 != epc_2: {epc_1 != epc_2}\")\n# epc_1 != epc_2: True\nprint(f\"epc_1 &lt; epc_2: {epc_1 &lt; epc_2}\")\n# epc_1 &lt; epc_2: True\nprint(f\"epc_2 &lt; epc_1: {epc_2 &lt; epc_1}\")\n# epc_2 &gt; epc_1: False\nprint(f\"epc_2 &gt; epc_1: {epc_2 &gt; epc_1}\")\n# epc_2 &gt; epc_1: True\nprint(f\"epc_1 &lt;= epc_3: {epc_1 &lt;= epc_3}\")\n# epc_1 &lt;= epc_3: True\nprint(f\"epc_2 &gt;= epc_1: {epc_2 &gt;= epc_1}\")\n# epc_2 &gt;= epc_1: True\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc_1 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n    let epc_2 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 1.0, bh::TimeSystem::UTC);\n    let epc_3 = bh::Epoch::from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh::TimeSystem::UTC);\n\n    // You can compare two Epoch instances for equality\n    println!(\"epc_1 == epc_2: {}\", epc_1 == epc_2);\n    // epc_1 == epc_2: false\n    println!(\"epc_1 == epc_3: {}\", epc_1 == epc_3);\n    // epc_1 == epc_3: true\n\n    // You can also use inequality and comparison operators\n    println!(\"epc_1 != epc_2: {}\", epc_1 != epc_2);\n    // epc_1 != epc_2: true\n    println!(\"epc_1 &lt; epc_2: {}\", epc_1 &lt; epc_2);\n    // epc_1 &lt; epc_2: true\n    println!(\"epc_2 &lt; epc_1: {}\", epc_2 &lt; epc_1);\n    // epc_2 &gt; epc_1: false\n    println!(\"epc_2 &gt; epc_1: {}\", epc_2 &gt; epc_1);\n    // epc_2 &gt; epc_1: true\n    println!(\"epc_1 &lt;= epc_3: {}\", epc_1 &lt;= epc_3);\n    // epc_1 &lt;= epc_3: true\n    println!(\"epc_2 &gt;= epc_1: {}\", epc_2 &gt;= epc_1);\n    // epc_2 &gt;= epc_1: true\n}\n</code></pre>"},{"location":"learn/time/epoch.html#output-and-formatting","title":"Output and Formatting","text":"<p>Finally, you can take any Epoch instance and then output it in different representations.</p>"},{"location":"learn/time/epoch.html#date-time_1","title":"Date Time","text":"<p>You can extract the date and time components from an Epoch, optionally converting to a different time system.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.5, 0.0)\nprint(f\"Epoch: {epc}\")\n# Epoch: 2024-06-15 14:30:45.500 UTC\n\n# Output the equivalent Julian Date\njd = epc.jd()\nprint(f\"Julian Date: {jd:.6f}\")\n# Julian Date: 2460477.104693\n\n# Get the Julian Date in a different time system (e.g., TT)\njd_tt = epc.jd_as_time_system(time_system=bh.TT)\nprint(f\"Julian Date (TT): {jd_tt:.6f}\")\n# Julian Date (TT): 2460477.105494\n\n# Output the equivalent Modified Julian Date\nmjd = epc.mjd()\nprint(f\"Modified Julian Date: {mjd:.6f}\")\n# Modified Julian Date: 60476.604693\n\n# Get the Modified Julian Date in a different time system (e.g., GPS)\nmjd_gps = epc.mjd_as_time_system(time_system=bh.GPS)\nprint(f\"Modified Julian Date (GPS): {mjd_gps:.6f}\")\n# Modified Julian Date (GPS): 60476.604902\n\n# Get the GPS Week and Seconds of Week\ngps_week, gps_sow = epc.gps_date()\nprint(f\"GPS Week: {gps_week}, Seconds of Week: {gps_sow:.3f}\")\n# GPS Week: 2318, Seconds of Week: 570663.500\n\n# The Epoch as GPS seconds since the GPS epoch\ngps_seconds = epc.gps_seconds()\nprint(f\"GPS Seconds since epoch: {gps_seconds:.3f}\")\n# GPS Seconds since epoch: 1402497063.500\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh::TimeSystem::UTC);\n    println!(\"Epoch: {}\", epc);\n    // Epoch: 2024-06-15 14:30:45.500 UTC\n\n    // Output the equivalent Julian Date\n    let jd = epc.jd();\n    println!(\"Julian Date: {:.6}\", jd);\n    // Julian Date: 2460477.104693\n\n    // Get the Julian Date in a different time system (e.g., TT)\n    let jd_tt = epc.jd_as_time_system(bh::TimeSystem::TT);\n    println!(\"Julian Date (TT): {:.6}\", jd_tt);\n    // Julian Date (TT): 2460477.105494\n\n    // Output the equivalent Modified Julian Date\n    let mjd = epc.mjd();\n    println!(\"Modified Julian Date: {:.6}\", mjd);\n    // Modified Julian Date: 60476.604693\n\n    // Get the Modified Julian Date in a different time system (e.g., GPS)\n    let mjd_gps = epc.mjd_as_time_system(bh::TimeSystem::GPS);\n    println!(\"Modified Julian Date (GPS): {:.6}\", mjd_gps);\n    // Modified Julian Date (GPS): 60476.604902\n\n    // Get the GPS Week and Seconds of Week\n    let (gps_week, gps_sow) = epc.gps_date();\n    println!(\"GPS Week: {}, Seconds of Week: {:.3}\", gps_week, gps_sow);\n    // GPS Week: 2318, Seconds of Week: 570663.500\n\n    // The Epoch as GPS seconds since the GPS epoch\n    let gps_seconds = epc.gps_seconds();\n    println!(\"GPS Seconds since epoch: {:.3}\", gps_seconds);\n    // GPS Seconds since epoch: 1402497063.500\n}\n</code></pre>"},{"location":"learn/time/epoch.html#string-representation","title":"String Representation","text":"<p>Epochs can be converted to human-readable strings in various formats and time systems.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\n# Create an epoch\nepc = bh.Epoch(2024, 6, 15, 14, 30, 45.123456789, 0.0)\n\n# Default string representation\nprint(f\"Default: {epc}\")\n# Default: 2024-06-15 14:30:45.123 UTC\n\n# Explicit string conversion\nprint(f\"String: {str(epc)}\")\n# String: 2024-06-15 14:30:45.123 UTC\n\n# Debug representation\nprint(f\"Debug: {repr(epc)}\")\n# Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n# Get string in a different time system\nprint(f\"TT: {epc.to_string_as_time_system(bh.TimeSystem.TT)}\")\n# TT: 2024-06-15 14:31:54.307 TT\n\n# Get as ISO 8601 formatted string\nprint(f\"ISO 8601: {epc.isostring()}\")\n# ISO 8601: 2024-06-15T14:30:45Z\n\n# Get as ISO 8601 with different number of decimal places\nprint(f\"ISO 8601 (0 decimal places): {epc.isostring_with_decimals(0)}\")\nprint(f\"ISO 8601 (3 decimal places): {epc.isostring_with_decimals(3)}\")\nprint(f\"ISO 8601 (6 decimal places): {epc.isostring_with_decimals(6)}\")\n# ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n# ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n# ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    // Create an epoch\n    let epc = bh::Epoch::from_datetime(2024, 6, 15, 14, 30, 45.123456789, 0.0, bh::TimeSystem::UTC);\n\n    // Default string representation\n    println!(\"Default: {}\", epc);\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Explicit string conversion (same as default in Rust)\n    println!(\"String: {}\", epc.to_string());\n    // String: 2024-06-15 14:30:45.123 UTC\n\n    // Debug representation\n    println!(\"Debug: {:?}\", epc);\n    // Debug: Epoch&lt;2460477, 9082, 123456788.98545027, 0, UTC&gt;\n\n    // Get string in a different time system\n    println!(\"TT: {}\", epc.to_string_as_time_system(bh::TimeSystem::TT));\n    // TT: 2024-06-15 14:31:54.307 TT\n\n    // Get as ISO 8601 formatted string\n    println!(\"ISO 8601: {}\", epc.isostring());\n    // ISO 8601: 2024-06-15T14:30:45Z\n\n    // Get as ISO 8601 with different number of decimal places\n    println!(\"ISO 8601 (0 decimal places): {}\", epc.isostring_with_decimals(0));\n    println!(\"ISO 8601 (3 decimal places): {}\", epc.isostring_with_decimals(3));\n    println!(\"ISO 8601 (6 decimal places): {}\", epc.isostring_with_decimals(6));\n    // ISO 8601 (0 decimal places): 2024-06-15T14:30:45Z\n    // ISO 8601 (3 decimal places): 2024-06-15T14:30:45.123Z\n    // ISO 8601 (6 decimal places): 2024-06-15T14:30:45.123456Z\n}\n</code></pre>"},{"location":"learn/time/epoch.html#see-also","title":"See Also","text":"<ul> <li>Epoch API Reference</li> </ul>"},{"location":"learn/time/time_range.html","title":"Time Range","text":"<p>The <code>TimeRange</code> class provides an easy way to iterate over a range of time instances. You can specify a start and end <code>Epoch</code>, along with a time step in seconds, and the <code>TimeRange</code> will generate all the <code>Epoch</code> instances within that range at the specified intervals.</p> PythonRust <pre><code>import brahe as bh\n\nbh.initialize_eop()\n\nfor epc in bh.TimeRange(\n    bh.Epoch(2024, 1, 1, 0, 0, 0.0, time_system=bh.UTC),\n    bh.Epoch(2024, 1, 2, 0, 0, 0.0, time_system=bh.UTC),\n    3600.0,\n):\n    print(epc)\n</code></pre> <pre><code>use brahe as bh;\n\nfn main() {\n    bh::initialize_eop().unwrap();\n\n    for epc in bh::TimeRange::new(\n        bh::Epoch::from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        bh::Epoch::from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh::TimeSystem::UTC),\n        3600.0\n    ) {\n        println!(\"{}\", epc);\n    }\n}\n</code></pre>"},{"location":"learn/trajectories/index.html","title":"Trajectories","text":"<p>Brahe provides trajectory containers for storing and managing time-series state data.</p>"},{"location":"learn/trajectories/index.html#overview","title":"Overview","text":"<p>Trajectories store sequences of states (positions and velocities) indexed by time. They support:</p> <ul> <li>Interpolation between time points</li> <li>Efficient storage</li> <li>Automatic eviction policies</li> <li>Multiple representations (Cartesian, Keplerian)</li> </ul>"},{"location":"learn/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":"<p>Brahe offers three trajectory implementations:</p>"},{"location":"learn/trajectories/index.html#dtrajectory","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory for arbitrary state sizes:</p> <ul> <li>Runtime-configurable dimension</li> <li>Flexible for various applications</li> <li>Slightly more overhead than static types</li> </ul> <p>Use when: State dimension varies or is determined at runtime.</p>"},{"location":"learn/trajectories/index.html#strajectory6","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital states:</p> <ul> <li>Fixed 6D states <code>[x, y, z, vx, vy, vz]</code></li> <li>Compile-time optimization</li> <li>Lower memory overhead</li> <li>Fastest performance</li> </ul> <p>Use when: Storing standard Cartesian orbital states.</p>"},{"location":"learn/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized trajectory for orbital mechanics:</p> <ul> <li>Stores states in multiple representations (Cartesian, Keplerian)</li> <li>Automatic frame tracking (ECI/ECEF)</li> <li>Orbit-specific interpolation</li> <li>Ideal for orbit analysis</li> </ul> <p>Use when: Performing orbital mechanics analysis and visualization.</p>"},{"location":"learn/trajectories/index.html#common-features","title":"Common Features","text":"<p>All trajectory types support:</p> <ul> <li>Interpolation: Linear, cubic, or Lagrange</li> <li>Eviction policies: None, LRU (least recently used), time-based</li> <li>Time indexing: Fast lookup by epoch</li> <li>State queries: Get state at specific times</li> </ul>"},{"location":"learn/trajectories/index.html#choosing-a-trajectory-type","title":"Choosing a Trajectory Type","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Need orbit-specific features?      \u2502\n\u2502 (Keplerian elements, frame info)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 Yes            \u2502 No\n    \u2502                \u2502\n    \u25bc                \u25bc\nOrbitTrajectory   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502 Fixed 6D state?        \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502 Yes            \u2502 No\n                  \u2502                \u2502\n                  \u25bc                \u25bc\n              STrajectory6    DTrajectory\n</code></pre>"},{"location":"learn/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory</li> <li>OrbitTrajectory</li> <li>API Reference</li> </ul>"},{"location":"learn/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory for variable-size state vectors.</p>"},{"location":"learn/trajectories/dtrajectory.html#overview","title":"Overview","text":"<p><code>DTrajectory</code> stores time-series state data where the state dimension is determined at runtime. It provides flexibility for applications with varying state sizes.</p>"},{"location":"learn/trajectories/dtrajectory.html#creating-a-dtrajectory","title":"Creating a DTrajectory","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory with 6D states\ntraj = bh.DTrajectory(\n    dimension=6,\n    interpolation=bh.InterpolationMethod.LINEAR,\n    eviction=bh.TrajectoryEvictionPolicy.NONE\n)\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\n\ntraj.add_state(epoch, state)\n\n# Add multiple states\nfor i in range(10):\n    epoch_i = epoch + i * 60.0  # Every minute\n    state_i = propagate_state(state, i * 60.0)  # Your propagation function\n    traj.add_state(epoch_i, state_i)\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#querying-states","title":"Querying States","text":"<pre><code>import brahe as bh\n\n# Get state at specific epoch\nquery_epoch = epoch + 300.0  # 5 minutes later\ninterpolated_state = traj.get_state(query_epoch)\n\n# Get state without interpolation (nearest)\nnearest_state = traj.get_state_nearest(query_epoch)\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#interpolation-methods","title":"Interpolation Methods","text":"<ul> <li>None: Return exact matches only</li> <li>Linear: Linear interpolation between points</li> <li>Cubic: Cubic spline interpolation</li> <li>Lagrange: Lagrange polynomial interpolation</li> </ul> <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(\n    dimension=6,\n    interpolation=bh.InterpolationMethod.CUBIC,\n    eviction=bh.TrajectoryEvictionPolicy.NONE\n)\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#eviction-policies","title":"Eviction Policies","text":"<p>Control memory usage by automatically removing old states:</p> <pre><code>import brahe as bh\n\n# Keep all states\ntraj = bh.DTrajectory(6, bh.InterpolationMethod.LINEAR, bh.TrajectoryEvictionPolicy.NONE)\n\n# Keep only most recent N states\ntraj = bh.DTrajectory(6, bh.InterpolationMethod.LINEAR, bh.TrajectoryEvictionPolicy.LRU)\ntraj.set_max_size(1000)  # Keep last 1000 states\n</code></pre>"},{"location":"learn/trajectories/dtrajectory.html#use-cases","title":"Use Cases","text":"<p><code>DTrajectory</code> is ideal for:</p> <ul> <li>Extended state vectors (state + covariance)</li> <li>Multi-spacecraft formations</li> <li>Custom dynamics models</li> <li>Variable-dimension applications</li> </ul>"},{"location":"learn/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory API Reference</li> <li>Trajectories Overview</li> </ul>"},{"location":"learn/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p>Specialized trajectory for orbital mechanics with multiple state representations.</p>"},{"location":"learn/trajectories/orbit_trajectory.html#overview","title":"Overview","text":"<p><code>OrbitTrajectory</code> provides orbit-specific features beyond basic state storage:</p> <ul> <li>Automatic Cartesian \u2194 Keplerian conversions</li> <li>Reference frame tracking (ECI/ECEF)</li> <li>Orbit-aware interpolation</li> <li>Built-in orbit analysis</li> </ul>"},{"location":"learn/trajectories/orbit_trajectory.html#creating-an-orbittrajectory","title":"Creating an OrbitTrajectory","text":"<pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(\n    frame=bh.OrbitFrame.ECI,\n    representation=bh.OrbitRepresentation.CARTESIAN,\n    interpolation=bh.InterpolationMethod.LINEAR,\n    eviction=bh.TrajectoryEvictionPolicy.NONE\n)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#reference-frames","title":"Reference Frames","text":"<p>Specify which reference frame states are stored in:</p> <ul> <li>ECI: Earth-Centered Inertial (inertial frame)</li> <li>ECEF: Earth-Centered Earth-Fixed (rotating with Earth)</li> </ul> <pre><code>import brahe as bh\n\n# ECI frame (most common for orbit propagation)\ntraj_eci = bh.OrbitTrajectory(\n    frame=bh.OrbitFrame.ECI,\n    representation=bh.OrbitRepresentation.CARTESIAN\n)\n\n# ECEF frame (useful for ground tracking)\ntraj_ecef = bh.OrbitTrajectory(\n    frame=bh.OrbitFrame.ECEF,\n    representation=bh.OrbitRepresentation.CARTESIAN\n)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#state-representations","title":"State Representations","text":"<p>Choose how orbital states are stored:</p> <ul> <li>Cartesian: <code>[x, y, z, vx, vy, vz]</code> in meters and m/s</li> <li>Keplerian: <code>[a, e, i, \u03a9, \u03c9, \u03bd]</code> orbital elements</li> </ul> <pre><code>import brahe as bh\n\n# Store as Cartesian states\ntraj_cart = bh.OrbitTrajectory(\n    frame=bh.OrbitFrame.ECI,\n    representation=bh.OrbitRepresentation.CARTESIAN\n)\n\n# Store as Keplerian elements\ntraj_kep = bh.OrbitTrajectory(\n    frame=bh.OrbitFrame.ECI,\n    representation=bh.OrbitRepresentation.KEPLERIAN\n)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#adding-orbital-states","title":"Adding Orbital States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.UTC)\n\n# Cartesian state [x, y, z, vx, vy, vz]\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add_state(epoch, state)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#querying-in-different-representations","title":"Querying in Different Representations","text":"<pre><code>import brahe as bh\n\nquery_epoch = epoch + 600.0  # 10 minutes later\n\n# Get Cartesian state\ncart_state = traj.get_state_cartesian(query_epoch)\n\n# Get Keplerian elements\nkep_elements = traj.get_state_keplerian(query_epoch)\na, e, i, raan, argp, nu = kep_elements\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#orbit-specific-features","title":"Orbit-Specific Features","text":""},{"location":"learn/trajectories/orbit_trajectory.html#ground-track","title":"Ground Track","text":"<pre><code>import brahe as bh\n\n# Get ground track (lat, lon, alt) over time\nground_track = traj.compute_ground_track(\n    start_epoch=epoch,\n    end_epoch=epoch + 5400.0,  # 90 minutes\n    step=10.0  # Every 10 seconds\n)\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#orbit-statistics","title":"Orbit Statistics","text":"<pre><code>import brahe as bh\n\n# Compute orbit statistics\nstats = traj.get_orbit_statistics()\nprint(f\"Mean altitude: {stats.mean_altitude / 1000:.1f} km\")\nprint(f\"Eccentricity: {stats.mean_eccentricity:.6f}\")\n</code></pre>"},{"location":"learn/trajectories/orbit_trajectory.html#use-cases","title":"Use Cases","text":"<p><code>OrbitTrajectory</code> is ideal for:</p> <ul> <li>Orbit visualization and analysis</li> <li>Multi-representation workflows</li> <li>Ground track computation</li> <li>Orbit determination</li> </ul>"},{"location":"learn/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>OrbitTrajectory API Reference</li> <li>Trajectories Overview</li> <li>Orbit Propagation</li> </ul>"},{"location":"learn/trajectories/strajectory6.html","title":"STrajectory6","text":""},{"location":"learn/trajectories/strajectory6.html#overview","title":"Overview","text":"<p><code>STrajectory6</code> is a static 6-dimensional trajectory class optimized for orbital state representation. Unlike <code>DTrajectory</code> which has dynamic dimensionality, <code>STrajectory6</code> is specifically designed for storing and interpolating 6D state vectors (position and velocity).</p>"},{"location":"learn/trajectories/strajectory6.html#key-concepts","title":"Key Concepts","text":""},{"location":"learn/trajectories/strajectory6.html#static-dimensionality","title":"Static Dimensionality","text":"<p>The \"S\" in <code>STrajectory6</code> stands for \"Static\" - the trajectory always stores exactly 6 dimensions. This specialization enables:</p> <ul> <li>Memory efficiency: Fixed-size allocations</li> <li>Performance optimization: Compile-time optimizations for 6D operations</li> <li>Type safety: Guaranteed 6D structure at compile time</li> </ul>"},{"location":"learn/trajectories/strajectory6.html#typical-use-cases","title":"Typical Use Cases","text":"<p><code>STrajectory6</code> is ideal for:</p> <ul> <li>Storing propagated orbital states</li> <li>Interpolating spacecraft trajectories</li> <li>Recording position and velocity time series</li> <li>Working with Cartesian state vectors</li> </ul>"},{"location":"learn/trajectories/strajectory6.html#state-representation","title":"State Representation","text":"<p>States are stored as 6-element vectors:</p> \\[ \\mathbf{x} = \\begin{bmatrix} x \\\\ y \\\\ z \\\\ v_x \\\\ v_y \\\\ v_z \\end{bmatrix} \\] <p>Where: - Position components (x, y, z) are in meters - Velocity components (vx, vy, vz) are in meters/second</p>"},{"location":"learn/trajectories/strajectory6.html#common-operations","title":"Common Operations","text":""},{"location":"learn/trajectories/strajectory6.html#creating-a-trajectory","title":"Creating a Trajectory","text":"<p>Trajectories are typically created by:</p> <ol> <li>Initializing an empty trajectory</li> <li>Adding states at specific epochs during propagation</li> <li>Setting interpolation method</li> </ol>"},{"location":"learn/trajectories/strajectory6.html#interpolation","title":"Interpolation","text":"<p><code>STrajectory6</code> supports multiple interpolation methods:</p> <ul> <li>Linear: Fast, simple interpolation between points</li> <li>Lagrange: Higher-order polynomial interpolation</li> <li>Hermite: Cubic interpolation using derivatives</li> </ul>"},{"location":"learn/trajectories/strajectory6.html#querying-states","title":"Querying States","text":"<p>Once populated, you can query states at any epoch within the trajectory's time span. The trajectory will automatically interpolate between stored states.</p>"},{"location":"learn/trajectories/strajectory6.html#comparison-with-other-trajectory-types","title":"Comparison with Other Trajectory Types","text":"Feature STrajectory6 DTrajectory OrbitTrajectory Dimensionality Fixed (6D) Dynamic (any) Fixed (orbital) Optimization Compile-time Runtime Orbital-specific Use Case Cartesian states Generic data Orbital elements Memory Most efficient for 6D Flexible Element-optimized"},{"location":"learn/trajectories/strajectory6.html#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Best for: Large numbers of 6D state queries</li> <li>Memory: Fixed overhead per state point</li> <li>Speed: Fastest interpolation for 6D data</li> <li>Scalability: Efficient up to millions of state points</li> </ul>"},{"location":"learn/trajectories/strajectory6.html#further-reading","title":"Further Reading","text":"<ul> <li>See OrbitTrajectory for orbital element representation</li> <li>See DTrajectory for dynamic dimensionality</li> <li>See Trajectories Overview for comparison of all trajectory types</li> </ul>"},{"location":"learn/trajectories/strajectory6.html#api-reference","title":"API Reference","text":"<p>For detailed API documentation, see STrajectory6 API Reference.</p>"},{"location":"library_api/index.html","title":"Python API Reference","text":"<p>This section provides comprehensive documentation for the Brahe Python API. All classes, functions, and modules are documented with detailed descriptions, parameters, return values, and usage examples.</p>"},{"location":"library_api/index.html#core-modules","title":"Core Modules","text":""},{"location":"library_api/index.html#time","title":"Time","text":"<p>The time module provides precise time representation and conversion between different time systems (UTC, TAI, GPS, TT, UT1). The <code>Epoch</code> class is the foundational time representation used throughout Brahe.</p> <p>Key Components: - <code>Epoch</code>: High-precision time representation with nanosecond accuracy - Time system conversions and utilities</p>"},{"location":"library_api/index.html#coordinates","title":"Coordinates","text":"<p>Coordinate transformation functions for converting between various coordinate systems used in astrodynamics.</p> <p>Key Components: - Cartesian coordinates (position and velocity vectors) - Geodetic coordinates (latitude, longitude, altitude) - Geocentric coordinates - Topocentric coordinates (East-North-Up, South-East-Zenith)</p>"},{"location":"library_api/index.html#frames","title":"Frames","text":"<p>Reference frame transformations between Earth-Centered Inertial (ECI) and Earth-Centered Earth-Fixed (ECEF) coordinate frames using IAU 2006/2000A models.</p>"},{"location":"library_api/index.html#orbits","title":"Orbits","text":"<p>Orbital mechanics representations and Two-Line Element handling.</p> <p>Key Components: - Keplerian orbital elements - Two-Line Element (TLE) format parsing and validation - Orbital property calculations</p>"},{"location":"library_api/index.html#propagators","title":"Propagators","text":"<p>Orbit propagators for predicting satellite positions over time.</p> <p>Key Components: - Keplerian propagator (analytical two-body dynamics) - SGP4/SDP4 propagator (TLE-based orbit prediction)</p>"},{"location":"library_api/index.html#attitude","title":"Attitude","text":"<p>Attitude representation and conversion between different rotation parameterizations.</p> <p>Key Components: - Quaternions - Rotation matrices (Direction Cosine Matrices) - Euler angles (various sequences) - Euler axis-angle representation</p>"},{"location":"library_api/index.html#trajectories","title":"Trajectories","text":"<p>High-level trajectory containers with interpolation support for storing and querying orbital states over time.</p>"},{"location":"library_api/index.html#earth-orientation-parameters-eop","title":"Earth Orientation Parameters (EOP)","text":"<p>Earth orientation parameter data management for high-precision coordinate frame transformations.</p>"},{"location":"library_api/index.html#constants","title":"Constants","text":"<p>Mathematical, physical, and time-related constants used throughout the library.</p>"},{"location":"library_api/index.html#navigation","title":"Navigation","text":"<p>Use the sidebar to navigate through the detailed API documentation for each module. Each page includes:</p> <ul> <li>Complete class and function signatures</li> <li>Detailed parameter descriptions</li> <li>Return value specifications</li> <li>Usage examples</li> <li>References to related functionality</li> </ul> <p>All documentation is automatically generated from the source code docstrings to ensure accuracy and consistency.</p>"},{"location":"library_api/frames.html","title":"Reference Frames Module","text":"<p>Reference frame transformations between ECI and ECEF coordinate systems.</p>"},{"location":"library_api/frames.html#brahe.frames","title":"frames","text":"<p>Reference Frames Module</p> <p>Reference frame transformations between ECI and ECEF coordinate systems.</p> <p>This module provides transformations between: - ECI (Earth-Centered Inertial): J2000/GCRF frame - ECEF (Earth-Centered Earth-Fixed): ITRF frame</p> <p>The transformations implement the IAU 2006/2000A precession-nutation model and use Earth Orientation Parameters (EOP) for high-precision conversions.</p> <p>Functions are provided for: - Rotation matrices (bias-precession-nutation, Earth rotation, polar motion) - Position vector transformations - State vector (position + velocity) transformations</p>"},{"location":"library_api/frames.html#brahe.frames.bias_precession_nutation","title":"bias_precession_nutation  <code>builtin</code>","text":"<pre><code>bias_precession_nutation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Bias-Precession-Nutation matrix transforming the <code>GCRS</code> to the <code>CIRS</code> intermediate reference frame. This transformation corrects for the bias, precession, and nutation of Celestial Intermediate Origin (<code>CIO</code>) with respect to inertial space.</p> <p>This formulation computes the Bias-Precession-Nutation correction matrix according using a <code>CIO</code> based model using using the <code>IAU 2006</code> precession and <code>IAU 2000A</code> nutation models.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to the Celestial Intermediate Pole (<code>CIP</code>) derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRS</code> -&gt; <code>CIRS</code></p> References <p>IAU SOFA Tools For Earth Attitude, Example 5.5 http://www.iausofa.org/2021_0512_C/sofa/sofa_pn_c.pdf Software Version 18, 2021-04-18</p>"},{"location":"library_api/frames.html#brahe.frames.earth_rotation","title":"earth_rotation  <code>builtin</code>","text":"<pre><code>earth_rotation(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>CIRS</code> to the <code>TIRS</code> intermediate reference frame. This transformation corrects for the Earth rotation.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>CIRS</code> -&gt; <code>TIRS</code></p>"},{"location":"library_api/frames.html#brahe.frames.polar_motion","title":"polar_motion  <code>builtin</code>","text":"<pre><code>polar_motion(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the Earth rotation matrix transforming the <code>TIRS</code> to the <code>ITRF</code> reference frame.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections to compute the polar motion correction based on empirical observations of polar motion drift.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>TIRS</code> -&gt; <code>ITRF</code></p>"},{"location":"library_api/frames.html#brahe.frames.rotation_eci_to_ecef","title":"rotation_eci_to_ecef  <code>builtin</code>","text":"<pre><code>rotation_eci_to_ecef(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the inertial to the Earth-fixed reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>GCRF</code> -&gt; <code>ITRF</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix\nR = bh.rotation_eci_to_ecef(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n# Output: Rotation matrix shape: (3, 3)\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.rotation_ecef_to_eci","title":"rotation_ecef_to_eci  <code>builtin</code>","text":"<pre><code>rotation_ecef_to_eci(epc: Epoch) -&gt; Any\n</code></pre> <p>Computes the combined rotation matrix from the Earth-fixed to the inertial reference frame. Applies corrections for bias, precession, nutation, Earth-rotation, and polar motion.</p> <p>The transformation is accomplished using the <code>IAU 2006/2000A</code>, <code>CIO</code>-based theory using classical angles. The method as described in section 5.5 of the SOFA C transformation cookbook.</p> <p>The function will utilize the global Earth orientation and loaded data to apply corrections for Celestial Intermidate Pole (<code>CIP</code>) and polar motion drift derived from empirical observations.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for computation of transformation matrix</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix transforming <code>ITRF</code> -&gt; <code>GCRF</code></p> Example <pre><code>import brahe as bh\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Get rotation matrix from ECEF to ECI\nR = bh.rotation_ecef_to_eci(epc)\nprint(f\"Rotation matrix shape: {R.shape}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_eci_to_ecef","title":"position_eci_to_ecef  <code>builtin</code>","text":"<pre><code>position_eci_to_ecef(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position vector in ECI (meters)\nr_eci = np.array([7000000.0, 0.0, 0.0])\n\n# Transform to ECEF\nr_ecef = bh.position_eci_to_ecef(epc, r_eci)\nprint(f\"ECEF position: {r_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.position_ecef_to_eci","title":"position_ecef_to_eci  <code>builtin</code>","text":"<pre><code>position_ecef_to_eci(epc: Epoch, x: ndarray) -&gt; Any\n</code></pre> <p>Transforms a position vector from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> frame (m), shape <code>(3,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECI</code> frame (m), shape <code>(3,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Position in ECEF (ground station)\nr_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\n\n# Transform to ECI\nr_eci = bh.position_ecef_to_eci(epc, r_ecef)\nprint(f\"ECI position: {r_eci}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_eci_to_ecef","title":"state_eci_to_ecef  <code>builtin</code>","text":"<pre><code>state_eci_to_ecef(epc: Epoch, x_eci: ndarray) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame to the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_eci</code> <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECI [x, y, z, vx, vy, vz] (meters, m/s)\nstate_eci = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\n\n# Transform to ECEF\nstate_ecef = bh.state_eci_to_ecef(epc, state_eci)\nprint(f\"ECEF state: {state_ecef}\")\n</code></pre>"},{"location":"library_api/frames.html#brahe.frames.state_ecef_to_eci","title":"state_ecef_to_eci  <code>builtin</code>","text":"<pre><code>state_ecef_to_eci(epc: Epoch, x_ecef: ndarray) -&gt; ndarray\n</code></pre> <p>Transforms a state vector (position and velocity) from the Earth Centered Earth Fixed (<code>ECEF</code>/<code>ITRF</code>) frame to the Earth Centered Inertial (<code>ECI</code>/<code>GCRF</code>) frame.</p> <p>Applies the full <code>IAU 2006/2000A</code> transformation including bias, precession, nutation, Earth rotation, and polar motion corrections using global Earth orientation parameters. The velocity transformation accounts for the Earth's rotation rate.</p> <p>Parameters:</p> Name Type Description Default <code>epc</code> <code>Epoch</code> <p>Epoch instant for the transformation</p> required <code>x_ecef</code> <code>ndarray</code> <p>State vector in <code>ECEF</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>State vector in <code>ECI</code> frame <code>[position (m), velocity (m/s)]</code>, shape <code>(6,)</code></p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# State vector in ECEF [x, y, z, vx, vy, vz] (meters, m/s)\nstate_ecef = np.array([4000000.0, 3000000.0, 4000000.0, 100.0, -50.0, 200.0])\n\n# Transform to ECI\nstate_eci = bh.state_ecef_to_eci(epc, state_ecef)\nprint(f\"ECI state: {state_eci}\")\n</code></pre>"},{"location":"library_api/access/index.html","title":"Access Computation API","text":"<p>The access computation module provides comprehensive tools for determining when satellites can observe or communicate with ground locations.</p>"},{"location":"library_api/access/index.html#core-functions","title":"Core Functions","text":""},{"location":"library_api/access/index.html#brahe.location_accesses","title":"location_accesses  <code>builtin</code>","text":"<pre><code>location_accesses(locations: PointLocation | PolygonLocation | List[PointLocation | PolygonLocation], propagators: SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator], search_start: Epoch, search_end: Epoch, constraint: Union[ElevationConstraint, OffNadirConstraint, LocalTimeConstraint, LookDirectionConstraint, AscDscConstraint, ElevationMaskConstraint, ConstraintAll, ConstraintAny, ConstraintNot], property_computers: [List[AccessPropertyComputer]] = None, config: [AccessSearchConfig] = None, time_tolerance: [float] = None) -&gt; List[AccessWindow]\n</code></pre> <p>Compute access windows for locations and satellites.</p> <p>This function accepts either single items or lists for both locations and propagators, automatically handling all combinations. All location-satellite pairs are computed and results are returned sorted by window start time.</p> <p>Parameters:</p> Name Type Description Default <code>locations</code> <code>PointLocation | PolygonLocation | List[PointLocation | PolygonLocation]</code> <p>Single location or list of locations</p> required <code>propagators</code> <code>SGPPropagator | KeplerianPropagator | List[SGPPropagator | KeplerianPropagator]</code> <p>Single propagator or list of propagators</p> required <code>search_start</code> <code>Epoch</code> <p>Start of search window</p> required <code>search_end</code> <code>Epoch</code> <p>End of search window</p> required <code>constraint</code> <code>AccessConstraint</code> <p>Access constraints to evaluate</p> required <code>property_computers</code> <code>Optional[List[AccessPropertyComputer]]</code> <p>Optional property computers</p> <code>None</code> <code>config</code> <code>Optional[AccessSearchConfig]</code> <p>Search configuration (default: 60s fixed grid, no adaptation)</p> <code>None</code> <code>time_tolerance</code> <code>Optional[float]</code> <p>Bisection search tolerance in seconds (default: 0.01)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AccessWindow]</code> <p>List[AccessWindow]: List of access windows sorted by start time</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a ground station\nstation = bh.PointLocation(-75.0, 40.0, 0.0)  # Philadelphia\n\n# Create satellite propagators\nepoch = bh.Epoch(2024, 1, 1, 0, 0, 0.0)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 97.8, 15.0, 30.0, 45.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.DEGREES)\nprop1 = bh.KeplerianPropagator(epoch, state)\n\n# Define access constraints\nconstraint = bh.ElevationConstraint(10.0)  # 10 degree minimum elevation\n\n# Single location, single propagator\nsearch_end = epoch + 86400.0  # 1 day\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint)\n\n# Single location, multiple propagators\nprop2 = bh.KeplerianPropagator(epoch, state)  # Different satellite\nwindows = bh.location_accesses(station, [prop1, prop2], epoch, search_end, constraint)\n\n# Multiple locations, single propagator\nstation2 = bh.PointLocation(-122.0, 37.0, 0.0)  # San Francisco\nwindows = bh.location_accesses([station, station2], prop1, epoch, search_end, constraint)\n\n# Multiple locations, multiple propagators\nwindows = bh.location_accesses([station, station2], [prop1, prop2], epoch, search_end, constraint)\n\n# Custom search configuration\nconfig = bh.AccessSearchConfig(initial_time_step=30.0, adaptive_step=True)\nwindows = bh.location_accesses(station, prop1, epoch, search_end, constraint, config=config)\n</code></pre>"},{"location":"library_api/access/index.html#configuration","title":"Configuration","text":""},{"location":"library_api/access/index.html#brahe.AccessSearchConfig","title":"AccessSearchConfig","text":"<pre><code>AccessSearchConfig(initial_time_step: float, adaptive_step: bool, adaptive_fraction: float)\n</code></pre> <p>Configuration for access search grid parameters.</p> <p>Controls the time step and adaptive stepping behavior for access window finding.</p> <p>Parameters:</p> Name Type Description Default <code>initial_time_step</code> <code>float</code> <p>Initial time step in seconds for grid search (default: 60.0)</p> required <code>adaptive_step</code> <code>bool</code> <p>Enable adaptive stepping after first access (default: False)</p> required <code>adaptive_fraction</code> <code>float</code> <p>Fraction of orbital period to use for adaptive step (default: 0.75)</p> required Example <pre><code>import brahe as bh\n\n# Create a config with custom parameters\nconfig = bh.AccessSearchConfig(\n    initial_time_step=30.0,\n    adaptive_step=True,\n    adaptive_fraction=0.5\n)\n\n# Use config with location_accesses\nwindows = bh.location_accesses(\n    station, prop, search_start, search_end,\n    constraint, config=config\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Configuration for access search grid parameters.\\n\\nControls the time step and adaptive stepping behavior for access window finding.\\n\\nArgs:\\n    initial_time_step (float): Initial time step in seconds for grid search (default: 60.0)\\n    adaptive_step (bool): Enable adaptive stepping after first access (default: False)\\n    adaptive_fraction (float): Fraction of orbital period to use for adaptive step (default: 0.75)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a config with custom parameters\\n    config = bh.AccessSearchConfig(\\n        initial_time_step=30.0,\\n        adaptive_step=True,\\n        adaptive_fraction=0.5\\n    )\\n\\n    # Use config with location_accesses\\n    windows = bh.location_accesses(\\n        station, prop, search_start, search_end,\\n        constraint, config=config\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_fraction","title":"adaptive_fraction  <code>property</code>","text":"<pre><code>adaptive_fraction: float\n</code></pre> <p>Get the adaptive fraction (fraction of orbital period).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Adaptive fraction</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.adaptive_step","title":"adaptive_step  <code>property</code>","text":"<pre><code>adaptive_step: bool\n</code></pre> <p>Get whether adaptive stepping is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Adaptive stepping flag</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.initial_time_step","title":"initial_time_step  <code>property</code>","text":"<pre><code>initial_time_step: float\n</code></pre> <p>Get the initial time step in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Initial time step</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.num_threads","title":"num_threads  <code>property</code>","text":"<pre><code>num_threads: Optional[int]\n</code></pre> <p>Get the number of threads for parallel computation.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Number of threads, or None to use global setting</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.parallel","title":"parallel  <code>property</code>","text":"<pre><code>parallel: bool\n</code></pre> <p>Get whether parallel computation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Parallel computation flag (default: True)</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/index.html#brahe.AccessSearchConfig.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/index.html#threading-control","title":"Threading Control","text":""},{"location":"library_api/access/index.html#brahe.set_num_threads","title":"set_num_threads  <code>builtin</code>","text":"<pre><code>set_num_threads(n: int) -&gt; Any\n</code></pre> <p>Set the number of threads for parallel computation.</p> <p>Configures the global thread pool used by Brahe for parallel operations such as access computations. This function can be called multiple times to dynamically change the thread pool configuration - each call will reinitialize the pool with the new thread count.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of threads to use. Must be at least 1.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If n &lt; 1.</p> <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Set to 4 threads initially\nbh.set_num_threads(4)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 4\n\n# Reinitialize with 8 threads - no error!\nbh.set_num_threads(8)\nprint(f\"Threads: {bh.get_max_threads()}\")  # Output: 8\n\n# All parallel operations (e.g., location_accesses) will now use\n# 8 threads unless overridden with AccessSearchConfig.num_threads\n</code></pre> Note <p>Unlike earlier versions, this function no longer raises an error if the thread pool has already been initialized. You can safely call it at any time to reconfigure the thread pool.</p>"},{"location":"library_api/access/index.html#brahe.set_max_threads","title":"set_max_threads  <code>builtin</code>","text":"<pre><code>set_max_threads() -&gt; Any\n</code></pre> <p>Set the thread pool to use all available CPU cores.</p> <p>This is a convenience function that sets the number of threads to 100% of available CPU cores. Can be called multiple times to reinitialize the thread pool dynamically.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# Use all available CPU cores\nbh.set_max_threads()\nprint(f\"Using all {bh.get_max_threads()} cores\")\n\n# Switch to 2 threads\nbh.set_num_threads(2)\n\n# Switch back to max - no error!\nbh.set_max_threads()\nprint(f\"Back to {bh.get_max_threads()} cores\")\n</code></pre> Note <p>This function can be called at any time, even after the thread pool has been initialized with a different configuration.</p>"},{"location":"library_api/access/index.html#brahe.set_ludicrous_speed","title":"set_ludicrous_speed  <code>builtin</code>","text":"<pre><code>set_ludicrous_speed() -&gt; Any\n</code></pre> <p>LUDICROUS SPEED! GO!</p> <p>Set the thread pool to use all available CPU cores (alias for <code>set_max_threads</code>).</p> <p>This is a fun alias for <code>set_max_threads()</code> that sets the number of threads to 100% of available CPU cores for maximum performance. Can be called multiple times to dynamically reinitialize the thread pool.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If thread pool fails to build.</p> Example <pre><code>import brahe as bh\n\n# MAXIMUM POWER! Use all available CPU cores\nbh.set_ludicrous_speed()\nprint(f\"Going ludicrous with {bh.get_max_threads()} threads!\")\n\n# Throttle down for testing\nbh.set_num_threads(1)\n\n# ENGAGE LUDICROUS SPEED again - no error!\nbh.set_ludicrous_speed()\n</code></pre> Note <p>This function can be called at any time to reconfigure the thread pool to use maximum available cores, regardless of previous configuration.</p>"},{"location":"library_api/access/index.html#brahe.get_max_threads","title":"get_max_threads  <code>builtin</code>","text":"<pre><code>get_max_threads() -&gt; int\n</code></pre> <p>Get the current maximum number of threads for parallel computation.</p> <p>Returns the number of threads configured for the global thread pool. If the thread pool hasn't been initialized yet, this initializes it with the default (90% of available cores) and returns that value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of threads currently configured.</p> Example <pre><code>import brahe as bh\n\n# Get default thread count (90% of cores, initialized on first call)\nthreads = bh.get_max_threads()\nprint(f\"Default: {threads} threads\")\n\n# Set to specific value and verify\nbh.set_num_threads(4)\nassert bh.get_max_threads() == 4\n\n# Reconfigure and verify again\nbh.set_num_threads(8)\nassert bh.get_max_threads() == 8\n\n# Switch to max cores\nbh.set_max_threads()\nprint(f\"Max cores: {bh.get_max_threads()}\")\n</code></pre> Note <p>Calling this function will initialize the thread pool with default settings (90% of cores) if it hasn't been configured yet. After initialization, you can still reconfigure it using set_num_threads() or set_max_threads().</p>"},{"location":"library_api/access/constraints.html","title":"Constraints","text":"<p>Constraints define criteria that must be satisfied for satellite access.</p>"},{"location":"library_api/access/constraints.html#built-in-constraints","title":"Built-in Constraints","text":""},{"location":"library_api/access/constraints.html#elevationconstraint","title":"ElevationConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint","title":"ElevationConstraint","text":"<pre><code>ElevationConstraint(min_elevation_deg: float | None, max_elevation_deg: float | None)\n</code></pre> <p>Elevation angle constraint for satellite visibility.</p> <p>Constrains access based on the elevation angle of the satellite above the local horizon at the ground location.</p> <p>Parameters:</p> Name Type Description Default <code>min_elevation_deg</code> <code>float | None</code> <p>Minimum elevation angle in degrees, or None for no minimum</p> required <code>max_elevation_deg</code> <code>float | None</code> <p>Maximum elevation angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None (unbounded constraint is meaningless)</p> Example <pre><code>import brahe as bh\n\n# Typical ground station constraint: 5\u00b0 minimum elevation\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\n\n# Both bounds specified\nconstraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\n\n# Only maximum (e.g., avoid zenith)\nconstraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Elevation angle constraint for satellite visibility.\\n\\nConstrains access based on the elevation angle of the satellite above\\nthe local horizon at the ground location.\\n\\nArgs:\\n    min_elevation_deg (float | None): Minimum elevation angle in degrees, or None for no minimum\\n    max_elevation_deg (float | None): Maximum elevation angle in degrees, or None for no maximum\\n\\nRaises:\\n    ValueError: If both min and max are None (unbounded constraint is meaningless)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Typical ground station constraint: 5\u00b0 minimum elevation\\n    constraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\\n\\n    # Both bounds specified\\n    constraint = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=85.0)\\n\\n    # Only maximum (e.g., avoid zenith)\\n    constraint = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=85.0)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#elevationmaskconstraint","title":"ElevationMaskConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint","title":"ElevationMaskConstraint","text":"<pre><code>ElevationMaskConstraint(mask: list[tuple[float, float]])\n</code></pre> <p>Azimuth-dependent elevation mask constraint.</p> <p>Constrains access based on azimuth-dependent elevation masks. Useful for ground stations with terrain obstructions or antenna limitations.</p> <p>The mask is defined as a list of (azimuth, elevation) pairs in degrees. Linear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>list[tuple[float, float]]</code> <p>List of (azimuth_deg, min_elevation_deg) pairs</p> required Example <pre><code>import brahe as bh\n\n# Ground station with terrain obstruction to the north\nmask = [\n    (0.0, 15.0),     # North: 15\u00b0 minimum\n    (90.0, 5.0),     # East: 5\u00b0 minimum\n    (180.0, 5.0),    # South: 5\u00b0 minimum\n    (270.0, 5.0),    # West: 5\u00b0 minimum\n]\nconstraint = bh.ElevationMaskConstraint(mask)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Azimuth-dependent elevation mask constraint.\\n\\nConstrains access based on azimuth-dependent elevation masks.\\nUseful for ground stations with terrain obstructions or antenna limitations.\\n\\nThe mask is defined as a list of (azimuth, elevation) pairs in degrees.\\nLinear interpolation is used between points, and the mask wraps at 0\u00b0/360\u00b0.\\n\\nArgs:\\n    mask (list[tuple[float, float]]): List of (azimuth_deg, min_elevation_deg) pairs\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Ground station with terrain obstruction to the north\\n    mask = [\\n        (0.0, 15.0),     # North: 15\u00b0 minimum\\n        (90.0, 5.0),     # East: 5\u00b0 minimum\\n        (180.0, 5.0),    # South: 5\u00b0 minimum\\n        (270.0, 5.0),    # West: 5\u00b0 minimum\\n    ]\\n    constraint = bh.ElevationMaskConstraint(mask)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ElevationMaskConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#offnadirconstraint","title":"OffNadirConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint","title":"OffNadirConstraint","text":"<pre><code>OffNadirConstraint(min_off_nadir_deg: float | None, max_off_nadir_deg: float | None)\n</code></pre> <p>Off-nadir angle constraint for satellite imaging.</p> <p>Constrains access based on the off-nadir angle (angle between the satellite's nadir vector and the line-of-sight to the location).</p> <p>Parameters:</p> Name Type Description Default <code>min_off_nadir_deg</code> <code>float | None</code> <p>Minimum off-nadir angle in degrees, or None for no minimum</p> required <code>max_off_nadir_deg</code> <code>float | None</code> <p>Maximum off-nadir angle in degrees, or None for no maximum</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If both min and max are None, or if any angle is negative</p> Example <pre><code>import brahe as bh\n\n# Imaging satellite with 45\u00b0 maximum slew angle\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\n\n# Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\nconstraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = \"Off-nadir angle constraint for satellite imaging.\\n\\nConstrains access based on the off-nadir angle (angle between the satellite's\\nnadir vector and the line-of-sight to the location).\\n\\nArgs:\\n    min_off_nadir_deg (float | None): Minimum off-nadir angle in degrees, or None for no minimum\\n    max_off_nadir_deg (float | None): Maximum off-nadir angle in degrees, or None for no maximum\\n\\nRaises:\\n    ValueError: If both min and max are None, or if any angle is negative\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Imaging satellite with 45\u00b0 maximum slew angle\\n    constraint = bh.OffNadirConstraint(min_off_nadir_deg=None, max_off_nadir_deg=45.0)\\n\\n    # Minimum 10\u00b0 to avoid nadir (e.g., for oblique imaging)\\n    constraint = bh.OffNadirConstraint(min_off_nadir_deg=10.0, max_off_nadir_deg=45.0)\\n    ```\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.OffNadirConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#lookdirectionconstraint","title":"LookDirectionConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint","title":"LookDirectionConstraint","text":"<pre><code>LookDirectionConstraint(allowed: LookDirection)\n</code></pre> <p>Look direction constraint (left/right relative to velocity).</p> <p>Constrains access based on the look direction of the satellite relative to its velocity vector.</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>LookDirection</code> <p>Required look direction (LEFT, RIGHT, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Satellite can only look right\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Either direction is acceptable\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Look direction constraint (left/right relative to velocity).\\n\\nConstrains access based on the look direction of the satellite relative\\nto its velocity vector.\\n\\nArgs:\\n    allowed (LookDirection): Required look direction (LEFT, RIGHT, or EITHER)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Satellite can only look right\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\\n\\n    # Either direction is acceptable\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LookDirectionConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#localtimeconstraint","title":"LocalTimeConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint","title":"LocalTimeConstraint","text":"<pre><code>LocalTimeConstraint(time_windows: list[tuple[int, int]])\n</code></pre> <p>Local solar time constraint.</p> <p>Constrains access based on the local solar time at the ground location. Useful for sun-synchronous orbits or daytime-only imaging.</p> <p>Time windows are specified in military time format (HHMM). Wrap-around windows (e.g., 2200-0200) are supported.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[int, int]]</code> <p>List of (start_military, end_military) tuples (0-2400)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any military time is invalid (&gt;2400 or minutes &gt;=60)</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\n\n# Two windows: morning (6-9 AM) and evening (4-7 PM)\nconstraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\n\n# Overnight window (10 PM to 2 AM) - handles wrap-around\nconstraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Local solar time constraint.\\n\\nConstrains access based on the local solar time at the ground location.\\nUseful for sun-synchronous orbits or daytime-only imaging.\\n\\nTime windows are specified in military time format (HHMM).\\nWrap-around windows (e.g., 2200-0200) are supported.\\n\\nArgs:\\n    time_windows (list[tuple[int, int]]): List of (start_military, end_military) tuples (0-2400)\\n\\nRaises:\\n    ValueError: If any military time is invalid (&gt;2400 or minutes &gt;=60)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Only daytime (6 AM to 6 PM local time)\\n    constraint = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\\n\\n    # Two windows: morning (6-9 AM) and evening (4-7 PM)\\n    constraint = bh.LocalTimeConstraint(time_windows=[(600, 900), (1600, 1900)])\\n\\n    # Overnight window (10 PM to 2 AM) - handles wrap-around\\n    constraint = bh.LocalTimeConstraint(time_windows=[(2200, 200)])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.from_hours","title":"from_hours  <code>builtin</code>","text":"<pre><code>from_hours(time_windows: list[tuple[float, float]]) -&gt; LocalTimeConstraint\n</code></pre> <p>Create from decimal hour windows instead of military time.</p> <p>Parameters:</p> Name Type Description Default <code>time_windows</code> <code>list[tuple[float, float]]</code> <p>List of (start_hour, end_hour) tuples [0, 24)</p> required <p>Returns:</p> Name Type Description <code>LocalTimeConstraint</code> <code>LocalTimeConstraint</code> <p>The constraint instance</p> Example <pre><code>import brahe as bh\n\n# Only daytime (6 AM to 6 PM local time)\nconstraint = bh.LocalTimeConstraint.from_hours([(6.0, 18.0)])\n\n# Overnight window (10 PM to 2 AM)\nconstraint = bh.LocalTimeConstraint.from_hours([(22.0, 2.0)])\n</code></pre>"},{"location":"library_api/access/constraints.html#brahe.LocalTimeConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#ascdscconstraint","title":"AscDscConstraint","text":""},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint","title":"AscDscConstraint","text":"<pre><code>AscDscConstraint(allowed: AscDsc)\n</code></pre> <p>Ascending/descending pass constraint.</p> <p>Constrains access based on whether the satellite is on an ascending or descending pass (moving north or south).</p> <p>Parameters:</p> Name Type Description Default <code>allowed</code> <code>AscDsc</code> <p>Required pass type (ASCENDING, DESCENDING, or EITHER)</p> required Example <pre><code>import brahe as bh\n\n# Only ascending passes\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Either type is acceptable\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Ascending/descending pass constraint.\\n\\nConstrains access based on whether the satellite is on an ascending or\\ndescending pass (moving north or south).\\n\\nArgs:\\n    allowed (AscDsc): Required pass type (ASCENDING, DESCENDING, or EITHER)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Only ascending passes\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\\n\\n    # Either type is acceptable\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.AscDscConstraint.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#logical-composition","title":"Logical Composition","text":""},{"location":"library_api/access/constraints.html#constraintall","title":"ConstraintAll","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAll","title":"ConstraintAll","text":"<pre><code>ConstraintAll(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with AND logic.</p> <p>All constraints must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with AND logic</p> required Example <pre><code>import brahe as bh\n\n# Ground station with multiple requirements\nelev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\ncombined = bh.ConstraintAll(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint combining multiple constraints with AND logic.\\n\\nAll constraints must be satisfied for the composite to evaluate to true.\\n\\nArgs:\\n    constraints (list): List of constraint objects to combine with AND logic\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Ground station with multiple requirements\\n    elev = bh.ElevationConstraint(min_elevation_deg=5.0, max_elevation_deg=None)\\n    time = bh.LocalTimeConstraint(time_windows=[(600, 1800)])\\n    combined = bh.ConstraintAll(constraints=[elev, time])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if ALL constraints are satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAll.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintany","title":"ConstraintAny","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintAny","title":"ConstraintAny","text":"<pre><code>ConstraintAny(constraints: List)\n</code></pre> <p>Composite constraint combining multiple constraints with OR logic.</p> <p>At least one constraint must be satisfied for the composite to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraints</code> <code>list</code> <p>List of constraint objects to combine with OR logic</p> required Example <pre><code>import brahe as bh\n\n# Accept either high elevation or specific time window\nelev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\ntime = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\ncombined = bh.ConstraintAny(constraints=[elev, time])\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint combining multiple constraints with OR logic.\\n\\nAt least one constraint must be satisfied for the composite to evaluate to true.\\n\\nArgs:\\n    constraints (list): List of constraint objects to combine with OR logic\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Accept either high elevation or specific time window\\n    elev = bh.ElevationConstraint(min_elevation_deg=60.0, max_elevation_deg=None)\\n    time = bh.LocalTimeConstraint(time_windows=[(1200, 1400)])\\n    combined = bh.ConstraintAny(constraints=[elev, time])\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if AT LEAST ONE constraint is satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintAny.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#constraintnot","title":"ConstraintNot","text":""},{"location":"library_api/access/constraints.html#brahe.ConstraintNot","title":"ConstraintNot","text":"<pre><code>ConstraintNot()\n</code></pre> <p>Composite constraint negating another constraint with NOT logic.</p> <p>The negated constraint must NOT be satisfied for this to evaluate to true.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <p>Constraint object to negate</p> required Example <pre><code>import brahe as bh\n\n# Avoid low elevation angles (i.e., require high elevation)\nlow_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\nhigh_elev = bh.ConstraintNot(constraint=low_elev)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Composite constraint negating another constraint with NOT logic.\\n\\nThe negated constraint must NOT be satisfied for this to evaluate to true.\\n\\nArgs:\\n    constraint: Constraint object to negate\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Avoid low elevation angles (i.e., require high elevation)\\n    low_elev = bh.ElevationConstraint(min_elevation_deg=None, max_elevation_deg=10.0)\\n    high_elev = bh.ConstraintNot(constraint=low_elev)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.evaluate","title":"evaluate  <code>method descriptor</code>","text":"<pre><code>evaluate(epoch: Epoch, sat_state_ecef: ndarray, location_ecef: ndarray) -&gt; bool\n</code></pre> <p>Evaluate whether the constraint is satisfied.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of evaluation</p> required <code>sat_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x, y, z, vx, vy, vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Ground location in ECEF [x, y, z] (meters)</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the negated constraint is NOT satisfied, False otherwise</p>"},{"location":"library_api/access/constraints.html#brahe.ConstraintNot.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; Any\n</code></pre> <p>Get the constraint name</p>"},{"location":"library_api/access/constraints.html#custom-constraints","title":"Custom Constraints","text":""},{"location":"library_api/access/constraints.html#accesspropertycomputer","title":"AccessPropertyComputer","text":""},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer","title":"AccessPropertyComputer","text":"<pre><code>AccessPropertyComputer(window: AccessWindow, satellite_state_ecef: ndarray, location_ecef: ndarray)\n</code></pre> <p>Base class for custom access property computers.</p> <p>Subclass this class and implement the <code>compute</code> and <code>property_names</code> methods to create custom property calculations that can be applied to access windows.</p> <p>The compute method is called for each access window and should return a dictionary of property names to values. Properties can be scalars, vectors, time series, booleans, strings, or any JSON-serializable value.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nclass DopplerComputer(bh.AccessPropertyComputer):\n    '''Computes Doppler shift at window midtime.'''\n\n    def compute(self, window: bh.AccessWindow, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; dict:\n        '''\n        Args:\n            window (AccessWindow): AccessWindow with timing information\n            satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\n            location_ecef (ndarray): Location position [x,y,z] in ECEF (m)\n\n        Returns:\n            dict: Property name -&gt; value\n        '''\n        # Extract velocity\n        vx, vy, vz = satellite_state_ecef[3:6]\n\n        # Line-of-sight vector\n        sat_pos = satellite_state_ecef[:3]\n        los = location_ecef - sat_pos\n        los_unit = los / np.linalg.norm(los)\n\n        # Radial velocity\n        sat_vel = np.array([vx, vy, vz])\n        radial_velocity = np.dot(sat_vel, los_unit)\n\n        # Doppler shift (L-band)\n        freq_hz = 1.57542e9  # GPS L1\n        doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\n\n        return {\"doppler_shift\": doppler_hz}\n\n    def property_names(self) -&gt; list:\n        '''Return list of property names this computer produces.'''\n        return [\"doppler_shift\"]\n\n# Use with access computation (future)\ncomputer = DopplerComputer()\n# accesses = bh.compute_accesses(..., property_computers=[computer])\n</code></pre> Notes <ul> <li>The <code>compute</code> method receives ECEF coordinates in SI units (meters, m/s)</li> <li>Property values are automatically converted to appropriate Rust types</li> <li>The window parameter provides access to timing via:</li> <li><code>window.window_open</code>: Start epoch</li> <li><code>window.window_close</code>: End epoch</li> <li><code>window.midtime()</code>: Midpoint epoch</li> <li><code>window.duration()</code>: Duration in seconds</li> </ul> <p>Initialize instance.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Base class for custom access property computers.\\n\\nSubclass this class and implement the `compute` and `property_names` methods\\nto create custom property calculations that can be applied to access windows.\\n\\nThe compute method is called for each access window and should return a dictionary\\nof property names to values. Properties can be scalars, vectors, time series,\\nbooleans, strings, or any JSON-serializable value.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    class DopplerComputer(bh.AccessPropertyComputer):\\n        \\'\\'\\'Computes Doppler shift at window midtime.\\'\\'\\'\\n\\n        def compute(self, window: bh.AccessWindow, satellite_state_ecef: np.ndarray, location_ecef: np.ndarray) -&gt; dict:\\n            \\'\\'\\'\\n            Args:\\n                window (AccessWindow): AccessWindow with timing information\\n                satellite_state_ecef (ndarray): Satellite state [x,y,z,vx,vy,vz] in ECEF (m, m/s)\\n                location_ecef (ndarray): Location position [x,y,z] in ECEF (m)\\n\\n            Returns:\\n                dict: Property name -&gt; value\\n            \\'\\'\\'\\n            # Extract velocity\\n            vx, vy, vz = satellite_state_ecef[3:6]\\n\\n            # Line-of-sight vector\\n            sat_pos = satellite_state_ecef[:3]\\n            los = location_ecef - sat_pos\\n            los_unit = los / np.linalg.norm(los)\\n\\n            # Radial velocity\\n            sat_vel = np.array([vx, vy, vz])\\n            radial_velocity = np.dot(sat_vel, los_unit)\\n\\n            # Doppler shift (L-band)\\n            freq_hz = 1.57542e9  # GPS L1\\n            doppler_hz = -radial_velocity * freq_hz / bh.C_LIGHT\\n\\n            return {\"doppler_shift\": doppler_hz}\\n\\n        def property_names(self) -&gt; list:\\n            \\'\\'\\'Return list of property names this computer produces.\\'\\'\\'\\n            return [\"doppler_shift\"]\\n\\n    # Use with access computation (future)\\n    computer = DopplerComputer()\\n    # accesses = bh.compute_accesses(..., property_computers=[computer])\\n    ```\\n\\nNotes:\\n    - The `compute` method receives ECEF coordinates in SI units (meters, m/s)\\n    - Property values are automatically converted to appropriate Rust types\\n    - The window parameter provides access to timing via:\\n      - `window.window_open`: Start epoch\\n      - `window.window_close`: End epoch\\n      - `window.midtime()`: Midpoint epoch\\n      - `window.duration()`: Duration in seconds'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.compute","title":"compute  <code>method descriptor</code>","text":"<pre><code>compute(_window, _satellite_state_ecef, _location_ecef) -&gt; dict\n</code></pre> <p>Compute custom properties for an access window.</p> <p>Override this method in your subclass to implement custom property calculations.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>AccessWindow</code> <p>Access window with timing information</p> required <code>satellite_state_ecef</code> <code>ndarray</code> <p>Satellite state in ECEF [x,y,z,vx,vy,vz] (meters, m/s)</p> required <code>location_ecef</code> <code>ndarray</code> <p>Location position in ECEF [x,y,z] (meters)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary mapping property names (str) to values (scalar, list, dict, etc.)</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.property_names","title":"property_names  <code>method descriptor</code>","text":"<pre><code>property_names() -&gt; list[str]\n</code></pre> <p>Return list of property names this computer will produce.</p> <p>Override this method to return the list of property names that your compute() method will include in its returned dictionary.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of property names</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/constraints.html#brahe.AccessPropertyComputer.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/enums.html","title":"Access Enumerations","text":"<p>Enumeration types used in access computation.</p>"},{"location":"library_api/access/enums.html#lookdirection","title":"LookDirection","text":""},{"location":"library_api/access/enums.html#brahe.LookDirection","title":"LookDirection","text":"<pre><code>LookDirection()\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <code>Any</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <code>Any</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <code>Any</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = LookDirection.Either\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.LEFT","title":"LEFT  <code>class-attribute</code>","text":"<pre><code>LEFT: Any = LookDirection.Left\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.RIGHT","title":"RIGHT  <code>class-attribute</code>","text":"<pre><code>RIGHT: Any = LookDirection.Right\n</code></pre> <p>Look direction of a satellite relative to its velocity vector.</p> <p>Indicates whether a satellite is looking to the left (counterclockwise from velocity), right (clockwise from velocity), or either direction.</p> <p>This is commonly used for imaging satellites with side-looking sensors or SAR systems that have a preferred look direction.</p> <p>Attributes:</p> Name Type Description <code>LEFT</code> <p>Left-looking (counterclockwise from velocity vector)</p> <code>RIGHT</code> <p>Right-looking (clockwise from velocity vector)</p> <code>EITHER</code> <p>Either left or right is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for right-looking only satellites\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\n\n# Create a constraint accepting either direction\nconstraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\n\n# Compare look directions\nassert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\nassert bh.LookDirection.LEFT == bh.LookDirection.LEFT\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Look direction of a satellite relative to its velocity vector.\\n\\nIndicates whether a satellite is looking to the left (counterclockwise from velocity),\\nright (clockwise from velocity), or either direction.\\n\\nThis is commonly used for imaging satellites with side-looking sensors or SAR systems\\nthat have a preferred look direction.\\n\\nAttributes:\\n    LEFT: Left-looking (counterclockwise from velocity vector)\\n    RIGHT: Right-looking (clockwise from velocity vector)\\n    EITHER: Either left or right is acceptable\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a constraint for right-looking only satellites\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.RIGHT)\\n\\n    # Create a constraint accepting either direction\\n    constraint = bh.LookDirectionConstraint(allowed=bh.LookDirection.EITHER)\\n\\n    # Compare look directions\\n    assert bh.LookDirection.LEFT != bh.LookDirection.RIGHT\\n    assert bh.LookDirection.LEFT == bh.LookDirection.LEFT\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/enums.html#brahe.LookDirection.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/enums.html#ascdsc","title":"AscDsc","text":""},{"location":"library_api/access/enums.html#brahe.AscDsc","title":"AscDsc","text":"<pre><code>AscDsc()\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <code>Any</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <code>Any</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <code>Any</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.ASCENDING","title":"ASCENDING  <code>class-attribute</code>","text":"<pre><code>ASCENDING: Any = AscDsc.Ascending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.DESCENDING","title":"DESCENDING  <code>class-attribute</code>","text":"<pre><code>DESCENDING: Any = AscDsc.Descending\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.EITHER","title":"EITHER  <code>class-attribute</code>","text":"<pre><code>EITHER: Any = AscDsc.Either\n</code></pre> <p>Ascending or descending pass type for satellite orbits.</p> <p>Indicates whether a satellite is moving from south to north (ascending) or north to south (descending) in its orbit. This is determined by the sign of the Z-component of the velocity vector in ECEF coordinates.</p> <p>This is useful for: - Sun-synchronous orbits that prefer specific pass types - Minimizing lighting variation between passes - Coordinating multi-satellite observations</p> <p>Attributes:</p> Name Type Description <code>ASCENDING</code> <p>Satellite moving from south to north (vz &gt; 0 in ECEF)</p> <code>DESCENDING</code> <p>Satellite moving from north to south (vz &lt; 0 in ECEF)</p> <code>EITHER</code> <p>Either ascending or descending is acceptable</p> Example <pre><code>import brahe as bh\n\n# Create a constraint for ascending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\n\n# Create a constraint for descending passes only\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\n\n# Accept either type\nconstraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\n\n# Compare pass types\nassert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\nassert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\n</code></pre>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Ascending or descending pass type for satellite orbits.\\n\\nIndicates whether a satellite is moving from south to north (ascending) or\\nnorth to south (descending) in its orbit. This is determined by the sign of\\nthe Z-component of the velocity vector in ECEF coordinates.\\n\\nThis is useful for:\\n- Sun-synchronous orbits that prefer specific pass types\\n- Minimizing lighting variation between passes\\n- Coordinating multi-satellite observations\\n\\nAttributes:\\n    ASCENDING: Satellite moving from south to north (vz &gt; 0 in ECEF)\\n    DESCENDING: Satellite moving from north to south (vz &lt; 0 in ECEF)\\n    EITHER: Either ascending or descending is acceptable\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a constraint for ascending passes only\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.ASCENDING)\\n\\n    # Create a constraint for descending passes only\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.DESCENDING)\\n\\n    # Accept either type\\n    constraint = bh.AscDscConstraint(allowed=bh.AscDsc.EITHER)\\n\\n    # Compare pass types\\n    assert bh.AscDsc.ASCENDING != bh.AscDsc.DESCENDING\\n    assert bh.AscDsc.ASCENDING == bh.AscDsc.ASCENDING\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/enums.html#brahe.AscDsc.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html","title":"Locations","text":"<p>Location types represent ground positions or areas that satellites can access.</p>"},{"location":"library_api/access/locations.html#pointlocation","title":"PointLocation","text":""},{"location":"library_api/access/locations.html#brahe.PointLocation","title":"PointLocation","text":"<pre><code>PointLocation(lon: float, lat: float, alt: float)\n</code></pre> <p>A single point location on Earth's surface.</p> <p>Represents a discrete point with geodetic coordinates (longitude, latitude, altitude). Commonly used for ground stations, imaging targets, or tessellated polygon tiles.</p> <p>Parameters:</p> Name Type Description Default <code>lon</code> <code>float</code> <p>Longitude in degrees (-180 to 180)</p> required <code>lat</code> <code>float</code> <p>Latitude in degrees (-90 to 90)</p> required <code>alt</code> <code>float</code> <p>Altitude above ellipsoid in meters (default: 0.0)</p> required Example <pre><code>import brahe as bh\n\n# Create a ground station in Svalbard\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\n\n# With identity\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard Ground Station\") \\\\\n    .with_id(1)\n\n# With custom properties\nsvalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"min_elevation_deg\", 5.0)\n\n# Access coordinates as properties\nlon = svalbard.lon  # Property (always degrees)\nlat = svalbard.lat  # Property (always degrees)\nlat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'A single point location on Earth\\'s surface.\\n\\nRepresents a discrete point with geodetic coordinates (longitude, latitude, altitude).\\nCommonly used for ground stations, imaging targets, or tessellated polygon tiles.\\n\\nArgs:\\n    lon (float): Longitude in degrees (-180 to 180)\\n    lat (float): Latitude in degrees (-90 to 90)\\n    alt (float): Altitude above ellipsoid in meters (default: 0.0)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create a ground station in Svalbard\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0)\\n\\n    # With identity\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\\\\\\n        .with_name(\"Svalbard Ground Station\") \\\\\\\\\\n        .with_id(1)\\n\\n    # With custom properties\\n    svalbard = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\\\\\\n        .add_property(\"country\", \"Norway\") \\\\\\\\\\n        .add_property(\"min_elevation_deg\", 5.0)\\n\\n    # Access coordinates as properties\\n    lon = svalbard.lon  # Property (always degrees)\\n    lat = svalbard.lat  # Property (always degrees)\\n    lat_rad = svalbard.latitude(bh.AngleFormat.RADIANS)  # Method for format conversion\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nloc = bh.PointLocation(15.4, 78.2, 0.0)\n\n# Dict-style assignment\nloc.properties[\"climate\"] = \"Arctic\"\nloc.properties[\"country\"] = \"Norway\"\n\n# Dict-style access\nprint(loc.properties[\"climate\"])  # \"Arctic\"\n\n# Dict methods\nif \"country\" in loc.properties:\n    del loc.properties[\"country\"]\n\n# Iteration\nfor key in loc.properties.keys():\n    print(key, loc.properties[key])\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value) -&gt; PointLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .add_property(\"country\", \"Norway\") \\\\\n    .add_property(\"elevation_mask_deg\", 5.0)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PointLocation\n</code></pre> <p>Create from GeoJSON Point Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Point geometry</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>New location instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Point Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [15.4, 78.2, 0.0]\n    },\n    \"properties\": {\n        \"name\": \"Svalbard\"\n    }\n}\n\nlocation = bh.PointLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PointLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p> Example <pre><code>import brahe as bh\n\nlocation = bh.PointLocation(lon=15.4, lat=78.2, alt=0.0) \\\\\n    .with_name(\"Svalbard\")\n\ngeojson = location.to_geojson()\n# Returns:\n# {\n#     \"type\": \"Feature\",\n#     \"geometry\": {\n#         \"type\": \"Point\",\n#         \"coordinates\": [15.4, 78.2, 0.0]\n#     },\n#     \"properties\": {\n#         \"name\": \"Svalbard\"\n#     }\n# }\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PointLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PointLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PointLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PointLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PointLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PointLocation</code> <code>PointLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/locations.html#polygonlocation","title":"PolygonLocation","text":""},{"location":"library_api/access/locations.html#brahe.PolygonLocation","title":"PolygonLocation","text":"<pre><code>PolygonLocation(vertices: list[list[float]])\n</code></pre> <p>A polygonal area on Earth's surface.</p> <p>Represents a closed polygon with multiple vertices. Commonly used for areas of interest, no-fly zones, or imaging footprints.</p> <p>The polygon is automatically closed if the first and last vertices don't match.</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>list[list[float]]</code> <p>List of [lon, lat, alt] vertices in degrees and meters</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If polygon has fewer than 4 vertices or has validation errors</p> Example <pre><code>import brahe as bh\n\n# Define a rectangular area\nvertices = [\n    [10.0, 50.0, 0.0],  # lon, lat, alt\n    [11.0, 50.0, 0.0],\n    [11.0, 51.0, 0.0],\n    [10.0, 51.0, 0.0],\n    [10.0, 50.0, 0.0],  # Closed (first == last)\n]\npolygon = bh.PolygonLocation(vertices)\n\n# With identity\npolygon = bh.PolygonLocation(vertices) \\\\\n    .with_name(\"AOI-1\") \\\\\n    .add_property(\"region\", \"Europe\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'A polygonal area on Earth\\'s surface.\\n\\nRepresents a closed polygon with multiple vertices.\\nCommonly used for areas of interest, no-fly zones, or imaging footprints.\\n\\nThe polygon is automatically closed if the first and last vertices don\\'t match.\\n\\nArgs:\\n    vertices (list[list[float]]): List of [lon, lat, alt] vertices in degrees and meters\\n\\nRaises:\\n    ValueError: If polygon has fewer than 4 vertices or has validation errors\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Define a rectangular area\\n    vertices = [\\n        [10.0, 50.0, 0.0],  # lon, lat, alt\\n        [11.0, 50.0, 0.0],\\n        [11.0, 51.0, 0.0],\\n        [10.0, 51.0, 0.0],\\n        [10.0, 50.0, 0.0],  # Closed (first == last)\\n    ]\\n    polygon = bh.PolygonLocation(vertices)\\n\\n    # With identity\\n    polygon = bh.PolygonLocation(vertices) \\\\\\\\\\n        .with_name(\"AOI-1\") \\\\\\\\\\n        .add_property(\"region\", \"Europe\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.alt","title":"alt  <code>property</code>","text":"<pre><code>alt: float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lat","title":"lat  <code>property</code>","text":"<pre><code>lat: float\n</code></pre> <p>Get center latitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.lon","title":"lon  <code>property</code>","text":"<pre><code>lon: float\n</code></pre> <p>Get center longitude in degrees.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in degrees</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.num_vertices","title":"num_vertices  <code>property</code>","text":"<pre><code>num_vertices: int\n</code></pre> <p>Get number of unique vertices (excluding closure).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of unique vertices</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: PropertiesDict\n</code></pre> <p>Get custom properties dictionary.</p> <p>Returns:</p> Name Type Description <code>PropertiesDict</code> <code>PropertiesDict</code> <p>Dictionary-like wrapper for properties that supports assignment</p> Example <pre><code>import brahe as bh\n\nverts = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0], [0.0, 1.0, 0.0]]\npoly = bh.PolygonLocation(verts)\n\n# Dict-style assignment\npoly.properties[\"region\"] = \"Test Area\"\npoly.properties[\"area_km2\"] = 123.45\n\n# Dict-style access\nprint(poly.properties[\"region\"])  # \"Test Area\"\n\n# Dict methods\nif \"area_km2\" in poly.properties:\n    del poly.properties[\"area_km2\"]\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.vertices","title":"vertices  <code>property</code>","text":"<pre><code>vertices: ndarray\n</code></pre> <p>Get polygon vertices.</p> <p>Returns all vertices including the closure vertex (first == last).</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Vertices as Nx3 array [[lon, lat, alt], ...]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.add_property","title":"add_property  <code>method descriptor</code>","text":"<pre><code>add_property(key: str, value) -&gt; PolygonLocation\n</code></pre> <p>Add a custom property (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Property name</p> required <code>value</code> <p>Property value (must be JSON-serializable)</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.altitude","title":"altitude  <code>method descriptor</code>","text":"<pre><code>altitude() -&gt; float\n</code></pre> <p>Get center altitude in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center altitude in meters</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_ecef","title":"center_ecef  <code>method descriptor</code>","text":"<pre><code>center_ecef() -&gt; ndarray\n</code></pre> <p>Get center position in ECEF coordinates [x, y, z].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>ECEF position in meters [x, y, z]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.center_geodetic","title":"center_geodetic  <code>method descriptor</code>","text":"<pre><code>center_geodetic() -&gt; ndarray\n</code></pre> <p>Get center coordinates in geodetic format [lon, lat, alt].</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>Geodetic coordinates [longitude_deg, latitude_deg, altitude_m]</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.from_geojson","title":"from_geojson  <code>builtin</code>","text":"<pre><code>from_geojson(geojson: dict) -&gt; PolygonLocation\n</code></pre> <p>Create from GeoJSON Polygon Feature.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON Feature object with Polygon geometry</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>New polygon instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If GeoJSON is invalid or not a Polygon Feature</p> Example <pre><code>import brahe as bh\n\ngeojson = {\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [[\n            [10.0, 50.0, 0.0],\n            [11.0, 50.0, 0.0],\n            [11.0, 51.0, 0.0],\n            [10.0, 51.0, 0.0],\n            [10.0, 50.0, 0.0]\n        ]]\n    },\n    \"properties\": {\n        \"name\": \"AOI-1\"\n    }\n}\n\npolygon = bh.PolygonLocation.from_geojson(geojson)\n</code></pre>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID (mutating).</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_id","title":"get_id  <code>method descriptor</code>","text":"<pre><code>get_id() -&gt; int\n</code></pre> <p>Get the numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int | None: ID if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_name","title":"get_name  <code>method descriptor</code>","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: Name if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.get_uuid","title":"get_uuid  <code>method descriptor</code>","text":"<pre><code>get_uuid() -&gt; str\n</code></pre> <p>Get the UUID as a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>str | None: UUID string if set, None otherwise</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.latitude","title":"latitude  <code>method descriptor</code>","text":"<pre><code>latitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center latitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center latitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.longitude","title":"longitude  <code>method descriptor</code>","text":"<pre><code>longitude(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get center longitude with angle format conversion.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Desired output format (DEGREES or RADIANS)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Center longitude in specified format</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int | None) -&gt; Any\n</code></pre> <p>Set the numeric ID (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int | None</code> <p>ID to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str | None) -&gt; Any\n</code></pre> <p>Set the name (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Name to set, or None to clear</p> required"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.to_geojson","title":"to_geojson  <code>method descriptor</code>","text":"<pre><code>to_geojson() -&gt; dict\n</code></pre> <p>Export to GeoJSON Feature format.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>GeoJSON Feature object</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; PolygonLocation\n</code></pre> <p>Set the numeric ID (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric identifier</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; PolygonLocation\n</code></pre> <p>Set the name (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Human-readable name</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; PolygonLocation\n</code></pre> <p>Generate a new UUID (builder pattern).</p> <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p>"},{"location":"library_api/access/locations.html#brahe.PolygonLocation.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; PolygonLocation\n</code></pre> <p>Set the UUID from a string (builder pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string</p> required <p>Returns:</p> Name Type Description <code>PolygonLocation</code> <code>PolygonLocation</code> <p>Self for chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If UUID string is invalid</p>"},{"location":"library_api/access/windows.html","title":"Access Windows","text":"<p>Access windows represent time periods when satellites can access ground locations.</p>"},{"location":"library_api/access/windows.html#accesswindow","title":"AccessWindow","text":""},{"location":"library_api/access/windows.html#brahe.AccessWindow","title":"AccessWindow","text":"<pre><code>AccessWindow(window_open: Epoch, window_close: Epoch)\n</code></pre> <p>An access window representing a period of time when access constraints are satisfied.</p> <p>AccessWindow stores the opening and closing times of an access period, along with computed properties for that window.</p> <p>Parameters:</p> Name Type Description Default <code>window_open</code> <code>Epoch</code> <p>Opening time of the access window</p> required <code>window_close</code> <code>Epoch</code> <p>Closing time of the access window</p> required Example <pre><code>import brahe as bh\n\n# Create an access window\nt_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\nt_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\nwindow = bh.AccessWindow(t_open, t_close)\n\n# Access window properties\nprint(f\"Duration: {window.duration()} seconds\")\nprint(f\"Midpoint: {window.midtime()}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'An access window representing a period of time when access constraints are satisfied.\\n\\nAccessWindow stores the opening and closing times of an access period, along with\\ncomputed properties for that window.\\n\\nArgs:\\n    window_open (Epoch): Opening time of the access window\\n    window_close (Epoch): Closing time of the access window\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create an access window\\n    t_open = bh.Epoch(2024, 1, 1, 12, 0, 0.0)\\n    t_close = bh.Epoch(2024, 1, 1, 12, 10, 0.0)\\n    window = bh.AccessWindow(t_open, t_close)\\n\\n    # Access window properties\\n    print(f\"Duration: {window.duration()} seconds\")\\n    print(f\"Midpoint: {window.midtime()}\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: AscDsc\n</code></pre> <p>Get ascending/descending pass type.</p> <p>Returns:</p> Name Type Description <code>AscDsc</code> <code>AscDsc</code> <p>Pass type enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: float\n</code></pre> <p>Get azimuth angle at window closing (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window close</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: float\n</code></pre> <p>Get azimuth angle at window opening (degrees, 0-360).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Azimuth at window open</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Get the duration of the access window in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Duration in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: float\n</code></pre> <p>Get maximum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: float\n</code></pre> <p>Get minimum elevation angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum elevation angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.end","title":"end  <code>property</code>","text":"<pre><code>end: Epoch\n</code></pre> <p>Get the end time of the access window (alias for window_close).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Closing time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.id","title":"id  <code>property</code>","text":"<pre><code>id: Optional[int]\n</code></pre> <p>Get the access window numeric ID.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: Window ID, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: float\n</code></pre> <p>Get local solar time at window midpoint (seconds since midnight, 0-86400).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Local time in seconds</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_id","title":"location_id  <code>property</code>","text":"<pre><code>location_id: Optional[int]\n</code></pre> <p>Get the location ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_name","title":"location_name  <code>property</code>","text":"<pre><code>location_name: Optional[str]\n</code></pre> <p>Get the location name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the location, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.location_uuid","title":"location_uuid  <code>property</code>","text":"<pre><code>location_uuid: Optional[str]\n</code></pre> <p>Get the location UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the location as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: LookDirection\n</code></pre> <p>Get look direction (Left or Right).</p> <p>Returns:</p> Name Type Description <code>LookDirection</code> <code>LookDirection</code> <p>Look direction enum value</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.midtime","title":"midtime  <code>property</code>","text":"<pre><code>midtime: Epoch\n</code></pre> <p>Get the midpoint time of the access window.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Midpoint time (average of start and end)</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.name","title":"name  <code>property</code>","text":"<pre><code>name: Optional[str]\n</code></pre> <p>Get the access window name (auto-generated or user-set).</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Window name, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: float\n</code></pre> <p>Get maximum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: float\n</code></pre> <p>Get minimum off-nadir angle during access (degrees).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum off-nadir angle</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.properties","title":"properties  <code>property</code>","text":"<pre><code>properties: AccessProperties\n</code></pre> <p>Get the access properties object.</p> <p>Returns:</p> Name Type Description <code>AccessProperties</code> <code>AccessProperties</code> <p>Computed properties for this access window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_id","title":"satellite_id  <code>property</code>","text":"<pre><code>satellite_id: Optional[int]\n</code></pre> <p>Get the satellite/object ID if available.</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: ID of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: Optional[str]\n</code></pre> <p>Get the satellite/object name if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of the satellite, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.satellite_uuid","title":"satellite_uuid  <code>property</code>","text":"<pre><code>satellite_uuid: Optional[str]\n</code></pre> <p>Get the satellite UUID if available.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID of the satellite as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.start","title":"start  <code>property</code>","text":"<pre><code>start: Epoch\n</code></pre> <p>Get the start time of the access window (alias for window_open).</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Opening time of the window</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: Optional[str]\n</code></pre> <p>Get the access window UUID.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: UUID as string, or None if not set</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_close","title":"window_close  <code>property</code>","text":"<pre><code>window_close: Epoch\n</code></pre> <p>Get the window closing time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window closing time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.window_open","title":"window_open  <code>property</code>","text":"<pre><code>window_open: Epoch\n</code></pre> <p>Get the window opening time.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Window opening time</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/windows.html#brahe.AccessWindow.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/access/windows.html#accessproperties","title":"AccessProperties","text":""},{"location":"library_api/access/windows.html#brahe.AccessProperties","title":"AccessProperties","text":"<pre><code>AccessProperties()\n</code></pre> <p>Properties computed for an access window.</p> <p>AccessProperties contains geometric properties (azimuth, elevation, off-nadir angles, local time, look direction, ascending/descending) computed over an access window, plus a dictionary of additional custom properties.</p> <p>Attributes:</p> Name Type Description <code>azimuth_open</code> <code>float</code> <p>Azimuth angle at window opening (degrees, 0-360)</p> <code>azimuth_close</code> <code>float</code> <p>Azimuth angle at window closing (degrees, 0-360)</p> <code>elevation_min</code> <code>float</code> <p>Minimum elevation angle (degrees)</p> <code>elevation_max</code> <code>float</code> <p>Maximum elevation angle (degrees)</p> <code>off_nadir_min</code> <code>float</code> <p>Minimum off-nadir angle (degrees)</p> <code>off_nadir_max</code> <code>float</code> <p>Maximum off-nadir angle (degrees)</p> <code>local_time</code> <code>float</code> <p>Local solar time (seconds since midnight, 0-86400)</p> <code>look_direction</code> <code>LookDirection</code> <p>Required look direction (Left or Right)</p> <code>asc_dsc</code> <code>AscDsc</code> <p>Pass type (Ascending or Descending)</p> Example <pre><code>import brahe as bh\n\n# Access properties are typically computed by the access computation system\n# This example shows accessing the properties\nprops = ...  # From access computation\n\nprint(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\nprint(f\"Max elevation: {props.elevation_max}\u00b0\")\nprint(f\"Look direction: {props.look_direction}\")\n\n# Access additional custom properties\nif \"signal_strength\" in props.additional:\n    print(f\"Signal: {props.additional['signal_strength']}\")\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Properties computed for an access window.\\n\\nAccessProperties contains geometric properties (azimuth, elevation, off-nadir angles,\\nlocal time, look direction, ascending/descending) computed over an access window,\\nplus a dictionary of additional custom properties.\\n\\nAttributes:\\n    azimuth_open (float): Azimuth angle at window opening (degrees, 0-360)\\n    azimuth_close (float): Azimuth angle at window closing (degrees, 0-360)\\n    elevation_min (float): Minimum elevation angle (degrees)\\n    elevation_max (float): Maximum elevation angle (degrees)\\n    off_nadir_min (float): Minimum off-nadir angle (degrees)\\n    off_nadir_max (float): Maximum off-nadir angle (degrees)\\n    local_time (float): Local solar time (seconds since midnight, 0-86400)\\n    look_direction (LookDirection): Required look direction (Left or Right)\\n    asc_dsc (AscDsc): Pass type (Ascending or Descending)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Access properties are typically computed by the access computation system\\n    # This example shows accessing the properties\\n    props = ...  # From access computation\\n\\n    print(f\"Azimuth at open: {props.azimuth_open}\u00b0\")\\n    print(f\"Max elevation: {props.elevation_max}\u00b0\")\\n    print(f\"Look direction: {props.look_direction}\")\\n\\n    # Access additional custom properties\\n    if \"signal_strength\" in props.additional:\\n        print(f\"Signal: {props.additional[\\'signal_strength\\']}\")\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.additional","title":"additional  <code>property</code>","text":"<pre><code>additional: AdditionalPropertiesDict\n</code></pre> <p>Get additional properties as a dict-like wrapper.</p> <p>Returns a dictionary-like object that automatically converts between Python types and internal PropertyValue representation.</p> <p>Supported Python types: - float -&gt; Scalar - list[float] -&gt; Vector - bool -&gt; Boolean - str -&gt; String - dict -&gt; Json</p> <p>Returns:</p> Name Type Description <code>AdditionalPropertiesDict</code> <code>AdditionalPropertiesDict</code> <p>Dict-like wrapper for additional properties</p> Example <pre><code># Dict-style assignment\nprops.additional[\"doppler_shift\"] = 2500.0\nprops.additional[\"snr_values\"] = [10.5, 12.3, 15.1]\nprops.additional[\"has_eclipse\"] = False\n\n# Dict-style access\nprint(props.additional[\"doppler_shift\"])  # 2500.0\n\n# Dict methods\nif \"doppler_shift\" in props.additional:\n    del props.additional[\"doppler_shift\"]\n\n# Iteration\nfor key in props.additional.keys():\n    print(key, props.additional[key])\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.asc_dsc","title":"asc_dsc  <code>property</code>","text":"<pre><code>asc_dsc: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_close","title":"azimuth_close  <code>property</code>","text":"<pre><code>azimuth_close: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.azimuth_open","title":"azimuth_open  <code>property</code>","text":"<pre><code>azimuth_open: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_max","title":"elevation_max  <code>property</code>","text":"<pre><code>elevation_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.elevation_min","title":"elevation_min  <code>property</code>","text":"<pre><code>elevation_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.local_time","title":"local_time  <code>property</code>","text":"<pre><code>local_time: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.look_direction","title":"look_direction  <code>property</code>","text":"<pre><code>look_direction: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_max","title":"off_nadir_max  <code>property</code>","text":"<pre><code>off_nadir_max: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.off_nadir_min","title":"off_nadir_min  <code>property</code>","text":"<pre><code>off_nadir_min: Any\n</code></pre>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/access/windows.html#brahe.AccessProperties.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/index.html","title":"Attitude","text":"<p>Module: <code>brahe.attitude</code></p> <p>Classes for representing and converting between different attitude representations.</p>"},{"location":"library_api/attitude/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Quaternion - Quaternion representation</li> <li>Rotation Matrix - Direction Cosine Matrix (DCM) representation</li> <li>Euler Angles - Euler angle sequences</li> <li>Euler Axis - Euler axis-angle representation</li> </ul>"},{"location":"library_api/attitude/euler_angles.html","title":"EulerAngle Class","text":"<p>The <code>EulerAngle</code> class represents attitude using Euler angle sequences for intuitive spacecraft orientation specification.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle","title":"EulerAngle","text":"<pre><code>EulerAngle(order: str, phi: float, theta: float, psi: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler angles.</p> <p>Euler angles describe rotations as a sequence of three rotations about specified axes. The rotation sequence is specified by the order parameter (e.g., \"XYZ\", \"ZYX\").</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")</p> required <code>phi</code> <code>float</code> <p>First rotation angle in radians or degrees</p> required <code>theta</code> <code>float</code> <p>Second rotation angle in radians or degrees</p> required <code>psi</code> <code>float</code> <p>Third rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\n\n# Create Euler angle rotation (roll, pitch, yaw in ZYX order)\ne = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n\n# Convert to rotation matrix\ndcm = e.to_rotation_matrix()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler angles.\\n\\nEuler angles describe rotations as a sequence of three rotations about\\nspecified axes. The rotation sequence is specified by the order parameter\\n(e.g., \"XYZ\", \"ZYX\").\\n\\nArgs:\\n    order (str): Rotation sequence (e.g., \"XYZ\", \"ZYX\", \"ZXZ\")\\n    phi (float): First rotation angle in radians or degrees\\n    theta (float): Second rotation angle in radians or degrees\\n    psi (float): Third rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angles (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create Euler angle rotation (roll, pitch, yaw in ZYX order)\\n    e = bh.EulerAngle(\"ZYX\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\\n    print(f\"Roll={e.phi}, Pitch={e.theta}, Yaw={e.psi}\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n\\n    # Convert to rotation matrix\\n    dcm = e.to_rotation_matrix()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.order","title":"order  <code>property</code>","text":"<pre><code>order: str\n</code></pre> <p>Get the rotation sequence order.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Order: {e.order}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.phi","title":"phi  <code>property</code>","text":"<pre><code>phi: float\n</code></pre> <p>Get the first rotation angle (phi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>First rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Phi: {e.phi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.psi","title":"psi  <code>property</code>","text":"<pre><code>psi: float\n</code></pre> <p>Get the third rotation angle (psi) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Third rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Psi: {e.psi}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.theta","title":"theta  <code>property</code>","text":"<pre><code>theta: float\n</code></pre> <p>Get the second rotation angle (theta) in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Second rotation angle in radians</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nprint(f\"Theta: {e.theta}\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from another Euler angle with different order.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Source Euler angles</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAngle.from_euler_angle(e1, \"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = bh.EulerAngle.from_euler_axis(ea, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAngle.from_quaternion(q, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix, order: str) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAngle.from_rotation_matrix(r, \"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, order: str, angle_format: AngleFormat) -&gt; EulerAngle\n</code></pre> <p>Create Euler angles from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>3-element array [phi, theta, psi]</p> required <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angles (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>New Euler angle instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.1, 0.2, 0.3])\neuler = bh.EulerAngle.from_vector(v, \"XYZ\", bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angles with different rotation sequence.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles with new order</p> Example <pre><code>import brahe as bh\n\ne1 = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_angle(\"ZYX\")\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nea = e.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_angles.html#brahe._brahe.EulerAngle.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html","title":"EulerAxis Class","text":"<p>The <code>EulerAxis</code> class represents attitude using axis-angle representation (Euler's rotation theorem).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis","title":"EulerAxis","text":"<pre><code>EulerAxis(axis: ndarray, angle: float, angle_format: AngleFormat)\n</code></pre> <p>Represents a rotation using Euler axis-angle representation.</p> <p>The Euler axis-angle representation describes a rotation as a single rotation about a specified axis by a given angle. This is also known as the axis-angle or rotation vector representation.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>ndarray</code> <p>3-element unit vector specifying rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Rotation of 90 degrees about z-axis\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle} rad\")\n\n# Convert to quaternion\nq = e.to_quaternion()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using Euler axis-angle representation.\\n\\nThe Euler axis-angle representation describes a rotation as a single rotation\\nabout a specified axis by a given angle. This is also known as the axis-angle\\nor rotation vector representation.\\n\\nArgs:\\n    axis (numpy.ndarray): 3-element unit vector specifying rotation axis\\n    angle (float): Rotation angle in radians or degrees\\n    angle_format (AngleFormat): Units of input angle (RADIANS or DEGREES)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Rotation of 90 degrees about z-axis\\n    axis = np.array([0.0, 0.0, 1.0])\\n    e = bh.EulerAxis(axis, np.pi/2, bh.AngleFormat.RADIANS)\\n    print(f\"Angle: {e.angle} rad\")\\n\\n    # Convert to quaternion\\n    q = e.to_quaternion()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.angle","title":"angle  <code>property</code>","text":"<pre><code>angle: float\n</code></pre> <p>Get the rotation angle in radians.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Rotation angle in radians</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Angle: {e.angle}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.axis","title":"axis  <code>property</code>","text":"<pre><code>axis: ndarray\n</code></pre> <p>Get the rotation axis as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3-element unit vector specifying rotation axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nprint(f\"Axis: {e.axis}\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\ne = bh.EulerAxis.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from another Euler axis (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Source Euler axis</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = bh.EulerAxis.from_euler_axis(e1)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\ne = bh.EulerAxis.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = bh.EulerAxis.from_rotation_matrix(r)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(x: float, y: float, z: float, angle: float, angle_format: AngleFormat) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from individual axis components and angle.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X component of rotation axis</p> required <code>y</code> <code>float</code> <p>Y component of rotation axis</p> required <code>z</code> <code>float</code> <p>Z component of rotation axis</p> required <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\n\ne = bh.EulerAxis.from_values(0.0, 0.0, 1.0, 1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, angle_format: AngleFormat, vector_first: bool) -&gt; EulerAxis\n</code></pre> <p>Create an Euler axis from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing axis and angle</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, array is [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>New Euler axis instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([0.0, 0.0, 1.0, 1.5708])\ne = bh.EulerAxis.from_vector(v, bh.AngleFormat.RADIANS, True)\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne = ea.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation (returns self).</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>This Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne1 = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\ne2 = e1.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = e.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\ne = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = e.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/attitude/euler_axis.html#brahe._brahe.EulerAxis.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(angle_format: AngleFormat, vector_first: bool) -&gt; ndarray\n</code></pre> <p>Convert Euler axis to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Units for output angle (RADIANS or DEGREES)</p> required <code>vector_first</code> <code>bool</code> <p>If True, returns [x, y, z, angle], else [angle, x, y, z]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing axis and angle</p>"},{"location":"library_api/attitude/quaternion.html","title":"Quaternion Class","text":"<p>The <code>Quaternion</code> class provides a compact, singularity-free representation of 3D rotations for spacecraft attitude determination and control.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion","title":"Quaternion","text":"<pre><code>Quaternion(w: float, x: float, y: float, z: float)\n</code></pre> <p>Represents a quaternion for 3D rotations.</p> <p>Quaternions provide a compact, singularity-free representation of rotations. The quaternion is stored as [w, x, y, z] where w is the scalar part and [x, y, z] is the vector part.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Scalar component</p> required <code>x</code> <code>float</code> <p>X component of vector part</p> required <code>y</code> <code>float</code> <p>Y component of vector part</p> required <code>z</code> <code>float</code> <p>Z component of vector part</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity quaternion\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nprint(f\"Norm: {q.norm()}\")\n\n# Create from array\nq_vec = np.array([1.0, 0.0, 0.0, 0.0])\nq2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\n\n# Convert to rotation matrix\ndcm = q.to_rotation_matrix()\n\n# Quaternion multiplication\nq3 = q * q2\n\n# Normalize\nq3.normalize()\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a quaternion for 3D rotations.\\n\\nQuaternions provide a compact, singularity-free representation of rotations.\\nThe quaternion is stored as [w, x, y, z] where w is the scalar part and\\n[x, y, z] is the vector part.\\n\\nArgs:\\n    w (float): Scalar component\\n    x (float): X component of vector part\\n    y (float): Y component of vector part\\n    z (float): Z component of vector part\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity quaternion\\n    q = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\\n    print(f\"Norm: {q.norm()}\")\\n\\n    # Create from array\\n    q_vec = np.array([1.0, 0.0, 0.0, 0.0])\\n    q2 = bh.Quaternion.from_vector(q_vec, scalar_first=True)\\n\\n    # Convert to rotation matrix\\n    dcm = q.to_rotation_matrix()\\n\\n    # Quaternion multiplication\\n    q3 = q * q2\\n\\n    # Normalize\\n    q3.normalize()\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.data","title":"data  <code>property</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Get the quaternion components as a numpy array [w, x, y, z].</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.conjugate","title":"conjugate  <code>method descriptor</code>","text":"<pre><code>conjugate() -&gt; Quaternion\n</code></pre> <p>Compute the conjugate of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Conjugate quaternion with negated vector part</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_conj = q.conjugate()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from an Euler axis representation.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nq = bh.Quaternion.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from another quaternion (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion.from_quaternion(q1)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a rotation matrix.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nrm = bh.RotationMatrix.from_matrix(mat)\nq = bh.Quaternion.from_rotation_matrix(rm)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.from_vector","title":"from_vector  <code>builtin</code>","text":"<pre><code>from_vector(v: ndarray, scalar_first: bool) -&gt; Quaternion\n</code></pre> <p>Create a quaternion from a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>ndarray</code> <p>4-element array containing quaternion components</p> required <code>scalar_first</code> <code>bool</code> <p>If True, array is [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>New quaternion instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nv = np.array([1.0, 0.0, 0.0, 0.0])\nq = bh.Quaternion.from_vector(v, scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.inverse","title":"inverse  <code>method descriptor</code>","text":"<pre><code>inverse() -&gt; Quaternion\n</code></pre> <p>Compute the inverse of the quaternion.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Inverse quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq_inv = q.inverse()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.norm","title":"norm  <code>method descriptor</code>","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Calculate the norm (magnitude) of the quaternion.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Euclidean norm of the quaternion</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nnorm = q.norm()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.normalize","title":"normalize  <code>method descriptor</code>","text":"<pre><code>normalize() -&gt; Any\n</code></pre> <p>Normalize the quaternion in-place to unit length.</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(2.0, 0.0, 0.0, 0.0)\nq.normalize()\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.slerp","title":"slerp  <code>method descriptor</code>","text":"<pre><code>slerp(other: Quaternion, t: float) -&gt; Quaternion\n</code></pre> <p>Perform spherical linear interpolation (SLERP) between two quaternions.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Quaternion</code> <p>Target quaternion</p> required <code>t</code> <code>float</code> <p>Interpolation parameter in [0, 1]</p> required <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Interpolated quaternion</p> Example <pre><code>import brahe as bh\n\nq1 = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nq2 = bh.Quaternion(0.707, 0.707, 0.0, 0.0)\nq_mid = q1.slerp(q2, 0.5)\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\neuler = q.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation (returns self).</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>This quaternion</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation.</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p>"},{"location":"library_api/attitude/quaternion.html#brahe._brahe.Quaternion.to_vector","title":"to_vector  <code>method descriptor</code>","text":"<pre><code>to_vector(scalar_first: bool) -&gt; ndarray\n</code></pre> <p>Convert quaternion to a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>scalar_first</code> <code>bool</code> <p>If True, returns [w, x, y, z], else [x, y, z, w]</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 4-element array containing quaternion components</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nv = q.to_vector(scalar_first=True)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html","title":"RotationMatrix Class","text":"<p>The <code>RotationMatrix</code> class represents attitude using Direction Cosine Matrices (DCM) for spacecraft orientation and coordinate transformations.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix","title":"RotationMatrix","text":"<pre><code>RotationMatrix(r11: float, r12: float, r13: float, r21: float, r22: float, r23: float, r31: float, r32: float, r33: float)\n</code></pre> <p>Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).</p> <p>A rotation matrix is an orthogonal 3x3 matrix with determinant +1 that represents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).</p> <p>Parameters:</p> Name Type Description Default <code>r11</code> <code>float</code> <p>Element at row 1, column 1</p> required <code>r12</code> <code>float</code> <p>Element at row 1, column 2</p> required <code>r13</code> <code>float</code> <p>Element at row 1, column 3</p> required <code>r21</code> <code>float</code> <p>Element at row 2, column 1</p> required <code>r22</code> <code>float</code> <p>Element at row 2, column 2</p> required <code>r23</code> <code>float</code> <p>Element at row 2, column 3</p> required <code>r31</code> <code>float</code> <p>Element at row 3, column 1</p> required <code>r32</code> <code>float</code> <p>Element at row 3, column 2</p> required <code>r33</code> <code>float</code> <p>Element at row 3, column 3</p> required <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create identity rotation\ndcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\n\n# Create from numpy array\nR = np.eye(3)\ndcm2 = bh.RotationMatrix.from_matrix(R)\n\n# Convert to quaternion\nq = dcm.to_quaternion()\n\n# Rotate a vector\nv = np.array([1.0, 0.0, 0.0])\nv_rot = dcm.rotate_vector(v)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a rotation using a 3x3 rotation matrix (Direction Cosine Matrix).\\n\\nA rotation matrix is an orthogonal 3x3 matrix with determinant +1 that\\nrepresents rotation in 3D space. Also known as a Direction Cosine Matrix (DCM).\\n\\nArgs:\\n    r11 (float): Element at row 1, column 1\\n    r12 (float): Element at row 1, column 2\\n    r13 (float): Element at row 1, column 3\\n    r21 (float): Element at row 2, column 1\\n    r22 (float): Element at row 2, column 2\\n    r23 (float): Element at row 2, column 3\\n    r31 (float): Element at row 3, column 1\\n    r32 (float): Element at row 3, column 2\\n    r33 (float): Element at row 3, column 3\\n\\nRaises:\\n    BraheError: If the matrix is not a valid rotation matrix\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Create identity rotation\\n    dcm = bh.RotationMatrix(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)\\n\\n    # Create from numpy array\\n    R = np.eye(3)\\n    dcm2 = bh.RotationMatrix.from_matrix(R)\\n\\n    # Convert to quaternion\\n    q = dcm.to_quaternion()\\n\\n    # Rotate a vector\\n    v = np.array([1.0, 0.0, 0.0])\\n    v_rot = dcm.rotate_vector(v)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rx","title":"Rx  <code>builtin</code>","text":"<pre><code>Rx(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the X axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for X-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Ry","title":"Ry  <code>builtin</code>","text":"<pre><code>Ry(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Y axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Y-axis rotation</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.Rz","title":"Rz  <code>builtin</code>","text":"<pre><code>Rz(angle: float, angle_format: AngleFormat) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix for rotation about the Z axis.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians or degrees</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Units of input angle (RADIANS or DEGREES)</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Rotation matrix for Z-axis rotation</p> Example <pre><code>import brahe as bh\n\nr = bh.RotationMatrix.Rz(1.5708, bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__imul__","title":"__imul__  <code>method descriptor</code>","text":"<pre><code>__imul__(value)\n</code></pre> <p>Return self*=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__mul__","title":"__mul__  <code>method descriptor</code>","text":"<pre><code>__mul__(value)\n</code></pre> <p>Return self*value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__rmul__","title":"__rmul__  <code>method descriptor</code>","text":"<pre><code>__rmul__(value)\n</code></pre> <p>Return value*self.</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_angle","title":"from_euler_angle  <code>builtin</code>","text":"<pre><code>from_euler_angle(e: EulerAngle) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from Euler angles.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAngle</code> <p>Euler angle representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\neuler = bh.EulerAngle(\"XYZ\", 0.1, 0.2, 0.3, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_angle(euler)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_euler_axis","title":"from_euler_axis  <code>builtin</code>","text":"<pre><code>from_euler_axis(e: EulerAxis) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from an Euler axis.</p> <p>Parameters:</p> Name Type Description Default <code>e</code> <code>EulerAxis</code> <p>Euler axis representation</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\naxis = np.array([0.0, 0.0, 1.0])\nea = bh.EulerAxis(axis, 1.5708, bh.AngleFormat.RADIANS)\nr = bh.RotationMatrix.from_euler_axis(ea)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_matrix","title":"from_matrix  <code>builtin</code>","text":"<pre><code>from_matrix(m: ndarray) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a 3x3 numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>ndarray</code> <p>3x3 rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> <p>Raises:</p> Type Description <code>BraheError</code> <p>If the matrix is not a valid rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nmat = np.eye(3)\nr = bh.RotationMatrix.from_matrix(mat)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_quaternion","title":"from_quaternion  <code>builtin</code>","text":"<pre><code>from_quaternion(q: Quaternion) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from a quaternion.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>Quaternion</code> <p>Source quaternion</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>Equivalent rotation matrix</p> Example <pre><code>import brahe as bh\n\nq = bh.Quaternion(1.0, 0.0, 0.0, 0.0)\nr = bh.RotationMatrix.from_quaternion(q)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.from_rotation_matrix","title":"from_rotation_matrix  <code>builtin</code>","text":"<pre><code>from_rotation_matrix(r: RotationMatrix) -&gt; RotationMatrix\n</code></pre> <p>Create a rotation matrix from another rotation matrix (copy constructor).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>RotationMatrix</code> <p>Source rotation matrix</p> required <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>New rotation matrix instance</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = bh.RotationMatrix.from_rotation_matrix(r1)\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_angle","title":"to_euler_angle  <code>method descriptor</code>","text":"<pre><code>to_euler_angle(order: str) -&gt; EulerAngle\n</code></pre> <p>Convert to Euler angle representation.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>str</code> <p>Desired rotation sequence (e.g., \"XYZ\", \"ZYX\")</p> required <p>Returns:</p> Name Type Description <code>EulerAngle</code> <code>EulerAngle</code> <p>Equivalent Euler angles</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\neuler = r.to_euler_angle(\"XYZ\")\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_euler_axis","title":"to_euler_axis  <code>method descriptor</code>","text":"<pre><code>to_euler_axis() -&gt; EulerAxis\n</code></pre> <p>Convert to Euler axis representation.</p> <p>Returns:</p> Name Type Description <code>EulerAxis</code> <code>EulerAxis</code> <p>Equivalent Euler axis</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\ne = r.to_euler_axis()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert rotation matrix to a 3x3 numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 3x3 rotation matrix</p>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_quaternion","title":"to_quaternion  <code>method descriptor</code>","text":"<pre><code>to_quaternion() -&gt; Quaternion\n</code></pre> <p>Convert to quaternion representation.</p> <p>Returns:</p> Name Type Description <code>Quaternion</code> <code>Quaternion</code> <p>Equivalent quaternion</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr = bh.RotationMatrix.from_array(np.eye(3))\nq = r.to_quaternion()\n</code></pre>"},{"location":"library_api/attitude/rotation_matrix.html#brahe._brahe.RotationMatrix.to_rotation_matrix","title":"to_rotation_matrix  <code>method descriptor</code>","text":"<pre><code>to_rotation_matrix() -&gt; RotationMatrix\n</code></pre> <p>Convert to rotation matrix representation (returns self).</p> <p>Returns:</p> Name Type Description <code>RotationMatrix</code> <code>RotationMatrix</code> <p>This rotation matrix</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nr1 = bh.RotationMatrix.from_array(np.eye(3))\nr2 = r1.to_rotation_matrix()\n</code></pre>"},{"location":"library_api/constants/index.html","title":"Constants","text":"<p>Mathematical, physical, and astronomical constants used throughout the brahe library.</p>"},{"location":"library_api/constants/index.html#categories","title":"Categories","text":""},{"location":"library_api/constants/index.html#units","title":"Units","text":"<p>Angle format enumerations and time system constants for specifying units and reference frames.</p>"},{"location":"library_api/constants/index.html#mathematical-constants","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/index.html#time-constants","title":"Time Constants","text":"<p>Julian date references and time system offset values.</p>"},{"location":"library_api/constants/index.html#physical-constants","title":"Physical Constants","text":"<p>Physical properties of Earth, celestial bodies, and universal constants.</p>"},{"location":"library_api/constants/index.html#quick-reference","title":"Quick Reference","text":"<p>All constants use SI base units unless otherwise noted:</p> <ul> <li>Distance: meters (m)</li> <li>Time: seconds (s)</li> <li>Angles: radians (rad)</li> <li>Gravitational Parameter: m\u00b3/s\u00b2</li> </ul> <p>Constants are accessible directly from the <code>brahe</code> module:</p> <pre><code>import brahe as bh\n\n# Mathematical constants\nangle_rad = 45.0 * bh.DEG2RAD  # Convert degrees to radians\n\n# Physical constants\nmu_earth = bh.GM_EARTH  # Earth's gravitational parameter\nc = bh.C_LIGHT          # Speed of light\n\n# Time system\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n</code></pre>"},{"location":"library_api/constants/math.html","title":"Mathematical Constants","text":"<p>Conversion factors for angles and other mathematical operations.</p>"},{"location":"library_api/constants/math.html#angle-conversions","title":"Angle Conversions","text":""},{"location":"library_api/constants/math.html#deg2rad","title":"DEG2RAD","text":"<p>Value: <code>0.017453292519943295</code> rad/deg</p> <p>Converts degrees to radians. Equivalent to \u03c0/180.</p>"},{"location":"library_api/constants/math.html#brahe.DEG2RAD","title":"DEG2RAD  <code>module-attribute</code>","text":"<pre><code>DEG2RAD: float = 0.017453292519943295\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2deg","title":"RAD2DEG","text":"<p>Value: <code>57.29577951308232</code> deg/rad</p> <p>Converts radians to degrees. Equivalent to 180/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2DEG","title":"RAD2DEG  <code>module-attribute</code>","text":"<pre><code>RAD2DEG: float = 57.29577951308232\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#as2rad","title":"AS2RAD","text":"<p>Value: <code>4.84813681109536e-06</code> rad/arcsec</p> <p>Converts arc seconds to radians. Equivalent to \u03c0/(180 \u00d7 3600).</p>"},{"location":"library_api/constants/math.html#brahe.AS2RAD","title":"AS2RAD  <code>module-attribute</code>","text":"<pre><code>AS2RAD: float = 4.84813681109536e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/math.html#rad2as","title":"RAD2AS","text":"<p>Value: <code>206264.80624709636</code> arcsec/rad</p> <p>Converts radians to arc seconds. Equivalent to (180 \u00d7 3600)/\u03c0.</p>"},{"location":"library_api/constants/math.html#brahe.RAD2AS","title":"RAD2AS  <code>module-attribute</code>","text":"<pre><code>RAD2AS: float = 206264.80624709636\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html","title":"Physical Constants","text":"<p>Physical properties of celestial bodies and universal constants. All values use SI base units.</p>"},{"location":"library_api/constants/physical.html#universal-constants","title":"Universal Constants","text":""},{"location":"library_api/constants/physical.html#c_light","title":"C_LIGHT","text":"<p>Value: <code>299792458.0</code> m/s</p> <p>Speed of light in vacuum.</p>"},{"location":"library_api/constants/physical.html#brahe.C_LIGHT","title":"C_LIGHT  <code>module-attribute</code>","text":"<pre><code>C_LIGHT: float = 299792458.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#au","title":"AU","text":"<p>Value: <code>1.495978707e11</code> m</p> <p>Astronomical Unit - mean distance of Earth from the Sun. TDB-compatible value.</p>"},{"location":"library_api/constants/physical.html#brahe.AU","title":"AU  <code>module-attribute</code>","text":"<pre><code>AU: float = 149597870700.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#p_sun","title":"P_SUN","text":"<p>Value: <code>4.56e-6</code> N/m\u00b2</p> <p>Solar radiation pressure at 1 AU.</p>"},{"location":"library_api/constants/physical.html#brahe.P_SUN","title":"P_SUN  <code>module-attribute</code>","text":"<pre><code>P_SUN: float = 4.56e-06\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#earth-constants","title":"Earth Constants","text":""},{"location":"library_api/constants/physical.html#geometry","title":"Geometry","text":""},{"location":"library_api/constants/physical.html#r_earth","title":"R_EARTH","text":"<p>Value: <code>6378136.3</code> m</p> <p>Earth's equatorial radius (GGM05 gravity model).</p>"},{"location":"library_api/constants/physical.html#brahe.R_EARTH","title":"R_EARTH  <code>module-attribute</code>","text":"<pre><code>R_EARTH: float = 6378136.3\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_a","title":"WGS84_A","text":"<p>Value: <code>6378137.0</code> m</p> <p>Earth's semi-major axis as defined by WGS84 geodetic system.</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_A","title":"WGS84_A  <code>module-attribute</code>","text":"<pre><code>WGS84_A: float = 6378137.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#wgs84_f","title":"WGS84_F","text":"<p>Value: <code>0.0033528106647474805</code> (dimensionless)</p> <p>Earth's ellipsoidal flattening. WGS84 value: 1/298.257223563</p>"},{"location":"library_api/constants/physical.html#brahe.WGS84_F","title":"WGS84_F  <code>module-attribute</code>","text":"<pre><code>WGS84_F: float = 0.0033528106647474805\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#ecc_earth","title":"ECC_EARTH","text":"<p>Value: <code>0.081819190842622</code> (dimensionless)</p> <p>Earth's first eccentricity (WGS84 value).</p>"},{"location":"library_api/constants/physical.html#brahe.ECC_EARTH","title":"ECC_EARTH  <code>module-attribute</code>","text":"<pre><code>ECC_EARTH: float = 0.081819190842622\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gravitational-properties","title":"Gravitational Properties","text":""},{"location":"library_api/constants/physical.html#gm_earth","title":"GM_EARTH","text":"<p>Value: <code>3.986004415e14</code> m\u00b3/s\u00b2</p> <p>Earth's gravitational parameter (\u03bc = G \u00d7 M).</p>"},{"location":"library_api/constants/physical.html#brahe.GM_EARTH","title":"GM_EARTH  <code>module-attribute</code>","text":"<pre><code>GM_EARTH: float = 398600441500000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#j2_earth","title":"J2_EARTH","text":"<p>Value: <code>0.0010826358191967</code> (dimensionless)</p> <p>Earth's J2 zonal harmonic coefficient (GGM05s gravity model). Represents Earth's oblateness.</p>"},{"location":"library_api/constants/physical.html#brahe.J2_EARTH","title":"J2_EARTH  <code>module-attribute</code>","text":"<pre><code>J2_EARTH: float = 0.0010826358191967\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#omega_earth","title":"OMEGA_EARTH","text":"<p>Value: <code>7.292115146706979e-05</code> rad/s</p> <p>Earth's axial rotation rate.</p>"},{"location":"library_api/constants/physical.html#brahe.OMEGA_EARTH","title":"OMEGA_EARTH  <code>module-attribute</code>","text":"<pre><code>OMEGA_EARTH: float = 7.292115146706979e-05\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#celestial-body-gravitational-parameters","title":"Celestial Body Gravitational Parameters","text":"<p>Gravitational parameters (\u03bc = G \u00d7 M) for major solar system bodies in m\u00b3/s\u00b2.</p>"},{"location":"library_api/constants/physical.html#sun","title":"Sun","text":""},{"location":"library_api/constants/physical.html#gm_sun","title":"GM_SUN","text":"<p>Value: <code>1.32712440041939e20</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SUN","title":"GM_SUN  <code>module-attribute</code>","text":"<pre><code>GM_SUN: float = 1.327124400419394e+20\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_sun","title":"R_SUN","text":"<p>Value: <code>6.9634e8</code> m</p> <p>Solar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_SUN","title":"R_SUN  <code>module-attribute</code>","text":"<pre><code>R_SUN: float = 695700000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#moon","title":"Moon","text":""},{"location":"library_api/constants/physical.html#gm_moon","title":"GM_MOON","text":"<p>Value: <code>4.9028e12</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MOON","title":"GM_MOON  <code>module-attribute</code>","text":"<pre><code>GM_MOON: float = 4902800066000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#r_moon","title":"R_MOON","text":"<p>Value: <code>1.738e6</code> m</p> <p>Lunar radius.</p>"},{"location":"library_api/constants/physical.html#brahe.R_MOON","title":"R_MOON  <code>module-attribute</code>","text":"<pre><code>R_MOON: float = 1738000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#inner-planets","title":"Inner Planets","text":""},{"location":"library_api/constants/physical.html#gm_mercury","title":"GM_MERCURY","text":"<p>Value: <code>2.2031868551e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MERCURY","title":"GM_MERCURY  <code>module-attribute</code>","text":"<pre><code>GM_MERCURY: float = 22031780000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_venus","title":"GM_VENUS","text":"<p>Value: <code>3.257e14</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_VENUS","title":"GM_VENUS  <code>module-attribute</code>","text":"<pre><code>GM_VENUS: float = 324858592000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_mars","title":"GM_MARS","text":"<p>Value: <code>4.305e13</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_MARS","title":"GM_MARS  <code>module-attribute</code>","text":"<pre><code>GM_MARS: float = 42828375210000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#outer-planets","title":"Outer Planets","text":""},{"location":"library_api/constants/physical.html#gm_jupiter","title":"GM_JUPITER","text":"<p>Value: <code>1.268e17</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_JUPITER","title":"GM_JUPITER  <code>module-attribute</code>","text":"<pre><code>GM_JUPITER: float = 1.267127648e+17\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_saturn","title":"GM_SATURN","text":"<p>Value: <code>3.794e16</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_SATURN","title":"GM_SATURN  <code>module-attribute</code>","text":"<pre><code>GM_SATURN: float = 3.79405852e+16\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_uranus","title":"GM_URANUS","text":"<p>Value: <code>5.794e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_URANUS","title":"GM_URANUS  <code>module-attribute</code>","text":"<pre><code>GM_URANUS: float = 5794548600000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#gm_neptune","title":"GM_NEPTUNE","text":"<p>Value: <code>6.837e15</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_NEPTUNE","title":"GM_NEPTUNE  <code>module-attribute</code>","text":"<pre><code>GM_NEPTUNE: float = 6836527100580000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/physical.html#dwarf-planets","title":"Dwarf Planets","text":""},{"location":"library_api/constants/physical.html#gm_pluto","title":"GM_PLUTO","text":"<p>Value: <code>9.77e11</code> m\u00b3/s\u00b2</p>"},{"location":"library_api/constants/physical.html#brahe.GM_PLUTO","title":"GM_PLUTO  <code>module-attribute</code>","text":"<pre><code>GM_PLUTO: float = 977000000000.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html","title":"Time Constants","text":"<p>Constants related to time systems, epochs, and time conversions.</p>"},{"location":"library_api/constants/time.html#julian-date-references","title":"Julian Date References","text":""},{"location":"library_api/constants/time.html#mjd_zero","title":"MJD_ZERO","text":"<p>Value: <code>2400000.5</code> days</p> <p>Offset of Modified Julian Date (MJD) with respect to Julian Date (JD). For any time t: <pre><code>MJD_ZERO = JD - MJD\n</code></pre></p>"},{"location":"library_api/constants/time.html#brahe.MJD_ZERO","title":"MJD_ZERO  <code>module-attribute</code>","text":"<pre><code>MJD_ZERO: float = 2400000.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#mjd2000","title":"MJD2000","text":"<p>Value: <code>51544.5</code> days</p> <p>Modified Julian Date of January 1, 2000 12:00:00 (J2000.0 epoch). Value is independent of time system.</p>"},{"location":"library_api/constants/time.html#brahe.MJD2000","title":"MJD2000  <code>module-attribute</code>","text":"<pre><code>MJD2000: float = 51544.5\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps_zero","title":"GPS_ZERO","text":"<p>Value: <code>44244.0</code> days</p> <p>Modified Julian Date of the start of GPS time (January 6, 1980 00:00:00 UTC).</p>"},{"location":"library_api/constants/time.html#brahe.GPS_ZERO","title":"GPS_ZERO  <code>module-attribute</code>","text":"<pre><code>GPS_ZERO: float = 44244.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#time-system-offsets","title":"Time System Offsets","text":"<p>All offset values are in seconds.</p>"},{"location":"library_api/constants/time.html#gps-tai","title":"GPS \u2194 TAI","text":""},{"location":"library_api/constants/time.html#gps_tai","title":"GPS_TAI","text":"<p>Value: <code>-19.0</code> seconds</p> <p>Offset of GPS time with respect to TAI: <code>GPS = TAI + GPS_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TAI","title":"GPS_TAI  <code>module-attribute</code>","text":"<pre><code>GPS_TAI: float = -19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_gps","title":"TAI_GPS","text":"<p>Value: <code>19.0</code> seconds</p> <p>Offset of TAI time with respect to GPS: <code>TAI = GPS + TAI_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_GPS","title":"TAI_GPS  <code>module-attribute</code>","text":"<pre><code>TAI_GPS: float = 19.0\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt-tai","title":"TT \u2194 TAI","text":""},{"location":"library_api/constants/time.html#tt_tai","title":"TT_TAI","text":"<p>Value: <code>32.184</code> seconds</p> <p>Offset of Terrestrial Time with respect to TAI: <code>TT = TAI + TT_TAI</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_TAI","title":"TT_TAI  <code>module-attribute</code>","text":"<pre><code>TT_TAI: float = 32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tai_tt","title":"TAI_TT","text":"<p>Value: <code>-32.184</code> seconds</p> <p>Offset of TAI with respect to Terrestrial Time: <code>TAI = TT + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.TAI_TT","title":"TAI_TT  <code>module-attribute</code>","text":"<pre><code>TAI_TT: float = -32.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#gps-tt","title":"GPS \u2194 TT","text":""},{"location":"library_api/constants/time.html#gps_tt","title":"GPS_TT","text":"<p>Value: <code>13.184</code> seconds</p> <p>Offset of GPS time with respect to TT: <code>GPS = TT + GPS_TT</code></p> <p>Computed as: <code>GPS_TAI + TAI_TT</code></p>"},{"location":"library_api/constants/time.html#brahe.GPS_TT","title":"GPS_TT  <code>module-attribute</code>","text":"<pre><code>GPS_TT: float = -51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/time.html#tt_gps","title":"TT_GPS","text":"<p>Value: <code>-13.184</code> seconds</p> <p>Offset of TT with respect to GPS time: <code>TT = GPS + TT_GPS</code></p>"},{"location":"library_api/constants/time.html#brahe.TT_GPS","title":"TT_GPS  <code>module-attribute</code>","text":"<pre><code>TT_GPS: float = 51.184\n</code></pre> <p>Convert a string or number to a floating-point number, if possible.</p>"},{"location":"library_api/constants/units.html","title":"Units","text":"<p>Enumerations for specifying angle formats and time systems.</p>"},{"location":"library_api/constants/units.html#angle-format","title":"Angle Format","text":"<p>The <code>AngleFormat</code> enumeration specifies whether angles are in radians or degrees.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/constants/units.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create rotation with angle in degrees\nq = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=90.0,\n    angle_format=bh.AngleFormat.DEGREES\n)\n\n# Create rotation with angle in radians\nq2 = bh.Quaternion.from_euler_axis(\n    axis=np.array([0.0, 0.0, 1.0]),\n    angle=np.pi/2,\n    angle_format=bh.AngleFormat.RADIANS\n)\n</code></pre>"},{"location":"library_api/constants/units.html#time-system","title":"Time System","text":"<p>The <code>TimeSystem</code> enumeration specifies the time reference system for epochs.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem","title":"TimeSystem","text":"<pre><code>TimeSystem()\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p> <p>Initialize instance.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UTC","title":"UTC  <code>class-attribute</code>","text":"<pre><code>UTC: Any = TimeSystem.UTC\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TAI","title":"TAI  <code>class-attribute</code>","text":"<pre><code>TAI: Any = TimeSystem.TAI\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.TT","title":"TT  <code>class-attribute</code>","text":"<pre><code>TT: Any = TimeSystem.TT\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.GPS","title":"GPS  <code>class-attribute</code>","text":"<pre><code>GPS: Any = TimeSystem.GPS\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#brahe.TimeSystem.UT1","title":"UT1  <code>class-attribute</code>","text":"<pre><code>UT1: Any = TimeSystem.UT1\n</code></pre> <p>Enumeration of supported time systems.</p> <p>Time systems define different conventions for measuring and representing time. Each system has specific uses in astrodynamics and timekeeping applications.</p>"},{"location":"library_api/constants/units.html#time-system-descriptions","title":"Time System Descriptions","text":"<ul> <li>UTC (Coordinated Universal Time): Civil time standard used worldwide. Includes leap seconds to keep within 0.9 seconds of UT1.</li> <li>TAI (International Atomic Time): Continuous time scale based on atomic clocks. Currently 37 seconds ahead of UTC (as of 2024).</li> <li>TT (Terrestrial Time): Theoretical time scale for solar system calculations. TT = TAI + 32.184 seconds.</li> <li>GPS (Global Positioning System): Continuous time starting from GPS epoch (January 6, 1980). Does not include leap seconds.</li> <li>UT1 (Universal Time 1): Based on Earth's rotation. Computed from UTC using Earth Orientation Parameters (EOP).</li> </ul>"},{"location":"library_api/constants/units.html#usage-example_1","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Create epoch in different time systems\nutc_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ntai_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.TAI)\ngps_epoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\n\n# Time system is preserved in the epoch\nprint(utc_epoch.time_system)  # Output: UTC\nprint(tai_epoch.time_system)  # Output: TAI\n</code></pre>"},{"location":"library_api/coordinates/index.html","title":"Coordinates","text":"<p>Module: <code>brahe.coordinates</code></p> <p>Comprehensive coordinate system transformations for satellite dynamics.</p>"},{"location":"library_api/coordinates/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Enumerations - Coordinate type enumerations (EllipsoidalConversionType, AngleFormat)</li> <li>Cartesian Coordinates - Cartesian state vectors and orbital element conversions</li> <li>Geodetic &amp; Geocentric - WGS84 geodetic and geocentric coordinate conversions</li> <li>Topocentric Coordinates - Local topocentric frames (ENZ, SEZ, AzElRange)</li> </ul>"},{"location":"library_api/coordinates/cartesian.html","title":"Cartesian Coordinates","text":"<p>Functions for working with Cartesian state vectors and conversions.</p>"},{"location":"library_api/coordinates/cartesian.html#state-conversions","title":"State Conversions","text":""},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_osculating_to_cartesian","title":"state_osculating_to_cartesian  <code>builtin</code>","text":"<pre><code>state_osculating_to_cartesian(x_oe: ndarray, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert osculating orbital elements to Cartesian state.</p> <p>Transforms a state vector from osculating Keplerian orbital elements to Cartesian position and velocity coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_oe</code> <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Orbital elements for a circular orbit\noe = np.array([7000000.0, 0.0, 0.0, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\nx_cart = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprint(f\"Cartesian state: {x_cart}\")\n</code></pre>"},{"location":"library_api/coordinates/cartesian.html#brahe.coordinates.state_cartesian_to_osculating","title":"state_cartesian_to_osculating  <code>builtin</code>","text":"<pre><code>state_cartesian_to_osculating(x_cart: ndarray, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Convert Cartesian state to osculating orbital elements.</p> <p>Transforms a state vector from Cartesian position and velocity coordinates to osculating Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>x_cart</code> <code>ndarray</code> <p>Cartesian state <code>[x, y, z, vx, vy, vz]</code> where position is in meters and velocity is in meters per second.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular elements (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Osculating orbital elements <code>[a, e, i, RAAN, omega, M]</code> where <code>a</code> is semi-major axis (meters), <code>e</code> is eccentricity (dimensionless), <code>i</code> is inclination (radians or degrees), <code>RAAN</code> is right ascension of ascending node (radians or degrees), <code>omega</code> is argument of periapsis (radians or degrees), and <code>M</code> is mean anomaly (radians or degrees).</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Cartesian state vector\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])  # [x, y, z, vx, vy, vz]\noe = bh.state_cartesian_to_osculating(x_cart, bh.AngleFormat.RADIANS)\nprint(f\"Orbital elements: a={oe[0]:.0f}m, e={oe[1]:.6f}, i={oe[2]:.6f} rad\")\n</code></pre>"},{"location":"library_api/coordinates/enums.html","title":"Coordinate Enumerations","text":"<p>Enumerations for specifying coordinate transformation types.</p>"},{"location":"library_api/coordinates/enums.html#ellipsoidalconversiontype","title":"EllipsoidalConversionType","text":"<p>Specifies the type of ellipsoidal conversion used in topocentric coordinate transformations.</p> <p>Values: - <code>GEOCENTRIC</code> - Uses geocentric latitude where the angle is measured from the center of the Earth - <code>GEODETIC</code> - Uses geodetic latitude where the angle is measured perpendicular to the WGS84 ellipsoid</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType","title":"EllipsoidalConversionType","text":"<pre><code>EllipsoidalConversionType()\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEOCENTRIC","title":"GEOCENTRIC  <code>class-attribute</code>","text":"<pre><code>GEOCENTRIC: Any = EllipsoidalConversionType.Geocentric\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.GEODETIC","title":"GEODETIC  <code>class-attribute</code>","text":"<pre><code>GEODETIC: Any = EllipsoidalConversionType.Geodetic\n</code></pre> <p>Python wrapper for EllipsoidalConversionType enum</p> <p>Specifies the type of ellipsoidal conversion used in coordinate transformations.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for EllipsoidalConversionType enum\\n\\nSpecifies the type of ellipsoidal conversion used in coordinate transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.EllipsoidalConversionType.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#angleformat","title":"AngleFormat","text":"<p>Specifies whether angles are in radians or degrees.</p> <p>Values: - <code>RADIANS</code> - Angles are in radians - <code>DEGREES</code> - Angles are in degrees</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat","title":"AngleFormat","text":"<pre><code>AngleFormat()\n</code></pre> <p>Python wrapper for AngleFormat enum</p> <p>Initialize instance.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.DEGREES","title":"DEGREES  <code>class-attribute</code>","text":"<pre><code>DEGREES: Any = AngleFormat.Degrees\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.RADIANS","title":"RADIANS  <code>class-attribute</code>","text":"<pre><code>RADIANS: Any = AngleFormat.Radians\n</code></pre> <p>Python wrapper for AngleFormat enum</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for AngleFormat enum'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/coordinates/enums.html#brahe.AngleFormat.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/coordinates/enums.html#see-also","title":"See Also","text":"<ul> <li>Topocentric Coordinates</li> <li>Geodetic &amp; Geocentric</li> </ul>"},{"location":"library_api/coordinates/geodetic.html","title":"Geodetic and Geocentric Coordinates","text":"<p>Functions for converting between geodetic, geocentric, and ECEF coordinates.</p>"},{"location":"library_api/coordinates/geodetic.html#geodetic-conversions","title":"Geodetic Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geodetic_to_ecef","title":"position_geodetic_to_ecef  <code>builtin</code>","text":"<pre><code>position_geodetic_to_ecef(x_geod: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geodetic position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geod</code> <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geodetic coordinates (GPS-like) to ECEF\nlat, lon, alt = 40.0, -105.0, 1655.0  # Boulder, CO (degrees, meters)\nx_geod = np.array([lat, lon, alt])\nx_ecef = bh.position_geodetic_to_ecef(x_geod, bh.AngleFormat.DEGREES)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geodetic","title":"position_ecef_to_geodetic  <code>builtin</code>","text":"<pre><code>position_ecef_to_geodetic(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geodetic coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geodetic coordinates (latitude, longitude, altitude) using the <code>WGS84</code> ellipsoid model.</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geodetic position <code>[latitude, longitude, altitude]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and altitude is in meters above the <code>WGS84</code> ellipsoid.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geodetic coordinates (GPS-like)\nx_ecef = np.array([-1275936.0, -4797210.0, 4020109.0])  # Example location\nx_geod = bh.position_ecef_to_geodetic(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geodetic: lat={x_geod[0]:.4f}\u00b0, lon={x_geod[1]:.4f}\u00b0, alt={x_geod[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#geocentric-conversions","title":"Geocentric Conversions","text":""},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_geocentric_to_ecef","title":"position_geocentric_to_ecef  <code>builtin</code>","text":"<pre><code>position_geocentric_to_ecef(x_geoc: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert geocentric position to <code>ECEF</code> Cartesian coordinates.</p> <p>Transforms a position from geocentric spherical coordinates (latitude, longitude, radius) to Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_geoc</code> <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert geocentric coordinates to ECEF\nlat, lon, r = 0.0, 0.0, 6378137.0  # Equator, prime meridian, Earth's radius\nx_geoc = np.array([lat, lon, r])\nx_ecef = bh.position_geocentric_to_ecef(x_geoc, bh.AngleFormat.RADIANS)\nprint(f\"ECEF position: {x_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/geodetic.html#brahe.coordinates.position_ecef_to_geocentric","title":"position_ecef_to_geocentric  <code>builtin</code>","text":"<pre><code>position_ecef_to_geocentric(x_ecef: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert <code>ECEF</code> Cartesian position to geocentric coordinates.</p> <p>Transforms a position from Earth-Centered Earth-Fixed (<code>ECEF</code>) Cartesian coordinates to geocentric spherical coordinates (latitude, longitude, radius).</p> <p>Parameters:</p> Name Type Description Default <code>x_ecef</code> <code>ndarray</code> <p><code>ECEF</code> Cartesian position <code>[x, y, z]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Geocentric position <code>[latitude, longitude, radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees, and radius is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ECEF to geocentric coordinates\nx_ecef = np.array([6378137.0, 0.0, 0.0])  # Point on equator, prime meridian\nx_geoc = bh.position_ecef_to_geocentric(x_ecef, bh.AngleFormat.DEGREES)\nprint(f\"Geocentric: lat={x_geoc[0]:.2f}\u00b0, lon={x_geoc[1]:.2f}\u00b0, r={x_geoc[2]:.0f}m\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html","title":"Topocentric Coordinates","text":"<p>Functions for working with local topocentric coordinate frames including East-North-Up (ENZ), South-East-Zenith (SEZ), and Azimuth-Elevation-Range.</p>"},{"location":"library_api/coordinates/topocentric.html#enz-east-north-up-frame","title":"ENZ (East-North-Up) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_enz","title":"rotation_ellipsoid_to_enz  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_enz(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to East-North-Up (<code>ENZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>ENZ</code> frame.</p>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_enz_to_ellipsoid","title":"rotation_enz_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_enz_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from East-North-Up (<code>ENZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local East-North-Up (<code>ENZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>ENZ</code> frame to ellipsoidal frame.</p>"},{"location":"library_api/coordinates/topocentric.html#position-conversions","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_enz","title":"relative_position_ecef_to_enz  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_enz(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to East-North-Up (<code>ENZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local East-North-Up (<code>ENZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nenz = bh.relative_position_ecef_to_enz(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"ENZ: East={enz[0]/1000:.1f}km, North={enz[1]/1000:.1f}km, Up={enz[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_enz_to_ecef","title":"relative_position_enz_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_enz_to_ecef(location_ecef: ndarray, r_enz: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from East-North-Up (<code>ENZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local East-North-Up (<code>ENZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_enz</code> <code>ndarray</code> <p>Relative position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nenz_offset = np.array([50000.0, 30000.0, 100000.0])  # 50km east, 30km north, 100km up\ntarget_ecef = bh.relative_position_enz_to_ecef(station_ecef, enz_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_enz_to_azel","title":"position_enz_to_azel  <code>builtin</code>","text":"<pre><code>position_enz_to_azel(x_enz: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from East-North-Up (<code>ENZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local East-North-Up (<code>ENZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_enz</code> <code>ndarray</code> <p>Position in <code>ENZ</code> frame <code>[east, north, up]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert ENZ to azimuth-elevation for satellite tracking\nenz = np.array([50000.0, 100000.0, 200000.0])  # East, North, Up (meters)\nazel = bh.position_enz_to_azel(enz, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#sez-south-east-zenith-frame","title":"SEZ (South-East-Zenith) Frame","text":""},{"location":"library_api/coordinates/topocentric.html#rotation-matrices_1","title":"Rotation Matrices","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_ellipsoid_to_sez","title":"rotation_ellipsoid_to_sez  <code>builtin</code>","text":"<pre><code>rotation_ellipsoid_to_sez(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from ellipsoidal coordinates to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Calculates the rotation matrix that transforms vectors from an ellipsoidal coordinate frame (geocentric or geodetic) to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from ellipsoidal frame to <code>SEZ</code> frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get rotation matrix for ground station in SEZ frame\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_sez = bh.rotation_ellipsoid_to_sez(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_sez.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.rotation_sez_to_ellipsoid","title":"rotation_sez_to_ellipsoid  <code>builtin</code>","text":"<pre><code>rotation_sez_to_ellipsoid(x_ellipsoid: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Compute rotation matrix from South-East-Zenith (<code>SEZ</code>) frame to ellipsoidal coordinates.</p> <p>Calculates the rotation matrix that transforms vectors from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to an ellipsoidal coordinate frame (geocentric or geodetic) at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>x_ellipsoid</code> <code>ndarray</code> <p>Ellipsoidal position <code>[latitude, longitude, altitude/radius]</code> where latitude is in radians or degrees, longitude is in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for input angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>3x3 rotation matrix from <code>SEZ</code> frame to ellipsoidal frame.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Get inverse rotation matrix from SEZ to ellipsoidal\nlat, lon, alt = 0.7, -1.5, 100.0  # radians, meters\nx_geod = np.array([lat, lon, alt])\nR_ellipsoid = bh.rotation_sez_to_ellipsoid(x_geod, bh.AngleFormat.RADIANS)\nprint(f\"Rotation matrix shape: {R_ellipsoid.shape}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#position-conversions_1","title":"Position Conversions","text":""},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_ecef_to_sez","title":"relative_position_ecef_to_sez  <code>builtin</code>","text":"<pre><code>relative_position_ecef_to_sez(location_ecef: ndarray, r_ecef: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from <code>ECEF</code> to South-East-Zenith (<code>SEZ</code>) frame.</p> <p>Transforms a relative position vector from Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates to the local South-East-Zenith (<code>SEZ</code>) topocentric frame at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>r_ecef</code> <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Ground station and satellite positions\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsat_ecef = np.array([4100000.0, 3100000.0, 4100000.0])\nsez = bh.relative_position_ecef_to_sez(station_ecef, sat_ecef, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"SEZ: South={sez[0]/1000:.1f}km, East={sez[1]/1000:.1f}km, Zenith={sez[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.relative_position_sez_to_ecef","title":"relative_position_sez_to_ecef  <code>builtin</code>","text":"<pre><code>relative_position_sez_to_ecef(location_ecef: ndarray, x_sez: ndarray, conversion_type: EllipsoidalConversionType) -&gt; Any\n</code></pre> <p>Convert relative position from South-East-Zenith (<code>SEZ</code>) frame to <code>ECEF</code>.</p> <p>Transforms a relative position vector from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to Earth-Centered Earth-Fixed (<code>ECEF</code>) coordinates at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>location_ecef</code> <code>ndarray</code> <p>Reference location in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> required <code>x_sez</code> <code>ndarray</code> <p>Relative position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>conversion_type</code> <code>EllipsoidalConversionType</code> <p>Type of ellipsoidal conversion (<code>GEOCENTRIC</code> or <code>GEODETIC</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Position vector in <code>ECEF</code> coordinates <code>[x, y, z]</code> in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ offset back to ECEF\nstation_ecef = np.array([4000000.0, 3000000.0, 4000000.0])\nsez_offset = np.array([30000.0, 50000.0, 100000.0])  # 30km south, 50km east, 100km up\ntarget_ecef = bh.relative_position_sez_to_ecef(station_ecef, sez_offset, bh.EllipsoidalConversionType.GEODETIC)\nprint(f\"Target ECEF: {target_ecef}\")\n</code></pre>"},{"location":"library_api/coordinates/topocentric.html#brahe.coordinates.position_sez_to_azel","title":"position_sez_to_azel  <code>builtin</code>","text":"<pre><code>position_sez_to_azel(x_sez: ndarray, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Convert position from South-East-Zenith (<code>SEZ</code>) frame to azimuth-elevation-range.</p> <p>Transforms a position from the local South-East-Zenith (<code>SEZ</code>) topocentric frame to azimuth-elevation-range spherical coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>x_sez</code> <code>ndarray</code> <p>Position in <code>SEZ</code> frame <code>[south, east, zenith]</code> in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for output angular coordinates (<code>RADIANS</code> or <code>DEGREES</code>).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Azimuth-elevation-range <code>[azimuth, elevation, range]</code> where azimuth and elevation are in radians or degrees, and range is in meters.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Convert SEZ to azimuth-elevation for satellite tracking\nsez = np.array([30000.0, 50000.0, 100000.0])  # South, East, Zenith (meters)\nazel = bh.position_sez_to_azel(sez, bh.AngleFormat.DEGREES)\nprint(f\"Az={azel[0]:.1f}\u00b0, El={azel[1]:.1f}\u00b0, Range={azel[2]/1000:.1f}km\")\n</code></pre>"},{"location":"library_api/datasets/index.html","title":"Datasets Module","text":"<p>The datasets module provides convenient access to satellite ephemeris data and groundstation locations from multiple sources. It handles downloading, parsing, and format conversion automatically.</p>"},{"location":"library_api/datasets/index.html#module-overview","title":"Module Overview","text":"<p>The module is organized by data source, with each source providing a consistent API:</p> <ul> <li><code>brahe.datasets.celestrak</code>: CelesTrak satellite ephemeris data</li> <li><code>brahe.datasets.groundstations</code>: Curated groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#submodules","title":"Submodules","text":"<ul> <li>CelesTrak Functions - Satellite ephemeris from CelesTrak</li> <li>Groundstation Functions - Groundstation location datasets</li> </ul>"},{"location":"library_api/datasets/index.html#see-also","title":"See Also","text":"<ul> <li>Datasets Overview - Understanding datasets module</li> <li>CelesTrak Details - CelesTrak data source specifics</li> </ul>"},{"location":"library_api/datasets/celestrak.html","title":"CelesTrak Functions","text":"<p>Functions for accessing satellite ephemeris data from CelesTrak.</p> <p>All functions are available via <code>brahe.datasets.celestrak.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/celestrak.html#get_ephemeris","title":"get_ephemeris","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_ephemeris","title":"celestrak_get_ephemeris  <code>builtin</code>","text":"<pre><code>celestrak_get_ephemeris(group: str) -&gt; list[tuple[str, str, str]]\n</code></pre> <p>Get satellite ephemeris data from CelesTrak</p> <p>Downloads and parses 3LE (three-line element) data for the specified satellite group from CelesTrak (https://celestrak.org).</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\"). See https://celestrak.org/NORAD/elements/ for available groups.</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str, str]]</code> <p>list[tuple[str, str, str]]: List of (name, line1, line2) tuples containing satellite names and TLE lines.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or data cannot be parsed.</p> Example <pre><code>import brahe as bh\n\n# Download ephemeris for ground stations\nephemeris = bh.datasets.celestrak.get_ephemeris(\"stations\")\n\n# Print first 5 satellites\nfor name, line1, line2 in ephemeris[:5]:\n    print(f\"Satellite: {name}\")\n    print(f\"  Line 1: {line1[:20]}...\")\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#get_ephemeris_as_propagators","title":"get_ephemeris_as_propagators","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_get_ephemeris_as_propagators","title":"celestrak_get_ephemeris_as_propagators  <code>builtin</code>","text":"<pre><code>celestrak_get_ephemeris_as_propagators(group: str, step_size: float) -&gt; list[SGPPropagator]\n</code></pre> <p>Get satellite ephemeris as SGP propagators from CelesTrak</p> <p>Downloads and parses 3LE data from CelesTrak, then creates SGP4/SDP4 propagators for each satellite. This is a convenient way to get ready-to-use propagators.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>step_size</code> <code>float</code> <p>Default step size for propagators in seconds.</p> required <p>Returns:</p> Type Description <code>list[SGPPropagator]</code> <p>list[SGPPropagator]: List of configured SGP propagators (PySGPPropagator), one per satellite.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails or no valid propagators can be created.</p> Note <p>Satellites with invalid TLE data will be skipped with a warning printed to stderr. The function will only raise an error if NO valid propagators can be created.</p> Example <pre><code>import brahe as bh\n\n# Get propagators for GNSS satellites with 60-second step size\npropagators = bh.datasets.celestrak.get_ephemeris_as_propagators(\"gnss\", 60.0)\nprint(f\"Loaded {len(propagators)} GNSS satellites\")\n\n# Propagate first satellite\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0, tsys=\"UTC\")\nstate = propagators[0].propagate(epoch)\n</code></pre>"},{"location":"library_api/datasets/celestrak.html#download_ephemeris","title":"download_ephemeris","text":""},{"location":"library_api/datasets/celestrak.html#brahe._brahe.celestrak_download_ephemeris","title":"celestrak_download_ephemeris  <code>builtin</code>","text":"<pre><code>celestrak_download_ephemeris(group: str, filepath: str, content_format: str, file_format: str) -&gt; Any\n</code></pre> <p>Download satellite ephemeris from CelesTrak and save to file</p> <p>Downloads 3LE data from CelesTrak and serializes to the specified file format. The file can contain either 2-line elements (TLE, without names) or 3-line elements (3LE, with satellite names), and can be saved as plain text, CSV, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Satellite group name (e.g., \"active\", \"stations\", \"gnss\", \"last-30-days\").</p> required <code>filepath</code> <code>str</code> <p>Output file path. Parent directories will be created if needed.</p> required <code>content_format</code> <code>str</code> <p>Content format - \"tle\" (2-line without names) or \"3le\" (3-line with names).</p> required <code>file_format</code> <code>str</code> <p>File format - \"txt\" (plain text), \"csv\" (comma-separated), or \"json\" (JSON array).</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If download fails, format is invalid, or file cannot be written.</p> Example <pre><code>import brahe as bh\n\n# Download GNSS satellites as 3LE in JSON format\nbh.datasets.celestrak.download_ephemeris(\"gnss\", \"gnss_sats.json\", \"3le\", \"json\")\n\n# Download active satellites as 2LE in plain text\nbh.datasets.celestrak.download_ephemeris(\"active\", \"active.txt\", \"tle\", \"txt\")\n\n# Download stations as 3LE in CSV format\nbh.datasets.celestrak.download_ephemeris(\"stations\", \"stations.csv\", \"3le\", \"csv\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html","title":"Groundstation Functions","text":"<p>Functions for accessing curated groundstation location datasets.</p> <p>All functions are available via <code>brahe.datasets.groundstations.&lt;function_name&gt;</code>.</p>"},{"location":"library_api/datasets/groundstations.html#load","title":"load","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load","title":"groundstations_load  <code>builtin</code>","text":"<pre><code>groundstations_load(provider: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstation locations for a specific provider</p> <p>Loads groundstation locations from embedded data. The data is compiled into the binary and does not require external files or internet connection.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name (case-insensitive). Available providers: - \"atlas\": Atlas Space Operations - \"aws\": Amazon Web Services Ground Station - \"ksat\": Kongsberg Satellite Services - \"leaf\": Leaf Space - \"ssc\": Swedish Space Corporation - \"viasat\": Viasat</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects with properties: - name: Groundstation name - provider: Provider name - frequency_bands: List of supported frequency bands</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If provider is unknown or data cannot be loaded.</p> Example <pre><code>import brahe as bh\n\n# Load KSAT groundstations\nksat_stations = bh.datasets.groundstations.load(\"ksat\")\n\nfor station in ksat_stations:\n    print(f\"{station.name}: ({station.lon():.2f}, {station.lat():.2f})\")\n\n# Check properties\nprops = ksat_stations[0].properties()\nprint(f\"Frequency bands: {props['frequency_bands']}\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_from_file","title":"load_from_file","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_from_file","title":"groundstations_load_from_file  <code>builtin</code>","text":"<pre><code>groundstations_load_from_file(filepath: str) -&gt; list[PointLocation]\n</code></pre> <p>Load groundstations from a custom GeoJSON file</p> <p>Loads groundstation locations from a user-provided GeoJSON file. The file must be a FeatureCollection with Point geometries.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to GeoJSON file.</p> required <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: List of PointLocation objects.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file cannot be read or parsed.</p> Example <pre><code>import brahe as bh\n\n# Load custom groundstations\nstations = bh.datasets.groundstations.load_from_file(\"my_stations.geojson\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#load_all","title":"load_all","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_load_all","title":"groundstations_load_all  <code>builtin</code>","text":"<pre><code>groundstations_load_all() -&gt; list[PointLocation]\n</code></pre> <p>Load all groundstations from all providers</p> <p>Convenience function to load groundstations from all available providers.</p> <p>Returns:</p> Type Description <code>list[PointLocation]</code> <p>list[PointLocation]: Combined list of all groundstations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no groundstations can be loaded.</p> Example <pre><code>import brahe as bh\n\nall_stations = bh.datasets.groundstations.load_all()\nprint(f\"Loaded {len(all_stations)} total groundstations\")\n</code></pre>"},{"location":"library_api/datasets/groundstations.html#list_providers","title":"list_providers","text":""},{"location":"library_api/datasets/groundstations.html#brahe._brahe.groundstations_list_providers","title":"groundstations_list_providers  <code>builtin</code>","text":"<pre><code>groundstations_list_providers() -&gt; list[str]\n</code></pre> <p>Get list of available groundstation providers</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of provider names that can be used with load().</p> Example <pre><code>import brahe as bh\n\nproviders = bh.datasets.groundstations.list_providers()\nprint(f\"Available: {', '.join(providers)}\")\n</code></pre>"},{"location":"library_api/eop/index.html","title":"Earth Orientation Parameters (EOP)","text":"<p>Module: <code>brahe.eop</code></p> <p>Earth Orientation Parameters provide corrections for the irregular rotation and orientation of the Earth, essential for accurate coordinate frame transformations between ECI and ECEF systems.</p>"},{"location":"library_api/eop/index.html#overview","title":"Overview","text":"<p>EOP data includes: - UT1-UTC: Difference between UT1 (Earth rotation time) and UTC - Polar Motion (x, y): Movement of Earth's rotation axis relative to the crust - dX, dY: Celestial pole offsets - LOD: Length of day variations</p>"},{"location":"library_api/eop/index.html#eop-providers","title":"EOP Providers","text":"<p>Brahe supports three types of EOP providers:</p>"},{"location":"library_api/eop/index.html#cachingeopprovider","title":"CachingEOPProvider","text":"<p>Automatically manage EOP file freshness with cache management and automatic updates.</p>"},{"location":"library_api/eop/index.html#fileeopprovider","title":"FileEOPProvider","text":"<p>Load EOP data from files (Standard or C04 format) for production applications with current data.</p>"},{"location":"library_api/eop/index.html#staticeopprovider","title":"StaticEOPProvider","text":"<p>Use user-defined fixed data, ideal for testing, offline use, or applications not requiring the most precise transformations.</p>"},{"location":"library_api/eop/index.html#global-eop-management","title":"Global EOP Management","text":"<p>EOP data is managed globally to avoid passing providers through every function call.</p>"},{"location":"library_api/eop/index.html#functions","title":"Functions","text":"<ul> <li>Setting global EOP providers</li> <li>Querying global EOP data</li> <li>Downloading latest EOP files</li> </ul>"},{"location":"library_api/eop/index.html#quick-start","title":"Quick Start","text":"<pre><code>import brahe as bh\n\n# Option 1: Use file-based EOP (recommended for production)\nbh.set_global_eop_provider(\n    bh.FileEOPProvider.from_default_standard()\n)\n\n# Option 2: Use static EOP (for testing/offline use)\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Now frame transformations will use the global EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]  # meters\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/index.html#see-also","title":"See Also","text":"<ul> <li>Frames - Coordinate frame transformations that use EOP</li> <li>Epoch - Time representation</li> </ul>"},{"location":"library_api/eop/caching_provider.html","title":"CachingEOPProvider","text":""},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider","title":"CachingEOPProvider","text":"<pre><code>CachingEOPProvider(eop_type: str, max_age_seconds: int, auto_refresh: bool, interpolate: bool, extrapolate: str, filepath: str = ...)\n</code></pre> <p>Caching EOP provider that automatically downloads updated files when stale.</p> <p>This provider wraps a FileEOPProvider and adds automatic cache management. It checks the age of the EOP file and downloads updated versions when the file exceeds the maximum age threshold. If the file doesn't exist, it will be downloaded on initialization.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>Type of EOP file - \"C04\" for IERS C04 format or \"StandardBulletinA\" for IERS finals2000A.all format</p> required <code>max_age_seconds</code> <code>int</code> <p>Maximum age of file in seconds before triggering a refresh. Common values: 86400 (1 day), 604800 (7 days)</p> required <code>auto_refresh</code> <code>bool</code> <p>If True, automatically checks file age and refreshes on every data access. If False, only checks on initialization and manual refresh() calls</p> required <code>interpolate</code> <code>bool</code> <p>Enable linear interpolation between tabulated EOP values. Recommended: True for smoother data</p> required <code>extrapolate</code> <code>str</code> <p>Behavior for dates outside EOP data range: \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)</p> required <code>filepath</code> <code>str</code> <p>Path to the EOP file (will be created if it doesn't exist). If None, uses default cache location: - StandardBulletinA: ~/.cache/brahe/finals.all.iau2000.txt - C04: ~/.cache/brahe/EOP_20_C04_one_file_1962-now.txt</p> <code>...</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file download fails or file is invalid</p> Example <pre><code>import brahe as bh\n\n# Using default cache location (recommended)\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,  # 7 days\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider_from_caching_provider(provider)\n\n# Check and refresh as needed\nprovider.refresh()\n\n# With explicit filepath\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\",\n    filepath=\"./eop_data/finals.all.iau2000.txt\"\n)\n\n# Auto-refresh mode (convenience)\nauto_provider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=24 * 3600,  # 24 hours\n    auto_refresh=True,  # Checks on every access\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Caching EOP provider that automatically downloads updated files when stale.\\n\\nThis provider wraps a FileEOPProvider and adds automatic cache management.\\nIt checks the age of the EOP file and downloads updated versions when the file\\nexceeds the maximum age threshold. If the file doesn\\'t exist, it will be\\ndownloaded on initialization.\\n\\nArgs:\\n    eop_type (str): Type of EOP file - \"C04\" for IERS C04 format or\\n        \"StandardBulletinA\" for IERS finals2000A.all format\\n    max_age_seconds (int): Maximum age of file in seconds before triggering\\n        a refresh. Common values: 86400 (1 day), 604800 (7 days)\\n    auto_refresh (bool): If True, automatically checks file age and refreshes\\n        on every data access. If False, only checks on initialization and\\n        manual refresh() calls\\n    interpolate (bool): Enable linear interpolation between tabulated EOP\\n        values. Recommended: True for smoother data\\n    extrapolate (str): Behavior for dates outside EOP data range:\\n        \"Hold\" (use last known value), \"Zero\" (return 0.0), or \"Error\" (raise exception)\\n    filepath (str, optional): Path to the EOP file (will be created if it doesn\\'t exist).\\n        If None, uses default cache location:\\n        - StandardBulletinA: ~/.cache/brahe/finals.all.iau2000.txt\\n        - C04: ~/.cache/brahe/EOP_20_C04_one_file_1962-now.txt\\n\\nRaises:\\n    RuntimeError: If file download fails or file is invalid\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Using default cache location (recommended)\\n    provider = bh.CachingEOPProvider(\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=7 * 86400,  # 7 days\\n        auto_refresh=False,\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    bh.set_global_eop_provider_from_caching_provider(provider)\\n\\n    # Check and refresh as needed\\n    provider.refresh()\\n\\n    # With explicit filepath\\n    provider = bh.CachingEOPProvider(\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=7 * 86400,\\n        auto_refresh=False,\\n        interpolate=True,\\n        extrapolate=\"Hold\",\\n        filepath=\"./eop_data/finals.all.iau2000.txt\"\\n    )\\n\\n    # Auto-refresh mode (convenience)\\n    auto_provider = bh.CachingEOPProvider(\\n        eop_type=\"StandardBulletinA\",\\n        max_age_seconds=24 * 3600,  # 24 hours\\n        auto_refresh=True,  # Checks on every access\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP file type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type (\"C04\", \"StandardBulletinA\", etc.)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_age","title":"file_age  <code>method descriptor</code>","text":"<pre><code>file_age() -&gt; float\n</code></pre> <p>Get the age of the currently loaded EOP file in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Age of the loaded file in seconds</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nage = provider.file_age()\nprint(f\"EOP file age: {age:.2f} seconds\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.file_epoch","title":"file_epoch  <code>method descriptor</code>","text":"<pre><code>file_epoch() -&gt; Epoch\n</code></pre> <p>Get the epoch when the EOP file was last loaded.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch in UTC when file was loaded</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\nfile_epoch = provider.file_epoch()\nprint(f\"EOP file loaded at: {file_epoch}\")\n</code></pre>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; Tuple\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>(pm_x, pm_y, ut1_utc, dx, dy, lod)</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last MJD with valid celestial pole offset data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dX/dY data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last MJD with valid LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with length of day data</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum MJD in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum Modified Julian Date</p>"},{"location":"library_api/eop/caching_provider.html#brahe.CachingEOPProvider.refresh","title":"refresh  <code>method descriptor</code>","text":"<pre><code>refresh() -&gt; Any\n</code></pre> <p>Manually refresh the cached EOP data.</p> <p>Checks if the file needs updating and downloads a new version if necessary.</p> Example <pre><code>import brahe as bh\n\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Later, manually force a refresh check\nprovider.refresh()\n</code></pre>"},{"location":"library_api/eop/file_provider.html","title":"FileEOPProvider","text":"<p>Load Earth Orientation Parameters from IERS data files.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider","title":"FileEOPProvider","text":"<pre><code>FileEOPProvider()\n</code></pre> <p>File-based Earth Orientation Parameter provider.</p> <p>Loads EOP data from files in standard IERS formats and provides interpolation and extrapolation capabilities.</p> Example <pre><code>import brahe as bh\n\n# Create from C04 file with interpolation\neop = bh.FileEOPProvider.from_c04_file(\n    \"./eop_data/finals2000A.all.csv\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Create from standard file\neop = bh.FileEOPProvider.from_standard_file(\n    \"./eop_data/finals.all\",\n    interpolate=True,\n    extrapolate=\"Zero\"\n)\n\n# Use default file location\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\n\n# Set as global provider\nbh.set_global_eop_provider_from_file_provider(eop)\n\n# Get EOP data for a specific MJD\nmjd = 60310.0\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'File-based Earth Orientation Parameter provider.\\n\\nLoads EOP data from files in standard IERS formats and provides\\ninterpolation and extrapolation capabilities.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create from C04 file with interpolation\\n    eop = bh.FileEOPProvider.from_c04_file(\\n        \"./eop_data/finals2000A.all.csv\",\\n        interpolate=True,\\n        extrapolate=\"Hold\"\\n    )\\n\\n    # Create from standard file\\n    eop = bh.FileEOPProvider.from_standard_file(\\n        \"./eop_data/finals.all\",\\n        interpolate=True,\\n        extrapolate=\"Zero\"\\n    )\\n\\n    # Use default file location\\n    eop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_file_provider(eop)\\n\\n    # Get EOP data for a specific MJD\\n    mjd = 60310.0\\n    ut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(mjd)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Extrapolation: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_c04_file","title":"from_c04_file  <code>builtin</code>","text":"<pre><code>from_c04_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a C04 format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to C04 EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with C04 file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_c04_file(\"./eop_data/finals2000A.all.csv\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_c04","title":"from_default_c04  <code>builtin</code>","text":"<pre><code>from_default_c04(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default C04 EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default C04 file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_c04(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_file","title":"from_default_file  <code>builtin</code>","text":"<pre><code>from_default_file(eop_type: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from default EOP file location with specified type.</p> <p>Parameters:</p> Name Type Description Default <code>eop_type</code> <code>str</code> <p>EOP file type (\"C04\" or \"StandardBulletinA\")</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default file of specified type</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_file(\"C04\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_default_standard","title":"from_default_standard  <code>builtin</code>","text":"<pre><code>from_default_standard(interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from the default standard IERS EOP file location.</p> <p>Parameters:</p> Name Type Description Default <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with default standard file</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_file","title":"from_file  <code>builtin</code>","text":"<pre><code>from_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from an EOP file with automatic format detection.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_file(\"./eop_data/eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.from_standard_file","title":"from_standard_file  <code>builtin</code>","text":"<pre><code>from_standard_file(filepath: str, interpolate: bool, extrapolate: str) -&gt; FileEOPProvider\n</code></pre> <p>Create provider from a standard IERS format EOP file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to standard IERS EOP file</p> required <code>interpolate</code> <code>bool</code> <p>Enable interpolation between data points</p> required <code>extrapolate</code> <code>str</code> <p>Extrapolation method (\"Hold\", \"Zero\", or \"Error\")</p> required <p>Returns:</p> Name Type Description <code>FileEOPProvider</code> <code>FileEOPProvider</code> <p>Provider initialized with standard file data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_standard_file(\"./eop_data/standard_eop.txt\", True, \"Hold\")\nbh.set_global_eop_provider_from_file_provider(eop)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"interpolation: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"is_initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_last_dxdy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"mjd_max: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#brahe.FileEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/file_provider.html#overview","title":"Overview","text":"<p><code>FileEOPProvider</code> loads EOP data from files in either Standard or C04 format provided by the International Earth Rotation and Reference Systems Service (IERS).</p> <p>Module: <code>brahe.eop</code></p> <p>Data Sources: - Standard Format: finals2000A.all - Combined rapid + predicted data - C04 Format: eopc04_IAU2000.XX - Long-term historical data</p>"},{"location":"library_api/eop/file_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/file_provider.html#from-default-files","title":"From Default Files","text":"<pre><code>import brahe as bh\n\n# Use default standard format file\nprovider = bh.FileEOPProvider.from_default_standard()\n\n# Use default C04 format file\nprovider = bh.FileEOPProvider.from_default_c04()\n</code></pre>"},{"location":"library_api/eop/file_provider.html#from-custom-files","title":"From Custom Files","text":"<pre><code>import brahe as bh\n\n# Load from custom standard file\nprovider = bh.FileEOPProvider.from_standard_file(\n    \"/path/to/finals2000A.all\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Load from custom C04 file\nprovider = bh.FileEOPProvider.from_c04_file(\n    \"/path/to/eopc04.XX\",\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#configuration-options","title":"Configuration Options","text":""},{"location":"library_api/eop/file_provider.html#interpolation","title":"Interpolation","text":"<p><code>interpolate: bool</code> - Enable/disable interpolation between data points</p> <ul> <li><code>True</code>: Linear interpolation for dates between data points (recommended)</li> <li><code>False</code>: Use nearest data point (step function)</li> </ul>"},{"location":"library_api/eop/file_provider.html#extrapolation","title":"Extrapolation","text":"<p><code>extrapolate: str</code> - Behavior when querying dates outside data range</p> <ul> <li><code>\"Hold\"</code>: Use first/last values for dates before/after data range</li> <li><code>\"Zero\"</code>: Return zero for all EOP values outside range</li> <li><code>\"Error\"</code>: Raise an error if date is outside range</li> </ul>"},{"location":"library_api/eop/file_provider.html#usage-with-global-eop","title":"Usage with Global EOP","text":"<pre><code>import brahe as bh\n\n# Create provider from file\nprovider = bh.FileEOPProvider.from_default_standard(\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n\n# Now all frame transformations use this EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [7000000.0, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#downloading-eop-files","title":"Downloading EOP Files","text":"<pre><code>import brahe as bh\n\n# Download latest standard EOP file\nfilepath = bh.download_standard_eop_file(\"./data\")\n\n# Download latest C04 EOP file\nfilepath = bh.download_c04_eop_file(\"./data\")\n\n# Use downloaded file\nprovider = bh.FileEOPProvider.from_standard_file(filepath)\n</code></pre>"},{"location":"library_api/eop/file_provider.html#see-also","title":"See Also","text":"<ul> <li>StaticEOPProvider - Built-in historical EOP data</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations using EOP</li> </ul>"},{"location":"library_api/eop/functions.html","title":"EOP Functions","text":"<p>Global EOP management and query functions.</p> <p>Module: <code>brahe.eop</code></p>"},{"location":"library_api/eop/functions.html#setting-global-eop-provider","title":"Setting Global EOP Provider","text":""},{"location":"library_api/eop/functions.html#initialize_eop","title":"initialize_eop","text":"<p>Recommended: Initialize the global EOP provider with sensible defaults. This is the easiest way to get started with EOP data for most applications.</p>"},{"location":"library_api/eop/functions.html#brahe.initialize_eop","title":"initialize_eop  <code>builtin</code>","text":"<pre><code>initialize_eop() -&gt; Any\n</code></pre> <p>Initialize the global EOP provider with recommended default settings.</p> <p>This convenience function creates a CachingEOPProvider with sensible defaults and sets it as the global provider. The provider will:</p> <ul> <li>Use StandardBulletinA EOP data format</li> <li>Automatically download/update EOP files when older than 7 days</li> <li>Use the default cache location (~/.cache/brahe/finals.all.iau2000.txt)</li> <li>Enable interpolation for smooth EOP data transitions</li> <li>Hold the last known EOP value when extrapolating beyond available data</li> <li>NOT auto-refresh on every access (manual refresh required)</li> </ul> <p>This is the recommended way to initialize EOP data for most applications, balancing accuracy, performance, and ease of use.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If file download or loading failed</p> Example <pre><code>import brahe as bh\n\n# Initialize with recommended defaults\nbh.initialize_eop()\n\n# Now you can perform frame transformations that require EOP data\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\npos_eci = [bh.R_EARTH + 500e3, 0.0, 0.0]\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n</code></pre> Example <pre><code>import brahe as bh\n\n# This is equivalent to:\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#set_global_eop_provider","title":"set_global_eop_provider","text":"<p>Set the global EOP provider using any supported provider type (StaticEOPProvider, FileEOPProvider, or CachingEOPProvider).</p>"},{"location":"library_api/eop/functions.html#brahe.set_global_eop_provider","title":"set_global_eop_provider  <code>builtin</code>","text":"<pre><code>set_global_eop_provider(provider: StaticEOPProvider | FileEOPProvider | CachingEOPProvider) -&gt; Any\n</code></pre> <p>Set the global EOP provider using any supported provider type.</p> <p>This function accepts any of the three EOP provider types: StaticEOPProvider, FileEOPProvider, or CachingEOPProvider. This is the recommended way to set the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>StaticEOPProvider | FileEOPProvider | CachingEOPProvider</code> <p>EOP provider to set globally</p> required Example <pre><code>import brahe as bh\n\n# Use with StaticEOPProvider\nprovider = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider(provider)\n\n# Use with FileEOPProvider\nprovider = bh.FileEOPProvider.from_default_standard(True, \"Hold\")\nbh.set_global_eop_provider(provider)\n\n# Use with CachingEOPProvider\nprovider = bh.CachingEOPProvider(\n    eop_type=\"StandardBulletinA\",\n    max_age_seconds=7 * 86400,\n    auto_refresh=False,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/functions.html#querying-global-eop-data","title":"Querying Global EOP Data","text":""},{"location":"library_api/eop/functions.html#get_global_eop","title":"get_global_eop","text":"<p>Get all EOP values for a specific Modified Julian Date.</p> <p>Returns: Tuple of (ut1_utc, pm_x, pm_y, dx, dy, lod)</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop","title":"get_global_eop  <code>builtin</code>","text":"<pre><code>get_global_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p>"},{"location":"library_api/eop/functions.html#get_global_ut1_utc","title":"get_global_ut1_utc","text":"<p>Get UT1-UTC offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_ut1_utc","title":"get_global_ut1_utc  <code>builtin</code>","text":"<pre><code>get_global_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p>"},{"location":"library_api/eop/functions.html#get_global_pm","title":"get_global_pm","text":"<p>Get polar motion (x, y) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_pm","title":"get_global_pm  <code>builtin</code>","text":"<pre><code>get_global_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p>"},{"location":"library_api/eop/functions.html#get_global_dxdy","title":"get_global_dxdy","text":"<p>Get celestial pole offsets (dx, dy) in radians.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_dxdy","title":"get_global_dxdy  <code>builtin</code>","text":"<pre><code>get_global_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p>"},{"location":"library_api/eop/functions.html#get_global_lod","title":"get_global_lod","text":"<p>Get length of day offset in seconds.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_lod","title":"get_global_lod  <code>builtin</code>","text":"<pre><code>get_global_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset from the global EOP provider.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p>"},{"location":"library_api/eop/functions.html#eop-metadata","title":"EOP Metadata","text":""},{"location":"library_api/eop/functions.html#get_global_eop_type","title":"get_global_eop_type","text":"<p>Get the type of global EOP provider (\"file\" or \"static\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_type","title":"get_global_eop_type  <code>builtin</code>","text":"<pre><code>get_global_eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type of the global provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_initialization","title":"get_global_eop_initialization","text":"<p>Check if global EOP provider has been initialized.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_initialization","title":"get_global_eop_initialization  <code>builtin</code>","text":"<pre><code>get_global_eop_initialization() -&gt; bool\n</code></pre> <p>Check if the global EOP provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if global EOP provider is initialized</p>"},{"location":"library_api/eop/functions.html#get_global_eop_interpolation","title":"get_global_eop_interpolation","text":"<p>Check if interpolation is enabled.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_interpolation","title":"get_global_eop_interpolation  <code>builtin</code>","text":"<pre><code>get_global_eop_interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled in the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p>"},{"location":"library_api/eop/functions.html#get_global_eop_extrapolation","title":"get_global_eop_extrapolation","text":"<p>Get extrapolation method (\"Hold\", \"Zero\", or \"Error\").</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_extrapolation","title":"get_global_eop_extrapolation  <code>builtin</code>","text":"<pre><code>get_global_eop_extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method of the global EOP provider.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p>"},{"location":"library_api/eop/functions.html#get_global_eop_len","title":"get_global_eop_len","text":"<p>Get number of EOP data points in provider.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_len","title":"get_global_eop_len  <code>builtin</code>","text":"<pre><code>get_global_eop_len() -&gt; int\n</code></pre> <p>Get the number of EOP data points in the global provider.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_min","title":"get_global_eop_mjd_min","text":"<p>Get minimum (earliest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_min","title":"get_global_eop_mjd_min  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_max","title":"get_global_eop_mjd_max","text":"<p>Get maximum (latest) MJD in EOP data.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_max","title":"get_global_eop_mjd_max  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the global EOP dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod","text":"<p>Get MJD of last LOD (Length of Day) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_lod","title":"get_global_eop_mjd_last_lod  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p>"},{"location":"library_api/eop/functions.html#get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy","text":"<p>Get MJD of last dX/dY (celestial pole offset) data point.</p>"},{"location":"library_api/eop/functions.html#brahe.get_global_eop_mjd_last_dxdy","title":"get_global_eop_mjd_last_dxdy  <code>builtin</code>","text":"<pre><code>get_global_eop_mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data in the global provider.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p>"},{"location":"library_api/eop/functions.html#downloading-eop-files","title":"Downloading EOP Files","text":""},{"location":"library_api/eop/functions.html#download_standard_eop_file","title":"download_standard_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_standard_eop_file","title":"download_standard_eop_file  <code>builtin</code>","text":"<pre><code>download_standard_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest standard Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest standard EOP data\nbh.download_standard_eop_file(\"./eop_data/standard_eop.txt\")\n</code></pre>"},{"location":"library_api/eop/functions.html#download_c04_eop_file","title":"download_c04_eop_file","text":""},{"location":"library_api/eop/functions.html#brahe.download_c04_eop_file","title":"download_c04_eop_file  <code>builtin</code>","text":"<pre><code>download_c04_eop_file(filepath: str) -&gt; Any\n</code></pre> <p>Download latest C04 Earth orientation parameter file. Will attempt to download the latest parameter file to the specified location. Creating any missing directories as required.</p> <p>The download source is the IERS Earth Orientation Data Products</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path of desired output file</p> required Example <pre><code>import brahe as bh\n\n# Download latest C04 EOP data\nbh.download_c04_eop_file(\"./eop_data/finals2000A.all.csv\")\n</code></pre>"},{"location":"library_api/eop/functions.html#usage-examples","title":"Usage Examples","text":""},{"location":"library_api/eop/functions.html#quick-start-recommended","title":"Quick Start (Recommended)","text":"<pre><code>import brahe as bh\n\n# Initialize EOP with recommended defaults - easiest way to get started!\nbh.initialize_eop()\n\n# Query EOP for specific epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epoch.mjd()\n\nut1_utc, pm_x, pm_y, dx, dy, lod = bh.get_global_eop(mjd)\nprint(f\"EOP for MJD {mjd}:\")\nprint(f\"  UT1-UTC: {ut1_utc:.6f} s\")\nprint(f\"  Polar Motion: ({pm_x*1e6:.3f}, {pm_y*1e6:.3f}) \u03bcrad\")\nprint(f\"  dX, dY: ({dx*1e6:.3f}, {dy*1e6:.3f}) \u03bcrad\")\nprint(f\"  LOD: {lod*1e3:.6f} ms\")\n</code></pre>"},{"location":"library_api/eop/functions.html#custom-provider-setup","title":"Custom Provider Setup","text":"<pre><code>import brahe as bh\n\n# Download and set up file-based EOP with custom settings\neop_file = bh.download_standard_eop_file(\"./data\")\nprovider = bh.FileEOPProvider.from_standard_file(\n    eop_file,\n    interpolate=True,\n    extrapolate=\"Hold\"\n)\nbh.set_global_eop_provider(provider)\n\n# Check provider status\nprint(f\"EOP Type: {bh.get_global_eop_type()}\")\nprint(f\"Data points: {bh.get_global_eop_len()}\")\nprint(f\"Date range: MJD {bh.get_global_eop_mjd_min():.1f} to {bh.get_global_eop_mjd_max():.1f}\")\nprint(f\"Interpolation: {bh.get_global_eop_interpolation()}\")\nprint(f\"Extrapolation: {bh.get_global_eop_extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/functions.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider</li> <li>StaticEOPProvider</li> <li>Frames - Frame transformations that use EOP</li> </ul>"},{"location":"library_api/eop/static_provider.html","title":"StaticEOPProvider","text":"<p>Built-in Earth Orientation Parameters for testing and offline use.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider","title":"StaticEOPProvider","text":"<pre><code>StaticEOPProvider()\n</code></pre> <p>Static Earth Orientation Parameter provider with constant values.</p> <p>Provides EOP data using fixed values that don't change with time. Useful for testing or scenarios where time-varying EOP data is not needed.</p> Example <pre><code>import brahe as bh\n\n# Create static EOP provider with default values\neop = bh.StaticEOPProvider()\n\n# Create static EOP provider with zero values\neop_zero = bh.StaticEOPProvider.from_zero()\n\n# Create with custom values\neop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\n\n# Set as global provider\nbh.set_global_eop_provider_from_static_provider(eop_custom)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = \"Static Earth Orientation Parameter provider with constant values.\\n\\nProvides EOP data using fixed values that don't change with time.\\nUseful for testing or scenarios where time-varying EOP data is not needed.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # Create static EOP provider with default values\\n    eop = bh.StaticEOPProvider()\\n\\n    # Create static EOP provider with zero values\\n    eop_zero = bh.StaticEOPProvider.from_zero()\\n\\n    # Create with custom values\\n    eop_custom = bh.StaticEOPProvider.from_values(0.1, 0.0, 0.0, 0.0, 0.0, 0.0)\\n\\n    # Set as global provider\\n    bh.set_global_eop_provider_from_static_provider(eop_custom)\\n    ```\"\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.eop_type","title":"eop_type  <code>method descriptor</code>","text":"<pre><code>eop_type() -&gt; str\n</code></pre> <p>Get the EOP data type.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>EOP type string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP type: {eop.eop_type()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.extrapolation","title":"extrapolation  <code>method descriptor</code>","text":"<pre><code>extrapolation() -&gt; str\n</code></pre> <p>Get the extrapolation method.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Extrapolation method string</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Extrapolation method: {eop.extrapolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_values","title":"from_values  <code>builtin</code>","text":"<pre><code>from_values(ut1_utc: float, pm_x: float, pm_y: float, dx: float, dy: float, lod: float) -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with specified values.</p> <p>Parameters:</p> Name Type Description Default <code>ut1_utc</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> required <code>pm_x</code> <code>float</code> <p>Polar motion x-component in radians</p> required <code>pm_y</code> <code>float</code> <p>Polar motion y-component in radians</p> required <code>dx</code> <code>float</code> <p>Celestial pole offset dx in radians</p> required <code>dy</code> <code>float</code> <p>Celestial pole offset dy in radians</p> required <code>lod</code> <code>float</code> <p>Length of day offset in seconds</p> required <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with specified EOP values</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with custom values\neop = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,\n    pm_x=1e-6,\n    pm_y=2e-6,\n    dx=1e-7,\n    dy=1e-7,\n    lod=0.001\n)\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.from_zero","title":"from_zero  <code>builtin</code>","text":"<pre><code>from_zero() -&gt; StaticEOPProvider\n</code></pre> <p>Create a static EOP provider with all values set to zero.</p> <p>Returns:</p> Name Type Description <code>StaticEOPProvider</code> <code>StaticEOPProvider</code> <p>Provider with all EOP values set to zero</p> Example <pre><code>import brahe as bh\n\n# Create EOP provider with all zeros (no corrections)\neop = bh.StaticEOPProvider.from_zero()\nbh.set_global_eop_provider_from_static_provider(eop)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_dxdy","title":"get_dxdy  <code>method descriptor</code>","text":"<pre><code>get_dxdy(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get celestial pole offsets for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Celestial pole offsets dx and dy in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\ndx, dy = eop.get_dxdy(58849.0)\nprint(f\"Celestial pole offsets: dx={dx} rad, dy={dy} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_eop","title":"get_eop  <code>method descriptor</code>","text":"<pre><code>get_eop(mjd: float) -&gt; tuple[float, float, float, float, float, float]\n</code></pre> <p>Get all EOP parameters for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float, float, float, float, float]</code> <p>tuple[float, float, float, float, float, float]: UT1-UTC, pm_x, pm_y, dx, dy, lod</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider()\nut1_utc, pm_x, pm_y, dx, dy, lod = eop.get_eop(58849.0)\nprint(f\"EOP: UT1-UTC={ut1_utc}s, PM=({pm_x},{pm_y})rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_lod","title":"get_lod  <code>method descriptor</code>","text":"<pre><code>get_lod(mjd: float) -&gt; float\n</code></pre> <p>Get length of day offset for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of day offset in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nlod = eop.get_lod(58849.0)\nprint(f\"Length of day offset: {lod} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_pm","title":"get_pm  <code>method descriptor</code>","text":"<pre><code>get_pm(mjd: float) -&gt; tuple[float, float]\n</code></pre> <p>Get polar motion components for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: Polar motion x and y components in radians</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\npm_x, pm_y = eop.get_pm(58849.0)\nprint(f\"Polar motion: x={pm_x} rad, y={pm_y} rad\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.get_ut1_utc","title":"get_ut1_utc  <code>method descriptor</code>","text":"<pre><code>get_ut1_utc(mjd: float) -&gt; float\n</code></pre> <p>Get UT1-UTC time difference for a given MJD.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian Date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>UT1-UTC time difference in seconds</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nut1_utc = eop.get_ut1_utc(58849.0)\nprint(f\"UT1-UTC: {ut1_utc} seconds\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.interpolation","title":"interpolation  <code>method descriptor</code>","text":"<pre><code>interpolation() -&gt; bool\n</code></pre> <p>Check if interpolation is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if interpolation is enabled</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Interpolation enabled: {eop.interpolation()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.is_initialized","title":"is_initialized  <code>method descriptor</code>","text":"<pre><code>is_initialized() -&gt; bool\n</code></pre> <p>Check if the provider is initialized.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if initialized</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Is initialized: {eop.is_initialized()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of EOP data points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of EOP data points</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"EOP data points: {eop.len()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_dxdy","title":"mjd_last_dxdy  <code>method descriptor</code>","text":"<pre><code>mjd_last_dxdy() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with dx/dy data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with dx/dy data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with dx/dy: {eop.mjd_last_dxdy()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_last_lod","title":"mjd_last_lod  <code>method descriptor</code>","text":"<pre><code>mjd_last_lod() -&gt; float\n</code></pre> <p>Get the last Modified Julian Date with LOD data.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Last MJD with LOD data</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Last MJD with LOD: {eop.mjd_last_lod()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_max","title":"mjd_max  <code>method descriptor</code>","text":"<pre><code>mjd_max() -&gt; float\n</code></pre> <p>Get the maximum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Maximum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Maximum MJD: {eop.mjd_max()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#brahe.StaticEOPProvider.mjd_min","title":"mjd_min  <code>method descriptor</code>","text":"<pre><code>mjd_min() -&gt; float\n</code></pre> <p>Get the minimum Modified Julian Date in the dataset.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Minimum MJD</p> Example <pre><code>import brahe as bh\n\neop = bh.StaticEOPProvider.from_zero()\nprint(f\"Minimum MJD: {eop.mjd_min()}\")\n</code></pre>"},{"location":"library_api/eop/static_provider.html#overview","title":"Overview","text":"<p><code>StaticEOPProvider</code> provides built-in historical EOP data that doesn't require external files. Useful for testing, examples, or when internet access is unavailable.</p> <p>Module: <code>brahe.eop</code></p> <p>Use Cases: - Unit testing - Examples and tutorials - Offline applications - Quick prototyping</p> <p>Limitations: - Fixed historical data (not updated) - Less accurate than file-based providers - Not suitable for production applications requiring current data</p>"},{"location":"library_api/eop/static_provider.html#creating-a-provider","title":"Creating a Provider","text":""},{"location":"library_api/eop/static_provider.html#zero-values","title":"Zero Values","text":"<pre><code>import brahe as bh\n\n# All EOP values set to zero\nprovider = bh.StaticEOPProvider.from_zero()\n\n# Set as global provider\nbh.set_global_eop_provider(provider)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#custom-values","title":"Custom Values","text":"<pre><code>import brahe as bh\n\n# Specify custom EOP values\nprovider = bh.StaticEOPProvider.from_values(\n    ut1_utc=0.1,      # UT1-UTC offset (seconds)\n    pm_x=0.0001,      # Polar motion X (radians)\n    pm_y=0.0001,      # Polar motion Y (radians)\n    dx=0.00001,       # Celestial pole offset dX (radians)\n    dy=0.00001,       # Celestial pole offset dY (radians)\n    lod=0.001         # Length of day offset (seconds)\n)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#default-values","title":"Default Values","text":"<pre><code>import brahe as bh\n\n# Use built-in default values\nprovider = bh.StaticEOPProvider()\n</code></pre>"},{"location":"library_api/eop/static_provider.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\n\n# Set up static EOP for testing\nbh.set_global_eop_provider(\n    bh.StaticEOPProvider.from_zero()\n)\n\n# Perform frame transformations\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# ECI to ECEF transformation\npos_eci = [7000000.0, 0.0, 0.0]  # meters in ECI\npos_ecef = bh.position_eci_to_ecef(epoch, pos_eci)\n\n# ECEF to ECI transformation\nvel_ecef = [0.0, 7500.0, 0.0]  # m/s in ECEF\nvel_eci = bh.position_ecef_to_eci(epoch, vel_ecef)\n</code></pre>"},{"location":"library_api/eop/static_provider.html#when-to-use","title":"When to Use","text":"<p>\u2705 Use StaticEOPProvider for: - Unit tests - Documentation examples - Learning and prototyping - Applications where high accuracy isn't critical</p> <p>\u274c Don't use StaticEOPProvider for: - Production orbit determination - Precise tracking applications - Applications requiring current EOP data - High-accuracy simulations</p>"},{"location":"library_api/eop/static_provider.html#see-also","title":"See Also","text":"<ul> <li>FileEOPProvider - File-based EOP for production use</li> <li>EOP Functions - Global EOP management</li> <li>Frames - Coordinate transformations</li> </ul>"},{"location":"library_api/orbits/index.html","title":"Orbits","text":"<p>Module: <code>brahe.orbits</code></p> <p>Comprehensive tools for orbital mechanics computations and TLE handling.</p>"},{"location":"library_api/orbits/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Keplerian Elements - Functions for computing orbital properties and converting between anomaly types</li> <li>Two-Line Elements (TLE) - TLE parsing, validation, and conversion utilities</li> <li>Enumerations - Orbit-related enumerations (OrbitRepresentation, OrbitFrame, etc.)</li> </ul> <p>Note: Orbit propagators have been moved to the <code>brahe.propagators</code> module.</p>"},{"location":"library_api/orbits/enums.html","title":"Orbit Enumerations","text":"<p>Enumerations for specifying orbit representation types and reference frames.</p>"},{"location":"library_api/orbits/enums.html#orbitrepresentation","title":"OrbitRepresentation","text":"<p>Specifies the type of orbital elements being used.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation","title":"OrbitRepresentation","text":"<pre><code>OrbitRepresentation()\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.CARTESIAN","title":"CARTESIAN  <code>class-attribute</code>","text":"<pre><code>CARTESIAN: Any = OrbitRepresentation.Cartesian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.KEPLERIAN","title":"KEPLERIAN  <code>class-attribute</code>","text":"<pre><code>KEPLERIAN: Any = OrbitRepresentation.Keplerian\n</code></pre> <p>Orbital state representation format.</p> <p>Specifies how orbital states are represented in the trajectory.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital state representation format.\\n\\nSpecifies how orbital states are represented in the trajectory.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitRepresentation.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#orbitframe","title":"OrbitFrame","text":""},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame","title":"OrbitFrame","text":"<pre><code>OrbitFrame()\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECEF","title":"ECEF  <code>class-attribute</code>","text":"<pre><code>ECEF: Any = OrbitFrame.ECEF\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.ECI","title":"ECI  <code>class-attribute</code>","text":"<pre><code>ECI: Any = OrbitFrame.ECI\n</code></pre> <p>Reference frame for orbital trajectory representation.</p> <p>Specifies the coordinate reference frame for position and velocity states.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Reference frame for orbital trajectory representation.\\n\\nSpecifies the coordinate reference frame for position and velocity states.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.OrbitFrame.name","title":"name  <code>method descriptor</code>","text":"<pre><code>name() -&gt; str\n</code></pre> <p>Get the full name of the reference frame.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable frame name</p>"},{"location":"library_api/orbits/enums.html#interpolationmethod","title":"InterpolationMethod","text":""},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod","title":"InterpolationMethod","text":"<pre><code>InterpolationMethod()\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p> <p>Initialize instance.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.LINEAR","title":"LINEAR  <code>class-attribute</code>","text":"<pre><code>LINEAR: Any = InterpolationMethod.Linear\n</code></pre> <p>Python bindings for the new trajectory architecture Interpolation method for trajectory state estimation.</p> <p>Specifies the algorithm used to estimate states at epochs between discrete trajectory points.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python bindings for the new trajectory architecture\\nInterpolation method for trajectory state estimation.\\n\\nSpecifies the algorithm used to estimate states at epochs between\\ndiscrete trajectory points.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/orbits/enums.html#brahe.InterpolationMethod.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/orbits/enums.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator</li> <li>Trajectories</li> </ul>"},{"location":"library_api/orbits/keplerian.html","title":"Keplerian Elements","text":"<p>Functions for working with Keplerian orbital elements and computing orbital properties.</p>"},{"location":"library_api/orbits/keplerian.html#orbital-properties","title":"Orbital Properties","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis","title":"semimajor_axis  <code>builtin</code>","text":"<pre><code>semimajor_axis(n: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from Earth given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis from mean motion (typical LEO satellite)\nn = 0.001027  # radians/second (~15 revolutions/day)\na = bh.semimajor_axis(n, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_general","title":"semimajor_axis_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_general(n: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the semi-major axis of an astronomical object from a general body given the object's mean motion.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interpret mean motion as AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for Jupiter orbiter\nn = 0.0001  # radians/second\na = bh.semimajor_axis_general(n, bh.GM_JUPITER, bh.AngleFormat.RADIANS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period","title":"semimajor_axis_from_orbital_period  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period(period: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for a 90-minute orbit\nperiod = 90 * 60.0  # 90 minutes in seconds\na = bh.semimajor_axis_from_orbital_period(period)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.semimajor_axis_from_orbital_period_general","title":"semimajor_axis_from_orbital_period_general  <code>builtin</code>","text":"<pre><code>semimajor_axis_from_orbital_period_general(period: float, gm: float) -&gt; float\n</code></pre> <p>Computes the semi-major axis from orbital period for a general body.</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>float</code> <p>The orbital period in seconds.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The semi-major axis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate semi-major axis for 2-hour Venus orbit\nperiod = 2 * 3600.0  # 2 hours in seconds\na = bh.semimajor_axis_from_orbital_period_general(period, bh.GM_VENUS)\nprint(f\"Semi-major axis: {a/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion","title":"mean_motion  <code>builtin</code>","text":"<pre><code>mean_motion(a: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for geostationary orbit (35786 km altitude)\na = bh.R_EARTH + 35786e3\nn = bh.mean_motion(a, bh.AngleFormat.DEGREES)\nprint(f\"Mean motion: {n:.6f} deg/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.mean_motion_general","title":"mean_motion_general  <code>builtin</code>","text":"<pre><code>mean_motion_general(a: float, gm: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the mean motion of an astronomical object around a general body given a semi-major axis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The mean motion of the astronomical object in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Calculate mean motion for a Mars orbiter\na = 4000000.0  # 4000 km semi-major axis\nn = bh.mean_motion_general(a, bh.GM_MARS, bh.AngleFormat.RADIANS)\nprint(f\"Mean motion: {n:.6f} rad/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period","title":"orbital_period  <code>builtin</code>","text":"<pre><code>orbital_period(a: float) -&gt; Any\n</code></pre> <p>Computes the orbital period of an object around Earth.</p> <p>Uses rastro.constants.GM_EARTH as the standard gravitational parameter for the calculation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period for ISS-like orbit (400 km altitude)\na = bh.R_EARTH + 400e3\nperiod = bh.orbital_period(a)\nprint(f\"Orbital period: {period/60:.2f} minutes\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.orbital_period_general","title":"orbital_period_general  <code>builtin</code>","text":"<pre><code>orbital_period_general(a: float, gm: float) -&gt; float\n</code></pre> <p>Computes the orbital period of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The orbital period of the astronomical object in seconds.</p> Example <pre><code>import brahe as bh\n\n# Calculate orbital period around the Moon\na = 1900000.0  # 1900 km semi-major axis\nperiod = bh.orbital_period_general(a, bh.GM_MOON)\nprint(f\"Lunar orbital period: {period/3600:.2f} hours\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_distance","title":"periapsis_distance  <code>builtin</code>","text":"<pre><code>periapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its periapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at periapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis distance for an elliptical orbit\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_peri = bh.periapsis_distance(a, e)\nprint(f\"Periapsis distance: {r_peri/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_distance","title":"apoapsis_distance  <code>builtin</code>","text":"<pre><code>apoapsis_distance(a: float, e: float) -&gt; float\n</code></pre> <p>Calculate the distance of an object at its apoapsis.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The distance of the object at apoapsis in meters.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis distance\na = 8000000.0  # 8000 km semi-major axis\ne = 0.2  # moderate eccentricity\nr_apo = bh.apoapsis_distance(a, e)\nprint(f\"Apoapsis distance: {r_apo/1000:.2f} km\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.periapsis_velocity","title":"periapsis_velocity  <code>builtin</code>","text":"<pre><code>periapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the periapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at periapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate periapsis velocity for a comet around the Sun\na = 5e11  # 5 AU semi-major axis (meters)\ne = 0.95  # highly elliptical\nv_peri = bh.periapsis_velocity(a, e, bh.GM_SUN)\nprint(f\"Periapsis velocity: {v_peri/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apoapsis_velocity","title":"apoapsis_velocity  <code>builtin</code>","text":"<pre><code>apoapsis_velocity(a: float, e: float, gm: float) -&gt; float\n</code></pre> <p>Computes the apoapsis velocity of an astronomical object around a general body.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>gm</code> <code>float</code> <p>The standard gravitational parameter of primary body in m\u00b3/s\u00b2.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apoapsis in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apoapsis velocity for a Martian satellite\na = 10000000.0  # 10000 km semi-major axis\ne = 0.3\nv_apo = bh.apoapsis_velocity(a, e, bh.GM_MARS)\nprint(f\"Apoapsis velocity: {v_apo/1000:.2f} km/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.perigee_velocity","title":"perigee_velocity  <code>builtin</code>","text":"<pre><code>perigee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the perigee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at perigee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate perigee velocity for Molniya orbit (highly elliptical)\na = 26554000.0  # meters\ne = 0.72  # high eccentricity\nv_peri = bh.perigee_velocity(a, e)\nprint(f\"Perigee velocity: {v_peri:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.apogee_velocity","title":"apogee_velocity  <code>builtin</code>","text":"<pre><code>apogee_velocity(a: float, e: float) -&gt; float\n</code></pre> <p>Computes the apogee velocity of an astronomical object around Earth.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The magnitude of velocity of the object at apogee in m/s.</p> Example <pre><code>import brahe as bh\n\n# Calculate apogee velocity for GTO (Geostationary Transfer Orbit)\na = 24400000.0  # meters\ne = 0.73  # high eccentricity\nv_apo = bh.apogee_velocity(a, e)\nprint(f\"Apogee velocity: {v_apo:.2f} m/s\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.sun_synchronous_inclination","title":"sun_synchronous_inclination  <code>builtin</code>","text":"<pre><code>sun_synchronous_inclination(a: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Computes the inclination for a Sun-synchronous orbit around Earth based on the J2 gravitational perturbation.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>The semi-major axis of the astronomical object in meters.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Return output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Inclination for a Sun synchronous orbit in degrees or radians.</p> Example <pre><code>import brahe as bh\n\n# Calculate sun-synchronous inclination for typical Earth observation satellite (600 km)\na = bh.R_EARTH + 600e3\ne = 0.001  # nearly circular\ninc = bh.sun_synchronous_inclination(a, e, bh.AngleFormat.DEGREES)\nprint(f\"Sun-synchronous inclination: {inc:.2f} degrees\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#anomaly-conversions","title":"Anomaly Conversions","text":""},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_mean","title":"anomaly_eccentric_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_mean(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to mean anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.1  # eccentricity\nM = bh.anomaly_eccentric_to_mean(E, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_eccentric_to_true","title":"anomaly_eccentric_to_true  <code>builtin</code>","text":"<pre><code>anomaly_eccentric_to_true(anm_ecc: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts eccentric anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_ecc</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert eccentric to true anomaly\nE = math.pi / 4  # 45 degrees eccentric anomaly\ne = 0.4  # eccentricity\nnu = bh.anomaly_eccentric_to_true(E, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_eccentric","title":"anomaly_mean_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_eccentric(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to eccentric anomaly (solves Kepler's equation)\nM = 1.5  # mean anomaly in radians\ne = 0.3  # eccentricity\nE = bh.anomaly_mean_to_eccentric(M, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_mean_to_true","title":"anomaly_mean_to_true  <code>builtin</code>","text":"<pre><code>anomaly_mean_to_true(anm_mean: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts mean anomaly into true anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_mean</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>True anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\n\n# Convert mean to true anomaly (combines Kepler's equation + eccentric anomaly conversion)\nM = 2.0  # mean anomaly in radians\ne = 0.25  # eccentricity\nnu = bh.anomaly_mean_to_true(M, e, bh.AngleFormat.RADIANS)\nprint(f\"True anomaly: {nu:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_eccentric","title":"anomaly_true_to_eccentric  <code>builtin</code>","text":"<pre><code>anomaly_true_to_eccentric(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into eccentric anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Eccentric anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to eccentric anomaly\nnu = math.pi / 3  # 60 degrees true anomaly\ne = 0.2  # eccentricity\nE = bh.anomaly_true_to_eccentric(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Eccentric anomaly: {E:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/keplerian.html#brahe.orbits.anomaly_true_to_mean","title":"anomaly_true_to_mean  <code>builtin</code>","text":"<pre><code>anomaly_true_to_mean(anm_true: float, e: float, angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Converts true anomaly into mean anomaly.</p> <p>Parameters:</p> Name Type Description Default <code>anm_true</code> <code>float</code> <p>True anomaly in radians or degrees.</p> required <code>e</code> <code>float</code> <p>The eccentricity of the astronomical object's orbit (dimensionless).</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Interprets input and returns output in AngleFormat.DEGREES or AngleFormat.RADIANS.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean anomaly in radians or degrees.</p> Example <pre><code>import brahe as bh\nimport math\n\n# Convert true to mean anomaly\nnu = math.pi / 2  # 90 degrees true anomaly\ne = 0.15  # eccentricity\nM = bh.anomaly_true_to_mean(nu, e, bh.AngleFormat.RADIANS)\nprint(f\"Mean anomaly: {M:.4f} radians\")\n</code></pre>"},{"location":"library_api/orbits/tle.html","title":"Two-Line Element (TLE)","text":"<p>Functions for parsing, validating, and converting Two-Line Element sets.</p> <p>For propagating orbits from TLE data, use the <code>SGPPropagator</code> class.</p>"},{"location":"library_api/orbits/tle.html#tle-utility-functions","title":"TLE Utility Functions","text":""},{"location":"library_api/orbits/tle.html#brahe.orbits.epoch_from_tle","title":"epoch_from_tle  <code>builtin</code>","text":"<pre><code>epoch_from_tle(line1: str) -&gt; Epoch\n</code></pre> <p>Extract Epoch from TLE line 1</p> <p>Extracts and parses the epoch timestamp from the first line of TLE data. The epoch is returned in UTC time system.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Extracted epoch in UTC time system</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; line1 = \"1 25544U 98067A   21001.50000000  .00001764  00000-0  40967-4 0  9997\"\n&gt;&gt;&gt; epoch = epoch_from_tle(line1)\n&gt;&gt;&gt; epoch.year()\n2021\n</code></pre>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_from_tle","title":"keplerian_elements_from_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_from_tle(line1: str, line2: str) -&gt; Tuple\n</code></pre> <p>Extract Keplerian orbital elements from TLE lines.</p> <p>Extracts the standard six Keplerian orbital elements from Two-Line Element (TLE) data. Returns elements in standard order: [a, e, i, raan, argp, M] where angles are in radians.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing: - epoch (Epoch): Epoch of the TLE data. - elements (numpy.ndarray): Six Keplerian elements [a, e, i, raan, argp, M] where   a is semi-major axis in meters, e is eccentricity (dimensionless), and   i, raan, argp, M are in radians.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.keplerian_elements_to_tle","title":"keplerian_elements_to_tle  <code>builtin</code>","text":"<pre><code>keplerian_elements_to_tle(epoch: Epoch, elements: ndarray, norad_id: str) -&gt; Tuple\n</code></pre> <p>Convert Keplerian elements to TLE lines.</p> <p>Converts standard Keplerian orbital elements to Two-Line Element (TLE) format. Input angles should be in degrees for compatibility with TLE format.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>elements</code> <code>ndarray</code> <p>Keplerian elements [a (m), e, i (deg), raan (deg), argp (deg), M (deg)].</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.create_tle_lines","title":"create_tle_lines  <code>builtin</code>","text":"<pre><code>create_tle_lines(epoch: Epoch, inclination: float, raan: float, eccentricity: float, arg_perigee: float, mean_anomaly: float, mean_motion: float, norad_id: str, ephemeris_type: int, element_set_number: int, revolution_number: int, classification: str = None, intl_designator: str = None, first_derivative: float = None, second_derivative: float = None, bstar: float = None) -&gt; Tuple\n</code></pre> <p>Create complete TLE lines from all parameters.</p> <p>Creates Two-Line Element (TLE) lines from complete set of orbital and administrative parameters. Provides full control over all TLE fields including derivatives and drag terms.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the elements.</p> required <code>inclination</code> <code>float</code> <p>Inclination in degrees.</p> required <code>raan</code> <code>float</code> <p>Right ascension of ascending node in degrees.</p> required <code>eccentricity</code> <code>float</code> <p>Eccentricity (dimensionless).</p> required <code>arg_perigee</code> <code>float</code> <p>Argument of periapsis in degrees.</p> required <code>mean_anomaly</code> <code>float</code> <p>Mean anomaly in degrees.</p> required <code>mean_motion</code> <code>float</code> <p>Mean motion in revolutions per day.</p> required <code>norad_id</code> <code>str</code> <p>NORAD catalog number (supports numeric and Alpha-5 format).</p> required <code>ephemeris_type</code> <code>int</code> <p>Ephemeris type (0-9).</p> required <code>element_set_number</code> <code>int</code> <p>Element set number.</p> required <code>revolution_number</code> <code>int</code> <p>Revolution number at epoch.</p> required <code>classification</code> <code>str</code> <p>Security classification. Defaults to ' '.</p> <code>None</code> <code>intl_designator</code> <code>str</code> <p>International designator. Defaults to ''.</p> <code>None</code> <code>first_derivative</code> <code>float</code> <p>First derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>second_derivative</code> <code>float</code> <p>Second derivative of mean motion. Defaults to 0.0.</p> <code>None</code> <code>bstar</code> <code>float</code> <p>BSTAR drag term. Defaults to 0.0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (line1, line2) - the two TLE lines as strings.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_line","title":"validate_tle_line  <code>builtin</code>","text":"<pre><code>validate_tle_line(line: str) -&gt; bool\n</code></pre> <p>Validate single TLE line.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line to validate.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the line is valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.validate_tle_lines","title":"validate_tle_lines  <code>builtin</code>","text":"<pre><code>validate_tle_lines(line1: str, line2: str) -&gt; bool\n</code></pre> <p>Validate TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if both lines are valid.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.calculate_tle_line_checksum","title":"calculate_tle_line_checksum  <code>builtin</code>","text":"<pre><code>calculate_tle_line_checksum(line: str) -&gt; int\n</code></pre> <p>Calculate TLE line checksum.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>TLE line.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Checksum value.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.parse_norad_id","title":"parse_norad_id  <code>builtin</code>","text":"<pre><code>parse_norad_id(norad_str: str) -&gt; int\n</code></pre> <p>Parse NORAD ID from string, handling both classic and Alpha-5 formats.</p> <p>Parameters:</p> Name Type Description Default <code>norad_str</code> <code>str</code> <p>NORAD ID string from TLE.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Parsed numeric NORAD ID.</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_numeric_to_alpha5","title":"norad_id_numeric_to_alpha5  <code>builtin</code>","text":"<pre><code>norad_id_numeric_to_alpha5(norad_id: int) -&gt; str\n</code></pre> <p>Convert numeric NORAD ID to Alpha-5 format.</p> <p>Parameters:</p> Name Type Description Default <code>norad_id</code> <code>int</code> <p>Numeric NORAD ID (100000-339999).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p>"},{"location":"library_api/orbits/tle.html#brahe.orbits.norad_id_alpha5_to_numeric","title":"norad_id_alpha5_to_numeric  <code>builtin</code>","text":"<pre><code>norad_id_alpha5_to_numeric(alpha5_id: str) -&gt; int\n</code></pre> <p>Convert Alpha-5 NORAD ID to numeric format.</p> <p>Parameters:</p> Name Type Description Default <code>alpha5_id</code> <code>str</code> <p>Alpha-5 format ID (e.g., \"A0001\").</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric NORAD ID.</p>"},{"location":"library_api/plots/index.html","title":"Plots","text":""},{"location":"library_api/plots/3d_trajectory.html","title":"3D Trajectory Visualization","text":""},{"location":"library_api/plots/3d_trajectory.html#brahe.plot_trajectory_3d","title":"plot_trajectory_3d","text":"<pre><code>plot_trajectory_3d(trajectories, time_range=None, units='km', normalize=False, view_azimuth=45.0, view_elevation=30.0, view_distance=None, show_earth=True, earth_texture='simple', backend='matplotlib') -&gt; object\n</code></pre> <p>Plot 3D trajectory in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d73] or [N\u00d76] (positions in ECI) - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>normalize</code> <code>bool</code> <p>Normalize to Earth radii. Default: False</p> <code>False</code> <code>view_azimuth</code> <code>float</code> <p>Camera azimuth angle (degrees). Default: 45.0</p> <code>45.0</code> <code>view_elevation</code> <code>float</code> <p>Camera elevation angle (degrees). Default: 30.0</p> <code>30.0</code> <code>view_distance</code> <code>float</code> <p>Camera distance from origin. Default: Auto</p> <code>None</code> <code>show_earth</code> <code>bool</code> <p>Show Earth sphere at origin. Default: True</p> <code>True</code> <code>earth_texture</code> <code>str</code> <p>'blue_marble', 'simple', or None. Default: 'simple'</p> <code>'simple'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + bh.orbital_period(oe[0]), 60.0)\n\n# Plot 3D trajectory\nfig = bh.plot_trajectory_3d(\n    [{\"trajectory\": traj, \"color\": \"red\", \"label\": \"LEO Orbit\"}],\n    units='km',\n    show_earth=True,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html","title":"Access Geometry Plotting","text":""},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_polar","title":"plot_access_polar","text":"<pre><code>plot_access_polar(access_windows, min_elevation=0.0, backend='matplotlib') -&gt; object\n</code></pre> <p>Plot access window geometry in polar coordinates (azimuth/elevation).</p> <p>Polar coordinates: - Radius: 90\u00b0 - elevation (zenith at center, horizon at edge) - Theta: Azimuth (North at top, clockwise)</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>min_elevation</code> <code>float</code> <p>Minimum elevation for plot edge (degrees). Default: 0.0</p> <code>0.0</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\n# Compute access\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot first access window\nfig = bh.plot_access_polar(\n    [{\"access_window\": windows[0], \"propagator\": prop, \"label\": \"Pass 1\"}],\n    min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/access_geometry.html#brahe.plot_access_elevation","title":"plot_access_elevation","text":"<pre><code>plot_access_elevation(access_windows, backend='matplotlib') -&gt; object\n</code></pre> <p>Plot elevation angle vs time for access windows.</p> <p>Parameters:</p> Name Type Description Default <code>access_windows</code> <code>list of dict</code> <p>List of access window groups, each with: - access_window: AccessWindow object - propagator (Propagator, optional): Propagator for full trajectory - color (str, optional): Line color - line_width (float, optional): Line width - label (str, optional): Legend label</p> required <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Setup (same as polar plot example)\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0).with_name(\"Satellite\")\nlocation = bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0).with_name(\"NYC\")\nconstraint = bh.ElevationConstraint(min_elevation_deg=10.0)\n\nwindows = bh.location_accesses([location], [prop], epoch, epoch + 86400.0, constraint)\n\n# Plot elevation profile\nfig = bh.plot_access_elevation(\n    [{\"access_window\": w, \"propagator\": prop, \"label\": f\"Pass {i+1}\"} for i, w in enumerate(windows[:3])],\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/ground_tracks.html","title":"Ground Track Plotting","text":""},{"location":"library_api/plots/ground_tracks.html#brahe.plot_groundtrack","title":"plot_groundtrack","text":"<pre><code>plot_groundtrack(trajectories=None, ground_stations=None, zones=None, gs_cone_altitude=500000.0, gs_min_elevation=10.0, basemap='natural_earth', show_borders=True, show_coastlines=True, border_width=0.5, show_grid=False, show_ticks=True, extent=None, backend='matplotlib') -&gt; object\n</code></pre> <p>Plot ground tracks with optional ground stations and polygon zones.</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array - color (str, optional): Line color - line_width (float, optional): Line width - track_length (float, optional): Length of track to display - track_units (str, optional): Units for track_length - \"orbits\" or \"seconds\". Default: \"orbits\"</p> <code>None</code> <code>ground_stations</code> <code>list of dict</code> <p>List of ground station groups, each with: - stations: List of PointLocation or (lat, lon) tuples - color (str, optional): Station and cone color - alpha (float, optional): Cone transparency - point_size (float, optional): Station marker size - show_ring (bool, optional): Show outer ring - ring_color (str, optional): Ring color - ring_width (float, optional): Ring line width</p> <code>None</code> <code>zones</code> <code>list of dict</code> <p>List of polygon zone groups, each with: - zone: PolygonLocation - fill (bool, optional): Fill interior - fill_alpha (float, optional): Fill transparency - fill_color (str, optional): Fill color - edge (bool, optional): Show edge - edge_color (str, optional): Edge color - points (bool, optional): Show vertices</p> <code>None</code> <code>gs_cone_altitude</code> <code>float</code> <p>Assumed satellite altitude for cone calculation (m). Default: 500e3</p> <code>500000.0</code> <code>gs_min_elevation</code> <code>float</code> <p>Minimum elevation angle (degrees). Default: 10.0</p> <code>10.0</code> <code>basemap</code> <code>str</code> <p>Basemap style - \"natural_earth\", \"stock\", or None. Default: \"natural_earth\"</p> <code>'natural_earth'</code> <code>show_borders</code> <code>bool</code> <p>Show country borders. Default: True</p> <code>True</code> <code>show_coastlines</code> <code>bool</code> <p>Show coastlines. Default: True</p> <code>True</code> <code>border_width</code> <code>float</code> <p>Border line width. Default: 0.5</p> <code>0.5</code> <code>show_grid</code> <code>bool</code> <p>Show lat/lon grid. Default: False</p> <code>False</code> <code>show_ticks</code> <code>bool</code> <p>Show lat/lon tick marks. Default: True</p> <code>True</code> <code>extent</code> <code>list</code> <p>[lon_min, lon_max, lat_min, lat_max] to zoom. Default: None (global)</p> <code>None</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create a simple LEO trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Define ground stations\nstations_aws = [\n    bh.PointLocation(np.radians(40.7128), np.radians(-74.0060), 0.0),  # NYC\n    bh.PointLocation(np.radians(37.7749), np.radians(-122.4194), 0.0),  # SF\n]\n\nstations_ksat = [\n    bh.PointLocation(np.radians(78.2232), np.radians(15.6267), 0.0),  # Svalbard\n]\n\n# Plot with per-group configuration\nfig = bh.plot_groundtrack(\n    trajectories=[{\"trajectory\": traj, \"color\": \"red\", \"track_length\": 2, \"track_units\": \"orbits\"}],\n    ground_stations=[\n        {\"stations\": stations_aws, \"color\": \"orange\", \"alpha\": 0.3},\n        {\"stations\": stations_ksat, \"color\": \"blue\", \"alpha\": 0.3},\n    ],\n    gs_cone_altitude=500e3,\n    gs_min_elevation=10.0,\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html","title":"Orbital Trajectory Plotting","text":""},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_cartesian_trajectory","title":"plot_cartesian_trajectory","text":"<pre><code>plot_cartesian_trajectory(trajectories, time_range=None, position_units='km', velocity_units='km/s', backend='matplotlib') -&gt; object\n</code></pre> <p>Plot Cartesian orbital elements (position and velocity) vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: x, y, z positions - Row 2: vx, vy, vz velocities</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>position_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>velocity_units</code> <code>str</code> <p>'m/s' or 'km/s'. Default: 'km/s'</p> <code>'km/s'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Cartesian elements\nfig = bh.plot_cartesian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    position_units='km',\n    velocity_units='km/s',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/plots/orbital_trajectories.html#brahe.plot_keplerian_trajectory","title":"plot_keplerian_trajectory","text":"<pre><code>plot_keplerian_trajectory(trajectories, time_range=None, angle_units='deg', sma_units='km', backend='matplotlib') -&gt; object\n</code></pre> <p>Plot Keplerian orbital elements vs time.</p> <p>Creates a 2x3 subplot layout: - Row 1: a (semi-major axis), e (eccentricity), i (inclination) - Row 2: \u03a9 (RAAN), \u03c9 (argument of periapsis), \u03bd (true anomaly)</p> <p>Parameters:</p> Name Type Description Default <code>trajectories</code> <code>list of dict</code> <p>List of trajectory groups, each with: - trajectory: OrbitTrajectory or numpy array [N\u00d76] or [N\u00d77] as [a, e, i, \u03a9, \u03c9, \u03bd] - times (np.ndarray, optional): Time array if trajectory is numpy array without time column - color (str, optional): Line/marker color - marker (str, optional): Marker style - label (str, optional): Legend label</p> required <code>time_range</code> <code>tuple</code> <p>(start_epoch, end_epoch) to filter data</p> <code>None</code> <code>angle_units</code> <code>str</code> <p>'rad' or 'deg'. Default: 'deg'</p> <code>'deg'</code> <code>sma_units</code> <code>str</code> <p>'m' or 'km'. Default: 'km'</p> <code>'km'</code> <code>backend</code> <code>str</code> <p>'matplotlib' or 'plotly'. Default: 'matplotlib'</p> <code>'matplotlib'</code> <p>Returns:</p> Type Description <code>object</code> <p>Generated figure object</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory\neop = bh.FileEOPProvider.from_default_standard(bh.EarthOrientationFileType.STANDARD, True)\nbh.set_global_eop_provider(eop)\n\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\n\nprop = bh.KeplerianPropagator.from_eci(epoch, state, 60.0)\ntraj = prop.propagate(epoch, epoch + 2*bh.orbital_period(oe[0]), 60.0)\n\n# Plot Keplerian elements\nfig = bh.plot_keplerian_trajectory(\n    [{\"trajectory\": traj, \"label\": \"LEO Orbit\"}],\n    angle_units='deg',\n    sma_units='km',\n    backend='matplotlib'\n)\n</code></pre>"},{"location":"library_api/propagators/index.html","title":"Propagators","text":"<p>Module: <code>brahe.propagators</code></p> <p>Orbit propagators for predicting satellite positions over time.</p>"},{"location":"library_api/propagators/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>KeplerianPropagator - Analytical two-body orbit propagator</li> <li>SGPPropagator - SGP4/SDP4 orbit propagator for TLE data</li> </ul>"},{"location":"library_api/propagators/keplerian_propagator.html","title":"Keplerian Propagator","text":"<p>Analytical two-body orbit propagator using Keplerian orbital elements.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator","title":"KeplerianPropagator","text":"<pre><code>KeplerianPropagator()\n</code></pre> <p>Python wrapper for KeplerianPropagator (new architecture) Keplerian orbit propagator using two-body dynamics.</p> <p>The Keplerian propagator implements ideal two-body orbital mechanics without perturbations. It's fast and accurate for short time spans but doesn't account for real-world effects like drag, J2, solar radiation pressure, etc.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Initial epoch and orbital elements\nepc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\n\n# Create propagator from Keplerian elements\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\n)\n\n# Propagate forward one orbit\nperiod = bh.orbital_period(oe[0])\nepc_future = epc0 + period\nstate = prop.state(epc_future)\nprint(f\"State after one orbit: {state}\")\n\n# Create from Cartesian state\nx_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\nprop2 = bh.KeplerianPropagator(\n    epc0, x_cart, bh.OrbitFrame.ECI,\n    bh.OrbitRepresentation.CARTESIAN,\n    bh.AngleFormat.RADIANS, 60.0\n)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for KeplerianPropagator (new architecture)\\nKeplerian orbit propagator using two-body dynamics.\\n\\nThe Keplerian propagator implements ideal two-body orbital mechanics without\\nperturbations. It\\'s fast and accurate for short time spans but doesn\\'t account\\nfor real-world effects like drag, J2, solar radiation pressure, etc.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    import numpy as np\\n\\n    # Initial epoch and orbital elements\\n    epc0 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    oe = np.array([7000000.0, 0.001, 0.9, 0.0, 0.0, 0.0])  # a, e, i, RAAN, omega, M\\n\\n    # Create propagator from Keplerian elements\\n    prop = bh.KeplerianPropagator.from_keplerian(\\n        epc0, oe, bh.AngleFormat.RADIANS, step_size=60.0\\n    )\\n\\n    # Propagate forward one orbit\\n    period = bh.orbital_period(oe[0])\\n    epc_future = epc0 + period\\n    state = prop.state(epc_future)\\n    print(f\"State after one orbit: {state}\")\\n\\n    # Create from Cartesian state\\n    x_cart = np.array([7000000.0, 0.0, 0.0, 0.0, 7546.0, 0.0])\\n    prop2 = bh.KeplerianPropagator(\\n        epc0, x_cart, bh.OrbitFrame.ECI,\\n        bh.OrbitRepresentation.CARTESIAN,\\n        bh.AngleFormat.RADIANS, 60.0\\n    )\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_epoch","title":"initial_epoch  <code>property</code>","text":"<pre><code>initial_epoch: Epoch\n</code></pre> <p>Get initial epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Initial propagator epoch.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\ntraj = prop.trajectory\nprint(f\"Trajectory contains {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_ecef","title":"from_ecef  <code>builtin</code>","text":"<pre><code>from_ecef(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECEF frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECEF frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_eci","title":"from_eci  <code>builtin</code>","text":"<pre><code>from_eci(epoch: Epoch, state: ndarray, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Cartesian state in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>6-element Cartesian state [x, y, z, vx, vy, vz] in ECI frame.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.from_keplerian","title":"from_keplerian  <code>builtin</code>","text":"<pre><code>from_keplerian(epoch: Epoch, elements: ndarray, angle_format: AngleFormat, step_size: float) -&gt; KeplerianPropagator\n</code></pre> <p>Create a new Keplerian propagator from Keplerian orbital elements.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>elements</code> <code>ndarray</code> <p>6-element Keplerian elements [a, e, i, raan, argp, mean_anomaly].</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format (Degrees or Radians).</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>New propagator instance.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)  # Take 10 steps (600 seconds total)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 3600.0  # Propagate to 1 hour ahead\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.propagate_steps(10)\nprop.reset()  # Return to initial epoch and state\nprint(f\"Reset to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_age(3600.0)  # Keep only states within 1 hour\nprop.propagate_to(epc + 7200.0)  # Propagate 2 hours\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.set_eviction_policy_max_size(100)  # Keep only 100 most recent states\nprop.propagate_steps(200)\nprint(f\"Trajectory length: {prop.trajectory.len()}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int or None) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_initial_conditions","title":"set_initial_conditions  <code>method descriptor</code>","text":"<pre><code>set_initial_conditions(epoch: Epoch, state: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat) -&gt; Any\n</code></pre> <p>Set initial conditions.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Initial epoch.</p> required <code>state</code> <code>ndarray</code> <p>Initial state vector.</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame.</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Angle format.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\n\n# Change initial conditions to a different orbit\nnew_oe = np.array([bh.R_EARTH + 800e3, 0.02, 1.2, 0.5, 0.3, 0.0])\nnew_state = bh.state_osculating_to_cartesian(new_oe, bh.AngleFormat.RADIANS)\nnew_epc = bh.Epoch.from_datetime(2024, 1, 2, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprop.set_initial_conditions(new_epc, new_state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, bh.AngleFormat.RADIANS)\nprint(f\"New initial epoch: {prop.initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str or None) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Compute state as osculating elements at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating elements [a, e, i, raan, argp, mean_anomaly].</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's native format.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_as_osculating_elements","title":"states_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>states_as_osculating_elements(epochs: list[Epoch], angle_format: AngleFormat) -&gt; List\n</code></pre> <p>Compute states as osculating elements at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <code>angle_format</code> <code>AngleFormat</code> <p>If AngleFormat.DEGREES, angular elements are returned in degrees, otherwise in radians.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of osculating element vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_ecef","title":"states_ecef  <code>method descriptor</code>","text":"<pre><code>states_ecef(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECEF state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step()  # Advance by default step_size (60 seconds)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\nprop.step_by(120.0)  # Advance by 120 seconds\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.01, 0.9, 1.0, 0.5, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\nprop = bh.KeplerianPropagator(epc, state, bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None, 60.0)\ntarget = epc + 300.0  # Target 5 minutes ahead\nprop.step_past(target)\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; KeplerianPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; KeplerianPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with identity set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\noe = np.array([7000e3, 0.001, 0.9, 0.0, 0.0, 0.0])\nprop = bh.KeplerianPropagator.from_keplerian(\n    epc, oe, bh.AngleFormat.RADIANS, 60.0\n).with_name(\"My Orbit\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; KeplerianPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#brahe.KeplerianPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; KeplerianPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>KeplerianPropagator</code> <code>KeplerianPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/keplerian_propagator.html#overview","title":"Overview","text":"<p>The Keplerian propagator provides fast, analytical orbit propagation for unperturbed two-body motion. It uses closed-form solutions to Kepler's equations for orbital element propagation.</p> <p>Key Features: - Fast analytical propagation (no numerical integration) - Perfect for preliminary analysis and mission design - No perturbations (atmospheric drag, J2, third-body, etc.) - Suitable for high-altitude orbits where perturbations are minimal</p> <p>Module: <code>brahe.orbits</code></p> <p>When to Use: - Preliminary orbit analysis - High-altitude orbits (GEO, cislunar) - Short propagation times where perturbations are negligible - Educational purposes</p> <p>When NOT to Use: - LEO orbits requiring accuracy beyond a few days - When atmospheric drag is significant - When J2 perturbations matter - Precise orbit determination applications</p>"},{"location":"library_api/propagators/keplerian_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Initial orbital elements [a, e, i, \u03a9, \u03c9, M] in SI units (m, rad)\n# Example: Geostationary orbit\na = 42164000.0        # Semi-major axis (m)\ne = 0.0001            # Eccentricity\ni = 0.0 * bh.DEG2RAD  # Inclination (rad)\nraan = 0.0            # Right ascension of ascending node (rad)\nargp = 0.0            # Argument of periapsis (rad)\nM = 0.0               # Mean anomaly (rad)\n\nelements = np.array([a, e, i, raan, argp, M])\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Create propagator\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI,\n    gm=bh.GM_EARTH\n)\n\n# Propagate to a future time\nfuture_epoch = epoch + 86400.0  # 1 day later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz]\n\n# Propagate to multiple times\ntimes = np.linspace(0, 7*86400, 100)  # 1 week in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)\n\nprint(f\"Propagated to {len(states)} epochs\")\nprint(f\"Final position: {states[-1][:3]} m\")\n</code></pre>"},{"location":"library_api/propagators/keplerian_propagator.html#orbital-elements","title":"Orbital Elements","text":"<p>The propagator accepts orbital elements in the following order: 1. a - Semi-major axis (meters) 2. e - Eccentricity (dimensionless) 3. i - Inclination (radians) 4. \u03a9 - Right ascension of ascending node (radians) 5. \u03c9 - Argument of periapsis (radians) 6. M or \u03bd - Mean anomaly or true anomaly (radians)</p> <p>Use <code>OrbitRepresentation</code> to specify element type: - <code>MEAN_ELEMENTS</code> - Mean orbital elements with mean anomaly - <code>OSCULATING_ELEMENTS</code> - Osculating elements with true anomaly</p>"},{"location":"library_api/propagators/keplerian_propagator.html#see-also","title":"See Also","text":"<ul> <li>SGPPropagator - SGP4/SDP4 propagator for TLE data</li> <li>Keplerian Elements - Orbital element conversion functions</li> <li>OrbitRepresentation - Element type specification</li> </ul>"},{"location":"library_api/propagators/sgp_propagator.html","title":"SGP Propagator","text":"<p>The SGP4/SDP4 propagator for satellite orbit propagation using Two-Line Element (TLE) data.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator","title":"SGPPropagator","text":"<pre><code>SGPPropagator()\n</code></pre> <p>Python wrapper for SGPPropagator (replaces TLE) SGP4/SDP4 satellite propagator using TLE data.</p> <p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using Two-Line Element (TLE) orbital data. This is the standard model used for tracking objects in Earth orbit.</p> Example <pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\n\n# Propagate to a specific epoch\nepc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_eci = prop.state(epc)\nprint(f\"Position: {state_eci[:3]}\")\nprint(f\"Velocity: {state_eci[3:]}\")\n\n# Propagate multiple epochs\nepochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\nstates = prop.states(epochs)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Python wrapper for SGPPropagator (replaces TLE)\\nSGP4/SDP4 satellite propagator using TLE data.\\n\\nThe SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models\\nfor propagating satellites using Two-Line Element (TLE) orbital data. This is the standard\\nmodel used for tracking objects in Earth orbit.\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n\\n    # ISS TLE data (example)\\n    line1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\\n    line2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\\n\\n    # Create propagator\\n    prop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\\n\\n    # Propagate to a specific epoch\\n    epc = bh.Epoch.from_datetime(2024, 1, 2, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\\n    state_eci = prop.state(epc)\\n    print(f\"Position: {state_eci[:3]}\")\\n    print(f\"Velocity: {state_eci[3:]}\")\\n\\n    # Propagate multiple epochs\\n    epochs = [epc + i*60.0 for i in range(10)]  # 10 minutes\\n    states = prop.states(epochs)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_epoch","title":"current_epoch  <code>property</code>","text":"<pre><code>current_epoch: Epoch\n</code></pre> <p>Get current epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Current propagator epoch.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\npropagator.step()\nprint(f\"Current epoch: {propagator.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.epoch","title":"epoch  <code>property</code>","text":"<pre><code>epoch: Epoch\n</code></pre> <p>Get TLE epoch.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch of the TLE data.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.id","title":"id  <code>property</code>","text":"<pre><code>id: int\n</code></pre> <p>Get the current numeric ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>int or None: The numeric ID, or None if not set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the current name.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The name, or None if not set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.norad_id","title":"norad_id  <code>property</code>","text":"<pre><code>norad_id: int\n</code></pre> <p>Get NORAD ID.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>NORAD catalog ID.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.satellite_name","title":"satellite_name  <code>property</code>","text":"<pre><code>satellite_name: str\n</code></pre> <p>Get satellite name (if available).</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: Satellite name if provided.</p> Example <pre><code>import brahe as bh\n\nname = \"ISS (ZARYA)\"\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_3le(name, line1, line2)\nprint(f\"Satellite: {propagator.satellite_name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_size","title":"step_size  <code>property</code>","text":"<pre><code>step_size: float\n</code></pre> <p>Get step size in seconds.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Step size in seconds.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\npropagator = bh.SGPPropagator.from_tle(line1, line2)\nprint(f\"Step size: {propagator.step_size} seconds\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory: OrbitTrajectory\n</code></pre> <p>Get accumulated trajectory.</p> <p>Returns:</p> Name Type Description <code>OrbitalTrajectory</code> <code>OrbitTrajectory</code> <p>The accumulated trajectory.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.propagate_steps(100)\ntraj = prop.trajectory\nprint(f\"Trajectory has {traj.len()} states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.uuid","title":"uuid  <code>property</code>","text":"<pre><code>uuid: str\n</code></pre> <p>Get the current UUID.</p> <p>Returns:</p> Type Description <code>str</code> <p>str or None: The UUID as a string, or None if not set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.current_state","title":"current_state  <code>method descriptor</code>","text":"<pre><code>current_state() -&gt; ndarray\n</code></pre> <p>Get current state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Current state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_3le","title":"from_3le  <code>builtin</code>","text":"<pre><code>from_3le(name: str, line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from 3-line TLE format (with satellite name).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Satellite name (line 0).</p> required <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.from_tle","title":"from_tle  <code>builtin</code>","text":"<pre><code>from_tle(line1: str, line2: str, step_size: float = 60.0) -&gt; SGPPropagator\n</code></pre> <p>Create a new SGP propagator from TLE lines.</p> <p>Parameters:</p> Name Type Description Default <code>line1</code> <code>str</code> <p>First line of TLE data.</p> required <code>line2</code> <code>str</code> <p>Second line of TLE data.</p> required <code>step_size</code> <code>float</code> <p>Step size in seconds for propagation. Defaults to 60.0.</p> <code>60.0</code> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>New SGP propagator instance.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.generate_uuid","title":"generate_uuid  <code>method descriptor</code>","text":"<pre><code>generate_uuid() -&gt; Any\n</code></pre> <p>Generate a new UUID and set it in-place (mutating).</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.get_elements","title":"get_elements  <code>method descriptor</code>","text":"<pre><code>get_elements(angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get Keplerian orbital elements from TLE data.</p> <p>Extracts the Keplerian elements directly from the TLE lines used to initialize this propagator.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for angular elements (DEGREES or RADIANS).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Keplerian elements [a, e, i, \u03a9, \u03c9, M] where: - a: semi-major axis [m] - e: eccentricity [dimensionless] - i: inclination [rad or deg] - \u03a9: right ascension of ascending node [rad or deg] - \u03c9: argument of periapsis [rad or deg] - M: mean anomaly [rad or deg]</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927\"\nline2 = \"2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get elements in degrees\noe_deg = prop.get_elements(bh.AngleFormat.DEGREES)\nprint(f\"Inclination: {oe_deg[2]:.4f} degrees\")\n\n# Get elements in radians\noe_rad = prop.get_elements(bh.AngleFormat.RADIANS)\nprint(f\"Inclination: {oe_rad[2]:.4f} radians\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.initial_state","title":"initial_state  <code>method descriptor</code>","text":"<pre><code>initial_state() -&gt; ndarray\n</code></pre> <p>Get initial state vector.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Initial state vector in the propagator's output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_steps","title":"propagate_steps  <code>method descriptor</code>","text":"<pre><code>propagate_steps(num_steps: int) -&gt; Any\n</code></pre> <p>Propagate forward by specified number of steps.</p> <p>Parameters:</p> Name Type Description Default <code>num_steps</code> <code>int</code> <p>Number of steps to take.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2, step_size=60.0)\nprop.propagate_steps(10)  # Advance by 10 steps (600 seconds)\nprint(f\"After 10 steps: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.propagate_to","title":"propagate_to  <code>method descriptor</code>","text":"<pre><code>propagate_to(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Propagate to a specific target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to propagate to.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 7200.0  # 2 hours later\nprop.propagate_to(target)\nprint(f\"Propagated to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.reset","title":"reset  <code>method descriptor</code>","text":"<pre><code>reset() -&gt; Any\n</code></pre> <p>Reset propagator to initial conditions.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ninitial_epoch = prop.epoch\nprop.propagate_steps(100)\nprop.reset()\nprint(f\"Reset to: {prop.current_epoch == initial_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds to keep states in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_age(86400.0)  # Keep 1 day of history\nprint(\"Trajectory limited to 24 hours of states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set trajectory eviction policy based on maximum size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to keep in trajectory.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.set_eviction_policy_max_size(1000)\nprint(\"Trajectory limited to 1000 states\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_id","title":"set_id  <code>method descriptor</code>","text":"<pre><code>set_id(id: int or None) -&gt; Any\n</code></pre> <p>Set the numeric ID in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int or None</code> <p>Numeric ID to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_identity","title":"set_identity  <code>method descriptor</code>","text":"<pre><code>set_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; Any\n</code></pre> <p>Set all identity fields in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_name","title":"set_name  <code>method descriptor</code>","text":"<pre><code>set_name(name: str or None) -&gt; Any\n</code></pre> <p>Set the name in-place (mutating).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Name to assign, or None to clear.</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.set_output_format","title":"set_output_format  <code>method descriptor</code>","text":"<pre><code>set_output_format(frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None) -&gt; Any\n</code></pre> <p>Set output format (frame, representation, and angle format).</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>OrbitFrame</code> <p>Output frame (ECI or ECEF).</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>Output representation (Cartesian or Keplerian).</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian (None for Cartesian).</p> required"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in ECI frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.state_pef","title":"state_pef  <code>method descriptor</code>","text":"<pre><code>state_pef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Compute state at a specific epoch in PEF coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch for state computation.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector [x, y, z, vx, vy, vz] in PEF frame.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of state vectors in the propagator's current output format.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.states_eci","title":"states_eci  <code>method descriptor</code>","text":"<pre><code>states_eci(epochs: list[Epoch]) -&gt; List\n</code></pre> <p>Compute states at multiple epochs in ECI coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of epochs for state computation.</p> required <p>Returns:</p> Type Description <code>List</code> <p>list[numpy.ndarray]: List of ECI state vectors.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step","title":"step  <code>method descriptor</code>","text":"<pre><code>step() -&gt; Any\n</code></pre> <p>Step forward by the default step size.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step()  # Advance by default step_size\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_by","title":"step_by  <code>method descriptor</code>","text":"<pre><code>step_by(step_size: float) -&gt; Any\n</code></pre> <p>Step forward by a specified time duration.</p> <p>Parameters:</p> Name Type Description Default <code>step_size</code> <code>float</code> <p>Time step in seconds.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\nprop.step_by(120.0)  # Advance by 2 minutes\nprint(f\"Advanced to: {prop.current_epoch}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.step_past","title":"step_past  <code>method descriptor</code>","text":"<pre><code>step_past(target_epoch: Epoch) -&gt; Any\n</code></pre> <p>Step past a specified target epoch.</p> <p>Parameters:</p> Name Type Description Default <code>target_epoch</code> <code>Epoch</code> <p>The epoch to step past.</p> required Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2)\ntarget = prop.epoch + 3600.0  # 1 hour later\nprop.step_past(target)\nprint(f\"Stepped past target\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_id","title":"with_id  <code>method descriptor</code>","text":"<pre><code>with_id(id: int) -&gt; SGPPropagator\n</code></pre> <p>Set the numeric ID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Numeric ID to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with ID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_identity","title":"with_identity  <code>method descriptor</code>","text":"<pre><code>with_identity(name: str or None, uuid_str: str or None, id: int or None) -&gt; SGPPropagator\n</code></pre> <p>Set all identity fields at once and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str or None</code> <p>Optional name to assign.</p> required <code>uuid_str</code> <code>str or None</code> <p>Optional UUID string to assign.</p> required <code>id</code> <code>int or None</code> <p>Optional numeric ID to assign.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with identity set.</p> Example <pre><code>import brahe as bh\nimport uuid\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nmy_uuid = str(uuid.uuid4())\nprop = bh.SGPPropagator.from_tle(line1, line2).with_identity(\"ISS\", my_uuid, 25544)\nprint(f\"Name: {prop.name}, ID: {prop.id}, UUID: {prop.uuid}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_name","title":"with_name  <code>method descriptor</code>","text":"<pre><code>with_name(name: str) -&gt; SGPPropagator\n</code></pre> <p>Set the name and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with name set.</p> Example <pre><code>import brahe as bh\n\nline1 = \"1 25544U 98067A   21027.77992426  .00003336  00000-0  68893-4 0  9990\"\nline2 = \"2 25544  51.6461 339.8014 0002571  24.9690  60.4407 15.48919393267689\"\nprop = bh.SGPPropagator.from_tle(line1, line2).with_name(\"My Satellite\")\nprint(f\"Name: {prop.name}\")\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_new_uuid","title":"with_new_uuid  <code>method descriptor</code>","text":"<pre><code>with_new_uuid() -&gt; SGPPropagator\n</code></pre> <p>Generate a new UUID, set it, and return self (consuming constructor pattern).</p> <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with new UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#brahe.SGPPropagator.with_uuid","title":"with_uuid  <code>method descriptor</code>","text":"<pre><code>with_uuid(uuid_str: str) -&gt; SGPPropagator\n</code></pre> <p>Set the UUID and return self (consuming constructor pattern).</p> <p>Parameters:</p> Name Type Description Default <code>uuid_str</code> <code>str</code> <p>UUID string to assign to this propagator.</p> required <p>Returns:</p> Name Type Description <code>SGPPropagator</code> <code>SGPPropagator</code> <p>Self with UUID set.</p>"},{"location":"library_api/propagators/sgp_propagator.html#overview","title":"Overview","text":"<p>The SGP (Simplified General Perturbations) propagator implements the SGP4/SDP4 models for propagating satellites using TLE orbital data. This is the standard model used for tracking objects in Earth orbit and is maintained by NORAD/Space Force.</p> <p>Key Features: - Industry-standard orbit propagation - Atmospheric drag modeling - Automatic selection between SGP4 (near-Earth) and SDP4 (deep-space) models - Compatible with standard TLE format</p> <p>Module: <code>brahe.orbits</code></p>"},{"location":"library_api/propagators/sgp_propagator.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\n\n# ISS TLE data (example)\nline1 = \"1 25544U 98067A   24001.50000000  .00016717  00000-0  30000-3 0  9005\"\nline2 = \"2 25544  51.6400 150.0000 0003000 100.0000 260.0000 15.50000000300000\"\n\n# Create propagator from TLE\nprop = bh.SGPPropagator.from_tle(line1, line2)\n\n# Get current epoch\nepoch = prop.epoch()\n\n# Propagate to a specific time\nfuture_epoch = epoch + 3600.0  # 1 hour later\nstate = prop.propagate(future_epoch)  # Returns [x, y, z, vx, vy, vz] in TEME frame\n\n# Propagate to multiple times\nimport numpy as np\ntimes = np.linspace(0, 86400, 100)  # 1 day in 100 steps\nepochs = [epoch + dt for dt in times]\nstates = prop.propagate_multiple(epochs)  # Returns array of states\n</code></pre>"},{"location":"library_api/propagators/sgp_propagator.html#see-also","title":"See Also","text":"<ul> <li>KeplerianPropagator - Analytical two-body propagator</li> <li>TLE - Two-Line Element format details</li> <li>Keplerian Elements - Orbital element functions</li> </ul>"},{"location":"library_api/time/index.html","title":"Time","text":"<p>Module: <code>brahe.time</code></p> <p>High-precision time system management and conversions.</p>"},{"location":"library_api/time/index.html#sub-modules","title":"Sub-modules","text":"<ul> <li>Epoch Class - Core time representation supporting multiple time systems</li> <li>Time Conversions - Functions for converting between time systems and formats</li> </ul>"},{"location":"library_api/time/conversions.html","title":"Time Conversions","text":"<p>Functions for converting between different time systems and formats.</p>"},{"location":"library_api/time/conversions.html#time-system-offset-functions","title":"Time System Offset Functions","text":""},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_mjd","title":"time_system_offset_for_mjd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_mjd(mjd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from UTC to TAI at J2000 epoch\nmjd_j2000 = 51544.0\noffset = bh.time_system_offset_for_mjd(mjd_j2000, bh.TimeSystem.UTC, bh.TimeSystem.TAI)\nprint(f\"UTC to TAI offset: {offset} seconds\")\n# Output: UTC to TAI offset: 32.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_jd","title":"time_system_offset_for_jd  <code>builtin</code>","text":"<pre><code>time_system_offset_for_jd(jd: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from GPS to UTC at a specific Julian Date\njd = 2460000.0\noffset = bh.time_system_offset_for_jd(jd, bh.TimeSystem.GPS, bh.TimeSystem.UTC)\nprint(f\"GPS to UTC offset: {offset} seconds\")\n# Output: GPS to UTC offset: -18.0 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.time_system_offset_for_datetime","title":"time_system_offset_for_datetime  <code>builtin</code>","text":"<pre><code>time_system_offset_for_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system_src: TimeSystem, time_system_dst: TimeSystem) -&gt; float\n</code></pre> <p>Calculate the offset between two time systems for a given Gregorian calendar date.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system_src</code> <code>TimeSystem</code> <p>Source time system</p> required <code>time_system_dst</code> <code>TimeSystem</code> <p>Destination time system</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Offset between time systems in seconds</p> Example <pre><code>import brahe as bh\n\n# Get offset from TT to TAI on January 1, 2024\noffset = bh.time_system_offset_for_datetime(\n    2024, 1, 1, 0, 0, 0.0, 0.0,\n    bh.TimeSystem.TT, bh.TimeSystem.TAI\n)\nprint(f\"TT to TAI offset: {offset} seconds\")\n# Output: TT to TAI offset: -32.184 seconds\n</code></pre>"},{"location":"library_api/time/conversions.html#datetime-conversion-functions","title":"DateTime Conversion Functions","text":""},{"location":"library_api/time/conversions.html#brahe.datetime_to_jd","title":"datetime_to_jd  <code>builtin</code>","text":"<pre><code>datetime_to_jd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Julian Date\njd = bh.datetime_to_jd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460311.000000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.datetime_to_mjd","title":"datetime_to_mjd  <code>builtin</code>","text":"<pre><code>datetime_to_mjd(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float) -&gt; float\n</code></pre> <p>Convert a Gregorian calendar date to the equivalent Modified Julian Date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified Julian date of epoch</p> Example <pre><code>import brahe as bh\n\n# Convert January 1, 2024 noon to Modified Julian Date\nmjd = bh.datetime_to_mjd(2024, 1, 1, 12, 0, 0.0, 0.0)\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.500000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.jd_to_datetime","title":"jd_to_datetime  <code>builtin</code>","text":"<pre><code>jd_to_datetime(jd: float) -&gt; Tuple\n</code></pre> <p>Convert a Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Julian Date to Gregorian calendar\njd = 2460311.0\nyear, month, day, hour, minute, second, nanosecond = bh.jd_to_datetime(jd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/conversions.html#brahe.mjd_to_datetime","title":"mjd_to_datetime  <code>builtin</code>","text":"<pre><code>mjd_to_datetime(mjd: float) -&gt; Tuple\n</code></pre> <p>Convert a Modified Julian Date to the equivalent Gregorian calendar date.</p> <p>Note: Due to the ambiguity of the nature of leap second insertion, this method should not be used if a specific behavior for leap second insertion is expected. This method treats leap seconds as if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Convert Modified Julian Date to Gregorian calendar\nmjd = 60310.5\nyear, month, day, hour, minute, second, nanosecond = bh.mjd_to_datetime(mjd)\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-01-01 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html","title":"Epoch Class","text":"<p>The <code>Epoch</code> class is the foundational time representation in Brahe, providing comprehensive support for multiple time systems and high-precision time computations with nanosecond accuracy.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch","title":"Epoch","text":"<pre><code>Epoch()\n</code></pre> <p>Represents a specific instant in time.</p> <p>Epoch is the primary and preferred mechanism for representing time in brahe. It accurately represents, tracks, and compares instants in time with nanosecond precision.</p> <p>Internally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation was chosen to enable accurate time system conversions using the IAU SOFA library (which operates in days and fractional days) while maintaining high precision for small time differences. The structure uses Kahan summation to accurately handle running sums over long periods without losing accuracy to floating-point rounding errors.</p> <p>All arithmetic operations (addition, subtraction) use seconds as the default unit and return time differences in seconds.</p> <p>The Epoch constructor accepts multiple input formats for convenience:</p> <ul> <li>Date components: <code>Epoch(year, month, day)</code> - creates epoch at midnight</li> <li>Full datetime: <code>Epoch(year, month, day, hour, minute, second, nanosecond)</code> - full precision</li> <li>Partial datetime: <code>Epoch(year, month, day, hour)</code> or <code>Epoch(year, month, day, hour, minute)</code> etc.</li> <li>ISO 8601 string: <code>Epoch(\"2024-01-01T12:00:00Z\")</code> - parse from string</li> <li>Python datetime: <code>Epoch(datetime_obj)</code> - convert from Python datetime</li> <li>Copy constructor: <code>Epoch(other_epoch)</code> - create a copy</li> <li>Time system: All constructors accept optional <code>time_system=</code> keyword argument (default: UTC)</li> </ul> Example <pre><code>import brahe as bh\nfrom datetime import datetime\n\n# Multiple ways to create the same epoch\nepc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\nepc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\nepc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\nprint(epc1)\n# Output: 2024-01-01 12:00:00.000 UTC\n\n# Create epoch at midnight\nmidnight = bh.Epoch(2024, 1, 1)\nprint(midnight)\n# Output: 2024-01-01 00:00:00.000 UTC\n\n# Use different time systems\ngps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\nprint(gps_time)\n# Output: 2024-01-01 12:00:00.000 GPS\n\n# Perform arithmetic operations\nepoch2 = epc1 + 3600.0  # Add one hour (in seconds)\ndiff = epoch2 - epc1     # Difference in seconds\nprint(f\"Time difference: {diff} seconds\")\n# Output: Time difference: 3600.0 seconds\n\n# Legacy constructors still available\nepc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nepc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\n</code></pre> <p>Initialize instance.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Represents a specific instant in time.\\n\\nEpoch is the primary and preferred mechanism for representing time in brahe.\\nIt accurately represents, tracks, and compares instants in time with nanosecond precision.\\n\\nInternally, Epoch stores time in terms of days, seconds, and nanoseconds. This representation\\nwas chosen to enable accurate time system conversions using the IAU SOFA library (which operates\\nin days and fractional days) while maintaining high precision for small time differences.\\nThe structure uses Kahan summation to accurately handle running sums over long periods without\\nlosing accuracy to floating-point rounding errors.\\n\\nAll arithmetic operations (addition, subtraction) use seconds as the default unit and return\\ntime differences in seconds.\\n\\nThe Epoch constructor accepts multiple input formats for convenience:\\n\\n- **Date components**: `Epoch(year, month, day)` - creates epoch at midnight\\n- **Full datetime**: `Epoch(year, month, day, hour, minute, second, nanosecond)` - full precision\\n- **Partial datetime**: `Epoch(year, month, day, hour)` or `Epoch(year, month, day, hour, minute)` etc.\\n- **ISO 8601 string**: `Epoch(\"2024-01-01T12:00:00Z\")` - parse from string\\n- **Python datetime**: `Epoch(datetime_obj)` - convert from Python datetime\\n- **Copy constructor**: `Epoch(other_epoch)` - create a copy\\n- **Time system**: All constructors accept optional `time_system=` keyword argument (default: UTC)\\n\\nExample:\\n    ```python\\n    import brahe as bh\\n    from datetime import datetime\\n\\n    # Multiple ways to create the same epoch\\n    epc1 = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0)\\n    epc2 = bh.Epoch(\"2024-01-01 12:00:00.000 UTC\")\\n    epc3 = bh.Epoch(datetime(2024, 1, 1, 12, 0, 0))\\n    print(epc1)\\n    # Output: 2024-01-01 12:00:00.000 UTC\\n\\n    # Create epoch at midnight\\n    midnight = bh.Epoch(2024, 1, 1)\\n    print(midnight)\\n    # Output: 2024-01-01 00:00:00.000 UTC\\n\\n    # Use different time systems\\n    gps_time = bh.Epoch(2024, 1, 1, 12, 0, 0.0, 0.0, time_system=bh.GPS)\\n    print(gps_time)\\n    # Output: 2024-01-01 12:00:00.000 GPS\\n\\n    # Perform arithmetic operations\\n    epoch2 = epc1 + 3600.0  # Add one hour (in seconds)\\n    diff = epoch2 - epc1     # Difference in seconds\\n    print(f\"Time difference: {diff} seconds\")\\n    # Output: Time difference: 3600.0 seconds\\n\\n    # Legacy constructors still available\\n    epc4 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\\n    epc5 = bh.Epoch.from_jd(2460310.0, bh.UTC)\\n    ```'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.time_system","title":"time_system  <code>property</code>","text":"<pre><code>time_system: TimeSystem\n</code></pre> <p>Time system of the epoch.</p> <p>Returns:</p> Name Type Description <code>TimeSystem</code> <code>TimeSystem</code> <p>The time system used by this epoch</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__add__","title":"__add__  <code>method descriptor</code>","text":"<pre><code>__add__(value)\n</code></pre> <p>Return self+value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__eq__","title":"__eq__  <code>method descriptor</code>","text":"<pre><code>__eq__(value)\n</code></pre> <p>Return self==value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ge__","title":"__ge__  <code>method descriptor</code>","text":"<pre><code>__ge__(value)\n</code></pre> <p>Return self&gt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__gt__","title":"__gt__  <code>method descriptor</code>","text":"<pre><code>__gt__(value)\n</code></pre> <p>Return self&gt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__iadd__","title":"__iadd__  <code>method descriptor</code>","text":"<pre><code>__iadd__(value)\n</code></pre> <p>Return self+=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__isub__","title":"__isub__  <code>method descriptor</code>","text":"<pre><code>__isub__(value)\n</code></pre> <p>Return self-=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__le__","title":"__le__  <code>method descriptor</code>","text":"<pre><code>__le__(value)\n</code></pre> <p>Return self&lt;=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__lt__","title":"__lt__  <code>method descriptor</code>","text":"<pre><code>__lt__(value)\n</code></pre> <p>Return self&lt;value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__ne__","title":"__ne__  <code>method descriptor</code>","text":"<pre><code>__ne__(value)\n</code></pre> <p>Return self!=value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__radd__","title":"__radd__  <code>method descriptor</code>","text":"<pre><code>__radd__(value)\n</code></pre> <p>Return value+self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__rsub__","title":"__rsub__  <code>method descriptor</code>","text":"<pre><code>__rsub__(value)\n</code></pre> <p>Return value-self.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.__sub__","title":"__sub__  <code>method descriptor</code>","text":"<pre><code>__sub__(value)\n</code></pre> <p>Return self-value.</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day","title":"day  <code>method descriptor</code>","text":"<pre><code>day() -&gt; int\n</code></pre> <p>Returns the day component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The day of the month as an integer from 1 to 31</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year","title":"day_of_year  <code>method descriptor</code>","text":"<pre><code>day_of_year() -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the epoch's time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, \"UTC\") doy = epoch.day_of_year() print(f\"Day of year: {doy}\") Day of year: 100.5</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.day_of_year_as_time_system","title":"day_of_year_as_time_system  <code>method descriptor</code>","text":"<pre><code>day_of_year_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Returns the day of year as a floating-point number in the specified time system.</p> <p>The day of year is computed such that January 1st at midnight is 1.0, January 1st at noon is 1.5, January 2nd at midnight is 2.0, etc.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>The time system to use for the calculation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The day of year as a floating-point number (1.0 to 366.999...)</p> Example <p>epoch = brahe.Epoch.from_datetime(2023, 4, 10, 12, 0, 0.0, 0.0, brahe.TimeSystem.UTC) doy_tai = epoch.day_of_year_as_time_system(brahe.TimeSystem.TAI) print(f\"Day of year in TAI: {doy_tai}\") Day of year in TAI: 100.50042824074075</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_date","title":"from_date  <code>builtin</code>","text":"<pre><code>from_date(year: int, month: int, day: int, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a calendar date at midnight.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing midnight on the specified date</p> Example <pre><code>import brahe as bh\n\n# Create an epoch at midnight on January 1, 2024 UTC\nepc = bh.Epoch.from_date(2024, 1, 1, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T00:00:00.000000000 UTC\n\n# Create epoch in different time system\nepc_tai = bh.Epoch.from_date(2024, 6, 15, bh.TimeSystem.TAI)\nprint(epc_tai)\n# Output: 2024-06-15T00:00:00.000000000 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_datetime","title":"from_datetime  <code>builtin</code>","text":"<pre><code>from_datetime(year: int, month: int, day: int, hour: int, minute: int, second: float, nanosecond: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a complete Gregorian calendar date and time.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>month</code> <code>int</code> <p>Month (1-12)</p> required <code>day</code> <code>int</code> <p>Day of month (1-31)</p> required <code>hour</code> <code>int</code> <p>Hour (0-23)</p> required <code>minute</code> <code>int</code> <p>Minute (0-59)</p> required <code>second</code> <code>float</code> <p>Second with fractional part</p> required <code>nanosecond</code> <code>float</code> <p>Nanosecond component</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified date and time</p> Example <pre><code>import brahe as bh\n\n# Create epoch for January 1, 2024 at 12:30:45.5 UTC\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-01-01T12:30:45.500000000 UTC\n\n# With nanosecond precision\nepc_ns = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 0.0, 123456789.0, bh.TimeSystem.TAI)\nprint(epc_ns)\n# Output: 2024-06-15T14:30:00.123456789 TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_day_of_year","title":"from_day_of_year  <code>builtin</code>","text":"<pre><code>from_day_of_year(year: int, day_of_year: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a year and floating-point day-of-year.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>Gregorian calendar year</p> required <code>day_of_year</code> <code>float</code> <p>Day of year as a floating-point number (1.0 = January 1st, 1.5 = January 1st noon, etc.)</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the specified day of year</p> Example <pre><code>import brahe as bh\n\n# Create epoch for day 100 of 2024 at midnight\nepc = bh.Epoch.from_day_of_year(2024, 100.0, bh.TimeSystem.UTC)\nprint(epc)\n# Output: 2024-04-09T00:00:00.000000000 UTC\n\n# Create epoch for day 100.5 (noon on day 100)\nepc_noon = bh.Epoch.from_day_of_year(2024, 100.5, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc_noon.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-04-09 12:00:00.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_date","title":"from_gps_date  <code>builtin</code>","text":"<pre><code>from_gps_date(week: int, seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS week and seconds.</p> <p>Parameters:</p> Name Type Description Default <code>week</code> <code>int</code> <p>GPS week number since GPS epoch (January 6, 1980)</p> required <code>seconds</code> <code>float</code> <p>Seconds into the GPS week</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS week 2200, day 3, noon\nweek = 2200\nseconds = 3 * 86400 + 12 * 3600  # 3 days + 12 hours\nepc = bh.Epoch.from_gps_date(week, seconds)\nprint(epc)\n\n# Verify GPS week extraction\nweek_out, sec_out = epc.gps_date()\nprint(f\"GPS Week: {week_out}, Seconds: {sec_out}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_nanoseconds","title":"from_gps_nanoseconds  <code>builtin</code>","text":"<pre><code>from_gps_nanoseconds(gps_nanoseconds: int) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS nanoseconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_nanoseconds</code> <code>int</code> <p>Nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS nanoseconds with high precision\ngps_ns = 1234567890123456789\nepc = bh.Epoch.from_gps_nanoseconds(gps_ns)\nprint(f\"Epoch: {epc}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_gps_seconds","title":"from_gps_seconds  <code>builtin</code>","text":"<pre><code>from_gps_seconds(gps_seconds: float) -&gt; Epoch\n</code></pre> <p>Create an Epoch from GPS seconds since the GPS epoch.</p> <p>Parameters:</p> Name Type Description Default <code>gps_seconds</code> <code>float</code> <p>Seconds since GPS epoch (January 6, 1980, 00:00:00 UTC)</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch in GPS time system</p> Example <pre><code>import brahe as bh\n\n# Create epoch from GPS seconds\ngps_seconds = 1234567890.5\nepc = bh.Epoch.from_gps_seconds(gps_seconds)\nprint(f\"Epoch: {epc}\")\nprint(f\"GPS seconds: {epc.gps_seconds()}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_jd","title":"from_jd  <code>builtin</code>","text":"<pre><code>from_jd(jd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>jd</code> <code>float</code> <p>Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Julian Date\njd = 2460000.0\nepc = bh.Epoch.from_jd(jd, bh.TimeSystem.UTC)\nprint(epc)\n\n# Verify round-trip conversion\njd_out = epc.jd()\nprint(f\"JD: {jd_out:.10f}\")\n# Output: JD: 2460000.0000000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_mjd","title":"from_mjd  <code>builtin</code>","text":"<pre><code>from_mjd(mjd: float, time_system: TimeSystem) -&gt; Epoch\n</code></pre> <p>Create an Epoch from a Modified Julian Date.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Modified Julian date</p> required <code>time_system</code> <code>TimeSystem</code> <p>Time system</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the Modified Julian date</p> Example <pre><code>import brahe as bh\n\n# Create epoch from Modified Julian Date\nmjd = 60000.0\nepc = bh.Epoch.from_mjd(mjd, bh.TimeSystem.UTC)\nprint(epc)\n\n# MJD is commonly used in astronomy\nmjd_j2000 = 51544.0  # J2000 epoch\nepc_j2000 = bh.Epoch.from_mjd(mjd_j2000, bh.TimeSystem.TT)\nprint(f\"J2000: {epc_j2000}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.from_string","title":"from_string  <code>builtin</code>","text":"<pre><code>from_string(datestr: str) -&gt; Epoch\n</code></pre> <p>Create an Epoch from an ISO 8601 formatted string.</p> <p>Parameters:</p> Name Type Description Default <code>datestr</code> <code>str</code> <p>ISO 8601 formatted date string (e.g., \"2024-01-01T12:00:00.000000000 UTC\")</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the parsed date and time</p> Example <pre><code>import brahe as bh\n\n# Parse ISO 8601 string with full precision\nepc = bh.Epoch.from_string(\"2024-01-01T12:00:00.000000000 UTC\")\nprint(epc)\n# Output: 2024-01-01T12:00:00.000000000 UTC\n\n# Parse different time systems\nepc_tai = bh.Epoch.from_string(\"2024-06-15T14:30:45.123456789 TAI\")\nprint(epc_tai.time_system)\n# Output: TimeSystem.TAI\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gast","title":"gast  <code>method descriptor</code>","text":"<pre><code>gast(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Apparent Sidereal Time (GAST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GAST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngast_rad = epc.gast(bh.AngleFormat.RADIANS)\ngast_deg = epc.gast(bh.AngleFormat.DEGREES)\nprint(f\"GAST: {gast_rad:.6f} rad = {gast_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gmst","title":"gmst  <code>method descriptor</code>","text":"<pre><code>gmst(angle_format: AngleFormat) -&gt; float\n</code></pre> <p>Get the Greenwich Mean Sidereal Time (GMST) for this epoch.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Format for the returned angle (radians or degrees)</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GMST angle</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\ngmst_rad = epc.gmst(bh.AngleFormat.RADIANS)\ngmst_deg = epc.gmst(bh.AngleFormat.DEGREES)\nprint(f\"GMST: {gmst_rad:.6f} rad = {gmst_deg:.6f} deg\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_date","title":"gps_date  <code>method descriptor</code>","text":"<pre><code>gps_date() -&gt; Tuple\n</code></pre> <p>Get the GPS week number and seconds into the week.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (week, seconds_into_week)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.GPS)\nweek, seconds = epc.gps_date()\nprint(f\"GPS Week: {week}, Seconds: {seconds:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_nanoseconds","title":"gps_nanoseconds  <code>method descriptor</code>","text":"<pre><code>gps_nanoseconds() -&gt; float\n</code></pre> <p>Get the nanoseconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS nanoseconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 123456789.0, bh.TimeSystem.GPS)\ngps_ns = epc.gps_nanoseconds()\nprint(f\"GPS nanoseconds: {gps_ns:.0f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.gps_seconds","title":"gps_seconds  <code>method descriptor</code>","text":"<pre><code>gps_seconds() -&gt; float\n</code></pre> <p>Get the seconds since GPS epoch (January 6, 1980, 00:00:00 UTC).</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>GPS seconds</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.GPS)\ngps_sec = epc.gps_seconds()\nprint(f\"GPS seconds: {gps_sec:.3f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.hour","title":"hour  <code>method descriptor</code>","text":"<pre><code>hour() -&gt; int\n</code></pre> <p>Returns the hour component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The hour as an integer from 0 to 23</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring","title":"isostring  <code>method descriptor</code>","text":"<pre><code>isostring() -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string with full nanosecond precision</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso = epc.isostring()\nprint(iso)\n# Output: 2024-01-01T12:30:45.123456789Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.isostring_with_decimals","title":"isostring_with_decimals  <code>method descriptor</code>","text":"<pre><code>isostring_with_decimals(decimals: int) -&gt; str\n</code></pre> <p>Convert the epoch to an ISO 8601 formatted string with specified decimal precision.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimal places for the seconds field</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>ISO 8601 formatted date string</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 30, 45.123456789, 0.0, bh.TimeSystem.UTC)\niso3 = epc.isostring_with_decimals(3)\niso6 = epc.isostring_with_decimals(6)\nprint(iso3)  # Output: 2024-01-01T12:30:45.123Z\nprint(iso6)  # Output: 2024-01-01T12:30:45.123457Z\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd","title":"jd  <code>method descriptor</code>","text":"<pre><code>jd() -&gt; float\n</code></pre> <p>Get the Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd = epc.jd()\nprint(f\"JD: {jd:.6f}\")\n# Output: JD: 2460310.500000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.jd_as_time_system","title":"jd_as_time_system  <code>method descriptor</code>","text":"<pre><code>jd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\njd_utc = epc.jd()\njd_tai = epc.jd_as_time_system(bh.TimeSystem.TAI)\nprint(f\"JD UTC: {jd_utc:.10f}\")\nprint(f\"JD TAI: {jd_tai:.10f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.minute","title":"minute  <code>method descriptor</code>","text":"<pre><code>minute() -&gt; int\n</code></pre> <p>Returns the minute component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The minute as an integer from 0 to 59</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd","title":"mjd  <code>method descriptor</code>","text":"<pre><code>mjd() -&gt; float\n</code></pre> <p>Get the Modified Julian Date in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd = epc.mjd()\nprint(f\"MJD: {mjd:.6f}\")\n# Output: MJD: 60310.000000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.mjd_as_time_system","title":"mjd_as_time_system  <code>method descriptor</code>","text":"<pre><code>mjd_as_time_system(time_system: TimeSystem) -&gt; float\n</code></pre> <p>Get the Modified Julian Date in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Modified Julian date in the specified time system</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nmjd_utc = epc.mjd()\nmjd_gps = epc.mjd_as_time_system(bh.TimeSystem.GPS)\nprint(f\"MJD UTC: {mjd_utc:.6f}\")\nprint(f\"MJD GPS: {mjd_gps:.6f}\")\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.month","title":"month  <code>method descriptor</code>","text":"<pre><code>month() -&gt; int\n</code></pre> <p>Returns the month component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The month as an integer from 1 to 12</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.nanosecond","title":"nanosecond  <code>method descriptor</code>","text":"<pre><code>nanosecond() -&gt; float\n</code></pre> <p>Returns the nanosecond component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The nanosecond component as a floating-point number</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.now","title":"now  <code>builtin</code>","text":"<pre><code>now() -&gt; Epoch\n</code></pre> <p>Create an Epoch representing the current UTC instant.</p> <p>This method uses the system clock to get the current time and creates an Epoch in the UTC time system.</p> <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>The epoch representing the current instant in time in UTC</p> Example <pre><code>import brahe as bh\n\n# Get current time as an Epoch\nnow = bh.Epoch.now()\nprint(f\"Current time: {now}\")\nprint(f\"Time system: {now.time_system}\")\n# Output: Time system: TimeSystem.UTC\n\n# Use in orbital calculations\nimport numpy as np\ncurrent_epoch = bh.Epoch.now()\noe = np.array([bh.R_EARTH + 500e3, 0.01, np.radians(97.8), 0.0, 0.0, 0.0])\nstate = bh.state_osculating_to_cartesian(oe, bh.AngleFormat.RADIANS)\npropagator = bh.KeplerianPropagator.from_eci(current_epoch, state, 60.0)\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.second","title":"second  <code>method descriptor</code>","text":"<pre><code>second() -&gt; float\n</code></pre> <p>Returns the second component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The second as a floating-point number from 0.0 to 59.999...</p>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime","title":"to_datetime  <code>method descriptor</code>","text":"<pre><code>to_datetime() -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 6, 15, 14, 30, 45.5, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime()\nprint(f\"{year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: 2024-06-15 14:30:45.500\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_datetime_as_time_system","title":"to_datetime_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_datetime_as_time_system(time_system: TimeSystem) -&gt; Tuple\n</code></pre> <p>Convert the epoch to Gregorian calendar date and time in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>A tuple containing (year, month, day, hour, minute, second, nanosecond)</p> Example <pre><code>import brahe as bh\n\n# Create epoch in UTC and convert to TAI\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nyear, month, day, hour, minute, second, ns = epc.to_datetime_as_time_system(bh.TimeSystem.TAI)\nprint(f\"TAI: {year}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:06.3f}\")\n# Output: TAI: 2024-01-01 12:00:37.000\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.to_string_as_time_system","title":"to_string_as_time_system  <code>method descriptor</code>","text":"<pre><code>to_string_as_time_system(time_system: TimeSystem) -&gt; str\n</code></pre> <p>Convert the epoch to a string representation in a specified time system.</p> <p>Parameters:</p> Name Type Description Default <code>time_system</code> <code>TimeSystem</code> <p>Target time system for the conversion</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the epoch</p> Example <pre><code>import brahe as bh\n\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nprint(epc.to_string_as_time_system(bh.TimeSystem.UTC))\nprint(epc.to_string_as_time_system(bh.TimeSystem.TAI))\n# Shows same instant in different time systems\n</code></pre>"},{"location":"library_api/time/epoch.html#brahe._brahe.Epoch.year","title":"year  <code>method descriptor</code>","text":"<pre><code>year() -&gt; int\n</code></pre> <p>Returns the year component of the epoch in the epoch's time system.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The year as a 4-digit integer</p>"},{"location":"library_api/trajectories/index.html","title":"Trajectories","text":"<p>Module: <code>brahe.trajectories</code></p> <p>Trajectory containers for storing, managing, and interpolating time-series state data.</p>"},{"location":"library_api/trajectories/index.html#overview","title":"Overview","text":"<p>Brahe provides several trajectory container types for storing sequences of states (positions, velocities, or other data) over time with automatic interpolation capabilities.</p>"},{"location":"library_api/trajectories/index.html#trajectory-types","title":"Trajectory Types","text":""},{"location":"library_api/trajectories/index.html#dtrajectory","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container where dimension is set at runtime. Flexible for storing any N-dimensional state data.</p>"},{"location":"library_api/trajectories/index.html#strajectory6","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state vectors [x, y, z, vx, vy, vz]. Faster than DTrajectory for fixed-size data.</p>"},{"location":"library_api/trajectories/index.html#orbittrajectory","title":"OrbitTrajectory","text":"<p>Specialized orbital trajectory with frame-aware storage and automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/index.html#key-features","title":"Key Features","text":"<ul> <li>Time-ordered storage: States automatically sorted by epoch</li> <li>Interpolation: Linear or Lagrange interpolation between states</li> <li>Eviction policies: Automatic state removal based on age or count</li> <li>Query methods: Get states before/after/at specific times</li> <li>Batch operations: Add and query multiple states efficiently</li> </ul>"},{"location":"library_api/trajectories/index.html#quick-comparison","title":"Quick Comparison","text":"Feature DTrajectory STrajectory6 OrbitTrajectory Dimension Runtime (any N) Compile-time (6) Compile-time (6) Performance Good Better Better Use Case General data Orbital states Frame-aware orbits Frames Not frame-aware Not frame-aware ECI/ECEF support"},{"location":"library_api/trajectories/index.html#usage-example","title":"Usage Example","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create epoch\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\n\n# Option 1: Dynamic trajectory (any dimension)\ntraj_dyn = bh.DTrajectory(dimension=6)\n\n# Option 2: Static 6D trajectory (faster for orbital states)\ntraj_static = bh.STrajectory6()\n\n# Option 3: Orbit trajectory (frame-aware)\ntraj_orbit = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Add states\nstate = np.array([7000000.0, 0.0, 0.0, 0.0, 7500.0, 0.0])  # [x,y,z,vx,vy,vz]\ntraj_static.add(epoch, state)\n\n# Propagate orbit and store trajectory\nprop = bh.KeplerianPropagator(...)\ntimes = np.linspace(0, 86400, 100)\nfor dt in times:\n    future_epoch = epoch + dt\n    state = prop.propagate(future_epoch)\n    traj_static.add(future_epoch, state)\n\n# Query with interpolation\nquery_epoch = epoch + 43200.0  # 12 hours later\ninterpolated_state = traj_static.interpolate(query_epoch)\n</code></pre>"},{"location":"library_api/trajectories/index.html#see-also","title":"See Also","text":"<ul> <li>InterpolationMethod - Interpolation options</li> <li>OrbitFrame - Frame specifications</li> <li>KeplerianPropagator - Analytical orbit propagation</li> <li>SGPPropagator - SGP4/SDP4 orbit propagation</li> </ul>"},{"location":"library_api/trajectories/dtrajectory.html","title":"DTrajectory","text":"<p>Dynamic-dimension trajectory container for N-dimensional state data.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory","title":"DTrajectory","text":"<pre><code>DTrajectory()\n</code></pre> <p>Dynamic-dimension trajectory container.</p> <p>Stores a sequence of N-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is determined at runtime.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Dynamic-dimension trajectory container.\\n\\nStores a sequence of N-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is\\ndetermined at runtime.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>N-element state vector where N is the trajectory dimension</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get the trajectory dimension (method form).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Any\n</code></pre> <p>Get end epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; DTrajectory\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>2D array of states with shape (num_epochs, dimension) where each row is a state vector</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nmethod = bh.InterpolationMethod.LINEAR\ntraj.set_interpolation_method(method)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Any\n</code></pre> <p>Get start epoch of trajectory</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; Any\n</code></pre> <p>Get time span of trajectory in seconds</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; DTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#brahe.DTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; DTrajectory\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>DTrajectory</code> <code>DTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#overview","title":"Overview","text":"<p><code>DTrajectory</code> is a flexible trajectory container where the state dimension is determined at runtime. Use this when you need to store state vectors of varying sizes or when the dimension isn't known at compile time.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Runtime dimension specification - Automatic time-ordering of states - Configurable interpolation (Linear or Lagrange) - Eviction policies for memory management - Efficient state queries and interpolation</p>"},{"location":"library_api/trajectories/dtrajectory.html#creating-a-trajectory","title":"Creating a Trajectory","text":"<pre><code>import brahe as bh\n\n# Create with specified dimension\ntraj = bh.DTrajectory(dimension=6)  # For orbital states\n\n# Create with specific interpolation method\ntraj = bh.DTrajectory(\n    dimension=3,\n    interpolation_method=bh.InterpolationMethod.LAGRANGE\n)\n\n# Create from existing data\nimport numpy as np\nepochs = [epoch1, epoch2, epoch3]\nstates = np.array([[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]])\ntraj = bh.DTrajectory.from_data(\n    epochs,\n    states,\n    interpolation_method=bh.InterpolationMethod.LINEAR\n)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#adding-states","title":"Adding States","text":"<pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(dimension=6)\n\n# Add single state\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([7e6, 0, 0, 0, 7.5e3, 0])\ntraj.add(epoch, state)\n\n# Add multiple states from propagation\nprop = bh.KeplerianPropagator(...)\nfor i in range(100):\n    future_epoch = epoch + i * 60.0  # Every minute\n    state = prop.propagate(future_epoch)\n    traj.add(future_epoch, state)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#querying-states","title":"Querying States","text":"<pre><code># Interpolate at specific epoch\nquery_epoch = epoch + 1800.0  # 30 minutes later\ninterp_state = traj.interpolate(query_epoch)\n\n# Get state at specific index\nstate_10 = traj.state(10)\nepoch_10 = traj.epoch(10)\n\n# Get first and last states\nfirst_epoch, first_state = traj.first()\nlast_epoch, last_state = traj.last()\n\n# Get state before/after epoch\nbefore_epoch, before_state = traj.state_before_epoch(query_epoch)\nafter_epoch, after_state = traj.state_after_epoch(query_epoch)\n\n# Get all data\nall_states = traj.to_matrix()  # Returns numpy array (n_states, dimension)\nall_epochs = traj.to_epochs()  # Returns list of Epochs\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#eviction-policies","title":"Eviction Policies","text":"<p>Control memory usage by automatically removing old states:</p> <pre><code># Maximum age: keep only states within 1 hour of newest\ntraj.set_eviction_policy_max_age(3600.0)\n\n# Maximum size: keep only last 1000 states\ntraj.set_eviction_policy_max_size(1000)\n\n# No eviction (default)\ntraj.set_eviction_policy_no_eviction()\n\n# Builder pattern (method chaining)\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_eviction_policy_max_age(3600.0) \\\n    .with_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#interpolation-methods","title":"Interpolation Methods","text":"<pre><code># Linear interpolation (faster, less accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n\n# Lagrange interpolation (slower, more accurate)\ntraj.set_interpolation_method(bh.InterpolationMethod.LAGRANGE)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#trajectory-information","title":"Trajectory Information","text":"<pre><code># Get dimension\ndim = traj.dimension()  # Returns dimension of state vectors\n\n# Get size\nn_states = traj.len()  # Number of states stored\n\n# Check if empty\nis_empty = traj.is_empty()\n\n# Get time span\nspan = traj.timespan()  # Duration in seconds from first to last\n\n# Get start/end epochs\nstart = traj.start_epoch()\nend = traj.end_epoch()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#clearing-and-removing-states","title":"Clearing and Removing States","text":"<pre><code># Clear all states\ntraj.clear()\n\n# Remove state at specific epoch\nremoved_state = traj.remove_epoch(epoch)\n\n# Remove state at index\nremoved_epoch, removed_state = traj.remove_at(index)\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#complete-example","title":"Complete Example","text":"<pre><code>import brahe as bh\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Set up propagator\nepoch_start = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch_start,\n    elements=elements,\n    element_type=bh.OrbitRepresentation.MEAN_ELEMENTS,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Create trajectory with eviction policy\ntraj = bh.DTrajectory(dimension=6) \\\n    .with_interpolation_method(bh.InterpolationMethod.LINEAR) \\\n    .with_eviction_policy_max_size(1000)\n\n# Propagate and store states\ntimes = np.linspace(0, 86400, 1440)  # 1 day, 1-minute steps\nfor dt in times:\n    epoch = epoch_start + dt\n    state = prop.propagate(epoch)\n    traj.add(epoch, state)\n\nprint(f\"Stored {traj.len()} states\")\nprint(f\"Time span: {traj.timespan()/3600:.1f} hours\")\n\n# Interpolate at arbitrary times\nquery_times = np.linspace(0, 86400, 100)\naltitudes = []\nfor dt in query_times:\n    query_epoch = epoch_start + dt\n    state = traj.interpolate(query_epoch)\n    altitude = (np.linalg.norm(state[:3]) - bh.R_EARTH) / 1000  # km\n    altitudes.append(altitude)\n\n# Plot altitude profile\nplt.plot(query_times/3600, altitudes)\nplt.xlabel('Time (hours)')\nplt.ylabel('Altitude (km)')\nplt.title('Orbit Altitude Over 1 Day')\nplt.grid(True)\nplt.show()\n</code></pre>"},{"location":"library_api/trajectories/dtrajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Fixed 6D trajectory (faster)</li> <li>OrbitTrajectory - Frame-aware orbital trajectory</li> <li>InterpolationMethod</li> </ul>"},{"location":"library_api/trajectories/orbit_trajectory.html","title":"OrbitTrajectory","text":"<p>Frame-aware orbital trajectory with automatic coordinate transformations.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory","title":"OrbitTrajectory","text":"<pre><code>OrbitTrajectory()\n</code></pre> <p>Orbital trajectory with frame and representation awareness.</p> <p>Stores a sequence of orbital states at specific epochs with support for interpolation, frame conversions, and representation transformations.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Orbital trajectory with frame and representation awareness.\\n\\nStores a sequence of orbital states at specific epochs with support for\\ninterpolation, frame conversions, and representation transformations.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.angle_format","title":"angle_format  <code>property</code>","text":"<pre><code>angle_format: AngleFormat\n</code></pre> <p>Get trajectory angle format for Keplerian states.</p> <p>Returns:</p> Type Description <code>AngleFormat</code> <p>AngleFormat or None: Angle format for Keplerian representation, None for Cartesian</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Angle format: {traj.angle_format}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.frame","title":"frame  <code>property</code>","text":"<pre><code>frame: OrbitFrame\n</code></pre> <p>Get trajectory reference frame.</p> <p>Returns:</p> Name Type Description <code>OrbitFrame</code> <code>OrbitFrame</code> <p>Reference frame of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Frame: {traj.frame}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.representation","title":"representation  <code>property</code>","text":"<pre><code>representation: OrbitRepresentation\n</code></pre> <p>Get trajectory state representation.</p> <p>Returns:</p> Name Type Description <code>OrbitRepresentation</code> <code>OrbitRepresentation</code> <p>State representation format of the trajectory</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Representation: {traj.representation}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.clear()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.default","title":"default  <code>builtin</code>","text":"<pre><code>default() -&gt; OrbitTrajectory\n</code></pre> <p>Create a default empty orbital trajectory (ECI Cartesian).</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory with ECI frame and Cartesian representation</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6 for orbital trajectories).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Dimension: {traj.dimension()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.end_epoch","title":"end_epoch  <code>method descriptor</code>","text":"<pre><code>end_epoch() -&gt; Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"End epoch: {traj.end_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get the epoch at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch to retrieve</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get epoch at index\nepoch_0 = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.epochs","title":"epochs  <code>method descriptor</code>","text":"<pre><code>epochs() -&gt; ndarray\n</code></pre> <p>Get all epochs as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 1D array of Julian dates for all epochs</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nepochs_array = traj.epochs()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.from_orbital_data","title":"from_orbital_data  <code>builtin</code>","text":"<pre><code>from_orbital_data(epochs: list[Epoch], states: ndarray, frame: OrbitFrame, representation: OrbitRepresentation, angle_format: AngleFormat or None = None) -&gt; OrbitTrajectory\n</code></pre> <p>Create orbital trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs for each state</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6-element state vectors with total length N*6 where N is the number of epochs</p> required <code>frame</code> <code>OrbitFrame</code> <p>Reference frame for the states</p> required <code>representation</code> <code>OrbitRepresentation</code> <p>State representation format</p> required <code>angle_format</code> <code>AngleFormat or None</code> <p>Angle format for Keplerian states, must be None for Cartesian representation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>New trajectory instance populated with data</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.get_interpolation_method","title":"get_interpolation_method  <code>method descriptor</code>","text":"<pre><code>get_interpolation_method() -&gt; InterpolationMethod\n</code></pre> <p>Get the current interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nmethod = traj.get_interpolation_method()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set eviction policy to keep states within maximum age.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set eviction policy to keep maximum number of states.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.start_epoch","title":"start_epoch  <code>method descriptor</code>","text":"<pre><code>start_epoch() -&gt; Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Start epoch: {traj.start_epoch()}\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state","title":"state  <code>method descriptor</code>","text":"<pre><code>state(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state at specified epoch (in native frame/representation).</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in trajectory's native frame and representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate1 = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc1, state1)\n\n# Query state at epoch\nstate = traj.state(epc1)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_as_osculating_elements","title":"state_as_osculating_elements  <code>method descriptor</code>","text":"<pre><code>state_as_osculating_elements(epoch: Epoch, angle_format: AngleFormat) -&gt; ndarray\n</code></pre> <p>Get state as osculating Keplerian elements at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <code>angle_format</code> <code>AngleFormat</code> <p>Desired angle format for output</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Osculating Keplerian elements [a, e, i, raan, argp, M]</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create Cartesian trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_cart = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_cart)\n\n# Get osculating elements in degrees\nelements = traj.state_as_osculating_elements(epc, bh.AngleFormat.DEGREES)\nprint(f\"Semi-major axis: {elements[0]/1000:.2f} km\")\nprint(f\"Inclination: {elements[2]:.2f} degrees\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get the state vector at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to retrieve</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at the specified index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state)\n\n# Get state at index\nstate_0 = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_ecef","title":"state_ecef  <code>method descriptor</code>","text":"<pre><code>state_ecef(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECEF Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECEF Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\nstate_eci = np.array([7000e3, 0.0, 0.0, 0.0, 7.5e3, 0.0])\ntraj.add(epc, state_eci)\n\n# Get ECEF state (automatically converted from ECI)\nstate_ecef = traj.state_ecef(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.state_eci","title":"state_eci  <code>method descriptor</code>","text":"<pre><code>state_eci(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Get state in ECI Cartesian frame at specified epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time for state query</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector in ECI Cartesian [x, y, z, vx, vy, vz] (meters, m/s)</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\n# Create trajectory in any frame/representation\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.KEPLERIAN, bh.AngleFormat.DEGREES)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.UTC)\noe = np.array([bh.R_EARTH + 500e3, 0.001, 98.0, 15.0, 30.0, 45.0])\ntraj.add(epc, oe)\n\n# Get ECI Cartesian state (automatically converted from Keplerian)\nstate_eci = traj.state_eci(epc)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.states","title":"states  <code>method descriptor</code>","text":"<pre><code>states() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array of states with shape (6, N) where N is the number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 60.0, state)\nstates_array = traj.states()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.timespan","title":"timespan  <code>method descriptor</code>","text":"<pre><code>timespan() -&gt; float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj.add(epc + 3600.0, state)\nprint(f\"Timespan: {traj.timespan()} seconds\")\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_ecef","title":"to_ecef  <code>method descriptor</code>","text":"<pre><code>to_ecef() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECEF (Earth-Centered Earth-Fixed) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECEF Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_ecef = traj.to_ecef()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_eci","title":"to_eci  <code>method descriptor</code>","text":"<pre><code>to_eci() -&gt; OrbitTrajectory\n</code></pre> <p>Convert to ECI (Earth-Centered Inertial) frame in Cartesian representation.</p> <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Cartesian frame</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECEF, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 0.0, 0.0])\ntraj.add(epc, state)\ntraj_eci = traj.to_eci()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_keplerian","title":"to_keplerian  <code>method descriptor</code>","text":"<pre><code>to_keplerian(angle_format: AngleFormat) -&gt; OrbitTrajectory\n</code></pre> <p>Convert to Keplerian representation in ECI frame.</p> <p>Parameters:</p> Name Type Description Default <code>angle_format</code> <code>AngleFormat</code> <p>Angle format for the result (Radians or Degrees)</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Trajectory in ECI Keplerian representation</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\ntraj_kep = traj.to_keplerian(bh.AngleFormat.RADIANS)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Convert trajectory to matrix representation.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: 2D array with shape (6, N) where N is number of states</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nmatrix = traj.to_matrix()\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_age(3600.0)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; OrbitTrajectory\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_eviction_policy_max_size(1000)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#brahe.OrbitTrajectory.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; OrbitTrajectory\n</code></pre> <p>Set interpolation method using builder pattern.</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>OrbitTrajectory</code> <code>OrbitTrajectory</code> <p>Self with updated interpolation method</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj = traj.with_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#overview","title":"Overview","text":"<p><code>OrbitTrajectory</code> is a specialized trajectory container for orbital mechanics that stores states in a specific reference frame (ECI or ECEF) and can automatically transform between frames when querying.</p> <p>Module: <code>brahe.trajectories</code></p> <p>Key Features: - Frame-aware storage (ECI or ECEF) - Automatic frame transformations on query - Built on STrajectory6 (6D states only) - Same performance as STrajectory6</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#creating-with-frame","title":"Creating with Frame","text":"<pre><code>import brahe as bh\n\n# ECI frame trajectory\ntraj_eci = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# ECEF frame trajectory\ntraj_ecef = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECEF)\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#example-usage","title":"Example Usage","text":"<pre><code>import brahe as bh\nimport numpy as np\n\n# Create ECI trajectory\ntraj = bh.OrbitTrajectory(frame=bh.OrbitFrame.ECI)\n\n# Propagate and store states in ECI\nepoch = bh.Epoch.from_datetime(2024, 1, 1, 0, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nelements = np.array([7000e3, 0.001, 98*bh.DEG2RAD, 0, 0, 0])\nprop = bh.KeplerianPropagator(\n    epoch=epoch,\n    elements=elements,\n    frame=bh.OrbitFrame.ECI\n)\n\n# Add states\nfor i in range(100):\n    t = epoch + i * 60.0\n    state_eci = prop.propagate(t)\n    traj.add(t, state_eci)\n\n# States are stored and retrieved in ECI\nquery_epoch = epoch + 1800.0\nstate = traj.interpolate(query_epoch)  # ECI frame\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#frame-information","title":"Frame Information","text":"<pre><code># Get trajectory frame\nframe = traj.frame()  # Returns OrbitFrame.ECI or OrbitFrame.ECEF\n</code></pre>"},{"location":"library_api/trajectories/orbit_trajectory.html#api","title":"API","text":"<p>OrbitTrajectory has the same API as STrajectory6 and DTrajectory, plus frame awareness.</p> <p>See STrajectory6 or DTrajectory for full API documentation.</p>"},{"location":"library_api/trajectories/orbit_trajectory.html#see-also","title":"See Also","text":"<ul> <li>STrajectory6 - Non-frame-aware 6D trajectory</li> <li>DTrajectory - Dynamic-dimension trajectory</li> <li>OrbitFrame - Frame specifications</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html","title":"STrajectory6","text":"<p>Static 6-dimensional trajectory optimized for orbital state storage.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6","title":"STrajectory6","text":"<pre><code>STrajectory6()\n</code></pre> <p>Static-dimension 6D trajectory container.</p> <p>Stores a sequence of 6-dimensional states at specific epochs with support for interpolation and automatic state eviction policies. Dimension is fixed at compile time for performance.</p> <p>Initialize instance.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__doc__","title":"__doc__  <code>class-attribute</code>","text":"<pre><code>__doc__ = 'Static-dimension 6D trajectory container.\\n\\nStores a sequence of 6-dimensional states at specific epochs with support\\nfor interpolation and automatic state eviction policies. Dimension is fixed\\nat compile time for performance.'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__module__","title":"__module__  <code>class-attribute</code>","text":"<pre><code>__module__ = 'brahe._brahe'\n</code></pre> <p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to 'utf-8'. errors defaults to 'strict'.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.end_epoch","title":"end_epoch  <code>property</code>","text":"<pre><code>end_epoch: Epoch\n</code></pre> <p>Get end epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: Last epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolation_method","title":"interpolation_method  <code>property</code>","text":"<pre><code>interpolation_method: InterpolationMethod\n</code></pre> <p>Get interpolation method.</p> <p>Returns:</p> Name Type Description <code>InterpolationMethod</code> <code>InterpolationMethod</code> <p>Current interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.length","title":"length  <code>property</code>","text":"<pre><code>length: int\n</code></pre> <p>Get the number of states in the trajectory.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Trajectory length: {traj.length}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.start_epoch","title":"start_epoch  <code>property</code>","text":"<pre><code>start_epoch: Epoch\n</code></pre> <p>Get start epoch of trajectory.</p> <p>Returns:</p> Type Description <code>Epoch</code> <p>Epoch or None: First epoch if trajectory is not empty, None otherwise</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.time_span","title":"time_span  <code>property</code>","text":"<pre><code>time_span: float\n</code></pre> <p>Get time span of trajectory in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>float or None: Time span between first and last epochs, or None if less than 2 states</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__getitem__","title":"__getitem__  <code>method descriptor</code>","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Return self[key].</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__iter__","title":"__iter__  <code>method descriptor</code>","text":"<pre><code>__iter__() -&gt; Any\n</code></pre> <p>Implement iter(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__len__","title":"__len__  <code>method descriptor</code>","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return len(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__new__","title":"__new__  <code>builtin</code>","text":"<pre><code>__new__(*args, **kwargs)\n</code></pre> <p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__repr__","title":"__repr__  <code>method descriptor</code>","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return repr(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.__str__","title":"__str__  <code>method descriptor</code>","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return str(self).</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.add","title":"add  <code>method descriptor</code>","text":"<pre><code>add(epoch: Epoch, state: ndarray) -&gt; Any\n</code></pre> <p>Add a state to the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Time of the state</p> required <code>state</code> <code>ndarray</code> <p>6-element state vector</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.clear","title":"clear  <code>method descriptor</code>","text":"<pre><code>clear() -&gt; Any\n</code></pre> <p>Clear all states from the trajectory.</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.dimension","title":"dimension  <code>method descriptor</code>","text":"<pre><code>dimension() -&gt; int\n</code></pre> <p>Get trajectory dimension (always 6).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Dimension of the trajectory (always 6)</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.epoch_at_idx","title":"epoch_at_idx  <code>method descriptor</code>","text":"<pre><code>epoch_at_idx(index: int) -&gt; Epoch\n</code></pre> <p>Get epoch at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the epoch</p> required <p>Returns:</p> Name Type Description <code>Epoch</code> <code>Epoch</code> <p>Epoch at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_epc = traj.epoch_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.first","title":"first  <code>method descriptor</code>","text":"<pre><code>first() -&gt; Tuple\n</code></pre> <p>Get the first (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for first state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nfirst_epc, first_state = traj.first()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.from_data","title":"from_data  <code>builtin</code>","text":"<pre><code>from_data(epochs: list[Epoch], states: ndarray, interpolation_method: InterpolationMethod = None) -&gt; STrajectory6\n</code></pre> <p>Create a trajectory from existing data.</p> <p>Parameters:</p> Name Type Description Default <code>epochs</code> <code>list[Epoch]</code> <p>List of time epochs</p> required <code>states</code> <code>ndarray</code> <p>Flattened 1D array of 6D state vectors with total length N*6 where N is the number of epochs</p> required <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method (default Linear)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>New 6D trajectory instance populated with data</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstates = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0,\n                   bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj = bh.STrajectory6.from_data([epc1, epc2], states)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get","title":"get  <code>method descriptor</code>","text":"<pre><code>get(index: int) -&gt; Tuple\n</code></pre> <p>Get both epoch and state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index to retrieve</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for epoch and state at the index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nret_epc, ret_state = traj.get(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.get_eviction_policy","title":"get_eviction_policy  <code>method descriptor</code>","text":"<pre><code>get_eviction_policy() -&gt; str\n</code></pre> <p>Get current eviction policy.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of eviction policy</p> Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\npolicy = traj.get_eviction_policy()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_after_epoch","title":"index_after_epoch  <code>method descriptor</code>","text":"<pre><code>index_after_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.index_before_epoch","title":"index_before_epoch  <code>method descriptor</code>","text":"<pre><code>index_before_epoch(epoch: Epoch) -&gt; int\n</code></pre> <p>Get the index of the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Index of the state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nindex = traj.index_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate","title":"interpolate  <code>method descriptor</code>","text":"<pre><code>interpolate(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using the configured interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.interpolate_linear","title":"interpolate_linear  <code>method descriptor</code>","text":"<pre><code>interpolate_linear(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Interpolate state at a given epoch using linear interpolation.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: Linearly interpolated state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate1 = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state1)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 2, 0.0, 0.0, bh.TimeSystem.UTC)\nstate2 = np.array([bh.R_EARTH + 510e3, 0.0, 0.0, 0.0, 7650.0, 0.0])\ntraj.add(epc2, state2)\nepc_mid = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nstate_interp = traj.interpolate_linear(epc_mid)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.is_empty","title":"is_empty  <code>method descriptor</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Check if trajectory is empty.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if trajectory contains no states, False otherwise</p> Example <pre><code>import brahe as bh\n\ntraj = bh.DTrajectory(6)\nprint(f\"Is empty: {traj.is_empty()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.last","title":"last  <code>method descriptor</code>","text":"<pre><code>last() -&gt; Tuple\n</code></pre> <p>Get the last (epoch, state) tuple in the trajectory, if any exists.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>tuple or None: Tuple of (Epoch, numpy.ndarray) for last state, or None if empty</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nlast_epc, last_state = traj.last()\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.len","title":"len  <code>method descriptor</code>","text":"<pre><code>len() -&gt; int\n</code></pre> <p>Get the number of states in the trajectory (alias for length).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of states in the trajectory</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nprint(f\"Number of states: {traj.len()}\")\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.nearest_state","title":"nearest_state  <code>method descriptor</code>","text":"<pre><code>nearest_state(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the nearest state to a given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing the nearest state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 30.0, 0.0, bh.TimeSystem.UTC)\nnearest_epc, nearest_state = traj.nearest_state(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove","title":"remove  <code>method descriptor</code>","text":"<pre><code>remove(index: int) -&gt; Tuple\n</code></pre> <p>Remove a state at a specific index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state to remove</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) for the removed epoch and state</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_epc, removed_state = traj.remove(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.remove_epoch","title":"remove_epoch  <code>method descriptor</code>","text":"<pre><code>remove_epoch(epoch: Epoch) -&gt; ndarray\n</code></pre> <p>Remove a state at a specific epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Epoch of the state to remove</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: The removed state vector</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nremoved_state = traj.remove_epoch(epc)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_age","title":"set_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_age(max_age: float) -&gt; Any\n</code></pre> <p>Set maximum age for trajectory states.</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age in seconds relative to most recent state</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_eviction_policy_max_size","title":"set_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>set_eviction_policy_max_size(max_size: int) -&gt; Any\n</code></pre> <p>Set maximum trajectory size.</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.set_interpolation_method","title":"set_interpolation_method  <code>method descriptor</code>","text":"<pre><code>set_interpolation_method(method: InterpolationMethod) -&gt; Any\n</code></pre> <p>Set the interpolation method for the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>InterpolationMethod</code> <p>New interpolation method</p> required Example <pre><code>import brahe as bh\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\ntraj.set_interpolation_method(bh.InterpolationMethod.LINEAR)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_after_epoch","title":"state_after_epoch  <code>method descriptor</code>","text":"<pre><code>state_after_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or after the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or after the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 11, 59, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_after_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_at_idx","title":"state_at_idx  <code>method descriptor</code>","text":"<pre><code>state_at_idx(index: int) -&gt; ndarray\n</code></pre> <p>Get state at a specific index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the state</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy.ndarray: State vector at index</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.DTrajectory(6)\nepc = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc, state)\nretrieved_state = traj.state_at_idx(0)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.state_before_epoch","title":"state_before_epoch  <code>method descriptor</code>","text":"<pre><code>state_before_epoch(epoch: Epoch) -&gt; Tuple\n</code></pre> <p>Get the state at or before the given epoch.</p> <p>Parameters:</p> Name Type Description Default <code>epoch</code> <code>Epoch</code> <p>Target epoch</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple</code> <p>Tuple of (Epoch, numpy.ndarray) containing state at or before the target epoch</p> Example <pre><code>import brahe as bh\nimport numpy as np\n\ntraj = bh.OrbitTrajectory(bh.OrbitFrame.ECI, bh.OrbitRepresentation.CARTESIAN, None)\nepc1 = bh.Epoch.from_datetime(2024, 1, 1, 12, 0, 0.0, 0.0, bh.TimeSystem.UTC)\nstate = np.array([bh.R_EARTH + 500e3, 0.0, 0.0, 0.0, 7600.0, 0.0])\ntraj.add(epc1, state)\nepc2 = bh.Epoch.from_datetime(2024, 1, 1, 12, 1, 0.0, 0.0, bh.TimeSystem.UTC)\nret_epc, ret_state = traj.state_before_epoch(epc2)\n</code></pre>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.to_matrix","title":"to_matrix  <code>method descriptor</code>","text":"<pre><code>to_matrix() -&gt; ndarray\n</code></pre> <p>Get all states as a numpy array</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_age","title":"with_eviction_policy_max_age  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_age(max_age: float) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep states within maximum age using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_age</code> <code>float</code> <p>Maximum age of states in seconds</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_eviction_policy_max_size","title":"with_eviction_policy_max_size  <code>method descriptor</code>","text":"<pre><code>with_eviction_policy_max_size(max_size: int) -&gt; STrajectory6\n</code></pre> <p>Set eviction policy to keep maximum number of states using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>max_size</code> <code>int</code> <p>Maximum number of states to retain</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated eviction policy</p>"},{"location":"library_api/trajectories/strajectory6.html#brahe.STrajectory6.with_interpolation_method","title":"with_interpolation_method  <code>method descriptor</code>","text":"<pre><code>with_interpolation_method(interpolation_method: InterpolationMethod) -&gt; STrajectory6\n</code></pre> <p>Set interpolation method using builder pattern</p> <p>Parameters:</p> Name Type Description Default <code>interpolation_method</code> <code>InterpolationMethod</code> <p>Interpolation method to use</p> required <p>Returns:</p> Name Type Description <code>STrajectory6</code> <code>STrajectory6</code> <p>Self with updated interpolation method</p>"},{"location":"library_api/trajectories/strajectory6.html#overview","title":"Overview","text":"<p><code>STrajectory6</code> provides compile-time optimized storage for 6-dimensional Cartesian states <code>[x, y, z, vx, vy, vz]</code>. It offers the best performance for standard orbital mechanics applications.</p>"},{"location":"library_api/trajectories/strajectory6.html#features","title":"Features","text":"<ul> <li>Fixed dimension: Always 6D (compile-time optimization)</li> <li>Lower memory overhead: More efficient than DTrajectory</li> <li>Fastest performance: Optimized for Cartesian orbital states</li> <li>Full interpolation: Supports linear, cubic, and Lagrange interpolation</li> <li>Eviction policies: Memory management via automatic state removal</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html#when-to-use","title":"When to Use","text":"<p>Use <code>STrajectory6</code> when:</p> <ul> <li>Storing standard Cartesian orbital states</li> <li>Performance is critical</li> <li>State dimension is always 6</li> <li>Not using orbit-specific features (use OrbitTrajectory for that)</li> </ul>"},{"location":"library_api/trajectories/strajectory6.html#see-also","title":"See Also","text":"<ul> <li>DTrajectory - Variable dimension trajectory</li> <li>OrbitTrajectory - Orbit-aware trajectory</li> <li>Trajectories Overview</li> </ul>"}]}